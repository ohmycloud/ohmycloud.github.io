{"author":{"name":null,"type":"card","url":"https://ohmycloud.github.io/"},"content":{"html":"\u003ch1 id=\"通过命令行获取参数httpsdocsrakuorglanguagesystem___top\"\u003e\u003ca href=\"https://docs.raku.org/language/system#___top\"\u003e通过命令行获取参数\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e最简单的方法是使用 \u003ca href=\"https://docs.raku.org/language/variables#%2524%252AARGS\"\u003e\u003ccode\u003e@*ARGS\u003c/code\u003e\u003c/a\u003e 变量从命令行获取参数;此数组将包含程序名称后面的字符串。 \u003ca href=\"https://docs.raku.org/language/variables#Runtime_environment\"\u003e\u003ccode\u003e%*ENV\u003c/code\u003e\u003c/a\u003e 将包含环境变量，因此如果您使用：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"n\"\u003eAPI_KEY\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e1967196417966160761\u003c/span\u003e\u003cspan class=\"n\"\u003efabc1511067\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e./\u003c/span\u003e\u003cspan class=\"n\"\u003econsume_api\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ep6\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e您可以通过以下方式在程序中使用它们：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$api-key\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"vg\"\u003e%*ENV\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003eAPI_KEY\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e//\u003c/span\u003e \u003cspan class=\"nb\"\u003edie\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eNeed the API key\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果先前未定义环境变量 \u003ccode\u003eAPI_KEY\u003c/code\u003e，则此操作将失败。\u003c/p\u003e\n\u003cp\u003eRaku 有一个更好的方法来处理命令行参数，如果它们代表文件名：那么使用 \u003ca href=\"https://docs.raku.org/language/variables#%2524%252AARGFILES\"\u003e\u003ccode\u003e$*ARGFILES\u003c/code\u003e\u003c/a\u003e 动态变量。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"vg\"\u003e$*ARGFILES\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003elines\u003c/span\u003e \u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$l\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eLong lines in \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"vg\"\u003e$*ARGFILES\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003epath\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nv\"\u003e$l\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003echars\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e72\u003c/span\u003e \u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e例如，你可以用 \u003ccode\u003eargf​​iles.p6 *.p6\u003c/code\u003e 的方式运行这个程序，每次找到一个超过72个字符的行时，它就会打印一个文件名。 \u003ccode\u003e$*ARGFILES\u003c/code\u003e 包含命令行中描述的所有文件的文件句柄 -  \u003ccode\u003e.lines\u003c/code\u003e 将依次读取每行文件的一行，每次处理新句柄时都会更改 \u003ccode\u003e$*ARGFILES.path\u003c/code\u003e 的值。通常，它为处理文件集的脚本提供了非常方便的 API。\u003c/p\u003e\n\u003ch1 id=\"以交互方式获取参数httpsdocsrakuorglanguagesystem___top\"\u003e\u003ca href=\"https://docs.raku.org/language/system#___top\"\u003e以交互方式获取参数\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e使用 \u003ccode\u003eprompt\u003c/code\u003e 让一个正在运行的程序向用户查询数据：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"kt\"\u003eUInt\u003c/span\u003e \u003cspan class=\"nv\"\u003e$num-iters\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eprompt\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eHow many iterations to run: \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"同步和异步运行程序httpsdocsrakuorglanguagesystem___top\"\u003e\u003ca href=\"https://docs.raku.org/language/system#___top\"\u003e同步和异步运行程序\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e运行外部程序有两个例程：\u003ca href=\"https://docs.raku.org/routine/run\"\u003e\u003ccode\u003erun\u003c/code\u003e\u003c/a\u003e 和 \u003ca href=\"https://docs.raku.org/routine/shell\"\u003e\u003ccode\u003eshell\u003c/code\u003e\u003c/a\u003e。两者都存在于 \u003ca href=\"https://docs.raku.org/type/IO\"\u003e\u003ccode\u003eIO\u003c/code\u003e\u003c/a\u003e 角色中，因此包含在混合该角色的所有类中，如 \u003ca href=\"https://docs.raku.org/type/IO::Path\"\u003eIO::Path\u003c/a\u003e。两者都返回一个 \u003ca href=\"https://docs.raku.org/type/Proc\"\u003eProc\u003c/a\u003e 对象，但主要区别在于 \u003ccode\u003erun\u003c/code\u003e 会尽可能避免系统 shell，而 \u003ccode\u003eshell\u003c/code\u003e 会通过默认系统 shell 运行命令。\u003c/p\u003e\n\u003cp\u003e运行所有外部程序的关键类是 \u003ca href=\"https://docs.raku.org/type/Proc::Async\"\u003eProc::Async\u003c/a\u003e，它以异步方式运行进程，并允许与正在运行的进程进行\u003ca href=\"https://docs.raku.org/language/concurrency#Proc%3A%3AAsync\"\u003e并发\u003c/a\u003e交互。通常，通过这些高级抽象接口与系统进行交互是一种很好的做法。但是，Raku 提供了通过低级接口与系统交互的其他方式。\u003c/p\u003e\n\u003ch1 id=\"通过原生-api-进行操作系统调用httpsdocsrakuorglanguagesystem___top\"\u003e\u003ca href=\"https://docs.raku.org/language/system#___top\"\u003e通过原生 API 进行操作系统调用\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://docs.raku.org/language/nativecall\"\u003e\u003ccode\u003eNativeCall\u003c/code\u003e\u003c/a\u003e 可用于与系统库以及任何其他可访问库进行交互。这个\u003ca href=\"(https://docs.raku.org/language/nativecall#Short_tutorial_on_calling_a_C_function)\"\u003e简短的教程\u003c/a\u003e解释了，例如，如何使用该接口调用系统函数，如 \u003ccode\u003egetaddrinfo\u003c/code\u003e;通过使用 NativeCall 接口的声明，也可以通过这种方式访问​​其他一些函数，例如 \u003ca href=\"https://docs.raku.org/language/5to6-perlfunc#kill\"\u003e\u003ccode\u003ekill\u003c/code\u003e\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e幸运的是，您不必为所有原生功能执行此操作。作为将 Perl 5 作为生态系统的一部分移植到 Raku 的蝴蝶项目的一部分，\u003ca href=\"https://github.com/lizmat\"\u003eElizabeth Mattijsen\u003c/a\u003e 正在将许多系统功能移植到 \u003ca href=\"https://github.com/lizmat/P5getprotobyname\"\u003e\u003ccode\u003eP5getprotobyname\u003c/code\u003e\u003c/a\u003e 等模块中，这些功能包括 \u003ccode\u003eendprotoent\u003c/code\u003e，\u003ccode\u003egetprotoent\u003c/code\u003e，\u003ccode\u003egetprotobyname\u003c/code\u003e 等功能。 \u003ccode\u003egetprotobynumber\u003c/code\u003e 和 \u003ccode\u003esetprotoent\u003c/code\u003e。如果要使用p6y形式的那些功能，请搜索并安装\u003ca href=\"https://modules.raku.org/search/?q=p5\"\u003eP5模块\u003c/a\u003e。\u003c/p\u003e\n","text":"通过命令行获取参数 最简单的方法是使用 @*ARGS 变量从命令行获取参数;此数组将包含程序名称后面的字符串。 %*ENV 将包含环境变量，因此如果您使用：\nexport API_KEY=1967196417966160761fabc1511067 ./consume_api.p6 您可以通过以下方式在程序中使用它们：\nmy $api-key = %*ENV\u0026lt;API_KEY\u0026gt; // die \u0026#34;Need the API key\u0026#34;; 如果先前未定义环境变量 API_KEY，则此操作将失败。\nRaku 有一个更好的方法来处理命令行参数，如果它们代表文件名：那么使用 $*ARGFILES 动态变量。\nfor $*ARGFILES.lines -\u0026gt; $l { say \u0026#34;Long lines in {$*ARGFILES.path}\u0026#34; if $l.chars \u0026gt; 72 ; } 例如，你可以用 argf​​iles.p6 *.p6 的方式运行这个程序，每次找到一个超过72个字符的行时，它就会打印一个文件名。 $*ARGFILES 包含命令行中描述的所有文件的文件句柄 - .lines 将依次读取每行文件的一行，每次处理新句柄时都会更改 $*ARGFILES.path 的值。通常，它为处理文件集的脚本提供了非常方便的 API。\n以交互方式获取参数 使用 prompt 让一个正在运行的程序向用户查询数据：\nmy UInt $num-iters = prompt \u0026#34;How many iterations to run: \u0026#34;; 同步和异步运行程序 运行外部程序有两个例程：run 和 shell。两者都存在于 IO 角色中，因此包含在混合该角色的所有类中，如 IO::Path。两者都返回一个 Proc 对象，但主要区别在于 run 会尽可能避免系统 shell，而 shell 会通过默认系统 shell 运行命令。\n运行所有外部程序的关键类是 Proc::Async，它以异步方式运行进程，并允许与正在运行的进程进行并发交互。通常，通过这些高级抽象接口与系统进行交互是一种很好的做法。但是，Raku 提供了通过低级接口与系统交互的其他方式。\n通过原生 API 进行操作系统调用 NativeCall 可用于与系统库以及任何其他可访问库进行交互。这个简短的教程解释了，例如，如何使用该接口调用系统函数，如 getaddrinfo;通过使用 NativeCall 接口的声明，也可以通过这种方式访问​​其他一些函数，例如 kill。\n幸运的是，您不必为所有原生功能执行此操作。作为将 Perl 5 作为生态系统的一部分移植到 Raku 的蝴蝶项目的一部分，Elizabeth Mattijsen 正在将许多系统功能移植到 P5getprotobyname 等模块中，这些功能包括 endprotoent，getprotoent，getprotobyname 等功能。 getprotobynumber 和 setprotoent。如果要使用p6y形式的那些功能，请搜索并安装P5模块。\n"},"name":"系统交互","published":"2018-12-10T21:13:31+08:00","summary":"通过命令行获取参数 最简单的方法是使用 @*ARGS 变量从命令行获取参数;此数组将包含程序名称后面的字符串。 %*ENV 将包含环境变量，因此如果您使用：\nexport API_KEY=1967196417966160761fabc1511067 ./consume_api.p6 您可以通过以下方式在程序中使用它们：\nmy $api-key = %*ENV\u0026lt;API_KEY\u0026gt; // die \u0026#34;Need the API key\u0026#34;; 如果先前未定义环境变量 API_KEY，则此操作将失败。\nRaku 有一个更好的方法来处理命令行参数，如果它们代表文件名：那么使用 $*ARGFILES 动态变量。\nfor $*ARGFILES.lines -\u0026gt; $l { say \u0026#34;Long lines in {$*ARGFILES.path}\u0026#34; if $l.chars \u0026gt; 72 ; } 例如，你可以用 argf​​iles.p6 *.p6 的方式运行这个程序，每次找到一个超过72个字符的行时，它就会打印一个文件名。 $*ARGFILES 包含命令行中描述的所有文件的文件句柄 - .lines 将依次读取每行文件的一行，每次处理新句柄时都会更改 $*ARGFILES.path 的值。通常，它为处理文件集的脚本提供了非常方便的 API。\n以交互方式获取参数 使用 prompt 让一个正在运行的程序向用户查询数据：\nmy UInt $num-iters = prompt \u0026#34;How many iterations to run: \u0026#34;; 同步和异步运行程序 运行外部程序有两个例程：run 和 shell。两者都存在于 IO 角色中，因此包含在混合该角色的所有类中，如 IO::Path。两者都返回一个 Proc 对象，但主要区别在于 run 会尽可能避免系统 shell，而 shell 会通过默认系统 shell 运行命令。","type":"entry","url":"https://ohmycloud.github.io/posts/66.system-interaction/"}