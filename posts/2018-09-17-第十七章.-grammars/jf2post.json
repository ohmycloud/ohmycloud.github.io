{"author":{"name":null,"type":"card","url":"https://ohmycloud.github.io/"},"content":{"html":"\u003ch1 id=\"声明\"\u003e声明\u003c/h1\u003e\n\u003cp\u003e本章翻译仅用于 Raku 学习和研究, 请支持电子版或\u003ca href=\"https://www.amazon.co.uk/Learning-Perl-6-Brian-Foy/dp/149197768X/ref=sr_1_1?ie=UTF8\u0026amp;qid=1536753267\u0026amp;sr=8-1\u0026amp;keywords=Learning+Perl+6\"\u003e纸质版\u003c/a\u003e。\u003c/p\u003e\n\u003ch1 id=\"第十七章-grammars\"\u003e第十七章. Grammars\u003c/h1\u003e\n\u003cp\u003eGrammars are patterns on a higher plane of existence. They integrate and reuse pattern fragments to parse and react to complicated formats. This feature is at the core of Raku in a very literal sense; the language itself is implemented as a grammar. Once you start using it you’ll probably prefer it to regexes for all but the most simple problems.\u003c/p\u003e\n\u003cp\u003eGrammars 是存在于更高层面上的模式。它们集成并重用模式片段来解析复杂的格式并做出反应。从字面意义上讲，这个功能是Raku的核心;语言本身是作为语法实现的。一旦你开始使用它，你可能更喜欢它除了最简单的问题之外的所有正则表达式。\u003c/p\u003e\n\u003ch1 id=\"a-simple-grammar\"\u003eA Simple Grammar\u003c/h1\u003e\n\u003cp\u003eA grammar is a special sort of package. It can have methods and subroutines but mostly comprises special pattern methods called \u003ccode\u003eregex\u003c/code\u003e, \u003ccode\u003etoken\u003c/code\u003e, and \u003ccode\u003erule\u003c/code\u003e. Each of these define a pattern and apply different modifiers.\u003c/p\u003e\n\u003ch6 id=\"note\"\u003eNOTE\u003c/h6\u003e\n\u003cp\u003eRaku tends to refer to \u003ccode\u003eregex\u003c/code\u003e, \u003ccode\u003etoken\u003c/code\u003e, and \u003ccode\u003erule\u003c/code\u003e declarations as “rules,” which can be a bit imprecise at times. In this book, you can tell the difference between the language keyword and the general term by the typesetting. I’ll try to not present an ambiguous situation.\u003c/p\u003e\n\u003cp\u003eStart with something simple (too simple for grammars). Define a \u003ccode\u003eTOP\u003c/code\u003e pattern that matches digits as the starting point. That name is special because \u003ccode\u003e.parse\u003c/code\u003e uses it by default. In this example, you declare that with \u003ccode\u003eregex\u003c/code\u003e:\u003c/p\u003e\n\u003cp\u003eGrammar 是一种特殊的包。它可以有方法和子程序，但主要包括称为 \u003ccode\u003eregex\u003c/code\u003e，\u003ccode\u003etoken\u003c/code\u003e 和 \u003ccode\u003erule\u003c/code\u003e 的特殊模式方法。其中每个都定义了一个模式并应用了不同的修饰符。\u003c/p\u003e\n\u003ch6 id=\"注意\"\u003e注意\u003c/h6\u003e\n\u003cp\u003eRaku 倾向于将 \u003ccode\u003eregex\u003c/code\u003e，\u003ccode\u003etoken\u003c/code\u003e 和 \u003ccode\u003erule\u003c/code\u003e 声明称为“规则”，有时可能有点不精确。在本书中，您可以通过排版来区分语言关键字和一般术语。我会尽量不提出模棱两可的情况。\u003c/p\u003e\n\u003cp\u003e从简单的东西开始（对于 grammar 来说太简单了）。定义匹配数字作为起点的 \u003ccode\u003eTOP\u003c/code\u003e 模式。该名称很特殊，因为 \u003ccode\u003e.parse\u003c/code\u003e 默认使用它。在此示例中，您使用 \u003ccode\u003eregex\u003c/code\u003e 声明一个 \u003ccode\u003eTOP\u003c/code\u003e：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Number {\n    regex TOP { \\d }\n    }\n\nmy $result = Number.parse( \u0026#39;7\u0026#39; );  # works\n\nput $result ?? \u0026#39;Parsed!\u0026#39; !! \u0026#39;Failed!\u0026#39;;  # Parsed!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis succeeds. \u003ccode\u003e.parse\u003c/code\u003e applies the grammar to the entire value of \u003ccode\u003e7\u003c/code\u003e. It starts with the parts that \u003ccode\u003eTOP\u003c/code\u003e describes. It can match a digit, and the value you pass to \u003ccode\u003e.parse\u003c/code\u003e is a digit.\u003c/p\u003e\n\u003cp\u003eWhen \u003ccode\u003e.parse\u003c/code\u003e succeeds, it returns a \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e object (it returns \u003ccode\u003eNil\u003c/code\u003e when it fails). Try it with a different value. Instead of a single digit, try several digits:\u003c/p\u003e\n\u003cp\u003e这成功了。 \u003ccode\u003e.parse\u003c/code\u003e 将 grammar 应用于整个值 \u003ccode\u003e7\u003c/code\u003e. 它从 \u003ccode\u003eTOP\u003c/code\u003e 描述的部分开始。它可以匹配一个数字，你传递给 \u003ccode\u003e.parse\u003c/code\u003e 的值是一个数字。\u003c/p\u003e\n\u003cp\u003e当 \u003ccode\u003e.parse\u003c/code\u003e 成功时，它返回一个 \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e 对象（当它失败时返回 \u003ccode\u003eNil\u003c/code\u003e）。尝试使用不同的值。尝试几个数字而不是单个数字：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy $result = Number.parse( \u0026#39;137\u0026#39; );  # fails (extra digits)\n\nput $result ?? \u0026#39;Parsed!\u0026#39; !! \u0026#39;Failed!\u0026#39;;  # Failed!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis time \u003ccode\u003e.parse\u003c/code\u003e doesn’t succeed. It starts matching with the first character and ends matching on the last character. It asserts that the text starts, there is a single digit, and the text ends. If \u003ccode\u003e.parse\u003c/code\u003e sees that there are some characters before or after its match, it fails. It matches everything or not at all. It’s almost the same thing as explicitly using anchors:\u003c/p\u003e\n\u003cp\u003e这次 \u003ccode\u003e.parse\u003c/code\u003e 没有成功。它开始与第一个字符匹配，并在最后一个字符上结束匹配。它断言文本开始，有一个数字，文本结束。如果 \u003ccode\u003e.parse\u003c/code\u003e 看到匹配之前或之后有一些字符，则会失败。它匹配全部或根本不匹配。它与显式地使用锚点几乎相同：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Number {\n    regex TOP { ^ \\d+ $ }  # explicitly anchored\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut \u003ccode\u003eTOP\u003c/code\u003e is only the default starting point for a grammar. You can tell \u003ccode\u003e.parse\u003c/code\u003e where you’d like to start. This version defines the same pattern but calls it \u003ccode\u003edigits\u003c/code\u003e instead of \u003ccode\u003eTOP\u003c/code\u003e:\u003c/p\u003e\n\u003cp\u003e但 \u003ccode\u003eTOP\u003c/code\u003e 是仅有的 grammar 的默认起点。你可以告诉 \u003ccode\u003e.parse\u003c/code\u003e 你想要开始的地方。此版本定义相同的模式但称为 \u003ccode\u003edigits\u003c/code\u003e 而不是 \u003ccode\u003eTOP\u003c/code\u003e：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Number {\n    regex digits { \\d+ }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTell \u003ccode\u003e.parse\u003c/code\u003e where to start with the \u003ccode\u003e:rule\u003c/code\u003e named argument:\u003c/p\u003e\n\u003cp\u003e使用 \u003ccode\u003e:rule\u003c/code\u003e 命名参数告诉 \u003ccode\u003e.parse\u003c/code\u003e 从哪里开始：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy @strings = \u0026#39;137\u0026#39;, \u0026#39;137 \u0026#39;, \u0026#39; 137 \u0026#39;;\n\nfor @strings -\u0026gt; $string {\n    my $result = Number.parse( $string, :rule\u0026lt;digits\u0026gt; );\n    put \u0026#34;｢$string｣ \u0026#34;, $result ?? \u0026#39;Parsed!\u0026#39; !! \u0026#39;Failed!\u0026#39;;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe first element of \u003ccode\u003e@strings\u003c/code\u003e parses because it is only digits. The other ones fail because they have extra characters:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e@strings\u003c/code\u003e 的第一个元素解析成功了因为它只是数字。其他的失败了因为他们有额外的字符：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e｢137｣ parsed!\n｢137 ｣ failed!\n｢ 137 ｣ failed!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDeclare \u003ccode\u003edigits\u003c/code\u003e with \u003ccode\u003erule\u003c/code\u003e instead of \u003ccode\u003eregex\u003c/code\u003e. This implicitly allows whitespace after any part of your pattern:\u003c/p\u003e\n\u003cp\u003e使用 \u003ccode\u003erule\u003c/code\u003e 而不是 \u003ccode\u003eregex\u003c/code\u003e 声明 \u003ccode\u003edigits\u003c/code\u003e。这隐式地允许在模式的任何部分之后有空格：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Number {\n    rule digits { \\d+ }  #  not anchored, and works\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow the second \u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003eStr\u003c/code\u003e\u003c/a\u003e matches too because the implicit whitespace can match the space at the end (but not the beginning):\u003c/p\u003e\n\u003cp\u003e现在第二个 \u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003eStr\u003c/code\u003e\u003c/a\u003e 也匹配，因为隐式空格可以匹配末尾的空格（但不是开头）：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e｢137｣ parsed!\n｢137 ｣ parsed!\n｢ 137 ｣ failed!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003erule\u003c/code\u003e applies \u003ccode\u003e:sigspace\u003c/code\u003e to its pattern. It’s the same thing as adding that adverb to the pattern:\u003c/p\u003e\n\u003cp\u003e该 \u003ccode\u003erule\u003c/code\u003e 将 \u003ccode\u003e:sigspace\u003c/code\u003e 应用到其模式。将该副词添加到模式中是一回事：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Number {\n    regex digits { :sigspace \\d+ }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e:sigspace\u003c/code\u003e inserts the predefined \u003ccode\u003e\u0026lt;.ws\u0026gt;\u003c/code\u003e \u003cem\u003eafter\u003c/em\u003e pattern tokens. Since there’s a dot before the name \u003ccode\u003ews\u003c/code\u003e, the \u003ccode\u003e\u0026lt;.ws\u0026gt;\u003c/code\u003e does not create a capture. It’s the same as adding optional whitespace explicitly:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e:sigspace\u003c/code\u003e在模式标记之后插入预定义的 \u003ccode\u003e\u0026lt;.ws\u0026gt;\u003c/code\u003e。由于名称 \u003ccode\u003ews\u003c/code\u003e 之前有一个点号，\u003ccode\u003e\u0026lt;.ws\u0026gt;\u003c/code\u003e 不会创建捕获。它与显式添加可选空格相同：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Number {\n    regex digits { \\d+ \u0026lt;.ws\u0026gt; }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eInstead of showing \u003ccode\u003eParsed!\u003c/code\u003e, you can on success output the \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e object you stored in \u003ccode\u003e$result\u003c/code\u003e:\u003c/p\u003e\n\u003cp\u003e您可以在成功输出存储在 \u003ccode\u003e$result\u003c/code\u003e 中的  \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e 对象，而不是显示 \u003ccode\u003eParsed!\u003c/code\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Number {\n    regex digits { \\d+ \u0026lt;.ws\u0026gt; }\n    }\n\nmy @strings = \u0026#39;137\u0026#39;, \u0026#39;137 \u0026#39;, \u0026#39; 137 \u0026#39;;\n\nfor @strings -\u0026gt; $string {\n    my $result = Number.parse( $string, :rule\u0026lt;digits\u0026gt; );\n    put $result ?? $result !! \u0026#39;Failed!\u0026#39;;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe output isn’t that different, but instead of its success status you see the text that matched:\u003c/p\u003e\n\u003cp\u003e输出没有那么不同，但您可以看到匹配到的文本，而不是其成功状态：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e｢137｣\n｢137 ｣\nFailed!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eModify the grammar to remove that dot from \u003ccode\u003e\u0026lt;.ws\u0026gt;\u003c/code\u003e so it captures whitespace and try again:\u003c/p\u003e\n\u003cp\u003e修改 grammar 以从 \u003ccode\u003e\u0026lt;.ws\u0026gt;\u003c/code\u003e 中删除该点号，以便捕获空格并再次尝试：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Number {\n    regex digits { \\d+ \u0026lt;ws\u0026gt; }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow the output shows the nested levels of named captures:\u003c/p\u003e\n\u003cp\u003e现在输出显示了命名捕获的嵌套级别：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e｢137｣\n ws =\u0026gt; ｢｣\n｢137 ｣\n ws =\u0026gt; ｢ ｣\nFailed!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis still doesn’t match the \u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003eStr\u003c/code\u003e\u003c/a\u003e with leading whitespace. The parser couldn’t match that since \u003ccode\u003erule\u003c/code\u003e only inserts \u003ccode\u003e\u0026lt;.ws\u0026gt;\u003c/code\u003e after explicit parts of the pattern. To match leading whitespace you need to add something to the front of the pattern. The beginning-of-string anchor does that, and now there’s something that \u003ccode\u003e\u0026lt;.ws\u0026gt;\u003c/code\u003e can come after:\u003c/p\u003e\n\u003cp\u003e这仍然与带有前导空格的 \u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003eStr\u003c/code\u003e\u003c/a\u003e 不匹配。解析器无法匹配，因为 \u003ccode\u003erule\u003c/code\u003e 仅在模式的显式部分之后插入 \u003ccode\u003e\u0026lt;.ws\u0026gt;\u003c/code\u003e。要匹配前导空格，您需要在模式的前面添加一些内容。字符串开头的锚点就是这样，现在有一些 \u003ccode\u003e\u0026lt;.ws\u0026gt;\u003c/code\u003e 后面可以出现的东西：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Number {\n    rule digits { ^ \\d+ }    # ^ \u0026lt;.ws\u0026gt; \\d+ \u0026lt;.ws\u0026gt;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere’s also the zero-width always-matches token, \u003ccode\u003e\u0026lt;?\u0026gt;\u003c/code\u003e:\u003c/p\u003e\n\u003cp\u003e还有零宽度始终匹配的 token 标记，\u003ccode\u003e\u0026lt;?\u0026gt;\u003c/code\u003e：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Number {\n    rule digits { \u0026lt;?\u0026gt; \\d+ }  #  \u0026lt;?\u0026gt; \u0026lt;.ws\u0026gt; \\d+ \u0026lt;.ws\u0026gt;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMost of the time you don’t want to play these games. If you want leading whitespace, you can note that explicitly (and you probably don’t want to capture it):\u003c/p\u003e\n\u003cp\u003e大多数时候你不想玩这些游戏。如果你想要前导空格，你可以显式地注意到（并且你可能不想捕获它）：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Number {\n    rule digits { \u0026lt;.ws\u0026gt; \\d+ }  # \u0026lt;.ws\u0026gt; \\d+ \u0026lt;.ws\u0026gt;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUse \u003ccode\u003etoken\u003c/code\u003e instead of \u003ccode\u003erule\u003c/code\u003e if you don’t want any implicit whitespace:\u003c/p\u003e\n\u003cp\u003e如果您不想要任何隐式空格，请使用 \u003ccode\u003etoken\u003c/code\u003e 而不是 \u003ccode\u003erule\u003c/code\u003e：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Number {\n    token digits { \\d+ }  # just the digits\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou’ll see another feature of \u003ccode\u003erule\u003c/code\u003e and \u003ccode\u003etoken\u003c/code\u003e later in this chapter.\u003c/p\u003e\n\u003cp\u003e您将在本章后面看到 \u003ccode\u003erule\u003c/code\u003e 和 \u003ccode\u003etoken\u003c/code\u003e 的另一个功能。\u003c/p\u003e\n\u003cp\u003eEXERCISE 17.1Write a grammer to match octal digits, with or without a leading \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003e0o\u003c/code\u003e. Your grammar should parse numbers such as \u003ccode\u003e123\u003c/code\u003e, \u003ccode\u003e0123\u003c/code\u003e, and \u003ccode\u003e0o456\u003c/code\u003e, but not \u003ccode\u003e8\u003c/code\u003e, \u003ccode\u003e129\u003c/code\u003e, or \u003ccode\u003eo345\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e练习17.1写一个 grammar 来匹配八进制数字，带或不带前导 \u003ccode\u003e0\u003c/code\u003e 或 \u003ccode\u003e0o\u003c/code\u003e。您的 grammar 应该解析诸如 \u003ccode\u003e123\u003c/code\u003e, \u003ccode\u003e0123\u003c/code\u003e 和 \u003ccode\u003e0o456\u003c/code\u003e 之类的数字，但不能解析 \u003ccode\u003e8\u003c/code\u003e ,\u003ccode\u003e129\u003c/code\u003e 或 \u003ccode\u003eo345\u003c/code\u003e。\u003c/p\u003e\n\u003ch1 id=\"multiple-rules\"\u003eMultiple Rules\u003c/h1\u003e\n\u003cp\u003eGrammars wouldn’t be useful if you were limited to one rule. You can define additional rules and use them inside other rules. In the first exercise you had only the \u003ccode\u003eTOP\u003c/code\u003e rule but you could separate the pattern into parts. Break up the pattern in \u003ccode\u003eTOP\u003c/code\u003e into rules for \u003ccode\u003eprefix\u003c/code\u003e and \u003ccode\u003edigits\u003c/code\u003e. It’s this decomposability that makes it so easy to solve hard parsing problems:\u003c/p\u003e\n\u003cp\u003e如果你只限于一条规则，那么 grammar 就没用了。您可以定义其他规则并在其他规则中使用它们。在第一个练习中，您只有 \u003ccode\u003eTOP\u003c/code\u003e 规则，但您可以将模式分成几部分。将 \u003ccode\u003eTOP\u003c/code\u003e 中的模式分解为 \u003ccode\u003eprefix\u003c/code\u003e和\u003ccode\u003edigits\u003c/code\u003e的规则。正是这种可分解性使得解决困难的解析问题变得如此简单：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar OctalNumber {\n    regex TOP          { \u0026lt;prefix\u0026gt;? \u0026lt;digits\u0026gt;  }\n    regex prefix       {  [ 0o? ]  }\n    regex digits       { \u0026lt;[0..7]\u0026gt;+ }\n    }\n\nmy $number = \u0026#39;0o177\u0026#39;;\nmy $result = OctalNumber.parse( $number );\nsay $result // \u0026#34;failed\u0026#34;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe stringified \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e object shows the overall match and the named subcaptures:\u003c/p\u003e\n\u003cp\u003e字符串化的 \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e 对象显示整体匹配和命名的子捕获：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e｢0o177｣\n prefix =\u0026gt; ｢0o｣\n digits =\u0026gt; ｢177｣\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can access the pieces:\u003c/p\u003e\n\u003cp\u003e你可以访问这些部分：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eput \u0026#34;Prefix: $result\u0026lt;prefix\u0026gt;\u0026#34;;\nput \u0026#34;Digits: $result\u0026lt;digits\u0026gt;\u0026#34;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEXERCISE 17.2Create a grammar to match a Raku variable name with a sigil (ignore sigilless variables, because that’s too easy). Use separate rules to match the sigil and the identifier. Here is a list of candidates to check if you don’t come up with your own:\u003ccode\u003emy @candidates = qw/     sigilless   $scalar  @array   %hash     $123abc    $abc'123 $ab'c123     $two-words $two-    $-dash     /;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eYou can suppress some of those named captures by prefixing the rule with a dot. You probably don’t care about the prefix, so don’t save it:\u003c/p\u003e\n\u003cp\u003e练习17.2 创建一个 grammar，匹配带有 sigil 的 Raku 变量名（忽略无符号变量，因为这太简单了）。使用单独的规则来匹配 sigil 和标识符。这是一个候选人列表，检查你是否没有自己的：\u003ccode\u003emy @candidates = qw/     sigilless   $scalar  @array   %hash     $123abc    $abc'123 $ab'c123     $two-words $two-    $-dash     /;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e您可以通过在规则前加一个点号来抑制某些命名捕获。您可能不关心前缀，所以不要保存它：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar OctalNumber {\n    regex TOP          { \u0026lt;.prefix\u0026gt;? \u0026lt;digits\u0026gt; }\n    regex prefix       {  [ 0o? ]  }\n    regex digits       { \u0026lt;[0..7]\u0026gt;+ }\n    }\n\nmy $number = \u0026#39;0o177\u0026#39;;\nmy $result = OctalNumber.parse( $number );\nsay $result // \u0026#34;failed\u0026#34;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe output doesn’t include the prefix information:\u003c/p\u003e\n\u003cp\u003e输出不包含前缀信息：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e｢0o177｣\n digits =\u0026gt; ｢177｣\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis doesn’t make much of a difference in this small example, but imagine a complicated grammar with many, many rules. That brings you to the next big feature of grammars. Besides the grammar itself, you can specify an \u003cem\u003eaction class\u003c/em\u003e that processes the rules as the grammar successfully parses them.\u003c/p\u003e\n\u003cp\u003e这在这个小例子中并没有太大的区别，但想象一下复杂的 grammar 有很多很多规则。这将带您进入 grammar 的下一个重要特征。除 grammar 本身外，您还可以指定一个 action 类来处理规则，因为 grammar 会成功解析它们。\u003c/p\u003e\n\u003ch1 id=\"debugging-grammars\"\u003eDebugging Grammars\u003c/h1\u003e\n\u003cp\u003eThere are two modules that can help you figure out what’s going on in your grammar. Both are much more impressive in your terminal.\u003c/p\u003e\n\u003cp\u003e有两个模块可以帮助您弄清楚 grammar 中发生了什么。两者在你的终端中都更令人印象深刻。\u003c/p\u003e\n\u003ch2 id=\"grammartracer\"\u003eGrammar::Tracer\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eGrammar::Tracer\u003c/code\u003e module shows you the path through a grammar (and applies to any grammar in its scope). Merely loading the module is enough to activate it:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eGrammar::Tracer\u003c/code\u003e 模块向您显示 grammar 的路径（并适用于其作用域内的任何 grammar）。仅加载模块就足以激活它：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003euse Grammar::Tracer;\n\ngrammar OctalNumber {\n    regex TOP          { \u0026lt;prefix\u0026gt;? \u0026lt;digits\u0026gt;  }\n    regex prefix       {  [ 0o? ]  }\n    regex digits       { \u0026lt;[0..7]\u0026gt;+ }\n    }\n\nmy $number = \u0026#39;0o177\u0026#39;;\n$/ = OctalNumber.parse( $number );\nsay $/ // \u0026#34;failed\u0026#34;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe first part of the output is the trace. It shows which rule it’s in and the result. In this example each one matches:\u003c/p\u003e\n\u003cp\u003e输出的第一部分是跟踪。它显示了它所在的规则和结果。在这个例子中，每个规则都匹配：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eTOP\n|  prefix\n|  * MATCH \u0026#34;0o\u0026#34;\n|  digits\n|  * MATCH \u0026#34;177\u0026#34;\n* MATCH \u0026#34;0o177\u0026#34;\n｢0o177｣\n prefix =\u0026gt; ｢0o｣\n digits =\u0026gt; ｢177｣\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eChanging the data to include invalid digits, such as \u003ccode\u003e0o178\u003c/code\u003e, means the grammar will fail. In the trace you can see it matches up to \u003ccode\u003e0o17\u003c/code\u003e but can’t continue, so you know where in your \u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003eStr\u003c/code\u003e\u003c/a\u003e things went wrong. It could be that the grammar should not match the text or the grammar is not as accommodating as it should be:\u003c/p\u003e\n\u003cp\u003e更改数据以包含无效数字（例如 \u003ccode\u003e0o178\u003c/code\u003e）意味着 grammar 将失败。在跟踪中，您可以看到它最多匹配到 \u003ccode\u003e0o17\u003c/code\u003e 但无法继续，因此你就知道  \u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003eStr\u003c/code\u003e\u003c/a\u003e  中的哪些地方出错了。可能是 grammar 不应该与文本匹配，或者 grammar 不应该像它应该的那样适应：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eTOP\n|  prefix\n|  * MATCH \u0026#34;0o\u0026#34;\n|  digits\n|  * MATCH \u0026#34;17\u0026#34;\n* MATCH \u0026#34;0o17\u0026#34;\ndigits\n* FAIL\ndigits\n* MATCH \u0026#34;0\u0026#34;\nfailed\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eInstead of adding \u003ccode\u003eGrammar::Tracer\u003c/code\u003e to your program you can load it from the command line with the \u003ccode\u003e-M\u003c/code\u003eswitch. You probably don’t mean to leave it in anyway:\u003c/p\u003e\n\u003cp\u003e您可以使用 \u003ccode\u003e-M\u003c/code\u003e 开关从命令行加载 \u003ccode\u003eGrammar::Tracer\u003c/code\u003e，而不是将 \u003ccode\u003eGrammar::Tracer\u003c/code\u003e 添加到程序中。你可能并不是故意把它留下来：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e% raku -MGrammar::Tracer program.p6\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"grammardebugger\"\u003eGrammar::Debugger\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eGrammar::Debugger\u003c/code\u003e module does the same thing as \u003ccode\u003eGrammar::Tracer\u003c/code\u003e (they come together in the same distribution) but allows you to proceed one step at a time. When you start it you get a prompt; type \u003ccode\u003eh\u003c/code\u003e to get a list of commands:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eGrammar::Debugger\u003c/code\u003e 模块与 \u003ccode\u003eGrammar::Tracer\u003c/code\u003e （它们在同一个发行版中）执行相同的操作，但允许您一次执行一个步骤。当你启动它时，你得到一个提示; 键入 \u003ccode\u003eh\u003c/code\u003e 以获取命令列表：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e% raku -MGrammar::Debugger test.p6\nTOP\n\u0026gt; h\n    r              run (until breakpoint, if any)\n    \u0026lt;enter\u0026gt;        single step\n    rf             run until a match fails\n    r \u0026lt;name\u0026gt;       run until rule \u0026lt;name\u0026gt; is reached\n    bp add \u0026lt;name\u0026gt;  add a rule name breakpoint\n    bp list        list all active rule name breakpoints\n    bp rm \u0026lt;name\u0026gt;   remove a rule name breakpoint\n    bp rm          removes all breakpoints\n    q              quit\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTyping Enter with no command single-steps through the parse process and gives you a chance to inspect the text and the state of the parser. The \u003ccode\u003erf\u003c/code\u003e command will get you to the next failing rule:\u003c/p\u003e\n\u003cp\u003e在没有命令的情况下键入回车键单步执行解析过程，并让你有机会检查文本和解析器的状态。\u003ccode\u003e rf\u003c/code\u003e 命令会使你进入下一个失败的规则：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u0026gt; rf\n|  prefix\n|  * MATCH \u0026#34;0o\u0026#34;\n|  digits\n|  * MATCH \u0026#34;17\u0026#34;\n* MATCH \u0026#34;0o17\u0026#34;\ndigits\n* FAIL\n\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"a-simple-action-class\"\u003eA Simple Action Class\u003c/h1\u003e\n\u003cp\u003eA grammar does its work by descending into its rules to take apart text. You can go the opposite way by processing each part of the parsed text to build a new \u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003eStr\u003c/code\u003e\u003c/a\u003e (or data structure, or whatever you like). You can tell \u003ccode\u003e.parse\u003c/code\u003e to use an action class to do this.\u003c/p\u003e\n\u003cp\u003egrammar 通过下降到它的规则中分解文本来完成其工作。你可以通过处理已解析文本的每个部分来构建新的 \u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003eStr\u003c/code\u003e\u003c/a\u003e（或数据结构，或任何您喜欢的任何内容）。您可以告诉 \u003ccode\u003e.parse\u003c/code\u003e 使用 action 类来执行此操作。\u003c/p\u003e\n\u003cp\u003eHere’s a simple action class, \u003ccode\u003eOctalActions\u003c/code\u003e. It doesn’t need to have the same name as the grammar, but the method names are the same as the rule names. Each method takes a \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e object argument. In this example, the signature uses \u003ccode\u003e$/\u003c/code\u003e, which is a variable with a few advantages that you’ll see in a moment:\u003c/p\u003e\n\u003cp\u003e这是一个简单的 action 类 \u003ccode\u003eOctalActions\u003c/code\u003e。它不需要与 grammar 具有相同的名称，但方法名称与规则名称相同。每个方法都接收 \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e 对象参数。在此示例中，签名使用 \u003ccode\u003e$/\u003c/code\u003e，这是一个具有一些优势的变量，稍后你将看到：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eclass OctalActions {\n    method digits ($/) { put \u0026#34;Action class got $/\u0026#34; }\n    }\n\ngrammar OctalNumber {\n    regex TOP          { \u0026lt;.prefix\u0026gt;? \u0026lt;digits\u0026gt;  }\n    regex prefix       {  [ 0o? ]  }\n    regex digits       { \u0026lt;[0..7]\u0026gt;+ }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTell \u003ccode\u003e.parse\u003c/code\u003e which class to use with the \u003ccode\u003e:actions\u003c/code\u003e named parameter. The name does not need to correspond to the grammar:\u003c/p\u003e\n\u003cp\u003e使用 \u003ccode\u003e:actions\u003c/code\u003e 命名参数告诉 \u003ccode\u003e.parse\u003c/code\u003e 使用哪个类。该名称不需要与 grammar 对应：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy $number = \u0026#39;0o177\u0026#39;;\nmy $result = OctalNumber.parse(\n    $number, :actions(OctalActions)\n    );\nsay $result // \u0026#34;failed\u0026#34;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis action class doesn’t do much. When the \u003ccode\u003edigits\u003c/code\u003e rule successfully matches it triggers the rule of the same name in the action class. That method merely outputs the argument:\u003c/p\u003e\n\u003cp\u003e这个 action 类做的不多。当 \u003ccode\u003edigits\u003c/code\u003e 规则成功匹配时，它会触发 action 类中相同名称的规则。该方法仅输出参数：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eAction class got 177\n｢0o177｣\n digits =\u0026gt; ｢177｣\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEXERCISE 17.3Implement your own action class for the \u003ccode\u003eOctalNumber\u003c/code\u003e grammar. When the \u003ccode\u003edigits\u003c/code\u003e method matches, output the decimal version of the number. The \u003ccode\u003eparse-base\u003c/code\u003e routine from \u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003eStr\u003c/code\u003e\u003c/a\u003e may be useful. For extra credit, take one number per line from standard input and turn them into decimal numbers.\u003c/p\u003e\n\u003cp\u003e练习17.3 为 \u003ccode\u003eOctalNumber\u003c/code\u003e grammar 实现自己的 action 类。当 \u003ccode\u003edigits\u003c/code\u003e 方法匹配时，输出数字的十进制版本。 \u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003eStr\u003c/code\u003e\u003c/a\u003e 的 \u003ccode\u003eparse-base\u003c/code\u003e 例程可能很有用。如需额外学分，请从标准输入中每行获取一个数字并将其转换为十进制数字。\u003c/p\u003e\n\u003ch2 id=\"creating-an-abstract-syntax-tree\"\u003eCreating an Abstract Syntax Tree\u003c/h2\u003e\n\u003cp\u003eActions shouldn’t output information directly. Instead, they can add values to the \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e object. Calling \u003ccode\u003emake\u003c/code\u003ein the action method sets a value in the abstract syntax tree (or \u003ccode\u003e.ast\u003c/code\u003e) slot of the \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e. You can access that with \u003ccode\u003e.made\u003c/code\u003e:\u003c/p\u003e\n\u003cp\u003eAction 不应直接输出信息。相反，他们可以向 \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e 对象添加值。在 action 方法中调用 \u003ccode\u003emake\u003c/code\u003e 会在 \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e 的抽象语法树（或 \u003ccode\u003e.ast\u003c/code\u003e ）槽中设置一个值。您可以使用 \u003ccode\u003e.made\u003c/code\u003e 访问它：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eclass OctalActions {\n    method digits ($/) {\n        make parse-base( ~$/, 8 ) # must stringify $/\n        }\n    }\n\ngrammar OctalNumber {\n    regex TOP          { \u0026lt;.prefix\u0026gt;? \u0026lt;digits\u0026gt;  }\n    regex prefix       {  [ 0o? ]  }\n    regex digits       { \u0026lt;[0..7]\u0026gt;+ }\n    }\n\nmy $number = \u0026#39;0o177\u0026#39;;\nmy $result = OctalNumber.parse(\n    $number, :actions(OctalActions)\n    );\nput $result ??\n    \u0026#34;Turned ｢{$result\u0026lt;digits\u0026gt;}｣ into ｢{$result\u0026lt;digits\u0026gt;.made}｣\u0026#34;\n    !! \u0026#39;Failed!\u0026#39;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003emake\u003c/code\u003e puts something into the \u003ccode\u003e.ast\u003c/code\u003e slot of the \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e and \u003ccode\u003e.made\u003c/code\u003e gets it back out. You can \u003ccode\u003emake\u003c/code\u003e any value that you like, including containers, objects, and most other things you can imagine. You still get the original, literal match.\u003c/p\u003e\n\u003cp\u003eIn the previous example, the \u003ccode\u003edigits\u003c/code\u003e action method handled the value. A \u003ccode\u003eTOP\u003c/code\u003e action method could do it, but it has to reach one level below the \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e object:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emake\u003c/code\u003e 将一些内容放入\u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e的 \u003ccode\u003e.ast\u003c/code\u003e 插槽中，然后 \u003ccode\u003e.made\u003c/code\u003e 将其恢复原状。您可以\u003ccode\u003emake\u003c/code\u003e 任何您喜欢的值，包括容器，对象和您可以想象的大多数其他内容。你仍然得到原始的，字面上的匹配。\u003c/p\u003e\n\u003cp\u003e在前面的示例中，\u003ccode\u003edigits\u003c/code\u003e action 方法处理了该值。 \u003ccode\u003eTOP\u003c/code\u003e action 方法可以做到，但它必须到达  \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e 对象下面的一个级别：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eclass OctalActions {\n    method digits ($/) {\n        make parse-base( ~$/, 8 ) # must stringify $/\n        }\n    }\n\ngrammar OctalNumber {\n    regex TOP          { \u0026lt;.prefix\u0026gt;? \u0026lt;digits\u0026gt;  }\n    regex prefix       {  [ 0o? ]  }\n    regex digits       { \u0026lt;[0..7]\u0026gt;+ }\n    }\n\nmy $number = \u0026#39;0o177\u0026#39;;\nmy $result = OctalNumber.parse(\n    $number, :actions(OctalActions)\n    );\nput $result.so ??\n    \u0026#34;Turned ｢{$number}｣ into ｢{$result.made}｣\u0026#34;\n    !! \u0026#39;Failed!\u0026#39;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou don’t have to use \u003ccode\u003e$/\u003c/code\u003e in the signature; it’s a convenience. There’s nothing particularly magical about it. You could use some other variable if you are paid by the character:\u003c/p\u003e\n\u003cp\u003e您不必在签名中使用 \u003ccode\u003e$/\u003c/code\u003e; 这是一个方便写法。它没什么特别神奇的。如果你有其它字符，您可以使用其他变量：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eclass OctalActions {\n    method TOP ($match) { make parse-base( ~$match\u0026lt;digits\u0026gt;, 8 ) }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEXERCISE 17.4Create a grammar to parse a four-part, dotted-decimal IP address, such as \u003ccode\u003e192.168.1.137\u003c/code\u003e. Create an action class that turns the parse results into a 32-bit number. Output that 32-bit number in hexadecimal.\u003c/p\u003e\n\u003cp\u003e练习17.4 创建一个 grammar 来解析一个由四部分组成的点分十进制 IP 地址，例如 \u003ccode\u003e192.168.1.137\u003c/code\u003e。创建一个 action 类，将解析结果转换为32位数。以十六进制输出那个32位数。\u003c/p\u003e\n\u003ch1 id=\"ratcheting\"\u003eRatcheting\u003c/h1\u003e\n\u003cp\u003eThe \u003ccode\u003erule\u003c/code\u003e and \u003ccode\u003etoken\u003c/code\u003e declarators have a feature that \u003ccode\u003eregex\u003c/code\u003e doesn’t; they both prevent backtracking by implicitly setting the \u003ccode\u003e:ratchet\u003c/code\u003e adverb. Once one of those rules matches they don’t backtrack to try again if there’s a failure later in the grammar.\u003c/p\u003e\n\u003cp\u003eHere’s a nonsense grammar that includes a rule \u003ccode\u003e\u0026lt;some-stuff\u0026gt;\u003c/code\u003e that matches one or more of any character. The \u003ccode\u003eTOP\u003c/code\u003e token wants to match digits surrounded by unspecified stuff:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003erule\u003c/code\u003e 和 \u003ccode\u003etoken\u003c/code\u003e 声明符具有 \u003ccode\u003eregex\u003c/code\u003e 不具有的功能;他们都通过隐式设置 \u003ccode\u003e:ratchet\u003c/code\u003e 副词来阻止回溯。一旦这些规则中的一个匹配，如果在 grammar 中稍后出现失败，则它们不会回溯以再次尝试。\u003c/p\u003e\n\u003cp\u003e这是一个无意义的 grammar，其中包含能匹配一个或多个字符的 \u003ccode\u003e\u0026lt;some-stuff\u0026gt;\u003c/code\u003e 规则。 \u003ccode\u003eTOP\u003c/code\u003e token 想要匹配由未指定的东西包围的数字：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Stuff {\n    token TOP { \u0026lt;some-stuff\u0026gt; \u0026lt;digits\u0026gt; \u0026lt;some-stuff\u0026gt; }\n    token digits       { \\d+ }\n    token some-stuff   { .+  }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis \u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003eStr\u003c/code\u003e\u003c/a\u003e could satisfy that pattern. It has stuff, some digits, and more stuff:\u003c/p\u003e\n\u003cp\u003e这个\u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003e字符串\u003c/code\u003e\u003c/a\u003e可以满足这种模式。它有东西，一些数字和更多的东西：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy $string = \u0026#39;abcdef123xyx456\u0026#39;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut, \u003ccode\u003eStuff\u003c/code\u003e fails to parse it:\u003c/p\u003e\n\u003cp\u003e但是，\u003ccode\u003eStuff\u003c/code\u003e 无法解析它：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy $result = Stuff.parse( $string );\nput \u0026#34;｢$string｣ \u0026#34;, $result ?? \u0026#39;Parsed!\u0026#39; !! \u0026#39;Failed!\u0026#39;; # Failed!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt’s the \u003ccode\u003e:ratchet\u003c/code\u003e that makes it fail. Work out its path to see why. \u003ccode\u003eTOP\u003c/code\u003e has to first match \u003ccode\u003e\u0026lt;some-stuff\u0026gt;\u003c/code\u003e. That matches any character one or more times, greedily—it matches the entire text. \u003ccode\u003eTOP\u003c/code\u003e next needs to match\u003ccode\u003e\u0026lt;digits\u0026gt;\u003c/code\u003e, but there is nothing left to match because of that greediness. Without \u003ccode\u003e:ratchet\u003c/code\u003e the pattern might roll back some of the characters it already consumed. With \u003ccode\u003e:ratchet\u003c/code\u003e it doesn’t do that. The grammar can’t match the rest of \u003ccode\u003eTOP\u003c/code\u003e and it fails.\u003c/p\u003e\n\u003cp\u003eWithout \u003ccode\u003e:ratchet\u003c/code\u003e the situation is different. If you use \u003ccode\u003eregex\u003c/code\u003e instead of \u003ccode\u003etoken\u003c/code\u003e, you allow the grammar to give back characters it has already matched:\u003c/p\u003e\n\u003cp\u003e是 \u003ccode\u003e:ratchet\u003c/code\u003e 使它失败的。找出原因，看看为什么。 \u003ccode\u003eTOP\u003c/code\u003e 必须首先匹配 \u003ccode\u003e\u0026lt;some-stuff\u0026gt;\u003c/code\u003e。这匹配任何一个字符一次或多次，贪婪地 - 它匹配整个文本。 \u003ccode\u003eTOP\u003c/code\u003e  接着需要匹配 \u003ccode\u003e\u0026lt;digits\u0026gt;\u003c/code\u003e，但由于这种贪婪，没有什么可以匹配的了。如果没有 \u003ccode\u003e:ratchet\u003c/code\u003e 模式可能会回滚它已经消耗的一些字符。使用 \u003ccode\u003e:ratchet\u003c/code\u003e 它不会那样做。Grammar 不能匹配 \u003ccode\u003eTOP\u003c/code\u003e 的其余部分，所以失败了。\u003c/p\u003e\n\u003cp\u003e没有 \u003ccode\u003e:ratchet\u003c/code\u003e 的情况是不同的。如果使用 \u003ccode\u003eregex\u003c/code\u003e 而不是 \u003ccode\u003etoken\u003c/code\u003e，则允许 grammar 归还已匹配的字符：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Stuff {\n    # regex does not turn on ratcheting\n    regex TOP { \u0026lt;some-stuff\u0026gt; \u0026lt;digits\u0026gt; \u0026lt;some-stuff\u0026gt; }\n    token digits       { \\d+ }\n    regex some-stuff   { .+  }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat could match. The \u003ccode\u003eTOP\u003c/code\u003e matches \u003ccode\u003e\u0026lt;some-stuff\u0026gt;\u003c/code\u003e but realizes it’s run out of text and starts backtracking. All parts of the grammar that want to allow backtracking have to use \u003ccode\u003eregex\u003c/code\u003e. It’s not good enough for \u003ccode\u003eTOP\u003c/code\u003e to backtrack but not \u003ccode\u003e\u0026lt;some-stuff\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e那可能会匹配。 \u003ccode\u003eTOP\u003c/code\u003e 匹配 \u003ccode\u003e\u0026lt;some-stuff\u0026gt;\u003c/code\u003e，但意识到它已用完文本并开始回溯。想要允许回溯的 grammar 的所有部分都必须使用 \u003ccode\u003eregex\u003c/code\u003e。对于 \u003ccode\u003eTOP\u003c/code\u003e 来说，回溯并不是足够好，除了 \u003ccode\u003e\u0026lt;some-stuff\u0026gt;\u003c/code\u003e 。\u003c/p\u003e\n\u003ch1 id=\"parsing-json\"\u003eParsing JSON\u003c/h1\u003e\n\u003cp\u003eIn \u003cem\u003eMastering Perl\u003c/em\u003e I presented a JSON parser that Randal Schwartz created using some advanced features of Perl 5 regular expressions. In many ways his implementation was a grammar, but he was forced to inseparably combine the parsing and the actions. That made the regular expression almost impenetrable. It’s much cleaner and more accessible to write it as a Raku grammar.\u003c/p\u003e\n\u003cp\u003eJSON is actually quite simple with only a few weird things to handle, but it gives you the opportunity to see how \u003ccode\u003eproto\u003c/code\u003e rules can simplify actions:\u003c/p\u003e\n\u003cp\u003e在 Mastering Perl 中，我提到了一个 Randal Schwartz 使用 Perl 5 正则表达式的一些高级功能创建的 JSON 解析器。在许多方面，他的实现是一种 grammar，但他被迫不可分割地将解析和 action 组合在一块。这使得正则表达式几乎无法穿透。用 Raku grammar 编写它会更清晰，更容易访问。\u003c/p\u003e\n\u003cp\u003eJSON 实际上非常简单，只需处理几个奇怪的事情，但它让您有机会了解 \u003ccode\u003eproto\u003c/code\u003e 规则如何简化 action：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Grammar::JSON {\n    rule TOP                { \u0026lt;.ws\u0026gt; \u0026lt;value\u0026gt; \u0026lt;.ws\u0026gt; }\n\n    rule object             { \u0026#39;{\u0026#39; ~ \u0026#39;}\u0026#39; \u0026lt;string-value-list\u0026gt; }\n    rule string-value-list  { \u0026lt;string-value\u0026gt; * % \u0026#39;,\u0026#39; }\n    token string-value      { \u0026lt;string\u0026gt; \u0026lt;.ws\u0026gt; \u0026#39;:\u0026#39; \u0026lt;.ws\u0026gt; \u0026lt;value\u0026gt; }\n\n    rule array              { \u0026#39;[\u0026#39; ~ \u0026#39;]\u0026#39; \u0026lt;list\u0026gt; }\n    rule list               { \u0026lt;value\u0026gt; * % \u0026#39;,\u0026#39; }\n\n    token value             {\n        \u0026lt;string\u0026gt; | \u0026lt;number\u0026gt; | \u0026lt;object\u0026gt; | \u0026lt;array\u0026gt; |\n        \u0026lt;true\u0026gt; | \u0026lt;false\u0026gt; | \u0026lt;null\u0026gt;\n        }\n\n    token true  { \u0026#39;true\u0026#39;  }\n    token false { \u0026#39;false\u0026#39; }\n    token null  { \u0026#39;null\u0026#39;  }\n\n    token string {\n        (:ignoremark \\\u0026#34; ) ~ \\\u0026#34;\n        [\n            \u0026lt;u_char\u0026gt;              |\n            [ \u0026#39;\\\\\u0026#39; \u0026lt;[\\\\/bfnrt\u0026#34;]\u0026gt; ] |\n            \u0026lt;-[\\\\\\\u0026#34;\\n\\t]\u0026gt;+\n        ]*\n        }\n\n    token u_char {\n        \u0026#39;\\\\u\u0026#39; \u0026lt;code_point\u0026gt;\n        }\n\n    token code_point { \u0026lt;[0..9a..fA..F]\u0026gt;**4 }\n\n    token number {\n        \u0026#39;-\u0026#39; ?\n        [ 0 | \u0026lt;[1..9]\u0026gt;\u0026lt;[0..9]\u0026gt;* ]\n        [ \u0026#39;.\u0026#39; \u0026lt;[0..9]\u0026gt;+ ]?\n        [ \u0026lt;[eE]\u0026gt; \u0026lt;[+-]\u0026gt;? \u0026lt;[0..9]\u0026gt;+ ]?\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou may be surprised at how easy and short that grammar is. It’s almost a straight translation of the grammar from \u003ca href=\"https://trac.tools.ietf.org/html/rfc8259\"\u003eRFC 8259\u003c/a\u003e. Now, create an action class for that:\u003c/p\u003e\n\u003cp\u003e您可能会对这个 grammar 的简单和简短感到惊讶。它几乎是  \u003ca href=\"https://trac.tools.ietf.org/html/rfc8259\"\u003eRFC 8259\u003c/a\u003e grammar 的直接翻译。现在，为此创建一个 action 类：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eclass JSON::Actions {\n    method TOP ($/) { make $\u0026lt;value\u0026gt;.made }\n    method object ($/) {\n        make $\u0026lt;string-value-list\u0026gt;.made.hash.item;\n        }\n    method array ($/) {\n        make $\u0026lt;list\u0026gt;.made.item;\n        }\n\n    method true       ($/) { make True }\n    method False      ($/) { make False }\n    method null       ($/) { make Nil }\n\n    method value      ($/) { make (\n        $\u0026lt;true\u0026gt; || $\u0026lt;false\u0026gt; || $\u0026lt;null\u0026gt; || $\u0026lt;object\u0026gt; ||\n        $\u0026lt;array\u0026gt; || $\u0026lt;string\u0026gt; || $\u0026lt;number\u0026gt; ).made\n        }\n\n    method string-value-list ($/) {\n        make $\u0026lt;string-value\u0026gt;\u0026gt;\u0026gt;.made.flat;\n        }\n\n    method string-value ($/) {\n        make $\u0026lt;string\u0026gt; =\u0026gt; $\u0026lt;value\u0026gt;\n        }\n\n    method list       ($/) { make ~$/ }\n    method string     ($/) { make $\u0026lt;uchar\u0026gt;.made || ~$/ }\n\n    method u_char     ($/) { make $\u0026lt;code_point\u0026gt;.made }\n    method code_point ($/) { make chr( (~$/).parse-base(16) ) }\n    method number     ($/) { make +$/ }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLook at the clunky handling of \u003ccode\u003evalue\u003c/code\u003e. Almost anything can be a value, so the action method does some ham-handed work to figure out which thing just matched. It looks into the possible submatches to find one with a defined value. Well, that’s pretty stupid even if it’s a quick way to get started (although there is some value in the immediate stupid versus the far-off smart).\u003c/p\u003e\n\u003cp\u003eA \u003ccode\u003eproto\u003c/code\u003e rule gets around this by making it easy for you to give different subrules the same name but different patterns. Instead of an alternation you have one token for each:\u003c/p\u003e\n\u003cp\u003e看看笨重的 \u003ccode\u003evalue\u003c/code\u003e 处理。几乎任何东西都可以是一个值，所以 action 方法会做一些简单的工作来弄清楚哪个东西匹配。它查找可能的子匹配以找到具有定义值的子匹配。好吧，即使这是一个快速入门的方式，这也是非常愚蠢的（虽然在愚蠢的直接智能中存在一些价值）。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eproto\u003c/code\u003e 规则可以让您轻松地为不同的子规则赋予相同的名称但不同的模式。不是备选分支，而是每个都有一个 \u003ccode\u003etoken\u003c/code\u003e：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eproto token value { * }\ntoken value:sym\u0026lt;string\u0026gt; { \u0026lt;string\u0026gt; }\ntoken value:sym\u0026lt;number\u0026gt; { \u0026lt;number\u0026gt; }\ntoken value:sym\u0026lt;object\u0026gt; { \u0026lt;object\u0026gt; }\ntoken value:sym\u0026lt;array\u0026gt;  { \u0026lt;array\u0026gt;  }\ntoken value:sym\u0026lt;true\u0026gt;   { \u0026lt;sym\u0026gt;    }\ntoken value:sym\u0026lt;false\u0026gt;  { \u0026lt;sym\u0026gt;    }\ntoken value:sym\u0026lt;null\u0026gt;   { \u0026lt;sym\u0026gt;    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe first \u003ccode\u003eproto\u003c/code\u003e rule matches \u003ccode\u003e*\u003c/code\u003e, which really means it dispatches to another rule in that group. It can dispatch to all of them and find the one that works.\u003c/p\u003e\n\u003cp\u003eSome of these use the special \u003ccode\u003e\u0026lt;sym\u0026gt;\u003c/code\u003e subrule in their pattern. This means that the name of the rule is the literal text to match. The \u003ccode\u003eproto\u003c/code\u003e rule \u003ccode\u003e\u0026lt;true\u0026gt;\u003c/code\u003e matches the literal text \u003ccode\u003etrue\u003c/code\u003e. You don’t have to type that out in the name and the pattern.\u003c/p\u003e\n\u003cp\u003eIt doesn’t matter which of those matches; the grammar calls each of them \u003ccode\u003e$\u0026lt;value\u0026gt;\u003c/code\u003e. The superrule only knows that something that is a value matched and that the subrule handled it appropriately. The action class \u003ccode\u003emake\u003c/code\u003es the right value and stores it in the \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cp\u003e第一个 \u003ccode\u003eproto\u003c/code\u003e 规则匹配 \u003ccode\u003e*\u003c/code\u003e，这实际上意味着它将分派给该组中的另一个规则。它可以发送给所有人并找到有效的。\u003c/p\u003e\n\u003cp\u003e其中一些在其模式中使用特殊的 \u003ccode\u003e\u0026lt;sym\u0026gt;\u003c/code\u003e 子规则。这意味着规则的名称是要匹配的文字文本。 \u003ccode\u003eproto\u003c/code\u003e 规则 \u003ccode\u003e\u0026lt;true\u0026gt;\u003c/code\u003e 匹配文字文本 \u003ccode\u003etrue\u003c/code\u003e。您不必在名称和模式中输入该内容。\u003c/p\u003e\n\u003cp\u003e哪些匹配无关紧要; grammar 调用每个 \u003ccode\u003e$\u0026lt;value\u0026gt;\u003c/code\u003e。超级规则只知道值匹配的东西，并且子规则适当地处理它。 action 类生成正确的值并将其存储在 \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e 中：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eclass JSON::Actions {\n    method TOP    ($/) { make $\u0026lt;value\u0026gt;.made }\n    method object ($/) { make $\u0026lt;string-value-list\u0026gt;.made.hash.item }\n\n    method string-value-list ($/) { make $\u0026lt;string-value\u0026gt;\u0026gt;\u0026gt;.made.flat }\n    method string-value      ($/) {\n        make $\u0026lt;string\u0026gt;.made =\u0026gt; $\u0026lt;value\u0026gt;.made\n        }\n\n    method array  ($/) { make $\u0026lt;list\u0026gt;.made.item }\n    method list   ($/) { make [ $\u0026lt;value\u0026gt;.map: *.made ] }\n\n    method string     ($/) { make $\u0026lt;uchar\u0026gt;.made || ~$/ }\n\n    method value:sym\u0026lt;number\u0026gt; ($/) { make +$/.Str }\n    method value:sym\u0026lt;string\u0026gt; ($/) { make $\u0026lt;string\u0026gt;.made }\n    method value:sym\u0026lt;true\u0026gt;   ($/) { make Bool::True  }\n    method value:sym\u0026lt;false\u0026gt;  ($/) { make Bool::False }\n    method value:sym\u0026lt;null\u0026gt;   ($/) { make Any }\n    method value:sym\u0026lt;object\u0026gt; ($/) { make $\u0026lt;object\u0026gt;.made }\n    method value:sym\u0026lt;array\u0026gt;  ($/) { make $\u0026lt;array\u0026gt;.made }\n\n    method u_char     ($/) { make $\u0026lt;code_point\u0026gt;.made }\n    method code_point ($/) { make chr( (~$/).parse-base(16) ) }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEXERCISE 17.5Implement your own JSON parser (steal all the code you like). Test it against some JSON files to see how well it works. You might like to try the JSON files at [\u003cem\u003ehttps://github.com/briandfoy/json-acceptance-tests\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e练习17.5实现自己的 JSON 解析器（窃取你喜欢的所有代码）。针对某些 JSON 文件进行测试，看看它的工作情况。您可能想在 \u003ca href=\"https//github.com/briandfoy/json-acceptance-tests\"\u003ehttps//github.com/briandfoy/json-acceptance-tests\u003c/a\u003e 上尝试 JSON文件。\u003c/p\u003e\n\u003ch1 id=\"parsing-csv\"\u003eParsing CSV\u003c/h1\u003e\n\u003cp\u003eLet’s parse some comma-separated values (CSV) files. These are tricky because there’s no actual standard (despite \u003ca href=\"https://tools.ietf.org/html/rfc4180\"\u003eRFC 4180\u003c/a\u003e). Microsoft Excel does it one way but some other producers do it slightly differently.\u003c/p\u003e\n\u003cp\u003ePeople often initially go wrong thinking they can merely split the data on a comma character—but that might be part of the literal data in a quoted field. The quote character may also be part of the literal data, but one producer might escape internal quote marks by doubling them, \u003ccode\u003e\u0026quot;\u0026quot;\u003c/code\u003e, while another might use the backslash, \u003ccode\u003e\\\u0026quot;\u003c/code\u003e. People often assume they are line-oriented, but some producers allow unescaped (but quoted!) vertical whitespace. If all of that wasn’t bad enough, what do you do if one line has fewer (or more) fields than the other lines?\u003c/p\u003e\n\u003cp\u003e让我们解析一些逗号分隔值（CSV）文件。这些都很棘手，因为没有实际的标准（尽管有despite \u003ca href=\"https://tools.ietf.org/html/rfc4180\"\u003eRFC 4180\u003c/a\u003e ）。 Microsoft Excel 以一种方式实现，但其他一些生产商则略有不同。\u003c/p\u003e\n\u003cp\u003e最初人们通常认为他们只能按照逗号字符拆分数据 - 但逗号可能是引用字段中字面量数据的一部分。引号字符也可能是字面量数据的一部分，但是有些制作人可能会通过两个双引号 \u003ccode\u003e\u0026quot;\u0026quot;\u003c/code\u003e 来避免内部引号，而另一个可能会使用反斜杠，\u003ccode\u003e\\\u0026quot;\u003c/code\u003e。人们通常认为它们是面向行的，但是一些制作人允许未转义的（但引起来！）垂直空白。如果所有这些都不够糟糕，如果一行的字段少于（或多于）其他行，你会怎么做？\u003c/p\u003e\n\u003ch6 id=\"warning-警告\"\u003eWARNING 警告\u003c/h6\u003e\n\u003cp\u003eDon’t parse CSV files like this. The \u003ccode\u003eText::CSV\u003c/code\u003e module not only parses the format but also tries to correct problems as it goes.\u003c/p\u003e\n\u003cp\u003e不要像这样解析 CSV 文件。 \u003ccode\u003eText::CSV\u003c/code\u003e 模块不仅可以解析格式，还可以尝试纠正问题。\u003c/p\u003e\n\u003cp\u003eStill willing to give it a try? You should find that grammars make most of these concerns tractable:\u003c/p\u003e\n\u003cp\u003e仍然愿意尝试一下？您应该发现 grammar 使大多数这样的问题易于处理：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe ratcheting behavior keeps things simple.\u003c/li\u003e\n\u003cli\u003eYou can easily handle balanced openers and closers (i.e., the quoting stuff).\u003c/li\u003e\n\u003cli\u003eA grammar can inherit other grammars, so you can adjust a grammar based on the data instead of writing one grammar that handles all the data.\u003c/li\u003e\n\u003cli\u003eYou’ve seen action classes, but you can also have action instances that remember extra non-\u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e data.\u003c/li\u003e\n\u003cli\u003eThere’s a \u003ccode\u003e.subparse\u003c/code\u003e method that lets you parse chunks so you can handle one record at a time.\u003c/li\u003e\n\u003cli\u003e棘轮行为使事情变得简单。\u003c/li\u003e\n\u003cli\u003e您可以轻松地处理平衡的开口和闭合（即引用的东西）。\u003c/li\u003e\n\u003cli\u003egrammar 可以继承其他 grammar，因此您可以根据数据调整 grammar，而不是编写一个处理所有数据的 grammar。\u003c/li\u003e\n\u003cli\u003e您已经看过 action 类，但你也可以拥有记住额外非\u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003e匹配\u003c/code\u003e\u003c/a\u003e数据的 action 实例。\u003c/li\u003e\n\u003cli\u003e有一个 \u003ccode\u003e.subparse\u003c/code\u003e 方法，可以让你解析块，这样你就可以一次处理一条记录。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHere’s a simple CSV grammar based off the rules in \u003ca href=\"https://tools.ietf.org/html/rfc4180\"\u003eRFC 4180\u003c/a\u003e. It allows for quoted fields and uses \u003ccode\u003e\u0026quot;\u0026quot;\u003c/code\u003e to escape a literal quote. If a comma, quote, or vertical whitespace appears in the literal data, it must be quoted:\u003c/p\u003e\n\u003cp\u003e这是一个简单的 CSV grammar，基于 \u003ca href=\"https://tools.ietf.org/html/rfc4180\"\u003eRFC 4180\u003c/a\u003e 中的规则。它允许引用的字段并使用 \u003ccode\u003e\u0026quot;\u0026quot;\u003c/code\u003e 来避免字面量引号。如果字面量数据中出现逗号，引号或垂直空格，则必须引起它：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Grammar::CSV {\n    token TOP       { \u0026lt;record\u0026gt;+ }\n    token record    { \u0026lt;value\u0026gt;+ % \u0026lt;.separator\u0026gt; \\R }\n    token separator { \u0026lt;.ws\u0026gt; \u0026#39;,\u0026#39; \u0026lt;.ws\u0026gt; }\n    token value     {\n        \u0026#39;\u0026#34;\u0026#39;             # quoted\n            \u0026lt;( [ \u0026lt;-[\u0026#34;]\u0026gt; | \u0026lt;.escaped-quote\u0026gt; ]* )\u0026gt;\n        \u0026#39;\u0026#34;\u0026#39;\n            |\n        \u0026lt;-[\u0026#34;,\\n\\f\\r]\u0026gt;+  # non-quoted (no vertical ws)\n            |\n            \u0026#39;\u0026#39;          # empty\n        }\n\n    token escaped-quote { \u0026#39;\u0026#34;\u0026#34;\u0026#39; }\n    }\n\nclass CSV::Actions {\n    method record ($/) { make $\u0026lt;value\u0026gt;».made.flat }\n    method value ($/)  {\n        # undo the double double quote\n        make $/.subst( rx/ \u0026#39;\u0026#34;\u0026#34;\u0026#39; /, \u0026#39;\u0026#34;\u0026#39;, :g )\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTry this on entire files. The entire file either satisfies this grammar or doesn’t:\u003c/p\u003e\n\u003cp\u003e在整个文件上试试这个。整个文件要么满足这个 grammar，要么不满足：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy $data = $filename.IO.slurp;\nmy $result = Grammar::CSV.parse( $data );\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou typically don’t want to parse entire files, though. Let’s fix the first part of that problem. You want to process records as you run into them. Instead of using \u003ccode\u003e.parse\u003c/code\u003e, which anchors to the end of the text, you can use \u003ccode\u003e.subparse\u003c/code\u003e, which doesn’t. This means you can parse part of the text then stop.\u003c/p\u003e\n\u003cp\u003eYou can deal with one record at a time. Using \u003ccode\u003e.subparse\u003c/code\u003e with the \u003ccode\u003erecord\u003c/code\u003e rule gets you the first record and only the first record. The \u003ccode\u003e.subparse\u003c/code\u003e method always returns a \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e, unlike \u003ccode\u003e.parse\u003c/code\u003e, which only returns a \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e when it succeeds. You can’t rely on the type of the object as an indication of success:\u003c/p\u003e\n\u003cp\u003e但是，您通常不希望解析整个文件。让我们解决这个问题的第一部分。您希望在遇到记录时处理记录。你可以使用 \u003ccode\u003e.subparse\u003c/code\u003e，而不是使用锚定到文本末尾的 \u003ccode\u003e.parse\u003c/code\u003e，  \u003ccode\u003e.subparse\u003c/code\u003e 不会锚定到文本末尾。这意味着您可以解析部分文本然后停止。\u003c/p\u003e\n\u003cp\u003e您可以一次处理一条记录。将 \u003ccode\u003e.subparse\u003c/code\u003e 与 \u003ccode\u003erecord\u003c/code\u003e 规则一起使用可以获得第一条记录，并且只获得第一条记录。与 \u003ccode\u003e.parse\u003c/code\u003e 不同，\u003ccode\u003e.subparse\u003c/code\u003e 方法总是返回一个 \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e，\u003ccode\u003e.parse\u003c/code\u003e 方法只在成功时返回一个 \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e。你不能依赖对象的类型作为成功的指示：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy $data = $filename.IO.slurp;\nmy $first_result = Grammar::CSV.subparse(\n    $data, :rule(\u0026#39;record\u0026#39;), :action(CSV::Actions)\n    );\nif $first-result { ... }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat works for the first line. Use \u003ccode\u003e:c(N)\u003c/code\u003e to tell these methods where to start in the \u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003eStr\u003c/code\u003e\u003c/a\u003e. You have to know where you want to start. The \u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e knows how far it got; look in the \u003ccode\u003e.from\u003c/code\u003e slot:\u003c/p\u003e\n\u003cp\u003e这适用于第一行。使用 \u003ccode\u003e:c(N)\u003c/code\u003e 告诉这些方法在 \u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003e字符串\u003c/code\u003e\u003c/a\u003e中从哪里开始。你必须知道你想要从哪里开始。\u003ca href=\"https://docs.raku.org/type/Match.html\"\u003e\u003ccode\u003eMatch\u003c/code\u003e\u003c/a\u003e 知道它进行了多远;看看 \u003ccode\u003e.from\u003c/code\u003e 插槽：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy $data  = $filename.IO.slurp;\n\nloop {\n    state $from = 0;\n    my $match = Grammar::CSV.subparse(\n        $data,\n        :rule(\u0026#39;record\u0026#39;),\n        :actions(CSV::Actions),\n        :c($from)\n        );\n    last unless $match;\n\n    put \u0026#34;Matched from {$match.from} to {$match.to}\u0026#34;;\n    $from = $match.to;\n    say $match;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is most of the way to a solution—it fails to go through the entire file if \u003ccode\u003e.subparse\u003c/code\u003e fails on one record. With some boring monkey work you could fix this to find the start of the next record and restart the parsing, but that’s more than I want to fit in this book.\u003c/p\u003e\n\u003cp\u003e这是解决方案的大部分方法 - 如果 \u003ccode\u003e.subparse\u003c/code\u003e 在一条记录上失败，则无法遍历整个文件。使用一些无聊的猴子工作，你可以修复这个问题，找到下一条记录的开始并重新开始解析，但这比我想要适应本书更多。\u003c/p\u003e\n\u003ch2 id=\"adjusting-the-grammar\"\u003eAdjusting the Grammar\u003c/h2\u003e\n\u003cp\u003eYou thought the problem was solved. Then, someone sent you a file with a slightly different format. Instead of escaping a \u003ccode\u003e\u0026quot;\u003c/code\u003e by doubling it, the new format uses the backslash.\u003c/p\u003e\n\u003cp\u003eNow your existing grammar fails to parse. You don’t have a rule that satisfies that type of escape because you didn’t need it for your grammar. As a matter of practice in both patterns and grammars, only match what you should match. Be liberal in what you accept in other ways, such as making a subgrammar to handle the new case:\u003c/p\u003e\n\u003cp\u003e你以为问题已经解决了。然后，有人给你发送了一个格式略有不同的文件。新格式使用反斜杠，而不是使用两个引号转义 \u003ccode\u003e\u0026quot;\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e现在你现有的 grammar 解析失败。您没有满足该类型的转义的规则，因为您的 grammar 不需要它。作为模式和 grammar 的练习，只匹配你应该匹配的内容。在其他方面随心所欲，例如制作一个子 grammar 来处理新案例：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Grammar::CSV::Backslashed is Grammar::CSV {\n    token escaped-quote { \u0026#39;\\\\\u0026#34;\u0026#39; }\n    }\n\nclass CSV::Actions::Backslashed is CSV::Actions {\n    method value ($/)  { make $/.subst( rx/ \u0026#39;\\\\\u0026#34;\u0026#39; /, \u0026#39;\u0026#34;\u0026#39;, :g ) }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWith two grammars, how do you get the one that you need to use? The name interpolation \u003ccode\u003e::($\u003c/code\u003e\u003cem\u003ename\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e comes in handy here:\u003c/p\u003e\n\u003cp\u003e有两个 grammar，你如何得到你需要使用的那个？\u003ccode\u003e::($\u003c/code\u003e\u003cem\u003ename\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e 在这里派上用场：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy %formats;\n%formats\u0026lt;doubled\u0026gt; = {\n    \u0026#39;file\u0026#39;    =\u0026gt; $*SPEC.catfile( \u0026lt;corpus test.csv\u0026gt; ),\n    \u0026#39;grammar\u0026#39; =\u0026gt; \u0026#39;Grammar::CSV\u0026#39;,\n    };\n%formats\u0026lt;backslashed\u0026gt; = {\n    \u0026#39;file\u0026#39; =\u0026gt; $*SPEC.catfile( \u0026lt;corpus test-backslash.csv\u0026gt; ),\n    \u0026#39;grammar\u0026#39; =\u0026gt; \u0026#39;Grammar::CSV::Backslashed\u0026#39;,\n    };\n\nfor %formats.values -\u0026gt; $hash {\n    $hash\u0026lt;data\u0026gt; = $hash\u0026lt;file\u0026gt;.IO.slurp;\n    my $class = (require ::( $hash\u0026lt;grammar\u0026gt; ) );\n    my $match = $class.parse( $hash\u0026lt;data\u0026gt; );\n    say \u0026#34;{$hash\u0026lt;file\u0026gt;} with {$hash\u0026lt;grammar\u0026gt;} \u0026#34;,\n        $match ?? \u0026#39;parsed\u0026#39; !! \u0026#39;failed\u0026#39;;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003e%formats\u003c/code\u003e \u003ca href=\"https://docs.raku.org/type/Hash.html\"\u003e\u003ccode\u003eHash\u003c/code\u003e\u003c/a\u003e of \u003ca href=\"https://docs.raku.org/type/Hash.html\"\u003e\u003ccode\u003eHash\u003c/code\u003e\u003c/a\u003ees stores the filenames and the grammars for them. You can load a grammar and use it to parse the data without the explicit grammar name:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e%formats\u003c/code\u003e \u003ca href=\"https://docs.raku.org/type/Hash.html\"\u003e\u003ccode\u003e散列\u003c/code\u003e\u003c/a\u003e的\u003ca href=\"https://docs.raku.org/type/Hash.html\"\u003e\u003ccode\u003e散列\u003c/code\u003e\u003c/a\u003e存储文件名和 grammar。您可以加载 grammar 并使用它来解析数据而不使用显式的 grammar 名称：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ecorpus/test.csv with Grammar::CSV parsed\ncorpus/test-backslash.csv with Grammar::CSV::Backslashed parsed\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat mostly solves the problem, although there are plenty of special cases that this doesn’t cover.\u003c/p\u003e\n\u003cp\u003e这主要解决了这个问题，尽管有很多特殊情况并没有涵盖。\u003c/p\u003e\n\u003ch2 id=\"using-roles-in-grammars\"\u003eUsing Roles in Grammars\u003c/h2\u003e\n\u003cp\u003eRoles can supply rules and methods that grammars can use. In the previous section you handled different sorts of double-quote escaping through inheritance, where you overrode the rule. You can do the same thing with roles.\u003c/p\u003e\n\u003cp\u003eA grammar can have methods and subroutines. The way you declare a name with \u003ccode\u003esub\u003c/code\u003e, \u003ccode\u003emethod\u003c/code\u003e, or \u003ccode\u003erule\u003c/code\u003e tells the language parser (not your grammar!) how to parse the stuff in the \u003ca href=\"https://docs.raku.org/type/Block.html\"\u003e\u003ccode\u003eBlock\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eFirst, adjust the main grammar to have a stub method for \u003ccode\u003e\u0026lt;escaped-quote\u0026gt;\u003c/code\u003e. This forces something else to define it:\u003c/p\u003e\n\u003cp\u003e角色可以提供 grammar 可以使用的规则和方法。在上一节中，您通过继承处理了不同类型的双引号转义，其中您重写了规则。你可以用角色做同样的事情。\u003c/p\u003e\n\u003cp\u003eGrammar 可以有方法和子程序。使用 \u003ccode\u003esub\u003c/code\u003e，\u003ccode\u003emethod\u003c/code\u003e或 \u003ccode\u003erule\u003c/code\u003e 声明名称的方式告诉语言解析器（而不是 grammar！）如何解析\u003ca href=\"https://docs.raku.org/type/Block.html\"\u003e\u003ccode\u003e块\u003c/code\u003e\u003c/a\u003e中的东西。\u003c/p\u003e\n\u003cp\u003e首先，调整主 grammar，使其具有 \u003ccode\u003e\u0026lt;escaped-quote\u0026gt;\u003c/code\u003e 的存根方法。这迫使别人定义它：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egrammar Grammar::CSV {\n     token TOP       { \u0026lt;record\u0026gt;+ }\n     token record    { \u0026lt;value\u0026gt;+ % \u0026lt;.separator\u0026gt; \\R }\n     token separator { \u0026lt;.ws\u0026gt; \u0026#39;,\u0026#39; \u0026lt;.ws\u0026gt; }\n     token value     {\n         \u0026#39;\u0026#34;\u0026#39;             # quoted\n             \u0026lt;( [ \u0026lt;-[\u0026#34;]\u0026gt; | \u0026lt;.escaped-quote\u0026gt; ]* )\u0026gt;\n         \u0026#39;\u0026#34;\u0026#39;\n             |\n         \u0026lt;-[\u0026#34;,\\n\\f\\r]\u0026gt;+  # non-quoted (no vertical ws)\n             |\n             \u0026#39;\u0026#39;          # empty\n         }\n\n     # stub that you must define in a role\n     method escaped-quote { !!! }\n     }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eA role will fill in that stub method. There’s one role for each way to escape the double quote:\u003c/p\u003e\n\u003cp\u003e角色将填充该存根方法。每种方式都有一个角色来转义双引号：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003erole DoubledQuote     { token escaped-quote { \u0026#39;\u0026#34;\u0026#34;\u0026#39;  } }\nrole BackslashedQuote { token escaped-quote { \u0026#39;\\\\\u0026#34;\u0026#39; } }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen it’s time to parse a file you can choose which role you want to use. You can create a new object for \u003ccode\u003eGrammar::CSV\u003c/code\u003e and apply the appropriate role to it:\u003c/p\u003e\n\u003cp\u003e在解析文件时，您可以选择要使用的角色。您可以为 \u003ccode\u003eGrammar::CSV\u003c/code\u003e 创建一个新对象并将适当的角色应用于它：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy $filename   = ...;\nmy $csv-data   = $filename.IO.slurp;\nmy $csv-parser = Grammar::CSV.new but DoubledQuote;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUse that object to parse your data:\u003c/p\u003e\n\u003cp\u003e使用该对象解析数据：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy $match = $csv-parser.parse: $csv-data;\nsay $match // \u0026#39;Failed!\u0026#39;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDoing this doesn’t fix the double quotes in the data—a \u003ccode\u003e\u0026quot;\u0026quot;\u003c/code\u003e stays as a \u003ccode\u003e\u0026quot;\u0026quot;\u003c/code\u003e—but you can fix that in an action class.\u003c/p\u003e\n\u003cp\u003eEXERCISE 17.6Adjust the CSV example to use roles instead of inheritance. Create an action class to adjust the escaped double quotes as you run into them. You can start with \u003cem\u003eGrammars/test.csv\u003c/em\u003e from the downloads section of \u003ca href=\"https://www.learningraku.com/\"\u003ethe book’s website\u003c/a\u003e if you like.\u003c/p\u003e\n\u003cp\u003e这样做不会修复数据中的双引号 -  \u003ccode\u003e\u0026quot;\u0026quot;\u003c/code\u003e 保留为 \u003ccode\u003e\u0026quot;\u0026quot;\u003c/code\u003e - 但您可以在 action 类中修复它。\u003c/p\u003e\n\u003cp\u003e练习17.6 调整 CSV 示例以使用角色而不是继承。创建一个 action 类，以便在遇到它们时调整转义的双引号。如果您愿意，可以从本书网站的下载部分 Grammars/ test.csv 开始。\u003c/p\u003e\n\u003ch1 id=\"summary\"\u003eSummary\u003c/h1\u003e\n\u003cp\u003eGrammars are one of the killer features of the language. You can define complex relationships between patterns and use action classes to run arbitrarily complex code when something matches. You might find that your entire program ends up being one big grammar.\u003c/p\u003e\n\u003cp\u003eGrammars 是 Raku 语言的杀手级特性之一。您可以定义模式之间的复杂关系，并在匹配时使用 action 类来运行任意复杂的代码。您可能会发现整个程序最终变成一个大的 grammar。\u003c/p\u003e\n","text":"声明 本章翻译仅用于 Raku 学习和研究, 请支持电子版或纸质版。\n第十七章. Grammars Grammars are patterns on a higher plane of existence. They integrate and reuse pattern fragments to parse and react to complicated formats. This feature is at the core of Raku in a very literal sense; the language itself is implemented as a grammar. Once you start using it you’ll probably prefer it to regexes for all but the most simple problems.\nGrammars 是存在于更高层面上的模式。它们集成并重用模式片段来解析复杂的格式并做出反应。从字面意义上讲，这个功能是Raku的核心;语言本身是作为语法实现的。一旦你开始使用它，你可能更喜欢它除了最简单的问题之外的所有正则表达式。\nA Simple Grammar A grammar is a special sort of package. It can have methods and subroutines but mostly comprises special pattern methods called regex, token, and rule. Each of these define a pattern and apply different modifiers.\nNOTE Raku tends to refer to regex, token, and rule declarations as “rules,” which can be a bit imprecise at times. In this book, you can tell the difference between the language keyword and the general term by the typesetting. I’ll try to not present an ambiguous situation.\nStart with something simple (too simple for grammars). Define a TOP pattern that matches digits as the starting point. That name is special because .parse uses it by default. In this example, you declare that with regex:\nGrammar 是一种特殊的包。它可以有方法和子程序，但主要包括称为 regex，token 和 rule 的特殊模式方法。其中每个都定义了一个模式并应用了不同的修饰符。\n注意 Raku 倾向于将 regex，token 和 rule 声明称为“规则”，有时可能有点不精确。在本书中，您可以通过排版来区分语言关键字和一般术语。我会尽量不提出模棱两可的情况。\n从简单的东西开始（对于 grammar 来说太简单了）。定义匹配数字作为起点的 TOP 模式。该名称很特殊，因为 .parse 默认使用它。在此示例中，您使用 regex 声明一个 TOP：\ngrammar Number { regex TOP { \\d } } my $result = Number.parse( \u0026#39;7\u0026#39; ); # works put $result ?? \u0026#39;Parsed!\u0026#39; !! \u0026#39;Failed!\u0026#39;; # Parsed! This succeeds. .parse applies the grammar to the entire value of 7. It starts with the parts that TOP describes. It can match a digit, and the value you pass to .parse is a digit.\nWhen .parse succeeds, it returns a Match object (it returns Nil when it fails). Try it with a different value. Instead of a single digit, try several digits:\n这成功了。 .parse 将 grammar 应用于整个值 7. 它从 TOP 描述的部分开始。它可以匹配一个数字，你传递给 .parse 的值是一个数字。\n当 .parse 成功时，它返回一个 Match 对象（当它失败时返回 Nil）。尝试使用不同的值。尝试几个数字而不是单个数字：\nmy $result = Number.parse( \u0026#39;137\u0026#39; ); # fails (extra digits) put $result ?? \u0026#39;Parsed!\u0026#39; !! \u0026#39;Failed!\u0026#39;; # Failed! This time .parse doesn’t succeed. It starts matching with the first character and ends matching on the last character. It asserts that the text starts, there is a single digit, and the text ends. If .parse sees that there are some characters before or after its match, it fails. It matches everything or not at all. It’s almost the same thing as explicitly using anchors:\n这次 .parse 没有成功。它开始与第一个字符匹配，并在最后一个字符上结束匹配。它断言文本开始，有一个数字，文本结束。如果 .parse 看到匹配之前或之后有一些字符，则会失败。它匹配全部或根本不匹配。它与显式地使用锚点几乎相同：\ngrammar Number { regex TOP { ^ \\d+ $ } # explicitly anchored } But TOP is only the default starting point for a grammar. You can tell .parse where you’d like to start. This version defines the same pattern but calls it digits instead of TOP:\n但 TOP 是仅有的 grammar 的默认起点。你可以告诉 .parse 你想要开始的地方。此版本定义相同的模式但称为 digits 而不是 TOP：\ngrammar Number { regex digits { \\d+ } } Tell .parse where to start with the :rule named argument:\n使用 :rule 命名参数告诉 .parse 从哪里开始：\nmy @strings = \u0026#39;137\u0026#39;, \u0026#39;137 \u0026#39;, \u0026#39; 137 \u0026#39;; for @strings -\u0026gt; $string { my $result = Number.parse( $string, :rule\u0026lt;digits\u0026gt; ); put \u0026#34;｢$string｣ \u0026#34;, $result ?? \u0026#39;Parsed!\u0026#39; !! \u0026#39;Failed!\u0026#39;; } The first element of @strings parses because it is only digits. The other ones fail because they have extra characters:\n@strings 的第一个元素解析成功了因为它只是数字。其他的失败了因为他们有额外的字符：\n｢137｣ parsed! ｢137 ｣ failed! ｢ 137 ｣ failed! Declare digits with rule instead of regex. This implicitly allows whitespace after any part of your pattern:\n使用 rule 而不是 regex 声明 digits。这隐式地允许在模式的任何部分之后有空格：\ngrammar Number { rule digits { \\d+ } # not anchored, and works } Now the second Str matches too because the implicit whitespace can match the space at the end (but not the beginning):\n现在第二个 Str 也匹配，因为隐式空格可以匹配末尾的空格（但不是开头）：\n｢137｣ parsed! ｢137 ｣ parsed! ｢ 137 ｣ failed! The rule applies :sigspace to its pattern. It’s the same thing as adding that adverb to the pattern:\n该 rule 将 :sigspace 应用到其模式。将该副词添加到模式中是一回事：\ngrammar Number { regex digits { :sigspace \\d+ } } :sigspace inserts the predefined \u0026lt;.ws\u0026gt; after pattern tokens. Since there’s a dot before the name ws, the \u0026lt;.ws\u0026gt; does not create a capture. It’s the same as adding optional whitespace explicitly:\n:sigspace在模式标记之后插入预定义的 \u0026lt;.ws\u0026gt;。由于名称 ws 之前有一个点号，\u0026lt;.ws\u0026gt; 不会创建捕获。它与显式添加可选空格相同：\ngrammar Number { regex digits { \\d+ \u0026lt;.ws\u0026gt; } } Instead of showing Parsed!, you can on success output the Match object you stored in $result:\n您可以在成功输出存储在 $result 中的 Match 对象，而不是显示 Parsed!\ngrammar Number { regex digits { \\d+ \u0026lt;.ws\u0026gt; } } my @strings = \u0026#39;137\u0026#39;, \u0026#39;137 \u0026#39;, \u0026#39; 137 \u0026#39;; for @strings -\u0026gt; $string { my $result = Number.parse( $string, :rule\u0026lt;digits\u0026gt; ); put $result ?? $result !! \u0026#39;Failed!\u0026#39;; } The output isn’t that different, but instead of its success status you see the text that matched:\n输出没有那么不同，但您可以看到匹配到的文本，而不是其成功状态：\n｢137｣ ｢137 ｣ Failed! Modify the grammar to remove that dot from \u0026lt;.ws\u0026gt; so it captures whitespace and try again:\n修改 grammar 以从 \u0026lt;.ws\u0026gt; 中删除该点号，以便捕获空格并再次尝试：\ngrammar Number { regex digits { \\d+ \u0026lt;ws\u0026gt; } } Now the output shows the nested levels of named captures:\n现在输出显示了命名捕获的嵌套级别：\n｢137｣ ws =\u0026gt; ｢｣ ｢137 ｣ ws =\u0026gt; ｢ ｣ Failed! This still doesn’t match the Str with leading whitespace. The parser couldn’t match that since rule only inserts \u0026lt;.ws\u0026gt; after explicit parts of the pattern. To match leading whitespace you need to add something to the front of the pattern. The beginning-of-string anchor does that, and now there’s something that \u0026lt;.ws\u0026gt; can come after:\n这仍然与带有前导空格的 Str 不匹配。解析器无法匹配，因为 rule 仅在模式的显式部分之后插入 \u0026lt;.ws\u0026gt;。要匹配前导空格，您需要在模式的前面添加一些内容。字符串开头的锚点就是这样，现在有一些 \u0026lt;.ws\u0026gt; 后面可以出现的东西：\ngrammar Number { rule digits { ^ \\d+ } # ^ \u0026lt;.ws\u0026gt; \\d+ \u0026lt;.ws\u0026gt; } There’s also the zero-width always-matches token, \u0026lt;?\u0026gt;:\n还有零宽度始终匹配的 token 标记，\u0026lt;?\u0026gt;：\ngrammar Number { rule digits { \u0026lt;?\u0026gt; \\d+ } # \u0026lt;?\u0026gt; \u0026lt;.ws\u0026gt; \\d+ \u0026lt;.ws\u0026gt; } Most of the time you don’t want to play these games. If you want leading whitespace, you can note that explicitly (and you probably don’t want to capture it):\n大多数时候你不想玩这些游戏。如果你想要前导空格，你可以显式地注意到（并且你可能不想捕获它）：\ngrammar Number { rule digits { \u0026lt;.ws\u0026gt; \\d+ } # \u0026lt;.ws\u0026gt; \\d+ \u0026lt;.ws\u0026gt; } Use token instead of rule if you don’t want any implicit whitespace:\n如果您不想要任何隐式空格，请使用 token 而不是 rule：\ngrammar Number { token digits { \\d+ } # just the digits } You’ll see another feature of rule and token later in this chapter.\n您将在本章后面看到 rule 和 token 的另一个功能。\nEXERCISE 17.1Write a grammer to match octal digits, with or without a leading 0 or 0o. Your grammar should parse numbers such as 123, 0123, and 0o456, but not 8, 129, or o345.\n练习17.1写一个 grammar 来匹配八进制数字，带或不带前导 0 或 0o。您的 grammar 应该解析诸如 123, 0123 和 0o456 之类的数字，但不能解析 8 ,129 或 o345。\nMultiple Rules Grammars wouldn’t be useful if you were limited to one rule. You can define additional rules and use them inside other rules. In the first exercise you had only the TOP rule but you could separate the pattern into parts. Break up the pattern in TOP into rules for prefix and digits. It’s this decomposability that makes it so easy to solve hard parsing problems:\n如果你只限于一条规则，那么 grammar 就没用了。您可以定义其他规则并在其他规则中使用它们。在第一个练习中，您只有 TOP 规则，但您可以将模式分成几部分。将 TOP 中的模式分解为 prefix和digits的规则。正是这种可分解性使得解决困难的解析问题变得如此简单：\ngrammar OctalNumber { regex TOP { \u0026lt;prefix\u0026gt;? \u0026lt;digits\u0026gt; } regex prefix { [ 0o? ] } regex digits { \u0026lt;[0..7]\u0026gt;+ } } my $number = \u0026#39;0o177\u0026#39;; my $result = OctalNumber.parse( $number ); say $result // \u0026#34;failed\u0026#34;; The stringified Match object shows the overall match and the named subcaptures:\n字符串化的 Match 对象显示整体匹配和命名的子捕获：\n｢0o177｣ prefix =\u0026gt; ｢0o｣ digits =\u0026gt; ｢177｣ You can access the pieces:\n你可以访问这些部分：\nput \u0026#34;Prefix: $result\u0026lt;prefix\u0026gt;\u0026#34;; put \u0026#34;Digits: $result\u0026lt;digits\u0026gt;\u0026#34;; EXERCISE 17.2Create a grammar to match a Raku variable name with a sigil (ignore sigilless variables, because that’s too easy). Use separate rules to match the sigil and the identifier. Here is a list of candidates to check if you don’t come up with your own:my @candidates = qw/ sigilless $scalar @array %hash $123abc $abc'123 $ab'c123 $two-words $two- $-dash /;\nYou can suppress some of those named captures by prefixing the rule with a dot. You probably don’t care about the prefix, so don’t save it:\n练习17.2 创建一个 grammar，匹配带有 sigil 的 Raku 变量名（忽略无符号变量，因为这太简单了）。使用单独的规则来匹配 sigil 和标识符。这是一个候选人列表，检查你是否没有自己的：my @candidates = qw/ sigilless $scalar @array %hash $123abc $abc'123 $ab'c123 $two-words $two- $-dash /;\n您可以通过在规则前加一个点号来抑制某些命名捕获。您可能不关心前缀，所以不要保存它：\ngrammar OctalNumber { regex TOP { \u0026lt;.prefix\u0026gt;? \u0026lt;digits\u0026gt; } regex prefix { [ 0o? ] } regex digits { \u0026lt;[0..7]\u0026gt;+ } } my $number = \u0026#39;0o177\u0026#39;; my $result = OctalNumber.parse( $number ); say $result // \u0026#34;failed\u0026#34;; The output doesn’t include the prefix information:\n输出不包含前缀信息：\n｢0o177｣ digits =\u0026gt; ｢177｣ This doesn’t make much of a difference in this small example, but imagine a complicated grammar with many, many rules. That brings you to the next big feature of grammars. Besides the grammar itself, you can specify an action class that processes the rules as the grammar successfully parses them.\n这在这个小例子中并没有太大的区别，但想象一下复杂的 grammar 有很多很多规则。这将带您进入 grammar 的下一个重要特征。除 grammar 本身外，您还可以指定一个 action 类来处理规则，因为 grammar 会成功解析它们。\nDebugging Grammars There are two modules that can help you figure out what’s going on in your grammar. Both are much more impressive in your terminal.\n有两个模块可以帮助您弄清楚 grammar 中发生了什么。两者在你的终端中都更令人印象深刻。\nGrammar::Tracer The Grammar::Tracer module shows you the path through a grammar (and applies to any grammar in its scope). Merely loading the module is enough to activate it:\nGrammar::Tracer 模块向您显示 grammar 的路径（并适用于其作用域内的任何 grammar）。仅加载模块就足以激活它：\nuse Grammar::Tracer; grammar OctalNumber { regex TOP { \u0026lt;prefix\u0026gt;? \u0026lt;digits\u0026gt; } regex prefix { [ 0o? ] } regex digits { \u0026lt;[0..7]\u0026gt;+ } } my $number = \u0026#39;0o177\u0026#39;; $/ = OctalNumber.parse( $number ); say $/ // \u0026#34;failed\u0026#34;; The first part of the output is the trace. It shows which rule it’s in and the result. In this example each one matches:\n输出的第一部分是跟踪。它显示了它所在的规则和结果。在这个例子中，每个规则都匹配：\nTOP | prefix | * MATCH \u0026#34;0o\u0026#34; | digits | * MATCH \u0026#34;177\u0026#34; * MATCH \u0026#34;0o177\u0026#34; ｢0o177｣ prefix =\u0026gt; ｢0o｣ digits =\u0026gt; ｢177｣ Changing the data to include invalid digits, such as 0o178, means the grammar will fail. In the trace you can see it matches up to 0o17 but can’t continue, so you know where in your Str things went wrong. It could be that the grammar should not match the text or the grammar is not as accommodating as it should be:\n更改数据以包含无效数字（例如 0o178）意味着 grammar 将失败。在跟踪中，您可以看到它最多匹配到 0o17 但无法继续，因此你就知道 Str 中的哪些地方出错了。可能是 grammar 不应该与文本匹配，或者 grammar 不应该像它应该的那样适应：\nTOP | prefix | * MATCH \u0026#34;0o\u0026#34; | digits | * MATCH \u0026#34;17\u0026#34; * MATCH \u0026#34;0o17\u0026#34; digits * FAIL digits * MATCH \u0026#34;0\u0026#34; failed Instead of adding Grammar::Tracer to your program you can load it from the command line with the -Mswitch. You probably don’t mean to leave it in anyway:\n您可以使用 -M 开关从命令行加载 Grammar::Tracer，而不是将 Grammar::Tracer 添加到程序中。你可能并不是故意把它留下来：\n% raku -MGrammar::Tracer program.p6 Grammar::Debugger The Grammar::Debugger module does the same thing as Grammar::Tracer (they come together in the same distribution) but allows you to proceed one step at a time. When you start it you get a prompt; type h to get a list of commands:\nGrammar::Debugger 模块与 Grammar::Tracer （它们在同一个发行版中）执行相同的操作，但允许您一次执行一个步骤。当你启动它时，你得到一个提示; 键入 h 以获取命令列表：\n% raku -MGrammar::Debugger test.p6 TOP \u0026gt; h r run (until breakpoint, if any) \u0026lt;enter\u0026gt; single step rf run until a match fails r \u0026lt;name\u0026gt; run until rule \u0026lt;name\u0026gt; is reached bp add \u0026lt;name\u0026gt; add a rule name breakpoint bp list list all active rule name breakpoints bp rm \u0026lt;name\u0026gt; remove a rule name breakpoint bp rm removes all breakpoints q quit Typing Enter with no command single-steps through the parse process and gives you a chance to inspect the text and the state of the parser. The rf command will get you to the next failing rule:\n在没有命令的情况下键入回车键单步执行解析过程，并让你有机会检查文本和解析器的状态。 rf 命令会使你进入下一个失败的规则：\n\u0026gt; rf | prefix | * MATCH \u0026#34;0o\u0026#34; | digits | * MATCH \u0026#34;17\u0026#34; * MATCH \u0026#34;0o17\u0026#34; digits * FAIL \u0026gt; A Simple Action Class A grammar does its work by descending into its rules to take apart text. You can go the opposite way by processing each part of the parsed text to build a new Str (or data structure, or whatever you like). You can tell .parse to use an action class to do this.\ngrammar 通过下降到它的规则中分解文本来完成其工作。你可以通过处理已解析文本的每个部分来构建新的 Str（或数据结构，或任何您喜欢的任何内容）。您可以告诉 .parse 使用 action 类来执行此操作。\nHere’s a simple action class, OctalActions. It doesn’t need to have the same name as the grammar, but the method names are the same as the rule names. Each method takes a Match object argument. In this example, the signature uses $/, which is a variable with a few advantages that you’ll see in a moment:\n这是一个简单的 action 类 OctalActions。它不需要与 grammar 具有相同的名称，但方法名称与规则名称相同。每个方法都接收 Match 对象参数。在此示例中，签名使用 $/，这是一个具有一些优势的变量，稍后你将看到：\nclass OctalActions { method digits ($/) { put \u0026#34;Action class got $/\u0026#34; } } grammar OctalNumber { regex TOP { \u0026lt;.prefix\u0026gt;? \u0026lt;digits\u0026gt; } regex prefix { [ 0o? ] } regex digits { \u0026lt;[0..7]\u0026gt;+ } } Tell .parse which class to use with the :actions named parameter. The name does not need to correspond to the grammar:\n使用 :actions 命名参数告诉 .parse 使用哪个类。该名称不需要与 grammar 对应：\nmy $number = \u0026#39;0o177\u0026#39;; my $result = OctalNumber.parse( $number, :actions(OctalActions) ); say $result // \u0026#34;failed\u0026#34;; This action class doesn’t do much. When the digits rule successfully matches it triggers the rule of the same name in the action class. That method merely outputs the argument:\n这个 action 类做的不多。当 digits 规则成功匹配时，它会触发 action 类中相同名称的规则。该方法仅输出参数：\nAction class got 177 ｢0o177｣ digits =\u0026gt; ｢177｣ EXERCISE 17.3Implement your own action class for the OctalNumber grammar. When the digits method matches, output the decimal version of the number. The parse-base routine from Str may be useful. For extra credit, take one number per line from standard input and turn them into decimal numbers.\n练习17.3 为 OctalNumber grammar 实现自己的 action 类。当 digits 方法匹配时，输出数字的十进制版本。 Str 的 parse-base 例程可能很有用。如需额外学分，请从标准输入中每行获取一个数字并将其转换为十进制数字。\nCreating an Abstract Syntax Tree Actions shouldn’t output information directly. Instead, they can add values to the Match object. Calling makein the action method sets a value in the abstract syntax tree (or .ast) slot of the Match. You can access that with .made:\nAction 不应直接输出信息。相反，他们可以向 Match 对象添加值。在 action 方法中调用 make 会在 Match 的抽象语法树（或 .ast ）槽中设置一个值。您可以使用 .made 访问它：\nclass OctalActions { method digits ($/) { make parse-base( ~$/, 8 ) # must stringify $/ } } grammar OctalNumber { regex TOP { \u0026lt;.prefix\u0026gt;? \u0026lt;digits\u0026gt; } regex prefix { [ 0o? ] } regex digits { \u0026lt;[0..7]\u0026gt;+ } } my $number = \u0026#39;0o177\u0026#39;; my $result = OctalNumber.parse( $number, :actions(OctalActions) ); put $result ?? \u0026#34;Turned ｢{$result\u0026lt;digits\u0026gt;}｣ into ｢{$result\u0026lt;digits\u0026gt;.made}｣\u0026#34; !! \u0026#39;Failed!\u0026#39;; The make puts something into the .ast slot of the Match and .made gets it back out. You can make any value that you like, including containers, objects, and most other things you can imagine. You still get the original, literal match.\nIn the previous example, the digits action method handled the value. A TOP action method could do it, but it has to reach one level below the Match object:\nmake 将一些内容放入Match的 .ast 插槽中，然后 .made 将其恢复原状。您可以make 任何您喜欢的值，包括容器，对象和您可以想象的大多数其他内容。你仍然得到原始的，字面上的匹配。\n在前面的示例中，digits action 方法处理了该值。 TOP action 方法可以做到，但它必须到达 Match 对象下面的一个级别：\nclass OctalActions { method digits ($/) { make parse-base( ~$/, 8 ) # must stringify $/ } } grammar OctalNumber { regex TOP { \u0026lt;.prefix\u0026gt;? \u0026lt;digits\u0026gt; } regex prefix { [ 0o? ] } regex digits { \u0026lt;[0..7]\u0026gt;+ } } my $number = \u0026#39;0o177\u0026#39;; my $result = OctalNumber.parse( $number, :actions(OctalActions) ); put $result.so ?? \u0026#34;Turned ｢{$number}｣ into ｢{$result.made}｣\u0026#34; !! \u0026#39;Failed!\u0026#39;; You don’t have to use $/ in the signature; it’s a convenience. There’s nothing particularly magical about it. You could use some other variable if you are paid by the character:\n您不必在签名中使用 $/; 这是一个方便写法。它没什么特别神奇的。如果你有其它字符，您可以使用其他变量：\nclass OctalActions { method TOP ($match) { make parse-base( ~$match\u0026lt;digits\u0026gt;, 8 ) } } EXERCISE 17.4Create a grammar to parse a four-part, dotted-decimal IP address, such as 192.168.1.137. Create an action class that turns the parse results into a 32-bit number. Output that 32-bit number in hexadecimal.\n练习17.4 创建一个 grammar 来解析一个由四部分组成的点分十进制 IP 地址，例如 192.168.1.137。创建一个 action 类，将解析结果转换为32位数。以十六进制输出那个32位数。\nRatcheting The rule and token declarators have a feature that regex doesn’t; they both prevent backtracking by implicitly setting the :ratchet adverb. Once one of those rules matches they don’t backtrack to try again if there’s a failure later in the grammar.\nHere’s a nonsense grammar that includes a rule \u0026lt;some-stuff\u0026gt; that matches one or more of any character. The TOP token wants to match digits surrounded by unspecified stuff:\nrule 和 token 声明符具有 regex 不具有的功能;他们都通过隐式设置 :ratchet 副词来阻止回溯。一旦这些规则中的一个匹配，如果在 grammar 中稍后出现失败，则它们不会回溯以再次尝试。\n这是一个无意义的 grammar，其中包含能匹配一个或多个字符的 \u0026lt;some-stuff\u0026gt; 规则。 TOP token 想要匹配由未指定的东西包围的数字：\ngrammar Stuff { token TOP { \u0026lt;some-stuff\u0026gt; \u0026lt;digits\u0026gt; \u0026lt;some-stuff\u0026gt; } token digits { \\d+ } token some-stuff { .+ } } This Str could satisfy that pattern. It has stuff, some digits, and more stuff:\n这个字符串可以满足这种模式。它有东西，一些数字和更多的东西：\nmy $string = \u0026#39;abcdef123xyx456\u0026#39;; But, Stuff fails to parse it:\n但是，Stuff 无法解析它：\nmy $result = Stuff.parse( $string ); put \u0026#34;｢$string｣ \u0026#34;, $result ?? \u0026#39;Parsed!\u0026#39; !! \u0026#39;Failed!\u0026#39;; # Failed! It’s the :ratchet that makes it fail. Work out its path to see why. TOP has to first match \u0026lt;some-stuff\u0026gt;. That matches any character one or more times, greedily—it matches the entire text. TOP next needs to match\u0026lt;digits\u0026gt;, but there is nothing left to match because of that greediness. Without :ratchet the pattern might roll back some of the characters it already consumed. With :ratchet it doesn’t do that. The grammar can’t match the rest of TOP and it fails.\nWithout :ratchet the situation is different. If you use regex instead of token, you allow the grammar to give back characters it has already matched:\n是 :ratchet 使它失败的。找出原因，看看为什么。 TOP 必须首先匹配 \u0026lt;some-stuff\u0026gt;。这匹配任何一个字符一次或多次，贪婪地 - 它匹配整个文本。 TOP 接着需要匹配 \u0026lt;digits\u0026gt;，但由于这种贪婪，没有什么可以匹配的了。如果没有 :ratchet 模式可能会回滚它已经消耗的一些字符。使用 :ratchet 它不会那样做。Grammar 不能匹配 TOP 的其余部分，所以失败了。\n没有 :ratchet 的情况是不同的。如果使用 regex 而不是 token，则允许 grammar 归还已匹配的字符：\ngrammar Stuff { # regex does not turn on ratcheting regex TOP { \u0026lt;some-stuff\u0026gt; \u0026lt;digits\u0026gt; \u0026lt;some-stuff\u0026gt; } token digits { \\d+ } regex some-stuff { .+ } } That could match. The TOP matches \u0026lt;some-stuff\u0026gt; but realizes it’s run out of text and starts backtracking. All parts of the grammar that want to allow backtracking have to use regex. It’s not good enough for TOP to backtrack but not \u0026lt;some-stuff\u0026gt;.\n那可能会匹配。 TOP 匹配 \u0026lt;some-stuff\u0026gt;，但意识到它已用完文本并开始回溯。想要允许回溯的 grammar 的所有部分都必须使用 regex。对于 TOP 来说，回溯并不是足够好，除了 \u0026lt;some-stuff\u0026gt; 。\nParsing JSON In Mastering Perl I presented a JSON parser that Randal Schwartz created using some advanced features of Perl 5 regular expressions. In many ways his implementation was a grammar, but he was forced to inseparably combine the parsing and the actions. That made the regular expression almost impenetrable. It’s much cleaner and more accessible to write it as a Raku grammar.\nJSON is actually quite simple with only a few weird things to handle, but it gives you the opportunity to see how proto rules can simplify actions:\n在 Mastering Perl 中，我提到了一个 Randal Schwartz 使用 Perl 5 正则表达式的一些高级功能创建的 JSON 解析器。在许多方面，他的实现是一种 grammar，但他被迫不可分割地将解析和 action 组合在一块。这使得正则表达式几乎无法穿透。用 Raku grammar 编写它会更清晰，更容易访问。\nJSON 实际上非常简单，只需处理几个奇怪的事情，但它让您有机会了解 proto 规则如何简化 action：\ngrammar Grammar::JSON { rule TOP { \u0026lt;.ws\u0026gt; \u0026lt;value\u0026gt; \u0026lt;.ws\u0026gt; } rule object { \u0026#39;{\u0026#39; ~ \u0026#39;}\u0026#39; \u0026lt;string-value-list\u0026gt; } rule string-value-list { \u0026lt;string-value\u0026gt; * % \u0026#39;,\u0026#39; } token string-value { \u0026lt;string\u0026gt; \u0026lt;.ws\u0026gt; \u0026#39;:\u0026#39; \u0026lt;.ws\u0026gt; \u0026lt;value\u0026gt; } rule array { \u0026#39;[\u0026#39; ~ \u0026#39;]\u0026#39; \u0026lt;list\u0026gt; } rule list { \u0026lt;value\u0026gt; * % \u0026#39;,\u0026#39; } token value { \u0026lt;string\u0026gt; | \u0026lt;number\u0026gt; | \u0026lt;object\u0026gt; | \u0026lt;array\u0026gt; | \u0026lt;true\u0026gt; | \u0026lt;false\u0026gt; | \u0026lt;null\u0026gt; } token true { \u0026#39;true\u0026#39; } token false { \u0026#39;false\u0026#39; } token null { \u0026#39;null\u0026#39; } token string { (:ignoremark \\\u0026#34; ) ~ \\\u0026#34; [ \u0026lt;u_char\u0026gt; | [ \u0026#39;\\\\\u0026#39; \u0026lt;[\\\\/bfnrt\u0026#34;]\u0026gt; ] | \u0026lt;-[\\\\\\\u0026#34;\\n\\t]\u0026gt;+ ]* } token u_char { \u0026#39;\\\\u\u0026#39; \u0026lt;code_point\u0026gt; } token code_point { \u0026lt;[0..9a..fA..F]\u0026gt;**4 } token number { \u0026#39;-\u0026#39; ? [ 0 | \u0026lt;[1..9]\u0026gt;\u0026lt;[0..9]\u0026gt;* ] [ \u0026#39;.\u0026#39; \u0026lt;[0..9]\u0026gt;+ ]? [ \u0026lt;[eE]\u0026gt; \u0026lt;[+-]\u0026gt;? \u0026lt;[0..9]\u0026gt;+ ]? } } You may be surprised at how easy and short that grammar is. It’s almost a straight translation of the grammar from RFC 8259. Now, create an action class for that:\n您可能会对这个 grammar 的简单和简短感到惊讶。它几乎是 RFC 8259 grammar 的直接翻译。现在，为此创建一个 action 类：\nclass JSON::Actions { method TOP ($/) { make $\u0026lt;value\u0026gt;.made } method object ($/) { make $\u0026lt;string-value-list\u0026gt;.made.hash.item; } method array ($/) { make $\u0026lt;list\u0026gt;.made.item; } method true ($/) { make True } method False ($/) { make False } method null ($/) { make Nil } method value ($/) { make ( $\u0026lt;true\u0026gt; || $\u0026lt;false\u0026gt; || $\u0026lt;null\u0026gt; || $\u0026lt;object\u0026gt; || $\u0026lt;array\u0026gt; || $\u0026lt;string\u0026gt; || $\u0026lt;number\u0026gt; ).made } method string-value-list ($/) { make $\u0026lt;string-value\u0026gt;\u0026gt;\u0026gt;.made.flat; } method string-value ($/) { make $\u0026lt;string\u0026gt; =\u0026gt; $\u0026lt;value\u0026gt; } method list ($/) { make ~$/ } method string ($/) { make $\u0026lt;uchar\u0026gt;.made || ~$/ } method u_char ($/) { make $\u0026lt;code_point\u0026gt;.made } method code_point ($/) { make chr( (~$/).parse-base(16) ) } method number ($/) { make +$/ } } Look at the clunky handling of value. Almost anything can be a value, so the action method does some ham-handed work to figure out which thing just matched. It looks into the possible submatches to find one with a defined value. Well, that’s pretty stupid even if it’s a quick way to get started (although there is some value in the immediate stupid versus the far-off smart).\nA proto rule gets around this by making it easy for you to give different subrules the same name but different patterns. Instead of an alternation you have one token for each:\n看看笨重的 value 处理。几乎任何东西都可以是一个值，所以 action 方法会做一些简单的工作来弄清楚哪个东西匹配。它查找可能的子匹配以找到具有定义值的子匹配。好吧，即使这是一个快速入门的方式，这也是非常愚蠢的（虽然在愚蠢的直接智能中存在一些价值）。\nproto 规则可以让您轻松地为不同的子规则赋予相同的名称但不同的模式。不是备选分支，而是每个都有一个 token：\nproto token value { * } token value:sym\u0026lt;string\u0026gt; { \u0026lt;string\u0026gt; } token value:sym\u0026lt;number\u0026gt; { \u0026lt;number\u0026gt; } token value:sym\u0026lt;object\u0026gt; { \u0026lt;object\u0026gt; } token value:sym\u0026lt;array\u0026gt; { \u0026lt;array\u0026gt; } token value:sym\u0026lt;true\u0026gt; { \u0026lt;sym\u0026gt; } token value:sym\u0026lt;false\u0026gt; { \u0026lt;sym\u0026gt; } token value:sym\u0026lt;null\u0026gt; { \u0026lt;sym\u0026gt; } The first proto rule matches *, which really means it dispatches to another rule in that group. It can dispatch to all of them and find the one that works.\nSome of these use the special \u0026lt;sym\u0026gt; subrule in their pattern. This means that the name of the rule is the literal text to match. The proto rule \u0026lt;true\u0026gt; matches the literal text true. You don’t have to type that out in the name and the pattern.\nIt doesn’t matter which of those matches; the grammar calls each of them $\u0026lt;value\u0026gt;. The superrule only knows that something that is a value matched and that the subrule handled it appropriately. The action class makes the right value and stores it in the Match:\n第一个 proto 规则匹配 *，这实际上意味着它将分派给该组中的另一个规则。它可以发送给所有人并找到有效的。\n其中一些在其模式中使用特殊的 \u0026lt;sym\u0026gt; 子规则。这意味着规则的名称是要匹配的文字文本。 proto 规则 \u0026lt;true\u0026gt; 匹配文字文本 true。您不必在名称和模式中输入该内容。\n哪些匹配无关紧要; grammar 调用每个 $\u0026lt;value\u0026gt;。超级规则只知道值匹配的东西，并且子规则适当地处理它。 action 类生成正确的值并将其存储在 Match 中：\nclass JSON::Actions { method TOP ($/) { make $\u0026lt;value\u0026gt;.made } method object ($/) { make $\u0026lt;string-value-list\u0026gt;.made.hash.item } method string-value-list ($/) { make $\u0026lt;string-value\u0026gt;\u0026gt;\u0026gt;.made.flat } method string-value ($/) { make $\u0026lt;string\u0026gt;.made =\u0026gt; $\u0026lt;value\u0026gt;.made } method array ($/) { make $\u0026lt;list\u0026gt;.made.item } method list ($/) { make [ $\u0026lt;value\u0026gt;.map: *.made ] } method string ($/) { make $\u0026lt;uchar\u0026gt;.made || ~$/ } method value:sym\u0026lt;number\u0026gt; ($/) { make +$/.Str } method value:sym\u0026lt;string\u0026gt; ($/) { make $\u0026lt;string\u0026gt;.made } method value:sym\u0026lt;true\u0026gt; ($/) { make Bool::True } method value:sym\u0026lt;false\u0026gt; ($/) { make Bool::False } method value:sym\u0026lt;null\u0026gt; ($/) { make Any } method value:sym\u0026lt;object\u0026gt; ($/) { make $\u0026lt;object\u0026gt;.made } method value:sym\u0026lt;array\u0026gt; ($/) { make $\u0026lt;array\u0026gt;.made } method u_char ($/) { make $\u0026lt;code_point\u0026gt;.made } method code_point ($/) { make chr( (~$/).parse-base(16) ) } } EXERCISE 17.5Implement your own JSON parser (steal all the code you like). Test it against some JSON files to see how well it works. You might like to try the JSON files at [https://github.com/briandfoy/json-acceptance-tests\n练习17.5实现自己的 JSON 解析器（窃取你喜欢的所有代码）。针对某些 JSON 文件进行测试，看看它的工作情况。您可能想在 https//github.com/briandfoy/json-acceptance-tests 上尝试 JSON文件。\nParsing CSV Let’s parse some comma-separated values (CSV) files. These are tricky because there’s no actual standard (despite RFC 4180). Microsoft Excel does it one way but some other producers do it slightly differently.\nPeople often initially go wrong thinking they can merely split the data on a comma character—but that might be part of the literal data in a quoted field. The quote character may also be part of the literal data, but one producer might escape internal quote marks by doubling them, \u0026quot;\u0026quot;, while another might use the backslash, \\\u0026quot;. People often assume they are line-oriented, but some producers allow unescaped (but quoted!) vertical whitespace. If all of that wasn’t bad enough, what do you do if one line has fewer (or more) fields than the other lines?\n让我们解析一些逗号分隔值（CSV）文件。这些都很棘手，因为没有实际的标准（尽管有despite RFC 4180 ）。 Microsoft Excel 以一种方式实现，但其他一些生产商则略有不同。\n最初人们通常认为他们只能按照逗号字符拆分数据 - 但逗号可能是引用字段中字面量数据的一部分。引号字符也可能是字面量数据的一部分，但是有些制作人可能会通过两个双引号 \u0026quot;\u0026quot; 来避免内部引号，而另一个可能会使用反斜杠，\\\u0026quot;。人们通常认为它们是面向行的，但是一些制作人允许未转义的（但引起来！）垂直空白。如果所有这些都不够糟糕，如果一行的字段少于（或多于）其他行，你会怎么做？\nWARNING 警告 Don’t parse CSV files like this. The Text::CSV module not only parses the format but also tries to correct problems as it goes.\n不要像这样解析 CSV 文件。 Text::CSV 模块不仅可以解析格式，还可以尝试纠正问题。\nStill willing to give it a try? You should find that grammars make most of these concerns tractable:\n仍然愿意尝试一下？您应该发现 grammar 使大多数这样的问题易于处理：\nThe ratcheting behavior keeps things simple. You can easily handle balanced openers and closers (i.e., the quoting stuff). A grammar can inherit other grammars, so you can adjust a grammar based on the data instead of writing one grammar that handles all the data. You’ve seen action classes, but you can also have action instances that remember extra non-Match data. There’s a .subparse method that lets you parse chunks so you can handle one record at a time. 棘轮行为使事情变得简单。 您可以轻松地处理平衡的开口和闭合（即引用的东西）。 grammar 可以继承其他 grammar，因此您可以根据数据调整 grammar，而不是编写一个处理所有数据的 grammar。 您已经看过 action 类，但你也可以拥有记住额外非匹配数据的 action 实例。 有一个 .subparse 方法，可以让你解析块，这样你就可以一次处理一条记录。 Here’s a simple CSV grammar based off the rules in RFC 4180. It allows for quoted fields and uses \u0026quot;\u0026quot; to escape a literal quote. If a comma, quote, or vertical whitespace appears in the literal data, it must be quoted:\n这是一个简单的 CSV grammar，基于 RFC 4180 中的规则。它允许引用的字段并使用 \u0026quot;\u0026quot; 来避免字面量引号。如果字面量数据中出现逗号，引号或垂直空格，则必须引起它：\ngrammar Grammar::CSV { token TOP { \u0026lt;record\u0026gt;+ } token record { \u0026lt;value\u0026gt;+ % \u0026lt;.separator\u0026gt; \\R } token separator { \u0026lt;.ws\u0026gt; \u0026#39;,\u0026#39; \u0026lt;.ws\u0026gt; } token value { \u0026#39;\u0026#34;\u0026#39; # quoted \u0026lt;( [ \u0026lt;-[\u0026#34;]\u0026gt; | \u0026lt;.escaped-quote\u0026gt; ]* )\u0026gt; \u0026#39;\u0026#34;\u0026#39; | \u0026lt;-[\u0026#34;,\\n\\f\\r]\u0026gt;+ # non-quoted (no vertical ws) | \u0026#39;\u0026#39; # empty } token escaped-quote { \u0026#39;\u0026#34;\u0026#34;\u0026#39; } } class CSV::Actions { method record ($/) { make $\u0026lt;value\u0026gt;».made.flat } method value ($/) { # undo the double double quote make $/.subst( rx/ \u0026#39;\u0026#34;\u0026#34;\u0026#39; /, \u0026#39;\u0026#34;\u0026#39;, :g ) } } Try this on entire files. The entire file either satisfies this grammar or doesn’t:\n在整个文件上试试这个。整个文件要么满足这个 grammar，要么不满足：\nmy $data = $filename.IO.slurp; my $result = Grammar::CSV.parse( $data ); You typically don’t want to parse entire files, though. Let’s fix the first part of that problem. You want to process records as you run into them. Instead of using .parse, which anchors to the end of the text, you can use .subparse, which doesn’t. This means you can parse part of the text then stop.\nYou can deal with one record at a time. Using .subparse with the record rule gets you the first record and only the first record. The .subparse method always returns a Match, unlike .parse, which only returns a Match when it succeeds. You can’t rely on the type of the object as an indication of success:\n但是，您通常不希望解析整个文件。让我们解决这个问题的第一部分。您希望在遇到记录时处理记录。你可以使用 .subparse，而不是使用锚定到文本末尾的 .parse， .subparse 不会锚定到文本末尾。这意味着您可以解析部分文本然后停止。\n您可以一次处理一条记录。将 .subparse 与 record 规则一起使用可以获得第一条记录，并且只获得第一条记录。与 .parse 不同，.subparse 方法总是返回一个 Match，.parse 方法只在成功时返回一个 Match。你不能依赖对象的类型作为成功的指示：\nmy $data = $filename.IO.slurp; my $first_result = Grammar::CSV.subparse( $data, :rule(\u0026#39;record\u0026#39;), :action(CSV::Actions) ); if $first-result { ... } That works for the first line. Use :c(N) to tell these methods where to start in the Str. You have to know where you want to start. The Match knows how far it got; look in the .from slot:\n这适用于第一行。使用 :c(N) 告诉这些方法在 字符串中从哪里开始。你必须知道你想要从哪里开始。Match 知道它进行了多远;看看 .from 插槽：\nmy $data = $filename.IO.slurp; loop { state $from = 0; my $match = Grammar::CSV.subparse( $data, :rule(\u0026#39;record\u0026#39;), :actions(CSV::Actions), :c($from) ); last unless $match; put \u0026#34;Matched from {$match.from} to {$match.to}\u0026#34;; $from = $match.to; say $match; } This is most of the way to a solution—it fails to go through the entire file if .subparse fails on one record. With some boring monkey work you could fix this to find the start of the next record and restart the parsing, but that’s more than I want to fit in this book.\n这是解决方案的大部分方法 - 如果 .subparse 在一条记录上失败，则无法遍历整个文件。使用一些无聊的猴子工作，你可以修复这个问题，找到下一条记录的开始并重新开始解析，但这比我想要适应本书更多。\nAdjusting the Grammar You thought the problem was solved. Then, someone sent you a file with a slightly different format. Instead of escaping a \u0026quot; by doubling it, the new format uses the backslash.\nNow your existing grammar fails to parse. You don’t have a rule that satisfies that type of escape because you didn’t need it for your grammar. As a matter of practice in both patterns and grammars, only match what you should match. Be liberal in what you accept in other ways, such as making a subgrammar to handle the new case:\n你以为问题已经解决了。然后，有人给你发送了一个格式略有不同的文件。新格式使用反斜杠，而不是使用两个引号转义 \u0026quot;。\n现在你现有的 grammar 解析失败。您没有满足该类型的转义的规则，因为您的 grammar 不需要它。作为模式和 grammar 的练习，只匹配你应该匹配的内容。在其他方面随心所欲，例如制作一个子 grammar 来处理新案例：\ngrammar Grammar::CSV::Backslashed is Grammar::CSV { token escaped-quote { \u0026#39;\\\\\u0026#34;\u0026#39; } } class CSV::Actions::Backslashed is CSV::Actions { method value ($/) { make $/.subst( rx/ \u0026#39;\\\\\u0026#34;\u0026#39; /, \u0026#39;\u0026#34;\u0026#39;, :g ) } } With two grammars, how do you get the one that you need to use? The name interpolation ::($name) comes in handy here:\n有两个 grammar，你如何得到你需要使用的那个？::($name) 在这里派上用场：\nmy %formats; %formats\u0026lt;doubled\u0026gt; = { \u0026#39;file\u0026#39; =\u0026gt; $*SPEC.catfile( \u0026lt;corpus test.csv\u0026gt; ), \u0026#39;grammar\u0026#39; =\u0026gt; \u0026#39;Grammar::CSV\u0026#39;, }; %formats\u0026lt;backslashed\u0026gt; = { \u0026#39;file\u0026#39; =\u0026gt; $*SPEC.catfile( \u0026lt;corpus test-backslash.csv\u0026gt; ), \u0026#39;grammar\u0026#39; =\u0026gt; \u0026#39;Grammar::CSV::Backslashed\u0026#39;, }; for %formats.values -\u0026gt; $hash { $hash\u0026lt;data\u0026gt; = $hash\u0026lt;file\u0026gt;.IO.slurp; my $class = (require ::( $hash\u0026lt;grammar\u0026gt; ) ); my $match = $class.parse( $hash\u0026lt;data\u0026gt; ); say \u0026#34;{$hash\u0026lt;file\u0026gt;} with {$hash\u0026lt;grammar\u0026gt;} \u0026#34;, $match ?? \u0026#39;parsed\u0026#39; !! \u0026#39;failed\u0026#39;; } The %formats Hash of Hashes stores the filenames and the grammars for them. You can load a grammar and use it to parse the data without the explicit grammar name:\n%formats 散列的散列存储文件名和 grammar。您可以加载 grammar 并使用它来解析数据而不使用显式的 grammar 名称：\ncorpus/test.csv with Grammar::CSV parsed corpus/test-backslash.csv with Grammar::CSV::Backslashed parsed That mostly solves the problem, although there are plenty of special cases that this doesn’t cover.\n这主要解决了这个问题，尽管有很多特殊情况并没有涵盖。\nUsing Roles in Grammars Roles can supply rules and methods that grammars can use. In the previous section you handled different sorts of double-quote escaping through inheritance, where you overrode the rule. You can do the same thing with roles.\nA grammar can have methods and subroutines. The way you declare a name with sub, method, or rule tells the language parser (not your grammar!) how to parse the stuff in the Block.\nFirst, adjust the main grammar to have a stub method for \u0026lt;escaped-quote\u0026gt;. This forces something else to define it:\n角色可以提供 grammar 可以使用的规则和方法。在上一节中，您通过继承处理了不同类型的双引号转义，其中您重写了规则。你可以用角色做同样的事情。\nGrammar 可以有方法和子程序。使用 sub，method或 rule 声明名称的方式告诉语言解析器（而不是 grammar！）如何解析块中的东西。\n首先，调整主 grammar，使其具有 \u0026lt;escaped-quote\u0026gt; 的存根方法。这迫使别人定义它：\ngrammar Grammar::CSV { token TOP { \u0026lt;record\u0026gt;+ } token record { \u0026lt;value\u0026gt;+ % \u0026lt;.separator\u0026gt; \\R } token separator { \u0026lt;.ws\u0026gt; \u0026#39;,\u0026#39; \u0026lt;.ws\u0026gt; } token value { \u0026#39;\u0026#34;\u0026#39; # quoted \u0026lt;( [ \u0026lt;-[\u0026#34;]\u0026gt; | \u0026lt;.escaped-quote\u0026gt; ]* )\u0026gt; \u0026#39;\u0026#34;\u0026#39; | \u0026lt;-[\u0026#34;,\\n\\f\\r]\u0026gt;+ # non-quoted (no vertical ws) | \u0026#39;\u0026#39; # empty } # stub that you must define in a role method escaped-quote { !!! } } A role will fill in that stub method. There’s one role for each way to escape the double quote:\n角色将填充该存根方法。每种方式都有一个角色来转义双引号：\nrole DoubledQuote { token escaped-quote { \u0026#39;\u0026#34;\u0026#34;\u0026#39; } } role BackslashedQuote { token escaped-quote { \u0026#39;\\\\\u0026#34;\u0026#39; } } When it’s time to parse a file you can choose which role you want to use. You can create a new object for Grammar::CSV and apply the appropriate role to it:\n在解析文件时，您可以选择要使用的角色。您可以为 Grammar::CSV 创建一个新对象并将适当的角色应用于它：\nmy $filename = ...; my $csv-data = $filename.IO.slurp; my $csv-parser = Grammar::CSV.new but DoubledQuote; Use that object to parse your data:\n使用该对象解析数据：\nmy $match = $csv-parser.parse: $csv-data; say $match // \u0026#39;Failed!\u0026#39;; Doing this doesn’t fix the double quotes in the data—a \u0026quot;\u0026quot; stays as a \u0026quot;\u0026quot;—but you can fix that in an action class.\nEXERCISE 17.6Adjust the CSV example to use roles instead of inheritance. Create an action class to adjust the escaped double quotes as you run into them. You can start with Grammars/test.csv from the downloads section of the book’s website if you like.\n这样做不会修复数据中的双引号 - \u0026quot;\u0026quot; 保留为 \u0026quot;\u0026quot; - 但您可以在 action 类中修复它。\n练习17.6 调整 CSV 示例以使用角色而不是继承。创建一个 action 类，以便在遇到它们时调整转义的双引号。如果您愿意，可以从本书网站的下载部分 Grammars/ test.csv 开始。\nSummary Grammars are one of the killer features of the language. You can define complex relationships between patterns and use action classes to run arbitrarily complex code when something matches. You might find that your entire program ends up being one big grammar.\nGrammars 是 Raku 语言的杀手级特性之一。您可以定义模式之间的复杂关系，并在匹配时使用 action 类来运行任意复杂的代码。您可能会发现整个程序最终变成一个大的 grammar。\n"},"name":"第十七章. Grammars","published":"2018-09-17T00:10:09+08:00","summary":"声明 本章翻译仅用于 Raku 学习和研究, 请支持电子版或纸质版。\n第十七章. Grammars Grammars are patterns on a higher plane of existence. They integrate and reuse pattern fragments to parse and react to complicated formats. This feature is at the core of Raku in a very literal sense; the language itself is implemented as a grammar. Once you start using it you’ll probably prefer it to regexes for all but the most simple problems.\nGrammars 是存在于更高层面上的模式。它们集成并重用模式片段来解析复杂的格式并做出反应。从字面意义上讲，这个功能是Raku的核心;语言本身是作为语法实现的。一旦你开始使用它，你可能更喜欢它除了最简单的问题之外的所有正则表达式。","type":"entry","url":"https://ohmycloud.github.io/posts/2018-09-17-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0.-grammars/"}