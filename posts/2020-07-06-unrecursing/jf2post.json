{"author":{"name":null,"type":"card","url":"https://ohmycloud.github.io/"},"content":{"html":"\u003ch2 id=\"categories-raku\"\u003ecategories: [\u0026ldquo;Raku\u0026rdquo;]\u003c/h2\u003e\n\u003cp\u003eMoritz \u003ca href=\"https://colabti.org/irclogger/irclogger_log/raku?date=2020-07-04#l268\"\u003e不满意\u003c/a\u003e Raku 给他的权力，让他与名单搏斗。他说的没错。如果简单的事情很容易，就不需要摔跤了。这让我想到了我在上一篇博文中构建的数据结构。它是一个列表和一个 \u003ccode\u003eProc::Async\u003c/code\u003e 的对。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e[[[Proc::Async],Proc::Async],Proc::Async]\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e其中，列表中混入了 \u003ccode\u003e.start\u003c/code\u003e 方法。这样我就可以按顺序连接 shell 命令，并按相反的顺序启动它们，而不需要特殊的套管来让 \u003ccode\u003e.start\u003c/code\u003e 被调用。毕竟在启动一对shell命令之前，我需要连接 STDOUT 和 STDIN。然而，任何形式的反省都会成为一种负担。而且我需要检查一个 Array 是否不在一个管道链的开始或结束。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e@a\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u0026gt;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$grep\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u0026gt;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$sort\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e# this is fine\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$find\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u0026gt;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$sort\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u0026gt;\u003c/span\u003e \u003cspan class=\"nv\"\u003e@a\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e# this too\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$find\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u0026gt;\u003c/span\u003e \u003cspan class=\"nv\"\u003e@a\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u0026gt;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$sort\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ethis\u003c/span\u003e \u003cspan class=\"nb\"\u003ecan\u003c/span\u003e \u003cspan class=\"nb\"\u003enot\u003c/span\u003e \u003cspan class=\"n\"\u003ework\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e数组不是一个并发的数据结构。链的左边和右边是。所以我们不能把它们混在一起。(我相信当 \u003ca href=\"https://github.com/rakudo/rakudo/issues/3778\"\u003eR#3778\u003c/a\u003e 修复后，我可以让这个工作。)\u003c/p\u003e\n\u003cp\u003e所以我\u003ca href=\"https://gist.github.com/537ef40a7201f57163419653563cadec\"\u003e重写\u003c/a\u003e了目前的内容。作为一个副作用，我们可以存储一个管道，并在以后手动启动它，并提供一个很好的要领。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$find\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kt\"\u003eProc::Async\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003enew\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e/usr/bin/find\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e/tmp\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$sort\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kt\"\u003eProc::Async\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003enew\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e/usr/bin/sort\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e@a\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$p\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nv\"\u003e$find\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u0026gt;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$sort\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u0026gt;\u003c/span\u003e \u003cspan class=\"nv\"\u003e@a\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e$p\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#OUTPUT: find ↦ sort ↦ @a\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e其中 \u003ccode\u003e$p\u003c/code\u003e 包含一个 \u003ccode\u003eShell::Pipe\u003c/code\u003e，它有 \u003ccode\u003e@.pipees\u003c/code\u003e。所以我们可以这样做。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"nv\"\u003e$p\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003epipees\u003c/span\u003e \u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$p\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nv\"\u003e$p\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003estderr\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003etap\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e{})\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nv\"\u003e$p\u003c/span\u003e \u003cspan class=\"o\"\u003e~~\u003c/span\u003e \u003cspan class=\"kt\"\u003eProc::Async\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e \u003cspan class=\"c1\"\u003e# silence is golden\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$p\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"k\"\u003estart\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我希望支持 Supply、Channel 和 Callable 作为一个管道的开始和结束。也许甚至在两者之间。然后我就可以继续处理错误处理。\u003c/p\u003e\n\u003cp\u003e构建复杂的数据结构是非常有诱惑力的，因为 Raku 是如此善于分解它们。这似乎是一个最好避免的选择。优雅可能只是一个解决方案，它的移动部件最少。\u003c/p\u003e\n\u003cp\u003eby \u003ca href=\"https://gfldex.wordpress.com/2020/07/06/unrecursing/\"\u003egfldex\u003c/a\u003e.\u003c/p\u003e\n","text":"categories: [\u0026ldquo;Raku\u0026rdquo;] Moritz 不满意 Raku 给他的权力，让他与名单搏斗。他说的没错。如果简单的事情很容易，就不需要摔跤了。这让我想到了我在上一篇博文中构建的数据结构。它是一个列表和一个 Proc::Async 的对。\n[[[Proc::Async],Proc::Async],Proc::Async]\n其中，列表中混入了 .start 方法。这样我就可以按顺序连接 shell 命令，并按相反的顺序启动它们，而不需要特殊的套管来让 .start 被调用。毕竟在启动一对shell命令之前，我需要连接 STDOUT 和 STDIN。然而，任何形式的反省都会成为一种负担。而且我需要检查一个 Array 是否不在一个管道链的开始或结束。\n@a |\u0026gt; $grep |\u0026gt; $sort; # this is fine $find |\u0026gt; $sort |\u0026gt; @a; # this too $find |\u0026gt; @a |\u0026gt; $sort; this can not work 数组不是一个并发的数据结构。链的左边和右边是。所以我们不能把它们混在一起。(我相信当 R#3778 修复后，我可以让这个工作。)\n所以我重写了目前的内容。作为一个副作用，我们可以存储一个管道，并在以后手动启动它，并提供一个很好的要领。\nmy $find = Proc::Async.new(\u0026#39;/usr/bin/find\u0026#39;, \u0026#39;/tmp\u0026#39;); my $sort = Proc::Async.new(\u0026#39;/usr/bin/sort\u0026#39;); my @a; my $p = $find |\u0026gt; $sort |\u0026gt; @a; say $p; #OUTPUT: find ↦ sort ↦ @a 其中 $p 包含一个 Shell::Pipe，它有 @.pipees。所以我们可以这样做。\nfor $p.pipees -\u0026gt; $p { $p.stderr.tap(-\u0026gt; {}) if $p ~~ Proc::Async}; # silence is golden $p.start; 我希望支持 Supply、Channel 和 Callable 作为一个管道的开始和结束。也许甚至在两者之间。然后我就可以继续处理错误处理。\n构建复杂的数据结构是非常有诱惑力的，因为 Raku 是如此善于分解它们。这似乎是一个最好避免的选择。优雅可能只是一个解决方案，它的移动部件最少。\nby gfldex.\n"},"name":"非递归","published":"2020-07-06T19:40:45+08:00","summary":"categories: [\u0026ldquo;Raku\u0026rdquo;] Moritz 不满意 Raku 给他的权力，让他与名单搏斗。他说的没错。如果简单的事情很容易，就不需要摔跤了。这让我想到了我在上一篇博文中构建的数据结构。它是一个列表和一个 Proc::Async 的对。\n[[[Proc::Async],Proc::Async],Proc::Async]\n其中，列表中混入了 .start 方法。这样我就可以按顺序连接 shell 命令，并按相反的顺序启动它们，而不需要特殊的套管来让 .start 被调用。毕竟在启动一对shell命令之前，我需要连接 STDOUT 和 STDIN。然而，任何形式的反省都会成为一种负担。而且我需要检查一个 Array 是否不在一个管道链的开始或结束。\n@a |\u0026gt; $grep |\u0026gt; $sort; # this is fine $find |\u0026gt; $sort |\u0026gt; @a; # this too $find |\u0026gt; @a |\u0026gt; $sort; this can not work 数组不是一个并发的数据结构。链的左边和右边是。所以我们不能把它们混在一起。(我相信当 R#3778 修复后，我可以让这个工作。)\n所以我重写了目前的内容。作为一个副作用，我们可以存储一个管道，并在以后手动启动它，并提供一个很好的要领。\nmy $find = Proc::Async.new(\u0026#39;/usr/bin/find\u0026#39;, \u0026#39;/tmp\u0026#39;); my $sort = Proc::Async.new(\u0026#39;/usr/bin/sort\u0026#39;); my @a; my $p = $find |\u0026gt; $sort |\u0026gt; @a; say $p; #OUTPUT: find ↦ sort ↦ @a 其中 $p 包含一个 Shell::Pipe，它有 @.","type":"entry","url":"https://ohmycloud.github.io/posts/2020-07-06-unrecursing/"}