{"author":{"name":null,"type":"card","url":"https://ohmycloud.github.io/"},"content":{"html":"\u003ch1 id=\"安装\"\u003e安装\u003c/h1\u003e\n\u003cp\u003e首先，首先安装 \u003ccode\u003eR\u003c/code\u003e 编程语言。在此之后，运行 \u003ccode\u003eR\u003c/code\u003e 并执行以下命令来安装 \u003ccode\u003ermarkdown\u003c/code\u003e: \u003ccode\u003einstall.packages(\u0026quot;rmarkdown\u0026quot;)\u003c/code\u003e。在安装 rmarkdown 时，我收到以下错误消息:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eError: .onLoad failed in loadNamespace() for \u0026#39;tcltk\u0026#39;, details:\n  call: dyn.load(file, DLLpath = DLLpath, ...)\n  error: unable to load shared object \u0026#39;/usr/lib/R/library/tcltk/libs/tcltk.so\u0026#39;:\n  libtk8.6.so: cannot open shared object file: No such file or directory\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这可以通过安装包 \u003ccode\u003etk\u003c/code\u003e 来解决，然后继续安装 rmarkdown。\u003c/p\u003e\n\u003ch1 id=\"rmarkdown-的代码块\"\u003eRmarkdown 的代码块\u003c/h1\u003e\n\u003cp\u003e你可以用 rmarkdown 做的几乎所有都可以用“常规” markdown 来做的事情。然而，rmarkdown 的一个突出特性是它能够执行代码块并返回结果。为此，rmarkdown 使用了 \u003ca href=\"https://yihui.name/knitr/\"\u003eknitr\u003c/a\u003e 包，这是一个使用 R 生成动态报告的引擎，除了 R 之外，它还支持其他语言引擎，您可以使用这些引擎来计算来自其他语言的代码。要列出可用引擎的名称，请在 R REPL 中执行 \u003ccode\u003enames(knitr::knit_engines$get())\u003c/code\u003e 命令。就像“常规” markdown 一样，代码块可以用三个反勾号创建，然后是代码，最后是另外三个反勾号。如果希望计算代码块，请在花括号 \u003ccode\u003e{}\u003c/code\u003e 中指定语言，该语言位于前三个反勾号之后。例如，要执行 Perl 5 代码，可以在 \u003ccode\u003e{}\u003c/code\u003e 中指定 \u003ccode\u003eperl\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e```{perl}\nsub factorial {\n    my ($n) = @_;\n    return 1 if $n == 0;\n    return factorial($n - 1) * $n;\n}\n\nfor (1..4) {\n    print \u0026quot;Factorial of $_: \u0026quot;, factorial($_), \u0026quot;\\n\u0026quot;;\n} \n```\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果任何表达式求值了，将按照如下方式处理，结果将显示在源代码下面:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esub factorial {\n    my ($n) = @_;\n    return 1 if $n == 0;\n    return factorial($n - 1) * $n;\n}\n\nfor (1..4) {\n    print \u0026quot;Factorial of $_: \u0026quot;, factorial($_), \u0026quot;\\n\u0026quot;;\n} \n## Factorial of 1: 1\n## Factorial of 2: 2\n## Factorial of 3: 6\n## Factorial of 4: 24\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e代码块的选项可以在花括号中指定。例如，为了防止对代码块的计算，您必须将 \u003ccode\u003eeval\u003c/code\u003e 设置为 \u003ccode\u003eFALSE\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e```{perl, eval=FALSE}\nmy $name = 'Nemy';\nprint \u0026quot;Hello, $name!\\n\u0026quot;;\n```\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这阻止了代码块的求值，只显示源代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emy $name = 'Nemy';\nprint \u0026quot;Hello, $name!\\n\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e要隐藏源代码并且仍然显示它的求值，可以将 \u003ccode\u003eecho\u003c/code\u003e 设置为 \u003ccode\u003eFALSE\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e```{perl, echo=FALSE}\nmy $name = 'Nemy';\nprint \u0026quot;Hello, $name!\\n\u0026quot;;\n```\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e只有结果被展示出来：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e## Hello, Nemy!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在花括号中可以指定一些选项。下面是我常用的一些选项的小列表:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eengine\u003c/strong\u003e-默认为\u003ccode\u003eR\u003c/code\u003e。\u003ccode\u003eknitr\u003c/code\u003e 将用命名语言计算这个块，例如 \u003ccode\u003eengine = 'python'\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eeval\u003c/strong\u003e-默认情况下为 \u003ccode\u003eTRUE\u003c/code\u003e。如果为 \u003ccode\u003eFALSE\u003c/code\u003e, knitr 将不会在代码块中运行代码。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eecho\u003c/strong\u003e-默认情况下为 \u003ccode\u003eTRUE\u003c/code\u003e。如果为 \u003ccode\u003eFALSE\u003c/code\u003e, knitr 将不会在最终文档中显示其结果上面的代码块中的代码。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ecollapse\u003c/strong\u003e-默认为 \u003ccode\u003eFALSE\u003c/code\u003e。如果为 \u003ccode\u003eTRUE\u003c/code\u003e，knitr 将把该块创建的所有源代码块和输出块折叠成单个块。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ecomment\u003c/strong\u003e-默认情况下是 \u003ccode\u003e##\u003c/code\u003e。knitr 将在最终文档的每行结果的开头添加的一个字符串，例如 \u003ccode\u003ecomment = '#=\u0026gt;'\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在这里可以找到关于\u003ca href=\"https://yihui.name/knitr/options/\"\u003e不同选项\u003c/a\u003e的更多信息。\u003c/p\u003e\n\u003ch1 id=\"rmarkdown-中的-raku\"\u003eRmarkdown 中的 Raku\u003c/h1\u003e\n\u003cp\u003e到目前为止，knitr 不支持 Raku 的语言引擎。但是，您可以使用 knitr 的引擎语言可扩展性来执行 rmarkdown 中的 Raku 代码块，方法是在您的文件中添加以下 R 代码块:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e```{r setup}\nlibrary(knitr)\neng_raku \u0026lt;- function(options) {\n  # create a temporary file\n  f \u0026lt;- basename(tempfile(\u0026quot;raku\u0026quot;, '.', paste('.', \u0026quot;raku\u0026quot;, sep = '')))\n  on.exit(unlink(f)) # cleanup temp file on function exit\n  writeLines(options$code, f)\n  out \u0026lt;- ''\n\n  # if eval != FALSE compile/run the code, preserving output\n  if (options$eval) {\n    out \u0026lt;- system(sprintf('raku %s', paste(f, options$engine.opts)), intern=TRUE)\n  }\n\n  # spit back stuff to the user\n  engine_output(options, options$code, out)\n}\n\nknitr::knit_engines$set(raku=eng_raku)\n```\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个变通方法是从\u003ca href=\"https://stackoverflow.com/questions/45857934/executing-perl-6-code-in-rmarkdown/45864801#45864801\"\u003e这里\u003c/a\u003e和\u003ca href=\"https://www.r-bloggers.com/running-go-language-chunks-in-r-markdown-rmd-files/\"\u003e这里\u003c/a\u003e 得到的。\u003c/p\u003e\n\u003cp\u003e这将允许你这样做:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e```{r, engine='raku'}\nsay [*] 1..5;\n```\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是，您可以使用 Perl 5 的引擎语言并通过将 \u003ccode\u003eengine.path\u003c/code\u003e 设置为 \u003ccode\u003eraku\u003c/code\u003e 使其路径更改为 Raku 可执行文件的路径，而不是在每个正在处理 Raku 代码的文件中添加这段 R 代码。然后，您可以通过如下方式处理 Raku 代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e```{perl, engine.path='raku'}\nsay [*] 1..5;\n```\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在您应该能够计算 Raku 代码块:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e```{perl, engine.path='raku', comment='#=\u0026gt;', collapse=TRUE}\nclass Point {\n    has $.x = 0;\n    has $.y = 0;\n    method distance-to-center() {\n        return sqrt($!x**2 + $!y**2);\n    }\n}\n\nmy $p = Point.new(x =\u0026gt; 3, y =\u0026gt; 4);\nsay $p.distance-to-center();\n```\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e会被处理成如下这样：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass Point {\n    has $.x = 0;\n    has $.y = 0;\n    method distance-to-center() {\n        return sqrt($!x**2 + $!y**2);\n    }\n}\n\nmy $p = Point.new(x =\u0026gt; 3, y =\u0026gt; 4);\nsay $p.distance-to-center();\n\n#=\u0026gt; 5\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"补遗\"\u003e补遗\u003c/h1\u003e\n\u003cp\u003e这篇文章是受我的启发，我希望有一个简单的设置，转录课堂笔记使用 \u003ccode\u003evim\u003c/code\u003e。注释可能闪烁着 \u003ccode\u003eLATEX\u003c/code\u003e，一些代码片段，并转换为 \u003ccode\u003e.pdf\u003c/code\u003e 文件，以便在此过程中进行审阅。rmarkdown 的易用性和广泛的功能使其成为这项工作的合适工具。\u003c/p\u003e\n\u003cp\u003e要从 vim 直接将 \u003ccode\u003e.rmd\u003c/code\u003e 转换为 \u003ccode\u003e.pdf\u003c/code\u003e 文件，我的 \u003ccode\u003e.vimrc\u003c/code\u003e 中有以下一行映射到 F5，以简化过程:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eautocmd Filetype rmd map \u0026lt;F5\u0026gt; :!echo\u0026lt;space\u0026gt;\u0026#34;require(rmarkdown);\n\u0026lt;space\u0026gt;render(\u0026#39;\u0026lt;c-r\u0026gt;%\u0026#39;)\u0026#34;\u0026lt;space\u0026gt;\\|\u0026lt;space\u0026gt;R\u0026lt;space\u0026gt;--vanilla\u0026lt;enter\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如您所见，这只是在 R 中加载 rmarkdown 包，将当前 .rmd 文件传递给函数 \u003ccode\u003erender\u003c/code\u003e，并将其结果传递给 \u003ccode\u003eR --vanilla\u003c/code\u003e 以使程序非交互式。\u003c/p\u003e\n\u003cp\u003e注意，您可能需要安装 \u003ccode\u003epandoc\u003c/code\u003e 才能正常工作。对于 pandoc latex 模板，我使用了 \u003ca href=\"https://github.com/Wandmalfarbe/pandoc-latex-template\"\u003eeisvogel.latex\u003c/a\u003e 的一个稍微改进版本。\u003c/p\u003e\n\u003cp\u003e以下是所有注释的 YAML 前言(元数据)的示例:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e---\ntitle: \u0026quot;Raku in rmarkdown\u0026quot;\nauthor: \u0026quot;Luis F. Uceta\u0026quot;\ndate: Aug 13, 2018\n\noutput: \n    pdf_document:\n        latex_engine: pdflatex\n        toc: true\n        template: eisvogel.latex\n\nfontsize: 12pt\ngeometry: margin=1in \nlinkcolor: red\nurlcolor: blue\n---\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这是这个文件的 \u003ccode\u003epdf\u003c/code\u003e，使用了之前的 \u003ccode\u003eYAML\u003c/code\u003e 前言和前面提到的 latex 模板。请注意，此 pdf 可能不反映对本文所做的最新更改。\u003c/p\u003e\n","text":"安装 首先，首先安装 R 编程语言。在此之后，运行 R 并执行以下命令来安装 rmarkdown: install.packages(\u0026quot;rmarkdown\u0026quot;)。在安装 rmarkdown 时，我收到以下错误消息:\nError: .onLoad failed in loadNamespace() for \u0026#39;tcltk\u0026#39;, details: call: dyn.load(file, DLLpath = DLLpath, ...) error: unable to load shared object \u0026#39;/usr/lib/R/library/tcltk/libs/tcltk.so\u0026#39;: libtk8.6.so: cannot open shared object file: No such file or directory 这可以通过安装包 tk 来解决，然后继续安装 rmarkdown。\nRmarkdown 的代码块 你可以用 rmarkdown 做的几乎所有都可以用“常规” markdown 来做的事情。然而，rmarkdown 的一个突出特性是它能够执行代码块并返回结果。为此，rmarkdown 使用了 knitr 包，这是一个使用 R 生成动态报告的引擎，除了 R 之外，它还支持其他语言引擎，您可以使用这些引擎来计算来自其他语言的代码。要列出可用引擎的名称，请在 R REPL 中执行 names(knitr::knit_engines$get()) 命令。就像“常规” markdown 一样，代码块可以用三个反勾号创建，然后是代码，最后是另外三个反勾号。如果希望计算代码块，请在花括号 {} 中指定语言，该语言位于前三个反勾号之后。例如，要执行 Perl 5 代码，可以在 {} 中指定 perl:\n```{perl} sub factorial { my ($n) = @_; return 1 if $n == 0; return factorial($n - 1) * $n; } for (1..4) { print \u0026quot;Factorial of $_: \u0026quot;, factorial($_), \u0026quot;\\n\u0026quot;; } ``` 如果任何表达式求值了，将按照如下方式处理，结果将显示在源代码下面:\nsub factorial { my ($n) = @_; return 1 if $n == 0; return factorial($n - 1) * $n; } for (1..4) { print \u0026quot;Factorial of $_: \u0026quot;, factorial($_), \u0026quot;\\n\u0026quot;; } ## Factorial of 1: 1 ## Factorial of 2: 2 ## Factorial of 3: 6 ## Factorial of 4: 24 代码块的选项可以在花括号中指定。例如，为了防止对代码块的计算，您必须将 eval 设置为 FALSE:\n```{perl, eval=FALSE} my $name = 'Nemy'; print \u0026quot;Hello, $name!\\n\u0026quot;; ``` 这阻止了代码块的求值，只显示源代码:\nmy $name = 'Nemy'; print \u0026quot;Hello, $name!\\n\u0026quot;; 要隐藏源代码并且仍然显示它的求值，可以将 echo 设置为 FALSE:\n```{perl, echo=FALSE} my $name = 'Nemy'; print \u0026quot;Hello, $name!\\n\u0026quot;; ``` 只有结果被展示出来：\n## Hello, Nemy! 在花括号中可以指定一些选项。下面是我常用的一些选项的小列表:\nengine-默认为R。knitr 将用命名语言计算这个块，例如 engine = 'python'。 eval-默认情况下为 TRUE。如果为 FALSE, knitr 将不会在代码块中运行代码。 echo-默认情况下为 TRUE。如果为 FALSE, knitr 将不会在最终文档中显示其结果上面的代码块中的代码。 collapse-默认为 FALSE。如果为 TRUE，knitr 将把该块创建的所有源代码块和输出块折叠成单个块。 comment-默认情况下是 ##。knitr 将在最终文档的每行结果的开头添加的一个字符串，例如 comment = '#=\u0026gt;'。 在这里可以找到关于不同选项的更多信息。\nRmarkdown 中的 Raku 到目前为止，knitr 不支持 Raku 的语言引擎。但是，您可以使用 knitr 的引擎语言可扩展性来执行 rmarkdown 中的 Raku 代码块，方法是在您的文件中添加以下 R 代码块:\n```{r setup} library(knitr) eng_raku \u0026lt;- function(options) { # create a temporary file f \u0026lt;- basename(tempfile(\u0026quot;raku\u0026quot;, '.', paste('.', \u0026quot;raku\u0026quot;, sep = ''))) on.exit(unlink(f)) # cleanup temp file on function exit writeLines(options$code, f) out \u0026lt;- '' # if eval != FALSE compile/run the code, preserving output if (options$eval) { out \u0026lt;- system(sprintf('raku %s', paste(f, options$engine.opts)), intern=TRUE) } # spit back stuff to the user engine_output(options, options$code, out) } knitr::knit_engines$set(raku=eng_raku) ``` 这个变通方法是从这里和这里 得到的。\n这将允许你这样做:\n```{r, engine='raku'} say [*] 1..5; ``` 但是，您可以使用 Perl 5 的引擎语言并通过将 engine.path 设置为 raku 使其路径更改为 Raku 可执行文件的路径，而不是在每个正在处理 Raku 代码的文件中添加这段 R 代码。然后，您可以通过如下方式处理 Raku 代码:\n```{perl, engine.path='raku'} say [*] 1..5; ``` 现在您应该能够计算 Raku 代码块:\n```{perl, engine.path='raku', comment='#=\u0026gt;', collapse=TRUE} class Point { has $.x = 0; has $.y = 0; method distance-to-center() { return sqrt($!x**2 + $!y**2); } } my $p = Point.new(x =\u0026gt; 3, y =\u0026gt; 4); say $p.distance-to-center(); ``` 会被处理成如下这样：\nclass Point { has $.x = 0; has $.y = 0; method distance-to-center() { return sqrt($!x**2 + $!y**2); } } my $p = Point.new(x =\u0026gt; 3, y =\u0026gt; 4); say $p.distance-to-center(); #=\u0026gt; 5 补遗 这篇文章是受我的启发，我希望有一个简单的设置，转录课堂笔记使用 vim。注释可能闪烁着 LATEX，一些代码片段，并转换为 .pdf 文件，以便在此过程中进行审阅。rmarkdown 的易用性和广泛的功能使其成为这项工作的合适工具。\n要从 vim 直接将 .rmd 转换为 .pdf 文件，我的 .vimrc 中有以下一行映射到 F5，以简化过程:\nautocmd Filetype rmd map \u0026lt;F5\u0026gt; :!echo\u0026lt;space\u0026gt;\u0026#34;require(rmarkdown); \u0026lt;space\u0026gt;render(\u0026#39;\u0026lt;c-r\u0026gt;%\u0026#39;)\u0026#34;\u0026lt;space\u0026gt;\\|\u0026lt;space\u0026gt;R\u0026lt;space\u0026gt;--vanilla\u0026lt;enter\u0026gt; 如您所见，这只是在 R 中加载 rmarkdown 包，将当前 .rmd 文件传递给函数 render，并将其结果传递给 R --vanilla 以使程序非交互式。\n注意，您可能需要安装 pandoc 才能正常工作。对于 pandoc latex 模板，我使用了 eisvogel.latex 的一个稍微改进版本。\n以下是所有注释的 YAML 前言(元数据)的示例:\n--- title: \u0026quot;Raku in rmarkdown\u0026quot; author: \u0026quot;Luis F. Uceta\u0026quot; date: Aug 13, 2018 output: pdf_document: latex_engine: pdflatex toc: true template: eisvogel.latex fontsize: 12pt geometry: margin=1in linkcolor: red urlcolor: blue --- 这是这个文件的 pdf，使用了之前的 YAML 前言和前面提到的 latex 模板。请注意，此 pdf 可能不反映对本文所做的最新更改。\n"},"name":"Rmarkdown 中的 Raku 代码","published":"2018-10-03T21:32:27+08:00","summary":"安装 首先，首先安装 R 编程语言。在此之后，运行 R 并执行以下命令来安装 rmarkdown: install.packages(\u0026quot;rmarkdown\u0026quot;)。在安装 rmarkdown 时，我收到以下错误消息:\nError: .onLoad failed in loadNamespace() for \u0026#39;tcltk\u0026#39;, details: call: dyn.load(file, DLLpath = DLLpath, ...) error: unable to load shared object \u0026#39;/usr/lib/R/library/tcltk/libs/tcltk.so\u0026#39;: libtk8.6.so: cannot open shared object file: No such file or directory 这可以通过安装包 tk 来解决，然后继续安装 rmarkdown。\nRmarkdown 的代码块 你可以用 rmarkdown 做的几乎所有都可以用“常规” markdown 来做的事情。然而，rmarkdown 的一个突出特性是它能够执行代码块并返回结果。为此，rmarkdown 使用了 knitr 包，这是一个使用 R 生成动态报告的引擎，除了 R 之外，它还支持其他语言引擎，您可以使用这些引擎来计算来自其他语言的代码。要列出可用引擎的名称，请在 R REPL 中执行 names(knitr::knit_engines$get()) 命令。就像“常规” markdown 一样，代码块可以用三个反勾号创建，然后是代码，最后是另外三个反勾号。如果希望计算代码块，请在花括号 {} 中指定语言，该语言位于前三个反勾号之后。例如，要执行 Perl 5 代码，可以在 {} 中指定 perl:","type":"entry","url":"https://ohmycloud.github.io/posts/2018-10-04-perl-6-code-in-rmarkdown/"}