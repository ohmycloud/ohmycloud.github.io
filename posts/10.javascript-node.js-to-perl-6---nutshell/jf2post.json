{"author":{"name":null,"type":"card","url":"https://ohmycloud.github.io/"},"content":{"html":"\u003cp\u003e大西瓜啊，忘记翻译了！\u003c/p\u003e\n\u003cp\u003eThis page attempts to provide a way for users experienced in Node.js to learn Raku. Features shared between the two languages will be explained here, as well as major differences in syntax and features.\u003c/p\u003e\n\u003cp\u003eThis is not a tutorial for learning Raku; this is a reference for users who are already at an intermediate to advanced skill level with Node.js.\u003c/p\u003e\n\u003cp\u003e此页面试图为在Node.js中有经验的用户提供学习Raku的方法。这里将解释两种语言之间共享的功能，以及语法和功能的主要差异。\u003c/p\u003e\n\u003cp\u003e这不是学习Raku的教程; 对于已经使用Node.js处于中级到高级技能级别的用户，这是一个参考。\u003c/p\u003e\n\u003ch1 id=\"基础语法httpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003e基础语法\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"hello-worldhttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003e\u0026ldquo;Hello, world!\u0026rdquo;\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eLet\u0026rsquo;s start with the typical first program when learning new languages. In Node.js, a hello world program would be written like this:\u003c/p\u003e\n\u003cp\u003e让我们从学习新语言时的典型第一个程序开始。在Node.js中，一个hello world程序将编写如下：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003econsole.log(\u0026#39;Hello, world!\u0026#39;);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere are a couple ways to write this in the same way in Raku:\u003c/p\u003e\n\u003cp\u003e以下是在Raku中以相同方式编写此内容的几种方法：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esay(\u0026#39;Hello, world!\u0026#39;);\nsay \u0026#39;Hello, world!\u0026#39;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eParentheses are optional for function calls in Raku. While semicolons are, for the most part, optional in Node.js, they are mandatory for expressions in Raku.\u003c/p\u003e\n\u003cp\u003eNow that we\u0026rsquo;ve greeted the world, let\u0026rsquo;s greet our good friend, Joe. We\u0026rsquo;ll start with Node.js again:\u003c/p\u003e\n\u003cp\u003e对于Raku中的函数调用，括号是可选的。虽然分号在Node.js中大多数是可选的，但它们对于Raku中的表达式是必需的。\u003c/p\u003e\n\u003cp\u003e现在我们迎接了世界，让我们迎接我们的好朋友乔。我们将再次从Node.js开始：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet name = \u0026#39;Joe\u0026#39;;\nconsole.log(\u0026#39;What\\\u0026#39;s up,\u0026#39; + name + \u0026#39;?\u0026#39;);\nconsole.log(`What\u0026#39;s up, {name}?`);\nconsole.log(\u0026#34;What\u0026#39;s up, \u0026#34;, name, \u0026#34;?\u0026#34;);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSince he didn\u0026rsquo;t hear us, let\u0026rsquo;s greet him again, this time in Raku:\u003c/p\u003e\n\u003cp\u003e因为他没有听到我们，所以让我再次问候他，这次是在Raku中：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy $name = \u0026#39;Joe\u0026#39;;\nsay \u0026#39;What\\\u0026#39;s up, \u0026#39; ~ $name ~ \u0026#39;?\u0026#39;;\nsay \u0026#34;What\u0026#39;s up, $name?\u0026#34;;\nsay \u0026#34;What\u0026#39;s up, \u0026#34;, $name, \u0026#34;?\u0026#34;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere, there are only a couple differences: most variables in Raku have what are called sigils, which are what the \u003ccode\u003e$\u003c/code\u003e in front of its name is, and string concatenation uses the \u003ccode\u003e~\u003c/code\u003e operator instead of \u003ccode\u003e+\u003c/code\u003e. What the two languages share in common here is support for string interpolation.\u003c/p\u003e\n\u003cp\u003eNow that the basic examples are out of the way, let\u0026rsquo;s explain the similarities between the two languages in greater detail.\u003c/p\u003e\n\u003cp\u003e这里只有几个不同之处：Raku中的大多数变量都有所谓的sigils，这就是\u003ccode\u003e$\u003c/code\u003e它名称前面的变量，字符串连接使用\u003ccode\u003e~\u003c/code\u003e运算符代替\u003ccode\u003e+\u003c/code\u003e。这两种语言的共同点是支持字符串插值。\u003c/p\u003e\n\u003cp\u003e现在基本的例子已经不在了，让我们更详细地解释两种语言之间的相似之处。\u003c/p\u003e\n\u003ch2 id=\"变量httpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003e变量\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eVariables in Node.js can be defined like this;\u003c/p\u003e\n\u003cp\u003eNode.js中的变量可以像这样定义;\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evar foo = 1;    // Lexically scoped with functions and modules\nlet foo = 1;    // Lexically scoped with blocks\nconst foo = 1;  // Lexically scoped with blocks; constant\n \nglobal.foo = 1; // Dynamically scoped; global\nfoo = 1;        // Ditto, but implicit; forbidden in strict mode\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn Raku there is no equivalent to \u003ccode\u003evar\u003c/code\u003e. An important note to make is that there is no variable hoisting in Raku; variables are defined and assigned at the line they\u0026rsquo;re on, not defined at the top of its scope and later assigned at that line.\u003c/p\u003e\n\u003cp\u003eThis is how the equivalent types of variables are defined in Raku:\u003c/p\u003e\n\u003cp\u003e在Raku中没有相当于\u003ccode\u003evar\u003c/code\u003e。需要注意的一点是，Raku中没有可变的吊装; 变量在它们所在的行上定义和分配，未在其范围的顶部定义，稍后在该行分配。\u003c/p\u003e\n\u003cp\u003e这是在Raku中定义等效类型的变量的方式：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy $foo = 1;      # Lexically scoped with blocks \nour $foo = 1;     # Lexically scoped with blocks and modules \nconstant foo = 1; # Lexically scoped with blocks and modules; constant \n \nmy $*foo = 1;       # Dynamically scoped with blocks \nOUR::\u0026lt;$foo\u0026gt; = 1;    # Dynamically scoped with blocks and modules \nGLOBAL::\u0026lt;$foo\u0026gt; = 1; # Dynamically scoped; global \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUse \u003ccode\u003emy\u003c/code\u003e where you\u0026rsquo;d use \u003ccode\u003elet\u003c/code\u003e, \u003ccode\u003eour\u003c/code\u003e for variables you\u0026rsquo;d define in the outermost scope needed, and \u003ccode\u003econstant\u003c/code\u003e where you\u0026rsquo;d uses \u003ccode\u003econst\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eDynamically scoped variables are not referred to in the same way as lexically scoped ones like they are in Node.js. User-defined ones use either a \u003ccode\u003e$*\u003c/code\u003e, \u003ccode\u003e@*\u003c/code\u003e, \u003ccode\u003e%*\u003c/code\u003e, or \u003ccode\u003e\u0026amp;*\u003c/code\u003e twigil. Refer to the documentation on \u003ca href=\"https://docs.raku.org/language/variables\"\u003evariables\u003c/a\u003e for more information on sigils, twigils, and variable containers.\u003c/p\u003e\n\u003cp\u003eVariables in Node.js can override others from outer scopes with the same name (though linters will usually complain about it depending on how they\u0026rsquo;re configured):\u003c/p\u003e\n\u003cp\u003e使用\u003ccode\u003emy\u003c/code\u003e您使用的位置\u003ccode\u003elet\u003c/code\u003e，\u003ccode\u003eour\u003c/code\u003e您需要在最外层范围内定义的变量以及\u003ccode\u003econstant\u003c/code\u003e您使用的位置\u003ccode\u003econst\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e动态范围变量的引用方式与它们在Node.js中的词汇范围变量相同。用户定义的那些使用一个\u003ccode\u003e$*\u003c/code\u003e，\u003ccode\u003e@*\u003c/code\u003e，\u003ccode\u003e%*\u003c/code\u003e，或\u003ccode\u003e\u0026amp;*\u003c/code\u003etwigil。有关sigils，twigils和变量容器的更多信息，请参阅有关\u003ca href=\"https://docs.raku.org/language/variables\"\u003e变量\u003c/a\u003e的文档。\u003c/p\u003e\n\u003cp\u003eNode.js中的变量可以覆盖具有相同名称的外部作用域中的其他变量（尽管linters通常会根据它们的配置方式来抱怨它）：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet foo = 1;\nfunction logDupe() {\n    let foo = 2;\n    console.log(foo);\n}\n \nlogDupe(2);       // 2\nconsole.log(foo); // 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRaku also allows this:\u003c/p\u003e\n\u003cp\u003eRaku 也允许这样：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy $foo = 1;\nsub log-dupe {\n    my $foo = 2;\n    say $foo;\n}\n \nlog-dupe; # 2 \nsay $foo; # 1 \n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"运算符httpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003e运算符\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"赋值httpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003e赋值\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003e=\u003c/code\u003e operator works the same across both languages.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e:=\u003c/code\u003e operator in Raku binds a value to a variable. Binding a variable to another variable gives them the same value and container, meaning mutating attributes of one will mutate the other\u0026rsquo;s as well. Bound variables cannot be reassigned with \u003ccode\u003e=\u003c/code\u003e or mutated with \u003ccode\u003e++\u003c/code\u003e, \u003ccode\u003e--\u003c/code\u003e, etc. but they can be bound to another value again:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e=\u003c/code\u003e 运算符可以跨两种语言相同。\u003c/p\u003e\n\u003cp\u003eRaku 中的 \u003ccode\u003e:=\u003c/code\u003e 运算符将值绑定到变量。将变量绑定到另一个变量会为它们提供相同的值和容器，这意味着一个变量属性也会改变另一个变量。绑定变量不能被重新分配\u003ccode\u003e=\u003c/code\u003e或突变\u003ccode\u003e++\u003c/code\u003e，\u003ccode\u003e--\u003c/code\u003e等，但它们可以被重新绑定到另一个值：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy %map;            # This is a hash, roughly equivalent to a JS object or map \nmy %unbound = %map;\nmy %bound := %map;\n%map\u0026lt;foo\u0026gt; = \u0026#39;bar\u0026#39;;\nsay %unbound;       # {} \nsay %bound;         # {foo =\u0026gt; bar} \n \n%bound := %unbound;\nsay %bound;         # {} \n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"相等httpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003e相等\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eNode.js has two equality operators: \u003ccode\u003e==\u003c/code\u003e and \u003ccode\u003e===\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e==\u003c/code\u003e is the loose equality operator. When comparing operands with the same type, it will return true if both operands are equal. However, if the operands are different types, they are both cast to their primitives before being compared, meaning these will return true:\u003c/p\u003e\n\u003cp\u003eNode.js有两个相等运算符：\u003ccode\u003e==\u003c/code\u003e和\u003ccode\u003e===\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e==\u003c/code\u003e是松散的平等算子。比较具有相同类型的操作数时，如果两个操作数相等，则返回true。但是，如果操作数是不同的类型，它们在被比较之前都被转换为它们的基元，这意味着它们将返回true：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003econsole\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e   \u003cspan class=\"o\"\u003e//\u003c/span\u003e \u003cspan class=\"n\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003econsole\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"o\"\u003e//\u003c/span\u003e \u003cspan class=\"n\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003econsole\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"o\"\u003e//\u003c/span\u003e \u003cspan class=\"n\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSimilarly, in Raku, both operands are cast to Numeric before comparison if they don\u0026rsquo;t share the same type:\u003c/p\u003e\n\u003cp\u003e类似地，在Raku中，如果它们不共享相同的类型，则在比较之前将两个操作数强制转换为Numeric：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esay 1 == 1;       # True \nsay \u0026#39;1\u0026#39; == 1;     # True \nsay [1,2,3] == 3; # True, since the array has three elements \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe inverse of \u003ccode\u003e==\u003c/code\u003e is \u003ccode\u003e!=\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eRaku has another operator similar to \u003ccode\u003e==\u003c/code\u003e: \u003ccode\u003eeq\u003c/code\u003e. Instead of casting operands to Numeric if they\u0026rsquo;re different types, \u003ccode\u003eeq\u003c/code\u003e will cast them to strings:\u003c/p\u003e\n\u003cp\u003e倒数\u003ccode\u003e==\u003c/code\u003e是\u003ccode\u003e!=\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003eRaku有另一个类似于的运算符\u003ccode\u003e==\u003c/code\u003e：\u003ccode\u003eeq\u003c/code\u003e。如果它们是不同的类型，而不是将操作数转换为Numeric，而不是\u003ccode\u003eeq\u003c/code\u003e将它们转换为字符串：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esay \u0026#39;1\u0026#39; eq \u0026#39;1\u0026#39;; # True \nsay 1 eq \u0026#39;1\u0026#39;;   # True \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe inverse of \u003ccode\u003eeq\u003c/code\u003e is \u003ccode\u003ene\u003c/code\u003e or \u003ccode\u003e!eq\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e===\u003c/code\u003e is the strict equality operator. This returns true if both operands are the same value. When comparing objects, this will \u003cem\u003eonly\u003c/em\u003e return true if they are the exact same object:\u003c/p\u003e\n\u003cp\u003e逆的\u003ccode\u003eeq\u003c/code\u003e是\u003ccode\u003ene\u003c/code\u003e或\u003ccode\u003e!eq\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e===\u003c/code\u003e是严格的相等运算符。如果两个操作数是相同的值，则返回true。比较对象时，如果它们是完全相同的对象，\u003cem\u003e则只\u003c/em\u003e返回true：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003econsole.log(1 === 1);   // true\nconsole.log(\u0026#39;1\u0026#39; === 1); // false\nconsole.log({} === {}); // false\n \nlet obj = {};\nlet obj2 = obj;\nconsole.log(obj === obj2); // true;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn Raku, the operator behaves the same, with one exception: two objects that have the same value, but different containers, will return false:\u003c/p\u003e\n\u003cp\u003e在Raku中，运算符的行为相同，但有一个例外：两个具有相同值但容器不同的对象将返回false：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esay 1 === 1; # True \nsay \u0026#39;1\u0026#39; === 1; # True \nsay {} === {};  # False \n \nmy \\hash = {};\nmy %hash = hash;\nsay hash === %hash; # False \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn the last case it\u0026rsquo;s the same object, but containers are different, which is why it returns False.\u003c/p\u003e\n\u003cp\u003eThe inverse of \u003ccode\u003e===\u003c/code\u003e is \u003ccode\u003e!==\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis is where Raku\u0026rsquo;s other equality operators are useful. If the values have different containers, the \u003ccode\u003eeqv\u003c/code\u003e operator can be used. This operator can be also be used to check for deep equality, which you would normally need to use a library for in Node.js:\u003c/p\u003e\n\u003cp\u003e在最后一种情况下，它是相同的对象，但容器是不同的，这就是它返回False的原因。\u003c/p\u003e\n\u003cp\u003e倒数\u003ccode\u003e===\u003c/code\u003e是\u003ccode\u003e!==\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这是Raku的其他相等运算符很有用的地方。如果值具有不同的容器，则\u003ccode\u003eeqv\u003c/code\u003e可以使用操作员。此运算符也可用于检查深度相等性，通常需要在Node.js中使用库：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esay {a =\u0026gt; 1} eqv {a =\u0026gt; 1}; # True; \n \nmy \\hash = {};\nmy %hash := hash;\nsay hash eqv %hash; # True \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn the case you need to check if two variables have the same container and value, use the \u003ccode\u003e=:=\u003c/code\u003e operator.\u003c/p\u003e\n\u003cp\u003e如果您需要检查两个变量是否具有相同的容器和值，请使用\u003ccode\u003e=:=\u003c/code\u003e运算符。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy @arr = [1,2,3];\nmy @arr2 := @arr;   # Bound variables keep the container of the other variable \nsay @arr =:= @arr2; # True \n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"smartmatchinghttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003eSmartmatching\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eRaku has one last operator for comparing values, but it is not exactly an equality operator. This is \u003ccode\u003e~~\u003c/code\u003e, the smartmatch operator. This has several uses: it can be used like \u003ccode\u003einstanceof\u003c/code\u003e in Node.js, to match a regex, and to check if a value is a key in a hash, bag, set, or map:\u003c/p\u003e\n\u003cp\u003eRaku有一个用于比较值的最后一个运算符，但它不完全是一个相等运算符。这就是\u003ccode\u003e~~\u003c/code\u003esmartmatch运营商。这有几个用途：它可以像\u003ccode\u003einstanceof\u003c/code\u003e在Node.js中一样使用，以匹配正则表达式，并检查值是否是散列，包，集或映射中的键：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esay \u0026#39;foo\u0026#39; ~~ Str; # True \n \nmy %hash = a =\u0026gt; 1;\nsay \u0026#39;a\u0026#39; ~~ %hash; # True \n \nmy $str = \u0026#39;abc\u0026#39;;\n$str ~~ s/abc/def/; # Mutates $str, like foo.replace(\u0026#39;abc\u0026#39;, \u0026#39;def\u0026#39;) \nsay $str;           # def \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhile we are talking about \u003ccode\u003einstanceof\u003c/code\u003e, the equivalent to the \u003ccode\u003econstructor\u003c/code\u003e property on Node.js objects in Raku is the \u003ccode\u003eWHAT\u003c/code\u003eattribute:\u003c/p\u003e\n\u003cp\u003e在我们讨论的时候\u003ccode\u003einstanceof\u003c/code\u003e，\u003ccode\u003econstructor\u003c/code\u003eRaku中Node.js对象的属性相当于\u003ccode\u003eWHAT\u003c/code\u003e属性：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003econsole.log(\u0026#39;foo\u0026#39;.constructor); // OUTPUT: String\nsay \u0026#39;foo\u0026#39;.WHAT; # OUTPUT: Str \n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"numerichttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003eNumeric\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eNode.js has \u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e, \u003ccode\u003e/\u003c/code\u003e, \u003ccode\u003e*\u003c/code\u003e, \u003ccode\u003e%\u003c/code\u003e, and (in ES6) \u003ccode\u003e**\u003c/code\u003e as numeric operators. When the operands are different types, similarly to the equality operators, are cast to their primitives before following through with the operation, making this possible:\u003c/p\u003e\n\u003cp\u003eNode.js的有\u003ccode\u003e+\u003c/code\u003e，\u003ccode\u003e-\u003c/code\u003e，\u003ccode\u003e/\u003c/code\u003e，\u003ccode\u003e*\u003c/code\u003e，\u003ccode\u003e%\u003c/code\u003e，和（在ES6）\u003ccode\u003e**\u003c/code\u003e作为数字运算符。当操作数是不同类型时，类似于相等运算符，在执行操作之前会转换为它们的基元，从而使这成为可能：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003econsole.log(1 + 2);   // 3\nconsole.log([] + {}); // [object Object]\nconsole.log({} + []); // 0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn Raku, again, they are converted to a Numeric type, as before:\u003c/p\u003e\n\u003cp\u003e在Raku中，它们再次转换为数字类型，如前所述：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esay 1 + 2;        # 3 \nsay [] + {};      # 0 \nsay {} + [1,2,3]; # 3 \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn addition, Raku has \u003ccode\u003ediv\u003c/code\u003e and \u003ccode\u003e%%\u003c/code\u003e. \u003ccode\u003ediv\u003c/code\u003e behaves like \u003ccode\u003eint\u003c/code\u003e division in C, while \u003ccode\u003e%%\u003c/code\u003e checks if one number is cleanly divisible by another or not:\u003c/p\u003e\n\u003cp\u003e另外，Raku有\u003ccode\u003ediv\u003c/code\u003e和\u003ccode\u003e%%\u003c/code\u003e。\u003ccode\u003ediv\u003c/code\u003e表现得像\u003ccode\u003eint\u003c/code\u003eC中的分裂，同时\u003ccode\u003e%%\u003c/code\u003e检查一个数字是否可以被另一个数字完全整除：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esay 4 div 3; # 1 \nsay 4 %% 3;  # False \nsay 6 %% 3;  # True \n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"bitwisehttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003eBitwise\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eNode.js has \u003ccode\u003e\u0026amp;\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e, \u003ccode\u003e^\u003c/code\u003e, \u003ccode\u003e~\u003c/code\u003e, \u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u0026gt;\u0026gt;\u003c/code\u003e, and \u003ccode\u003e~\u003c/code\u003e for bitwise operators:\u003c/p\u003e\n\u003cp\u003eNode.js的有\u003ccode\u003e\u0026amp;\u003c/code\u003e，\u003ccode\u003e|\u003c/code\u003e，\u003ccode\u003e^\u003c/code\u003e，\u003ccode\u003e~\u003c/code\u003e，\u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e，\u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e，\u003ccode\u003e\u0026gt;\u0026gt;\u0026gt;\u003c/code\u003e，和\u003ccode\u003e~\u003c/code\u003e对位运算符：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003econsole.log(1 \u0026lt;\u0026lt; 1);  // 2\nconsole.log(1 \u0026gt;\u0026gt; 1);  // 0\nconsole.log(1 \u0026gt;\u0026gt;\u0026gt; 1); // 0\nconsole.log(1 \u0026amp; 1);   // 1\nconsole.log(0 | 1);   // 1\nconsole.log(1 ^ 1);   // 0\nconsole.log(~1);      // -2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn Raku, there is no equivalent to \u003ccode\u003e\u0026gt;\u0026gt;\u0026gt;\u003c/code\u003e. All bitwise operators are prefixed with \u003ccode\u003e+\u003c/code\u003e, however two\u0026rsquo;s complement uses \u003ccode\u003e+^\u003c/code\u003e instead of \u003ccode\u003e~\u003c/code\u003e:\u003c/p\u003e\n\u003cp\u003e在Raku中，没有相当于\u003ccode\u003e\u0026gt;\u0026gt;\u0026gt;\u003c/code\u003e。所有按位运算符都以前缀为前缀\u003ccode\u003e+\u003c/code\u003e，但是使用两个补码\u003ccode\u003e+^\u003c/code\u003e而不是\u003ccode\u003e~\u003c/code\u003e：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esay 1 +\u0026lt; 1; # 2 \nsay 1 +\u0026gt; 1; # 0 \n            # No equivalent for \u0026gt;\u0026gt;\u0026gt; \nsay 1 +\u0026amp; 1; # 1 \nsay 0 +| 1; # 1 \nsay 1 +^ 1; # 0 \nsay +^1;    # -2 \n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"custom-operators-and-operator-overloadinghttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003eCustom operators and operator overloading\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eNode.js does not allow operator overloading without having to use a Makefile or build Node.js with a custom version of V8. Raku allows custom operators and operator overloading natively! Since all operators are subroutines, you can define your own like so:\u003c/p\u003e\n\u003cp\u003eNode.js不允许运算符重载而不必使用Makefile或使用自定义版本的V8构建Node.js. Raku允许自定义操作符和操作符本机重载！由于所有运算符都是子程序，因此您可以像这样定义自己的运算符：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emulti sub infix:\u0026lt;||=\u0026gt;($a, $b) is equiv(\u0026amp;infix:\u0026lt;+=\u0026gt;) { $a || $b }\n \nmy $foo = 0;\n$foo ||= 1;\nsay $foo; # OUTPUT: 1 \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOperators can be defined as \u003ccode\u003eprefix\u003c/code\u003e, \u003ccode\u003einfix\u003c/code\u003e, or \u003ccode\u003epostfix\u003c/code\u003e. The \u003ccode\u003eis tighter\u003c/code\u003e, \u003ccode\u003eis equiv\u003c/code\u003e, and \u003ccode\u003eis looser\u003c/code\u003e traits optionally define the operator\u0026rsquo;s precedence. In this case, \u003ccode\u003e||=\u003c/code\u003e has the same precedence as \u003ccode\u003e+=\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eNote how \u003ccode\u003emulti\u003c/code\u003e is used when declaring the operator subroutines. This allows multiple subroutines with the same name to be declared while also having different signatures. This will be explained in greater detail in the \u003ca href=\"https://docs.raku.org/language/js-nutshell#Functions\"\u003eFunctions\u003c/a\u003e section. For now, all we need to know is that it allows us to override any native operator we want:\u003c/p\u003e\n\u003cp\u003e运算符可以定义为\u003ccode\u003eprefix\u003c/code\u003e，\u003ccode\u003einfix\u003c/code\u003e，或\u003ccode\u003epostfix\u003c/code\u003e。的\u003ccode\u003eis tighter\u003c/code\u003e，\u003ccode\u003eis equiv\u003c/code\u003e和\u003ccode\u003eis looser\u003c/code\u003e性状选择定义操作的优先级。在这种情况下，\u003ccode\u003e||=\u003c/code\u003e具有相同的优先级\u003ccode\u003e+=\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e注意\u003ccode\u003emulti\u003c/code\u003e在声明操作符子例程时如何使用。这允许声明具有相同名称的多个子例程，同时具有不同的签名。这将在“ \u003ca href=\"https://docs.raku.org/language/js-nutshell#Functions\"\u003e功能”\u003c/a\u003e部分中详细说明。目前，我们需要知道的是它允许我们覆盖我们想要的任何本机运算符：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Using the `is default` trait here forces this subroutine to be chosen first, \n# so long as the signature of the subroutine matches. \nmulti sub prefix:\u0026lt;++\u0026gt;($a) is default { $a - 1 }\n \nmy $foo = 1;\nsay ++$foo; # OUTPUT: 0 \n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"control-flowhttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003eControl flow\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"ifelsehttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003eif/else\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eYou should be familiar with how \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e looks in JavaScript:\u003c/p\u003e\n\u003cp\u003e您应该熟悉 JavaScript 中的 \u003ccode\u003eif\u003c/code\u003e/ \u003ccode\u003eelse\u003c/code\u003e：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet diceRoll = Math.ceil(Math.random() * 6) + Math.ceil(Math.random() * 6);\nif (diceRoll === 2) {\n    console.log(\u0026#39;Snake eyes!\u0026#39;);\n} else if (diceRoll === 16) {\n    console.log(\u0026#39;Boxcars!\u0026#39;);\n} else {\n    console.log(`Rolled ${diceRoll}.`);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn Raku, \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e works largely the same, with a few key differences. One, parentheses are not required. Two, \u003ccode\u003eelse if\u003c/code\u003e is written as \u003ccode\u003eelsif\u003c/code\u003e. Three, the if clause may be written \u003cem\u003eafter\u003c/em\u003e a statement:\u003c/p\u003e\n\u003cp\u003e在Raku中，\u003ccode\u003eif\u003c/code\u003e/的\u003ccode\u003eelse\u003c/code\u003e工作方式基本相同，只有一些关键的区别。一，括号不是必需的。二，\u003ccode\u003eelse if\u003c/code\u003e写成\u003ccode\u003eelsif\u003c/code\u003e。三，if语句可以\u003cem\u003e在\u003c/em\u003e声明\u003cem\u003e后\u003c/em\u003e写出：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy Int $dice-roll = ceiling rand * 12 + ceiling rand * 12;\nif $dice-roll == 2 {\n    say \u0026#39;Snake eyes!\u0026#39;;\n} elsif $dice-roll == 16 {\n    say \u0026#39;Boxcars!\u0026#39;;\n} else {\n    say \u0026#34;Rolled $dice-roll.\u0026#34;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAlternatively, though less efficient, this could be written to use \u003ccode\u003eif\u003c/code\u003e after statements:\u003c/p\u003e\n\u003cp\u003e或者，虽然效率较低，但可以\u003ccode\u003eif\u003c/code\u003e在语句后使用：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy Int $dice-roll = ceiling rand * 12 + ceiling rand * 12;\nsay \u0026#39;Snake eyes!\u0026#39;        if $dice-roll == 2;\nsay \u0026#39;Boxcars!\u0026#39;           if $dice-roll == 16;\nsay \u0026#34;Rolled $dice-roll.\u0026#34; if $dice-roll !~~ 2 | 16;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRaku also has \u003ccode\u003ewhen\u003c/code\u003e, which is like \u003ccode\u003eif\u003c/code\u003e, but if the condition given is true, no code past the \u003ccode\u003ewhen\u003c/code\u003e block within the block it\u0026rsquo;s in is executed:\u003c/p\u003e\n\u003cp\u003eRaku也有\u003ccode\u003ewhen\u003c/code\u003e，就像是\u003ccode\u003eif\u003c/code\u003e，但是如果给出的条件为真，\u003ccode\u003ewhen\u003c/code\u003e那么执行它所执行的块中没有代码超过块：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e{\n    when True {\n        say \u0026#39;In when block!\u0026#39;; # OUTPUT: In when block! \n    }\n    say \u0026#39;This will never be output!\u0026#39;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAdditionally, Raku has \u003ccode\u003ewith\u003c/code\u003e, \u003ccode\u003eorwith\u003c/code\u003e, and \u003ccode\u003ewithout\u003c/code\u003e, which are like \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003eelse if\u003c/code\u003e, and \u003ccode\u003eelse\u003c/code\u003e respectively, but instead of checking whether their condition is true, they check if it\u0026rsquo;s defined.\u003c/p\u003e\n\u003cp\u003e此外，Raku的有\u003ccode\u003ewith\u003c/code\u003e，\u003ccode\u003eorwith\u003c/code\u003e和\u003ccode\u003ewithout\u003c/code\u003e，这是一样\u003ccode\u003eif\u003c/code\u003e，\u003ccode\u003eelse if\u003c/code\u003e和，\u003ccode\u003eelse\u003c/code\u003e分别但是，不是检查自己的条件是否为真，他们检查，如果它被定义。\u003c/p\u003e\n\u003ch3 id=\"switchhttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003eswitch\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSwitch statements are a way of checking for equality between a given value and a list of values and run some code if one matches. \u003ccode\u003ecase\u003c/code\u003e statements define each value to compare to. \u003ccode\u003edefault\u003c/code\u003e, if included, acts as a fallback for when the given value matches no cases. After matching a case, \u003ccode\u003ebreak\u003c/code\u003e is typically used to prevent the code from the cases that follow the one matched from being executed, though rarely this is intentionally omitted.\u003c/p\u003e\n\u003cp\u003eSwitch语句是一种检查给定值和值列表之间相等性的方法，并在匹配时运行一些代码。\u003ccode\u003ecase\u003c/code\u003e语句定义要比较的每个值。\u003ccode\u003edefault\u003c/code\u003e，如果包含，则作为给定值不匹配任何情况的后备。在匹配案例之后，\u003ccode\u003ebreak\u003c/code\u003e通常用于防止代码跟随匹配的案例执行，尽管很少有意省略。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003econst ranklist = [2, 3, 4, 5, 6, 7, 8, 9, \u0026#39;Jack\u0026#39;, \u0026#39;Queen\u0026#39;, \u0026#39;King\u0026#39;, \u0026#39;Ace\u0026#39;];\nconst ranks    = Array.from(Array(3), () =\u0026gt; ranklist[Math.floor(Math.random() * ranks.length)]);\nlet   score    = 0;\n \nfor (let rank of ranks) {\n    switch (rank) {\n        case \u0026#39;Jack\u0026#39;:\n        case \u0026#39;Queen\u0026#39;:\n        case \u0026#39;King\u0026#39;:\n            score += 10;\n            break;\n        case \u0026#39;Ace\u0026#39;;\n            score += (score \u0026lt;= 11) ? 10 : 1;\n            break;\n        default:\n            score += rank;\n            break;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn Raku, \u003ccode\u003egiven\u003c/code\u003e can be used like switch statements. There is no equivalent to \u003ccode\u003ebreak\u003c/code\u003e since \u003ccode\u003ewhen\u003c/code\u003e blocks are most commonly used like \u003ccode\u003ecase\u003c/code\u003e statements. One major difference between \u003ccode\u003eswitch\u003c/code\u003e and \u003ccode\u003egiven\u003c/code\u003e is that a value passed to a \u003ccode\u003eswitch\u003c/code\u003e statement will only match cases that are exactly equal to the value; \u003ccode\u003egiven\u003c/code\u003e values are smartmatched (\u003ccode\u003e~~\u003c/code\u003e) against the \u003ccode\u003ewhen\u003c/code\u003e values.\u003c/p\u003e\n\u003cp\u003e在Raku中，\u003ccode\u003egiven\u003c/code\u003e可以像switch语句一样使用。没有相应的，\u003ccode\u003ebreak\u003c/code\u003e因为\u003ccode\u003ewhen\u003c/code\u003e块最常用于\u003ccode\u003ecase\u003c/code\u003e语句。\u003ccode\u003eswitch\u003c/code\u003e和之间的一个主要区别\u003ccode\u003egiven\u003c/code\u003e是传递给\u003ccode\u003eswitch\u003c/code\u003e语句的值只匹配与值完全相等的情况; \u003ccode\u003egiven\u003c/code\u003e值是\u003ccode\u003e~~\u003c/code\u003e针对值的smartmatched（）\u003ccode\u003ewhen\u003c/code\u003e。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy     @ranklist = [2, 3, 4, 5, 6, 7, 8, 9, \u0026#39;Jack\u0026#39;, \u0026#39;Queen\u0026#39;, \u0026#39;King\u0026#39;, \u0026#39;Ace\u0026#39;];\nmy     @ranks    = @ranklist.pick: 3;\nmy Int $score    = 0;\n \nfor @ranks -\u0026gt; $rank {\n    # The when blocks implicitly return the last statement they contain. \n    $score += do given $rank {\n        when \u0026#39;Jack\u0026#39; | \u0026#39;Queen\u0026#39; | \u0026#39;King\u0026#39; { 10 }\n        when \u0026#39;Ace\u0026#39; { $score \u0026lt;= 11 ?? 10 !! 1 }\n        default { $_ }\n    };\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf there are multiple \u003ccode\u003ewhen\u003c/code\u003e blocks that match the value passed to \u003ccode\u003egiven\u003c/code\u003e and you wish to run more than one of them, use \u003ccode\u003eproceed\u003c/code\u003e. \u003ccode\u003esucceed\u003c/code\u003e may be used to exit both the \u003ccode\u003ewhen\u003c/code\u003e block it\u0026rsquo;s in and the given block, preventing any following statements from being executed:\u003c/p\u003e\n\u003cp\u003e如果有多个\u003ccode\u003ewhen\u003c/code\u003e块与传递的值匹配，\u003ccode\u003egiven\u003c/code\u003e并且您希望运行多个块，请使用\u003ccode\u003eproceed\u003c/code\u003e。\u003ccode\u003esucceed\u003c/code\u003e可用于退出\u003ccode\u003ewhen\u003c/code\u003e它所在的块和给定的块，防止执行以下任何语句：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003egiven Int {\n    when Int     { say \u0026#39;Int is Int\u0026#39;;     proceed }\n    when Numeric { say \u0026#39;Int is Numeric\u0026#39;; proceed }\n    when Any     { say \u0026#39;Int is Any\u0026#39;;     succeed }\n    when Mu      { say \u0026#39;Int is Mu\u0026#39;               } # Won\u0026#39;t output \n}\n \n# OUTPUT: \n# Int is Int \n# Int is Numeric \n# Int is Any \n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"for-while-and-dowhilehttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003efor, while, and do/while\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThere are three different types of for loops in JavaScript:\u003c/p\u003e\n\u003cp\u003eJavaScript中有三种不同类型的for循环：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// C-style for loops\nconst letters = {};\nfor (let ord = 0x61; ord \u0026lt;= 0x7A; ord++) {\n    let letter = String.fromCharCode(ord);\n    letters[letter] = letter.toUpperCase();\n}\n \n// for..in loops (typically used on objects)\nfor (let letter in letters) {\n    console.log(letters[letter]);\n    # OUTPUT: \n    # A \n    # B \n    # C \n    # etc. \n}\n \n// for..of loops (typically used on arrays, maps, and sets)\nfor (let letter of Object.values(letters)) {\n    console.log(letter);\n    # OUTPUT: \n    # A \n    # B \n    # C \n    # etc. \n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRaku \u003ccode\u003efor\u003c/code\u003e loops most closely resemble \u003ccode\u003efor..of\u003c/code\u003e loops, since they work on anything as long as it\u0026rsquo;s iterable. C-style loops are possible to write using \u003ccode\u003eloop\u003c/code\u003e, but this is discouraged since they\u0026rsquo;re better written as \u003ccode\u003efor\u003c/code\u003e loops using ranges. Like \u003ccode\u003eif\u003c/code\u003e statements, \u003ccode\u003efor\u003c/code\u003e may follow a statement, with the current iteration being accessible using the \u003ccode\u003e$_\u003c/code\u003e variable (known as \u0026ldquo;it\u0026rdquo;). Methods on \u003ccode\u003e$_\u003c/code\u003e may be called without specifying the variable:\u003c/p\u003e\n\u003cp\u003eRaku \u003ccode\u003efor\u003c/code\u003e循环最接近\u003ccode\u003efor..of\u003c/code\u003e循环，因为只要它是可迭代的，它们就可以处理任何东西。C风格的循环可以使用\u003ccode\u003eloop\u003c/code\u003e，但不鼓励这样做，因为它们更好地编写为\u003ccode\u003efor\u003c/code\u003e使用范围的循环。类似\u003ccode\u003eif\u003c/code\u003e语句，\u003ccode\u003efor\u003c/code\u003e可以遵循一个语句，当前迭代可以使用\u003ccode\u003e$_\u003c/code\u003e变量（称为“它”）访问。\u003ccode\u003e$_\u003c/code\u003e可以在不指定变量的情况下调用方法：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy Str %letters{Str};\n%letters{$_} = .uc for \u0026#39;a\u0026#39;..\u0026#39;z\u0026#39;;\n.say for %letters.values;\n# OUTPUT: \n# A \n# B \n# C \n# etc. \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003ewhile\u003c/code\u003e loops work identically between JavaScript and Raku. Raku also has \u003ccode\u003euntil\u003c/code\u003e loops, where instead of iterating until the given condition is false, they iterate until the condition is true.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edo/while\u003c/code\u003e loops are known as \u003ccode\u003erepeat/while\u003c/code\u003e loops in Raku. Likewise with \u003ccode\u003ewhile\u003c/code\u003e, \u003ccode\u003erepeat/until\u003c/code\u003e loops also exist and loop until the given condition is false.\u003c/p\u003e\n\u003cp\u003eTo write infinite loops in Raku, use \u003ccode\u003eloop\u003c/code\u003e rather than \u003ccode\u003efor\u003c/code\u003e or \u003ccode\u003ewhile\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn JavaScript, \u003ccode\u003econtinue\u003c/code\u003e is used to skip to the next iteration in a loop, and \u003ccode\u003ebreak\u003c/code\u003e is used to exit a loop early:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ewhile\u003c/code\u003e循环在JavaScript和Raku之间的工作相同.Raku也有\u003ccode\u003euntil\u003c/code\u003e循环，而不是迭代直到给定条件为假，它们迭代直到条件为真。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edo/while\u003c/code\u003e循环\u003ccode\u003erepeat/while\u003c/code\u003e在Raku 中称为循环。同样\u003ccode\u003ewhile\u003c/code\u003e，\u003ccode\u003erepeat/until\u003c/code\u003e循环也存在并循环，直到给定条件为假。\u003c/p\u003e\n\u003cp\u003e要在Raku中编写无限循环，请使用\u003ccode\u003eloop\u003c/code\u003e而不是\u003ccode\u003efor\u003c/code\u003e或\u003ccode\u003ewhile\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e在JavaScript中，\u003ccode\u003econtinue\u003c/code\u003e用于跳转到循环中的下一个迭代，并\u003ccode\u003ebreak\u003c/code\u003e用于提前退出循环：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elet primes = new Set();\nlet i      = 2;\n \ndo {\n    let isPrime = true;\n    for (let prime of primes) {\n        if (i % prime == 0) {\n            isPrime = false;\n            break;\n        }\n    }\n    if (!isPrime) continue;\n    primes.add(i);\n} while (++i \u0026lt; 20);\n \nconsole.log(primes); # OUTPUT: Set { 2, 3, 5, 7, 11, 13, 17, 19 } \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn Raku, these are known as \u003ccode\u003enext\u003c/code\u003e and \u003ccode\u003elast\u003c/code\u003e respectively. There is also \u003ccode\u003eredo\u003c/code\u003e, which repeats the current iteration without evaluating the loop\u0026rsquo;s condition again.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enext\u003c/code\u003e/\u003ccode\u003eredo\u003c/code\u003e/\u003ccode\u003elast\u003c/code\u003e statements may be followed by a label defined before an outer loop to make the statement work on the loop the label refers to, rather than the loop the statement is in:\u003c/p\u003e\n\u003cp\u003e在Raku中，这些分别称为\u003ccode\u003enext\u003c/code\u003e和\u003ccode\u003elast\u003c/code\u003e。还有\u003ccode\u003eredo\u003c/code\u003e，它重复当前迭代而不再评估循环的条件。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enext\u003c/code\u003e/ \u003ccode\u003eredo\u003c/code\u003e/ \u003ccode\u003elast\u003c/code\u003e语句后跟一个在外部循环之前定义的标签，以使该语句在标签所引用的循环上起作用，而不是该语句所在的循环：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy %primes is SetHash;\nmy Int $i = 2;\n \nOUTSIDE:\nrepeat {\n    next OUTSIDE if $i %% $_ for %primes.keys;\n    %primes{$i}++;\n} while ++$i \u0026lt; 20;\n \nsay %primes; # OUTPUT: SetHash(11 13 17 19 2 3 5 7) \n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"dohttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003edo\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003edo\u003c/code\u003e is not currently a feature in JavaScript, however a proposal has been made to \u003ca href=\"https://github.com/tc39/proposal-do-expressions\"\u003eadd it to ECMAScript\u003c/a\u003e. \u003ccode\u003edo\u003c/code\u003e expressions evaluate a block and return the result:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edo\u003c/code\u003e目前不是JavaScript中的一项功能，但已提出\u003ca href=\"https://github.com/tc39/proposal-do-expressions\"\u003e将其添加到ECMAScript\u003c/a\u003e的提案。\u003ccode\u003edo\u003c/code\u003e表达式计算一个块并返回结果：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003econstant VERSION        = v2.0.0;\nconstant VERSION_NUMBER = do {\n    my @digits = VERSION.Str.comb(/\\d+/);\n    :16(sprintf \u0026#34;%02x%02x%04x\u0026#34;, |@digits)\n};\nsay VERSION_NUMBER; # OUTPUT: 33554432 \n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"typeshttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003eTypes\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"creating-typeshttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003eCreating types\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eIn JavaScript, types are created by making a class (or a constructor in ES5 and earlier). If you\u0026rsquo;ve used TypeScript, you can define a type as a subset of other types like so:\u003c/p\u003e\n\u003cp\u003e在JavaScript中，通过创建类（或ES5及更早版本中的构造函数）来创建类型。如果您使用过TypeScript，则可以将类型定义为其他类型的子集，如下所示：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003etype ID = string | number;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn Raku, classes, roles, subsets, and enums are considered types. Creating classes and roles will be discussed in \u003ca href=\"https://docs.raku.org/language/js-nutshell#Object-oriented_programming\"\u003ethe OOP section of this article\u003c/a\u003e. Creating an ID subset can be done like so:\u003c/p\u003e\n\u003cp\u003e在Raku中，类，角色，子集和枚举被视为类型。创建类和角色将在本文\u003ca href=\"https://docs.raku.org/language/js-nutshell#Object-oriented_programming\"\u003e的OOP部分中讨论\u003c/a\u003e。创建ID子集可以这样完成：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esubset ID where Str | Int;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSee the documentation on \u003ca href=\"https://docs.raku.org/language/typesystem#subset\"\u003esubset\u003c/a\u003e and \u003ca href=\"https://docs.raku.org/type/Junction\"\u003eJunction\u003c/a\u003e for more information.\u003c/p\u003e\n\u003cp\u003eTypeScript enums may have numbers or strings as their values. Defining the values is optional; by default, the value of the first key is 0, the next key, 1, the next, 2, etc. For example, here is an enum that defines directions for extended ASCII arrow symbols (perhaps for a TUI game):\u003c/p\u003e\n\u003cp\u003e有关更多信息，请参阅\u003ca href=\"https://docs.raku.org/language/typesystem#subset\"\u003e子集\u003c/a\u003e和\u003ca href=\"https://docs.raku.org/type/Junction\"\u003e连接\u003c/a\u003e的文档。\u003c/p\u003e\n\u003cp\u003eTypeScript枚举可以包含数字或字符串作为其值。定义值是可选的; 默认情况下，第一个键的值为0，下一个键为1，下一个键为2，等等。例如，这是一个枚举，用于定义扩展ASCII箭头符号的方向（可能用于TUI游戏）：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eenum Direction (\n    UP    = \u0026#39;↑\u0026#39;,\n    DOWN  = \u0026#39;↓\u0026#39;,\n    LEFT  = \u0026#39;←\u0026#39;,\n    RIGHT = \u0026#39;→\u0026#39;\n);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEnums in Raku may have any type as their keys\u0026rsquo; values. Enum keys (and optionally, values) can be defined by writing \u003ccode\u003eenum\u003c/code\u003e, followed by the name of the enum, then the list of keys (and optionally, values), which can be done using \u003ca href=\"https://docs.raku.org/language/quoting#Word_quoting%3A_%3C_%3E\"\u003e\u0026lt; \u0026gt;\u003c/a\u003e, \u003ca href=\"https://docs.raku.org/language/quoting#Word_quoting_with_interpolation_and_quote_protection%3A_%C2%AB_%C2%BB\"\u003e« »\u003c/a\u003e, or \u003ca href=\"https://docs.raku.org/language/operators#term_%28_%29\"\u003e( )\u003c/a\u003e. \u003ccode\u003e( )\u003c/code\u003e must be used if you want to define values for the enum\u0026rsquo;s keys. Here is the Direction enum as written in Raku:\u003c/p\u003e\n\u003cp\u003eRaku中的枚举可以使用任何类型作为其键值。枚举键（以及可选的值）可以通过写入来定义\u003ccode\u003eenum\u003c/code\u003e，然后是枚举的名称，然后是键列表（以及可选的值），可以使用\u003ca href=\"https://docs.raku.org/language/quoting#Word_quoting%3A_%3C_%3E\"\u003e\u0026lt;\u0026gt;\u003c/a\u003e，\u003ca href=\"https://docs.raku.org/language/quoting#Word_quoting_with_interpolation_and_quote_protection%3A_%C2%AB_%C2%BB\"\u003e«»\u003c/a\u003e或\u003ca href=\"https://docs.raku.org/language/operators#term_%28_%29\"\u003e（）来完成\u003c/a\u003e。\u003ccode\u003e( )\u003c/code\u003e如果要为枚举键定义值，则必须使用。这是Raku中编写的Direction枚举：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eenum Direction (\n    UP    =\u0026gt; \u0026#39;↑\u0026#39;,\n    DOWN  =\u0026gt; \u0026#39;↓\u0026#39;,\n    LEFT  =\u0026gt; \u0026#39;←\u0026#39;,\n    RIGHT =\u0026gt; \u0026#39;→\u0026#39;\n);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSee the documentation on \u003ca href=\"https://docs.raku.org/language/typesystem#enum\"\u003eenum\u003c/a\u003e for more information.\u003c/p\u003e\n\u003cp\u003e有关更多信息，请参阅\u003ca href=\"https://docs.raku.org/language/typesystem#enum\"\u003e枚举\u003c/a\u003e文档。\u003c/p\u003e\n\u003ch3 id=\"using-typeshttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003eUsing types\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eIn TypeScript, you can define the type of variables. Attempting to assign a value that doesn\u0026rsquo;t match the type of the variable will make the transpiler error out. This is done like so:\u003c/p\u003e\n\u003cp\u003e在TypeScript中，您可以定义变量的类型。尝试分配与变量类型不匹配的值将导致转换器错误。这样做是这样的：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eenum Name (Phoebe, Daniel, Joe);\nlet name: string = \u0026#39;Phoebe\u0026#39;;\nname = Phoebe; # Causes tsc to error out \n \nlet hobbies: [string] = [\u0026#39;origami\u0026#39;, \u0026#39;playing instruments\u0026#39;, \u0026#39;programming\u0026#39;];\n \nlet todo: Map\u0026lt;string, boolean\u0026gt; = new Map([\n    [\u0026#39;clean the bathroom\u0026#39;, false],\n    [\u0026#39;walk the dog\u0026#39;, true],\n    [\u0026#39;wash the dishes\u0026#39;, true]\n]);\n \nlet doJob: (job: string) =\u0026gt; boolean = function (job: string): boolean {\n    todo.set(job, true);\n    return true;\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn Raku, variables can be typed by placing the type between the declarator (\u003ccode\u003emy\u003c/code\u003e, \u003ccode\u003eour\u003c/code\u003e, etc.) and the variable name. Assigning a value that doesn\u0026rsquo;t match the variable\u0026rsquo;s type will throw either a compile-time or runtime error, depending on how the value is evaluated:\u003c/p\u003e\n\u003cp\u003e在Raku中，变量可以通过将说明符（之间的类型被键入\u003ccode\u003emy\u003c/code\u003e，\u003ccode\u003eour\u003c/code\u003e等）和变量名。分配与变量类型不匹配的值将引发编译时或运行时错误，具体取决于值的计算方式：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eenum Name \u0026lt;Phoebe Daniel Joe\u0026gt;;\nmy Str $name = \u0026#39;Phoebe\u0026#39;;\n$name = Phoebe; # Throws a compile-time error \n \n# The type here defines the type of the elements of the array. \nmy Str @hobbies = [\u0026#39;origami\u0026#39;, \u0026#39;playing instruments\u0026#39;, \u0026#39;programming\u0026#39;];\n \n# The type between the declarator and variable defines the type of the values \n# of the hash. \n# The type in the curly braces defines the type of the keys of the hash. \nmy Bool %todo{Str} = (\n    \u0026#39;clean the bathroom\u0026#39; =\u0026gt; False,\n    \u0026#39;walk the dog\u0026#39;       =\u0026gt; True,\n    \u0026#39;wash the dishes\u0026#39;    =\u0026gt; True\n);\n \n# The type here defines the return value of the routine. \nmy Bool \u0026amp;do-job = sub (Str $job --\u0026gt; Bool) {\n    %todo{$job} = True;\n};\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"比较-javascript-和-raku-的类型httpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003e比较 JavaScript 和 Raku 的类型\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eHere is a table of some JavaScript types and their equivalents in Raku:\u003c/p\u003e\n\u003cp\u003e以下是Raku中一些JavaScript类型及其等价物的表格：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003eJavaScript\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003eRaku\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eObject\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eMu, Any, Hash\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eArray\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eList, Array, Seq\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eString\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eStr\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eNumber\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eInt, Num, Rat\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eBoolean\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eBool\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eMap\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eMap, Hash\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eSet\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eSet, SetHash\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003ccode\u003eObject\u003c/code\u003e is both a superclass of all types in JavaScript and a way to create a hash. In Raku, \u003ca href=\"https://docs.raku.org/type/Mu\"\u003eMu\u003c/a\u003e is a superclass of all types, though usually you want to use \u003ca href=\"https://docs.raku.org/type/Any\"\u003eAny\u003c/a\u003e instead, which is a subclass of \u003ccode\u003eMu\u003c/code\u003e but also a superclass of nearly every type, with \u003ca href=\"https://docs.raku.org/type/Junction\"\u003eJunction\u003c/a\u003e being an exception. When using \u003ccode\u003eObject\u003c/code\u003e as a hash, \u003ca href=\"https://docs.raku.org/type/Hash\"\u003eHash\u003c/a\u003e is what you want to use.\u003c/p\u003e\n\u003cp\u003eThere are three types equivalent to \u003ccode\u003eArray\u003c/code\u003e. \u003ca href=\"https://docs.raku.org/type/Array\"\u003eArray\u003c/a\u003e is most similar to \u003ccode\u003eArray\u003c/code\u003e, since it acts as a mutable array. \u003ca href=\"https://docs.raku.org/type/List\"\u003eList\u003c/a\u003e is similar to \u003ccode\u003eArray\u003c/code\u003e, but is immutable. \u003ca href=\"https://docs.raku.org/type/Seq\"\u003eSeq\u003c/a\u003e is used to create lazy arrays.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eString\u003c/code\u003e and \u003ca href=\"https://docs.raku.org/type/Str\"\u003eStr\u003c/a\u003e are for the most part used identically.\u003c/p\u003e\n\u003cp\u003eThere are several different types in Raku equivalent to \u003ccode\u003eNumber\u003c/code\u003e, but the three you\u0026rsquo;ll most commonly see are \u003ca href=\"https://docs.raku.org/type/Int\"\u003eInt\u003c/a\u003e, \u003ca href=\"https://docs.raku.org/type/Num\"\u003eNum\u003c/a\u003e, and \u003ca href=\"https://docs.raku.org/type/Rat\"\u003eRat\u003c/a\u003e. \u003ccode\u003eInt\u003c/code\u003erepresents an integer. \u003ccode\u003eNum\u003c/code\u003e represents a floating-point number, making it the most similar to \u003ccode\u003eNumber\u003c/code\u003e. \u003ccode\u003eRat\u003c/code\u003e represents a fraction of two numbers, and is used when \u003ccode\u003eNum\u003c/code\u003e cannot provide precise enough values.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eBoolean\u003c/code\u003e and \u003ca href=\"https://docs.raku.org/type/Bool\"\u003eBool\u003c/a\u003e are for the most part used identically.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eMap\u003c/code\u003e has both a mutable and an immutable equivalent in Raku. \u003ca href=\"https://docs.raku.org/type/Map\"\u003eMap\u003c/a\u003e is the immutable one, and \u003ca href=\"https://docs.raku.org/type/Hash\"\u003eHash\u003c/a\u003e is the mutable one. Don\u0026rsquo;t get them mixed up! Like \u003ccode\u003eMap\u003c/code\u003e in JavaScript, \u003ccode\u003eMap\u003c/code\u003e and \u003ccode\u003eHash\u003c/code\u003e can have any type of key or value, not just strings for keys.\u003c/p\u003e\n\u003cp\u003eLike \u003ccode\u003eMap\u003c/code\u003e, \u003ccode\u003eSet\u003c/code\u003e also has both a mutable and an immutable equivalent in Raku. \u003ca href=\"https://docs.raku.org/type/Set\"\u003eSet\u003c/a\u003e is the immutable one, and \u003ca href=\"https://docs.raku.org/type/SetHash\"\u003eSetHash\u003c/a\u003e is the mutable one.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eObject\u003c/code\u003e既是JavaScript中所有类型的超类，也是创建哈希的方法。在Raku中，\u003ca href=\"https://docs.raku.org/type/Mu\"\u003e穆\u003c/a\u003e是所有类型的超类，尽管通常要使用\u003ca href=\"https://docs.raku.org/type/Any\"\u003e任何\u003c/a\u003e代替，这是的一个子类\u003ccode\u003eMu\u003c/code\u003e，而且几乎所有类型的超类，与\u003ca href=\"https://docs.raku.org/type/Junction\"\u003e接线\u003c/a\u003e是一个例外。当\u003ccode\u003eObject\u003c/code\u003e用作哈希时，\u003ca href=\"https://docs.raku.org/type/Hash\"\u003e哈希\u003c/a\u003e就是你想要使用的。\u003c/p\u003e\n\u003cp\u003e有三种类型相当于\u003ccode\u003eArray\u003c/code\u003e。\u003ca href=\"https://docs.raku.org/type/Array\"\u003e数组\u003c/a\u003e最相似\u003ccode\u003eArray\u003c/code\u003e，因为它充当可变数组。\u003ca href=\"https://docs.raku.org/type/List\"\u003e列表\u003c/a\u003e类似于\u003ccode\u003eArray\u003c/code\u003e，但是是不可变的。\u003ca href=\"https://docs.raku.org/type/Seq\"\u003eSeq\u003c/a\u003e用于创建惰性数组。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eString\u003c/code\u003e和\u003ca href=\"https://docs.raku.org/type/Str\"\u003eStr\u003c/a\u003e在大多数情况下使用相同。\u003c/p\u003e\n\u003cp\u003eRaku中有几种不同的类型相当于\u003ccode\u003eNumber\u003c/code\u003e，但你最常见的三种是\u003ca href=\"https://docs.raku.org/type/Int\"\u003eInt\u003c/a\u003e，\u003ca href=\"https://docs.raku.org/type/Num\"\u003eNum\u003c/a\u003e和\u003ca href=\"https://docs.raku.org/type/Rat\"\u003eRat\u003c/a\u003e。\u003ccode\u003eInt\u003c/code\u003e表示整数。\u003ccode\u003eNum\u003c/code\u003e表示一个浮点数，使其最相似\u003ccode\u003eNumber\u003c/code\u003e。\u003ccode\u003eRat\u003c/code\u003e表示两个数字的一小部分，并且在\u003ccode\u003eNum\u003c/code\u003e无法提供足够精确的值时使用。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eBoolean\u003c/code\u003e和\u003ca href=\"https://docs.raku.org/type/Bool\"\u003eBool\u003c/a\u003e在大多数情况下使用相同。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eMap\u003c/code\u003e既具有可变的，并且在Raku的不可变等效\u003ca href=\"https://docs.raku.org/type/Map\"\u003e地图\u003c/a\u003e是不可变的一个，并且\u003ca href=\"https://docs.raku.org/type/Hash\"\u003e哈希\u003c/a\u003e是可变的一个。不要混淆他们！就像\u003ccode\u003eMap\u003c/code\u003e在JavaScript中，\u003ccode\u003eMap\u003c/code\u003e并且\u003ccode\u003eHash\u003c/code\u003e可以有任何类型的键或值，而不仅仅是钥匙串。\u003c/p\u003e\n\u003cp\u003e像\u003ccode\u003eMap\u003c/code\u003e，\u003ccode\u003eSet\u003c/code\u003e也都一个可变的和Raku中一个不变的等效\u003ca href=\"https://docs.raku.org/type/Set\"\u003e设置\u003c/a\u003e是不可变的一个，并且\u003ca href=\"https://docs.raku.org/type/SetHash\"\u003eSetHash\u003c/a\u003e是可变的。\u003c/p\u003e\n\u003ch2 id=\"函数httpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003e函数\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e# TBD\u003c/p\u003e\n\u003ch1 id=\"面向对象编程httpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003e面向对象编程\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e# TBD\u003c/p\u003e\n\u003ch1 id=\"异步编程httpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003e异步编程\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e# TBD\u003c/p\u003e\n\u003ch1 id=\"网络-apihttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003e网络 API\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"网络httpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003e网络\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIn Raku, there are two APIs for dealing with networking: \u003ccode\u003eIO::Socket::INET\u003c/code\u003e (for synchronous networking), and \u003ccode\u003eIO::Socket::Async\u003c/code\u003e (for asynchronous networking).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eIO::Socket::INET\u003c/code\u003e currently only supports TCP connections. Its API resembles that of C\u0026rsquo;s socket API. If you\u0026rsquo;re familiar with that, then it won\u0026rsquo;t take long to understand how to use it. For example, here\u0026rsquo;s an echo server that closes the connection after receiving its first message:\u003c/p\u003e\n\u003cp\u003e在Raku中，有两个用于处理网络的API :( \u003ccode\u003eIO::Socket::INET\u003c/code\u003e用于同步网络）和\u003ccode\u003eIO::Socket::Async\u003c/code\u003e（用于异步网络）。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eIO::Socket::INET\u003c/code\u003e目前只支持TCP连接。它的API类似于C的套接字API。如果您熟悉它，那么理解如何使用它不会花费很长时间。例如，这是一个echo服务器，它在收到第一条消息后关闭连接：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy IO::Socket::INET $server .= new:\n    :localhost\u0026lt;localhost\u0026gt;,\n    :localport\u0026lt;8000\u0026gt;,\n    :listen;\n \nmy IO::Socket::INET $client .= new: :host\u0026lt;localhost\u0026gt;, :port\u0026lt;8000\u0026gt;;\n$client.print: \u0026#39;Hello, world!\u0026#39;;\n \nmy IO::Socket::INET $conn = $server.accept;\nmy Str $msg               = $conn.recv;\nsay $msg; # OUTPUT: Hello, world! \n$conn.print($msg);\n \nsay $client.recv; # OUTPUT: Hello, world! \n$conn.close;\n$client.close;\n$server.close;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBy default, \u003ccode\u003eIO::Socket::INET\u003c/code\u003e connections are IPv4 only. To use IPv6 instead, pass \u003ccode\u003e:family(PF_INET6)\u003c/code\u003e when constructing a server or a client.\u003c/p\u003e\n\u003cp\u003eIn contrast, \u003ccode\u003eIO::Socket::Async\u003c/code\u003e supports both IPv4 and IPv6 without the need to specify which family you wish to use. It also supports UDP sockets. Here\u0026rsquo;s how you would write the same echo server as above asynchronously (note that \u003ccode\u003eSupply.tap\u003c/code\u003e is multithreaded; if this is undesirable, use \u003ccode\u003eSupply.act\u003c/code\u003e instead:\u003c/p\u003e\n\u003cp\u003e默认情况下，\u003ccode\u003eIO::Socket::INET\u003c/code\u003e连接仅限IPv4。要使用IPv6，请\u003ccode\u003e:family(PF_INET6)\u003c/code\u003e在构建服务器或客户端时传递。\u003c/p\u003e\n\u003cp\u003e相反，\u003ccode\u003eIO::Socket::Async\u003c/code\u003e支持IPv4和IPv6，无需指定要使用的族。它还支持UDP套接字。以下是如何异步编写与上面相同的echo服务器（请注意，这\u003ccode\u003eSupply.tap\u003c/code\u003e是多线程的;如果这是不合需要的，请\u003ccode\u003eSupply.act\u003c/code\u003e改用：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy $supply = IO::Socket::Async.listen(\u0026#39;localhost\u0026#39;, 8000);\nmy $server = $supply.tap(-\u0026gt; $conn {\n    $conn.Supply.tap(-\u0026gt; $data {\n        say $data; # OUTPUT: Hello, world! \n        await $conn.print: $data;\n        $conn.close;\n    })\n});\n \nmy $client = await IO::Socket::Async.connect(\u0026#39;localhost\u0026#39;, 8000);\n$client.Supply.tap(-\u0026gt; $data {\n    say $data; # OUTPUT: Hello, world! \n    $client.close;\n    $server.close;\n});\n \nawait $client.print: \u0026#39;Hello, world!\u0026#39;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe equivalent code in Node.js looks like this:\u003c/p\u003e\n\u003cp\u003eNode.js中的等效代码如下所示：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003econst net = require(\u0026#39;net\u0026#39;);\n \nconst server = net.createServer(conn =\u0026gt; {\n    conn.setEncoding(\u0026#39;utf8\u0026#39;);\n    conn.on(\u0026#39;data\u0026#39;, data =\u0026gt; {\n        console.log(data); # OUTPUT: Hello, world! \n        conn.write(data);\n        conn.end();\n    });\n}).listen(8000, \u0026#39;localhost\u0026#39;);\n \nconst client = net.createConnection(8000, \u0026#39;localhost\u0026#39;, () =\u0026gt; {\n    client.setEncoding(\u0026#39;utf8\u0026#39;);\n    client.on(\u0026#39;data\u0026#39;, data =\u0026gt; {\n        console.log(data); # OUTPUT: Hello, world! \n        client.end();\n        server.close();\n    });\n    client.write(\u0026#34;Hello, world!\u0026#34;);\n});\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"httphttpshttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003eHTTP/HTTPS\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eRaku doesn\u0026rsquo;t natively support HTTP/HTTPS. However, CPAN packages such as \u003ca href=\"https://cro.services/\"\u003eCro\u003c/a\u003e help fill the gap.\u003c/p\u003e\n\u003cp\u003eRaku本身不支持HTTP / HTTPS。然而，像\u003ca href=\"https://cro.services/\"\u003eCro\u003c/a\u003e这样的CPAN包填补了这个空白。\u003c/p\u003e\n\u003ch2 id=\"dnshttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003eDNS\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eRaku does not currently support the majority of the features that Node.js\u0026rsquo;s DNS module implements. \u003ccode\u003eIO::Socket::INET\u003c/code\u003e and \u003ccode\u003eIO::Socket::Async\u003c/code\u003e can resolve hostnames, but features like resolving DNS records and reverse IP lookups are not implemented yet. There are some modules that are a work in progress, such as \u003ca href=\"https://github.com/tbrowder/Net-DNS-BIND-Manage-Raku/\"\u003eNet::DNS::BIND::Manage\u003c/a\u003e, that aim to improve DNS support.\u003c/p\u003e\n\u003cp\u003eRaku目前不支持Node.js的DNS模块实现的大多数功能。\u003ccode\u003eIO::Socket::INET\u003c/code\u003e并且\u003ccode\u003eIO::Socket::Async\u003c/code\u003e可以解析主机名，但尚未实现解析DNS记录和反向IP查找等功能。有些模块正在进行中，例如\u003ca href=\"https://github.com/tbrowder/Net-DNS-BIND-Manage-Raku/\"\u003eNet :: DNS :: BIND :: Manage\u003c/a\u003e，旨在改善DNS支持。\u003c/p\u003e\n\u003ch2 id=\"punycodehttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003ePunycode\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003ePunycode support is available through the \u003ca href=\"https://github.com/Kaiepi/p6-Net-LibIDN\"\u003eNet::LibIDN\u003c/a\u003e, \u003ca href=\"https://github.com/Kaiepi/p6-Net-LibIDN2\"\u003eNet::LibIDN2\u003c/a\u003e, and \u003ca href=\"https://github.com/FROGGS/p6-IDNA-Punycode\"\u003eIDNA::Punycode\u003c/a\u003e modules on CPAN.\u003c/p\u003e\n\u003cp\u003e通过CPAN上的\u003ca href=\"https://github.com/Kaiepi/p6-Net-LibIDN\"\u003eNet :: LibIDN\u003c/a\u003e，\u003ca href=\"https://github.com/Kaiepi/p6-Net-LibIDN2\"\u003eNet :: LibIDN2\u003c/a\u003e和\u003ca href=\"https://github.com/FROGGS/p6-IDNA-Punycode\"\u003eIDNA :: Punycode\u003c/a\u003e模块可以获得Punycode支持。\u003c/p\u003e\n\u003ch1 id=\"文件系统-apihttpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003e文件系统 API\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e# TBD\u003c/p\u003e\n\u003ch1 id=\"模块和包httpsdocsrakuorglanguagejs-nutshell___top\"\u003e\u003ca href=\"https://docs.raku.org/language/js-nutshell#___top\"\u003e模块和包\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e# TBD\u003c/p\u003e\n","text":"大西瓜啊，忘记翻译了！\nThis page attempts to provide a way for users experienced in Node.js to learn Raku. Features shared between the two languages will be explained here, as well as major differences in syntax and features.\nThis is not a tutorial for learning Raku; this is a reference for users who are already at an intermediate to advanced skill level with Node.js.\n此页面试图为在Node.js中有经验的用户提供学习Raku的方法。这里将解释两种语言之间共享的功能，以及语法和功能的主要差异。\n这不是学习Raku的教程; 对于已经使用Node.js处于中级到高级技能级别的用户，这是一个参考。\n基础语法 \u0026ldquo;Hello, world!\u0026rdquo; Let\u0026rsquo;s start with the typical first program when learning new languages. In Node.js, a hello world program would be written like this:\n让我们从学习新语言时的典型第一个程序开始。在Node.js中，一个hello world程序将编写如下：\nconsole.log(\u0026#39;Hello, world!\u0026#39;); Here are a couple ways to write this in the same way in Raku:\n以下是在Raku中以相同方式编写此内容的几种方法：\nsay(\u0026#39;Hello, world!\u0026#39;); say \u0026#39;Hello, world!\u0026#39;; Parentheses are optional for function calls in Raku. While semicolons are, for the most part, optional in Node.js, they are mandatory for expressions in Raku.\nNow that we\u0026rsquo;ve greeted the world, let\u0026rsquo;s greet our good friend, Joe. We\u0026rsquo;ll start with Node.js again:\n对于Raku中的函数调用，括号是可选的。虽然分号在Node.js中大多数是可选的，但它们对于Raku中的表达式是必需的。\n现在我们迎接了世界，让我们迎接我们的好朋友乔。我们将再次从Node.js开始：\nlet name = \u0026#39;Joe\u0026#39;; console.log(\u0026#39;What\\\u0026#39;s up,\u0026#39; + name + \u0026#39;?\u0026#39;); console.log(`What\u0026#39;s up, {name}?`); console.log(\u0026#34;What\u0026#39;s up, \u0026#34;, name, \u0026#34;?\u0026#34;); Since he didn\u0026rsquo;t hear us, let\u0026rsquo;s greet him again, this time in Raku:\n因为他没有听到我们，所以让我再次问候他，这次是在Raku中：\nmy $name = \u0026#39;Joe\u0026#39;; say \u0026#39;What\\\u0026#39;s up, \u0026#39; ~ $name ~ \u0026#39;?\u0026#39;; say \u0026#34;What\u0026#39;s up, $name?\u0026#34;; say \u0026#34;What\u0026#39;s up, \u0026#34;, $name, \u0026#34;?\u0026#34;; Here, there are only a couple differences: most variables in Raku have what are called sigils, which are what the $ in front of its name is, and string concatenation uses the ~ operator instead of +. What the two languages share in common here is support for string interpolation.\nNow that the basic examples are out of the way, let\u0026rsquo;s explain the similarities between the two languages in greater detail.\n这里只有几个不同之处：Raku中的大多数变量都有所谓的sigils，这就是$它名称前面的变量，字符串连接使用~运算符代替+。这两种语言的共同点是支持字符串插值。\n现在基本的例子已经不在了，让我们更详细地解释两种语言之间的相似之处。\n变量 Variables in Node.js can be defined like this;\nNode.js中的变量可以像这样定义;\nvar foo = 1; // Lexically scoped with functions and modules let foo = 1; // Lexically scoped with blocks const foo = 1; // Lexically scoped with blocks; constant global.foo = 1; // Dynamically scoped; global foo = 1; // Ditto, but implicit; forbidden in strict mode In Raku there is no equivalent to var. An important note to make is that there is no variable hoisting in Raku; variables are defined and assigned at the line they\u0026rsquo;re on, not defined at the top of its scope and later assigned at that line.\nThis is how the equivalent types of variables are defined in Raku:\n在Raku中没有相当于var。需要注意的一点是，Raku中没有可变的吊装; 变量在它们所在的行上定义和分配，未在其范围的顶部定义，稍后在该行分配。\n这是在Raku中定义等效类型的变量的方式：\nmy $foo = 1; # Lexically scoped with blocks our $foo = 1; # Lexically scoped with blocks and modules constant foo = 1; # Lexically scoped with blocks and modules; constant my $*foo = 1; # Dynamically scoped with blocks OUR::\u0026lt;$foo\u0026gt; = 1; # Dynamically scoped with blocks and modules GLOBAL::\u0026lt;$foo\u0026gt; = 1; # Dynamically scoped; global Use my where you\u0026rsquo;d use let, our for variables you\u0026rsquo;d define in the outermost scope needed, and constant where you\u0026rsquo;d uses const.\nDynamically scoped variables are not referred to in the same way as lexically scoped ones like they are in Node.js. User-defined ones use either a $*, @*, %*, or \u0026amp;* twigil. Refer to the documentation on variables for more information on sigils, twigils, and variable containers.\nVariables in Node.js can override others from outer scopes with the same name (though linters will usually complain about it depending on how they\u0026rsquo;re configured):\n使用my您使用的位置let，our您需要在最外层范围内定义的变量以及constant您使用的位置const。\n动态范围变量的引用方式与它们在Node.js中的词汇范围变量相同。用户定义的那些使用一个$*，@*，%*，或\u0026amp;*twigil。有关sigils，twigils和变量容器的更多信息，请参阅有关变量的文档。\nNode.js中的变量可以覆盖具有相同名称的外部作用域中的其他变量（尽管linters通常会根据它们的配置方式来抱怨它）：\nlet foo = 1; function logDupe() { let foo = 2; console.log(foo); } logDupe(2); // 2 console.log(foo); // 1 Raku also allows this:\nRaku 也允许这样：\nmy $foo = 1; sub log-dupe { my $foo = 2; say $foo; } log-dupe; # 2 say $foo; # 1 运算符 赋值 The = operator works the same across both languages.\nThe := operator in Raku binds a value to a variable. Binding a variable to another variable gives them the same value and container, meaning mutating attributes of one will mutate the other\u0026rsquo;s as well. Bound variables cannot be reassigned with = or mutated with ++, --, etc. but they can be bound to another value again:\n= 运算符可以跨两种语言相同。\nRaku 中的 := 运算符将值绑定到变量。将变量绑定到另一个变量会为它们提供相同的值和容器，这意味着一个变量属性也会改变另一个变量。绑定变量不能被重新分配=或突变++，--等，但它们可以被重新绑定到另一个值：\nmy %map; # This is a hash, roughly equivalent to a JS object or map my %unbound = %map; my %bound := %map; %map\u0026lt;foo\u0026gt; = \u0026#39;bar\u0026#39;; say %unbound; # {} say %bound; # {foo =\u0026gt; bar} %bound := %unbound; say %bound; # {} 相等 Node.js has two equality operators: == and ===.\n== is the loose equality operator. When comparing operands with the same type, it will return true if both operands are equal. However, if the operands are different types, they are both cast to their primitives before being compared, meaning these will return true:\nNode.js有两个相等运算符：==和===。\n==是松散的平等算子。比较具有相同类型的操作数时，如果两个操作数相等，则返回true。但是，如果操作数是不同的类型，它们在被比较之前都被转换为它们的基元，这意味着它们将返回true：\nconsole.log(1 == 1); // true console.log(\u0026#39;1\u0026#39; == 1); // true console.log([] == 0); // true Similarly, in Raku, both operands are cast to Numeric before comparison if they don\u0026rsquo;t share the same type:\n类似地，在Raku中，如果它们不共享相同的类型，则在比较之前将两个操作数强制转换为Numeric：\nsay 1 == 1; # True say \u0026#39;1\u0026#39; == 1; # True say [1,2,3] == 3; # True, since the array has three elements The inverse of == is !=.\nRaku has another operator similar to ==: eq. Instead of casting operands to Numeric if they\u0026rsquo;re different types, eq will cast them to strings:\n倒数==是!=。\nRaku有另一个类似于的运算符==：eq。如果它们是不同的类型，而不是将操作数转换为Numeric，而不是eq将它们转换为字符串：\nsay \u0026#39;1\u0026#39; eq \u0026#39;1\u0026#39;; # True say 1 eq \u0026#39;1\u0026#39;; # True The inverse of eq is ne or !eq.\n=== is the strict equality operator. This returns true if both operands are the same value. When comparing objects, this will only return true if they are the exact same object:\n逆的eq是ne或!eq。\n===是严格的相等运算符。如果两个操作数是相同的值，则返回true。比较对象时，如果它们是完全相同的对象，则只返回true：\nconsole.log(1 === 1); // true console.log(\u0026#39;1\u0026#39; === 1); // false console.log({} === {}); // false let obj = {}; let obj2 = obj; console.log(obj === obj2); // true; In Raku, the operator behaves the same, with one exception: two objects that have the same value, but different containers, will return false:\n在Raku中，运算符的行为相同，但有一个例外：两个具有相同值但容器不同的对象将返回false：\nsay 1 === 1; # True say \u0026#39;1\u0026#39; === 1; # True say {} === {}; # False my \\hash = {}; my %hash = hash; say hash === %hash; # False In the last case it\u0026rsquo;s the same object, but containers are different, which is why it returns False.\nThe inverse of === is !==.\nThis is where Raku\u0026rsquo;s other equality operators are useful. If the values have different containers, the eqv operator can be used. This operator can be also be used to check for deep equality, which you would normally need to use a library for in Node.js:\n在最后一种情况下，它是相同的对象，但容器是不同的，这就是它返回False的原因。\n倒数===是!==。\n这是Raku的其他相等运算符很有用的地方。如果值具有不同的容器，则eqv可以使用操作员。此运算符也可用于检查深度相等性，通常需要在Node.js中使用库：\nsay {a =\u0026gt; 1} eqv {a =\u0026gt; 1}; # True; my \\hash = {}; my %hash := hash; say hash eqv %hash; # True In the case you need to check if two variables have the same container and value, use the =:= operator.\n如果您需要检查两个变量是否具有相同的容器和值，请使用=:=运算符。\nmy @arr = [1,2,3]; my @arr2 := @arr; # Bound variables keep the container of the other variable say @arr =:= @arr2; # True Smartmatching Raku has one last operator for comparing values, but it is not exactly an equality operator. This is ~~, the smartmatch operator. This has several uses: it can be used like instanceof in Node.js, to match a regex, and to check if a value is a key in a hash, bag, set, or map:\nRaku有一个用于比较值的最后一个运算符，但它不完全是一个相等运算符。这就是~~smartmatch运营商。这有几个用途：它可以像instanceof在Node.js中一样使用，以匹配正则表达式，并检查值是否是散列，包，集或映射中的键：\nsay \u0026#39;foo\u0026#39; ~~ Str; # True my %hash = a =\u0026gt; 1; say \u0026#39;a\u0026#39; ~~ %hash; # True my $str = \u0026#39;abc\u0026#39;; $str ~~ s/abc/def/; # Mutates $str, like foo.replace(\u0026#39;abc\u0026#39;, \u0026#39;def\u0026#39;) say $str; # def While we are talking about instanceof, the equivalent to the constructor property on Node.js objects in Raku is the WHATattribute:\n在我们讨论的时候instanceof，constructorRaku中Node.js对象的属性相当于WHAT属性：\nconsole.log(\u0026#39;foo\u0026#39;.constructor); // OUTPUT: String say \u0026#39;foo\u0026#39;.WHAT; # OUTPUT: Str Numeric Node.js has +, -, /, *, %, and (in ES6) ** as numeric operators. When the operands are different types, similarly to the equality operators, are cast to their primitives before following through with the operation, making this possible:\nNode.js的有+，-，/，*，%，和（在ES6）**作为数字运算符。当操作数是不同类型时，类似于相等运算符，在执行操作之前会转换为它们的基元，从而使这成为可能：\nconsole.log(1 + 2); // 3 console.log([] + {}); // [object Object] console.log({} + []); // 0 In Raku, again, they are converted to a Numeric type, as before:\n在Raku中，它们再次转换为数字类型，如前所述：\nsay 1 + 2; # 3 say [] + {}; # 0 say {} + [1,2,3]; # 3 In addition, Raku has div and %%. div behaves like int division in C, while %% checks if one number is cleanly divisible by another or not:\n另外，Raku有div和%%。div表现得像intC中的分裂，同时%%检查一个数字是否可以被另一个数字完全整除：\nsay 4 div 3; # 1 say 4 %% 3; # False say 6 %% 3; # True Bitwise Node.js has \u0026amp;, |, ^, ~, \u0026lt;\u0026lt;, \u0026gt;\u0026gt;, \u0026gt;\u0026gt;\u0026gt;, and ~ for bitwise operators:\nNode.js的有\u0026amp;，|，^，~，\u0026lt;\u0026lt;，\u0026gt;\u0026gt;，\u0026gt;\u0026gt;\u0026gt;，和~对位运算符：\nconsole.log(1 \u0026lt;\u0026lt; 1); // 2 console.log(1 \u0026gt;\u0026gt; 1); // 0 console.log(1 \u0026gt;\u0026gt;\u0026gt; 1); // 0 console.log(1 \u0026amp; 1); // 1 console.log(0 | 1); // 1 console.log(1 ^ 1); // 0 console.log(~1); // -2 In Raku, there is no equivalent to \u0026gt;\u0026gt;\u0026gt;. All bitwise operators are prefixed with +, however two\u0026rsquo;s complement uses +^ instead of ~:\n在Raku中，没有相当于\u0026gt;\u0026gt;\u0026gt;。所有按位运算符都以前缀为前缀+，但是使用两个补码+^而不是~：\nsay 1 +\u0026lt; 1; # 2 say 1 +\u0026gt; 1; # 0 # No equivalent for \u0026gt;\u0026gt;\u0026gt; say 1 +\u0026amp; 1; # 1 say 0 +| 1; # 1 say 1 +^ 1; # 0 say +^1; # -2 Custom operators and operator overloading Node.js does not allow operator overloading without having to use a Makefile or build Node.js with a custom version of V8. Raku allows custom operators and operator overloading natively! Since all operators are subroutines, you can define your own like so:\nNode.js不允许运算符重载而不必使用Makefile或使用自定义版本的V8构建Node.js. Raku允许自定义操作符和操作符本机重载！由于所有运算符都是子程序，因此您可以像这样定义自己的运算符：\nmulti sub infix:\u0026lt;||=\u0026gt;($a, $b) is equiv(\u0026amp;infix:\u0026lt;+=\u0026gt;) { $a || $b } my $foo = 0; $foo ||= 1; say $foo; # OUTPUT: 1 Operators can be defined as prefix, infix, or postfix. The is tighter, is equiv, and is looser traits optionally define the operator\u0026rsquo;s precedence. In this case, ||= has the same precedence as +=.\nNote how multi is used when declaring the operator subroutines. This allows multiple subroutines with the same name to be declared while also having different signatures. This will be explained in greater detail in the Functions section. For now, all we need to know is that it allows us to override any native operator we want:\n运算符可以定义为prefix，infix，或postfix。的is tighter，is equiv和is looser性状选择定义操作的优先级。在这种情况下，||=具有相同的优先级+=。\n注意multi在声明操作符子例程时如何使用。这允许声明具有相同名称的多个子例程，同时具有不同的签名。这将在“ 功能”部分中详细说明。目前，我们需要知道的是它允许我们覆盖我们想要的任何本机运算符：\n# Using the `is default` trait here forces this subroutine to be chosen first, # so long as the signature of the subroutine matches. multi sub prefix:\u0026lt;++\u0026gt;($a) is default { $a - 1 } my $foo = 1; say ++$foo; # OUTPUT: 0 Control flow if/else You should be familiar with how if/else looks in JavaScript:\n您应该熟悉 JavaScript 中的 if/ else：\nlet diceRoll = Math.ceil(Math.random() * 6) + Math.ceil(Math.random() * 6); if (diceRoll === 2) { console.log(\u0026#39;Snake eyes!\u0026#39;); } else if (diceRoll === 16) { console.log(\u0026#39;Boxcars!\u0026#39;); } else { console.log(`Rolled ${diceRoll}.`); } In Raku, if/else works largely the same, with a few key differences. One, parentheses are not required. Two, else if is written as elsif. Three, the if clause may be written after a statement:\n在Raku中，if/的else工作方式基本相同，只有一些关键的区别。一，括号不是必需的。二，else if写成elsif。三，if语句可以在声明后写出：\nmy Int $dice-roll = ceiling rand * 12 + ceiling rand * 12; if $dice-roll == 2 { say \u0026#39;Snake eyes!\u0026#39;; } elsif $dice-roll == 16 { say \u0026#39;Boxcars!\u0026#39;; } else { say \u0026#34;Rolled $dice-roll.\u0026#34;; } Alternatively, though less efficient, this could be written to use if after statements:\n或者，虽然效率较低，但可以if在语句后使用：\nmy Int $dice-roll = ceiling rand * 12 + ceiling rand * 12; say \u0026#39;Snake eyes!\u0026#39; if $dice-roll == 2; say \u0026#39;Boxcars!\u0026#39; if $dice-roll == 16; say \u0026#34;Rolled $dice-roll.\u0026#34; if $dice-roll !~~ 2 | 16; Raku also has when, which is like if, but if the condition given is true, no code past the when block within the block it\u0026rsquo;s in is executed:\nRaku也有when，就像是if，但是如果给出的条件为真，when那么执行它所执行的块中没有代码超过块：\n{ when True { say \u0026#39;In when block!\u0026#39;; # OUTPUT: In when block! } say \u0026#39;This will never be output!\u0026#39;; } Additionally, Raku has with, orwith, and without, which are like if, else if, and else respectively, but instead of checking whether their condition is true, they check if it\u0026rsquo;s defined.\n此外，Raku的有with，orwith和without，这是一样if，else if和，else分别但是，不是检查自己的条件是否为真，他们检查，如果它被定义。\nswitch Switch statements are a way of checking for equality between a given value and a list of values and run some code if one matches. case statements define each value to compare to. default, if included, acts as a fallback for when the given value matches no cases. After matching a case, break is typically used to prevent the code from the cases that follow the one matched from being executed, though rarely this is intentionally omitted.\nSwitch语句是一种检查给定值和值列表之间相等性的方法，并在匹配时运行一些代码。case语句定义要比较的每个值。default，如果包含，则作为给定值不匹配任何情况的后备。在匹配案例之后，break通常用于防止代码跟随匹配的案例执行，尽管很少有意省略。\nconst ranklist = [2, 3, 4, 5, 6, 7, 8, 9, \u0026#39;Jack\u0026#39;, \u0026#39;Queen\u0026#39;, \u0026#39;King\u0026#39;, \u0026#39;Ace\u0026#39;]; const ranks = Array.from(Array(3), () =\u0026gt; ranklist[Math.floor(Math.random() * ranks.length)]); let score = 0; for (let rank of ranks) { switch (rank) { case \u0026#39;Jack\u0026#39;: case \u0026#39;Queen\u0026#39;: case \u0026#39;King\u0026#39;: score += 10; break; case \u0026#39;Ace\u0026#39;; score += (score \u0026lt;= 11) ? 10 : 1; break; default: score += rank; break; } } In Raku, given can be used like switch statements. There is no equivalent to break since when blocks are most commonly used like case statements. One major difference between switch and given is that a value passed to a switch statement will only match cases that are exactly equal to the value; given values are smartmatched (~~) against the when values.\n在Raku中，given可以像switch语句一样使用。没有相应的，break因为when块最常用于case语句。switch和之间的一个主要区别given是传递给switch语句的值只匹配与值完全相等的情况; given值是~~针对值的smartmatched（）when。\nmy @ranklist = [2, 3, 4, 5, 6, 7, 8, 9, \u0026#39;Jack\u0026#39;, \u0026#39;Queen\u0026#39;, \u0026#39;King\u0026#39;, \u0026#39;Ace\u0026#39;]; my @ranks = @ranklist.pick: 3; my Int $score = 0; for @ranks -\u0026gt; $rank { # The when blocks implicitly return the last statement they contain. $score += do given $rank { when \u0026#39;Jack\u0026#39; | \u0026#39;Queen\u0026#39; | \u0026#39;King\u0026#39; { 10 } when \u0026#39;Ace\u0026#39; { $score \u0026lt;= 11 ?? 10 !! 1 } default { $_ } }; } If there are multiple when blocks that match the value passed to given and you wish to run more than one of them, use proceed. succeed may be used to exit both the when block it\u0026rsquo;s in and the given block, preventing any following statements from being executed:\n如果有多个when块与传递的值匹配，given并且您希望运行多个块，请使用proceed。succeed可用于退出when它所在的块和给定的块，防止执行以下任何语句：\ngiven Int { when Int { say \u0026#39;Int is Int\u0026#39;; proceed } when Numeric { say \u0026#39;Int is Numeric\u0026#39;; proceed } when Any { say \u0026#39;Int is Any\u0026#39;; succeed } when Mu { say \u0026#39;Int is Mu\u0026#39; } # Won\u0026#39;t output } # OUTPUT: # Int is Int # Int is Numeric # Int is Any for, while, and do/while There are three different types of for loops in JavaScript:\nJavaScript中有三种不同类型的for循环：\n// C-style for loops const letters = {}; for (let ord = 0x61; ord \u0026lt;= 0x7A; ord++) { let letter = String.fromCharCode(ord); letters[letter] = letter.toUpperCase(); } // for..in loops (typically used on objects) for (let letter in letters) { console.log(letters[letter]); # OUTPUT: # A # B # C # etc. } // for..of loops (typically used on arrays, maps, and sets) for (let letter of Object.values(letters)) { console.log(letter); # OUTPUT: # A # B # C # etc. } Raku for loops most closely resemble for..of loops, since they work on anything as long as it\u0026rsquo;s iterable. C-style loops are possible to write using loop, but this is discouraged since they\u0026rsquo;re better written as for loops using ranges. Like if statements, for may follow a statement, with the current iteration being accessible using the $_ variable (known as \u0026ldquo;it\u0026rdquo;). Methods on $_ may be called without specifying the variable:\nRaku for循环最接近for..of循环，因为只要它是可迭代的，它们就可以处理任何东西。C风格的循环可以使用loop，但不鼓励这样做，因为它们更好地编写为for使用范围的循环。类似if语句，for可以遵循一个语句，当前迭代可以使用$_变量（称为“它”）访问。$_可以在不指定变量的情况下调用方法：\nmy Str %letters{Str}; %letters{$_} = .uc for \u0026#39;a\u0026#39;..\u0026#39;z\u0026#39;; .say for %letters.values; # OUTPUT: # A # B # C # etc. while loops work identically between JavaScript and Raku. Raku also has until loops, where instead of iterating until the given condition is false, they iterate until the condition is true.\ndo/while loops are known as repeat/while loops in Raku. Likewise with while, repeat/until loops also exist and loop until the given condition is false.\nTo write infinite loops in Raku, use loop rather than for or while.\nIn JavaScript, continue is used to skip to the next iteration in a loop, and break is used to exit a loop early:\nwhile循环在JavaScript和Raku之间的工作相同.Raku也有until循环，而不是迭代直到给定条件为假，它们迭代直到条件为真。\ndo/while循环repeat/while在Raku 中称为循环。同样while，repeat/until循环也存在并循环，直到给定条件为假。\n要在Raku中编写无限循环，请使用loop而不是for或while。\n在JavaScript中，continue用于跳转到循环中的下一个迭代，并break用于提前退出循环：\nlet primes = new Set(); let i = 2; do { let isPrime = true; for (let prime of primes) { if (i % prime == 0) { isPrime = false; break; } } if (!isPrime) continue; primes.add(i); } while (++i \u0026lt; 20); console.log(primes); # OUTPUT: Set { 2, 3, 5, 7, 11, 13, 17, 19 } In Raku, these are known as next and last respectively. There is also redo, which repeats the current iteration without evaluating the loop\u0026rsquo;s condition again.\nnext/redo/last statements may be followed by a label defined before an outer loop to make the statement work on the loop the label refers to, rather than the loop the statement is in:\n在Raku中，这些分别称为next和last。还有redo，它重复当前迭代而不再评估循环的条件。\nnext/ redo/ last语句后跟一个在外部循环之前定义的标签，以使该语句在标签所引用的循环上起作用，而不是该语句所在的循环：\nmy %primes is SetHash; my Int $i = 2; OUTSIDE: repeat { next OUTSIDE if $i %% $_ for %primes.keys; %primes{$i}++; } while ++$i \u0026lt; 20; say %primes; # OUTPUT: SetHash(11 13 17 19 2 3 5 7) do do is not currently a feature in JavaScript, however a proposal has been made to add it to ECMAScript. do expressions evaluate a block and return the result:\ndo目前不是JavaScript中的一项功能，但已提出将其添加到ECMAScript的提案。do表达式计算一个块并返回结果：\nconstant VERSION = v2.0.0; constant VERSION_NUMBER = do { my @digits = VERSION.Str.comb(/\\d+/); :16(sprintf \u0026#34;%02x%02x%04x\u0026#34;, |@digits) }; say VERSION_NUMBER; # OUTPUT: 33554432 Types Creating types In JavaScript, types are created by making a class (or a constructor in ES5 and earlier). If you\u0026rsquo;ve used TypeScript, you can define a type as a subset of other types like so:\n在JavaScript中，通过创建类（或ES5及更早版本中的构造函数）来创建类型。如果您使用过TypeScript，则可以将类型定义为其他类型的子集，如下所示：\ntype ID = string | number; In Raku, classes, roles, subsets, and enums are considered types. Creating classes and roles will be discussed in the OOP section of this article. Creating an ID subset can be done like so:\n在Raku中，类，角色，子集和枚举被视为类型。创建类和角色将在本文的OOP部分中讨论。创建ID子集可以这样完成：\nsubset ID where Str | Int; See the documentation on subset and Junction for more information.\nTypeScript enums may have numbers or strings as their values. Defining the values is optional; by default, the value of the first key is 0, the next key, 1, the next, 2, etc. For example, here is an enum that defines directions for extended ASCII arrow symbols (perhaps for a TUI game):\n有关更多信息，请参阅子集和连接的文档。\nTypeScript枚举可以包含数字或字符串作为其值。定义值是可选的; 默认情况下，第一个键的值为0，下一个键为1，下一个键为2，等等。例如，这是一个枚举，用于定义扩展ASCII箭头符号的方向（可能用于TUI游戏）：\nenum Direction ( UP = \u0026#39;↑\u0026#39;, DOWN = \u0026#39;↓\u0026#39;, LEFT = \u0026#39;←\u0026#39;, RIGHT = \u0026#39;→\u0026#39; ); Enums in Raku may have any type as their keys\u0026rsquo; values. Enum keys (and optionally, values) can be defined by writing enum, followed by the name of the enum, then the list of keys (and optionally, values), which can be done using \u0026lt; \u0026gt;, « », or ( ). ( ) must be used if you want to define values for the enum\u0026rsquo;s keys. Here is the Direction enum as written in Raku:\nRaku中的枚举可以使用任何类型作为其键值。枚举键（以及可选的值）可以通过写入来定义enum，然后是枚举的名称，然后是键列表（以及可选的值），可以使用\u0026lt;\u0026gt;，«»或（）来完成。( )如果要为枚举键定义值，则必须使用。这是Raku中编写的Direction枚举：\nenum Direction ( UP =\u0026gt; \u0026#39;↑\u0026#39;, DOWN =\u0026gt; \u0026#39;↓\u0026#39;, LEFT =\u0026gt; \u0026#39;←\u0026#39;, RIGHT =\u0026gt; \u0026#39;→\u0026#39; ); See the documentation on enum for more information.\n有关更多信息，请参阅枚举文档。\nUsing types In TypeScript, you can define the type of variables. Attempting to assign a value that doesn\u0026rsquo;t match the type of the variable will make the transpiler error out. This is done like so:\n在TypeScript中，您可以定义变量的类型。尝试分配与变量类型不匹配的值将导致转换器错误。这样做是这样的：\nenum Name (Phoebe, Daniel, Joe); let name: string = \u0026#39;Phoebe\u0026#39;; name = Phoebe; # Causes tsc to error out let hobbies: [string] = [\u0026#39;origami\u0026#39;, \u0026#39;playing instruments\u0026#39;, \u0026#39;programming\u0026#39;]; let todo: Map\u0026lt;string, boolean\u0026gt; = new Map([ [\u0026#39;clean the bathroom\u0026#39;, false], [\u0026#39;walk the dog\u0026#39;, true], [\u0026#39;wash the dishes\u0026#39;, true] ]); let doJob: (job: string) =\u0026gt; boolean = function (job: string): boolean { todo.set(job, true); return true; }; In Raku, variables can be typed by placing the type between the declarator (my, our, etc.) and the variable name. Assigning a value that doesn\u0026rsquo;t match the variable\u0026rsquo;s type will throw either a compile-time or runtime error, depending on how the value is evaluated:\n在Raku中，变量可以通过将说明符（之间的类型被键入my，our等）和变量名。分配与变量类型不匹配的值将引发编译时或运行时错误，具体取决于值的计算方式：\nenum Name \u0026lt;Phoebe Daniel Joe\u0026gt;; my Str $name = \u0026#39;Phoebe\u0026#39;; $name = Phoebe; # Throws a compile-time error # The type here defines the type of the elements of the array. my Str @hobbies = [\u0026#39;origami\u0026#39;, \u0026#39;playing instruments\u0026#39;, \u0026#39;programming\u0026#39;]; # The type between the declarator and variable defines the type of the values # of the hash. # The type in the curly braces defines the type of the keys of the hash. my Bool %todo{Str} = ( \u0026#39;clean the bathroom\u0026#39; =\u0026gt; False, \u0026#39;walk the dog\u0026#39; =\u0026gt; True, \u0026#39;wash the dishes\u0026#39; =\u0026gt; True ); # The type here defines the return value of the routine. my Bool \u0026amp;do-job = sub (Str $job --\u0026gt; Bool) { %todo{$job} = True; }; 比较 JavaScript 和 Raku 的类型 Here is a table of some JavaScript types and their equivalents in Raku:\n以下是Raku中一些JavaScript类型及其等价物的表格：\nJavaScript Raku Object Mu, Any, Hash Array List, Array, Seq String Str Number Int, Num, Rat Boolean Bool Map Map, Hash Set Set, SetHash Object is both a superclass of all types in JavaScript and a way to create a hash. In Raku, Mu is a superclass of all types, though usually you want to use Any instead, which is a subclass of Mu but also a superclass of nearly every type, with Junction being an exception. When using Object as a hash, Hash is what you want to use.\nThere are three types equivalent to Array. Array is most similar to Array, since it acts as a mutable array. List is similar to Array, but is immutable. Seq is used to create lazy arrays.\nString and Str are for the most part used identically.\nThere are several different types in Raku equivalent to Number, but the three you\u0026rsquo;ll most commonly see are Int, Num, and Rat. Intrepresents an integer. Num represents a floating-point number, making it the most similar to Number. Rat represents a fraction of two numbers, and is used when Num cannot provide precise enough values.\nBoolean and Bool are for the most part used identically.\nMap has both a mutable and an immutable equivalent in Raku. Map is the immutable one, and Hash is the mutable one. Don\u0026rsquo;t get them mixed up! Like Map in JavaScript, Map and Hash can have any type of key or value, not just strings for keys.\nLike Map, Set also has both a mutable and an immutable equivalent in Raku. Set is the immutable one, and SetHash is the mutable one.\nObject既是JavaScript中所有类型的超类，也是创建哈希的方法。在Raku中，穆是所有类型的超类，尽管通常要使用任何代替，这是的一个子类Mu，而且几乎所有类型的超类，与接线是一个例外。当Object用作哈希时，哈希就是你想要使用的。\n有三种类型相当于Array。数组最相似Array，因为它充当可变数组。列表类似于Array，但是是不可变的。Seq用于创建惰性数组。\nString和Str在大多数情况下使用相同。\nRaku中有几种不同的类型相当于Number，但你最常见的三种是Int，Num和Rat。Int表示整数。Num表示一个浮点数，使其最相似Number。Rat表示两个数字的一小部分，并且在Num无法提供足够精确的值时使用。\nBoolean和Bool在大多数情况下使用相同。\nMap既具有可变的，并且在Raku的不可变等效地图是不可变的一个，并且哈希是可变的一个。不要混淆他们！就像Map在JavaScript中，Map并且Hash可以有任何类型的键或值，而不仅仅是钥匙串。\n像Map，Set也都一个可变的和Raku中一个不变的等效设置是不可变的一个，并且SetHash是可变的。\n函数 # TBD\n面向对象编程 # TBD\n异步编程 # TBD\n网络 API 网络 In Raku, there are two APIs for dealing with networking: IO::Socket::INET (for synchronous networking), and IO::Socket::Async (for asynchronous networking).\nIO::Socket::INET currently only supports TCP connections. Its API resembles that of C\u0026rsquo;s socket API. If you\u0026rsquo;re familiar with that, then it won\u0026rsquo;t take long to understand how to use it. For example, here\u0026rsquo;s an echo server that closes the connection after receiving its first message:\n在Raku中，有两个用于处理网络的API :( IO::Socket::INET用于同步网络）和IO::Socket::Async（用于异步网络）。\nIO::Socket::INET目前只支持TCP连接。它的API类似于C的套接字API。如果您熟悉它，那么理解如何使用它不会花费很长时间。例如，这是一个echo服务器，它在收到第一条消息后关闭连接：\nmy IO::Socket::INET $server .= new: :localhost\u0026lt;localhost\u0026gt;, :localport\u0026lt;8000\u0026gt;, :listen; my IO::Socket::INET $client .= new: :host\u0026lt;localhost\u0026gt;, :port\u0026lt;8000\u0026gt;; $client.print: \u0026#39;Hello, world!\u0026#39;; my IO::Socket::INET $conn = $server.accept; my Str $msg = $conn.recv; say $msg; # OUTPUT: Hello, world! $conn.print($msg); say $client.recv; # OUTPUT: Hello, world! $conn.close; $client.close; $server.close; By default, IO::Socket::INET connections are IPv4 only. To use IPv6 instead, pass :family(PF_INET6) when constructing a server or a client.\nIn contrast, IO::Socket::Async supports both IPv4 and IPv6 without the need to specify which family you wish to use. It also supports UDP sockets. Here\u0026rsquo;s how you would write the same echo server as above asynchronously (note that Supply.tap is multithreaded; if this is undesirable, use Supply.act instead:\n默认情况下，IO::Socket::INET连接仅限IPv4。要使用IPv6，请:family(PF_INET6)在构建服务器或客户端时传递。\n相反，IO::Socket::Async支持IPv4和IPv6，无需指定要使用的族。它还支持UDP套接字。以下是如何异步编写与上面相同的echo服务器（请注意，这Supply.tap是多线程的;如果这是不合需要的，请Supply.act改用：\nmy $supply = IO::Socket::Async.listen(\u0026#39;localhost\u0026#39;, 8000); my $server = $supply.tap(-\u0026gt; $conn { $conn.Supply.tap(-\u0026gt; $data { say $data; # OUTPUT: Hello, world! await $conn.print: $data; $conn.close; }) }); my $client = await IO::Socket::Async.connect(\u0026#39;localhost\u0026#39;, 8000); $client.Supply.tap(-\u0026gt; $data { say $data; # OUTPUT: Hello, world! $client.close; $server.close; }); await $client.print: \u0026#39;Hello, world!\u0026#39;; The equivalent code in Node.js looks like this:\nNode.js中的等效代码如下所示：\nconst net = require(\u0026#39;net\u0026#39;); const server = net.createServer(conn =\u0026gt; { conn.setEncoding(\u0026#39;utf8\u0026#39;); conn.on(\u0026#39;data\u0026#39;, data =\u0026gt; { console.log(data); # OUTPUT: Hello, world! conn.write(data); conn.end(); }); }).listen(8000, \u0026#39;localhost\u0026#39;); const client = net.createConnection(8000, \u0026#39;localhost\u0026#39;, () =\u0026gt; { client.setEncoding(\u0026#39;utf8\u0026#39;); client.on(\u0026#39;data\u0026#39;, data =\u0026gt; { console.log(data); # OUTPUT: Hello, world! client.end(); server.close(); }); client.write(\u0026#34;Hello, world!\u0026#34;); }); HTTP/HTTPS Raku doesn\u0026rsquo;t natively support HTTP/HTTPS. However, CPAN packages such as Cro help fill the gap.\nRaku本身不支持HTTP / HTTPS。然而，像Cro这样的CPAN包填补了这个空白。\nDNS Raku does not currently support the majority of the features that Node.js\u0026rsquo;s DNS module implements. IO::Socket::INET and IO::Socket::Async can resolve hostnames, but features like resolving DNS records and reverse IP lookups are not implemented yet. There are some modules that are a work in progress, such as Net::DNS::BIND::Manage, that aim to improve DNS support.\nRaku目前不支持Node.js的DNS模块实现的大多数功能。IO::Socket::INET并且IO::Socket::Async可以解析主机名，但尚未实现解析DNS记录和反向IP查找等功能。有些模块正在进行中，例如Net :: DNS :: BIND :: Manage，旨在改善DNS支持。\nPunycode Punycode support is available through the Net::LibIDN, Net::LibIDN2, and IDNA::Punycode modules on CPAN.\n通过CPAN上的Net :: LibIDN，Net :: LibIDN2和IDNA :: Punycode模块可以获得Punycode支持。\n文件系统 API # TBD\n模块和包 # TBD\n"},"name":"Javascript(Node.js) 到 Raku - 简而言之","published":"2018-10-16T21:13:31+08:00","summary":"大西瓜啊，忘记翻译了！\nThis page attempts to provide a way for users experienced in Node.js to learn Raku. Features shared between the two languages will be explained here, as well as major differences in syntax and features.\nThis is not a tutorial for learning Raku; this is a reference for users who are already at an intermediate to advanced skill level with Node.js.\n此页面试图为在Node.js中有经验的用户提供学习Raku的方法。这里将解释两种语言之间共享的功能，以及语法和功能的主要差异。\n这不是学习Raku的教程; 对于已经使用Node.js处于中级到高级技能级别的用户，这是一个参考。\n基础语法 \u0026ldquo;Hello, world!\u0026rdquo; Let\u0026rsquo;s start with the typical first program when learning new languages.","type":"entry","url":"https://ohmycloud.github.io/posts/10.javascript-node.js-to-perl-6---nutshell/"}