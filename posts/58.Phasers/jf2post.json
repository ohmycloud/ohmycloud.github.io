{"author":{"name":null,"type":"card","url":"https://ohmycloud.github.io/"},"content":{"html":"\u003cp\u003e程序的生命周期（执行时间表）分为几个阶段。\u003cem\u003ephaser\u003c/em\u003e是在特定执行阶段调用的代码块。\u003c/p\u003e\n\u003ch1 id=\"phasershttpsdocsrakuorglanguagephasers___top\"\u003e\u003ca href=\"https://docs.raku.org/language/phasers#___top\"\u003ePhasers\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003ephaser 块只是包含它的闭包的 trait，并在适当的时刻自动调用。这些自动调用的块称为 \u003cem\u003ephasers\u003c/em\u003e，因为它们通常标记从计算的一个阶段到另一个阶段的转换。例如，在编译编译单元结束时调用 \u003ccode\u003eCHECK\u003c/code\u003e 块。也可以安装其他类型的 phasers; 它们会在适当的时候自动调用，其中一些 phasers 响应各种控制异常和退出值。例如，如果块的退出成功或失败，则可能会调用某些 phasers，在这种情况下\u003cem\u003e成功\u003c/em\u003e退出, 则在这时返回定义的值或列表，而不带任何 \u003ccode\u003eFailure\u003c/code\u003e 或异常。\u003c/p\u003e\n\u003cp\u003e以下是摘要：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eBEGIN\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  * at compile time, as soon as possible, only ever runs once \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eCHECK\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  * at compile time, as late as possible, only ever runs once \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \u003cspan class=\"k\"\u003eINIT\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  * at runtime, as soon as possible, only ever runs once \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eEND\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at runtime, as late as possible, only ever runs once \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eDOC\u003c/span\u003e \u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"k\"\u003eBEGIN\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"k\"\u003eCHECK\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"k\"\u003eINIT\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e# only in documentation mode \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eENTER\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  * at every block entry time, repeats on loop blocks. \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eLEAVE\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at every block exit time (even stack unwinds from exceptions) \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \u003cspan class=\"k\"\u003eKEEP\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at every successful block exit, part of LEAVE queue \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \u003cspan class=\"k\"\u003eUNDO\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at every unsuccessful block exit, part of LEAVE queue \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eFIRST\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at loop initialization time, before any ENTER \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \u003cspan class=\"k\"\u003eNEXT\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at loop continuation time, before any LEAVE \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at loop termination time, after any LEAVE \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ePRE\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  assert precondition at every block entry, before ENTER \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \u003cspan class=\"k\"\u003ePOST\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  assert postcondition at every block exit, after LEAVE \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eCATCH\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  catch exceptions, before LEAVE \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eCONTROL\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  catch control exceptions, before LEAVE \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  supply tapped by whenever-block is done, runs very last \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \u003cspan class=\"k\"\u003eQUIT\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  catch async exceptions within a whenever-block, runs very last \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eCOMPOSE\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  when a role is composed into a class (Not yet implemented) \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eCLOSE\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  appears in a supply block, called when the supply is closed \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e标记为 \u003ccode\u003e*\u003c/code\u003e 号的 phaser 具有运行时值，并且如果早于周围表达式进行求值，则只需保存其结果，以便在以后计算表达式的其余部分时在表达式中使用：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$compiletime\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003eBEGIN\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nb\"\u003enow\u003c/span\u003e \u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eour\u003c/span\u003e \u003cspan class=\"nv\"\u003e$random\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003eENTER\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nb\"\u003erand\u003c/span\u003e \u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e与其他语句前缀一样，这些产生值的构造可以放在块或语句的前面：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$compiletime\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003eBEGIN\u003c/span\u003e \u003cspan class=\"nb\"\u003enow\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eour\u003c/span\u003e \u003cspan class=\"nv\"\u003e$random\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003eENTER\u003c/span\u003e \u003cspan class=\"nb\"\u003erand\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这些 phaser 的大多数将接收块或函数引用。语句形式对于将词法作用域的声明暴露给周围的词法作用域而不在块中“捕获”它特别有用。\u003c/p\u003e\n\u003cp\u003e它们声明了与前面示例相同作用域的相同变量，但在指定时间把语句作为整体运行：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eBEGIN\u003c/span\u003e \u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$compiletime\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003enow\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eENTER\u003c/span\u003e \u003cspan class=\"k\"\u003eour\u003c/span\u003e \u003cspan class=\"nv\"\u003e$random\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003erand\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e（但请注意，在运行时克隆任何周围闭包时，在编译时计算的变量值可能不会持久存在。）\u003c/p\u003e\n\u003cp\u003e大多数非值生成 phasers 也可能如此使用：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eEND\u003c/span\u003e \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$accumulator\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e但请注意：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eEND\u003c/span\u003e \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$accumulator\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003eEND\u003c/code\u003e time 时将变量设置为 0 ，因为这是实际执行 “my” 声明的时间。只有无参数的 phasers 可以使用语句形式。这意味着 \u003ccode\u003eCATCH\u003c/code\u003e 和 \u003ccode\u003eCONTROL\u003c/code\u003e 始终需要一个块，因为它们接收一个设置 \u003ccode\u003e$_\u003c/code\u003e 为当前主题的参数，以便内部行为能够表现为 switch 语句。（如果允许使用裸语句，那么 \u003ccode\u003e$_\u003c/code\u003e 临时绑定会在 \u003ccode\u003eCATCH\u003c/code\u003e或者\u003ccode\u003eCONTROL\u003c/code\u003e 结束时泄漏出来，带来不可预测的，甚至可能是可怕的后果。异常处理程序应该减少不确定性，而不是增加它。）\u003c/p\u003e\n\u003cp\u003e其中一些 phasers 也具有可以在变量上设置的相应 trait; 他们使用 \u003ccode\u003ewill\u003c/code\u003e 后面跟着小写的 phaser 名称。这些优点是将讨论中的变量作为主题传递给闭包：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eour\u003c/span\u003e \u003cspan class=\"nv\"\u003e$h\u003c/span\u003e \u003cspan class=\"n\"\u003ewill\u003c/span\u003e \u003cspan class=\"n\"\u003eenter\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003erememberit\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"n\"\u003ewill\u003c/span\u003e \u003cspan class=\"n\"\u003eundo\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eforgetit\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e只有在块内可以多次出现的 phaser 才有资格获得这种每个变量(per-variable)形式; 这不包括 \u003ccode\u003eCATCH\u003c/code\u003e 和其他例如 \u003ccode\u003eCLOSE\u003c/code\u003e 或 \u003ccode\u003eQUIT\u003c/code\u003e phaser 。\u003c/p\u003e\n\u003cp\u003ephaser 外部的块的主题作为 \u003ccode\u003eOUTER::\u0026lt;$_\u0026gt;\u003c/code\u003e 仍然可用。返回值是否可修改可能是所讨论的 phaser 的策略。特别地，不应在 \u003ccode\u003ePOST\u003c/code\u003e phaser 内修改返回值，但 \u003ccode\u003eLEAVE\u003c/code\u003e phaser 可能更自由。\u003c/p\u003e\n\u003cp\u003e在方法的词法作用域中定义的任何 phaser 都是闭合 \u003ccode\u003eself\u003c/code\u003e 以及正常词汇。（或者等效地，实现可以简单地将所有这样的 phaser 转换为其引导的调用者是当前对象的子方法。）\u003c/p\u003e\n\u003cp\u003e当多个 phaser 被安排在同一时刻运行时，一般的打破平局的原则是初始化 phaser 按照声明的顺序执行，而最终 phaser 以相反的顺序执行，因为设置和拆除通常希望以相反的顺序相互发生。\u003c/p\u003e\n\u003ch2 id=\"执行顺序httpsdocsrakuorglanguagephasers___top\"\u003e\u003ca href=\"https://docs.raku.org/language/phasers#___top\"\u003e执行顺序\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e编译开始\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"k\"\u003eBEGIN\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at compile time, As soon as possible, only ever runs once \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"k\"\u003eCHECK\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at compile time, As late as possible, only ever runs once \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eCOMPOSE\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  when a role is composed into a class (Not yet implemented) \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e执行开始\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"k\"\u003eINIT\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at runtime, as soon as possible, only ever runs once \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在块执行开始之前\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ePRE\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  assert precondition at every block entry, before ENTER \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e循环执行开始\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"k\"\u003eFIRST\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at loop initialization time, before any ENTER \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e块执行开始\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"k\"\u003eENTER\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at every block entry time, repeats on loop blocks. \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e可能会发生异常\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"k\"\u003eCATCH\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  catch exceptions, before LEAVE \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eCONTROL\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  catch control exceptions, before LEAVE \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e循环结束，继续或结束\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"k\"\u003eNEXT\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at loop continuation time, before any LEAVE \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at loop termination time, after any LEAVE \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e块结束\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"k\"\u003eLEAVE\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at every block exit time (even stack unwinds from exceptions) \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"k\"\u003eKEEP\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at every successful block exit, part of LEAVE queue \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"k\"\u003eUNDO\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at every unsuccessful block exit, part of LEAVE queue \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e块的后置条件\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"k\"\u003ePOST\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  assert postcondition at every block exit, after LEAVE \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e异步 whenever-block 结束\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  if ended normally with done, runs once after block \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"k\"\u003eQUIT\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  catch async exceptions \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e程序终止\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eEND\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e#  at runtime, ALAP, only ever runs once \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"程序执行-phasershttpsdocsrakuorglanguagephasers___top\"\u003e\u003ca href=\"https://docs.raku.org/language/phasers#___top\"\u003e程序执行 phasers\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"begin\"\u003eBEGIN\u003c/h2\u003e\n\u003cp\u003e编译时运行，一旦 phaser 中的代码编译完毕，就只运行一次。\u003c/p\u003e\n\u003cp\u003e返回值可在以后的 phaser 中使用：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eAbout to print 3 things\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"o\"\u003e^\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"o\"\u003e^\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003epick\u003c/span\u003e \u003cspan class=\"o\"\u003e~\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e-\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e \u003cspan class=\"o\"\u003e~\u003c/span\u003e \u003cspan class=\"k\"\u003eBEGIN\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nb\"\u003esay\u003c/span\u003e  \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eGenerating BEGIN value\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e \u003cspan class=\"o\"\u003e^\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003epick\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# OUTPUT: \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# Generating BEGIN value \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# About to print 3 things \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 3-3 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 4-3 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 6-3 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ephaser 中的 \u003ccode\u003e^10 .pick\u003c/code\u003e 只产生一次，并在运行时期间由循环重用。注意怎么 \u003ccode\u003eBEGIN\u003c/code\u003e 块中的 \u003ca href=\"https://docs.raku.org/routine/say\"\u003esay\u003c/a\u003e 是在上述循环执行之前是怎么执行的。\u003c/p\u003e\n\u003ch2 id=\"check\"\u003eCHECK\u003c/h2\u003e\n\u003cp\u003e在编译时运行，尽可能晚，只运行一次。\u003c/p\u003e\n\u003cp\u003e可以具有即使在后期 phases 提供的返回值。\u003c/p\u003e\n\u003cp\u003e在运行时生成的代码仍然可以启动 \u003ccode\u003eCHECK\u003c/code\u003e 和 \u003ccode\u003eINIT\u003c/code\u003e phasers，但当然这些 phaser 无法做出需要及时返回的事情。你需要一个虫洞。\u003c/p\u003e\n\u003ch2 id=\"init\"\u003eINIT\u003c/h2\u003e\n\u003cp\u003e在 main 执行期间编译后运行，尽快运行一次。它可以具有即使在后期 phases 也提供的返回值。\u003c/p\u003e\n\u003cp\u003e当 phaser 位于不同的模块中时， phaser \u003ccode\u003eINIT\u003c/code\u003e 和 \u003ccode\u003eEND\u003c/code\u003e phaser 将被视为在使用模块中就像在 \u003ccode\u003euse\u003c/code\u003e 时声明一样。（如果模块被多次使用，则依赖于此顺序是错误的，因为仅在第一次注意到它们时才安装 phaser 。）\u003c/p\u003e\n\u003cp\u003e在运行时生成的代码仍然可以启动 \u003ccode\u003eCHECK\u003c/code\u003e 和 \u003ccode\u003eINIT\u003c/code\u003e phaser，但当然这些 phaser 无法做出需要及时返回的事情。你需要一个虫洞。\u003c/p\u003e\n\u003cp\u003e对 \u003ccode\u003eINIT\u003c/code\u003e 克隆闭包的所有副本只运行一次。\u003c/p\u003e\n\u003ch2 id=\"end\"\u003eEND\u003c/h2\u003e\n\u003cp\u003e在 main 执行期间编译后运行，尽可能晚，只运行一次。\u003c/p\u003e\n\u003cp\u003e当 phaser 位于不同的模块中时， \u003ccode\u003eINIT\u003c/code\u003e 和 \u003ccode\u003eEND\u003c/code\u003e phaser 将被视为在正使用的模块中就像在 \u003ccode\u003euse\u003c/code\u003e 时声明一样。（如果模块被多次使用，则依赖于此顺序是错误的，因为仅在第一次注意到它们时才安装 phaser 。）\u003c/p\u003e\n\u003ch1 id=\"block-phasershttpsdocsrakuorglanguagephasers___top\"\u003e\u003ca href=\"https://docs.raku.org/language/phasers#___top\"\u003eBlock phasers\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e块的上下文中的执行具有其自己的 phases。\u003c/p\u003e\n\u003cp\u003e块离开 phaser 等待直到调用堆栈实际展开才能运行。只有在某个异常处理程序决定以这种方式处理异常之后才会展开。也就是说，仅仅因为异常被抛出堆栈帧并不意味着我们已经正式离开了块，因为异常可能是可恢复的。在任何情况下，异常处理程序都指定在失败代码的动态作用域内运行，无论异常是否可恢复。堆栈已展开，仅在未恢复异常时才调用 phaser 。\u003c/p\u003e\n\u003cp\u003e这些可以在块内多次出现。所以它们确实不是真正的 trait - 它们将自己添加到存储在实际 trait 中的列表中。如果你检查块的 \u003ccode\u003eENTER\u003c/code\u003e trait，你会发现它实际上是一个 phaser 列表而不是一个 phaser 。\u003c/p\u003e\n\u003cp\u003e所有这些 phaser 块都可以看到任何先前声明的词法变量，即使在调用闭包时尚未详细说明这些变量（在这种情况下，变量会计算为未定义的值。）\u003c/p\u003e\n\u003ch2 id=\"enter\"\u003eENTER\u003c/h2\u003e\n\u003cp\u003e在每个块进入时运行，在循环块上重复。\u003c/p\u003e\n\u003cp\u003e可以具有即使在后期 phases 提供的返回值。\u003c/p\u003e\n\u003cp\u003e从 \u003ccode\u003eENTER\u003c/code\u003e phaser 抛出的异常将中止 \u003ccode\u003eENTER\u003c/code\u003e 队列，但是从 \u003ccode\u003eLEAVE\u003c/code\u003e phaser 抛出的异常将不会。\u003c/p\u003e\n\u003ch2 id=\"leave\"\u003eLEAVE\u003c/h2\u003e\n\u003cp\u003e在每个块退出时运行（甚至堆栈从异常中展开），除非程序突然退出（例如 \u003ca href=\"https://docs.raku.org/routine/exit\"\u003e\u003ccode\u003eexit\u003c/code\u003e\u003c/a\u003e）。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eLEAVE\u003c/code\u003e 在任何 \u003ccode\u003eCATCH\u003c/code\u003e 和 \u003ccode\u003eCONTROL\u003c/code\u003e phaser 之后必须计算给定块的 phaser 。这包括 \u003ccode\u003eLEAVE\u003c/code\u003e 变体，\u003ccode\u003eKEEP\u003c/code\u003e 和 \u003ccode\u003eUNDO\u003c/code\u003e。\u003ccode\u003ePOST\u003c/code\u003e 在其他一切之后对 phaser 进行计算，以保证偶数 \u003ccode\u003eLEAVE\u003c/code\u003e phaser 不会违反后置条件。\u003c/p\u003e\n\u003cp\u003e从 \u003ccode\u003eENTER\u003c/code\u003e phaser 抛出的异常将中止 \u003ccode\u003eENTER\u003c/code\u003e 队列，但是从 \u003ccode\u003eLEAVE\u003c/code\u003e phaser 抛出的异常将不会。\u003c/p\u003e\n\u003cp\u003e如果 \u003ccode\u003ePOST\u003c/code\u003e 失败或任何类型的 \u003ccode\u003eLEAVE\u003c/code\u003e 块在堆栈展开时抛出异常，则展开继续并收集要处理的异常。展开完成后，将从该点抛出所有新异常。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003eanswer\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eLEAVE\u003c/span\u003e \u003cspan class=\"nb\"\u003esay\u003c/span\u003e „\u003cspan class=\"n\"\u003eI\u003c/span\u003e \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nb\"\u003eafter\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nb\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e“\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"mi\"\u003e42\u003c/span\u003e \u003cspan class=\"c1\"\u003e# this is the return value \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e注意:\u003c/strong\u003e 铭记 \u003ccode\u003eLEAVE\u003c/code\u003e phaser 直接在程序的块，即使用错误的参数尝试调用该例程, 他们也将得到执行：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003efoo\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eHello!\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eLEAVE\u003c/span\u003e \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eoh noes!\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003etry\u003c/span\u003e \u003cspan class=\"n\"\u003efoo\u003c/span\u003e \u003cspan class=\"nb\"\u003erand\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e# OUTPUT: «oh noes!» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e虽然子程序的主体没有得到执行，因为 sub 的\u003ca href=\"https://docs.raku.org/type/Int\"\u003eInt\u003c/a\u003e 和 \u003ca href=\"https://docs.raku.org/routine/rand\"\u003e\u003ccode\u003erand\u003c/code\u003e\u003c/a\u003e 期望返回一个 \u003ca href=\"https://docs.raku.org/type/Num\"\u003eNum\u003c/a\u003e，其块进入和离开时（指令绑定失败），因此 \u003ccode\u003eLEAVE\u003c/code\u003e phaser \u003cem\u003e正\u003c/em\u003e运行。\u003c/p\u003e\n\u003ch2 id=\"keep\"\u003eKEEP\u003c/h2\u003e\n\u003cp\u003e在每个成功的块出口处运行，作为 LEAVE 队列的一部分（共享相同的执行顺序）。\u003c/p\u003e\n\u003ch2 id=\"undo\"\u003eUNDO\u003c/h2\u003e\n\u003cp\u003e在每个不成功的块出口处运行，作为 LEAVE 队列的一部分（共享相同的执行顺序）。\u003c/p\u003e\n\u003ch2 id=\"pre\"\u003ePRE\u003c/h2\u003e\n\u003cp\u003e断言每个块条目的前提条件。在 ENTER phase 之前运行。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePRE\u003c/code\u003e phaser 在任何 \u003ccode\u003eENTER\u003c/code\u003e 或 \u003ccode\u003eFIRST\u003c/code\u003e 之前启动。\u003c/p\u003e\n\u003cp\u003e失败的 \u003ccode\u003ePRE\u003c/code\u003e 和 \u003ccode\u003ePOST\u003c/code\u003e phaser 抛出的异常不能被同一个块中的 \u003ccode\u003eCATCH\u003c/code\u003e 异常捕获，这意味着如果\u003ccode\u003ePRE\u003c/code\u003ephaser 失败，则 \u003ccode\u003ePOST\u003c/code\u003e phaser 不会运行。\u003c/p\u003e\n\u003ch2 id=\"post\"\u003ePOST\u003c/h2\u003e\n\u003cp\u003e在每个块条目处断言后置条件。在 LEAVE phase 后运行。\u003c/p\u003e\n\u003cp\u003e对于如 \u003ccode\u003eKEEP\u003c/code\u003e 和 \u003ccode\u003ePOST\u003c/code\u003e 的 phaser，在正常情况下退出作用域时运行，返回值（如果有的话）从该作用域可作为 phaser 中的当前主题。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePOST\u003c/code\u003e 块可以以两种方式之一来定义。要么 \u003ccode\u003ePOST\u003c/code\u003e 定义为单独的 phaser ，在这种情况下 \u003ccode\u003ePRE\u003c/code\u003e 和 \u003ccode\u003ePOST\u003c/code\u003e 不共享词法作用域。或者，任何 \u003ccode\u003ePRE\u003c/code\u003e phaser 都可以将其对应的 \u003ccode\u003ePOST\u003c/code\u003e 定义为嵌入式 phaser 块，该 phaser 块封闭在 \u003ccode\u003ePRE\u003c/code\u003e 的词法作用域内。\u003c/p\u003e\n\u003cp\u003e如果 \u003ccode\u003ePOST\u003c/code\u003e 失败或任何类型的 \u003ccode\u003eLEAVE\u003c/code\u003e 块在堆栈展开时抛出异常，则展开继续并收集要处理的异常。展开完成后，将从该点抛出所有新异常。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePRE\u003c/code\u003e 和 \u003ccode\u003ePOST\u003c/code\u003e phaser 抛出的异常不能被同一个块中的  \u003ccode\u003eCATCH\u003c/code\u003e 异常捕获，这意味着如果 \u003ccode\u003ePRE\u003c/code\u003e phaser 失败，\u003ccode\u003ePOST\u003c/code\u003e phaser 就不会运行。\u003c/p\u003e\n\u003ch1 id=\"loop-phasershttpsdocsrakuorglanguagephasers___top\"\u003e\u003ca href=\"https://docs.raku.org/language/phasers#___top\"\u003eLoop phasers\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003eFIRST\u003c/code\u003e，\u003ccode\u003eNEXT\u003c/code\u003e 和 \u003ccode\u003eLAST\u003c/code\u003e 仅在循环的词法作用域内有意义，并且可能仅在这样的循环块的顶层发生。\u003c/p\u003e\n\u003ch2 id=\"first\"\u003eFIRST\u003c/h2\u003e\n\u003cp\u003e在 ENTER 之前运行循环初始化。\u003c/p\u003e\n\u003ch2 id=\"next\"\u003eNEXT\u003c/h2\u003e\n\u003cp\u003e循环继续（通过 \u003ccode\u003enext\u003c/code\u003e 或因为你到达循环的底部并循环回来）时运行，在LEAVE之前。\u003c/p\u003e\n\u003cp\u003e仅当正常到达循环块的末尾或 \u003ccode\u003enext\u003c/code\u003e显式 执行时，才执行 \u003ccode\u003eNEXT\u003c/code\u003e。 与 \u003ccode\u003eLEAVE\u003c/code\u003e phaser 不同，\u003ccode\u003eNEXT\u003c/code\u003e 如果通过除由 \u003ccode\u003enext\u003c/code\u003e 引发的控制异常之外的任何异常退出循环块，则不执行 \u003ccode\u003eNEXT\u003c/code\u003e phaser。特别地，\u003ccode\u003elast\u003c/code\u003e 绕过了 \u003ccode\u003eNEXT\u003c/code\u003e phaser 的计算。\u003c/p\u003e\n\u003ch2 id=\"last\"\u003eLAST\u003c/h2\u003e\n\u003cp\u003e在循环结束时运行，在 \u003ccode\u003eLEAVE\u003c/code\u003e 之后(或者当它使用 \u003ccode\u003elast\u003c/code\u003e 或 \u003ccode\u003ereturn\u003c/code\u003e 退出时; 或者因为你到了循环的底部) 。\u003c/p\u003e\n\u003ch1 id=\"exception-handling-phasershttpsdocsrakuorglanguagephasers___top\"\u003e\u003ca href=\"https://docs.raku.org/language/phasers#___top\"\u003eException handling phasers\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"catch\"\u003eCATCH\u003c/h2\u003e\n\u003cp\u003e在 LEAVE phase 之前，当前块引发异常时运行。\u003c/p\u003e\n\u003ch2 id=\"control\"\u003eCONTROL\u003c/h2\u003e\n\u003cp\u003e在 LEAVE phase 之前，当前块引发控制异常时运行。它通过 \u003ccode\u003ereturn\u003c/code\u003e，\u003ccode\u003efail\u003c/code\u003e，\u003ccode\u003eredo\u003c/code\u003e，\u003ccode\u003enext\u003c/code\u003e，\u003ccode\u003elast\u003c/code\u003e，\u003ccode\u003eemit\u003c/code\u003e，\u003ccode\u003etake\u003c/code\u003e，\u003ccode\u003ewarn\u003c/code\u003e，\u003ccode\u003eproceed\u003c/code\u003e 和 \u003ccode\u003esucceed\u003c/code\u003e 发生。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nb\"\u003eelems\u003c/span\u003e \u003cspan class=\"k\"\u003egather\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eCONTROL\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ewhen\u003c/span\u003e \u003cspan class=\"ne\"\u003eCX::Warn\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eWARNING!!! \u003c/span\u003e\u003cspan class=\"nv\"\u003e$_\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eresume\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ewhen\u003c/span\u003e \u003cspan class=\"ne\"\u003eCX::Take\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eDon\u0026#39;t take my stuff\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eresume\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003ewarn\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003epeople take stuff here\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003etake\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003ekeys\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# OUTPUT: \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# WARNING!!! people take stuff here \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# Don\u0026#39;t take my stuff \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 0 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"object-phasershttpsdocsrakuorglanguagephasers___top\"\u003e\u003ca href=\"https://docs.raku.org/language/phasers#___top\"\u003eObject phasers\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"compose-not-yet-implemented\"\u003eCOMPOSE (Not yet implemented)\u003c/h2\u003e\n\u003cp\u003e将角色组合到一个类中时运行。\u003c/p\u003e\n\u003ch1 id=\"asynchronous-phasershttpsdocsrakuorglanguagephasers___top\"\u003e\u003ca href=\"https://docs.raku.org/language/phasers#___top\"\u003eAsynchronous phasers\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"last-1\"\u003eLAST\u003c/h2\u003e\n\u003cp\u003e当\u003ca href=\"https://docs.raku.org/type/Supply\"\u003eSupply\u003c/a\u003e 完成 \u003ccode\u003edone\u003c/code\u003e 调用或当一个 \u003ccode\u003esupply\u003c/code\u003e 块正常退出时运行。它在 \u003ccode\u003ewhenever\u003c/code\u003e 块完成后完全运行。\u003c/p\u003e\n\u003cp\u003e此 phaser 重用该名称 \u003ccode\u003eLAST\u003c/code\u003e，但与 \u003ccode\u003eLAST\u003c/code\u003e 循环 phaser 的工作方式不同。此 phaser 类似于用 \u003ccode\u003etap\u003c/code\u003e supply 设置例程 \u003ccode\u003edone\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"quit\"\u003eQUIT\u003c/h2\u003e\n\u003cp\u003e当 \u003ca href=\"https://docs.raku.org/type/Supply\"\u003eSupply\u003c/a\u003e 以异常提前终止时运行。它在放置的  \u003ccode\u003ewhenever\u003c/code\u003e 块完成后运行。\u003c/p\u003e\n\u003cp\u003e此 phaser 类似于 \u003ccode\u003equit\u003c/code\u003e 在 \u003ccode\u003etap\u003c/code\u003e supply 时设置例程 \u003ccode\u003equit\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"close\"\u003eCLOSE\u003c/h2\u003e\n\u003cp\u003e出现在 supply 块中。supply 关闭时调用。\u003c/p\u003e\n\u003ch1 id=\"doc-phasershttpsdocsrakuorglanguagephasers___top\"\u003e\u003ca href=\"https://docs.raku.org/language/phasers#___top\"\u003eDOC phasers\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"doc\"\u003eDOC\u003c/h2\u003e\n\u003cp\u003ephaser \u003ccode\u003eBEGIN\u003c/code\u003e，\u003ccode\u003eCHECK\u003c/code\u003e 和 \u003ccode\u003eINIT\u003c/code\u003e 仅在文档模式时，前面带有 \u003ccode\u003eDOC\u003c/code\u003e 关键字。当使用 \u003ccode\u003e--doc\u003c/code\u003e 运行时编译器在文档中。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eDOC\u003c/span\u003e \u003cspan class=\"k\"\u003eINIT\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003einit\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e  \u003cspan class=\"p\"\u003e}\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# prints \u0026#39;init\u0026#39; at initialization time when in documentation mode. \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","text":"程序的生命周期（执行时间表）分为几个阶段。phaser是在特定执行阶段调用的代码块。\nPhasers phaser 块只是包含它的闭包的 trait，并在适当的时刻自动调用。这些自动调用的块称为 phasers，因为它们通常标记从计算的一个阶段到另一个阶段的转换。例如，在编译编译单元结束时调用 CHECK 块。也可以安装其他类型的 phasers; 它们会在适当的时候自动调用，其中一些 phasers 响应各种控制异常和退出值。例如，如果块的退出成功或失败，则可能会调用某些 phasers，在这种情况下成功退出, 则在这时返回定义的值或列表，而不带任何 Failure 或异常。\n以下是摘要：\nBEGIN {...} # * at compile time, as soon as possible, only ever runs once CHECK {...} # * at compile time, as late as possible, only ever runs once INIT {...} # * at runtime, as soon as possible, only ever runs once END {...} # at runtime, as late as possible, only ever runs once DOC [BEGIN|CHECK|INIT] {...} # only in documentation mode ENTER {...} # * at every block entry time, repeats on loop blocks. LEAVE {...} # at every block exit time (even stack unwinds from exceptions) KEEP {...} # at every successful block exit, part of LEAVE queue UNDO {...} # at every unsuccessful block exit, part of LEAVE queue FIRST {...} # at loop initialization time, before any ENTER NEXT {...} # at loop continuation time, before any LEAVE LAST {...} # at loop termination time, after any LEAVE PRE {...} # assert precondition at every block entry, before ENTER POST {...} # assert postcondition at every block exit, after LEAVE CATCH {...} # catch exceptions, before LEAVE CONTROL {...} # catch control exceptions, before LEAVE LAST {...} # supply tapped by whenever-block is done, runs very last QUIT {...} # catch async exceptions within a whenever-block, runs very last COMPOSE {...} # when a role is composed into a class (Not yet implemented) CLOSE {...} # appears in a supply block, called when the supply is closed 标记为 * 号的 phaser 具有运行时值，并且如果早于周围表达式进行求值，则只需保存其结果，以便在以后计算表达式的其余部分时在表达式中使用：\nmy $compiletime = BEGIN { now }; our $random = ENTER { rand }; 与其他语句前缀一样，这些产生值的构造可以放在块或语句的前面：\nmy $compiletime = BEGIN now; our $random = ENTER rand; 这些 phaser 的大多数将接收块或函数引用。语句形式对于将词法作用域的声明暴露给周围的词法作用域而不在块中“捕获”它特别有用。\n它们声明了与前面示例相同作用域的相同变量，但在指定时间把语句作为整体运行：\nBEGIN my $compiletime = now; ENTER our $random = rand; （但请注意，在运行时克隆任何周围闭包时，在编译时计算的变量值可能不会持久存在。）\n大多数非值生成 phasers 也可能如此使用：\nEND say my $accumulator; 但请注意：\nEND say my $accumulator = 0; 在 END time 时将变量设置为 0 ，因为这是实际执行 “my” 声明的时间。只有无参数的 phasers 可以使用语句形式。这意味着 CATCH 和 CONTROL 始终需要一个块，因为它们接收一个设置 $_ 为当前主题的参数，以便内部行为能够表现为 switch 语句。（如果允许使用裸语句，那么 $_ 临时绑定会在 CATCH或者CONTROL 结束时泄漏出来，带来不可预测的，甚至可能是可怕的后果。异常处理程序应该减少不确定性，而不是增加它。）\n其中一些 phasers 也具有可以在变量上设置的相应 trait; 他们使用 will 后面跟着小写的 phaser 名称。这些优点是将讨论中的变量作为主题传递给闭包：\nour $h will enter { .rememberit() } will undo { .forgetit() }; 只有在块内可以多次出现的 phaser 才有资格获得这种每个变量(per-variable)形式; 这不包括 CATCH 和其他例如 CLOSE 或 QUIT phaser 。\nphaser 外部的块的主题作为 OUTER::\u0026lt;$_\u0026gt; 仍然可用。返回值是否可修改可能是所讨论的 phaser 的策略。特别地，不应在 POST phaser 内修改返回值，但 LEAVE phaser 可能更自由。\n在方法的词法作用域中定义的任何 phaser 都是闭合 self 以及正常词汇。（或者等效地，实现可以简单地将所有这样的 phaser 转换为其引导的调用者是当前对象的子方法。）\n当多个 phaser 被安排在同一时刻运行时，一般的打破平局的原则是初始化 phaser 按照声明的顺序执行，而最终 phaser 以相反的顺序执行，因为设置和拆除通常希望以相反的顺序相互发生。\n执行顺序 编译开始\nBEGIN {...} # at compile time, As soon as possible, only ever runs once CHECK {...} # at compile time, As late as possible, only ever runs once COMPOSE {...} # when a role is composed into a class (Not yet implemented) 执行开始\nINIT {...} # at runtime, as soon as possible, only ever runs once 在块执行开始之前\nPRE {...} # assert precondition at every block entry, before ENTER 循环执行开始\nFIRST {...} # at loop initialization time, before any ENTER 块执行开始\nENTER {...} # at every block entry time, repeats on loop blocks. 可能会发生异常\nCATCH {...} # catch exceptions, before LEAVE CONTROL {...} # catch control exceptions, before LEAVE 循环结束，继续或结束\nNEXT {...} # at loop continuation time, before any LEAVE LAST {...} # at loop termination time, after any LEAVE 块结束\nLEAVE {...} # at every block exit time (even stack unwinds from exceptions) KEEP {...} # at every successful block exit, part of LEAVE queue UNDO {...} # at every unsuccessful block exit, part of LEAVE queue 块的后置条件\nPOST {...} # assert postcondition at every block exit, after LEAVE 异步 whenever-block 结束\nLAST {...} # if ended normally with done, runs once after block QUIT {...} # catch async exceptions 程序终止\nEND {...} # at runtime, ALAP, only ever runs once 程序执行 phasers BEGIN 编译时运行，一旦 phaser 中的代码编译完毕，就只运行一次。\n返回值可在以后的 phaser 中使用：\nsay \u0026#34;About to print 3 things\u0026#34;; for ^3 { say ^10 .pick ~ \u0026#39;-\u0026#39; ~ BEGIN { say \u0026#34;Generating BEGIN value\u0026#34;; ^10 .pick } } # OUTPUT: # Generating BEGIN value # About to print 3 things # 3-3 # 4-3 # 6-3 phaser 中的 ^10 .pick 只产生一次，并在运行时期间由循环重用。注意怎么 BEGIN 块中的 say 是在上述循环执行之前是怎么执行的。\nCHECK 在编译时运行，尽可能晚，只运行一次。\n可以具有即使在后期 phases 提供的返回值。\n在运行时生成的代码仍然可以启动 CHECK 和 INIT phasers，但当然这些 phaser 无法做出需要及时返回的事情。你需要一个虫洞。\nINIT 在 main 执行期间编译后运行，尽快运行一次。它可以具有即使在后期 phases 也提供的返回值。\n当 phaser 位于不同的模块中时， phaser INIT 和 END phaser 将被视为在使用模块中就像在 use 时声明一样。（如果模块被多次使用，则依赖于此顺序是错误的，因为仅在第一次注意到它们时才安装 phaser 。）\n在运行时生成的代码仍然可以启动 CHECK 和 INIT phaser，但当然这些 phaser 无法做出需要及时返回的事情。你需要一个虫洞。\n对 INIT 克隆闭包的所有副本只运行一次。\nEND 在 main 执行期间编译后运行，尽可能晚，只运行一次。\n当 phaser 位于不同的模块中时， INIT 和 END phaser 将被视为在正使用的模块中就像在 use 时声明一样。（如果模块被多次使用，则依赖于此顺序是错误的，因为仅在第一次注意到它们时才安装 phaser 。）\nBlock phasers 块的上下文中的执行具有其自己的 phases。\n块离开 phaser 等待直到调用堆栈实际展开才能运行。只有在某个异常处理程序决定以这种方式处理异常之后才会展开。也就是说，仅仅因为异常被抛出堆栈帧并不意味着我们已经正式离开了块，因为异常可能是可恢复的。在任何情况下，异常处理程序都指定在失败代码的动态作用域内运行，无论异常是否可恢复。堆栈已展开，仅在未恢复异常时才调用 phaser 。\n这些可以在块内多次出现。所以它们确实不是真正的 trait - 它们将自己添加到存储在实际 trait 中的列表中。如果你检查块的 ENTER trait，你会发现它实际上是一个 phaser 列表而不是一个 phaser 。\n所有这些 phaser 块都可以看到任何先前声明的词法变量，即使在调用闭包时尚未详细说明这些变量（在这种情况下，变量会计算为未定义的值。）\nENTER 在每个块进入时运行，在循环块上重复。\n可以具有即使在后期 phases 提供的返回值。\n从 ENTER phaser 抛出的异常将中止 ENTER 队列，但是从 LEAVE phaser 抛出的异常将不会。\nLEAVE 在每个块退出时运行（甚至堆栈从异常中展开），除非程序突然退出（例如 exit）。\nLEAVE 在任何 CATCH 和 CONTROL phaser 之后必须计算给定块的 phaser 。这包括 LEAVE 变体，KEEP 和 UNDO。POST 在其他一切之后对 phaser 进行计算，以保证偶数 LEAVE phaser 不会违反后置条件。\n从 ENTER phaser 抛出的异常将中止 ENTER 队列，但是从 LEAVE phaser 抛出的异常将不会。\n如果 POST 失败或任何类型的 LEAVE 块在堆栈展开时抛出异常，则展开继续并收集要处理的异常。展开完成后，将从该点抛出所有新异常。\nsub answer() { LEAVE say „I say after the return value.“; 42 # this is the return value } 注意: 铭记 LEAVE phaser 直接在程序的块，即使用错误的参数尝试调用该例程, 他们也将得到执行：\nsub foo (Int) { say \u0026#34;Hello!\u0026#34;; LEAVE say \u0026#34;oh noes!\u0026#34; } try foo rand; # OUTPUT: «oh noes!» 虽然子程序的主体没有得到执行，因为 sub 的Int 和 rand 期望返回一个 Num，其块进入和离开时（指令绑定失败），因此 LEAVE phaser 正运行。\nKEEP 在每个成功的块出口处运行，作为 LEAVE 队列的一部分（共享相同的执行顺序）。\nUNDO 在每个不成功的块出口处运行，作为 LEAVE 队列的一部分（共享相同的执行顺序）。\nPRE 断言每个块条目的前提条件。在 ENTER phase 之前运行。\nPRE phaser 在任何 ENTER 或 FIRST 之前启动。\n失败的 PRE 和 POST phaser 抛出的异常不能被同一个块中的 CATCH 异常捕获，这意味着如果PREphaser 失败，则 POST phaser 不会运行。\nPOST 在每个块条目处断言后置条件。在 LEAVE phase 后运行。\n对于如 KEEP 和 POST 的 phaser，在正常情况下退出作用域时运行，返回值（如果有的话）从该作用域可作为 phaser 中的当前主题。\nPOST 块可以以两种方式之一来定义。要么 POST 定义为单独的 phaser ，在这种情况下 PRE 和 POST 不共享词法作用域。或者，任何 PRE phaser 都可以将其对应的 POST 定义为嵌入式 phaser 块，该 phaser 块封闭在 PRE 的词法作用域内。\n如果 POST 失败或任何类型的 LEAVE 块在堆栈展开时抛出异常，则展开继续并收集要处理的异常。展开完成后，将从该点抛出所有新异常。\nPRE 和 POST phaser 抛出的异常不能被同一个块中的 CATCH 异常捕获，这意味着如果 PRE phaser 失败，POST phaser 就不会运行。\nLoop phasers FIRST，NEXT 和 LAST 仅在循环的词法作用域内有意义，并且可能仅在这样的循环块的顶层发生。\nFIRST 在 ENTER 之前运行循环初始化。\nNEXT 循环继续（通过 next 或因为你到达循环的底部并循环回来）时运行，在LEAVE之前。\n仅当正常到达循环块的末尾或 next显式 执行时，才执行 NEXT。 与 LEAVE phaser 不同，NEXT 如果通过除由 next 引发的控制异常之外的任何异常退出循环块，则不执行 NEXT phaser。特别地，last 绕过了 NEXT phaser 的计算。\nLAST 在循环结束时运行，在 LEAVE 之后(或者当它使用 last 或 return 退出时; 或者因为你到了循环的底部) 。\nException handling phasers CATCH 在 LEAVE phase 之前，当前块引发异常时运行。\nCONTROL 在 LEAVE phase 之前，当前块引发控制异常时运行。它通过 return，fail，redo，next，last，emit，take，warn，proceed 和 succeed 发生。\nsay elems gather { CONTROL { when CX::Warn { say \u0026#34;WARNING!!! $_\u0026#34;; .resume } when CX::Take { say \u0026#34;Don\u0026#39;t take my stuff\u0026#34;; .resume } } warn \u0026#39;people take stuff here\u0026#39;; take \u0026#39;keys\u0026#39;; } # OUTPUT: # WARNING!!! people take stuff here # Don\u0026#39;t take my stuff # 0 Object phasers COMPOSE (Not yet implemented) 将角色组合到一个类中时运行。\nAsynchronous phasers LAST 当Supply 完成 done 调用或当一个 supply 块正常退出时运行。它在 whenever 块完成后完全运行。\n此 phaser 重用该名称 LAST，但与 LAST 循环 phaser 的工作方式不同。此 phaser 类似于用 tap supply 设置例程 done。\nQUIT 当 Supply 以异常提前终止时运行。它在放置的 whenever 块完成后运行。\n此 phaser 类似于 quit 在 tap supply 时设置例程 quit。\nCLOSE 出现在 supply 块中。supply 关闭时调用。\nDOC phasers DOC phaser BEGIN，CHECK 和 INIT 仅在文档模式时，前面带有 DOC 关键字。当使用 --doc 运行时编译器在文档中。\nDOC INIT { say \u0026#39;init\u0026#39; } # prints \u0026#39;init\u0026#39; at initialization time when in documentation mode. "},"name":"Phasers","published":"2018-12-02T21:13:31+08:00","summary":"程序的生命周期（执行时间表）分为几个阶段。phaser是在特定执行阶段调用的代码块。\nPhasers phaser 块只是包含它的闭包的 trait，并在适当的时刻自动调用。这些自动调用的块称为 phasers，因为它们通常标记从计算的一个阶段到另一个阶段的转换。例如，在编译编译单元结束时调用 CHECK 块。也可以安装其他类型的 phasers; 它们会在适当的时候自动调用，其中一些 phasers 响应各种控制异常和退出值。例如，如果块的退出成功或失败，则可能会调用某些 phasers，在这种情况下成功退出, 则在这时返回定义的值或列表，而不带任何 Failure 或异常。\n以下是摘要：\nBEGIN {...} # * at compile time, as soon as possible, only ever runs once CHECK {...} # * at compile time, as late as possible, only ever runs once INIT {...} # * at runtime, as soon as possible, only ever runs once END {...} # at runtime, as late as possible, only ever runs once DOC [BEGIN|CHECK|INIT] {.","type":"entry","url":"https://ohmycloud.github.io/posts/58.phasers/"}