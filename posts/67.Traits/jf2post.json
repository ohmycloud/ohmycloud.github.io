{"author":{"name":null,"type":"card","url":"https://ohmycloud.github.io/"},"content":{"html":"\u003cp\u003e在 Raku 中，\u003cem\u003etraits\u003c/em\u003e是附加到对象和类的编译器钩子，它们修改了类和对象的默认行为，功能或表示。作为这样的编译器钩子，它们是在编译时定义的，尽管它们可以用于运行时。\u003c/p\u003e\n\u003cp\u003e通过使用 \u003ccode\u003etrait_mod\u003c/code\u003e 关键字，已经将几个 traits 定义为语言或 Rakudo 编译器的一部分。接下来列出并解释它们。\u003c/p\u003e\n\u003ch1 id=\"is-traithttpsdocsrakuorglanguagetraits___top\"\u003e\u003ca href=\"https://docs.raku.org/language/traits#___top\"\u003eis trait\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e定义为\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eproto\u003c/span\u003e \u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nb\"\u003etrait_mod\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003eis\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;(\u003c/span\u003e\u003cspan class=\"kt\"\u003eMu\u003c/span\u003e \u003cspan class=\"nv\"\u003e$\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003eis\u003c/code\u003e 适用于任何类型的标量对象，并且可以接收任意数量的命名参数或位置参数。它是最常用的 trait，取决于第一个参数的类型，采用以下形式。\u003c/p\u003e\n\u003ch2 id=\"is-应用于类httpsdocsrakuorglanguagetraits___top\"\u003e\u003ca href=\"https://docs.raku.org/language/traits#___top\"\u003e\u003ccode\u003eis\u003c/code\u003e 应用于类\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e最常见的形式涉及两个类，一个正在定义，另一个现有，定义为 \u003ca href=\"https://docs.raku.org/syntax/is\"\u003edefines parenthood\u003c/a\u003e。  \u003ccode\u003eA is B\u003c/code\u003e, 如果两个都是类，则将 A 定义为 B 的子类。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eis DEPRECATED\u003c/code\u003e 可以应用于类，属性或例程，将它们标记为已弃用并发出警告消息（如果提供了的话）。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eis\u003c/code\u003e 的几个实例被直接转换为它们引用的类的属性：\u003ccode\u003erw\u003c/code\u003e，\u003ccode\u003enativesize\u003c/code\u003e，\u003ccode\u003ectype\u003c/code\u003e，\u003ccode\u003eunsigned\u003c/code\u003e，\u003ccode\u003ehidden\u003c/code\u003e，\u003ccode\u003earray_type\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e不可实例化的表示 trait 与表示没有多大关系，与特定类可以做什么有关; 它有效地防止以任何可能的方式创建类的实例。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003econstant\u003c/span\u003e \u003cspan class=\"nv\"\u003e@IMM\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003eInnie Minnie Moe\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003edon\u0026#39;t-instantiate\u003c/span\u003e \u003cspan class=\"k\"\u003eis\u003c/span\u003e \u003cspan class=\"k\"\u003erepr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003eUninstantiable\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$.counter\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nf\"\u003eimm\u003c/span\u003e \u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nv\"\u003e@IMM\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e \u003cspan class=\"nv\"\u003e$.counter\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e \u003cspan class=\"ow\"\u003emod\u003c/span\u003e \u003cspan class=\"nv\"\u003e@IMM\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eelems\u003c/span\u003e \u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"n\"\u003edon\u0026#39;t-instantiate\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eimm\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"o\"\u003e^\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e不能实例化的类仍然可以通过它们的类变量和方法使用, 如上所示。尝试这样: \u003ccode\u003emy $do-instantiate = don't-instantiate.new;\u003c/code\u003e 来实例化它们会产生错误。\u003c/p\u003e\n\u003ch2 id=\"is-repr-和原生表示httpsdocsrakuorglanguagetraits___top\"\u003e\u003ca href=\"https://docs.raku.org/language/traits#___top\"\u003e\u003ccode\u003eis repr\u003c/code\u003e 和原生表示\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e由于 \u003ccode\u003eis\u003c/code\u003e trait 通常指的是它们所应用的类或对象的性质，因此它们在\u003ca href=\"(https://docs.raku.org/language/nativecall)\"\u003e原生调用\u003c/a\u003e中被广泛使用，以指定将由原生函数通过 \u003ccode\u003eis repr\u003c/code\u003e 后缀处理的数据结构的\u003ca href=\"https://docs.raku.org/language/nativecall#Specifying_the_native_representation\"\u003e表示\u003c/a\u003e。同时，\u003ccode\u003eis native\u003c/code\u003e 用于通过原生函数实际实现的例程。这些是可以使用的表示：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCStruct 对应于 C 语言中的 \u003ccode\u003estruct\u003c/code\u003e。它是一种复合数据结构，包括不同的异构和低级数据结构;请参阅\u003ca href=\"https://docs.raku.org/language/nativecall#Structs\"\u003e此示例\u003c/a\u003e和进一步说明。\u003c/li\u003e\n\u003cli\u003e类似地，CPPStruct 对应于 C++ 中的 \u003ccode\u003estruct\u003c/code\u003e。但是，这是暂时是 Rakudo 特定的。\u003c/li\u003e\n\u003cli\u003eCPointer 是任何这些语言的指针。它是一个动态数据结构，必须在使用之前进行实例化，可\u003ca href=\"https://docs.raku.org/language/nativecall#Basic_use_of_pointers\"\u003e用于\u003c/a\u003e其方法也是原生的类。\u003c/li\u003e\n\u003cli\u003eCUnion 将使用与 C 中的 \u003ccode\u003eunion\u003c/code\u003e 相同的表示形式; 看一下\u003ca href=\"https://docs.raku.org/language/nativecall#CUnions\"\u003e这个例子\u003c/a\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e另一方面，P6opaque 是用于 Raku 中所有对象的默认表示。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eThar\u003c/span\u003e \u003cspan class=\"p\"\u003e{};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"n\"\u003eThar\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eREPR\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e    \u003cspan class=\"c1\"\u003e#OUTPUT: «P6opaque␤» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e除非另有说明，否则\u003ca href=\"https://docs.raku.org/language/mop\"\u003e元对象协议\u003c/a\u003e默认对每个对象和类使用它;因此，除非您有效地使用该接口，否则通常没有必要。\u003c/p\u003e\n\u003ch2 id=\"is-作用于例程httpsdocsrakuorglanguagetraits___top\"\u003e\u003ca href=\"https://docs.raku.org/language/traits#___top\"\u003e\u003ccode\u003eis\u003c/code\u003e 作用于例程\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eis\u003c/code\u003e trait 可用于定义方法和例程以建立\u003ca href=\"https://docs.raku.org/language/functions#Precedence\"\u003e优先级\u003c/a\u003e和\u003ca href=\"https://docs.raku.org/language/functions#Associativity\"\u003e关联性\u003c/a\u003e。它们充当使用 \u003ca href=\"https://docs.raku.org/type/Sub#Traits\"\u003etrait_mod\u003c/a\u003e 定义的子元素，该元素将要添加的 trait 的类型和名称作为参数。在子例程的情况下，trait 将是添加跨越类和角色层次结构的功能的一种方式，或者甚至可以用于向独立定义的例程添加行为。s\u003c/p\u003e\n","text":"在 Raku 中，traits是附加到对象和类的编译器钩子，它们修改了类和对象的默认行为，功能或表示。作为这样的编译器钩子，它们是在编译时定义的，尽管它们可以用于运行时。\n通过使用 trait_mod 关键字，已经将几个 traits 定义为语言或 Rakudo 编译器的一部分。接下来列出并解释它们。\nis trait 定义为\nproto sub trait_mod:\u0026lt;is\u0026gt;(Mu $, |) {*} is 适用于任何类型的标量对象，并且可以接收任意数量的命名参数或位置参数。它是最常用的 trait，取决于第一个参数的类型，采用以下形式。\nis 应用于类 最常见的形式涉及两个类，一个正在定义，另一个现有，定义为 defines parenthood。 A is B, 如果两个都是类，则将 A 定义为 B 的子类。\nis DEPRECATED 可以应用于类，属性或例程，将它们标记为已弃用并发出警告消息（如果提供了的话）。\nis 的几个实例被直接转换为它们引用的类的属性：rw，nativesize，ctype，unsigned，hidden，array_type。\n不可实例化的表示 trait 与表示没有多大关系，与特定类可以做什么有关; 它有效地防止以任何可能的方式创建类的实例。\nconstant @IMM = \u0026lt;Innie Minnie Moe\u0026gt;; class don\u0026#39;t-instantiate is repr(\u0026#39;Uninstantiable\u0026#39;) { my $.counter; method imm () { return @IMM[ $.counter++ mod @IMM.elems ]; } } say don\u0026#39;t-instantiate.imm for ^10; 不能实例化的类仍然可以通过它们的类变量和方法使用, 如上所示。尝试这样: my $do-instantiate = don't-instantiate.new; 来实例化它们会产生错误。\nis repr 和原生表示 由于 is trait 通常指的是它们所应用的类或对象的性质，因此它们在原生调用中被广泛使用，以指定将由原生函数通过 is repr 后缀处理的数据结构的表示。同时，is native 用于通过原生函数实际实现的例程。这些是可以使用的表示：\nCStruct 对应于 C 语言中的 struct。它是一种复合数据结构，包括不同的异构和低级数据结构;请参阅此示例和进一步说明。 类似地，CPPStruct 对应于 C++ 中的 struct。但是，这是暂时是 Rakudo 特定的。 CPointer 是任何这些语言的指针。它是一个动态数据结构，必须在使用之前进行实例化，可用于其方法也是原生的类。 CUnion 将使用与 C 中的 union 相同的表示形式; 看一下这个例子。 另一方面，P6opaque 是用于 Raku 中所有对象的默认表示。\nclass Thar {}; say Thar.REPR; #OUTPUT: «P6opaque␤» 除非另有说明，否则元对象协议默认对每个对象和类使用它;因此，除非您有效地使用该接口，否则通常没有必要。\nis 作用于例程 is trait 可用于定义方法和例程以建立优先级和关联性。它们充当使用 trait_mod 定义的子元素，该元素将要添加的 trait 的类型和名称作为参数。在子例程的情况下，trait 将是添加跨越类和角色层次结构的功能的一种方式，或者甚至可以用于向独立定义的例程添加行为。s\n"},"name":"Traits","published":"2018-12-11T21:13:31+08:00","summary":"在 Raku 中，traits是附加到对象和类的编译器钩子，它们修改了类和对象的默认行为，功能或表示。作为这样的编译器钩子，它们是在编译时定义的，尽管它们可以用于运行时。\n通过使用 trait_mod 关键字，已经将几个 traits 定义为语言或 Rakudo 编译器的一部分。接下来列出并解释它们。\nis trait 定义为\nproto sub trait_mod:\u0026lt;is\u0026gt;(Mu $, |) {*} is 适用于任何类型的标量对象，并且可以接收任意数量的命名参数或位置参数。它是最常用的 trait，取决于第一个参数的类型，采用以下形式。\nis 应用于类 最常见的形式涉及两个类，一个正在定义，另一个现有，定义为 defines parenthood。 A is B, 如果两个都是类，则将 A 定义为 B 的子类。\nis DEPRECATED 可以应用于类，属性或例程，将它们标记为已弃用并发出警告消息（如果提供了的话）。\nis 的几个实例被直接转换为它们引用的类的属性：rw，nativesize，ctype，unsigned，hidden，array_type。\n不可实例化的表示 trait 与表示没有多大关系，与特定类可以做什么有关; 它有效地防止以任何可能的方式创建类的实例。\nconstant @IMM = \u0026lt;Innie Minnie Moe\u0026gt;; class don\u0026#39;t-instantiate is repr(\u0026#39;Uninstantiable\u0026#39;) { my $.counter; method imm () { return @IMM[ $.counter++ mod @IMM.elems ]; } } say don\u0026#39;t-instantiate.","type":"entry","url":"https://ohmycloud.github.io/posts/67.traits/"}