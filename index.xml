<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>
            
            
            焉知非鱼</title>
        <link>https://ohmyweekly.github.io/</link>
        <description>Recent content 
            on 焉知非鱼</description>
        <language>en-us</language>
        <lastBuildDate>Mon, 05 Apr 2021 19:55:25 +0800</lastBuildDate>
        <generator>Hugo -- gohugo.io</generator>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
            <atom:link href="https://ohmyweekly.github.io/index.xml" rel="self" type="application/rss&#43;xml" />
        
            
            <item>
                <title>Call Site Dependency Injection</title>
                <link>https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/</link>
                
                
                <description>&lt;blockquote&gt;Call Site Dependency Injection&lt;/blockquote&gt;&lt;p&gt;本帖文档调用站点依赖注入模式。这是一个相当低级的样本，和企业 DI 没有什么关系。这个模式有点 Rust 特有。&lt;/p&gt;
&lt;p&gt;通常，当你实现一个需要用户提供一些功能的类型时，首先想到的是在构造函数中提供它。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Engine&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;config&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;Config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;impl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Engine&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;config&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;Config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nc&#34;&gt;Engine&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;go&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这个例子中，我们实现了 Engine，调用者提供了 Config。&lt;/p&gt;
&lt;p&gt;另一种方法是将依赖关系传递给每个方法调用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Engine&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;impl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Engine&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nc&#34;&gt;Engine&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;go&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;config&lt;/span&gt;: &lt;span class=&#34;kp&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;Config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 Rust 中，后者(call-site injection)有时用 lifetime 更好。让我们来看看这些例子吧!&lt;/p&gt;
&lt;h2 id=&#34;lazy-字段&#34;&gt;Lazy 字段&lt;/h2&gt;
&lt;p&gt;在第一个例子中，我们想根据其他字段惰性地计算一个字段的值。就像这样:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Widget&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name_hash&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;Lazy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;u64&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;impl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Widget&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nc&#34;&gt;Widget&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Widget&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name_hash&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;Lazy&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;||&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;compute_hash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个设计的问题是在 Rust 中无法使用。Lazy 中的闭包需要访问 &lt;strong&gt;self&lt;/strong&gt;，而这将创建一个自引用的数据结构!&lt;/p&gt;
&lt;p&gt;解决的办法是在使用 Lazy 的地方提供闭包。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Widget&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name_hash&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;OnceCell&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;u64&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;impl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Widget&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nc&#34;&gt;Widget&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Widget&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name_hash&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;OnceCell&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;name_hash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;kt&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name_hash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_or_init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;||&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;compute_hash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;间接哈希表&#34;&gt;间接哈希表&lt;/h2&gt;
&lt;p&gt;下一个例子是关于将一个自定义的哈希函数插入到哈希表中。在 Rust 的标准库中，这只能在类型级别上实现，通过实现类型的 Hash 特性。更通用的设计是在运行时用哈希函数给表做参数。这是 &lt;code&gt;C++&lt;/code&gt; 所做的。然而在 Rust 中，这就不够通用了。&lt;/p&gt;
&lt;p&gt;考虑一个字符串互译器，它将字符串存储在一个向量中，并额外维护一个基于哈希的索引。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Interner&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;Vec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;HashSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;usize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;impl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Interner&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;intern&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;: &lt;span class=&#34;kp&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;kt&#34;&gt;usize&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;lookup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;: &lt;span class=&#34;kt&#34;&gt;usize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;kp&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;str&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;set&lt;/strong&gt; 字段将字符串存储在一个哈希表中，但它是用相邻 &lt;strong&gt;vec&lt;/strong&gt; 的索引来表示它们。&lt;/p&gt;
&lt;p&gt;用一个闭包来构造 &lt;strong&gt;set&lt;/strong&gt; 不会成功，原因和 Lazy 一样 - 这将创建一个自引用结构。在 &lt;code&gt;C++&lt;/code&gt; 中，存在一个变通的方法 - 可以将 &lt;strong&gt;vec&lt;/strong&gt; 装箱，并在 &lt;strong&gt;Interner&lt;/strong&gt; 和闭包之间共享一个稳定的指针。在 Rust 中，这会产生别名，阻止使用 &lt;strong&gt;&amp;amp;mut Vec&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;奇怪的是，在 std API 中，使用排序的 vec 而不是哈希是可行的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Interner&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;Vec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Invariant: sorted
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;Vec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;usize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;impl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Interner&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;intern&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;: &lt;span class=&#34;kp&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;kt&#34;&gt;usize&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;binary_search_by&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cmp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Ok&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to_string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;lookup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;: &lt;span class=&#34;kt&#34;&gt;usize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;kp&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;str&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是因为闭包是在调用站点而不是在构造站点供给的。&lt;/p&gt;
&lt;p&gt;hashbrown crate 通过 &lt;a href=&#34;https://docs.rs/hashbrown/0.9.1/hashbrown/hash_map/struct.HashMap.html#method.raw_entry_mut&#34;&gt;RawEntry&lt;/a&gt; 为哈希提供了这种风格的 API。&lt;/p&gt;
&lt;h2 id=&#34;per-容器分配器&#34;&gt;Per 容器分配器&lt;/h2&gt;
&lt;p&gt;第三个例子来自 Zig 编程语言。与 Rust 不同，Zig 没有一个祝福的全局分配器。相反，Zig 中的容器有两种风味。&amp;ldquo;Managed&amp;rdquo; 风味接受一个分配器作为构造参数，并将其存储为一个字段（&lt;a href=&#34;https://github.com/ziglang/zig/blob/1590ed9d6aea95e5a21e3455e8edba4cdb374f2c/lib/std/array_list.zig#L36-L43&#34;&gt;Source&lt;/a&gt;）。而 &amp;ldquo;Unmanaged&amp;rdquo; 风味则在每个方法中添加一个分配器参数（&lt;a href=&#34;https://github.com/ziglang/zig/blob/1590ed9d6aea95e5a21e3455e8edba4cdb374f2c/lib/std/array_list.zig#L436-L440&#34;&gt;Source&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;第二种方式更节俭 - 可以用一个分配器引用与许多容器。&lt;/p&gt;
&lt;h2 id=&#34;胖指针&#34;&gt;胖指针&lt;/h2&gt;
&lt;p&gt;最后一个例子来自于 Rust 语言本身。为了实现动态调度，Rust 使用了胖指针，它有两个字宽。第一个字指向对象，第二个字指向 vtable。这些指针是在泛用具体类型的时候制造的。&lt;/p&gt;
&lt;p&gt;这与 &lt;code&gt;C++&lt;/code&gt; 不同，&lt;code&gt;C++&lt;/code&gt; 的 vtable 指针是在构造过程中嵌入到对象本身中的。&lt;/p&gt;
&lt;p&gt;看了这些例子后，我对 Scala 式的隐式参数很热衷。考虑一下这段带有 Zig 风格向量的 Rust 代码的假设。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_allocator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xs&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Vec&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ys&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Vec&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的问题是 Drop - 释放向量需要访问分配器，而如何提供一个分配器并不清楚。Zig 通过使用 defer 语句而不是 destructors 躲避了这个问题。在使用隐式参数的 Rust 中，我想下面的方法可以用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;impl&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;implicit&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;: &lt;span class=&#34;kp&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Allocator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Drop&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Vec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，我想分享最后一个例子，CSDI 思维帮助我发现了一个更好的应用级架构。&lt;/p&gt;
&lt;p&gt;rust-analyzer 的很多行为是可以配置的。有嵌套提示的切换，完成度可以调整，一些功能根据编辑器的不同而有不同的工作方式。第一个实现是将一个全局的 Config 结构和其他分析状态一起存储。然后各个子系统读取这个 Config 的位。为了避免通过这个共享结构将不同的功能耦合在一起，配置键是动态的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Config&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个系统是可行的，但感觉相当笨拙。&lt;/p&gt;
&lt;p&gt;现在的实现要简单得多。现在每个方法都接受一个特定的 config 参数，而不是将一个单一的 Config 作为状态的一部分来存储。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_completions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;analysis&lt;/span&gt;: &lt;span class=&#34;kp&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;Analysis&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;config&lt;/span&gt;: &lt;span class=&#34;kp&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;CompletionConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;FileId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt;: &lt;span class=&#34;kt&#34;&gt;usize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_inlay_hints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;analysis&lt;/span&gt;: &lt;span class=&#34;kp&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;Analysis&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;config&lt;/span&gt;: &lt;span class=&#34;kp&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;HintsConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;FileId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不仅代码更简单，而且更灵活。因为配置不再是状态的一部分，所以可以根据上下文的不同，对同一功能使用不同的配置。例如，显式调用的完成和异步的完成可能是不同的。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&#34;https://old.reddit.com/r/rust/comments/kmd41e/blog_post_call_site_dependency_injection/&#34;&gt;/r/rust&lt;/a&gt; 上讨论。&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&#34;https://matklad.github.io/2020/12/28/csdi.html&#34;&gt;https://matklad.github.io/2020/12/28/csdi.html&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/rust">Rust</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/rust">Rust</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/</guid>
                <pubDate>Mon, 05 Apr 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>For the Love of Macros</title>
                <link>https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/</link>
                
                
                <description>&lt;blockquote&gt;For the Love of Macros&lt;/blockquote&gt;&lt;p&gt;我一直在重读 Ted Kaminski 关于软件设计的博客。我强烈推荐所有的文章，尤其是早期的文章（这是&lt;a href=&#34;https://www.tedinski.com/2018/01/16/how-humans-write-programs.html&#34;&gt;第一篇&lt;/a&gt;）。他设法提供了既不平凡又合理的设计建议（当然是主观判断），这是一个难得的标本!&lt;/p&gt;
&lt;p&gt;无论如何，这一系列的见解之一是，当设计一个抽象的概念时，我们总是要面对权力和属性之间的内在权衡。我们使用一个特定的抽象能表达的越多，我们对使用它的代码能说的就越少。然而，我们人类对更多表达能力的偏爱并非与生俱来。这一点在编程语言社区中很明显，用户不停地要求提供新功能，而语言设计者却说不。&lt;/p&gt;
&lt;p&gt;宏是一个在 &amp;ldquo;更强大&amp;quot;方面走得很远的语言功能。宏给了你一种在源代码上抽象的能力。作为交换，你放弃了（自动）推理表面语法的能力。作为一个具体的&lt;a href=&#34;https://rust-analyzer.github.io/blog/2020/03/30/macros-vs-rename.html&#34;&gt;例子&lt;/a&gt;，重命名重构在具有强大宏系统的语言中并不能 100% 可靠地工作。&lt;/p&gt;
&lt;p&gt;我确实认为，在理想的世界里，对于一个想要扩展到巨大项目的语言来说，这是一个错误的交易。当你增加了更多的程序员、更多的年限和更多的数百万行代码时，自动推理和转换源代码的能力就会变得越来越重要。但是，请谨慎对待这一点 - 我显然是有偏见的，因为我花了几年时间开发 Rust IDE。&lt;/p&gt;
&lt;p&gt;也就是说，宏有巨大的吸引力 - 它们是语言设计师的胶带。宏很少是最好的工具，但它们几乎可以完成任何工作。语言设计是渐进式的。宏系统通过为许多功能提供一个现成的穷人的替代品来缓解设计压力。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我想探讨一下 Rust 中宏的用途。目的是为了找到不放弃&amp;quot;推理源代码&amp;quot;属性的解决方案。&lt;/p&gt;
&lt;h2 id=&#34;字符串插值&#34;&gt;字符串插值&lt;/h2&gt;
&lt;p&gt;到目前为止，最常见的使用情况是 &lt;code&gt;format!&lt;/code&gt; 系列的宏。这里的无宏解决方案很直接 - 字符串插值语法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;number&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;||&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;92&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;$key: ${values()}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;assert_eq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to_string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;number: 92&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 Rust 中，插值可能不应该直接构造一个字符串，而是可以产生一个实现 Display 的值（就像 &lt;code&gt;format_args!&lt;/code&gt; 一样），这样可以避免分配。一个有趣的扩展是允许在格式字符串片段上迭代。这样一来，插值语法就可以用于 SQL 语句或命令行参数之类的东西，而不用担心引入注入漏洞。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;my dir&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ls $arg&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to_cmd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;assert_eq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to_string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ls &amp;#39;my dir&amp;#39;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://julialang.org/blog/2012/03/shelling-out-sucks/&#34;&gt;这篇&lt;/a&gt;关于 Julia 编程语言的文章解释了这个问题。 &lt;a href=&#34;https://github.com/matklad/xshell&#34;&gt;xshell&lt;/a&gt; crate 为 Rust 实现了这个想法。&lt;/p&gt;
&lt;h2 id=&#34;derives&#34;&gt;Derives&lt;/h2&gt;
&lt;p&gt;我认为在 Rust 中，宏的第二个最常见，也可能是最重要的用法是派生。Rust 是为数不多的能正确实现平等的语言之一（禁止比较苹果和橘子），但这关键取决于 &lt;code&gt;derive(Eq)&lt;/code&gt; 的能力。这个领域常见的解决方案是编译器中的特殊 casing（Haskell 的派生）或运行时反射。&lt;/p&gt;
&lt;p&gt;但我最感兴趣的解决方案是 &lt;code&gt;C#&lt;/code&gt; &lt;a href=&#34;https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/&#34;&gt;源码生成器&lt;/a&gt;。这并不是什么新鲜事 - 这只是老式的（源码）代码生成器，只是具有很好的实现质量。你可以提供自定义的代码，这些代码在构建过程中被运行，它可以读取现有的源码并生成额外的文件，然后再添加到编译中。&lt;/p&gt;
&lt;p&gt;这个解决方案的优点在于它将所有的复杂性从语言中移出，移到了编译系统中。这意味着你可以免费获得基线工具支持。生成代码的 Goto 定义？就能用了。调试时想介入一些序列化代码？磁盘上有实际的源码，所以可以放心的去做! 你是比较喜欢用 &lt;code&gt;printf&lt;/code&gt; 的人？好吧，你需要说服构建系统不要踩过你的改动，但是，否则，为什么不呢？&lt;/p&gt;
&lt;p&gt;此外，源码生成器的表现力明显更强。它们可以调用到 Roslyn 编译器来分析源代码，所以它们能够生成类型导向的代码。&lt;/p&gt;
&lt;p&gt;为了有用，源码生成器需要一些语言级别的支持，以便将一个实体分割到多个文件中。在 &lt;code&gt;C#&lt;/code&gt; 中，部分类就扮演了这个角色。&lt;/p&gt;
&lt;h2 id=&#34;特定领域语言&#34;&gt;特定领域语言&lt;/h2&gt;
&lt;p&gt;宏的存在理由是嵌入式 DSL 的实现。我们希望在语言中引入自定义语法，以简洁地对程序的领域进行建模。例如，可以用宏来嵌入 Rust 代码中的 HTML 片段。&lt;/p&gt;
&lt;p&gt;对我个人来说，eDSL 不是要解决的问题，只是一个问题。引入一个新的子语言（即使是小的）会花费大量的认知复杂性预算。如果你偶尔需要它，最好坚持只把有点啰嗦的函数调用链在一起。如果你经常需要它，引入外部的 DSL 是有意义的，它有一个编译器，一个语言服务器，以及所有使编程富有成效的工具。对我来说，基于宏的 DSL 只是在成本效益曲线上不落像一个有趣的点。&lt;/p&gt;
&lt;p&gt;也就是说，Kotlin 编程语言很好地解决了强类型化、工具友好型 DSL 的问题（例子）。令人气愤的是，很难指出具体的解决方案是什么。就是&amp;hellip;&amp;hellip;主要是具体的语法。下面是一些成分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;闭包的语法是 &lt;code&gt;{ arg -&amp;gt; body }&lt;/code&gt;，或者直接是 &lt;code&gt;{ body }&lt;/code&gt;，所以闭包在语法上类似于块。&lt;/li&gt;
&lt;li&gt;扩展方法（这只是静态方法的语法糖）。&lt;/li&gt;
&lt;li&gt;Java 风格的隐式 this，它将名称引入到作用域中，而不需要显式声明。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boats.gitlab.io/blog/post/the-problem-of-effects/&#34;&gt;TCP-preserving&lt;/a&gt; inline closures (这是唯一一个非语法特征)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管如此，这还不足以实现 Jetpack Compose UI DSL，它还需要一个编译器插件。&lt;/p&gt;
&lt;h2 id=&#34;sqlx&#34;&gt;sqlx&lt;/h2&gt;
&lt;p&gt;我想调用的一个有趣的 DSL 案例是 &lt;a href=&#34;https://docs.rs/sqlx/0.5.1/sqlx/macro.query.html&#34;&gt;sqlx::query&lt;/a&gt;。它允许我们写这样的代码。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;account&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sqlx&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;select (1) as id, &amp;#39;Herp Derpinson&amp;#39; as name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fetch_one&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;await&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// anonymous struct has `#[derive(Debug)]` for convenience
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;{:?}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;account&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;{}: {}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;account&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;account&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这一点我想是eDSL确实很拉风的几个案例之一。没有宏的情况下，我不知道该怎么做。使用字符串插值（高级版本，以保护不被注入），可以指定查询。使用源码生成器，可以检查查询的语法和类型，例如，在这种情况下，会出现类型错误。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;: &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;f32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;select (1) as id, &amp;#39;Herp Derpinson&amp;#39; as name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fetch_one&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;await&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但这还不足以生成一个匿名结构体，也不足以摆脱动态 casts。&lt;/p&gt;
&lt;h2 id=&#34;有条件编译&#34;&gt;有条件编译&lt;/h2&gt;
&lt;p&gt;Rust 还使用宏进行条件编译。这个用例令人信服地展示了&amp;quot;缺乏属性&amp;quot;方面的能力。处理特征组合是 Cargo 永远头痛的问题。当特征标志改变时，用户不得不反复重新编译大块的装箱图。在 CI 上用 &lt;code&gt;Cargo test --no-default-features&lt;/code&gt; 捕捉类型错误是非常恼人的，尤其是当你在提交 PR 之前确实运行了 &lt;code&gt;Cargo test&lt;/code&gt;。&amp;ldquo;添加特性&amp;quot;是一个无法选中的一厢情愿。&lt;/p&gt;
&lt;p&gt;在这种情况下，我不知道有什么好的无宏选择。但是，原则上，这似乎是可行的，如果将条件编译进一步推到编译器流水线的下游，推到代码生成和链接阶段。编译器可以在为一个函数生成机器代码之前，选择特定平台的版本，而不是在解析过程中提前丢弃一些代码。在此之前，它会检查该函数的所有条件编译版本是否具有相同的接口。这样一来，平台特定的类型错误就不可能出现了。&lt;/p&gt;
&lt;h2 id=&#34;占位符语法&#34;&gt;占位符语法&lt;/h2&gt;
&lt;p&gt;最后一个我想介绍的用例是占位符语法。Rust 的 &lt;code&gt;macro_call!(...)&lt;/code&gt; 语法开辟了一个很好的隔离区域，只要小括号是平衡的，任何东西都可以用。理论上，这允许语言设计者在确定某些东西之前先试验临时语法。在实践中，这看起来好像并没有什么好处？有人反对稳定 &lt;code&gt;postfix .await&lt;/code&gt;，而不通过中间期与 &lt;code&gt;await!&lt;/code&gt; 宏来稳定。而且，稳定之后，所有的语法讨论都立即被遗忘了？另一方面，我们确实有 &lt;code&gt;try! -&amp;gt; ?&lt;/code&gt; 转变，但我不认为它有助于发现任何设计上的缺陷？至少，我们成功地稳定了那个&lt;a href=&#34;https://internals.rust-lang.org/t/can-try-and-use-the-into-trait-instead-of-from/6714&#34;&gt;不必要的限制性&lt;/a&gt;去语法糖。&lt;/p&gt;
&lt;p&gt;对于结论，我想绕回源码生成器。究竟是什么让它们比宏更容易被工具化？我认为有以下三个特性。第一，无论是输入还是输出，从根本上说，都是文本。没有中间的表示方式（比如 token 树），而这个元程序设施使用的是中间的表示方式。这意味着，它不需要与编译器深度集成。当然，在内部，该工具可以自由地对代码进行任意解析、类型检查和转换。其次，有一个阶段性的区分。源码生成器是一次执行，无序的。在元编程和名称解析之间没有来回，这又可以将&amp;quot;元&amp;quot;的部分保留在外面。第三，源码生成器只能添加代码，不能改变现有代码的含义。这意味着，在代码生成器的存在下，语义上合理的源码转换依然如此。&lt;/p&gt;
&lt;p&gt;就这样吧! 在 &lt;a href=&#34;https://old.reddit.com/r/rust/comments/ljnkwg/blog_post_for_the_love_of_macros/&#34;&gt;/r/rust&lt;/a&gt; 上讨论。&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&#34;https://matklad.github.io/2021/02/14/for-the-love-of-macros.html&#34;&gt;https://matklad.github.io/2021/02/14/for-the-love-of-macros.html&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/rustlang">rustlang</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/rust">Rust</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/</guid>
                <pubDate>Mon, 05 Apr 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>Psql</title>
                <link>https://ohmyweekly.github.io/notes/2021-04-05-psql/</link>
                
                
                <description>&lt;blockquote&gt;Psql&lt;/blockquote&gt;&lt;h1 id=&#34;raku-与-postgresql-的连接性一览&#34;&gt;Raku 与 PostgreSQL 的连接性一览&lt;/h1&gt;
&lt;p&gt;在我看来，Raku 是一门伟大的语言，我每天都在使用它，而且越来越多。我可以说它将取代我的 Perl 脚本。&lt;/p&gt;
&lt;p&gt;Raku 有一个广泛的模块库，当然包括数据库连接，这反过来又包括连接 PostgreSQL 的功能。
在这篇简单的文章中，我将快速演示如何使用 Raku 的一段代码来完成许多比数据库应用程序还琐碎的任务。
脚本是以增量的方式呈现的，所以连接数据库部分必须始终作为脚本的前言。&lt;/p&gt;
&lt;p&gt;DB::Pg 模块在某种程度上与 Perl 5 的 DBD::Pg 很相似，所以很多概念和方法名都会让人想起后者。&lt;/p&gt;
&lt;h2 id=&#34;安装方法&#34;&gt;安装方法&lt;/h2&gt;
&lt;p&gt;可以使用 zef 来安装 DB::Pg 模块。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;% zef install DB::Pg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据你的系统速度和已经安装的库，可能需要几分钟的时间。&lt;/p&gt;
&lt;p&gt;如果你要使用 LISTEN/NOTIFY，你需要同时安装 epoLl.NET 和 EPOLl.NET。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;% zef install epoll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;连接到数据库&#34;&gt;连接到数据库&lt;/h2&gt;
&lt;p&gt;现在可以使用 DB::Pg 模块连接到数据库。例如，一个简单的脚本可以接受命令行上的所有参数（清晰的文本！），可以是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;#!raku

use DB::Pg;

sub MAIN( Str :$host = &#39;miguel&#39;,
          Str :$username = &#39;luca&#39;,
          Str :$password = &#39;secet&#39;,
          Str :$database = &#39;testdb&#39; ) {

    &amp;quot;Connecting $username @ $host/$database&amp;quot;.say;

    my $connection = DB::Pg.new: conninfo =&amp;gt; &amp;quot;host=$host user=$username password=$password dbname=$database&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如你所见，DB::Pg模块接受一个 conninfo 字符串。&lt;/p&gt;
&lt;h2 id=&#34;读取查询和结果&#34;&gt;读取查询和结果&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.query&lt;/code&gt; 方法允许向数据库发出读取查询。结果是一个 Result 类对象，它可以通过不同的方法来使用，最著名的是 &lt;code&gt;.hash&lt;/code&gt; 和 &lt;code&gt;.arrays&lt;/code&gt;，它们返回一连串的 hash 或 arrays，从查询中提取的每一行都有一个 &lt;code&gt;.rows&lt;/code&gt; 和 &lt;code&gt;.column&lt;/code&gt; 等特殊方法分别提供了查询返回的行数和结果集的列名。&lt;/p&gt;
&lt;p&gt;举个例子，这里是一个简单的查询。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my $query = &#39;SELECT current_role, current_time&#39;;
my $results = $connection.query: $query;

say &amp;quot;The query { $query } returned { $results.rows } rows with columns: { $results.columns.join( &#39;, &#39; ) }&amp;quot;;
for $results.hashes -&amp;gt; $row {
    for $row.kv -&amp;gt; $column, $value {
        say &amp;quot;Column $column = $value&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这段代码提供了一个类似于下面的输出。&lt;/p&gt;
&lt;p&gt;查询 &lt;code&gt;SELECT current_role, current_time&lt;/code&gt; 返回1行，列数为： current_role, current_time。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Column current_role = luca
Column current_time = 14:48:47.147983+02
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;光标&#34;&gt;光标&lt;/h2&gt;
&lt;p&gt;默认情况下，&lt;code&gt;.query&lt;/code&gt; 方法将从查询中获取所有的行，这对于较大的数据集来说是一个问题。可以使用 &lt;code&gt;.cursor&lt;/code&gt; 方法，它可以接受可选的批量大小（默认为1000个元组），并可选地接受将结果获取为哈希序列的指定器。&lt;/p&gt;
&lt;p&gt;作为一个简单的例子。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;for $connection.cursor( &#39;select * from raku&#39;, fetch =&amp;gt; 2, :hash ) -&amp;gt; %row {
    say &amp;quot;====================&amp;quot;;
    for %row.kv -&amp;gt; $column, $value {
        say &amp;quot;Column [ $column ] = $value&amp;quot;;
    }
    say &amp;quot;====================&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;产生和输出像这样的东西。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;====================
Column [ pk ] = 2
Column [ t ] = This is value 0
====================
====================
Column [ pk ] = 3
Column [ t ] = This is value 1
====================
====================
Column [ t ] = This is value 2
Column [ pk ] = 4
====================
====================
Column [ pk ] = 5
Column [ t ] = This is value 3
====================
...
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;撰写声明&#34;&gt;撰写声明&lt;/h2&gt;
&lt;p&gt;编写语句可以通过 &lt;code&gt;.execute&lt;/code&gt; 方法来执行，如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;$connection.execute: q&amp;lt; insert into raku( t ) values( &#39;Hello World&#39; )&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;交易和编制报表&#34;&gt;交易和编制报表&lt;/h2&gt;
&lt;p&gt;为了处理事务，你需要访问被&amp;quot;屏蔽&amp;quot;到 DB::Pg 主对象中的数据库处理程序。数据库对象像往常一样提供了 &lt;code&gt;.begin&lt;/code&gt;、&lt;code&gt;.rollback&lt;/code&gt;、&lt;code&gt;.commit&lt;/code&gt;等方法。&lt;/p&gt;
&lt;p&gt;此外，还可以使用 &lt;code&gt;.prepare&lt;/code&gt; 方法来获得一个已准备好的语句，该语句可以被缓存并用于循环和重复性任务中。值得注意的是，&lt;code&gt;.prepare&lt;/code&gt; 方法使用了 &lt;code&gt;$1&lt;/code&gt;、&lt;code&gt;$2&lt;/code&gt; 等参数占位符，当语句接受单个值时，必须在 &lt;code&gt;.execute&lt;/code&gt; 中不指定索引。&lt;/p&gt;
&lt;p&gt;举个例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my $database-handler = $connection.db;
my $statement = $database-handler.prepare: &#39;insert into raku( t ) values( $1 )&#39;;

$database-handler.begin;
$statement.execute( &amp;quot;This is value $_&amp;quot; )  for 0 .. 10;
$database-handler.commit;
$database-handler.finish;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述循环相当于一个SQL事务，如:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;k&#34;&gt;BEGIN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;INSERT&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;INTO&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;raku&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;This is value 0&amp;#39;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;INSERT&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;INTO&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;raku&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;This is value 1&amp;#39;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;INSERT&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;INTO&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;raku&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;This is value 2&amp;#39;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;INSERT&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;INTO&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;raku&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;This is value 10&amp;#39;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;COMMIT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;.finish&lt;/code&gt; 方法是必需的，因为 DB::Pg 处理缓存。请注意，&lt;code&gt;.commit&lt;/code&gt; 和 &lt;code&gt;.rollback&lt;/code&gt; 方法是流畅的，并返回一个对象实例，这样你就可以调用 &lt;code&gt;.commit.finish&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;数据库与连接&#34;&gt;数据库与连接&lt;/h2&gt;
&lt;p&gt;缓存的处理方式是，当发出一个查询时，会打开一个新的连接并使用。一旦工作完成，连接就会返回到内部池中。DB::Pg::Database 对象做的工作和 DB::Pg 的一样，不同的是它不会自动将连接返回到池中，所以需要自己进行 &lt;code&gt;.&lt;/code&gt; 完成。&lt;/p&gt;
&lt;p&gt;因此，你可以在两个对象上使用相同的 &lt;code&gt;.query&lt;/code&gt; 和 &lt;code&gt;.execute&lt;/code&gt; 方法，但 DB::Pg 会自动将连接返回到内部池中，而数据库对象则允许你对何时将连接返回到池中进行细粒度的控制。&lt;/p&gt;
&lt;h2 id=&#34;复制&#34;&gt;复制&lt;/h2&gt;
&lt;p&gt;PostgreSQL 提供了特殊的 COPY 命令，可以用来复制从和进入。有一个方法 &lt;code&gt;.copy-in&lt;/code&gt; 可以执行 &lt;code&gt;COPY FROM&lt;/code&gt;，而 &lt;code&gt;COPY TO&lt;/code&gt; 可以在迭代循环中使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my $file = &#39;/tmp/raku.csv&#39;.IO.open: :w;
for $connection.query: &#39;COPY raku TO stdout (FORMAT CSV)&#39;  -&amp;gt; $row {
    $file.print: $row;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上将 CSV 结果导出到文本文件上。
如果要读回数据，可以发出 &lt;code&gt;.copy-in&lt;/code&gt; 方法，但首先需要发出 &lt;code&gt;SQL COPY&lt;/code&gt;。工作流程是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;issue a COPY FROM STDIN;
use .copy-data to slurp all the data;
use .copy-end to notify the database that the COPY is concluded.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对.copy-end的需求是一个建议：可以在一次运行中发出不同的.copy-data，例如从不同文件中导入数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;$database-handler = $connection.db;
$database-handler.query: &#39;COPY raku FROM STDIN (FORMAT CSV)&#39;;
$database-handler.copy-data:  &#39;/tmp/raku1.csv&#39;.IO.slurp;
$database-handler.copy-data:  &#39;/tmp/raku2.csv&#39;.IO.slurp;
$database-handler.copy-end;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;转换器&#34;&gt;转换器&lt;/h2&gt;
&lt;p&gt;可以指定转换器，即处理进出数据库的值的特殊角色；这让我想起了 DBI::Class 的 &lt;code&gt;inflate&lt;/code&gt; 和 &lt;code&gt;deflate&lt;/code&gt; 选项。
第一步是在 &lt;code&gt;DB::Pg&lt;/code&gt; 中给转换器实例添加一个角色，这样的实例必须。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加一个新的类型转换方法。&lt;/li&gt;
&lt;li&gt;增加一个转换方法来处理类型字符串化的值，并返回新值（在任何 Raku 实例中）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为一个例子，下面将一个文本 PostgreSQL 类型转换为一个 Str Raku 对象，并在其内容上进行反转。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;$connection.converter does role fluca-converter
{
    submethod BUILD { self.add-type( text =&amp;gt; Str ) }
    multi method convert( Str:U, Str:D $value) {
        $value.flip.uc;
    }

}

.say for $connection.query( &#39;select * from raku&#39; ).arrays;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;产生类似于的输出。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[442 DLROW OLLEH]
[454 DLROW OLLEH]
[466 DLROW OLLEH]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中字符串 Hello World 被翻转。&lt;/p&gt;
&lt;h2 id=&#34;listen-和-notify&#34;&gt;listen 和 notify&lt;/h2&gt;
&lt;p&gt;DB::Pg也可以处理LISTEN和NOTIFY，它们能够与Raku的react动态功能进行交互。
首先，创建一个简单的机制来通知一些事件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;testdb=&amp;gt; create or replace rule r_raku_insert 
         as on insert to raku 
         do also 
         SELECT pg_notify( &#39;insert_event&#39;, &#39;INSERTING ROW(S)&#39; );
CREATE RULE

testdb=&amp;gt; create or replace rule r_raku_delete
         as on delete to raku 
         do also 
         SELECT pg_notify( &#39;delete_event&#39;, &#39;DELETING ROW(S)&#39; );
CREATE RULE
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在，可以创建一个等待传入事件的 Raku 脚本。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;react {
    whenever $connection.listen( &#39;delete_event&#39; ) { .say; }
    whenever $connection.listen( &#39;insert_event&#39; ) { .say; }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;目的是，每次发出一个事件，&lt;code&gt;.listen&lt;/code&gt; 都会将消息有效载荷传递给 react 代码块。因此，发出一些 &lt;code&gt;DELETE&lt;/code&gt; 和 &lt;code&gt;INSERT&lt;/code&gt; 会导致输出。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DELETING ROW(S)
INSERTING ROW(S)
INSERTING ROW(S)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以通过 &lt;code&gt;.unlisten&lt;/code&gt; 方法停止监听反应块。也可以通过 &lt;code&gt;.notify&lt;/code&gt; 方法发出事件。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;DB::Pg 是 PostgreSQL 的一个很好的驱动程序，它允许 Raku 直接在语言中利用很多功能。&lt;/p&gt;
&lt;p&gt;文章 A glance at Raku connectivity towards PostgreSQL 已经由 Luca Ferrari 发布在博客上。&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&#34;https://fluca1978.github.io/2021/03/29/RakuPostgreSQL.html&#34;&gt;https://fluca1978.github.io/2021/03/29/RakuPostgreSQL.html&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/rakulang">rakulang</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-04-05-psql/</guid>
                <pubDate>Mon, 05 Apr 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>Std Error in Rust</title>
                <link>https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/</link>
                
                
                <description>&lt;blockquote&gt;Std Error in Rust&lt;/blockquote&gt;&lt;h1 id=&#34;学习-stdioerror&#34;&gt;学习 std::io::Error&lt;/h1&gt;
&lt;p&gt;在这篇文章中，我们将剖析 Rust 标准库中 std::io::Error 类型的实现。相关代码在这里：&lt;code&gt;library/std/src/io/error.rs&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你可以把这篇文章看成是其中之一。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个标准库的特定位的研究&lt;/li&gt;
&lt;li&gt;一个高级错误管理指南&lt;/li&gt;
&lt;li&gt;一个漂亮的 API 设计案例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文章要求基本熟悉 Rust 错误处理。&lt;/p&gt;
&lt;p&gt;在设计一个用于 &lt;code&gt;Result&amp;lt;T，E&amp;gt;&lt;/code&gt; 的 Error 类型时，主要的问题是&amp;quot;如何使用这个错误？&amp;quot;。通常，以下情况之一为真。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;错误被程序化处理。消费者检查错误，所以它的内部结构需要在合理的程度上暴露出来。&lt;/li&gt;
&lt;li&gt;错误被传播并显示给用户。消费者不检查 &lt;code&gt;fmt::Display&lt;/code&gt; 之外的错误；所以它的内部结构可以被封装。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，暴露实现细节和封装细节之间存在紧张关系。实现第一种情况的常见反模式是定义一个厨房水槽枚举。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;pub&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Tokio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tokio&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;io&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ConnectionDiscovery&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;PathBuf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reason&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stderr&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Deserialize&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;source&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;serde_json&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Generic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种方法有很多问题。&lt;/p&gt;
&lt;p&gt;首先，从底层库中暴露错误会使它们成为你的公共 API 的一部分。在你的依赖关系中的主要 semver bump 会要求你也做一个新的主要版本。&lt;/p&gt;
&lt;p&gt;其次，它将所有的实现细节都固定下来。例如，如果你注意到 ConnectionDiscovery 的大小是巨大的，那么将这个变体装箱将是一个突破性的变化。&lt;/p&gt;
&lt;p&gt;第三，它通常表明了一个更大的设计问题。厨房水槽错误将不同的故障模式打包成一种类型。但是，如果故障模式差异很大，处理起来可能就不合理了! 这说明情况看起来更像案例二。&lt;/p&gt;
&lt;p&gt;错误厨房水槽病的一个经常有效的治疗方法是将错误推送给调用者的模式。&lt;/p&gt;
&lt;p&gt;考虑这个例子:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;my_function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nb&#34;&gt;Result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MyError&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thing&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dep_function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Ok&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;92&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;my_function&lt;/code&gt; 调用 &lt;code&gt;dep_function&lt;/code&gt;，所以 &lt;code&gt;MyError&lt;/code&gt; 应该可以从 &lt;code&gt;DepError&lt;/code&gt; 转换过来。更好的写法可能是这样的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;my_function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thing&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;DepThing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nb&#34;&gt;Result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MyError&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Ok&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;92&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这个版本中，调用者被迫调用 &lt;code&gt;dep_function&lt;/code&gt; 并处理其错误。这就用更多的类型交换了更多的类型安全。&lt;code&gt;MyError&lt;/code&gt; 和 &lt;code&gt;DepError&lt;/code&gt; 现在是不同的类型，调用者可以分别处理它们。如果 &lt;code&gt;DepError&lt;/code&gt; 是 &lt;code&gt;MyError&lt;/code&gt; 的变体，那么就需要进行运行时匹配。&lt;/p&gt;
&lt;p&gt;这个想法的一个极端版本是 &lt;code&gt;sans-io&lt;/code&gt; 编程。大多数错误来自于 IO；如果你把所有的 IO 推给调用者，你就可以跳过大部分的错误处理。&lt;/p&gt;
&lt;p&gt;无论枚举方法多么糟糕，它确实实现了第一种情况的最大可检查性。&lt;/p&gt;
&lt;p&gt;以传播为中心的第二种情况下的错误管理，通常是通过使用盒状特质对象来处理。像 &lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt; 这样的类型可以从任何具体的错误中构造出来，可以通过 &lt;code&gt;Display&lt;/code&gt; 打印出来，并且仍然可以选择通过动态下传来暴露底层错误。&lt;code&gt;Anyhow&lt;/code&gt; crate 就是这种风格的一个很好的例子。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::io::Error&lt;/code&gt; 的例子很有趣，因为它想同时具备上述两种风格。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是 std，所以封装和面向未来是最重要的。&lt;/li&gt;
&lt;li&gt;来自操作系统的 IO 错误往往可以被处理（比如 EWOULDBLOCK）。&lt;/li&gt;
&lt;li&gt;对于系统编程语言来说，准确地暴露底层 OS 错误是很重要的。&lt;/li&gt;
&lt;li&gt;未来潜在的操作系统错误集是没有限制的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;io::Error&lt;/code&gt; 也是一种词汇类型，应该可以表示一些不完全的 os 错误。例如，Rust Paths 可以包含内部的0字节，打开这样的路径应该在进行 &lt;code&gt;syscall&lt;/code&gt; 之前返回一个 &lt;code&gt;io::Error&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是 &lt;code&gt;std::io::Error&lt;/code&gt; 的样子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;pub&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;repr&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;Repr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Repr&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Simple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ErrorKind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Custom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Custom&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Custom&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kind&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;ErrorKind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dyn&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Send&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Sync&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先要注意的是，它内部是一个枚举，但这是一个隐藏得很好的实现细节。为了允许检查和处理各种错误条件，有一个单独的公共无字段种类枚举。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#[derive(Clone, Copy)]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#[non_exhaustive]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;pub&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ErrorKind&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;NotFound&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PermissionDenied&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Interrupted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;impl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;pub&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nc&#34;&gt;ErrorKind&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;repr&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;decode_error_kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Custom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Simple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然 ErrorKind 和 Repr 都是枚举，但公开暴露 ErrorKind 就没那么可怕了。一个 &lt;code&gt;#[non_exhaustive]Copy&lt;/code&gt; 无字段枚举的设计空间是一个点 - 没有合理的替代方案或兼容性隐患。&lt;/p&gt;
&lt;p&gt;有些 &lt;code&gt;io::Errors&lt;/code&gt; 只是原始的操作系统错误代码。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;impl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;pub&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;from_raw_os_error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;: &lt;span class=&#34;kt&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nc&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;repr&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;pub&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;raw_os_error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nb&#34;&gt;Option&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;repr&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Some&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Custom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(..)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Simple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(..)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;特定平台的 &lt;code&gt;sys::decode_error_kind&lt;/code&gt; 函数负责将错误代码映射到 &lt;code&gt;ErrorKind&lt;/code&gt; 枚举。所有这些都意味着代码可以通过检查 &lt;code&gt;.kind()&lt;/code&gt; 来跨平台处理错误类别。然而，如果需要以一种依赖于操作系统的方式处理一个非常特殊的错误代码，这也是可能的。API 小心翼翼地提供了一个方便的抽象，而没有抽象掉重要的低级细节。&lt;/p&gt;
&lt;p&gt;一个 &lt;code&gt;std::io::Error&lt;/code&gt; 也可以从一个 &lt;code&gt;ErrorKind&lt;/code&gt; 中构造出来。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;impl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;From&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ErrorKind&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kind&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;ErrorKind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nc&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;repr&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Simple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这提供了跨平台访问错误代码风格的错误处理。如果你需要尽可能快的错误，这很方便。&lt;/p&gt;
&lt;p&gt;最后，还有第三种完全自定义的变体表示。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;impl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;pub&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kind&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;ErrorKind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nc&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;where&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;Into&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dyn&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Send&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Sync&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Self&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;_new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;into&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kind&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;ErrorKind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dyn&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Send&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Sync&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nc&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;repr&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Custom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Box&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Custom&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;pub&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_ref&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nb&#34;&gt;Option&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dyn&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Send&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Sync&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;&amp;#39;static&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;repr&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(..)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Simple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(..)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Custom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Some&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;pub&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;into_inner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nb&#34;&gt;Option&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dyn&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Send&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Sync&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;repr&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(..)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Simple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(..)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Custom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Some&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要注意的地方。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通用的 &lt;code&gt;new&lt;/code&gt; 函数委托给单态的 &lt;code&gt;_new&lt;/code&gt; 函数。这改善了编译时间，因为在单态化过程中需要重复的代码更少。我认为这也改善了一些运行时：&lt;code&gt;_new&lt;/code&gt; 函数没有被标记为内联，所以会在调用处产生一个函数调用。这是好的，因为错误构造是冷路径，节省指令缓存是受欢迎的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义变体被框住了 - 这是为了让整体 &lt;code&gt;size_of&lt;/code&gt; 更小。错误的 &lt;code&gt;on-the-stack&lt;/code&gt; 大小是很重要的：即使没有错误，你也要为此付出代价!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种类型都是指&amp;quot;静态错误&amp;quot;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dyn&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Send&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Sync&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;&amp;#39;static&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dyn&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Send&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Sync&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;dyn Trait + &#39;_&lt;/code&gt; 中，&lt;code&gt;&#39;_&lt;/code&gt; 被省略为 &lt;code&gt;&#39;static&lt;/code&gt;，除非 trait 对象是在引用后面，在这种情况下，它被省略为 &lt;code&gt;&amp;amp;&#39;a dyn Trait + &#39;a&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get_ref&lt;/code&gt;, &lt;code&gt;get_mut&lt;/code&gt; 和 &lt;code&gt;into_inner&lt;/code&gt; 提供了对底层错误的完全访问。类似于 &lt;code&gt;os_error&lt;/code&gt; 的情况，抽象模糊了细节，但也提供了钩子来获取底层数据的原样。&lt;/p&gt;
&lt;p&gt;同样，Display 的实现揭示了内部表示的最重要细节。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;impl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fmt&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Display&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fmt&lt;/span&gt;: &lt;span class=&#34;kp&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fmt&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Formatter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;&amp;#39;_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nc&#34;&gt;fmt&lt;/span&gt;::&lt;span class=&#34;nb&#34;&gt;Result&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;repr&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;detail&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;error_string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;{} (os error {})&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;detail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Simple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;{}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;as_str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Custom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;综上所述，std::io::Error:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封装了它的内部表现形式，并通过框定大的枚举变体来优化它。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;ErrorKind&lt;/code&gt; 模式提供了一种方便的方法来处理基于类别的错误。&lt;/li&gt;
&lt;li&gt;完全暴露底层操作系统的错误（如果有的话）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以透明地包裹任何其他错误类型。&lt;/p&gt;
&lt;p&gt;最后一点意味着 &lt;code&gt;io::Error&lt;/code&gt; 可以用于临时错误，因为 &lt;code&gt;&amp;amp;str&lt;/code&gt; 和 String 可以转换为 &lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;n&#34;&gt;io&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;io&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;ErrorKind&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;something went wrong&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它也可以作为 anyhow 的简单替换。我想一些库可能会用这个来简化他们的错误处理。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;n&#34;&gt;io&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;io&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;ErrorKind&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;InvalidData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_specific_error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例如，&lt;code&gt;serde_json&lt;/code&gt; 提供了以下方法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;from_reader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rdr&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nb&#34;&gt;Result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;serde_json&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;where&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;Read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;DeserializeOwned&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;读取会因为 &lt;code&gt;io::Error&lt;/code&gt; 而失败，所以 &lt;code&gt;serde_json::Error&lt;/code&gt; 需要能够在内部表示 &lt;code&gt;io::Error&lt;/code&gt;。我认为这是倒退的 (但我不知道整个上下文，如果被证明是错的我会很高兴！)，签名应该是这样的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;from_reader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rdr&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nb&#34;&gt;Result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;io&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;where&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;Read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;DeserializeOwned&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么，&lt;code&gt;serde_json::Error&lt;/code&gt; 就不会有 &lt;code&gt;Io&lt;/code&gt; 的变体，而会以 &lt;code&gt;InvalidData&lt;/code&gt; 的形式被藏到 &lt;code&gt;io::Error&lt;/code&gt; 中。
补遗, 2021-01-25&lt;/p&gt;
&lt;p&gt;重新阅读这篇文章，我现在认为正确的返回类型应该是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;from_reader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rdr&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nb&#34;&gt;Result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;serde_json&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;io&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;where&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;Read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;DeserializeOwned&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这迫使 IO 和反序列化错误分开处理，这在这种情况下是有意义的。IO 错误可能是程序领域之外的硬件/环境问题，而序列化错误很可能是系统中的某个错误。&lt;/p&gt;
&lt;p&gt;我认为 &lt;code&gt;std::io::Error&lt;/code&gt; 是一个非常了不起的类型，它能够在没有太多妥协的情况下为许多不同的用例服务。但我们是否可以做得更好呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::io::Error&lt;/code&gt; 的首要问题是，当一个文件系统操作失败时，你不知道它是为哪个路径失败的。这是可以理解的 - Rust 是一种系统语言，所以它不应该比 OS 原生提供的东西增加多少脂肪。OS 返回的是一个整数返回代码，而将其与一个堆分配的 &lt;code&gt;PathBuf&lt;/code&gt; 耦合在一起，可能是一个不可接受的开销!&lt;/p&gt;
&lt;p&gt;我很惊讶地得知，事实上，&lt;code&gt;std&lt;/code&gt; 对每一个与路径相关的系统调用都会进行分配。&lt;/p&gt;
&lt;p&gt;它需要以某种形式存在。&lt;code&gt;OS API&lt;/code&gt; 需要在字符串的结尾有一个不幸的零字节. 但我想知道对短路径使用堆栈分配的缓冲区是否有意义。可能不会 - 路径通常不会那么短，而且现代分配器能有效地处理瞬时分配。&lt;/p&gt;
&lt;p&gt;我不知道这里有什么明显的好办法。一个选择是在编译时（一旦我们得到 &lt;code&gt;std-aware cargo&lt;/code&gt;）或运行时（&lt;code&gt;a-la RUST_BACKTRACE&lt;/code&gt;）添加开关，以堆分配所有与路径相关的 IO 错误。一个类似形的问题是 &lt;code&gt;io::Error&lt;/code&gt; 不携带 backtrace。&lt;/p&gt;
&lt;p&gt;另一个问题是，&lt;code&gt;std::io::Error&lt;/code&gt; 的效率不高。&lt;/p&gt;
&lt;p&gt;它的体积是相当大的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;n&#34;&gt;assert_eq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_of&lt;/span&gt;::&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;io&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_of&lt;/span&gt;::&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;usize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于自定义的情况，会产生双重的间接和分配。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Repr&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Simple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ErrorKind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// First Box :|
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Custom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Custom&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Custom&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kind&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;ErrorKind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Second Box :(
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dyn&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Send&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Sync&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我想我们现在可以解决这个问题了&lt;/p&gt;
&lt;p&gt;首先，我们可以通过使用一个瘦的特质对象来摆脱双重内向性，比如失败或 anyhow。现在 GlobalAlloc 已经存在，这是一个比较直接的实现。&lt;/p&gt;
&lt;p&gt;其次，我们可以利用指针是对齐的这一事实，将 Os 和 Simple 变体都用最小的有效位集储藏到 usize 中。我认为我们甚至可以发挥创意，使用第二个最小有意义的位，把第一个位留作小众。这样一来，即使是像 &lt;code&gt;io::Result&amp;lt;i32&amp;gt;&lt;/code&gt; 这样的东西，也可以是指针大小的!&lt;/p&gt;
&lt;p&gt;本篇文章到此结束。下一次你要为你的库设计一个错误类型的时候，花点时间去看看 &lt;code&gt;std::io::Error&lt;/code&gt; 的源头，你可能会发现一些值得偷的东西。&lt;/p&gt;
&lt;p&gt;讨论在 /r/rust.Net 上进行。&lt;/p&gt;
&lt;h2 id=&#34;额外的谜题&#34;&gt;额外的谜题&lt;/h2&gt;
&lt;p&gt;看看实现中的这一行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;impl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fmt&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Display&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fmt&lt;/span&gt;: &lt;span class=&#34;kp&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fmt&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Formatter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;&amp;#39;_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;-&amp;gt; &lt;span class=&#34;nc&#34;&gt;fmt&lt;/span&gt;::&lt;span class=&#34;nb&#34;&gt;Result&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;repr&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;detail&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;error_string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;{} (os error {})&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;detail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Simple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;{}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;as_str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Repr&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Custom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原文链接: &lt;a href=&#34;https://matklad.github.io/2020/10/15/study-of-std-io-error.html&#34;&gt;https://matklad.github.io/2020/10/15/study-of-std-io-error.html&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/rustlang">rustlang</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/rust">Rust</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/</guid>
                <pubDate>Mon, 05 Apr 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>Two Beautiful Rust Programs</title>
                <link>https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/</link>
                
                
                <description>&lt;blockquote&gt;Two Beautiful Rust Programs&lt;/blockquote&gt;&lt;h1 id=&#34;two-beautiful-rust-programs&#34;&gt;Two Beautiful Rust Programs&lt;/h1&gt;
&lt;p&gt;这是一则 Rust 编程语言的短广告，目标是有经验的 &lt;code&gt;C++&lt;/code&gt; 开发者。作为一则广告，它只能吊起你的胃口，具体内容请参考其他资源。&lt;/p&gt;
&lt;p&gt;第一个程序:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xs&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;: &lt;span class=&#34;kp&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;i32&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;92&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;{}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个程序创建了一个 32 位整数的向量(&lt;code&gt;std::vector&amp;lt;int32_t&amp;gt;&lt;/code&gt;)，接收第一个元素 &lt;code&gt;x&lt;/code&gt; 的引用，再向向量推送一个数字，然后使用 &lt;code&gt;x&lt;/code&gt;。这个程序是错误的：扩展向量可能会使对元素的引用无效，而且 &lt;code&gt;*x&lt;/code&gt; 可能会取消引用一个 danging 指针。&lt;/p&gt;
&lt;p&gt;这个程序的好处是它不会被编译。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0502]: cannot borrow xs as mutable
    because it is also borrowed as immutable
 --&amp;gt; src/main.rs:4:5

     let x: &amp;amp;i32 = &amp;amp;xs[0];
                    -- immutable borrow occurs here
     xs.push(92);
     ^^^^^^^^^^^ mutable borrow occurs here
     println!(x);
              - immutable borrow later used here
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Rust 编译器跟踪每块数据的别名状态，并禁止潜在的别名数据的突变。在这个例子中，&lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;xs&lt;/code&gt; 别名了向量在堆中存储的第一个整数。&lt;/p&gt;
&lt;p&gt;Rust 不允许做傻事。&lt;/p&gt;
&lt;p&gt;第二个程序:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;k&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;crossbeam&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;scope&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parking_lot&lt;/span&gt;::&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MutexGuard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Mutex&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;scope&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;spawn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;guard&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;MutexGuard&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;guard&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unwrap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;total&lt;/span&gt;: &lt;span class=&#34;kp&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;mut&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;i32&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_mut&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;total = {}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;total&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个程序创建一个由 mutex 保护的整数计数器，生成10个线程，从每个线程开始将计数器递增10次，并打印出总数。&lt;/p&gt;
&lt;p&gt;计数器变量位于堆栈中，这些堆栈数据的指针与其他线程共享。线程必须锁定 mutex 才能进行增量。打印总数时，绕过 mutex 读取计数器，没有任何同步。&lt;/p&gt;
&lt;p&gt;这个程序的妙处在于，它的正确性依赖于几位精妙的推理，每一个推理都会被编译器检查。&lt;/p&gt;
&lt;p&gt;子线程不会逃离主函数 所以可以从它的堆栈中读取计数器&lt;/p&gt;
&lt;p&gt;子线程只通过 mutex 访问 counter。&lt;/p&gt;
&lt;p&gt;子线程将在我们从计数器中读出总数而不使用 mutex 时终止。&lt;/p&gt;
&lt;p&gt;如果这些约束中的任何一个被破坏，编译器就会拒绝该代码。没有必要使用 &lt;code&gt;std::shared_ptr&lt;/code&gt; 只是为了防御性地确保内存不会在你的脚下被释放。&lt;/p&gt;
&lt;p&gt;Rust 允许做危险的、聪明的、快速的事情，而不用担心引入未定义的行为。&lt;/p&gt;
&lt;p&gt;如果你喜欢你所看到的，这里有两本我推荐的书，可以让你更深入地了解 Rust。&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&#34;https://matklad.github.io/2020/07/15/two-beautiful-programs.html&#34;&gt;https://matklad.github.io/2020/07/15/two-beautiful-programs.html&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/rustlang">rustlang</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/rust">Rust</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/</guid>
                <pubDate>Mon, 05 Apr 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>争取在 MoarVM 中建立一个新的总调度机制</title>
                <link>https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/</link>
                
                
                <description>&lt;blockquote&gt;Towards a New General Dispatch Mechanism in Moarvm&lt;/blockquote&gt;&lt;p&gt;我的天啊，看来我是两年多来第一次写 Raku 内部的博文了。当然，两年前还不叫 Raku。总之，话不多说，继续说说这个共同的脑洞吧。&lt;/p&gt;
&lt;h2 id=&#34;什么是调度&#34;&gt;什么是调度？&lt;/h2&gt;
&lt;p&gt;我用 &amp;ldquo;dispatch&amp;rdquo; 来表示我们接受一组参数，最后根据这些参数采取一些行动的过程。一些熟悉的例子包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进行一个方法调用，比如 &lt;code&gt;$basket.add($product, $quantity)&lt;/code&gt;。传统上，我们可能只调用 &lt;code&gt;$product&lt;/code&gt; 和 &lt;code&gt;$qauntity&lt;/code&gt; 作为参数，但就我的目的而言，所有的 &lt;code&gt;$basket&lt;/code&gt;、方法名  &amp;ldquo;add&amp;rdquo;、&lt;code&gt;$product&lt;/code&gt; 和 &lt;code&gt;$quantity&lt;/code&gt; 都是 dispatch 的参数：它们是我们需要的东西，以便决定我们要做什么。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进行子程序调用，如 &lt;code&gt;uc($youtube-comment)&lt;/code&gt;。由于 Raku sub 调用是词法解析的，所以在这种情况下，调度的参数是 &lt;code&gt;&amp;amp;uc&lt;/code&gt;（查找子程序的结果）和 &lt;code&gt;$youtube-comment&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用多个调度子程序或方法，根据参数的数量和类型来决定调用一组候选程序中的哪一个。这个过程可以看作是发生在上述两个调度中的一个 &amp;ldquo;内部&amp;rdquo;，因为我们在 Raku 中既有多重调度子程序，也有方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;乍一看，也许前两个看起来相当简单，第三个就有点手忙脚乱了 - 这也算是事实。然而，Raku 还有一些其他的特性，使得调度变得相当，嗯，有趣。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;wrap&lt;/code&gt; 允许我们包装任何 Routine (sub 或方法); 包装器可以选择用原来的参数或新的参数来服从原来的例程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当进行多重调度时，我们可以写一个原型例程，让它选择何时 - 甚至是否 - 调用合适的候选者。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;callsame&lt;/code&gt; 这样的例程，以便在调度中推迟到下一个候选者。但这意味着什么呢？如果我们是在一个多重调度中，它意味着下一个最适用的候选者，如果有的话。如果我们是在一个方法调度中，那么它意味着一个基类的方法。(同样的事情也被用来实现去下一个封装者，或者，最终也是去最初封装的例程)。而且这些都可以结合起来：我们可以包装一个 multi 方法，这意味着我们可以有 3 个层次的东西，都有可能贡献下一个要调用的东西!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多亏了这一点，dispatch - 至少在 Raku 中 - 并不总是我们所做的事情并产生一个结果，而是一个可能会被要求继续多次进行的过程!&lt;/p&gt;
&lt;p&gt;最后，虽然我上面所写的例子都可以很清楚地看成是调度的例子，但在 Raku 中，其他一些常见的构造也可以表达为一种调度。分配是一个例子：它的语义取决于分配的目标和被分配的值，因此我们需要选择正确的语义。强制类型转换(Coercion)是另一个例子，返回值类型检查又是一个例子。&lt;/p&gt;
&lt;h2 id=&#34;为什么调度很重要&#34;&gt;为什么调度很重要？&lt;/h2&gt;
&lt;p&gt;Dispatch 在我们的程序中无处不在，它悄悄地把想做事情的代码和做事情的代码联系在一起。它的无处不在意味着它在程序性能中扮演着重要的角色。在最好的情况下，我们可以将成本降为零。在最坏的情况下，调度的成本高到足以超过作为调度结果的工作的成本。&lt;/p&gt;
&lt;p&gt;初步估计，当运行时&amp;quot;理解&amp;quot;调度时，性能至少会有些不错，但当运行时不理解时，很有可能会很糟糕。调度往往涉及到一个可以缓存的工作量，往往会有一些廉价的防护措施来验证缓存结果的有效性。例如，在方法调度中，天真地我们需要走一个线性化的继承图，并询问沿途遇到的每个类是否有指定名称的方法。显然，如果我们在每次方法调用时都这样做，速度不会非常快。然而，特定类型上的特定方法名（精确识别，不考虑子类）每次都会解析到同一个方法。因此，我们可以缓存查找的结果，只要调用者的类型与用于产生缓存结果的类型相匹配，就可以使用它。&lt;/p&gt;
&lt;h2 id=&#34;语言运行时的专门化与通用化机制&#34;&gt;语言运行时的专门化与通用化机制&lt;/h2&gt;
&lt;p&gt;当一个人开始构建一个针对特定语言的运行时，并且必须在相当紧张的预算下完成时，要想获得某种可容忍的性能，最明显的方法就是将各种热路径语言语义烘焙到运行时中。这正是 MoarVM 的起步方式。因此，如果我们看看 MoarVM 几年前的样子，我们会发现这样的事情。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对方法缓存的一些支持&lt;/li&gt;
&lt;li&gt;一个与 Raku 的多重调度语义高度绑定的多重调度缓存，只有在调度都是名义类型的时候才真正能够起到帮助作用（所以使用 &lt;code&gt;where&lt;/code&gt; 的代价非常高）。&lt;/li&gt;
&lt;li&gt;一种机制，用于指定如何在封装代码对象内部找到实际的代码句柄（例如，&lt;code&gt;Sub&lt;/code&gt; 对象有一个私有属性，它持有识别要运行的字节码的低级代码句柄）。&lt;/li&gt;
&lt;li&gt;一些有限的尝试，让我们能够在知道一个调度不会继续的情况下正确地进行优化 - 这需要编译器和运行时之间的谨慎合作（或者不那么外交地讲，这都是一个大黑客）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些今天都还在，然而也都在淘汰的路上。这个榜单最能说明问题的是什么，不包括在内。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;私有方法调用，需要不同的缓存 但最初的虚拟机设计限制了每一种类型的调用&lt;/li&gt;
&lt;li&gt;合格的方法调用(&lt;code&gt;$obj.SomeType::method-name()&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;体面优化调度恢复的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几年前，我开始部分解决这个问题，引入了一种机制，我称之为 &amp;ldquo;specializer 插件&amp;rdquo;。但首先，什么是特化器(specializer)？&lt;/p&gt;
&lt;p&gt;MoarVM 刚开始的时候，它是一个比较简单的字节码解释器。它只需要足够快的速度击败 Parrot VM 就可以获得相当的使用量，我认为在继续实现一些更有趣的优化之前，这一点非常重要（当时我们还没有今天这样的发布前自动测试基础设施，因此更多的是依赖于早期采用者的反馈）。总之，在能够像其他后端一样运行 Raku 语言后不久，我就开始了动态优化器的开发。它在程序被解释时收集类型统计，识别热代码，将其放入 &lt;a href=&#34;https://en.wikipedia.org/wiki/Static_single_assignment_form&#34;&gt;SSA 形式&lt;/a&gt;，使用类型统计插入防护，将这些与字节码的静态属性一起使用来分析和优化，并为相关函数生成专门的字节码。这个字节码可以省略类型检查和各种查找，也可以使用一系列的内部操作，做出各种假设，由于优化器证明了程序的属性，这些假设是安全的。这被称为专门化的字节码，因为它的很多通用性 - 这将使它能够正确地工作在我们可能遇到的所有类型的值上 - 被删除了，转而工作在运行时实际发生的特殊情况下。(代码，尤其是动态语言中的代码，一般来说，理论上的通用性远远大于实践中的通用性。)&lt;/p&gt;
&lt;p&gt;这个组件 - 内部称为 &amp;ldquo;spesh&amp;rdquo; 的 specializer - 为 Raku 程序的性能带来了显著的进一步提升，随着时间的推移，它的复杂程度也在不断提高，并采用了&lt;a href=&#34;https://en.wikipedia.org/wiki/Inline_expansion&#34;&gt;内联&lt;/a&gt;和&lt;a href=&#34;https://en.wikipedia.org/wiki/Escape_analysis&#34;&gt;带有标量替换的转义分析&lt;/a&gt;等优化功能。这些并不是容易构建的东西 - 但一旦运行时拥有了它们，它们就会创造出以前不存在的设计可能性，并使在没有它们的情况下做出的决定看起来是次优的。&lt;/p&gt;
&lt;p&gt;值得注意的是，那些特殊情况下的语言特定机制，在早期为了获得一些速度而被嵌入到运行时中，反而成为了一种负担和瓶颈。它们具有复杂的语义，这意味着它们对优化器来说要么是不透明的（所以优化器无法对它们进行推理，意味着优化受到抑制），要么就是需要在优化器中进行特殊的封装（一种负担）。&lt;/p&gt;
&lt;p&gt;所以，回到 specializer 插件。我到了一个地步，我想承担像 &lt;code&gt;$obj.?meth(&amp;quot;call me maybe&amp;quot;, dispatch)&lt;/code&gt;、&lt;code&gt;$obj.SomeType::meth()&lt;/code&gt;(用类开始寻找的调度限定)，以及角色中的私有方法调用(不能静态解析)这样的性能。同时，我还准备实现一定量的转义分析，但意识到它的作用将非常有限，因为赋值在虚拟机中也被特例化了，有一大块不透明的 C 代码在做热路径的事情。&lt;/p&gt;
&lt;p&gt;但为什么我们要让 C 代码来做那些热路径的事情呢？嗯，因为让每个赋值都调用一个虚拟机级别的函数，做一堆检查和逻辑，花费太大了。为什么这样做成本很高？因为函数调用的开销和解释的成本。这在以前都是正确的。但是，若干年后的发展。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内联被实现了，并且可以消除做一个函数调用的开销。&lt;/li&gt;
&lt;li&gt;我们可以编译成机器代码，消除解释开销。&lt;/li&gt;
&lt;li&gt;我们当时的处境是，我们手头有 specializer 的类型信息，可以让我们消除 C 代码中的分支，但由于我们调用的只是一个不透明的函数，所以没有办法抓住这个机会&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我解决了上面提到的分配问题和调度问题，引入了一个新的机制：specializer 插件。它们的工作原理如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当我们第一次到达字节码中的一个给定的调用点时，我们就会运行这个插件。它产生了一个要调用的代码对象，以及一组守卫（为了使用该代码对象结果而必须满足的条件）。&lt;/li&gt;
&lt;li&gt;下一次到达时，我们检查是否满足守卫，如果满足，就用结果&lt;/li&gt;
&lt;li&gt;如果没有，我们再运行一次插件，并在 callsite 处堆积一个防护集。&lt;/li&gt;
&lt;li&gt;我们统计了一个给定的防护集成功的频率，然后将其用于 specializer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;绝大多数情况下都是单态的，这意味着只产生一组守卫，而且之后总是成功的。因此，特殊化器可以将这些守卫编译到专门的字节码中，然后假设给定的目标调用者就是将被调用的守卫。(进一步，重复的守卫可以被消除，所以某个插件引入的守卫可能会减少到零)。&lt;/p&gt;
&lt;p&gt;Specializer 插件感觉挺好的。一个新机制解决了多个优化头疼的问题。&lt;/p&gt;
&lt;p&gt;新的 MoarVM 调度机制是对一个相当简单的问题的回答：如果我们把所有与调度相关的特例机制去掉，而采用有点像 specializer 插件的机制，会怎么样？由此产生的机制需要是一个比 specializer 插件更强大的机制。进一步说，我可以学习特殊器插件的一些缺点。因此，虽然它们会在比较短的寿命后消失，但我认为可以说，如果没有这些经验，我就不会有能力设计新的 MoarVM 调度机制。&lt;/p&gt;
&lt;h2 id=&#34;调度操作和引导调度器&#34;&gt;调度操作和引导调度器&lt;/h2&gt;
&lt;p&gt;所有的方法缓存。所有的多重调度缓存。所有的 specializer 插件。所有用于在代码对象中解包字节码句柄的调用协议的东西。这一切都将被取消，取而代之的是一个新的调度指令。它的名字很无聊，叫 &lt;code&gt;dispatch&lt;/code&gt;。它看起来像这样。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;dispatch_o result, &#39;dispatcher-name&#39;, callsite, arg0, arg1, ..., argN
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用名为 dispatcher-name 的调度器。&lt;/li&gt;
&lt;li&gt;给它指定的参数寄存器（所引用的调用点表示参数的数量）。&lt;/li&gt;
&lt;li&gt;将调度的对象结果放入寄存器结果中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(旁白：这意味着一个新的调用约定，即我们不再将参数复制到参数缓冲区，而是将寄存器集的基数和一个指针传递到找到寄存器参数映射的字节码中，然后做一个查询 &lt;code&gt;registers[map[argument_index]]&lt;/code&gt; 来获取一个参数的值。仅此一点，我们在解释时就很省事，因为我们不再需要每个参数绕着解释器循环了）。)&lt;/p&gt;
&lt;p&gt;有些参数可能是我们传统上称之为参数的东西。有些则是针对调度过程本身。这其实并不重要 - 但如果我们安排将只针对调度的参数放在前面（例如，方法名），而将针对调度目标的参数放在后面（例如，方法参数），则会更加理想。&lt;/p&gt;
&lt;p&gt;新的 bootstrap 机制提供了少量的内置调度器，它们的名字以 &amp;ldquo;boot-&amp;rdquo; 开头。它们是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boot-value&lt;/code&gt; - 取第一个参数并将其作为结果（身份函数，除了丢弃任何其他参数）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boot-constant&lt;/code&gt; - 取第一个参数并将其作为结果，但同时也将其视为一个将始终产生的常量值（因此意味着优化器可以将任何用于计算该值的纯代码视为死值）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boot-code&lt;/code&gt; - 取第一个参数（必须是虚拟机字节码句柄），并运行该字节码，将其余参数作为参数传给它；评估为字节码的返回值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boot-syscall&lt;/code&gt; - 将第一个参数视为虚拟机提供的内置操作的名称，然后调用它，并将其余参数作为其参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boot-resume&lt;/code&gt; - 恢复正在进行的最上层调度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;差不多就是这样。我们构建的每一个调度器，为了教给运行时一些其他的调度行为，最终都会终止于其中一个。&lt;/p&gt;
&lt;h2 id=&#34;在引导程序的基础上&#34;&gt;在引导程序的基础上&lt;/h2&gt;
&lt;p&gt;教 MoarVM 了解不同种类的调度，不外乎使用调度机制本身! 在大多数情况下，&lt;code&gt;boot-syscall&lt;/code&gt; 被用来注册一个调度器，设置守卫，并提供与它们相匹配的结果。&lt;/p&gt;
&lt;p&gt;这里是一个最小的例子，取自 dispatcher 测试套件，展示了一个提供同一性功能的 dispatcher 的样子。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-register&#39;, &#39;identity&#39;, -&amp;gt; $capture {
    nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-delegate&#39;, &#39;boot-value&#39;, $capture);
});
sub identity($x) {
    nqp::dispatch(&#39;identity&#39;, $x)
}
ok(identity(42) == 42, &#39;Can define identity dispatch (1)&#39;);
ok(identity(&#39;foo&#39;) eq &#39;foo&#39;, &#39;Can define identity dispatch (2)&#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在第一条语句中，我们调用 dispatcher-register MoarVM 系统调用，传递一个 dispatcher 的名称以及一个闭包，每次我们需要处理调度时，都会调用这个闭包（我倾向于将其称为&amp;quot;调度回调&amp;quot;）。它接收一个单一的参数，这是一个参数的捕获（其实不是 Raku 级别的捕获，但想法 - 一个包含一组调用参数的对象 - 是一样的）。&lt;/p&gt;
&lt;p&gt;每一个用户定义的调度器最终都应该使用 dispatcher-delegate，以便确定另一个调度器将控制权传递给它。在这种情况下，它立即委托给 &lt;code&gt;boot-value&lt;/code&gt; - 这意味着它除了是 &lt;code&gt;boot-value&lt;/code&gt; 内置调度器的包装器外，其实什么都不是。&lt;/p&gt;
&lt;p&gt;sub &lt;code&gt;identity&lt;/code&gt; 包含一个调度操作的静态出现。鉴于我们两次调用 sub，我们在运行时将两次遇到这个 op，但这两次是非常不同的。&lt;/p&gt;
&lt;p&gt;第一次是 &amp;ldquo;记录&amp;rdquo; 阶段。参数形成一个捕获，回调运行，回调又将其传给引导值调度器，产生结果。这样就形成了一个极其简单的调度程序，它说结果应该是捕获中的第一个参数。由于没有守卫，所以这将永远是一个有效的结果。&lt;/p&gt;
&lt;p&gt;第二次遇到调度操作时，它那里已经记录了一个调度程序，所以我们处于运行模式。在 MoarVM 源码中开启调试模式，我们可以看到结果的调度程序是这样的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dispatch program (1 temporaries)
  Ops:
    Load argument 0 into temporary 0
    Set result object value from temporary 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说，它将参数 0 读入一个临时位置，然后将其设置为调度的结果。请注意，没有提到我们经过了额外的一层调度，这些在结果调度程序中的成本为零。&lt;/p&gt;
&lt;h2 id=&#34;捕获操作&#34;&gt;捕获操作&lt;/h2&gt;
&lt;p&gt;参数捕获是不可改变的。各种虚拟机系统调用的存在，可以通过一些调整将它们转化为新的参数捕获，例如删除或插入参数。这里还有一个测试套件的例子。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-register&#39;, &#39;drop-first&#39;, -&amp;gt; $capture {
    my $capture-derived := nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-drop-arg&#39;, $capture, 0);
    nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-delegate&#39;, &#39;boot-value&#39;, $capture-derived);
});
ok(nqp::dispatch(&#39;drop-first&#39;, &#39;first&#39;, &#39;second&#39;) eq &#39;second&#39;,
    &#39;dispatcher-drop-arg works&#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就在将捕获传递给引导值调度器之前丢弃了第一个参数 - 意味着它将返回第二个参数。回头看一下之前的身份函数的调度程序。你能猜到这个程序会是什么样子吗？&lt;/p&gt;
&lt;p&gt;好吧，就是这样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dispatch program (1 temporaries)
  Ops:
    Load argument 1 into temporary 0
    Set result string value from temporary 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同样，虽然在这样一个调度器的记录阶段，我们确实是创建了捕获对象，并做了一个调度器代理，但由此产生的调度程序要简单得多。&lt;/p&gt;
&lt;p&gt;下面是一个稍微复杂一点的例子。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my $target := -&amp;gt; $x { $x + 1 }
nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-register&#39;, &#39;call-on-target&#39;, -&amp;gt; $capture {
    my $capture-derived := nqp::dispatch(&#39;boot-syscall&#39;,
            &#39;dispatcher-insert-arg-literal-obj&#39;, $capture, 0, $target);
    nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-delegate&#39;,
            &#39;boot-code-constant&#39;, $capture-derived);
});
sub cot() { nqp::dispatch(&#39;call-on-target&#39;, 49) }
ok(cot() == 50,
    &#39;dispatcher-insert-arg-literal-obj works at start of capture&#39;);
ok(cot() == 50,
    &#39;dispatcher-insert-arg-literal-obj works at start of capture after link too&#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里，我们有一个存储在变量 &lt;code&gt;$target&lt;/code&gt; 中的闭包。我们把它作为捕获的第一个参数插入，然后委托给 &lt;code&gt;boot-code-constant&lt;/code&gt;，它将调用那个代码对象，并把其他调度参数传递给它。再次，在记录阶段，我们真正要做的事情是这样的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个新的捕获 在开始的时候插入一个代码对象。&lt;/li&gt;
&lt;li&gt;委托给引导代码常量分配器，它&amp;hellip;。&lt;/li&gt;
&lt;li&gt;&amp;hellip;在没有原始参数的情况下创建一个新的捕获，并使用这些参数运行字节码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此产生的调度程序呢？就是这个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dispatch program (1 temporaries)
  Ops:
    Load collectable constant at index 0 into temporary 0
    Skip first 0 args of incoming capture; callsite from 0
    Invoke MVMCode in temporary 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说，加载我们要调用的常量字节码句柄，设置 &lt;code&gt;args&lt;/code&gt;（在本例中等于传入捕获的参数），然后用这些参数调用字节码。参数的洗牌，又一次消失了。一般来说，只要我们做最终的字节码调用的参数是初始调度参数的尾巴，参数转换就会变得不过是一个指针的添加。&lt;/p&gt;
&lt;h2 id=&#34;守卫&#34;&gt;守卫&lt;/h2&gt;
&lt;p&gt;目前看到的所有调度方案都是无条件的：一旦在某一通话地点记录下来，就应一直使用。要使这样的机制具有实用性，缺少的一大块就是守卫。守卫断言了一些属性，比如参数的类型或者参数是确定的（&lt;code&gt;Int:D&lt;/code&gt;）还是不确定的（&lt;code&gt;Int:U&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;下面是一个有点长的测试用例，并在其中放置了一些解释。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;# A couple of classes for test purposes
my class C1 { }
my class C2 { }
 
# A counter used to make sure we&#39;re only invokving the dispatch callback as
# many times as we expect.
my $count := 0;
 
# A type-name dispatcher that maps a type into a constant string value that
# is its name. This isn&#39;t terribly useful, but it is a decent small example.
nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-register&#39;, &#39;type-name&#39;, -&amp;gt; $capture {
    # Bump the counter, just for testing purposes.
    $count++;
 
    # Obtain the value of the argument from the capture (using an existing
    # MoarVM op, though in the future this may go away in place of a syscall)
    # and then obtain the string typename also.
    my $arg-val := nqp::captureposarg($capture, 0);
    my str $name := $arg-val.HOW.name($arg-val);
 
    # This outcome is only going to be valid for a particular type. We track
    # the argument (which gives us an object back that we can use to guard
    # it) and then add the type guard.
    my $arg := nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-track-arg&#39;, $capture, 0);
    nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-guard-type&#39;, $arg);
 
    # Finally, insert the type name at the start of the capture and then
    # delegate to the boot-constant dispatcher.
    nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-delegate&#39;, &#39;boot-constant&#39;,
        nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-insert-arg-literal-str&#39;,
            $capture, 0, $name));
});
 
# A use of the dispatch for the tests. Put into a sub so there&#39;s a single
# static dispatch op, which all dispatch programs will hang off.
sub type-name($obj) {
    nqp::dispatch(&#39;type-name&#39;, $obj)
}
 
# Check with the first type, making sure the guard matches when it should
# (although this test would pass if the guard were ignored too).
ok(type-name(C1) eq &#39;C1&#39;, &#39;Dispatcher setting guard works&#39;);
ok($count == 1, &#39;Dispatch callback ran once&#39;);
ok(type-name(C1) eq &#39;C1&#39;, &#39;Can use it another time with the same type&#39;);
ok($count == 1, &#39;Dispatch callback was not run again&#39;);
 
# Test it with a second type, both record and run modes. This ensures the
# guard really is being checked.
ok(type-name(C2) eq &#39;C2&#39;, &#39;Can handle polymorphic sites when guard fails&#39;);
ok($count == 2, &#39;Dispatch callback ran a second time for new type&#39;);
ok(type-name(C2) eq &#39;C2&#39;, &#39;Second call with new type works&#39;);
 
# Check that we can use it with the original type too, and it has stacked
# the dispatch programs up at the same callsite.
ok(type-name(C1) eq &#39;C1&#39;, &#39;Call with original type still works&#39;);
ok($count == 2, &#39;Dispatch callback only ran a total of 2 times&#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候就会产生两个调度程序，一个是 C1。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dispatch program (1 temporaries)
  Ops:
    Guard arg 0 (type=C1)
    Load collectable constant at index 1 into temporary 0
    Set result string value from temporary 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一个是 C2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dispatch program (1 temporaries)
  Ops:
    Guard arg 0 (type=C2)
    Load collectable constant at index 1 into temporary 0
    Set result string value from temporary 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再一次，没有捕获操作、跟踪或调度器委托的遗留问题；调度程序对一个参数进行类型防护，然后产生结果字符串。整个对 &lt;code&gt;$arg-val.HOW.name($arg-val)&lt;/code&gt; 的调用都被省略了，我们写的调度程序将知识进行了编码 - 以虚拟机能够理解的方式 - 一个类型的名称可以被认为是不可改变的。&lt;/p&gt;
&lt;p&gt;这个例子有点造作，但现在考虑一下，我们反而要查找一个方法，并在调用者类型上进行守卫：这就是一个方法缓存! 守护更多参数的类型，我们就有了一个多缓存。两者都做，我们就有了一个多方法缓存。&lt;/p&gt;
&lt;p&gt;后者很有意思，因为方法调度和多调度都想对调用者进行守护。事实上，在 MoarVM 中，今天会有两个这样的类型测试，直到我们到了特殊化器做工作并消除这些重复的守卫。然而，新的调度器并没有将调度器 - guard-类型当作一种命令式操作，将守卫写入结果调度程序中。相反，它声明相关的参数必须被防护。如果其他的调度器已经这样做了，那它就是幂等的。一旦我们委派通过的所有调度程序，在通往最终结果的路径上，都有了自己的发言权，就会发出守卫。&lt;/p&gt;
&lt;p&gt;有趣的是：特别细心的人会注意到，调度机制也被用作实现新的调度程序的一部分，事实上，这最终也将意味着特殊化者可以将调度程序特殊化，让它们也被 JIT 编译成更高效的东西。毕竟，从 MoarVM 的角度来看，这一切都只是要运行的字节码，只是有些字节码是告诉 VM 如何更高效地执行 Raku 程序的!&lt;/p&gt;
&lt;h2 id=&#34;恢复调度&#34;&gt;恢复调度&lt;/h2&gt;
&lt;p&gt;可恢复调度器需要做两件事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在注册调度器的时候，提供一个恢复回调和一个调度回调。&lt;/li&gt;
&lt;li&gt;在 dispatch 回调中，指定一个捕获，这将形成恢复初始化状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当发生恢复时，将调用恢复回调，并提供恢复的任何参数。它还可以获得在 dispatch 回调中设置的 resume 初始化状态。resume 初始化状态包含了第一次恢复调度时继续进行调度所需要的东西。我们先来看看方法调度的工作原理，看一个具体的例子。我也会在此时，切换到看真正的 Rakudo 调度器，而不是简化的测试用例。&lt;/p&gt;
&lt;p&gt;Rakudo 调度器利用授权、重复守卫和捕获操作都没有运行时成本的优势，在结果调度程序中，至少在我看来，很好地因素了一个有些复杂的调度过程。方法调度有多个切入点：普通无聊的 &lt;code&gt;$obj.meth()&lt;/code&gt;，限定的 &lt;code&gt;$obj.Type::meth()&lt;/code&gt;，以及调用我也许 &lt;code&gt;$obj.?meth()&lt;/code&gt;。这些都有共同的 resume 语义 - 或者至少，只要我们在 resume 初始化状态中始终携带一个起始类型，也就是我们做方法调度的对象的类型，就可以使它们成为。&lt;/p&gt;
&lt;p&gt;这里是普通方法调度的切入点，去掉了报告缺失方法错误的无聊细节。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;# A standard method call of the form $obj.meth($arg); also used for the
# indirect form $obj.&amp;quot;$name&amp;quot;($arg). It receives the decontainerized invocant,
# the method name, and the the args (starting with the invocant including any
# container).
nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-register&#39;, &#39;raku-meth-call&#39;, -&amp;gt; $capture {
    # Try to resolve the method call using the MOP.
    my $obj := nqp::captureposarg($capture, 0);
    my str $name := nqp::captureposarg_s($capture, 1);
    my $meth := $obj.HOW.find_method($obj, $name);
 
    # Report an error if there is no such method.
    unless nqp::isconcrete($meth) {
        !!! &#39;Error reporting logic elided for brevity&#39;;
    }
 
    # Establish a guard on the invocant type and method name (however the name
    # may well be a literal, in which case this is free).
    nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-guard-type&#39;,
        nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-track-arg&#39;, $capture, 0));
    nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-guard-literal&#39;,
        nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-track-arg&#39;, $capture, 1));
 
    # Add the resolved method and delegate to the resolved method dispatcher.
    my $capture-delegate := nqp::dispatch(&#39;boot-syscall&#39;,
        &#39;dispatcher-insert-arg-literal-obj&#39;, $capture, 0, $meth);
    nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-delegate&#39;,
        &#39;raku-meth-call-resolved&#39;, $capture-delegate);
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在是解析方法 dispatcher，也就是处理恢复的地方。首先，让我们看看正常的 dispatch 回调（恢复回调是包含的，但是是空的，我稍后会展示它）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;# Resolved method call dispatcher. This is used to call a method, once we have
# already resolved it to a callee. Its first arg is the callee, the second and
# third are the type and name (used in deferral), and the rest are the args to
# the method.
nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-register&#39;, &#39;raku-meth-call-resolved&#39;,
    # Initial dispatch
    -&amp;gt; $capture {
        # Save dispatch state for resumption. We don&#39;t need the method that will
        # be called now, so drop it.
        my $resume-capture := nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-drop-arg&#39;,
            $capture, 0);
        nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-set-resume-init-args&#39;, $resume-capture);
 
        # Drop the dispatch start type and name, and delegate to multi-dispatch or
        # just invoke if it&#39;s single dispatch.
        my $delegate_capture := nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-drop-arg&#39;,
            nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-drop-arg&#39;, $capture, 1), 1);
        my $method := nqp::captureposarg($delegate_capture, 0);
        if nqp::istype($method, Routine) &amp;amp;&amp;amp; $method.is_dispatcher {
            nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-delegate&#39;, &#39;raku-multi&#39;, $delegate_capture);
        }
        else {
            nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-delegate&#39;, &#39;raku-invoke&#39;, $delegate_capture);
        }
    },
    # Resumption
    -&amp;gt; $capture {
        ... &#39;Will be shown later&#39;;
    });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;raku-meth-call 中有一个可以论证的欺骗：它实际上并没有插入调用者的类型对象来代替调用者。事实证明，这并不重要。否则，我认为注释（在真正的实现中也可以找到）很好地说明了这个问题。&lt;/p&gt;
&lt;p&gt;有一个重要的点可能并不清楚 - 但遵循了一个重复的主题 - 那就是恢复初始化状态的设置也更多的是一种声明式而不是命令式的东西：在调度的时候并没有运行时成本，而是我们在周围保留了足够的信息，以便能够在我们需要的时候重建恢复初始化状态。事实上，当我们处于恢复的运行阶段时，我们甚至不需要在创建捕获对象的意义上重建它）。&lt;/p&gt;
&lt;p&gt;现在说说复盘。我将介绍一个严重简化的版本，它只处理 callsame 语义（完整的东西也要处理 lastcall 和 nextcallee 这样的乐趣）。resume 初始化状态的存在是为了给 resumption 过程播种。一旦我们知道我们实际上确实要处理恢复，我们就可以做一些事情，比如计算我们想要走过的继承图中的全部方法列表。每个可恢复的调度器在调用栈上得到一个单一的存储槽，它可以用于它的状态。它可以在恢复的第一步中初始化这个，然后在我们走的时候更新它。或者更准确的说，它可以设置一个调度程序，在运行时就会这样做。&lt;/p&gt;
&lt;p&gt;对于我们将要走过的候选链来说，链接列表原来是一个非常方便的数据结构。我们可以通过跟踪当前节点来完成链接列表的工作，也就是说只需要有一个东西发生突变，也就是当前调度的状态。调度程序机制还提供了一种从对象中读取属性的方法，这就足以将遍历链接列表表达到调度程序中。这也意味着零分配。&lt;/p&gt;
&lt;p&gt;所以，不多说了，下面是链接列表（在 NQP 这个受限的 Raku 子集中，相当不如在完整的 Raku 中漂亮）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;# A linked list is used to model the state of a dispatch that is deferring
# through a set of methods, multi candidates, or wrappers. The Exhausted class
# is used as a sentinel for the end of the chain. The current state of the
# dispatch points into the linked list at the appropriate point; the chain
# itself is immutable, and shared over (runtime) dispatches.
my class DeferralChain {
    has $!code;
    has $!next;
    method new($code, $next) {
        my $obj := nqp::create(self);
        nqp::bindattr($obj, DeferralChain, &#39;$!code&#39;, $code);
        nqp::bindattr($obj, DeferralChain, &#39;$!next&#39;, $next);
        $obj
    }
    method code() { $!code }
    method next() { $!next }
};
my class Exhausted {};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后是恢复处理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-register&#39;, &#39;raku-meth-call-resolved&#39;,
    # Initial dispatch
    -&amp;gt; $capture {
        ... &#39;Presented earlier;
    },
    # Resumption. The resume init capture&#39;s first two arguments are the type
    # that we initially did a method dispatch against and the method name
    # respectively.
    -&amp;gt; $capture {
        # Work out the next method to call, if any. This depends on if we have
        # an existing dispatch state (that is, a method deferral is already in
        # progress).
        my $init := nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-get-resume-init-args&#39;);
        my $state := nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-get-resume-state&#39;);
        my $next_method;
        if nqp::isnull($state) {
            # No state, so just starting the resumption. Guard on the
            # invocant type and name.
            my $track_start_type := nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-track-arg&#39;, $init, 0);
            nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-guard-type&#39;, $track_start_type);
            my $track_name := nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-track-arg&#39;, $init, 1);
            nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-guard-literal&#39;, $track_name);
 
            # Also guard on there being no dispatch state.
            my $track_state := nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-track-resume-state&#39;);
            nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-guard-literal&#39;, $track_state);
 
            # Build up the list of methods to defer through.
            my $start_type := nqp::captureposarg($init, 0);
            my str $name := nqp::captureposarg_s($init, 1);
            my @mro := nqp::can($start_type.HOW, &#39;mro_unhidden&#39;)
                ?? $start_type.HOW.mro_unhidden($start_type)
                !! $start_type.HOW.mro($start_type);
            my @methods;
            for @mro {
                my %mt := nqp::hllize($_.HOW.method_table($_));
                if nqp::existskey(%mt, $name) {
                    @methods.push(%mt{$name});
                }
            }
 
            # If there&#39;s nothing to defer to, we&#39;ll evaluate to Nil (just don&#39;t set
            # the next method, and it happens below).
            if nqp::elems(@methods) &amp;gt;= 2 {
                # We can defer. Populate next method.
                @methods.shift; # Discard the first one, which we initially called
                $next_method := @methods.shift; # The immediate next one
 
                # Build chain of further methods and set it as the state.
                my $chain := Exhausted;
                while @methods {
                    $chain := DeferralChain.new(@methods.pop, $chain);
                }
                nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-set-resume-state-literal&#39;, $chain);
            }
        }
        elsif !nqp::istype($state, Exhausted) {
            # Already working through a chain of method deferrals. Obtain
            # the tracking object for the dispatch state, and guard against
            # the next code object to run.
            my $track_state := nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-track-resume-state&#39;);
            my $track_method := nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-track-attr&#39;,
                $track_state, DeferralChain, &#39;$!code&#39;);
            nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-guard-literal&#39;, $track_method);
 
            # Update dispatch state to point to next method.
            my $track_next := nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-track-attr&#39;,
                $track_state, DeferralChain, &#39;$!next&#39;);
            nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-set-resume-state&#39;, $track_next);
 
            # Set next method, which we shall defer to.
            $next_method := $state.code;
        }
        else {
            # Dispatch already exhausted; guard on that and fall through to returning
            # Nil.
            my $track_state := nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-track-resume-state&#39;);
            nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-guard-literal&#39;, $track_state);
        }
 
        # If we found a next method...
        if nqp::isconcrete($next_method) {
            # Call with same (that is, original) arguments. Invoke with those.
            # We drop the first two arguments (which are only there for the
            # resumption), add the code object to invoke, and then leave it
            # to the invoke or multi dispatcher.
            my $just_args := nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-drop-arg&#39;,
                nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-drop-arg&#39;, $init, 0),
                0);
            my $delegate_capture := nqp::dispatch(&#39;boot-syscall&#39;,
                &#39;dispatcher-insert-arg-literal-obj&#39;, $just_args, 0, $next_method);
            if nqp::istype($next_method, Routine) &amp;amp;&amp;amp; $next_method.is_dispatcher {
                nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-delegate&#39;, &#39;raku-multi&#39;,
                        $delegate_capture);
            }
            else {
                nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-delegate&#39;, &#39;raku-invoke&#39;,
                        $delegate_capture);
            }
        }
        else {
            # No method, so evaluate to Nil (boot-constant disregards all but
            # the first argument).
            nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-delegate&#39;, &#39;boot-constant&#39;,
                nqp::dispatch(&#39;boot-syscall&#39;, &#39;dispatcher-insert-arg-literal-obj&#39;,
                    $capture, 0, Nil));
        }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是相当多的内容，也是相当多的代码。但请记住，这只是运行在调度恢复的记录阶段。它还会在 callsame 的 callsite 产生一个调度程序，并带有通常的守卫和结果。隐式守卫是为我们在该点恢复的调度程序创建的。在最常见的情况下，这最终将是单形或双形的，尽管涉及多个调度或方法调度的嵌套的情况可能会产生一个更有形态的 callsite。&lt;/p&gt;
&lt;p&gt;我选取的设计迫使 resume 回调处理两种情况：第一次复用和后一次复用。这在几个方面都不理想。&lt;/p&gt;
&lt;p&gt;这对那些编写调度简历回调的人来说有点不方便。然而，这又不是特别常见的活动!&lt;/p&gt;
&lt;p&gt;这种差异导致两个调度程序堆积在一个调用点，而在其他情况下，这个调用点可能只得到一个
只有其中第二项真正重要。之所以不统一，是为了确保绝大多数从未恢复调度的电话，不会因其最终从未使用的功能而产生每次调度的费用。如果结果是使用该功能的人多花了一点成本，那就这样吧。事实上，早期的基准测试显示，使用新调度器的 callsame 与 wrap 和方法调用似乎比当前 Rakudo 中的速度快了 10 倍，这还没等专门人员对它有足够的了解，就已经进一步改进了!&lt;/p&gt;
&lt;h2 id=&#34;目前所做的事情&#34;&gt;目前所做的事情&lt;/h2&gt;
&lt;p&gt;我上面讨论的所有内容都已经实现了，只是我可能在某个地方给人的印象是，使用新的 dispatcher 已经完全实现了多重调度，而现在还不是这样（没有处理 where 子句，也不支持调度恢复）。&lt;/p&gt;
&lt;h2 id=&#34;今后的步骤&#34;&gt;今后的步骤&lt;/h2&gt;
&lt;p&gt;下一步显然是要完全实现多调度的缺失部分。另一个缺失的语义是对 callwith 和 nextwith 的支持，当我们希望改变移动到下一个候选人时使用的参数。抛开其他一些小问题不谈，理论上来说，这至少可以让所有的 Raku 调度语义得到支持。&lt;/p&gt;
&lt;p&gt;目前，所有的标准方法调用（$obj.meth()）和其他调用（foo()和$foo()）都会通过现有的调度机制，而不是新的调度器。这些也需要迁移到新的调度器上，而且任何发现的错误都需要修复。这将使事情达到新调度器在语义上已经准备好的程度。&lt;/p&gt;
&lt;p&gt;之后是性能工作：确保专用器能够处理调度程序的防护和结果。最初的目标是，让常见调用形式的稳态性能至少与当前乐道主分支中的性能相同。已经很清楚了，对于一些到目前为止还很冰冷的东西来说，会有一些大的胜利，但它不应该以最常见的调度种类的退步为代价，因为这些调度种类之前已经得到了大量的优化努力。&lt;/p&gt;
&lt;p&gt;此外，NQP - 乐道编译器和运行时内脏的其他位写的乐的限制形式 - 也需要迁移到使用新的调度器。只有做到这一点，才有可能从 MoarVM 中扯出当前的方法缓存、多调度缓存等。&lt;/p&gt;
&lt;p&gt;一个悬而未决的问题是，如何处理 MoarVM 以外的后端。理想情况下，新的调度机制将被移植到这些地方。相当多的内容应该可以用 JVM 的 invokedynamic 来表达（而这一切可能会在基于 Truffle 的 Raku 实现中发挥得相当好，尽管我不确定目前是否有这方面的积极努力）。&lt;/p&gt;
&lt;h2 id=&#34;未来的机会&#34;&gt;未来的机会&lt;/h2&gt;
&lt;p&gt;虽然我目前的重点是发布一个使用新调度机制的 Rakudo 和 MoarVM 版本，但这不会是旅程的终点。一些眼前的想法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对角色的方法调用需要把角色打入一个类中， 所以方法查找会返回一个闭包来完成这个任务并替换调用者。这是一个很大的间接性；新的调度者可以获得 pun，并产生一个调度程序，用 punn 化的类类型对象替换角色类型对象，这将使每次调用的成本大大降低。&lt;/li&gt;
&lt;li&gt;我期望使用新的 dispatcher 可以使句柄（dlegated）和 fallback（处理缺失的方法调用）机制都能有更好的表现&lt;/li&gt;
&lt;li&gt;当前的 assuming - 用于为例程讨价还价或其他首要参数 - 的实现并不理想，利用新调度器的参数重写能力的实现可能会有更好的表现。
在新的调度机制的帮助下，一些新的语言功能也可能以高效的方式提供。例如，目前没有一种可靠的方式来尝试调用一段代码，如果签名绑定了就运行它，如果没有绑定就做其他事情。相反，像 Cro 路由器这样的东西，必须先做签名的试绑定，然后再做调用，这使得路由的成本相当高。还有一个建议已久的想法，就是通过签名与 &lt;code&gt;when&lt;/code&gt; 构造提供模式匹配 (例如，&lt;code&gt;when * -&amp;gt; ($x) {}; when * -&amp;gt; ($x, *@tail) { }&lt;/code&gt;)，这和需求差不多，只是在一个不太动态的环境下。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;最后&#34;&gt;最后&amp;hellip;&lt;/h2&gt;
&lt;p&gt;在新的调度机制上的工作比我最初预期的历程要长。设计的恢复部分特别具有挑战性，而且还有一些重要的细节需要处理。一路走来，大概有四种潜在的方法被抛弃了（虽然其中的元素都影响了我在这篇文章中描述的内容）。能坚持下来的抽象真的非常非常难。&lt;/p&gt;
&lt;p&gt;我最终也不得不从根本上离开几个月做 Raku 工作，在其他一些工作中感觉有点被压垮了，并且一直在与同样重要的 RakuAST 项目（它将因为能够承担新的调度器的存在而被简化，并且还为我提供了一系列更柔和的 Raku 黑客任务，而调度器的工作提供了很少的轻松选择）。&lt;/p&gt;
&lt;p&gt;鉴于这些，我很高兴终于看到了隧道尽头的光亮。剩下的工作是数不胜数的，而我们使用新的调度器发布 Rakudo 和 MoarVM 的那一天，感觉还需要几个月的时间（我希望写下这句话不是在诱惑命运！）。&lt;/p&gt;
&lt;p&gt;新的调度器可能是 MoarVM 自我创建以来最重要的变化，因为它看到我们删除了一堆从一开始就存在的东西。RakuAST 也将为 Rakudo 编译器带来十年来最大的架构变化。两者都是一个机会，将多年来学习的东西硬生生地折合到运行时和编译器中。我希望再过十年，当我回顾这一切的时候，至少会觉得自己这次犯了更多有趣的错误。&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&#34;https://6guts.wordpress.com/2021/03/15/towards-a-new-general-dispatch-mechanism-in-moarvm/&#34;&gt;https://6guts.wordpress.com/2021/03/15/towards-a-new-general-dispatch-mechanism-in-moarvm/&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/rakulang">rakulang</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/</guid>
                <pubDate>Mon, 15 Mar 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>Raku is a match for *</title>
                <link>https://ohmyweekly.github.io/notes/2021-03-12-raku-is-a-match-for-star/</link>
                
                
                <description>&lt;blockquote&gt;Raku Is a Match for *&lt;/blockquote&gt;&lt;p&gt;PimDaniel &lt;a href=&#34;https://gist.github.com/gfldex/ffa8d0e60cbd3845b4d91bd2029fcd5b&#34;&gt;提出&lt;/a&gt;了一个有趣的问题。&lt;/p&gt;
&lt;p&gt;我如何在匹配时测试 match is True : 这不起作用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;if my ($type,$a,$b,$c) = ($v ~~ /^ (&#39;horiz&#39;|&#39;vertic&#39;) &#39;_&#39; (\d+) &#39;_&#39; (\d+) &#39;_&#39; (\d+) $/)&amp;gt;&amp;gt;.Str { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好吧，我分2次做了1/捕捉并测试匹配，2/将匹配转换为Str。&lt;/p&gt;
&lt;p&gt;没有得到及时的回答，完全没有改进。我也找不到一个好的方法来快速完成这个任务。事实上我花了一个小时才破解这个螺母。这里的主要问题是，一个失败的匹配会产生 &lt;code&gt;.Str&lt;/code&gt; 会抱怨的 Nil。所以让我们把 if 的布尔检查和转换为 Str 的过程分开。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my $a = &#39;1 B&#39;;

if $a ~~ /(&amp;lt;digit&amp;gt;) \s (&amp;lt;alpha&amp;gt;)/ -&amp;gt; $_ {
    my ($one, $B) = .deepmap: *.Str;
    say &amp;quot;$one $B&amp;quot;;
}
# OUTPUT: 1 B
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过将条件表达式的结果强行放入主题中，我们可以在匹配的结果上运行任何方法，但前提是 &lt;code&gt;Match.bool&lt;/code&gt; 返回 true。我没有 &lt;code&gt;CS*&lt;/code&gt; 学位，但如果 Raku-signatures 不会变成 turing complete，我会非常惊讶。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;if $a ~~ /(&amp;lt;digit&amp;gt;) \s (&amp;lt;alpha&amp;gt;)/ -&amp;gt; Match (Str() $one, Str() $B) {
    dd $one;
    dd $B;
}
# OUTPUT: &amp;quot;1&amp;quot;
          &amp;quot;B&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;if&lt;/code&gt; 块的签名将 &lt;code&gt;Match&lt;/code&gt; 胁迫为一个列表。我们选择其中的两个元素，并将这些元素胁迫为 &lt;code&gt;Str&lt;/code&gt;。当然，我们可以根据捕获的位置来强制到任何我们喜欢的东西。&lt;/p&gt;
&lt;p&gt;Raku 中的 Regexes 被编译成相同的字节码，然后程序的其余部分。事实上，语法只是一个具有有趣语法的类。这就是为什么我们可以轻松地在 regex  里面运行Raku 代码。这意味着我们可以把整个程序从内部翻出来。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my @a = &amp;lt;1 B 3 D 4&amp;gt;;
my @b;

my $hit;

for @a -&amp;gt; $e {
    @b.push: ($e ~~ /(&amp;lt;alpha&amp;gt;) || { next } /).Str;
}

say @b;
# OUTPUT: [B D]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这里，如果匹配不成功，我们就跳过 &lt;code&gt;.push&lt;/code&gt;，用 &lt;code&gt;next&lt;/code&gt; 跳过循环体的其余部分。我们可以在 &lt;code&gt;regex&lt;/code&gt; 内部发出任何控制异常。这意味着我们可以将整个过程粘在一个 &lt;code&gt;sub&lt;/code&gt; 中，然后从 &lt;code&gt;regex&lt;/code&gt; 中返回我们正在寻找的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub cherry-pick-numeric(Str $matchee) {
    $matchee ~~ m/(&amp;lt;digit&amp;gt;) &amp;amp;&amp;amp; { return .Numeric }/;
    Empty
}

@b = do .&amp;amp;cherry-pick-numeric for @a;

dd @b;
# OUTPUT: Array @b = [1, 3, 4]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Raku 已经酝酿了10年。这是一个巨大的任务。现在，困难的部分来了。我们必须从那庞大的语言中找到所有好的惯用法。好东西会降临到那些等待的人身上（IRC上）。&lt;/p&gt;
&lt;p&gt;*) 阅读。不要相信我写的任何东西。你已经被警告了。&lt;/p&gt;
&lt;p&gt;更新一下。&lt;/p&gt;
&lt;p&gt;我以真正的懒惰方式，想出了一个办法，在本该完成的工作之后，把匹配变成一个惰性列表。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;$a = &#39;1B3D4&#39;;

my \ll := gather $a ~~ m:g/
      [ &amp;lt;alpha&amp;gt; &amp;amp;&amp;amp; { take $/&amp;lt;alpha&amp;gt;.Str } ]
    | [ &amp;lt;digit&amp;gt; &amp;amp;&amp;amp; { take $/.&amp;lt;digit&amp;gt;.Numeric } ]
    | [ { say &#39;step&#39; } ]
/;
say ll[0];
say ll[3];
# OUTPUT: 1
          step
          step
          step
          D
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;技巧是用 &lt;code&gt;:g&lt;/code&gt; 副词强制匹配一直运行到字符串的末尾。这个运行将被 &lt;code&gt;take&lt;/code&gt; 打断（通过抛出 &lt;code&gt;CX::Take&lt;/code&gt;），当从 &lt;code&gt;gather&lt;/code&gt; 返回的 &lt;code&gt;Seq&lt;/code&gt; 中询问下一个值时再继续。我不知道这是否是有效的内存思想。可能会有一个 &lt;code&gt;Match&lt;/code&gt; 实例为每个 &lt;code&gt;take&lt;/code&gt; 保留在身边。&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&#34;https://gfldex.wordpress.com/2021/03/11/raku-is-a-match-for/&#34;&gt;https://gfldex.wordpress.com/2021/03/11/raku-is-a-match-for/&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/flink">Flink</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/flink">Flink</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/flink-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3">Flink 官方文档</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-03-12-raku-is-a-match-for-star/</guid>
                <pubDate>Fri, 12 Mar 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>BUILD 和 TWEAK 的区别</title>
                <link>https://ohmyweekly.github.io/notes/2021-03-07-difference-between-build-and-tweak-in-raku/</link>
                
                
                <description>&lt;blockquote&gt;Difference Between Build and Tweak in Raku&lt;/blockquote&gt;&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;class Student {
    has $.name;
    has $.sex;
    has $!age;

    method BUILD(:$!name) {

    }
}

my $stu = Student.new(:name(&#39;赵今麦&#39;), :sex(&#39;女&#39;));
dd $stu;
# Student $stu = Student.new(name =&amp;gt; &amp;quot;赵今麦&amp;quot;, sex =&amp;gt; Any)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你加上 &lt;code&gt;BUILD&lt;/code&gt; 方法, 你必须自己全权负责设置所有的东西。也就是既包括公共属性, 也包括私有属性。&lt;/p&gt;
&lt;p&gt;但你可以通过巧妙地命名参数来让你的生活更轻松。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;method BUILD (:$!name, :$!sex, :$!age) { }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;BUILD&lt;/code&gt; 方法可以初始化私有属性:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;class Student {
    has $.name;
    has $.sex;
    has $!age;

    method BUILD(:$name, :$sex, :$age) {
        $!name = $name;
        $!sex = $sex;
        $!age = $age;
    }

    method heart() { return &#39;♥ &#39; ~ $!age }
}

my $stu = Student.new(:name(&#39;赵今麦&#39;), :sex(&#39;女&#39;), :age(18));
dd $stu;
say $stu;
say $stu.heart(); 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以在 TWEAK 方法中初始化私有属性:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;class Student {
    has $.name;
    has $.sex;
    has $!age;

    method TWEAK(:$name, :$sex, :$age) {
        $!age = $age + 1;
    }

    method heart() { return &#39;♥&#39; ~ $!age }
}

my $stu = Student.new(:name(&#39;赵今麦&#39;), :sex(&#39;女&#39;), :age(18));
dd $stu;
say $stu;
say $stu.heart(); 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 &lt;code&gt;TWEAK&lt;/code&gt;，你会得到与 &lt;code&gt;BUILD&lt;/code&gt; 相同的参数，但所有的初始设置都已经完成了（&lt;code&gt;BUILD&lt;/code&gt; 或公共属性的自动绑定，以及所有的默认值，再加上保证所需值的存在）。你只是有机会做一些最后的调整。&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/raku">Raku</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/build">BUILD</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/tweak">TWEAK</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/object">Object</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-03-07-difference-between-build-and-tweak-in-raku/</guid>
                <pubDate>Sun, 07 Mar 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>Understanding Null Safety</title>
                <link>https://ohmyweekly.github.io/notes/2021-03-05-understanding-null-safety/</link>
                
                
                <description>&lt;blockquote&gt;Understanding Null Safety&lt;/blockquote&gt;&lt;p&gt;空值安全是我们在 Dart 2.0 中用&lt;a href=&#34;https://dart.dev/guides/language/type-system&#34;&gt;健全的静态类型系统&lt;/a&gt;取代了原来的不健全的可选类型系统后，对 Dart 做出的最大改变。当 Dart 刚推出的时候，编译时空安全是一个罕见的功能，需要长时间的介绍。今天，Kotlin、Swift、Rust 和其他语言都有自己的答案，这已经成为一个非常&lt;a href=&#34;https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/&#34;&gt;熟悉的问题&lt;/a&gt;。下面是一个例子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Without null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;isEmpty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;isEmpty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你在没有 null 安全的情况下运行这个 Dart 程序，它就会在调用.length 时抛出一个 NoSuchMethodError 异常。&lt;code&gt;null&lt;/code&gt; 值是 &lt;code&gt;Null&lt;/code&gt; 类的一个实例，而 Null 没有 &amp;ldquo;length&amp;rdquo; getter。运行时的失败很糟糕。这在像 Dart 这样的语言中尤其如此，因为它被设计成在终端用户的设备上运行。如果一个服务器应用程序失败了，你通常可以在任何人注意到之前重新启动它。但是当一个 Flutter 应用在用户的手机上崩溃时，他们并不高兴。当你的用户不高兴时，你也不高兴。&lt;/p&gt;
&lt;p&gt;开发者喜欢像 Dart 这样的静态类型语言，因为它们可以让类型检查器在编译时发现代码中的错误，通常就在 IDE 中。越早发现错误，就能越早修复它。当语言设计者谈论 &amp;ldquo;修复空值引用错误&amp;quot;时，他们的意思是丰富静态类型检查器，使语言能够检测到像上面试图在一个可能是空的值上调用 &lt;code&gt;.length&lt;/code&gt; 这样的错误。&lt;/p&gt;
&lt;p&gt;对于这个问题，没有一个真正的解决方案。Rust 和 Kotlin 都有自己的方法，在这些语言的上下文中是有意义的。这个文档详细介绍了我们对 Dart 的答案。它包括对静态类型系统的修改，以及一系列其他的修改和新的语言特性，让你不仅能写出空值安全的代码，而且希望能享受这样做的乐趣。&lt;/p&gt;
&lt;p&gt;这个文档很长。如果你想看一些较短的文件，它只涵盖了你需要知道的东西，以便开始运行，请从&lt;a href=&#34;https://dart.dev/null-safety&#34;&gt;概述&lt;/a&gt;开始。当你准备好了更深入的理解，并且有时间的时候，请回到这里，这样你就可以理解这个语言是如何处理 &lt;code&gt;null&lt;/code&gt; 的，为什么我们要这样设计它，以及如何写出习惯的，现代的，空值安全的 Dart。(Spoiler alert: 它最终会出人意料地接近你今天写 Dart 的方式。)&lt;/p&gt;
&lt;p&gt;语言处理空值引用错误的各种方法各有优缺点。这些原则指导了我们的选择。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码默认情况下应该是安全的。如果你写了新的 Dart 代码，并且没有使用任何显式的不安全特性，它永远不会在运行时抛出一个空值引用错误。所有可能的空值引用错误都会被静态地捕获。如果你想将一些检查推迟到运行时以获得更大的灵活性，你可以，但你必须通过使用一些在代码中文本可见的功能来选择。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;换句话说，我们并不是给你一件救生衣，让你每次出海时都记得穿上它。相反，我们给你一艘不沉的船。除非你跳海，否则你会保持干燥。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空值安全代码应该很容易写。大多数现有的 Dart 代码都是动态正确的，不会出现空值引用错误。你喜欢你的 Dart 程序现在的样子，我们希望你能够继续这样写代码。安全性不应该要求牺牲可用性，对类型检查器进行忏悔，或者必须显著改变你的思维方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此产生的空安全代码应该是完全健全的。在静态检查的上下文中，&amp;ldquo;健全&amp;quot;对不同的人意味着不同的东西。对我们来说，在空值安全的上下文中，这意味着如果一个表达式的静态类型不允许空，那么该表达式的任何可能的执行都不可能评估为空。语言主要通过静态检查来提供这种保证，但也可以涉及一些运行时检查。虽然，注意第一个原则：任何发生这些运行时检查的地方都将是你的选择）。&lt;/p&gt;
&lt;p&gt;健全性对于用户的信心很重要。一艘大部分时间都保持漂浮的船，并不是你热衷于在公海上冒险的船。但它对我们无畏的编译器黑客来说也很重要。当语言对程序的语义属性做出硬性保证时，意味着编译器可以执行假设这些属性为真的优化。当涉及到 &lt;code&gt;null&lt;/code&gt; 时，这意味着我们可以生成更小的代码，消除不需要的 &lt;code&gt;null&lt;/code&gt; 检查，以及更快的代码，不需要在调用方法之前验证接收器是非 null。&lt;/p&gt;
&lt;p&gt;有一个注意事项：我们只保证完全空值安全的 Dart 程序的健全性。Dart 支持包含新的空值安全代码和旧的遗留代码混合的程序。在这些混合版本的程序中，仍然可能发生空值引用错误。在一个混合版本的程序中，你可以在空值安全的部分获得所有的静态安全优势，但是在整个应用程序是空安全的之前，你不能获得完整的运行时健全性。&lt;/p&gt;
&lt;p&gt;请注意，消除 &lt;code&gt;null&lt;/code&gt; 并不是一个目标。&lt;code&gt;null&lt;/code&gt; 没有什么不好。相反，能够表示一个值的缺失真的很有用。直接在语言中构建对特殊的 &amp;ldquo;absence&amp;rdquo; 值的支持，使得处理缺失的工作变得灵活和可用。它是可选参数、方便的 &lt;code&gt;?.&lt;/code&gt; null-aware 操作符和默认初始化的基础。并不是 null 不好，而是让 null 去了你想不到的地方才会引起问题。&lt;/p&gt;
&lt;p&gt;因此，有了 null 安全，我们的目标是让你控制和洞察 null 可以流经你的程序的地方，并确定它不能流到某个地方，从而导致崩溃。&lt;/p&gt;
&lt;h2 id=&#34;类型系统中的空值&#34;&gt;类型系统中的空值&lt;/h2&gt;
&lt;p&gt;空值安全始于静态类型系统，因为其他一切都建立在静态类型系统之上。你的 Dart 程序中有一个完整的类型宇宙：像 int 和 String 这样的基元类型，像 List 这样的集合类型，以及所有你和你使用的包所定义的类和类型。在 null 安全之前，静态类型系统允许值 null 流入任何这些类型的表达式中。&lt;/p&gt;
&lt;p&gt;在类型理论的行话中，Null 类型被视为所有类型的一个子类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dart.dev/null-safety/understanding-null-safety/hierarchy-before.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;在某些表达式上允许的操作集 - getters、setters、methods 和 operator - 由其类型定义。如果类型是 List，你可以对它调用. &lt;code&gt;add()&lt;/code&gt; 或 &lt;code&gt;[]&lt;/code&gt;。如果它是 int，你可以调用 &lt;code&gt;+&lt;/code&gt;。但是空值并没有定义任何这些方法。允许 null 流入其他类型的表达式意味着任何这些操作都可能失败。这就是 null 引用错误的真正症结所在 - 每一次失败都来自于试图在 null 上查找一个它没有的方法或属性。&lt;/p&gt;
&lt;h2 id=&#34;非可空类型和可空类型&#34;&gt;非可空类型和可空类型&lt;/h2&gt;
&lt;p&gt;Null 安全通过改变类型层次结构，从根本上消除了这个问题。Null 类型仍然存在，但它不再是所有类型的子类型。取而代之的是，类型层次结构是这样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dart.dev/null-safety/understanding-null-safety/hierarchy-after.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于 Null 不再是子类型, 除了特殊的 &lt;code&gt;Null&lt;/code&gt; 类之外，没有任何类型允许值为 null。我们已经将所有类型默认为不可空值。如果你有一个 String 类型的变量，它将总是包含一个字符串。在那里，我们已经修复了所有的空值引用错误。&lt;/p&gt;
&lt;p&gt;如果我们认为 null 根本没有用，我们可以在这里停止。但是 null 是有用的，所以我们仍然需要一种方法来处理它。可选参数就是一个很好的说明性案例。考虑一下这个 null 安全的 Dart 代码。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;makeCoffee&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;coffee&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dairy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dairy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;coffee&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt; with &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dairy&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Black &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;coffee&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里，我们希望允许 dairy 参数接受任何字符串，或者接受 null 值，而不接受其他任何值。为了表达这一点，我们在底层基类型 String 的结尾处加上 &lt;code&gt;?&lt;/code&gt;。 从本质上讲，这就是定义了一个底层类型和 Null 类型的&lt;a href=&#34;https://en.wikipedia.org/wiki/Union_type&#34;&gt;联合&lt;/a&gt;。所以，如果 Dart 有全功能的联合类型，那么 &lt;code&gt;String?&lt;/code&gt; 将是 &lt;code&gt;String|Null&lt;/code&gt; 的简写。&lt;/p&gt;
&lt;h2 id=&#34;使用可空类型&#34;&gt;使用可空类型&lt;/h2&gt;
&lt;p&gt;如果你有一个可空类型的表达式，你可以用这个结果做什么？由于我们的原则默认是安全的，所以答案是不多，我们不能让你对它调用底层类型的方法，因为如果值是空的，这些方法可能会失败。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Hypothetical unsound null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bad&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maybeString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maybeString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;bad&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果我们让你运行它，就会崩溃。我们唯一可以安全地让你访问的方法和属性是由底层类型和 Null 类定义的。那就是 &lt;code&gt;toString()&lt;/code&gt;、&lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;hashCode&lt;/code&gt;。因此，你可以使用可空类型作为映射键，将它们存储在集合中，将它们与其他值进行比较，并在字符串插值中使用它们，但仅此而已。&lt;/p&gt;
&lt;p&gt;它们如何与非可空类型交互？将一个不可空值类型传递给期望空值类型的东西总是安全的。如果一个函数接受 String 吗，那么传递一个 String 是允许的，因为它不会引起任何问题。我们通过使每个可空类型成为其底层类型的超类型来建立模型。你也可以安全地把 null 传给期望是可空类型的东西，所以 Null 也是每个可空类型的一个子类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dart.dev/null-safety/understanding-null-safety/nullable-hierarchy.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是反过来说，把一个可空类型传递给期待底层非可空类型的东西是不安全的。期待一个 String 的代码可以在值上调用 String 方法。如果你把一个 &lt;code&gt;String?&lt;/code&gt; 传给它，null 可能会流进来，这可能会失败。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Hypothetical unsound null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;requireStringNotNull&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;definitelyString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;definitelyString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maybeString&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// Or not!
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;requireStringNotNull&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maybeString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个程序不安全，我们不应该允许它。然而，Dart 一直有这个东西，叫做隐式下传。例如，如果你把一个 Object 类型的值传递给一个期望为 String 的函数，类型检查器就会允许它。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Without null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;requireStringNotObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;definitelyString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;definitelyString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maybeString&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;it is&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;requireStringNotObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maybeString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了保持合理性，编译器在 requireStringNotObject() 的参数上默默地插入了一个 &lt;code&gt;as String&lt;/code&gt; cast。这个转码可能会在运行时失败并抛出一个异常，但在编译时，Dart 说这是确定的。由于非可空类型被建模为可空类型的子类型，所以隐式下投会让你把一个 &lt;code&gt;String?&lt;/code&gt; 传递给期待一个 String 的东西。允许这样做会违反我们默认安全的目标。所以，有了空值安全，我们就完全取消了隐式下传。&lt;/p&gt;
&lt;p&gt;这使得对 requireStringNotNull() 的调用会产生一个编译错误，这是你想要的。但这也意味着所有的隐式下包都会成为编译错误，包括对 requireStringNotObject() 的调用。你必须自己添加显式下传。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;requireStringNotObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;definitelyString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;definitelyString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maybeString&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;it is&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;requireStringNotObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maybeString&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们认为这总体上是一个好的变化。在我们的印象中，大多数用户从来都不喜欢隐性降频。尤其是，你可能之前就被这个烧过。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Without null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filterEvens&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;where&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isEven&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;发现错误了吗？&lt;code&gt;.where()&lt;/code&gt; 方法是懒惰的，所以它返回的是一个 Iterable，而不是 List。这个程序在编译时，当它试图将 Iterable 投射到 filterEvens 声明它返回的 List 类型时，会在运行时抛出一个异常。移除隐式下投后，这就变成了一个编译错误。&lt;/p&gt;
&lt;p&gt;我们说到哪里了？对了，好吧，就好像我们把你程序中的类型宇宙分成了两半。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dart.dev/null-safety/understanding-null-safety/bifurcate.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;有一个非空值类型的区域。这些类型让你可以访问所有有趣的方法，但永远不能包含 null。然后是一个由所有相应的可空类型组成的平行家族。这些类型允许 null，但你不能对它们做太多事情。我们让值从非可空侧流向可空侧，因为这样做是安全的，但不是其他方向。&lt;/p&gt;
&lt;p&gt;这样看来，可空类型基本上是无用的。它们没有方法，你无法摆脱它们。别担心，我们有一整套的功能来帮助你把值从可空型的一半移到另一边，我们很快就会讲到。&lt;/p&gt;
&lt;p&gt;顶部和底部
这一部分有点深奥。你可以跳过它，除了最后的两个子弹，除非你对类型系统感兴趣。想象一下，在你的程序中，所有的类型之间都有边缘，它们是彼此的子类型和超类型。如果你把它画出来，就像这个文档中的图一样，它将形成一个巨大的有向图，上面有像 Object 这样的超类型，下面有像你自己的类型这样的叶子类。&lt;/p&gt;
&lt;p&gt;如果这个有向图到了顶部，有一个单一的类型是超类型（直接或间接），这个类型就被称为顶部类型。同样，如果在那个底部有一个奇怪的类型是每个类型的子类型，你就有一个底部类型。在这种情况下，你的有向图是一个网格）。&lt;/p&gt;
&lt;p&gt;如果你的类型系统有顶层和底层类型，那是很方便的，因为这意味着像最小上界这样的类型级操作（类型推理使用它来根据一个条件表达式的两个分支的类型找出它的类型）总是可以产生一个类型。在 null 安全之前，Object 是 Dart 的顶层类型，Null 是其底层类型。&lt;/p&gt;
&lt;p&gt;由于现在 Object 是不可空的，所以它不再是顶类型。Null 不是它的子类型。Dart 没有命名的顶类型。如果你需要一个顶类型，你要 Object? 同样，Null 也不再是底层类型。如果是的话，一切都还会是 null。相反，我们添加了一个新的底层类型，名为 Never。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dart.dev/null-safety/understanding-null-safety/top-and-bottom.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;在实践中，这意味着。&lt;/p&gt;
&lt;p&gt;如果你想表明你允许任何类型的值，就用 Object? 而不是 Object. 事实上，使用 Object 就变得很不寻常了，因为该类型意味着 &amp;ldquo;可能是任何可能的值，除了这个奇怪的禁止值 null&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;在极少数情况下，你需要一个底层类型，用 Never 代替 Null。如果你不知道是否需要底层类型，你可能不需要。&lt;/p&gt;
&lt;h2 id=&#34;确保正确性&#34;&gt;确保正确性&lt;/h2&gt;
&lt;p&gt;我们将类型的宇宙分为可空和不可空的两半。为了保持健全性和我们的原则，即除非你要求，否则你永远不会在运行时得到一个 null 引用错误，我们需要保证 null 永远不会出现在非 nullable 端的任何类型中。&lt;/p&gt;
&lt;p&gt;摆脱隐式下传，去掉 Null 这个底层类型，涵盖了类型在程序中跨赋值流转和在函数调用中从参数流转到参数的所有主要地方。剩下的主要的 null 可以潜入的地方是当一个变量第一次出现和离开一个函数的时候。所以会出现一些额外的编译错误。&lt;/p&gt;
&lt;h3 id=&#34;无效返回&#34;&gt;无效返回&lt;/h3&gt;
&lt;p&gt;如果一个函数的返回类型是非空的，那么通过该函数的每一条路径都必须到达一个返回值的返回语句。在 null 安全之前，Dart 对于缺失返回的情况非常宽松。比如说&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Without null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;missingReturn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// No return.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你分析这个，你就会得到一个温柔的提示，也许你忘了一个返回，但如果没有，也没什么大不了的。这是因为如果执行到了函数体的末端，那么 Dart 就会隐式返回 null。由于每个类型都是可空的，所以从技术上讲，这个函数是安全的，尽管它可能不是你想要的。&lt;/p&gt;
&lt;p&gt;对于健全的非可空类型，这个程序是完全错误的，不安全的。在空值安全下，如果一个具有非可空值返回类型的函数不能可靠地返回一个值，你会得到一个编译错误。所谓 &amp;ldquo;可靠&amp;rdquo;，是指语言分析了所有通过函数的控制流路径。只要它们都能返回一些东西，它就满足了。这个分析是相当聪明的，所以即使这个函数也是可以的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;alwaysReturns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;zero&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ArgumentError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Negative values not allowed.&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;big&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;toString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们将在下一节更深入地研究新的流程分析。&lt;/p&gt;
&lt;h3 id=&#34;未初始化的变量&#34;&gt;未初始化的变量&lt;/h3&gt;
&lt;p&gt;当你声明一个变量时，如果你没有给它一个显式的初始化器，Dart 默认用 null 初始化变量。这很方便，但如果变量的类型是不可空的，显然是完全不安全的。所以我们必须对不可空值的变量进行严格的规定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶级变量和静态字段的声明必须有一个初始化器。由于这些变量可以在程序中的任何地方被访问和赋值，编译器不可能保证变量在被使用之前就已经被赋予了一个值。唯一安全的选择是要求声明本身有一个初始化表达式，产生一个正确类型的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;topLevel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;SomeClass&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;staticField&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;实例字段必须在声明时有一个初始化器，使用初始化形式，或者在构造函数的初始化列表中初始化。这有很多行话。下面是例子。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;SomeClass&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;atDeclaration&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;initializingFormal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;initializationList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;n&#34;&gt;SomeClass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initializingFormal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;initializationList&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;换句话说，只要字段在到达构造函数体之前就有一个值，就可以了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部变量是最灵活的情况。一个不可空的局部变量不需要有一个初始化器。这完全可以。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tracingFibonacci&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tracingFibonacci&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tracingFibonacci&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;规则只是局部变量在使用前必须肯定分配。我们也可以依靠我所提到的新流分析来实现。只要每个通往变量使用的路径都先初始化它，使用就可以了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可选参数必须有一个默认值。如果你没有为一个可选的位置参数或命名参数传递一个参数，那么语言就会用默认值来填充它。如果你不指定默认值，那么默认的默认值就是 null，如果参数的类型是不可空的，那就飞不起来了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，如果你想让一个参数是可选的，你需要让它变成 null，或者指定一个有效的非空的默认值。&lt;/p&gt;
&lt;p&gt;这些限制听起来很繁琐，但在实践中并不太坏。它们与现有的围绕最终变量的限制非常相似，而且你可能已经使用这些限制多年，甚至没有真正注意到。另外，请记住，这些限制只适用于不可空值的变量。你总是可以让类型可空，然后让默认初始化为空。&lt;/p&gt;
&lt;p&gt;即便如此，这些规则也会造成摩擦。幸运的是，我们有一套新的语言特性来润滑最常见的模式，在这些新的限制下，你的速度变慢了。不过，首先，是时候谈谈流分析了。&lt;/p&gt;
&lt;h2 id=&#34;流程分析&#34;&gt;流程分析&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Control_flow_analysis&#34;&gt;控制流分析&lt;/a&gt;在编译器中已经存在多年。它大多被用户隐藏起来，在编译器优化过程中使用，但一些新的语言已经开始使用同样的技术来实现可见的语言功能。Dart 已经在类型推广的形式下有了一抹流分析。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// With (or without) null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;isEmptyList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;object&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isEmpty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// &amp;lt;-- OK!
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;请注意，在标记行中，我们可以在对象上调用 isEmpty。该方法定义在 List 上，而不是 Object 上。这是因为类型检查器会查看程序中所有的 is 表达式和控制流路径。如果某个控制流构造体只有在变量上的某个 is 表达式为真时才会执行，那么在这个构造体里面，变量的类型就会被 &amp;ldquo;推广 &amp;ldquo;到测试类型。&lt;/p&gt;
&lt;p&gt;在这里的例子中，if 语句的 then 分支只有在 object 实际包含一个 list 时才会运行。因此，Dart 将对象推广到 List 类型，而不是其声明的 Object 类型。这是一个方便的功能，但它是相当有限的。在 null 安全之前，下面的功能相同的程序无法工作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Without null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;isEmptyList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;object&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isEmpty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// &amp;lt;-- Error!
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同样，只有当对象包含一个 list 时，才能达到.isEmpty 的调用，所以这个程序是动态正确的。但是类型推广规则不够聪明，没有看到返回语句意味着只有当对象是一个 list 时才能到达第二个语句。&lt;/p&gt;
&lt;p&gt;对于空安全，我们把这种有限的分析方法，在几个方面做得更加强大。&lt;/p&gt;
&lt;h3 id=&#34;可到达性分析&#34;&gt;可到达性分析&lt;/h3&gt;
&lt;p&gt;首先，我们修复了&lt;a href=&#34;https://github.com/dart-lang/sdk/issues/18921&#34;&gt;长期以来的抱怨&lt;/a&gt;，即类型推广对早期返回和其他无法到达的代码路径并不聪明。当分析一个函数时，它现在会考虑到返回、break、抛出以及函数中任何其他可能提前终止执行的方式。在空安全下，这个函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;isEmptyList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;object&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isEmpty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在是完全有效的。因为 if 语句会在对象不是 List 时退出函数，所以 Dart 会在第二条语句中促进对象成为 List。这是一个非常好的改进，它帮助了很多 Dart 代码，甚至是与 nullability 无关的东西。&lt;/p&gt;
&lt;h3 id=&#34;never---不可达到的代码&#34;&gt;Never - 不可达到的代码&lt;/h3&gt;
&lt;p&gt;您也可以对这种可达到性分析进行编程。新的底类型 Never 没有值。(什么样的值同时是 String、bool 和 int 呢？)那么一个表达式具有 Never 类型意味着什么呢？意味着该表达式永远不能成功完成评估。它必须抛出一个异常，中止，或者以其他方式确保期望表达式结果的周围代码永远不会运行。&lt;/p&gt;
&lt;p&gt;事实上，根据语言的规定，抛出表达式的静态类型是 Never。Never 类型在核心库中被声明，你可以将其作为类型注释。也许你有一个帮助函数，以方便抛出某种异常。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Never&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wrongType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ArgumentError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Expected &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;, but was &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;runtimeType&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;.&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可以这样使用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Point&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;operator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;other&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Point&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wrongType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Point&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;other&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;// Constructor and hashCode...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个程序分析起来没有错误。请注意，==方法的最后一行访问了其他的.x 和.y。尽管函数没有任何返回或抛出，但它已经被提升为 Point。控制流分析知道，wrongType()的声明类型是 Never，这意味着 if 语句的 then 分支必须以某种方式中止。由于第二条语句只有在 other 是 Point 时才能到达，所以 Dart 提倡使用它。&lt;/p&gt;
&lt;p&gt;换句话说，在你自己的 API 中使用 Never 可以让你扩展 Dart 的可达性分析。&lt;/p&gt;
&lt;h3 id=&#34;确定赋值分析&#34;&gt;确定赋值分析&lt;/h3&gt;
&lt;p&gt;这个我简单的提到了局部变量。Dart 需要确保一个不可空的局部变量在读取之前总是被初始化。我们使用确定赋值分析来尽可能灵活地处理这个问题。该语言分析每个函数体，并通过所有控制流路径跟踪局部变量和参数的赋值。只要在每一条到达某个使用变量的路径上都对变量进行了赋值，就认为该变量已经初始化。这让你可以在没有初始化器的情况下声明一个变量，然后在之后使用复杂的控制流对其进行初始化，即使该变量具有不可空值的类型。&lt;/p&gt;
&lt;p&gt;我们还使用确定赋值分析来使最终变量更加灵活。在空安全之前，如果你需要以任何一种有趣的方式对局部变量进行初始化，那么使用 final 是很困难的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tracingFibonacci&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tracingFibonacci&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tracingFibonacci&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这将是一个错误，因为结果变量是 final，但没有初始化器。在空安全下进行更智能的流分析，这个程序是没有问题的。分析可以知道，在每条控制流路径上，result 肯定是精确地初始化了一次，所以标记变量 final 的约束条件是满足的。&lt;/p&gt;
&lt;h3 id=&#34;对空检查的类型提升&#34;&gt;对空检查的类型提升&lt;/h3&gt;
&lt;p&gt;更加智能的流程分析帮助了很多 Dart 代码，甚至是与空性无关的代码。但我们现在做这些改变并不是偶然的。我们把类型分为可空性和非可空性集。如果你有一个可空类型的值，你就不能真正对它做任何有用的事情。在值为空的情况下，这种限制是好的。它可以防止你崩溃。&lt;/p&gt;
&lt;p&gt;但如果值不是空的，能够把它移到非可空的一面，这样你就可以对它调用方法，这将是一件好事。对于局部变量和参数来说，流程分析是实现这一点的主要方法之一。我们已经扩展了类型提升，还可以查看 &lt;code&gt;== null&lt;/code&gt; 和 &lt;code&gt;!= null&lt;/code&gt; 表达式。&lt;/p&gt;
&lt;p&gt;如果你检查一个可空类型的变量，看看它是不是空的，Dart 就会把这个变量推广到底层的非可空类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;makeCommand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;executable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arguments&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;executable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arguments&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arguments&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里，arguments 有一个可空的类型。通常，这禁止你对它调用.join()。但是由于我们在 if 语句中对该调用进行了保护，检查以确保该值不是空的，所以 Dart 将其从  &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 提升为 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;，并允许你在其上调用方法或将其传递给期望非空值列表的函数。&lt;/p&gt;
&lt;p&gt;这听起来是一件相当小的事情，但这种基于流程的对 null 检查的推广是使大多数现有 Dart 代码在 null 安全下工作的原因。大多数 Dart 代码都是动态正确的，并且确实通过在调用方法之前检查空值来避免抛出空值引用错误。新的关于 null 检查的流程分析将这种动态正确性变成了可证明的静态正确性。&lt;/p&gt;
&lt;p&gt;当然，它也能配合我们对可到达性的更智能的分析。上面的函数也可以写成一样。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;makeCommand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;executable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arguments&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;executable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arguments&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arguments&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;语言也比较聪明，什么样的表达方式会引起推广。显式 &lt;code&gt;== null&lt;/code&gt; 或 &lt;code&gt;!= null&lt;/code&gt; 当然可以。但是，使用 as、assignments 或我们即将提到的后缀 &lt;code&gt;!&lt;/code&gt; 操作符的显式投掷也会导致提升。总的目标是，如果代码是动态正确的，而且静态地找出这一点是合理的，分析应该足够聪明。&lt;/p&gt;
&lt;h3 id=&#34;不必要的代码警告&#34;&gt;不必要的代码警告&lt;/h3&gt;
&lt;p&gt;拥有更智能的可达性分析，并知道 null 可能流经你的程序的地方，有助于确保你添加代码来处理 null。但我们也可以用同样的分析来检测你不需要的代码。在 null 安全之前，如果你写了这样的东西。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;checkList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isEmpty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Got nothing&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Got something&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Dart 没有办法知道那个 &lt;code&gt;null-aware?&lt;/code&gt; 操作符是否有用。它只知道，你可以把 null 传给函数。但是在 null safe Dart 中，如果你用现在不可空的 List 类型注释了那个函数，那么它知道 list 永远不会是 null。这就意味着这个 &lt;code&gt;?.&lt;/code&gt; 永远不会做任何有用的事情，你可以而且应该只使用 &lt;code&gt;.&lt;/code&gt; 类型。&lt;/p&gt;
&lt;p&gt;为了帮助你简化你的代码，我们已经为这样的不必要的代码添加了警告，现在静态分析已经精确到可以检测到它了。在一个不可空类型上使用一个 null-aware 操作符，甚至是像&lt;code&gt;== null&lt;/code&gt; 或 &lt;code&gt;!= null&lt;/code&gt; 这样的检查，都会被报告为一个警告。&lt;/p&gt;
&lt;p&gt;当然，这也与非空类型的晋升有关。一旦一个变量被推广到一个不可空类型，如果你再次对它进行多余的 null 检查，你会得到一个警告。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;checkList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;No list&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isEmpty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Empty list&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Got something&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你在这里得到了一个警告，因为在它执行的时候，我们已经知道 list 不能为空。这些警告的目的不仅仅是清理无意义的代码。通过删除不需要的 null 检查，我们确保剩下的有意义的检查能够脱颖而出。我们希望您能够查看您的代码，并看到 null 可以在哪里流动。&lt;/p&gt;
&lt;h2 id=&#34;使用可空类型-1&#34;&gt;使用可空类型&lt;/h2&gt;
&lt;p&gt;我们现在已经把 null 收进了可空类型的集合。通过流程分析，我们可以安全地让一些非空值越过栅栏跳到非可空类型的一边，在那里我们可以使用它们。这是一个很大的进步，但如果我们在这里停下来，所产生的系统仍然是痛苦的限制。流程分析只对局部和参数有帮助。&lt;/p&gt;
&lt;p&gt;为了尽量恢复 Dart 在 null 安全之前的灵活性&amp;ndash;并且在某些地方超越它，我们有一些其他的新特性。&lt;/p&gt;
&lt;h3 id=&#34;更加智能的空感知方法&#34;&gt;更加智能的空感知方法&lt;/h3&gt;
&lt;p&gt;Dart 的 null aware 操作符 &lt;code&gt;?.&lt;/code&gt; 比 null safety 更早。运行时语义规定，如果接收者为空，那么右侧的属性访问将被跳过，表达式评价为空。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Without null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;notAString&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;notAString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这不是抛出一个异常，而是打印 &amp;ldquo;null&amp;rdquo;。null-aware 操作符是一个很好的工具，它使可空类型在 Dart 中可用。虽然我们不能让你在可空类型上调用方法，但我们可以也确实让你在它们上使用 null-aware 操作符。空值后安全版本的程序是。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;notAString&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;notAString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它的工作原理和之前的一样。&lt;/p&gt;
&lt;p&gt;然而，如果你曾经在 Dart 中使用过 null-aware 操作符，当你在方法链中使用它们时，你可能会遇到一个烦恼。比方说，你想看看一个可能不存在的字符串的长度是否是一个偶数（不是一个特别现实的问题，我知道，但请和我一起工作）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;notAString&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;notAString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isEven&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即使这个程序使用了?，但在运行时还是会抛出一个异常。问题在于.isEven 表达式的接收者是它左边的整个 notAString?.length 表达式的结果。该表达式的值为 null，所以我们在尝试调用.isEven 时得到一个空值引用错误。如果你曾经在 Dart 中使用过?.，你可能学到了一个苦涩的方法，那就是在你使用过一次之后，你必须将 null-aware 操作符应用到链中的每个属性或方法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;notAString&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;notAString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isEven&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这很烦人，但更糟糕的是，它掩盖了重要信息。考虑一下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;showGizmo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thing&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thing&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;doohickey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gizmo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我有个问题要问你。Thing 上的 doohickey getter 可以返回 null 吗？看起来可以，因为你在结果上使用了?。但可能只是第二个?.只是为了处理 thing 为 null 的情况，而不是 doohickey 的结果。你无法判断。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们借鉴了 C#设计相同功能的一个聪明的想法。当你在一个方法链中使用一个 null-aware 操作符时，如果接收者评估为 null，那么整个方法链的其余部分都会被短路并跳过。这意味着如果 doohickey 有一个不可空的返回类型，那么你可以也应该写。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;showGizmo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thing&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thing&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;doohickey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gizmo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;事实上，如果你不这样做，你会在第二个?上得到一个不必要的代码警告。如果你看到这样的代码。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;showGizmo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thing&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;thing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thing&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;doohickey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gizmo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么你就可以肯定地知道，这意味着 doohickey 本身有一个可空的返回类型。每一个?对应一个可以导致 null 流入方法链的唯一路径。这使得方法链中的 null-aware 操作符既更简洁又更精确。&lt;/p&gt;
&lt;p&gt;在这时，我们又增加了几个其他的空感知操作符。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// Null-aware cascade:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;receiver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Null-aware index operator:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;receiver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;没有一个 null-aware 函数调用操作符，但你可以写。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Allowed with or without null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arg1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arg2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;null-断言运算符&#34;&gt;Null 断言运算符&lt;/h3&gt;
&lt;p&gt;使用流式分析将一个可空型变量移到非可空型变量的伟大之处在于，这样做被证明是安全的。你可以在之前的可空型变量上调用方法，而不会放弃非可空型的任何安全或性能。&lt;/p&gt;
&lt;p&gt;但是，可空类型的许多有效用途无法以取悦静态分析的方式证明其安全性。比如说&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety, incorrectly:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;HttpResponse&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;n&#34;&gt;HttpResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ok&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;HttpResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;notFound&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;404&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Not found&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;toString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;OK&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;ERROR &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt; &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;toUpperCase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你尝试运行这个，你在调用 toUpperCase()时得到一个编译错误。错误字段是可空的，因为它在成功的响应中不会有一个值。我们通过检查类可以看到，当错误信息为空时，我们永远不会访问它。但这需要理解代码的值和错误的可空性之间的关系。类型检查器是看不到这种联系的。&lt;/p&gt;
&lt;p&gt;换句话说，我们这些代码的人类维护者知道错误在我们使用它的时候不会是空的，我们需要一种方法来断言这一点。通常情况下，你使用 as cast 来断言类型，在这里你也可以做同样的事情。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;toString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;OK&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;ERROR &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt; &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;toUpperCase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果投递失败，将错误地投递到不可空的 String 类型，会抛出一个运行时异常。否则，它将为我们提供一个非空值字符串，我们可以在其上调用方法。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;投弃可空性 &amp;ldquo;经常出现，以至于我们有了一种新的速记语法。一个后缀的感叹号 (!) 将左边的表达式并将其投射到其底层的不可空类型上。所以上面的函数相当于&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;toString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;OK&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;ERROR &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt; &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;toUpperCase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当底层类型是啰嗦的时候，这个单字符的 &amp;ldquo;bang 操作符 &amp;ldquo;特别方便。如果仅仅为了从某个类型中投弃一个单一的?，而不得不写成 Map&amp;lt;TransactionProviderFactory, List&amp;lt;Set&lt;!-- raw HTML omitted --&gt;&amp;gt;，那就真的很烦人了。&lt;/p&gt;
&lt;p&gt;当然，就像任何投射一样，使用 !的同时也会损失静态安全。必须在运行时检查投射以保持合理性，而且可能会失败并抛出一个异常。但是你可以控制这些转码被插入的位置，你可以通过查看你的代码随时看到它们。&lt;/p&gt;
&lt;h3 id=&#34;late-变量&#34;&gt;Late 变量&lt;/h3&gt;
&lt;p&gt;类型检查器不能证明代码安全的最常见的地方是围绕顶层变量和字段。下面是一个例子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety, incorrectly:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Coffee&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;heat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;hot&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;chill&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;iced&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;serve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39; coffee&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;coffee&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Coffee&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;coffee&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;heat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;coffee&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;serve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里，heat()方法是在服务()之前调用的。这意味着 _temperature 在使用之前会被初始化为一个非空值。但是静态分析来确定这一点是不可行的。(对于像这个微不足道的例子来说可能是可行的，但是一般情况下，试图跟踪一个类的每一个实例的状态是难以解决的。)。&lt;/p&gt;
&lt;p&gt;因为类型检查器不能分析字段和顶层变量的用途，它有一个保守的规则，即不可空值字段必须在声明时初始化（或者在实例字段的构造函数初始化列表中）。所以 Dart 在这个类上报告了一个编译错误。&lt;/p&gt;
&lt;p&gt;你可以通过使字段可空，然后在用途上使用 null 断言操作符来修复这个错误。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Coffee&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;heat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;hot&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;chill&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;iced&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;serve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39; coffee&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样做很好，但它给类的维护者发出了一个混乱的信号。但它给类的维护者发出了一个混乱的信号。通过标记 _temperature 为 nullable，你暗示 null 对于该字段来说是一个有用的、有意义的值。但这不是我们的目的。_temperature 字段永远不应该在其 null 状态下被观察到。&lt;/p&gt;
&lt;p&gt;为了处理常见的延迟初始化的状态模式，我们添加了一个新的修饰符 late。你可以像这样使用它。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Coffee&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;late&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;heat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;hot&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;chill&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;iced&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;serve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39; coffee&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;请注意，_temperature 字段的类型不可空，但没有初始化。另外，在使用它的时候也没有明确的空断言。有一些模型可以应用到迟到的语义中，但我是这样想的。晚期修饰符的意思是 &amp;ldquo;在运行时执行这个变量的约束，而不是在编译时执行&amp;rdquo;。这几乎就像 &amp;ldquo;late &amp;ldquo;这个词描述的是什么时候执行变量的保证。&lt;/p&gt;
&lt;p&gt;在这种情况下，由于该字段还没有确定初始化，所以每次读取该字段时，都会插入一个运行时检查，以确保它已经被分配了一个值。如果没有，就会抛出一个异常。给变量类型为 String 意味着 &amp;ldquo;你应该永远不会看到我的值不是字符串&amp;rdquo;，而后期修饰符意味着 &amp;ldquo;在运行时验证&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;在某些方面，迟到修饰符比使用? &amp;ldquo;神奇&amp;rdquo;，因为对字段的任何使用都可能失败，而且在使用现场没有任何文字可见。但你确实必须在声明处写晚期才能得到这种行为，我们的信念是，在那里看到修饰符已经足够明确，这一点是可以维护的。&lt;/p&gt;
&lt;p&gt;作为回报，你可以得到比使用可空类型更好的静态安全。因为现在字段的类型是非可空的，所以试图将 null 或可空的 String 分配给字段是一个编译错误。晚期修饰符可以让你推迟初始化，但仍然禁止你把它当作一个可空变量来处理。&lt;/p&gt;
&lt;h3 id=&#34;惰性初始化&#34;&gt;惰性初始化&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;late&lt;/code&gt; 修饰符也有一些其他的特殊能力。这可能看起来很矛盾，但你可以在一个有初始化器的字段上使用 late。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Weather&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;late&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_readThermometer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当你这样做的时候，初始化器会变得懒惰。它不是在实例构造完成后立即运行，而是在第一次访问该字段时就延迟并缓慢运行。换句话说，它的工作方式与顶层变量或静态字段的初始化器完全一样。当初始化表达式的成本很高且可能不需要时，这可以很方便。&lt;/p&gt;
&lt;p&gt;当你在实例字段上使用后期，懒惰地运行初始化器会给你一个额外的奖励。通常实例字段初始化器不能访问这个，因为在所有字段初始化器完成之前，你不能访问新对象。但有了迟来的字段，就不再是这样了，所以你可以访问这个，调用方法，或者访问实例上的字段。&lt;/p&gt;
&lt;h3 id=&#34;late-final-变量&#34;&gt;late final 变量&lt;/h3&gt;
&lt;p&gt;你也可以把 &lt;code&gt;late&lt;/code&gt; 和 &lt;code&gt;final&lt;/code&gt; 结合起来。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Coffee&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;late&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;heat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;hot&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;chill&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;iced&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;serve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39; coffee&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;与普通的 final 字段不同，您不必在声明中或在构造函数初始化列表中初始化该字段。你可以在以后的运行时对它进行赋值。但是你只能对它赋值一次，而且这个事实会在运行时被检查。如果你试图对它进行不止一次的赋值，就像这里同时调用 heat() 和 chill() 一样，第二次赋值就会抛出一个异常。这是对最终被初始化且之后不可改变的状态进行建模的好方法。&lt;/p&gt;
&lt;p&gt;换句话说，新的 late 修饰符结合 Dart 的其他变量修饰符，覆盖了 Kotlin 中 lateinit 和 Swift 中 lazy 的大部分功能空间。如果你想在局部变量上使用它，你甚至可以在局部变量上使用它，如果你想进行一点局部的懒惰评估。&lt;/p&gt;
&lt;h3 id=&#34;所需的命名参数&#34;&gt;所需的命名参数&lt;/h3&gt;
&lt;p&gt;为了保证你永远不会看到一个具有不可空类型的空参数，类型检查器要求所有可选参数要么具有可空类型，要么具有默认值。如果你想让一个命名的参数有一个可空的类型而没有默认值呢？那就意味着你想要求调用者总是传递它。换句话说，你想要一个命名的参数，但不是可选的。&lt;/p&gt;
&lt;p&gt;我用这个表直观地展示了 Dart 参数的各种类型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;             mandatory    optional
            +------------+------------+
positional  | f(int x)   | f([int x]) |
            +------------+------------+
named       | ???        | f({int x}) |
            +------------+------------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于不清楚的原因，Dart 长期以来一直支持这个表的三个角，但把 named+mandatory 的组合空了。在空安全的情况下，我们填补了这一点。你在参数前放上 required，就可以声明一个必要的命名参数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;({&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;required&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;required&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里，所有的参数都必须以名字传递。参数 a 和 c 是可选的，可以省略。参数 b 和 d 是必填的，必须传递。注意，要求性与可空性无关。可空类型的命名参数可以是必需的，不可空类型的命名参数可以是可选的（如果它们有一个默认值）。&lt;/p&gt;
&lt;p&gt;这是另一个我认为无论空值安全性如何都能让 Dart 变得更好的特性之一。它只是让我觉得这个语言更加完整。&lt;/p&gt;
&lt;h3 id=&#34;抽象字段&#34;&gt;抽象字段&lt;/h3&gt;
&lt;p&gt;Dart 的一个特点是它坚持了一个叫做统一访问原则的东西。用人话说就是字段与 getter 和 setter 是没有区别的。在某个 Dart 类中的 &amp;ldquo;属性 &amp;ldquo;是计算还是存储，这是一个实现细节。正因为如此，在使用抽象类定义接口的时候，一般都会使用字段声明。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Cup&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Beverage&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;contents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其目的是让用户只实现该类，而不要扩展它。字段语法只是写一个 getter/setter 对的较短方式。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Cup&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Beverage&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;get&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;contents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;set&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;contents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Beverage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但 Dart 不知道这个类永远不会被用作具体类型。它把那个内容声明看作是一个真实的字段。而且，不幸的是，这个字段是不可空的，也没有初始化器，所以你得到一个编译错误。&lt;/p&gt;
&lt;p&gt;一个解决方法是使用显式的抽象 getter/setter 声明，就像第二个例子中那样。但这有点啰嗦，所以在 null 安全的情况下，我们还增加了对显式抽象字段声明的支持。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Cup&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Beverage&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;contents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这和第二个例子的行为完全一样。它只是用给定的名称和类型声明了一个抽象的 getter 和 setter。&lt;/p&gt;
&lt;h3 id=&#34;使用可空字段&#34;&gt;使用可空字段&lt;/h3&gt;
&lt;p&gt;这些新特性涵盖了许多常见的模式，并且在大多数时间里，让处理 null 的工作变得相当轻松。但即便如此，我们的经验是，可空字段仍然是困难的。在你能让字段迟到且不可空的情况下，你是金子般的存在。但在很多情况下，你需要检查字段是否有值，这就需要让它可空，这样你就可以观察到空。&lt;/p&gt;
&lt;p&gt;你可能会期望这样做是可行的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety, incorrectly:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Coffee&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;heat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;hot&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;chill&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;iced&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;checkTemp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Ready to serve &amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;!&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;serve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39; coffee&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 checkTemp()里面，我们检查 _temperature 是否为空。如果不是，我们访问它，并最终调用+。不幸的是，这是不允许的。基于流式的类型推广并不适用于字段，因为静态分析无法证明字段的值在你检查 null 和你使用它的点之间没有变化。考虑到在病理情况下，字段本身可能会被子类中的 getter 覆盖，在第二次调用时返回 null）。&lt;/p&gt;
&lt;p&gt;所以，既然我们关心健全性，那么字段就不会推广，上面的方法就不会编译。这是很烦人的。在像这里这样简单的情况下，你最好的选择是在字段的使用上打上一个! 这似乎是多余的，但这多少是 Dart 如今的行为方式。&lt;/p&gt;
&lt;p&gt;另一个有用的模式是先把字段复制到一个本地变量中，然后再使用它。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;checkTemp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_temperature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Ready to serve &amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;temperature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;!&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于类型推广确实适用于本地人，所以现在可以正常使用。如果你需要改变值，只要记得存储回字段，而不仅仅是本地。&lt;/p&gt;
&lt;h3 id=&#34;无效性和属性&#34;&gt;无效性和属性&lt;/h3&gt;
&lt;p&gt;像大多数现代静态类型的语言一样，Dart 有通用类和通用方法。它们与可空性的交互方式有一些看似反直觉的地方，但一旦你想清楚了其中的含义，就会明白。首先是 &amp;ldquo;这个类型是可空性的吗？&amp;ldquo;不再是一个简单的是或否的问题。考虑一下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;a string&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 Box 的定义中，T 是一个可空类型还是一个不可空类型？正如你所看到的，它可以被实例化为任何一种类型。答案是 T 是一个潜在的可空类型。在一个通用类或方法的主体中，潜在可空类型具有可空类型和不可空类型的所有限制。&lt;/p&gt;
&lt;p&gt;前者意味着除了在 Object 上定义的少量方法外，你不能调用它的任何方法。后者意味着你必须在使用该类型的任何字段或变量之前初始化它们。这可能会使类型参数变得相当难处理。&lt;/p&gt;
&lt;p&gt;在实践中，有几种模式表现出来。在类似集合的类中，类型参数可以用任何类型实例化，你只需要处理这些限制。在大多数情况下，就像这里的例子一样，这意味着只要你需要处理一个类型参数的值，就必须确保你确实可以访问这个类型参数的值。幸运的是，集合类很少对其元素调用方法。&lt;/p&gt;
&lt;p&gt;在你无法访问一个值的地方，你可以使类型参数的使用是可空的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;full&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意对象声明上的? 现在这个字段有一个显式可空的类型，所以可以不初始化它。&lt;/p&gt;
&lt;p&gt;当你使一个类型参数类型像这里的 T? 一样可空的时候，你可能需要把可空性抛掉。正确的方法是使用显式为 T 的转写，而不是使用 !操作符。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;full&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

  &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;unbox&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;!操作符总是在值为 null 时抛出。但是如果类型参数已经被实例化为一个可空类型，那么 null 对于 T 来说是一个完全有效的值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;box&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Box&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;full&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;box&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unbox&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个程序应该无误地运行。使用 T 就可以实现这一点。使用 !会抛出一个异常。&lt;/p&gt;
&lt;p&gt;其他通用类型有一些约束，限制了可以应用的类型参数的种类。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Interval&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;n&#34;&gt;Interval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

  &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;get&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;isEmpty&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果绑定是不可空的，那么类型参数也是不可空的，这意味着你有不可空类型的限制&amp;ndash;你不能让字段和变量不初始化。这意味着你有不可空值类型的限制&amp;ndash;你不能让字段和变量不初始化。这里的示例类必须有一个初始化字段的构造函数。&lt;/p&gt;
&lt;p&gt;作为这种限制的回报，你可以调用在其绑定上声明的参数类型的值的任何方法。然而，拥有一个不可空的绑定确实会阻止你的通用类的用户用一个可空的类型参数来实例化它。对于大多数类来说，这可能是一个合理的限制。&lt;/p&gt;
&lt;p&gt;你也可以使用一个可空的绑定。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Interval&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;get&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;isEmpty&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;localMin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;localMax&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// No min or max means an open-ended interval.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;localMin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;localMax&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;localMax&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;localMin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这意味着在类的主体中，你可以灵活地将类型参数处理为 nullable。请注意，这次我们没有构造函数，这也没关系。字段将被隐式初始化为 null。你可以声明类型参数类型的未初始化变量。&lt;/p&gt;
&lt;p&gt;但是你也有 nullability 的限制&amp;ndash;你不能在该类型的变量上调用任何东西，除非你先处理好 nullability。在这里的例子中，我们复制局部变量中的字段，并检查这些局部变量是否为空，以便在使用&amp;lt;=之前，流分析将它们推广到非可空性类型。&lt;/p&gt;
&lt;p&gt;请注意，可空性绑定并不妨碍用户用非空类型实例化类。一个可空的边界意味着类型参数可以是可空的，而不是说它必须是可空的。事实上，如果你不写扩展子句，类型参数的默认约束是可空值约束 Object? 没有办法要求类型参数是可空的。如果你想让类型参数的使用可靠地是可空的，你可以在类的主体里面使用 T?&lt;/p&gt;
&lt;h2 id=&#34;核心库的变化&#34;&gt;核心库的变化&lt;/h2&gt;
&lt;p&gt;语言中还有一些其他的调整，但都是次要的。例如，没有 on 子句的 catch 的默认类型现在是 Object 而不是动态的。开关语句中的跌穿分析使用了新的流分析。&lt;/p&gt;
&lt;p&gt;剩下的真正对你有意义的变化是在核心库中。在我们开始进行空值安全大冒险之前，我们担心原来没有办法在不大规模破坏世界的情况下让我们的核心库实现空值安全。结果并没有那么可怕。有一些重大的变化，但大多数情况下，迁移很顺利。大多数核心库要么不接受 null，自然而然地迁移到非可空类型，要么接受并优雅地用可空类型接受它。&lt;/p&gt;
&lt;p&gt;不过有几个重要的角落。&lt;/p&gt;
&lt;h3 id=&#34;map-索引操作符是可空的&#34;&gt;Map 索引操作符是可空的&lt;/h3&gt;
&lt;p&gt;这并不是真正的改变，更多的是一个需要知道的事情。Map 类的 index [] 操作符如果键不存在，则返回 null。这意味着该操作符的返回类型必须是可空的。V?&lt;/p&gt;
&lt;p&gt;我们可以将该方法改为当键不存在时抛出一个异常，然后给它一个更容易使用的非空值返回类型。但是，使用索引操作符并检查 null 以查看键是否不存在的代码是非常常见的，根据我们的分析，约占所有使用的一半。打破所有这些代码会让 Dart 生态系统燃起熊熊大火。&lt;/p&gt;
&lt;p&gt;相反，运行时的行为是一样的，因此返回类型必须是可空的。这意味着你一般不能立即使用 map 查询的结果。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety, incorrectly:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;value&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// Error.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当你试图在一个可空字符串上调用.length 时，会出现编译错误。在你知道键存在的情况下，你可以通过使用！.length 来教导类型检查器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Using null safety:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;value&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// OK.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们考虑过在 Map 中添加另一个方法来为你做这件事：查找 key，如果没有找到就抛出，否则就返回一个非空值。但是该怎么称呼它呢？没有一个名字比单字符的 !更短，也没有一个方法的名字比在调用现场看到一个内置语义的 !更清晰。所以，在地图中访问一个已知存在元素的习惯性方式是使用[]! 你会习惯的。&lt;/p&gt;
&lt;h3 id=&#34;没有未命名的-list-构造函数&#34;&gt;没有未命名的 List 构造函数&lt;/h3&gt;
&lt;p&gt;List 上的未命名构造函数创建了一个给定大小的新列表，但没有初始化任何元素。如果你创建了一个非可空类型的 list，然后访问一个元素，这将会在健全性保证中留下一个非常大的漏洞。&lt;/p&gt;
&lt;p&gt;为了避免这种情况，我们完全删除了构造函数。在空安全代码中调用 List()是一个错误，即使是可空类型。这听起来很吓人，但实际上，大多数代码都是使用 list literals、List.filled()、List.generate()或者作为转换其他集合的结果来创建列表的。对于想要创建某种类型的空列表的边缘情况，我们添加了一个新的 List.empty()构造函数。&lt;/p&gt;
&lt;p&gt;在 Dart 中，创建一个完全未初始化的列表的模式一直让人觉得格格不入，现在更是如此。如果你的代码被这一点破坏了，你可以随时通过使用许多其他的方法来产生一个列表来修复它。&lt;/p&gt;
&lt;h3 id=&#34;不能在不可空的列表上设置较大的长度&#34;&gt;不能在不可空的列表上设置较大的长度&lt;/h3&gt;
&lt;p&gt;这一点鲜为人知，但 List 上的 length getter 也有一个相应的 setter。你可以将长度设置为一个较短的值来截断列表。你也可以将它设置为一个较长的长度，以便用未初始化的元素填充列表。&lt;/p&gt;
&lt;p&gt;如果你对一个非空值类型的列表这样做，当你以后访问那些未写入的元素时，你会违反健全性。为了防止这种情况发生，如果（也只有当）列表的元素类型是不可空的，而你又将其设置为较长的长度时，长度设置器会抛出一个运行时异常。截断所有类型的列表仍然是可以的，你可以增长可空类型的列表。&lt;/p&gt;
&lt;p&gt;如果你定义了自己的列表类型，扩展了 ListBase 或应用了 ListMixin，那么这有一个重要的后果。这两种类型都提供了 insert()的实现，之前通过设置长度为插入的元素腾出空间。这样做会因空安全而失败，所以我们将 ListMixin（ListBase 共享）中 insert()的实现改为调用 add()。如果你想能够使用继承的 insert()方法，你的自定义列表类应该提供 add()的定义。&lt;/p&gt;
&lt;h3 id=&#34;不能在迭代之前或之后访问-iteratorcurrent&#34;&gt;不能在迭代之前或之后访问 Iterator.current&lt;/h3&gt;
&lt;p&gt;Iterator 类是一个可变的 &amp;ldquo;游标 &amp;ldquo;类，用于遍历实现 Iterable 的类型的元素。在访问任何元素之前，你应该调用 moveNext()来前进到第一个元素。当该方法返回 false 时，你已经到达了终点，没有更多的元素。&lt;/p&gt;
&lt;p&gt;过去，如果你在第一次调用 moveNext()之前或在迭代结束后调用它，current 会返回 null。有了 null 安全，那就要求 current 的返回类型是 E? 而不是 E。这又意味着每个元素的访问都需要进行运行时空检查。&lt;/p&gt;
&lt;p&gt;鉴于几乎没有人以那种错误的方式访问当前元素，这些检查将毫无用处。由于在迭代之前或之后可能会有一个该类型的值，所以我们让迭代器的行为没有被定义，如果你在不应该调用它的时候调用它。大多数 Iterator 的实现都会抛出一个 StateError。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;这是一个非常详细的关于 null 安全的语言和库变化的介绍。这是一个很大的东西，但这是一个相当大的语言变化。更重要的是，我们希望达到一个点，让 Dart 仍然感觉到凝聚力和可用性。这不仅需要改变类型系统，还需要改变其他一些围绕它的可用性功能。我们不希望它让人感觉像被栓上了 null safety。&lt;/p&gt;
&lt;p&gt;要带走的核心点是。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型在默认情况下是不可空值的，而通过添加 &lt;code&gt;?.&lt;/code&gt; 来实现空值化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选参数必须是可空的，或者有一个默认值。可以使用 required 使命名参数成为非可选参数。不可空值的顶层变量和静态字段必须有初始化器。不可空值的实例字段必须在构造函数主体开始之前初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果接收者为空，则空感知操作符后的方法链会短路。有新的空感知级联(&lt;code&gt;?..&lt;/code&gt;)和索引(&lt;code&gt;?[]&lt;/code&gt;)运算符。后缀的空断言 &amp;ldquo;bang&amp;rdquo; 运算符(!)将其可空操作数投射到底层的非可空类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流程分析让你可以安全地将可空的局部变量和参数转化为可用的非可空变量。新的流分析还对类型提升、缺失返回、不可达代码和变量初始化有更智能的规则。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;late 修饰符让你可以在其他地方使用不可空类型和 final，否则你可能无法使用，但会牺牲运行时检查。它还为你提供了惰性初始化的字段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;List 类被修改为防止未初始化元素。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，一旦你吸收了所有这些，并让你的代码进入 null 安全的世界，你就会得到一个健全的程序，编译器可以优化，并且在你的代码中可以看到每一个可能发生运行时错误的地方。我们希望你觉得这样的努力是值得的。&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&#34;https://dart.dev/null-safety/understanding-null-safety&#34;&gt;https://dart.dev/null-safety/understanding-null-safety&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/dart">Dart</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/dart">Dart</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/dart-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3">Dart 官方文档</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-03-05-understanding-null-safety/</guid>
                <pubDate>Fri, 05 Mar 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>如何在 Raku 中输入 Unicode</title>
                <link>https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/</link>
                
                
                <description>&lt;blockquote&gt;How to Type Unicode in Raku&lt;/blockquote&gt;&lt;p&gt;Raku 有非常好的 Unicode 支持, 但是输入 Unicode 一直是一个很大的问题。在 REPL 中, 输入 Unicode 都不太方便。下面介绍几种方法来方便地输入 Unicode。&lt;/p&gt;
&lt;h1 id=&#34;comma&#34;&gt;Comma&lt;/h1&gt;
&lt;p&gt;最方便的是使用 Raku 自己的 IDE, &lt;a href=&#34;http://commaide.com&#34;&gt;Comma&lt;/a&gt;。但是需要做两个设置:&lt;/p&gt;
&lt;p&gt;首先, 切换到 Comma IDE, 点击左上角菜单栏的 &lt;strong&gt;Comma&lt;/strong&gt; 选项, 在弹出的 &lt;strong&gt;Preference&lt;/strong&gt; 窗口中, 找到左侧菜单栏中的 &lt;strong&gt;Editor&lt;/strong&gt; 选项, 点击 &lt;strong&gt;Code Style&lt;/strong&gt; 中的 &lt;strong&gt;Raku&lt;/strong&gt;, 在右侧的窗口的最上面, 找到 &lt;strong&gt;Schema&lt;/strong&gt; 一行, 点击倒三角图标, 在下拉菜单中选择 &lt;strong&gt;Project&lt;/strong&gt;。然后在第二行文字中找到 &lt;strong&gt;Editor Behavior&lt;/strong&gt;, 勾选 &lt;strong&gt;Convert operators to Unicode&lt;/strong&gt;。完成后点击右下角的 &lt;strong&gt;Apply&lt;/strong&gt;, 然后点击 &lt;strong&gt;OK&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这样当你在 Comma 中键入 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 这样的运算符后, Comma 会自动把它转为 Unicode 形式的 &lt;code&gt;»&lt;/code&gt;。目前已支持大部分 Unicode 运算符了。Comma 是跨平台的 Raku 编辑器, 支持 Windows、Linux 和 MacOS, 所以你想跨平台开发的话, Comma 值得一试。&lt;/p&gt;
&lt;h1 id=&#34;kitty&#34;&gt;Kitty&lt;/h1&gt;
&lt;p&gt;如果你想在 Vim 中开发 Raku, 又不想失去输入 Unicode 的乐趣, 请使用 &lt;a href=&#34;https://github.com/kovidgoyal/kitty&#34;&gt;Kitty&lt;/a&gt; 终端。点开 Kitty 终端, 使用快捷键 Ctrl + Shift + U 即可触发输入 Unnicode 的界面(也可以键入命令 kitty +kitten unicode_input 来触发)。再通过快捷键  F1、F2、F3 和 F4 (或通过 Ctrl+[ 和 Ctrl+] 切换标签)可以分别按代码搜索 Unicode、按名字搜索 Unicode、按表情搜索和收藏。&lt;/p&gt;
&lt;p&gt;例如在 REPL 中键入 Unicode 字符:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ raku
Welcome to 𝐑𝐚𝐤𝐮𝐝𝐨™ v2021.02.
Implementing the 𝐑𝐚𝐤𝐮™ programming language v6.d.
Built on MoarVM version 2021.02.

To &lt;span class=&#34;nb&#34;&gt;exit&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;exit&amp;#39;&lt;/span&gt; or &lt;span class=&#34;s1&#34;&gt;&amp;#39;^D&amp;#39;&lt;/span&gt;
&amp;gt; my @a &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; 1..5&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&amp;gt; @a».sin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;借助 Kitty, 数组 &lt;code&gt;@a&lt;/code&gt; 后面的 &lt;code&gt;»&lt;/code&gt; 可以这样输入, 先输入 &lt;code&gt;@a&lt;/code&gt;, 然后使用快捷键 Shift + Ctrl + U 调出 Kitty 的 &lt;strong&gt;Unicode input&lt;/strong&gt; 界面, 一般有两种方法, 第一种是通过快捷键 F1, 然后输入对应的 Unicode 编码, 再回车。第二种是通过快捷键 F2, 通过名字搜索, 例如输入单词 quota, 会出现一堆引号符号供你选择, 按上下方向键选中 &lt;code&gt;»&lt;/code&gt;, 再回车即可。Vim 中同理。&lt;/p&gt;
&lt;h1 id=&#34;julia-repl&#34;&gt;Julia REPL&lt;/h1&gt;
&lt;p&gt;在 REPL 中输入 &lt;code&gt;\′ + 单词 + Tab, 例如输入 &lt;/code&gt;\heartsuit` 再按 Tab, 就会自动变成 ♡&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;julia&amp;gt; &lt;span class=&#34;se&#34;&gt;\h&lt;/span&gt;eartsuit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;ipython&#34;&gt;IPython&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;\^&lt;/code&gt; 输入上标, &lt;code&gt;\_p&lt;/code&gt; 输入下标。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ipython
&lt;span class=&#34;se&#34;&gt;\^&lt;/span&gt;a
&lt;span class=&#34;se&#34;&gt;\_&lt;/span&gt;p
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;vscode&#34;&gt;VScode&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;\\′ + 完整的单词 + Tab, VsCode 会自动转换为 Unicode。 例如 &lt;/code&gt;^a&lt;code&gt;和&lt;/code&gt;_p`&lt;/p&gt;
&lt;h1 id=&#34;dmenu&#34;&gt;dmenu&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span class=&#34;ch&#34;&gt;#!/usr/bin/perl&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;#use strict;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#use warnings;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#use autodie;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#use utf8;&lt;/span&gt;


&lt;span class=&#34;nb&#34;&gt;open&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$FH&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; | dmenu -i -l 30 -fn &amp;#39;-xos4-terminus-medium-r-*-*-10-*&amp;#39; | sed &amp;#39;s/^\\(.\\).*/\\1/&amp;#39; | tr -d &amp;#39;\n&amp;#39; | { pbcopy; pbpaste; } &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# if you do not have the xos4-terminus font that makes characters a little bigger :&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# uncoment this line and use the second here document&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#open $FH, &amp;#34; | dmenu -i -l 30 | sed &amp;#39;s/^\\(.\\).*/\\1/&amp;#39; | tr -d &amp;#39;\n&amp;#39; | { xsel -ib; xsel -ip; } &amp;#34;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# also you can compile dmenu from source and change the font size directly in the C done&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# in the file config.h / config.def.h&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# this heredoc is well aligned with the -xos4-terminus-medium-r-*-*-10-* font&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;print&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$FH&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;dl&#34;&gt;EOF&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#39;
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;«         hyper operator
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;»         hyper operator
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;∈        membership
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;∉        non-membership
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;∪         set union
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;∩         set intersection
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;∖         set difference
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;≡         set equality
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;≢        set inequality
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⊖        symmetric set difference
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⊍         baggy multiplication
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⊎         baggy addition
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;∅        empty set
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⊆        subset
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⊈         not a subset
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⊂        strict subset
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⊄        not a strict subset
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;∋        reverse membership
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;∌          reverse non-membership
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⊇        superset
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⊉         not a superset
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⊃        strict superset
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⊅        not a strict superset
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;∞         infinity
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⚛        atomic operator
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;π        pi
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;τ         tau
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;𝑒         Euler&amp;#39;s number
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;∘         function composition
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;×        multiplication 
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;÷        division
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;≤         inferior or equal
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;≥         greater or equal
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;≠   	     inequality
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;−        substraction
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;≅       approximatively equal
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;…      sequence operator
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;‘         left single quotation mark
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;’         right single quotation mark
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;‚         single low-9 quotation mark 
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;”         right double quotation mark
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;“         left double quotation mark
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;„         double low-9 quotation mark
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;｢         halfwidth left corner bracket
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;｣         halfwidth right corner bracket
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⁺         plus superscript
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⁻         minus superscript
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⁰         0 superscript
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;¹         1 superscript 
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;²         2 superscript 
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;³         3 superscript 
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⁴         4 superscript 
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⁵         5 superscript 
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⁶         6 superscript 
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⁷         7 superscript 
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⁸         8 superscript 
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;⁹         9 superscript 
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&lt;/span&gt;&lt;span class=&#34;dl&#34;&gt;EOF&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# use this without -xos4-terminus-medium-r-*-*-10-* font&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# the default font may change given which font packages are installed and given the font configurations&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;#print $FH &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#«         hyper operator&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#»         hyper operator&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#∈         membership&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#∉         non-membership&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#∪         set union&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#∩         set intersection&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#∖         set difference&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#≡         set equality&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#≢         set inequality&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⊖         symmetric set difference&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⊍         baggy multiplication&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⊎         baggy addition&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#∅         empty set&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⊆         subset&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⊈         not a subset&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⊂         strict subset&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⊄         not a strict subset&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#∋         reverse membership&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#∌         reverse non-membership&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⊇         superset&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⊉         not a superset&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⊃         strict superset&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⊅         not a strict superset&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#∞         infinity&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⚛         atomic operator&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#π         pi&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#τ         tau&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#𝑒         Euler&amp;#39;s number&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#∘         function composition&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#×         multiplication &lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#÷         division&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#≤         inferior or equal&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#≥         greater or equal&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#≠         inequality&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#−         substraction&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#≅         approximatively equal&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#…         sequence operator&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#‘         left single quotation mark&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#’         right single quotation mark&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#‚         single low-9 quotation mark &lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#”         right double quotation mark&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#“         left double quotation mark&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#„         double low-9 quotation mark&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#｢         halfwidth left corner bracket&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#｣         halfwidth right corner bracket&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⁺         plus superscript&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⁻         minus superscript&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⁰         0 superscript&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#¹         1 superscript &lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#²         2 superscript &lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#³         3 superscript &lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⁴         4 superscript &lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⁵         5 superscript &lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⁶         6 superscript &lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⁷         7 superscript &lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⁸         8 superscript &lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#⁹         9 superscript &lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#EOF&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#;&lt;/span&gt;



&lt;span class=&#34;nb&#34;&gt;close&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$FH&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;



&lt;span class=&#34;cp&#34;&gt;__END__
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;=pod 
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;=head1 NAME
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;lazy_raku_unicode.pl
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;=head1 SYNOPSIS
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;This script allows you to select a Unicode symbol from a drop-down menu that you can simply paste into your text editor, terminal or IDE.
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;All it does is send a heredoc through a pipe to dmenu, and copy to the clipboard the character that you selected.
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;Dmenu is a program that reads lines from stdin, display them in a menu, and write to stdout the lines selected.
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;It is not practical to execute this script from a terminal each time you want a character though. This is why it should be executed by sxhkd.
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;Sxhkd is the program that will call this script each time you press the right key combination.
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;Only the most useful Unicode characters are present to not make dmenu get too slow. (It is usually very fast when there is only ascii text.)
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;This include most of the Raku operators that have a Unicode version, plus some quoting characters, superscripts, and mathematical constants.
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;=head1 MANUAL INSTALLATION STEPS
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;=head2 INSTALLING DMENU
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;B&amp;lt;On Debian or Ubuntu :&amp;gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;	sudo apt install suckless-tools
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;B&amp;lt;On Archlinux :&amp;gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;	sudo pacman -Sy dmenu
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;B&amp;lt;Compile it from source :&amp;gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;	https://tools.suckless.org/dmenu/
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;=head2 CHANGING DMENU FONT SIZE (OPTIIONAL)
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;You have only two ways of changing the font size :
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;Change the default font with the B&amp;lt;-fn&amp;gt; flag (See dmenu(1) for the specifics).
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;	
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;	dmenu -l 30 -fn &amp;#39;-xos4-terminus-medium-r-*-*-10-*&amp;#39;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;Modify directly the C source code of dmenu. Only the files B&amp;lt;config.h / config.def.h&amp;gt;.
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;Simply edit this line and change 10 by 14 for example.
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;	static const char *fonts[] = {
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;		&amp;#34;monospace:size=10&amp;#34;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;	};
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;Then execute sudo make install and you&amp;#39;re ready to go.
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;=head2 INSTALLING SXHKD
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;B&amp;lt;On Debian or Ubuntu :&amp;gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;	sudo apt install sxhkd
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;B&amp;lt;On Archlinux :&amp;gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;	sudo pacman -Sy sxhkd
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;=head2 CONFIGURING SXHKD
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;B&amp;lt;Autostarting sxhkd at startup :&amp;gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;simply put this line in B&amp;lt;~/.xprofile&amp;gt; :
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;	sxhkd &amp;amp;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;B&amp;lt;Setting the keybinding :&amp;gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;	
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;Add these two lines in B&amp;lt;~/.config/sxhkd/sxhkdrc&amp;gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;	ctrl + apostrophe
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;		/path/to/lazy_raku_unicode.pl
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;The keybinding have to start at the beginning of a line, and the command has to follow on the next line and be preceded by a tabulation.
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;To make sxhkd reload the config file, either kill it and relaunch it, or send a SIGUSR1 signal. This command can do it :
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;	pidof sxhkd | kill -SIGUSR1 $(cat /dev/stdin)
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;If you want to use a different keybinding, please see sxhkd(1) and use xev(1) to find the name of keys.
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;Here the name of some of the keys : ctrl, super, alt, Return .
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;=head1 SEE ALSO
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;dmenu(1), sxhkd(1), xev(1)
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;=cut
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参考链接: &lt;a href=&#34;https://docs.raku.org/language/unicode_entry&#34;&gt;https://docs.raku.org/language/unicode_entry&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/raku">Raku</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/unicode">Unicode</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/</guid>
                <pubDate>Mon, 01 Mar 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>Method-ish</title>
                <link>https://ohmyweekly.github.io/notes/2021-02-17-method-isd/</link>
                
                
                <description>&lt;blockquote&gt;Method-ish&lt;/blockquote&gt;&lt;p&gt;在我的上一篇文章中，我又一次为从 CORE 中增强类的方法而苦恼。这种挣扎完全没有必要，因为我并没有用增加的方法改变对象的状态。对于做更高级的东西，我可能不得不这样做。把手伸进 Raku 的内部这么深，我可能会把自己烫伤。既然我想做的是把我的代码绑在编译器的变化上，反正我可能会全身心地投入到 nqp-land 中去。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my \j = 1 | 2 | 3;
dd j;
use nqp;
.say for nqp::getattr(j, Junction, &#39;$!eigenstates&#39;);
# OUTPUT: any(1, 2, 3)
          1
          2
          3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以使用 nqp 来获取私有属性，而不需要添加任何方法。这就有点儿不伦不类了。所以，让我们用一个伪方法来做一些 deboilerplating。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub pry(Mu $the-object is raw) {
    use InterceptAllMethods;

    class Interceptor {
        has Mu $!the-object;
        method ^find_method(Mu \type, Str $name) {
            my method (Mu \SELF:) is raw {
                use nqp;
                my $the-object := nqp::getattr(SELF, Interceptor, &#39;$!the-object&#39;);
                nqp::getattr($the-object, $the-object.WHAT, &#39;$!&#39; ~ $name)
            }
        }
    }

    use nqp;
    nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, &#39;$!the-object&#39;, $the-object);
}

.say for j.&amp;amp;pry.eigenstates;
# OUTPUT: 1
          2
          3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过 InterceptAllMethods，lizmat 改变了类关键字的行为，允许我们提供一个 FALLBACK-method 来捕获任何方法，包括从 Mu 继承的方法。这反过来又允许 pry 返回的对象将任何方法调用转移到一个自定义的方法。在这个方法中，我们可以对 &lt;code&gt;.&amp;amp;pry&lt;/code&gt; 被调用的对象做任何我们想做的事情。&lt;/p&gt;
&lt;p&gt;由于我们的特殊对象会拦截任何调用，甚至是 Mu 的调用，我们需要找到另一种方法来调用 &lt;code&gt;.new&lt;/code&gt;。由于 &lt;code&gt;.^&lt;/code&gt; 不是 &lt;code&gt;.&lt;/code&gt; 的特殊形式，我们可以用它来获得对类方法的访问。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub interceptor(Method $the-method){
    use InterceptAllMethods;
    use nqp;

    sub (Mu $the-object is raw) {
        my class Interceptor {
            has Mu $!the-object;
            has Code $!the-method;

            method ^find_method(Mu \type, Mu:D $name) {
                my method (Mu \SELF: |c) is raw {
                    $!the-method.($!the-object, $name, |c)
                }
            }
            method ^introspect(Mu \type, Mu \obj) {
                my method call-it() is raw {
                    $!the-object
                }
                obj.&amp;amp;call-it;
            }
            method ^new(Mu \type, $the-object!, $the-method) {
                nqp::p6bindattrinvres(
                        nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, &#39;$!the-object&#39;, $the-object),
                        Interceptor, &#39;$!the-method&#39;, $the-method)
            }
        }

            # nqp::p6bindattrinvres(
                #     nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, &#39;$!the-object&#39;, $the-object),
                #   Interceptor, &#39;$!the-method&#39;, $the-method);
        Interceptor.^new($the-object, $the-method)
    }
}

my &amp;amp;first-defined = interceptor(
    my method (Positional \SELF: $name) {
        for SELF.flat -&amp;gt; $e {
            with $e.&amp;quot;$name&amp;quot;(|%_) {
                .return
            }
        }
        Nil
    }
);

my $file = &amp;lt;file1.txt file2.txt file3.txt nohup.out&amp;gt;».IO.&amp;amp;first-defined.open(:r);
dd $file;
# OUTPUT: Handle $file = IO::Handle.new(path =&amp;gt; IO::Path.new(&amp;quot;nohup.out&amp;quot;, :SPEC(IO::Spec::Unix), :CWD(&amp;quot;/home/dex/projects/raku/tmp&amp;quot;)), chomp =&amp;gt; Bool::True, nl-in =&amp;gt; $[&amp;quot;\n&amp;quot;, &amp;quot;\r\n&amp;quot;], nl-out =&amp;gt; &amp;quot;\n&amp;quot;, encoding =&amp;gt; &amp;quot;utf8&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;sub &lt;code&gt;interceptor&lt;/code&gt; 接受一个方法并返回一个 sub。如果这个 sub 像方法一样被调用，它将把要被调用的方法的名称和调用者转发给一个自定义方法。当 &lt;code&gt;.&amp;amp;first-defined&lt;/code&gt; 被调用时，会返回一个特殊的对象。让我们来看看它是什么。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my \uhhh-special = &amp;lt;a b c&amp;gt;.&amp;amp;first-defined;
dd uhhh-special.^introspect(uhhh-special);
# OUTPUT: ($(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;), method &amp;lt;anon&amp;gt; (Positional \SELF: $name, *%_) { #`(Method|93927752146784) ... })
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们必须给 &lt;code&gt;.^introspect&lt;/code&gt; 一个我们想看的对象，因为它的调用者是类 Interceptor 的类型对象。&lt;/p&gt;
&lt;p&gt;目前，我还不知道有什么办法（毕竟，我知道的只是足够多的东西，真的很危险。这是不幸的，因为 lizmat 决定重载关键字 &lt;code&gt;class&lt;/code&gt;，而不是用不同的名字导出特殊的 &lt;code&gt;Metamodel::ClassHOW&lt;/code&gt;。如果我们不想或不能有外部依赖，我们可以使用 MOP 来创建我们的类型对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;class InterceptHOW is Metamodel::ClassHOW {
    method publish_method_cache(|) { }
}

sub ipry(Mu $the-object is raw) {
    my \Interceptor = InterceptHOW.new_type(:name&amp;lt;Interceptor&amp;gt;);
    Interceptor.^add_attribute(Attribute.new(:name&amp;lt;$!the-object&amp;gt;, :type(Mu), :package(Interceptor)));
    Interceptor.^add_meta_method(&#39;find_method&#39;,
        my method find_method(Mu \type, Str $name) {
            # say „looking for $name“;
            my method (Mu \SELF:) is raw {
                use nqp;
                my $the-object := nqp::getattr(SELF, Interceptor, &#39;$!the-object&#39;);
                nqp::getattr($the-object, $the-object.WHAT, &#39;$!&#39; ~ $name)
            }
    });
    Interceptor.^compose;

    use nqp;
    nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, &#39;$!the-object&#39;, $the-object);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当我写这篇文章的时候，我发现 &lt;code&gt;.^add_meta_method&lt;/code&gt; 只有在提供给它的方法的第一个参数的名字和 &lt;code&gt;Str&lt;/code&gt; 相同的时候才会工作。起初，我尝试了一个匿名方法，它最终出现在 &lt;code&gt;.^meta_method_table&lt;/code&gt; 中，但从未被调用。我想这个 bug 其实并不重要，因为这个元方法根本没有被记录下来。如果我玩火，我没有权利抱怨烧伤。你会在野外的 &lt;code&gt;Actions.nqp&lt;/code&gt; 中发现这个方法。Class 关键字并没有什么神奇的作用。Rakudo 只是使用 MOP 来构造类型对象。&lt;/p&gt;
&lt;p&gt;我们不能在 Raku 中重载赋值操作符。这其实并不需要，因为赋值是通过调用一个名为 STORE 的方法来实现的。由于我们得到了对 dispatch 的完全控制，我们可以拦截任何方法调用，包括一连串的方法调用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;multi sub methodify(%h, :$deeply!) {
    sub interceptor(%h, $parent = Nil){
        use InterceptAllMethods;
        use nqp;

        class Interceptor is Callable {
            has Mu $!the-object;
            has Mu @!stack;

            method ^find_method(Mu \type, Mu:D $name) {
                my method (Mu \SELF: |c) is raw {
                    my @new-stack = @!stack;
                    my $the-object = $!the-object;

                    if $name eq &#39;STORE&#39; {
                        # workaround for rakudobug#4203
                        $the-object{||@new-stack.head(*-1)}:delete if $the-object{||@new-stack.head(*-1)}:exists;

                        $the-object{||@new-stack} = c;
                        return-rw c
                    } else {
                        @new-stack.push: $name;
                        my \nextlevel = SELF.^new($!the-object, @new-stack, $name);
                        nextlevel
                    }
                }
            }
            method ^introspect(Mu \type, Mu \obj) {
                my method call-it() is raw {
                    $!the-object, @!stack
                }
                obj.&amp;amp;call-it;
            }
            method ^new(Mu \type, $the-object!, @new-stack?, $name?) {
                $name
                    ?? nqp::p6bindattrinvres(
                        nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, &#39;$!the-object&#39;, $the-object),
                        Interceptor, &#39;@!stack&#39;, @new-stack)
                    !! nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, &#39;$!the-object&#39;, $the-object)
                }
        }

        Interceptor.^new(%h)
    }

    interceptor(%h)
}

my %h2;
my $o2 = methodify(%h2, :deeply);
$o2.a.b = 42;
dd %h2;
$o2.a.b.c = &amp;lt;answer&amp;gt;;
dd %h2;
say $o2.a.b.c;
# OUTPUT: Hash %h2 = {:a(${:b(\(42))})}
          Hash %h2 = {:a(${:b(${:c(\(&amp;quot;answer&amp;quot;))})})}
          This type cannot unbox to a native string: P6opaque, Interceptor
            in block &amp;lt;unit&amp;gt; at /home/dex/projects/raku/any-chain.raku line 310
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每当我们调用一个方法时，都会创建一个新的 Interceptor 实例，它存储了前一个方法的名称。这样我们就可以沿着方法调用链移动。由于赋值调用 STORE，我们可以将赋值转移到我们用作实际数据结构的 Hash 中。唉，检索值就不一样了，因为 Raku 不区分方法调用和 FETCH。在这里，龙比我强。我还是包含了这个一半失败的尝试，因为我对 slippy 半列表有很好的利用。这需要使用 &lt;code&gt;v6.e.preview&lt;/code&gt;，让我踩到了一个 bug。可能还有更多这样的情况。所以请使用同样的，这样我们就可以在 &lt;code&gt;.e&lt;/code&gt; 发布到野外之前，把所有的野兽都杀掉。&lt;/p&gt;
&lt;p&gt;能够完全控制方法调用链将是一件好事。也许我们可以用 RakuAST 来做到这一点。&lt;/p&gt;
&lt;p&gt;有了这些已经可以工作的东西，我们可以做一些有趣的事情。那些烦人的异常总是在拖我们的后腿。我们可以用 &lt;code&gt;try&lt;/code&gt; 来化解它们，但那会破坏一个方法调用链。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;constant no-argument-given = Mu.new;
sub try(Mu $obj is raw, Mu $alternate-value = no-argument-given) {
    interceptor(my method (Mu \SELF: $name, |c) {
        my $o = SELF;
        my \m = $o.^lookup($name) orelse {
            my $bt = Backtrace.new;
            my $idx = $bt.next-interesting-index($bt.next-interesting-index + 1);
            (X::Method::NotFound.new(:method($name), :typename($o.^name)) but role :: { method vault-backtrace { False }}).throw(Backtrace.new($idx + 1));
        }

        try {
            $o = $o.&amp;quot;$name&amp;quot;(|c);
        }
 
        $! ~~ Exception
            ?? $alternate-value.WHICH eqv no-argument-given.WHICH
                ?? $o
                !! $alternate-value
            !! $o
    }).($obj)
}

class C {
    has $.greeting;
    method might-throw { die &amp;quot;Not today love!&amp;quot; }
    method greet { say $.greeting }
}

C.new(greeting =&amp;gt; ‚Let&#39;s make love!‘).&amp;amp;try.might-throw.greet;
# OUTPUT: Let&#39;s make love!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;伪方法 try 将会化解任何异常，并允许继续调用 C 语言的方法。我必须用一个特殊的值来标记没有可选的参数 &lt;code&gt;$alternate-value&lt;/code&gt;，因为它实际上可能会把异常对象变成 &lt;code&gt;Nil&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我很肯定还有很多这样的小帮手在等着我们去发现。未来可能会有一个模块，希望能帮助 Raku 成为一个好的&lt;a href=&#34;https://ftp.fau.de/fosdem/2021/D.perl/programming_lang_for_free_software.webm&#34;&gt;编程语言&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&#34;https://gfldex.wordpress.com/2021/02/17/method-ish/&#34;&gt;https://gfldex.wordpress.com/2021/02/17/method-ish/&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/raku">Raku</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku-%E5%8D%9A%E5%AE%A2">Raku 博客</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-02-17-method-isd/</guid>
                <pubDate>Sun, 28 Feb 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>模式分派</title>
                <link>https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/</link>
                
                
                <description>&lt;blockquote&gt;Pattern Dispatch&lt;/blockquote&gt;&lt;p&gt;一直以来乐于助人的 &lt;a href=&#34;https://stackoverflow.com/users/1077672/raiph&#34;&gt;raiph&lt;/a&gt; 在回答一个关于模式匹配的&lt;a href=&#34;https://stackoverflow.com/questions/66233465/haskell-like-pattern-matching-in-raku&#34;&gt;问题&lt;/a&gt;时希望得到 RakuAST，就像在 Haskell 中一样。有人提出用 MMD 来解决这个问题。这样做，得到一个贯穿的默认路径是无解的。由于 dispatch 简单来说就是模式匹配，我们只需要做一些额外的工作。简而言之，dispatcher 得到一个函数列表和一个带参数的列表。第一个接受所有参数的函数获胜。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;class Hold { has $.key; }
class Press { has $.key; }
class Err { has $.msg; }

sub else(&amp;amp;code) { &amp;amp;code }

sub match($needle, *@tests) {
    for @tests.head(*-1) -&amp;gt; &amp;amp;f {
        if &amp;amp;f.cando(\($needle)) {
            return f($needle);
        }
    }
    @tests.tail.();
}

match Hold.new(:key&amp;lt;a&amp;gt;),
    -&amp;gt; Hold (:$key) { put „holding $key“; },
    -&amp;gt; Press (:$key) { put „pressing $key“; },
    -&amp;gt; Err (:$msg) { warn „ERR: $msg“ },
    else { fail ‚unsopported‘ };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法 &lt;code&gt;.cando&lt;/code&gt; 需要一个 &lt;a href=&#34;https://docs.raku.org/type/Capture&#34;&gt;Capture&lt;/a&gt; 来告诉我们一个 Routine 是否可以用一个给定的参数列表来调用。为了创建这样一个捕获，我们使用字面的 &lt;code&gt;\($arguments, $go, $here)&lt;/code&gt;。我们不在最后测试默认值。相反，当没有其他函数匹配时，我们会调用该函数。声明 sub &lt;code&gt;else&lt;/code&gt; 只是为了美化。&lt;/p&gt;
&lt;p&gt;由于我们是在函数式的土地上，我们可以使用 Raku 提供给我们的所有方便的功能。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my &amp;amp;key-matcher = &amp;amp;match.assuming(*,[
        -&amp;gt; Hold (:$key) { put „holding $key“; },
        -&amp;gt; Press (:$key) { put „pressing $key“; },
        -&amp;gt; Err (:$msg) { warn „ERR: $msg“ },
        else { fail ‚unsopported‘ };
]);

sub key-source {
    gather loop {
        sleep 1;
        take (Hold.new(:key&amp;lt;a&amp;gt;), Press.new(:key&amp;lt;b&amp;gt;), Err.new(:msg&amp;lt;WELP!&amp;gt;), &#39;unsupported&#39;).pick;
    }
}

.&amp;amp;key-matcher for key-source;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们要帮助 &lt;code&gt;.assuming&lt;/code&gt; 有点理解 slurpies，把函数列表放在一个显式 Array 中。&lt;/p&gt;
&lt;p&gt;总有一种函数式的方法来解决一个问题。有时我们甚至可以从中得到一个整齐的语法。&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&#34;https://gfldex.wordpress.com/2021/02/24/pattern-dispatch/&#34;&gt;https://gfldex.wordpress.com/2021/02/24/pattern-dispatch/&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/raku">Raku</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku-%E5%8D%9A%E5%AE%A2">Raku 博客</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/</guid>
                <pubDate>Sun, 28 Feb 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>自定义 when</title>
                <link>https://ohmyweekly.github.io/notes/2021-02-28-custom-when/</link>
                
                
                <description>&lt;blockquote&gt;Custom When&lt;/blockquote&gt;&lt;p&gt;我不太喜欢上一篇文章中使用匹配的语法。它的参数列表中的逗号看起来很奇怪，不合适。也许是因为我的眼睛习惯了给定的块。睡一觉就好了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub accord(&amp;amp;c) { (c(CALLER::&amp;lt;$_&amp;gt;); succeed) if &amp;amp;c.cando(\(CALLER::&amp;lt;$_&amp;gt;)) }

given Err.new(:msg&amp;lt;a&amp;gt;) {
    accord -&amp;gt; Hold (:$key) { put „holding $key“; }
    accord -&amp;gt; Err (:$msg) { warn „ERR: $msg“ }
    default { fail ‚unsupported‘ }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是因为 &lt;code&gt;accord&lt;/code&gt; 模仿了 &lt;code&gt;when&lt;/code&gt; 的工作。它做了一些匹配，当 True 时调用一个块，并在每个块的结尾添加一个 success（通过抛出一个控制异常）。given 所做的只是设置主题。它还充当了 caller 的角色，所以我们可以通过一个伪包来访问它的 &lt;code&gt;$_&lt;/code&gt;。利用 pointy 的签名来做&lt;a href=&#34;https://docs.raku.org/type/Signature#Destructuring_arguments&#34;&gt;解构&lt;/a&gt;是相当强大的。把这个添加到 CORE 中可能是个好主意。&lt;/p&gt;
&lt;p&gt;我们可能要把 Raku 的定义改成: &amp;ldquo;Raku 是一种高度可组合的编程语言&amp;rdquo;, 在这里，所有的东西都会落到实处。&amp;quot;&lt;/p&gt;
&lt;p&gt;更新一下。&lt;/p&gt;
&lt;p&gt;有些情况下，&lt;code&gt;$_&lt;/code&gt; 不是动态的。另外，success 正在抛出一个控制异常，而这些的处理程序是由 when 或默认添加的。这种情况是在编译时发生的，目前不能用宏来解决。第一个问题可以用黑魔法解决。后一个问题需要用默认块。我没有找到一种方法来提供一个合理的错误信息，如果缺少这个块。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;multi sub accord(&amp;amp;c) {
    use nqp;
    $_ := nqp::getlexcaller(&#39;$_&#39;);
    (c($_); succeed) if &amp;amp;c.cando(\($_))
}

for @possibilities.roll(1) -&amp;gt; $needle {
    given $needle {
        accord -&amp;gt; Hold (:$key) { put „holding $key“; }
        accord -&amp;gt; Err (:$msg) { warn „ERR: $msg“ }
        default { warn ‚unsopported‘ }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原文链接: &lt;a href=&#34;https://gfldex.wordpress.com/2021/02/25/custom-when/&#34;&gt;https://gfldex.wordpress.com/2021/02/25/custom-when/&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/raku">Raku</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/rakulang">Rakulang</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-02-28-custom-when/</guid>
                <pubDate>Sun, 28 Feb 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>为最年轻的 Raku 贡献力量</title>
                <link>https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/</link>
                
                
                <description>&lt;blockquote&gt;Contributing to Raku&lt;/blockquote&gt;&lt;p&gt;在过去的几周里，我看到了一些&lt;a href=&#34;https://mydeveloperplanet.com/2021/01/20/how-to-start-contributing-to-open-source/&#34;&gt;文章&lt;/a&gt;和&lt;a href=&#34;https://youtu.be/GAqfMNB-YBU&#34;&gt;视频&lt;/a&gt;，讲述了在开源软件中构思是多么的伟大。这次我又想起了另一篇旧文&lt;a href=&#34;http://strangelyconsistent.org/blog/perl-6-is-my-mmorpg&#34;&gt;Raku 是我的 MMORPG&lt;/a&gt;。它说，你可以从以下几个方面受益于开源软件。比如说，可以做一个大侠，基于一些开源软件来写软件。作为写手，可以写博客、微博等，对所选软件产生兴趣。或者你可以成为一个法师 - 实现新的功能和修复 bug。今天小编就带着弓箭手来告诉大家如何成为 &lt;a href=&#34;https://raku.org/&#34;&gt;Raku&lt;/a&gt; 编程语言的法师。&lt;/p&gt;
&lt;h2 id=&#34;选择一个任务&#34;&gt;选择一个任务&lt;/h2&gt;
&lt;p&gt;让我们挑选一些编译器的 bug，并修复它。让我们去 &lt;a href=&#34;https://rakudo.org/&#34;&gt;Rakudo&lt;/a&gt; 编译器 &lt;a href=&#34;https://github.com/rakudo/rakudo/issues&#34;&gt;issues&lt;/a&gt;中选择我们想要修复的 bug。我滚动了一下 bug 列表，遇到了解析 - 运气不错，我前段时间一直在研究&lt;a href=&#34;https://www.apress.com/gp/book/9781484232279&#34;&gt;编译器语法&lt;/a&gt;，看了一本这方面的好书。找到了四个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rakurs.atroxaper.net/assets/img/posts/2021-02-13-contributing-raku-1.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标签为 LTA （Less Than Awesome - 当真实行为与直觉预期不同时）- 我们暂时把它划掉。&lt;/li&gt;
&lt;li&gt;标签 &amp;ldquo;需要共识&amp;rdquo; - 我们只想修复一个不复杂的 bug - 肯定要划掉。&lt;/li&gt;
&lt;li&gt;标签为 &amp;ldquo;grammar and actions&amp;rdquo; 的关于一个可能死的代码是一个很好的候选人的第一个任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;任务确定后，现在我们需要配置工作环境。在 Windows、Linux 和 macOS 中，一切应该都差不多。我将通过 macOS 的例子来告诉你。&lt;/p&gt;
&lt;h2 id=&#34;建立工作环境&#34;&gt;建立工作环境&lt;/h2&gt;
&lt;p&gt;为源码和我们建立的编译器建立文件夹。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;mkdir ~/dev-rakudo &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; mkdir ~/dev-rakudo-install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Rakudo 编译器由三部分组成。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚拟机。现在有三种 - JVM、JS 和 MoarVM。我们以 MoarVM 为最稳定的一个。&lt;/li&gt;
&lt;li&gt;NQP（Not Quite Perl），是一种低级（中级）语言的实现，它是 Raku 的一个 &amp;ldquo;子集&amp;rdquo;。虚拟机可以执行用 NQP 编写的代码。&lt;/li&gt;
&lt;li&gt;Rakudo 编译器本身，用 NQP 和 Raku 编写。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下载并编译这三个组件。我分别花了一分半钟、半分钟和两分半钟才编好。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ~/dev-rakudo &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git clone git@github.com:MoarVM/MoarVM.git &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; MoarVM
perl Configure.pl --prefix ~/dev-rakudo-install &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -j &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install

&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ~/dev-rakudo &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git clone git@github.com:Raku/nqp.git &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; nqp
perl Configure.pl --backend&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;moar --prefix ~/dev-rakudo-install &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -j &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install

&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ~/dev-rakudo &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git clone git@github.com:rakudo/rakudo.git &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; rakudo
perl Configure.pl --backend&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;moar --prefix ~/dev-rakudo-install &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -j &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意参数。&lt;code&gt;--prefix&lt;/code&gt; 显示了 &lt;code&gt;make install&lt;/code&gt; 命令后可执行文件的复制位置，&lt;code&gt;--backend=moar&lt;/code&gt; 表示正在使用的虚拟机，而 &lt;code&gt;-j 4&lt;/code&gt; 则要求跨多线程并行化（以防加快进度）。现在我们已经建立了 Rakudo 编译器 &lt;code&gt;~/dev-rakudo-install/bin/raku&lt;/code&gt;。我们还需要官方的编译器测试套件。你应该把它和它的代码一起放在文件夹里。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ~/dev-rakudo/rakudo &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git clone https://github.com/Raku/roast.git t/spec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们先进行测试。这种情况很常见，有些测试甚至在新的变化之前就失败了。我们需要辨别出来，这样以后就不会害怕这些变化破坏了一些不必要的东西。&lt;/p&gt;
&lt;p&gt;这里和下面我将在 &lt;code&gt;~/dev-rakudo/rakudo&lt;/code&gt; 文件夹中工作，除非另有说明。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; make spectest
[...]
Test Summary Report
-------------------
t/spec/S32-str/utf8-c8.t    (Wstat: 65280 Tests: 54 Failed: 0)
  Non-zero exit status: 255
  Parse errors: Bad plan.  You planned 66 tests but ran 54.
Files=1346, Tests=117144, 829 wallclock secs (27.70 usr  6.04 sys + 2638.79 cusr 210.98 csys = 2883.51 CPU)
Result: FAIL
make: *** [m-spectest5] Error 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;14分钟内共运行了1,346个文件中的117,144次测试。一些与utf8相关的测试由于某种原因失败了，其他的都能正常工作。我们已经准备好去工作了!&lt;/p&gt;
&lt;h2 id=&#34;让我们来看看问题的陈述&#34;&gt;让我们来看看问题的陈述&lt;/h2&gt;
&lt;p&gt;问题陈述说，某个元运算符 &lt;code&gt;R&lt;/code&gt; 在 colonpair 上出了问题。我打开文档，搜索 R 这个词，但下拉列表中没有这个名字的元运算符。我试着输入 metaop，看到的是反向元操作符(R)。原来，如果你想把二元运算的操作数按相反的顺序写出来，你可以在其符号前使用前缀 R。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;say 3 R- 2 == -1 # Output: True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Colonpair 是命名对的语法。它看起来就像名字前面有一个冒号，前面有一个括号，有一个值。例如 &lt;code&gt;:foo(42)&lt;/code&gt; 是一个名称为 &lt;code&gt;foo&lt;/code&gt;、值为 &lt;code&gt;42&lt;/code&gt; 的对儿。这个语法通常用于在调用函数时，向函数传递一个命名参数中的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sub-with-named-parameter(:$foo) {
    say $foo;
}

sub-with-named-parameter(:foo(42)); # Output: 42
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果一个函数参数不是命名的，而是位置的，那么在用命名对调用时，就会出现编译错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sub-without-named-parameter($foo) { # &amp;lt;- 没有冒号
  say $foo;
}

sub-without-named-parameter(:foo(42)); # Unexpected named argument &#39;foo&#39; passed
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你在调用这样的函数时用括号包围一个参数，整个参数对将被传递到位置参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sub-without-named-parameter($foo) {
  say $foo;
}

sub-without-named-parameter((:foo(42))); # Output: foo =&amp;gt; 42
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 Raku 中，你可以写一个函数来捕获所有传递给它的参数并分析它们。这是在单个参数 - 捕获前用竖线完成的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sub-with-capture(|foo) { # &amp;lt;- 参数捕获
  say foo;
}

sub-with-capture(:foo(42));     # Output: \(:foo(42))
sub-with-capture(42);           # Output: \(42)
sub-with-capture(:foo(3 Z- 2)); # Output: \(:foo((1,).Seq))
sub-with-capture(:foo(3 R- 2)); # Output: \(-1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;倒数第二行使用了 Z 元操作符 - zip 操作符。它将左右两部分作为一个列表，按顺序每次从它们中抽取一个元素，并进行操作，从而形成一个序列。&lt;/p&gt;
&lt;p&gt;在最后一行，只用了我们需要的 R 元操作符。在这种情况下，它不是一个对，而是一个常量，它被传递到函数中。我们可以假设这是元运算符工作方式的一些特殊性，但用 Z 的例子表明并非如此。其实这是一个 bug - 当一个对被传递到一个使用 R 元运算符的函数中时，它的值会被转换。&lt;/p&gt;
&lt;h2 id=&#34;我们需要一个新的测试&#34;&gt;我们需要一个新的测试&lt;/h2&gt;
&lt;p&gt;为了确保未来的变化能够修复错误的行为，我们需要写一个新的测试。在测试文件中不难找到 R 元操作符的测试（&lt;a href=&#34;https://github.com/Raku/roast/blob/fea1d16d993eb851d2935155e0b0d074fa3593bf/S03-metaops/reverse.t&#34;&gt;S03-metops/reverse.t&lt;/a&gt;）。下面我将补充以下测试。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;# https://github.com/rakudo/rakudo/issues/1632
{
  sub subroutine($expected, |actual) {
    is actual.gist, $expected, &amp;quot;Сolonpair exists&amp;quot;
  }

  subroutine(&#39;\(:foo(-1))&#39;, :foo(3 R- 2));
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该测试有一个功能，有两个参数 - 正常和捕获。在函数体中，第一个参数和传递的 Capture 的字符串表示进行比较。你可以使用 &lt;code&gt;make&lt;/code&gt; 对新构建的编译器进行单独测试。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; make t/spec/S03-metaops/reverse.t
[...]
ok 69 - [R~]=
not ok 70 - Colonpair exists
# Failed test &#39;Colonpair exists&#39;
# at t/spec/S03-metaops/reverse.t line 191
# expected: &#39;\(:foo(-1))&#39;
#      got: &#39;\(-1)&#39;
# You planned 69 tests, but ran 70
# You failed 1 test of 70
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以看到，测试失败了（如预期）。还有一个单独的说明，系统预计69次测试，但收到70次。这是基于 TAP 的测试系统的特点 - 必须在文件的顶部修正传递给 &lt;code&gt;plan&lt;/code&gt; 函数的数字。现在测试崩溃了，但编号没有受到影响。你可以开始修复它。&lt;/p&gt;
&lt;h2 id=&#34;凝视法&#34;&gt;凝视法&lt;/h2&gt;
&lt;p&gt;一开始我很相信任务上的标签 - 如果是解析的话，一定是源码解析阶段的某个地方出现了问题。目前我的认识如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基础解析器代码在文件 &lt;code&gt;rakudo/src/Perl6/Grammar.nqp&lt;/code&gt; 中。&lt;/li&gt;
&lt;li&gt;这个解析器是从 &lt;code&gt;nqp/src/HLL/Grammar.nqp&lt;/code&gt; 文件中的基础解析器继承的。&lt;/li&gt;
&lt;li&gt;元操作符的解析和工作方式都差不多，你可以通过仔细观察来发现不同之处。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我在基础解析器代码中找到了对元操作符的引用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;token infix_prefix_meta_operator:sym&amp;lt;R&amp;gt; {
  &amp;lt;sym&amp;gt; &amp;lt;infixish(&#39;R&#39;)&amp;gt; {}
  &amp;lt;.can_meta($&amp;lt;infixish&amp;gt;, &amp;quot;reverse the args of&amp;quot;)&amp;gt;
  &amp;lt;O=.revO($&amp;lt;infixish&amp;gt;)&amp;gt;
}

token infix_prefix_meta_operator:sym&amp;lt;Z&amp;gt; {
  &amp;lt;sym&amp;gt; &amp;lt;infixish(&#39;Z&#39;)&amp;gt; {}
  &amp;lt;.can_meta($&amp;lt;infixish&amp;gt;, &amp;quot;zip with&amp;quot;)&amp;gt;
  &amp;lt;O(|%list_infix)&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这需要对 Raku grammar 有一定的了解。据我所知，原来这两个元运算符在解析上并没有根本的区别。一段时间后，在解析器的源代码中挖得够多了，我开始怀疑解析工作是否正确。认为代码 &lt;code&gt;my $r = :foo(3 R- 2); say $r; # Output: foo =&amp;gt; -1&lt;/code&gt; 正确工作的建议 - 问题恰恰发生在调用函数时。显然，我白白相信了任务栏上的标签。&lt;/p&gt;
&lt;h2 id=&#34;编译器将帮助我们&#34;&gt;编译器将帮助我们&lt;/h2&gt;
&lt;p&gt;颇为迟钝的我想起了我从一开始就应该做的事情。Rakudo 编译器有 &lt;code&gt;--target&lt;/code&gt; 调试开关。它取编译器阶段的名称，你想将其结果输出到控制台并退出。我想看看 &lt;code&gt;--target=parse&lt;/code&gt;（因为我只知道这一个）。&lt;/p&gt;
&lt;p&gt;我从 &lt;code&gt;~/dev-rakudo/rakudo&lt;/code&gt; 文件夹中使用 &lt;code&gt;rakumo-m&lt;/code&gt;，这样我就不必等待通过 &lt;code&gt;make install&lt;/code&gt; 命令将所需文件复制到 &lt;code&gt;~/dev-rakudo-install&lt;/code&gt;。简单的脚本可以这样运行。更复杂的脚本必须在 &lt;code&gt;make install&lt;/code&gt; 之后从 &lt;code&gt;-install&lt;/code&gt; 中运行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; cat ~/test.raku
sub s(|c) { say c }
s(:foo(3 R- 2));
s(:foo(3 Z- 2));

&amp;gt; ./rakudo-m --target=parse ~/test.raku
[...]
- args: (:foo(3 R- 2))
  - semiarglist: :foo(3 R- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 R- 2)
        - colonpair: :foo(3 R- 2)
          - identifier: foo
          - coloncircumfix: (3 R- 2)
            - circumfix: (3 R- 2)
              - semilist: 3 R- 2
                - statement: 1 matches
                  - EXPR: R- 2
[...]
- args: (:foo(3 Z- 2))
  - semiarglist: :foo(3 Z- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 Z- 2)
        - colonpair: :foo(3 Z- 2)
          - identifier: foo
          - coloncircumfix: (3 Z- 2)
            - circumfix: (3 Z- 2)
              - semilist: 3 Z- 2
                - statement: 1 matches
                  - EXPR: Z- 2
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结论：R 和 Z 的解析是一样的。&lt;/p&gt;
&lt;h2 id=&#34;这不是解析&#34;&gt;这不是解析&lt;/h2&gt;
&lt;p&gt;所有被解析的东西都会被传递给所谓的 Action，把字词变成一棵语法树。在我们的例子中，Actions 位于文件 &lt;code&gt;rakudo/src/Perl6/Actions.nqp&lt;/code&gt; 和 &lt;code&gt;nqp/src/HLL/Actions.nqp&lt;/code&gt; 中。这里就比较容易搞清楚了，毕竟是代码，是 grammar。&lt;/p&gt;
&lt;p&gt;我在主 Actions 中找到了以下代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
elsif $&amp;lt;infix_prefix_meta_operator&amp;gt; {
[...]
  if    $metasym eq &#39;R&#39; { $helper := &#39;&amp;amp;METAOP_REVERSE&#39;; $t := nqp::flip($t) if $t; }
  elsif $metasym eq &#39;X&#39; { $helper := &#39;&amp;amp;METAOP_CROSS&#39;; $t := nqp::uc($t); }
  elsif $metasym eq &#39;Z&#39; { $helper := &#39;&amp;amp;METAOP_ZIP&#39;; $t := nqp::uc($t); }
  
  my $metapast := QAST::Op.new( :op&amp;lt;call&amp;gt;, :name($helper), WANTED($basepast,&#39;infixish&#39;) );
  $metapast.push(QAST::Var.new(:name(baseop_reduce($base&amp;lt;OPER&amp;gt;&amp;lt;O&amp;gt;.made)), :scope&amp;lt;lexical&amp;gt;))
    if $metasym eq &#39;X&#39; || $metasym eq &#39;Z&#39;;
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它说，如果在代码中解析了元操作符 &lt;code&gt;R&lt;/code&gt;、&lt;code&gt;Z&lt;/code&gt; 或 &lt;code&gt;X&lt;/code&gt;，就应该在语法树中添加一些 &lt;code&gt;METAOP_&lt;/code&gt; 函数调用。在 &lt;code&gt;Z&lt;/code&gt; 和 &lt;code&gt;X&lt;/code&gt; 的情况下，它会多一个参数，即某种还原函数。所有这些功能都可以在 &lt;code&gt;rakudo/src/core.c/metaops.pm6&lt;/code&gt; 中找到。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub METAOP_REVERSE(\op) is implementation-detail {
  -&amp;gt; |args { op.(|args.reverse) }
}

sub METAOP_ZIP(\op, &amp;amp;reduce) is implementation-detail {
 nqp::if(op.prec(&#39;thunky&#39;).starts-with(&#39;.&#39;),
  -&amp;gt; +lol {
    my $arity = lol.elems;
    [...]
  },
  -&amp;gt; +lol {
    Seq.new(Rakudo::Iterator.ZipIterablesOp(lol,op))
  }
  )
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;给你：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;\op&lt;/code&gt; 是由我们的元操作符，即-，在前面的操作。&lt;/li&gt;
&lt;li&gt;Trait &lt;code&gt;implementation-detail&lt;/code&gt; 只是表明这不是公共代码，是编译器实现的一部分。&lt;/li&gt;
&lt;li&gt;由于-操作没有笨重的特性，所以 &lt;code&gt;&amp;amp;reduce&lt;/code&gt; 函数不会参与计算，&lt;code&gt;Z&lt;/code&gt; 的结果是 &lt;code&gt;Seq.new(...)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt; 的结果是一个操作调用 - 参数顺序相反。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这时我想起还有一个 - 目标，即星。它将显示行动的结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ./rakudo-m --target=ast ~/test.raku
[...]
- QAST::Op(call &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&amp;lt;foo&amp;gt;) &amp;lt;wanted&amp;gt; :statement_id&amp;lt;5&amp;gt; :before_promotion&amp;lt;?&amp;gt; R-
    - QAST::Op(call &amp;amp;METAOP_REVERSE) &amp;lt;wanted&amp;gt; :is_pure&amp;lt;?&amp;gt;
      - QAST::Var(lexical &amp;amp;infix:&amp;lt;-&amp;gt;) &amp;lt;wanted&amp;gt;
    - QAST::Want &amp;lt;wanted&amp;gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &amp;lt;wanted&amp;gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
- QAST::Op(call &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;7&amp;gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(:named&amp;lt;foo&amp;gt;) &amp;lt;wanted&amp;gt; :statement_id&amp;lt;8&amp;gt; :before_promotion&amp;lt;?&amp;gt; Z-
    - QAST::Op(call &amp;amp;METAOP_ZIP) &amp;lt;wanted&amp;gt; :is_pure&amp;lt;?&amp;gt;
      - QAST::Var(lexical &amp;amp;infix:&amp;lt;-&amp;gt;) &amp;lt;wanted&amp;gt;
      - QAST::Var(lexical &amp;amp;METAOP_REDUCE_LEFT)
    - QAST::Want &amp;lt;wanted&amp;gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &amp;lt;wanted&amp;gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一如所料。除了调用不同的 &lt;code&gt;METAOP_&lt;/code&gt; 函数外，所有的东西几乎都是一样的。从它们的代码中我们可以知道，原则上这些函数的不同之处在于返回值的类型 - 分别是 &lt;code&gt;Int&lt;/code&gt; 和 &lt;code&gt;Seq&lt;/code&gt;。众所周知，Raku 对不同类型的对象的上下文相当敏感&amp;hellip;&amp;hellip;我想，它关注的可能是返回值。我试着用下面的方式修改代码。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub METAOP_REVERSE(\op) is implementation-detail {
  -&amp;gt; |args { Seq.new(op.(|args.reverse)) }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译、运行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; make
[...]
Stage start      :   0.000
Stage parse      :  61.026
Stage syntaxcheck:   0.000
Stage ast        :   0.000
Stage optimize   :   7.076
Stage mast       :  14.120
Stage mbc        :   3.941
[...]
&amp;gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一切都没有改变。所以，不是返回值&amp;hellip;&amp;hellip;想了想，不知道为什么结果又是 &lt;code&gt;-1&lt;/code&gt; 而不是 &lt;code&gt;(-1,).Seq&lt;/code&gt;。而且，从代码来看，&lt;code&gt;Seq&lt;/code&gt; 根本就没有一个合适的构造函数。下一次，作为一些疯狂的事情，我尝试调用 &lt;code&gt;METAOP_REVERSE&lt;/code&gt; 结果只是为了崩溃。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub METAOP_REVERSE(\op) is implementation-detail {
  -&amp;gt; |args { die }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译、运行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; make
[...]
&amp;gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;怎么会呢？语法树中包含了对 &lt;code&gt;METAOP_REVERSE&lt;/code&gt; 的调用，它的代码应该是折叠的，但计算仍然进行，我们得到 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这些都不是《行动》。&lt;/p&gt;
&lt;p&gt;这里我的目光落在编译器的构建日志上。它是一些阶段被列在那里。我随机试了 &lt;code&gt;--target=mast&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ./rakudo-m --target=mast ~/test.raku
[...]
MAST::Frame name&amp;lt;s&amp;gt;, cuuid&amp;lt;1&amp;gt;
  Local types: 0&amp;lt;obj&amp;gt;, 1&amp;lt;obj&amp;gt;, 2&amp;lt;obj&amp;gt;, 3&amp;lt;obj&amp;gt;, 4&amp;lt;int&amp;gt;, 5&amp;lt;str&amp;gt;, 6&amp;lt;obj&amp;gt;, 7&amp;lt;obj&amp;gt;, 8&amp;lt;obj&amp;gt;,
  Lexical types: 0&amp;lt;obj&amp;gt;, 1&amp;lt;obj&amp;gt;, 2&amp;lt;obj&amp;gt;, 3&amp;lt;obj&amp;gt;, 4&amp;lt;obj&amp;gt;,
  Lexical names: 0&amp;lt;c&amp;gt;, 1&amp;lt;$¢&amp;gt;, 2&amp;lt;$!&amp;gt;, 3&amp;lt;$/&amp;gt;, 4&amp;lt;$*DISPATCHER&amp;gt;,
  Lexical map: $!&amp;lt;2&amp;gt;, c&amp;lt;0&amp;gt;, $*DISPATCHER&amp;lt;4&amp;gt;, $¢&amp;lt;1&amp;gt;, $/&amp;lt;3&amp;gt;,
  Outer: name&amp;lt;&amp;lt;unit&amp;gt;&amp;gt;, cuuid&amp;lt;2&amp;gt;
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;某种不可读的矩阵。星号和桅杆之间有一个阶段性的优化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ./rakudo-m --target=optimize ~/test.raku
[...]
- QAST::Op(callstatic &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;amp;infix:&amp;lt;-&amp;gt;)  :METAOP_opt_result&amp;lt;?&amp;gt;
    - QAST::Want &amp;lt;wanted&amp;gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
    - QAST::Want &amp;lt;wanted&amp;gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
[...]
- QAST::Op(callstatic &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;7&amp;gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&amp;lt;foo&amp;gt;) &amp;lt;wanted&amp;gt; :statement_id&amp;lt;8&amp;gt; :before_promotion&amp;lt;?&amp;gt; Z-
    - QAST::Op(callstatic &amp;amp;METAOP_ZIP) &amp;lt;wanted&amp;gt; :is_pure&amp;lt;?&amp;gt;
      - QAST::Var(lexical &amp;amp;infix:&amp;lt;-&amp;gt;) &amp;lt;wanted&amp;gt;
      - QAST::Var(lexical &amp;amp;METAOP_REDUCE_LEFT)
    - QAST::Want &amp;lt;wanted&amp;gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &amp;lt;wanted&amp;gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;哈，就是这样。在优化阶段后，行将失踪。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;QAST::Op+{QAST::SpecialArg}(call :named&amp;lt;foo&amp;gt;) &amp;lt;wanted&amp;gt; :statement_id&amp;lt;5&amp;gt; :before_promotion&amp;lt;?&amp;gt; R-.&lt;/code&gt;
并将整个 &lt;code&gt;METAOP_REVERSE&lt;/code&gt; 调用替换为通常的操作 &lt;code&gt;(&amp;amp;infix:&amp;lt;-&amp;gt;)&lt;/code&gt;。所以问题一定在优化器的某个地方。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只有在 &lt;code&gt;optim_nameless_call&lt;/code&gt; 方法中才会提到 &lt;code&gt;&amp;amp;METAOP_ASSIGN&lt;/code&gt;，其中 &lt;code&gt;QAST::Op+{QAST::SpecialArg}(call :named&amp;lt;foo&amp;gt;)&lt;/code&gt;。显然，这个操作负责生成一个命名对 - 它已经有了一个名字（命名参数），它需要计算值。从优化 &lt;code&gt;_&lt;/code&gt; 无名方法的执行路径来看，我们可以得出结论，我们对最后一个块感兴趣。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
  elsif self.op_eq_core($metaop, &#39;&amp;amp;METAOP_REVERSE&#39;) {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;amp;&amp;amp; nqp::elems($op) == 3;
    return QAST::Op.new(:op&amp;lt;call&amp;gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: &#39;METAOP_opt_result&#39;, 1;
  }
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;让我提醒你，优化前的树是这样的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
- QAST::Op(call &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&amp;lt;foo&amp;gt;) &amp;lt;wanted&amp;gt; :statement_id&amp;lt;5&amp;gt; :before_promotion&amp;lt;?&amp;gt; R-
    - QAST::Op(call &amp;amp;METAOP_REVERSE) &amp;lt;wanted&amp;gt; :is_pure&amp;lt;?&amp;gt;
      - QAST::Var(lexical &amp;amp;infix:&amp;lt;-&amp;gt;) &amp;lt;wanted&amp;gt;
    - QAST::Want &amp;lt;wanted&amp;gt; 3
    - QAST::Want &amp;lt;wanted&amp;gt; 2
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而精简之后，是这样的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
- QAST::Op(callstatic &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;amp;infix:&amp;lt;-&amp;gt;)  :METAOP_opt_result&amp;lt;?&amp;gt;
    - QAST::Want &amp;lt;wanted&amp;gt; 2
    - QAST::Want &amp;lt;wanted&amp;gt; 3
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说，优化 &lt;code&gt;_nameless_call&lt;/code&gt; 做了以下工作。&lt;/p&gt;
&lt;p&gt;如果我们的 &lt;code&gt;QAST::Op+{QAST::SpecialArg}&lt;/code&gt; 操作没有三个参数，如果 &lt;code&gt;METAOP_REVERSE&lt;/code&gt; 调用没有一个正确的类型，我们就返回空。这不是我们的情况。
否则，我们将返回一个新的操作，代替我们的 &lt;code&gt;QAST::Op+{QAST::SpecialArg}&lt;/code&gt; 操作，以相反的顺序调用 &lt;code&gt;&amp;amp;infix:&amp;lt;-&amp;gt;&lt;/code&gt; 参数。就是说，把结果打包成一对就没了。&lt;/p&gt;
&lt;p&gt;在摸索了一下如何解决这个问题，并阅读了 &lt;code&gt;QAST::SpecialArg&lt;/code&gt; 和 &lt;code&gt;QAST::Node&lt;/code&gt; 的实现后，我想到了下面的代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
  elsif self.op_eq_core($metaop, &#39;&amp;amp;METAOP_REVERSE&#39;) {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;amp;&amp;amp; nqp::elems($op) == 3;
    my $opt_result := QAST::Op.new(:op&amp;lt;call&amp;gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: &#39;METAOP_opt_result&#39;, 1;
    if $op.named { $opt_result.named($op.named) } # 添加选项 named 
    if $op.flat { $opt_result.flat($op.flat) }    # 添加选项 flat
    return $opt_result;
  }
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还有木头。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
- QAST::Op(callstatic &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call &amp;amp;infix:&amp;lt;-&amp;gt; :named&amp;lt;foo&amp;gt;)  :METAOP_opt_result&amp;lt;?&amp;gt;
    - QAST::Want &amp;lt;wanted&amp;gt; 2
    - QAST::Want &amp;lt;wanted&amp;gt; 3
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命名的参数返回到它的位置。测试也开始通过。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; make t/spec/S03-metaops/reverse.t
[...]
All tests successful.
Files=1, Tests=70,  3 wallclock secs ( 0.03 usr  0.01 sys +  3.61 cusr  0.17 csys =  3.82 CPU)
Result: PASS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们本可以就此打住，但这是编译器优化器的代码，它的结果是一个有两个整数参数的方法调用。我认为这在某种程度上是次优的。如果我们将返回表达式改为返回 &lt;code&gt;self.visit_op: $opt_result;&lt;/code&gt;，对产生的非优化操作调用优化器，那么产生的树就会像这样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
- QAST::Op(callstatic &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Want+{QAST::SpecialArg}(:named&amp;lt;foo&amp;gt;)
    - QAST::WVal+{QAST::SpecialArg}(Int :named&amp;lt;foo&amp;gt;)
    - QAST::IVal(-1)
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在一切都很理想。&lt;/p&gt;
&lt;h2 id=&#34;分享成果&#34;&gt;分享成果&lt;/h2&gt;
&lt;p&gt;我们已经到了终点线。现在我们只需要分享我们的经验。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重要的是：运行所有的 &lt;code&gt;make spectest&lt;/code&gt; 测试，确保没有新的东西被破坏。&lt;/li&gt;
&lt;li&gt;在 GitHub 上使用 Rakudo 编译器和测试制作 fork 仓库。&lt;/li&gt;
&lt;li&gt;将 fork 仓库添加为新的 git 远程仓库。&lt;/li&gt;
&lt;li&gt;cd ~/dev-rakudo/rakudo &amp;amp;&amp;amp; git remote add fork &lt;!-- raw HTML omitted --&gt;。&lt;/li&gt;
&lt;li&gt;cd ~/dev-rakudo/t/spec &amp;amp;&amp;amp; git remote add fork &lt;!-- raw HTML omitted --&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重要：确保两个仓库在 git 中都有正确的用户名和用户邮箱。&lt;/p&gt;
&lt;p&gt;提交到两个版本库，详细说明你为什么做了哪些改动，并添加对原始问题跟踪器的引用。&lt;/p&gt;
&lt;p&gt;运行提交。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd ~/dev-rakudo/rakudo &amp;amp;&amp;amp; git push fork
cd ~/dev-rakudo/t/spec &amp;amp;&amp;amp; git push fork
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向两个仓库提出拉取请求。在他们的描述中，最好是相互参照和原任务。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;对开源软件的贡献是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;趣味性和趣味性。&lt;/li&gt;
&lt;li&gt;给你的感觉是，你正在做一些有用的事情，你真的是。&lt;/li&gt;
&lt;li&gt;让你认识新的有趣和专业的人（任何关于 Raku 的问题都会在 &lt;code&gt;#raku IRC&lt;/code&gt; 频道中得到回答）。&lt;/li&gt;
&lt;li&gt;解决非标准任务，没有截止日期的压力，是一种很好的体验。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选择你觉得最舒服的角色等级，去做新的任务吧!&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/rakulang">rakulang</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/rakulang">Rakulang</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/</guid>
                <pubDate>Tue, 16 Feb 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>Caesarean Substrings With Raku and Perl</title>
                <link>https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/</link>
                
                
                <description>&lt;blockquote&gt;Caesarean Substrings With Raku and Perl&lt;/blockquote&gt;&lt;p&gt;[113] 发表于2021年1月30日。
这是我对 &lt;a href=&#34;https://perlweeklychallenge.org/blog/perl-weekly-challenge-097/&#34;&gt;Perl 每周挑战#097&lt;/a&gt; 的回应。&lt;/p&gt;
&lt;h2 id=&#34;挑战-0971-凯撒密码&#34;&gt;挑战 #097.1: 凯撒密码&lt;/h2&gt;
&lt;p&gt;给你一个只包含字母 &lt;code&gt;A..Z&lt;/code&gt; 的字符串 &lt;code&gt;$S&lt;/code&gt; 和一个数字 &lt;code&gt;$N&lt;/code&gt;。
写一个脚本，用&lt;a href=&#34;https://en.wikipedia.org/wiki/Caesar_cipher&#34;&gt;凯撒密码&lt;/a&gt;对给定的字符串 &lt;code&gt;$S&lt;/code&gt; 进行加密，左移大小为 &lt;code&gt;$N&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例子:
输入: $S = &amp;ldquo;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&amp;rdquo;, $N = 3
输出: &amp;ldquo;QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Plain:    ABCDEFGHIJKLMNOPQRSTUVWXYZ
Cipher:   XYZABCDEFGHIJKLMNOPQRSTUVW&lt;/p&gt;
&lt;p&gt;Plaintext:  THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG
Ciphertext: QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD&lt;/p&gt;
&lt;p&gt;&amp;ldquo;只用字母 &lt;code&gt;A...Z&lt;/code&gt;&amp;rdquo; 的表述是错误的，因为例子中也有几个空格。因此，应该允许这些空格。&lt;/p&gt;
&lt;p&gt;文件: caesar-cipher&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;#! /usr/bin/env raku

subset AZ-space of Str where /^ &amp;lt;[ A .. Z \s ]&amp;gt;+ $/;   # [1]
subset PosInt of Int where -25 &amp;lt;= $_ &amp;lt;= 25;            # [2]

unit sub MAIN (AZ-space $S = &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39;,
               PosInt $N = 3);                         # [3]

say $S.comb.map({ caesar($_, $N) }).join;              # [4]

sub caesar ($char, $shift)
{
  return $char if $char eq &amp;quot; &amp;quot;;                        # [5]

  my $code = $char.ord;                                # [6]

  $code -= $shift;                                     # [7]

  $code += 26 if $code &amp;lt; 65;  # &#39;A&#39;                    # [8]
  $code -= 26 if $code &amp;gt; 90;  # &#39;Z&#39;                    # [8a]

  return $code.chr;                                    # [9]
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[1] 所允许的字符 (或 «特定领域字母»).&lt;/p&gt;
&lt;p&gt;[2] 挑战说左移值是一个数字。允许除整数以外的任何东西是没有意义的，所以我把值限制在这个类型。负值应该是可以的，它们意味着右移值（而不是左移）。&lt;/p&gt;
&lt;p&gt;[3] 参数，默认值为挑战中给出的值。&lt;/p&gt;
&lt;p&gt;[4] 将字符串分割成单个字符（用梳子(comb)，在每个字符上应用 &amp;ldquo;caesar&amp;rdquo; 函数（用map），再次将字符连接成一个字符串（用join），然后打印出来。&lt;/p&gt;
&lt;p&gt;[5] 不移动空格。&lt;/p&gt;
&lt;p&gt;[6] 获取字符的代码点。&lt;/p&gt;
&lt;p&gt;[7] 减去移位值（当我们向左移位时，或在字母表中降低移位值）。&lt;/p&gt;
&lt;p&gt;[8] 绕回, 如果我们移出A-Z范围，这里为更低 - 或更高的 [8b]。&lt;/p&gt;
&lt;p&gt;[9] 获取指定代码点的字符。&lt;/p&gt;
&lt;p&gt;查看 docs.raku.org/routine/ord 获取更多关于 ord 的信息。&lt;/p&gt;
&lt;p&gt;查看 docs.raku.org/routine/chr 获取更多关于 chr 的信息。&lt;/p&gt;
&lt;p&gt;运行它:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./caesar-cipher &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Raku 有一个 ords 变体，它接收一整个字符串，而不是一个字符作为 ord。还有 chrs，它接收一个代码点数组，并将它们变成一个字符串，而不是像 chr 那样接收一个字符的代码点。让我们用它们来写一个更短的程序。&lt;/p&gt;
&lt;p&gt;文件: caesar-cipher-map&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;#! /usr/bin/env raku

subset AZ-space of Str where /^ &amp;lt;[ A .. Z \s ]&amp;gt;+ $/;
subset PosInt of Int where -25 &amp;lt;= $_ &amp;lt;= 25;

unit sub MAIN (AZ-space $S = &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39;,
               PosInt $N = 3);

say caesar($S, $N);

sub caesar ($string, $shift)
{
  return $string.ords.map({$_ == 32 ?? 32 !! (($_ - $shift - 65) % 26 ) + 65}).chrs;
    # #################### # 1a ############# ############ # 1b  # 1c ## 1d
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[1] 我们使用map来改变各个代码点。我们让代码点为32的空间单独存在[1a]。每一个其他的值我们都还原成0到25之间的数字（通过减去第一个字母的代码点（A：65）和移位值[1b]）。模数运算符 (%) 为我们处理负值，做正确的事情。例如：-2 % 26 -&amp;gt; 24 [1c]。然后我们添加调整值到它们应该在的位置(从A到Z)[1d]，然后我们将整个数组的代码点变成一个字符串。&lt;/p&gt;
&lt;p&gt;查看 docs.raku.org/routine/ords 获取更多关于 ords 的信息。&lt;/p&gt;
&lt;p&gt;查看 docs.raku.org/routine/chrs 获取更多关于 chrs 的信息。&lt;/p&gt;
&lt;p&gt;运行它的结果和之前一样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./caesar-cipher-map &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher-map &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher-map &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher-map &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;perl-版本&#34;&gt;Perl 版本&lt;/h2&gt;
&lt;p&gt;这是对第一个 Raku 版的直接翻译。&lt;/p&gt;
&lt;p&gt;File: caesar-cipher-perl&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span class=&#34;ch&#34;&gt;#! /usr/bin/env perl&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;use&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;strict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;use&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;warnings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;use&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;feature&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#39;say&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;use&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;feature&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#39;signatures&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;no&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;warnings&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;experimental::signatures&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;my&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$S&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;shift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;@ARGV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;sr&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;nb&#34;&gt;die&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Illegal characters&amp;#34;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;unless&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$S&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=~&lt;/span&gt;&lt;span class=&#34;sr&#34;&gt; /^[A-Z\s]+$/&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;my&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;shift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;@ARGV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;sr&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;nb&#34;&gt;die&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Illegal shift $N&amp;#34;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!~&lt;/span&gt; &lt;span class=&#34;sr&#34;&gt;/^\-?\d+$/&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;say&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;map&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;caesar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;split&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sr&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;sub&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;caesar&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;($char, $shift)
&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$char&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$char&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;eq&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;k&#34;&gt;my&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;ord&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

  &lt;span class=&#34;nv&#34;&gt;$code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$shift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;nv&#34;&gt;$code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;26&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;65&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# &amp;#39;A&amp;#39;&lt;/span&gt;
  &lt;span class=&#34;nv&#34;&gt;$code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;26&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;90&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# &amp;#39;Z&amp;#39;&lt;/span&gt;

  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;chr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行它的结果和 Raku 版一样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./caesar-cipher-perl &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher-perl &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher-perl &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher-perl &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;挑战-0972二进制子字符串binary-substrings&#34;&gt;挑战 #097.2：二进制子字符串(Binary Substrings)&lt;/h2&gt;
&lt;p&gt;给你一个二进制字符串 &lt;code&gt;$B&lt;/code&gt; 和一个整数 &lt;code&gt;$S&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;写一个脚本来拆分大小为 &lt;code&gt;$S&lt;/code&gt; 的二进制字符串 &lt;code&gt;$B&lt;/code&gt;，然后找出使其相同的最小翻转次数。&lt;/p&gt;
&lt;p&gt;例 1:
输入: $B = “101100101”, $S = 3
输出: 1&lt;/p&gt;
&lt;p&gt;二进制子字符串:
&amp;ldquo;101&amp;rdquo;: 0 flip
&amp;ldquo;100&amp;rdquo;: 1 flip to make it &amp;ldquo;101&amp;rdquo;
&amp;ldquo;101&amp;rdquo;: 0 flip&lt;/p&gt;
&lt;p&gt;例 2:
输入 $B = “10110111”, $S = 4
输出: 2&lt;/p&gt;
&lt;p&gt;二进制子字符串:
&amp;ldquo;1011&amp;rdquo;: 0 flip
&amp;ldquo;0111&amp;rdquo;: 2 flips to make it &amp;ldquo;1011&amp;rdquo;&lt;/p&gt;
&lt;p&gt;我们先从第一个例子中的二进制子字符串中砍掉3个字符块。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; say &amp;quot;101100101&amp;quot;.comb(3);   # -&amp;gt; (101 100 101)
&amp;gt; say &amp;quot;1011001010&amp;quot;.comb(3);  # -&amp;gt; (101 100 101 0)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二行显示了如果长度不匹配会发生什么。这就给了我们一个非法的值，因为我们不能将一位数翻转为三位数的值。所以我们必须添加一个检查。&lt;/p&gt;
&lt;p&gt;然后我们将第一个子串与其余的子串进行比较，一次一个。在这里使用bitwise XOR（Exclusive OR）运算符是一个合理的选择。这给了我们一个二进制值，其中1的数量就是该子串的翻转次数。Raku确实有一个XOR运算符。+^. 但是它 &amp;ldquo;将两个参数都强制为Int，并进行位智XOR操作&amp;rdquo;(根据文档&amp;quot;；参见docs.raku.org/language/operators#infix_+^)。&lt;/p&gt;
&lt;p&gt;我们可以在进行XOR操作之前，将二进制值转换为十进制值。让我们试试。&lt;/p&gt;
&lt;p&gt;获取翻转的次数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; say (&amp;quot;10101&amp;quot;.parse-base(2) +^ &amp;quot;10111&amp;quot;.parse-base(2)).base(2).comb.sum;  # -&amp;gt; 1
&amp;gt; say (&amp;quot;11101&amp;quot;.parse-base(2) +^ &amp;quot;10111&amp;quot;.parse-base(2)).base(2).comb.sum;  # -&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这当然可行，但需要大量的代码。所以我将使用一个更简单的方法 - 逐个比较每个数字。&lt;/p&gt;
&lt;p&gt;File: binary-substring&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;#! /usr/bin/env raku

subset BinaryString where /^ &amp;lt;[01]&amp;gt;+ $/;                    # [1]
subset PosInt of Int where * &amp;gt; 0;                           # [2]

unit sub MAIN (BinaryString $B = &#39;101100101&#39;,               # [1]
               PosInt $S where $B.chars %% $S = 3,          # [2]
	       :v(:$verbose));

my @B     = $B.comb($S.Int);                                # [3]
my $first = @B.shift;                                       # [4]
my $total = 0;                                              # [5]

for @B -&amp;gt; $current                                          # [6]
{
  my $flip = bit-diff($first, $current);                    # [7]
  $total += $flip;                                          # [8]
  say &amp;quot;: $first -&amp;gt; $current -&amp;gt; Flip: $flip&amp;quot; if $verbose;
}

say $total;                                                 # [9]

sub bit-diff ($a, $b)                                       # [7]
{
  my $flip = 0;                                             # [10]

  for ^$a.chars -&amp;gt; $index                                   # [11]
  {
    $flip++ if $a.substr($index,1) ne $b.substr($index,1);  # [12]
  }

  return $flip;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[1] 确保二进制字符串是合法的（只包含 &amp;ldquo;0 &amp;ldquo;和 &amp;ldquo;1&amp;rdquo;）。&lt;/p&gt;
&lt;p&gt;[2] 确保是一个正整数，同时确保字符串是被它偶数分割的。(例如，&amp;ldquo;4 &amp;ldquo;给我们提供了长度为4的子串，如果最后一个较短，程序将中止。)&lt;/p&gt;
&lt;p&gt;[3] 梳子通常用于将一个字符串分割成单个字符，但我们可以通过指定长度来获得每个子字符串中的多个字符，比如这样。&lt;/p&gt;
&lt;p&gt;[4] 例子首先将第一个子串与自己进行比较，给出零翻转。这是愚蠢的(ish)，所以我跳过这一点，把第一个子串移出。&lt;/p&gt;
&lt;p&gt;[5] 结果会到这里。&lt;/p&gt;
&lt;p&gt;[6] 对于每一个子串（除了第一个，见[4]）。&lt;/p&gt;
&lt;p&gt;[7] 获取每个子串的翻转次数。&lt;/p&gt;
&lt;p&gt;[8] 并将其添加到总数中。&lt;/p&gt;
&lt;p&gt;[9] 打印它。&lt;/p&gt;
&lt;p&gt;[10] 翻转的数量会在这里。&lt;/p&gt;
&lt;p&gt;[11] 对于两个子串中的每个索引（具有相同的长度）。&lt;/p&gt;
&lt;p&gt;[12] - 如果给定位置上的字符不同，则在总数的基础上加1，意味着移动。&lt;/p&gt;
&lt;p&gt;See docs.raku.org/routine/comb for more information about comb.&lt;/p&gt;
&lt;p&gt;运行它。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./binary-substring &amp;quot;101100101&amp;quot; 3
 1

$ ./binary-substring -v &amp;quot;101100101&amp;quot; 3
: 101 -&amp;gt; 100 -&amp;gt; Flip: 1
: 101 -&amp;gt; 101 -&amp;gt; Flip: 0
1

$ ./binary-substring &amp;quot;10110111&amp;quot; 4
2

$ ./binary-substring -v &amp;quot;10110111&amp;quot; 4
: 1011 -&amp;gt; 0111 -&amp;gt; Flip: 2
2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看起来不错。&lt;/p&gt;
&lt;h2 id=&#34;perl&#34;&gt;Perl&lt;/h2&gt;
&lt;p&gt;这是对 Raku 版本的直接翻译，只是我必须实现 &amp;ldquo;comb&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;文件： binary-substring-perl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;#! /usr/bin/env perl

use strict;
use warnings;
use feature &#39;say&#39;;
use feature &#39;signatures&#39;;
use Getopt::Long;

no warnings &amp;quot;experimental::signatures&amp;quot;;

my $verbose = 0;

GetOptions(&amp;quot;verbose&amp;quot;  =&amp;gt; \$verbose);

my $B = shift(@ARGV) // &#39;101100101&#39;;

die &amp;quot;Not a binary number&amp;quot; unless $B =~ /^[01]+$/;

my $S = shift(@ARGV) // 3;

die &amp;quot;Not an integer&amp;quot; unless $S =~ /^[1-9][0-9]*$/;
die &amp;quot;Not a legal length&amp;quot; if length($B) % $S;

my @B     =  comb($B, $S);
my $first = shift(@B);
my $total = 0;

for my $current (@B)
{
  my $flip = bit_diff($first, $current);
  $total += $flip;
  say &amp;quot;: $first -&amp;gt; $current -&amp;gt; Flip: $flip&amp;quot; if $verbose;
}

say $total;

sub bit_diff ($a, $b)
{
  my $flip = 0;

  for my $index (0 .. length($a))
  {
    $flip++ if substr($a, $index,1) ne substr($b, $index,1);
  }

  return $flip;
}

sub comb ($string, $length = 1)  # [1]
{
  my @result;

  while ($string)
  {
    push(@result, substr($string, 0, $length));
    $string = substr($string, $length);
  }
  return @result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[1] 缺失的 Raku 例程 &amp;ldquo;comb&amp;rdquo;。可选的第二个参数指定了它所返回的每个子串中所包含的（第一个参数的）子串长度。&lt;/p&gt;
&lt;p&gt;运行它的结果与 Raku 版本相同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./binary-substring-perl &amp;quot;101100101&amp;quot; 3
1

$ ./binary-substring-perl -v &amp;quot;101100101&amp;quot; 3
: 101 -&amp;gt; 100 -&amp;gt; Flip: 1
: 101 -&amp;gt; 101 -&amp;gt; Flip: 0
1

$ ./binary-substring-perl &amp;quot;101100111&amp;quot; 3
2

$ ./binary-substring-perl -v &amp;quot;101100111&amp;quot; 3
: 101 -&amp;gt; 100 -&amp;gt; Flip: 1
: 101 -&amp;gt; 111 -&amp;gt; Flip: 1
2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就是这样。&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/raku">Raku</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/rakulang">Rakulang</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/</guid>
                <pubDate>Sun, 07 Feb 2021 00:00:00 +0800</pubDate>
            </item>
        
    </channel>
</rss>


