<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
    
    
    

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    
    <meta name="referrer" content="no-referrer">

    <title>
        
            正则表达式 ❚ 焉知非鱼
        
    </title>

    
    


    
    
    
    

    
    
    
    

    
    
    

    
    
    
    <style>
     
     
     :root {
         --theme-color: #ac4142;
         --theme-color-light: rgba(172, 65, 66, 0.2);
     }
     
     html {
         line-height: 1.5;
     }
    </style>

    
    

    
    
    
    
    <link rel="stylesheet" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css">
    
    <link rel="preload" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css" as="style">

    



    
        <style>
         
         /* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }

         
         /* Overrides on top of the theme and Chroma CSS */
/* Chroma-based lines highlighting in code blocks */
.chroma .hl {
    background-color: #e8e8e8;
    /* Extend highlight up to 100 characters (assuming that the code blocks never have more than 100 characters in a line) */
    min-width: 100ch;
}
/* GenericHeading */ .chroma .gh { color: #999999; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa; font-weight: bold }

         
        </style>
    

    

    
    
    

    
    <script src="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js"></script>
    
    <link rel="preload" href="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js" as="script">

    
    
    <script defer src="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js"></script>
    
    <link rel="preload" href="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js" as="script">

    

    

    
    
    

    
    
<!-- rel="me" links for IndieAuth -->







    
 
<meta property="og:title" content="正则表达式" />
<meta property="og:description"
      content=" " />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/rakulang/61.regexes/" />


    
        <meta property="article:published_time" content="2018-12-05T21:13:31&#43;08:00"/>
    
    
        <meta property="article:modified_time" content="2018-12-05T21:13:31&#43;08:00"/>
    









    




     <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="正则表达式"/>
<meta name="twitter:description" content=" "/>


    
    
    <link rel="alternate" type="application/jf2post+json" href="http://localhost:1313/rakulang/61.regexes/jf2post.json" title="Jf2post for 焉知非鱼" />
    
     



    
    
    
        
    


     
        
        <meta name="DC.Creator" content="焉知非鱼"/>
    



    
    
    
    <meta name="hugo-build-date" content="2024-03-01T16:16:06Z"/>
    <meta name="hugo-commit-hash" content="312735366b20d64bd61bff8627f593749f86c964"/>
    <meta name="generator" content="Hugo 0.123.7">
</head>


    
        <body lang="en">
    

        
        <div class="border" id="home"></div>

        <div class="wrapper">   
            
<nav id="nav" class="nav-collapse opened" aria-hidden="false">
    <ul class="navbar">
        <li><a class="" href="/">Home</a></li>
        
            
                <li><a class="" href="http://localhost:1313/posts/">Posts</a></li>
            
        
            
                <li><a class="" href="http://localhost:1313/notes/">Notes</a></li>
            
        
            
                <li><a class="" href="http://localhost:1313/rakulang/">Rakulang</a></li>
            
        
        
            <li><a class="" href="http://localhost:1313/search/">Search</a></li>
        
    </ul>
</nav>

            <div class="container">
                <header class="masthead">
                    <div class="masthead-title no-text-decoration">
                        <a href="/">焉知非鱼</a> <span class="blinking-cursor">❚</span>
                    </div>
                    <div class="masthead-tagline">
                        Wait the light to fall
                    </div>
                </header>

                








<article class="post h-entry rakulang">
    <header>
        <div class="center">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="http://localhost:1313/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="http://localhost:1313/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>

        <h1 class="post-title p-name">正则表达式</h1>

        
        <data class="u-url" value="http://localhost:1313/rakulang/61.regexes/"></data>

        <div class="date-syndication">
            


    
    
    <div class="post-date">
        
        <time datetime="2018-12-05T21:13:31+0800" class="dt-published">Wed Dec 5, 2018</time>
        
        
    </div>


            




        </div>
         



    
    
    
        
    


    
        
        <span class="hide">
            &mdash; <a href="http://localhost:1313/" class="u-author">焉知非鱼</a>
        </span>
    


    </header>

    <div class="content">
        


        





                       


        <div class="e-content">
            




<p>正则表达式, 简称 regexes, 是描述文本模式的字符序列。模式匹配就是将这些模式和实际的文本进行匹配的过程。</p>
<h2 id="词法约定">词法约定&nbsp;<a class="headline-hash no-text-decoration" href="#词法约定">#</a> </h2>
<p>Raku 正则表达式有特殊的写法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">m</span><span class="p">/</span><span class="sr">abc</span><span class="p">/;</span>         <span class="c1"># a regex that is immediately matched against $_ </span>
</span></span><span class="line"><span class="cl"><span class="k">rx</span><span class="p">/</span><span class="sr">abc</span><span class="p">/;</span>        <span class="c1"># a Regex object </span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr">abc</span><span class="p">/;</span>          <span class="c1"># a Regex object </span>
</span></span></code></pre></div><p>对于前两个例子,  分隔符还能用除了斜线之外的其它字符:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">m</span><span class="p">{</span><span class="sr">abc</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">rx</span><span class="p">{</span><span class="sr">abc</span><span class="p">};</span>
</span></span></code></pre></div><p>注意, 冒号和圆括号都不能用作分隔符; 禁止使用冒号作为正则表达式分割符是因为它和副词冲突, 例如 <code>rx:i/abc/</code>(忽略大小写的正则表达式), 而圆括号表明函数调用。</p>
<p>空白符在正则表达式中通常被忽略(带有 <code>:s</code> 或 <code>:sigspace</code> 副词的正则表达式除外)。</p>
<p>通常, 对于 Raku 来说, 正则表达式中的注释以 <code>#</code> 号开头, 直至行尾。</p>
<h2 id="字面值">字面值&nbsp;<a class="headline-hash no-text-decoration" href="#字面值">#</a> </h2>
<p>正则表达式最简单的情况是匹配字符串字面值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">properly</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> perl </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">&#39;properly&#39; contains &#39;perl&#39;</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>字母数字和下划线 <code>_</code> 按字面值匹配。所有其它字符要么使用反斜线转义(例如, <code>\:</code> 匹配一个冒号), 要么用引号引起来:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">two words</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">/;</span>     <span class="c1"># matches &#39;two words&#39; including the blank </span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&#34;</span><span class="s2">a:b</span><span class="p">&#34;</span><span class="sr">       </span><span class="p">/;</span>     <span class="c1"># matches &#39;a:b&#39; including the colon </span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">#</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">/;</span>             <span class="c1"># matches a hash character </span>
</span></span></code></pre></div><p>字符串是从左往右搜索的, 所以如果只有部分字符串匹配正则表达式也足够:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abcdef</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> de </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$/</span><span class="p">;</span>            <span class="c1"># OUTPUT: «de␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">prematch</span><span class="p">;</span>    <span class="c1"># OUTPUT: «abc␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">postmatch</span><span class="p">;</span>   <span class="c1"># OUTPUT: «f␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">from</span><span class="p">;</span>        <span class="c1"># OUTPUT: «3␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">to</span><span class="p">;</span>          <span class="c1"># OUTPUT: «5␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>匹配结果存储在 <code>$/</code> 变量中并且也从匹配中返回。如果匹配成功, 那么结果就是 <a href="https://docs.raku.org/type/Match">Match</a> 类型, 否则它就是 <a href="https://docs.raku.org/type/Nil">Nil</a></p>
<h2 id="通配符和字符类">通配符和字符类&nbsp;<a class="headline-hash no-text-decoration" href="#通配符和字符类">#</a> </h2>
<h3 id="点号匹配任意字符-">点号匹配任意字符: .&nbsp;<a class="headline-hash no-text-decoration" href="#点号匹配任意字符-">#</a> </h3>
<p>在正则表达式中一个未转义的点 <code>.</code>  匹配任意单个字符。</p>
<p>所以,  这些都匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">perl</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">per</span><span class="ni">.</span><span class="p">/;</span>       <span class="c1"># matches the whole string </span>
</span></span><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">perl</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> per </span><span class="ni">.</span><span class="sr"> </span><span class="p">/;</span>    <span class="c1"># the same; whitespace is ignored </span>
</span></span><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">perl</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> pe</span><span class="ni">.</span><span class="sr">l </span><span class="p">/;</span>     <span class="c1"># the . matches the r </span>
</span></span><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">speller</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> pe</span><span class="ni">.</span><span class="sr">l</span><span class="p">/;</span>   <span class="c1"># the . matches the first l </span>
</span></span></code></pre></div><p>下面这个不匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">perl</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">.</span><span class="sr"> per </span><span class="p">/;</span>
</span></span></code></pre></div><p>因为在目标字符串中 <code>per</code> 前面没有要匹配的字符。</p>
<h3 id="反斜杠-预定义字符类">反斜杠, 预定义字符类&nbsp;<a class="headline-hash no-text-decoration" href="#反斜杠-预定义字符类">#</a> </h3>
<h3 id="unicode-properties">Unicode properties&nbsp;<a class="headline-hash no-text-decoration" href="#unicode-properties">#</a> </h3>
<p>Raku 有 <code>\w</code> 形式的预定义字符类。大写形式是它的反面, <code>\W</code>。</p>
<ul>
<li>\d 和 \D</li>
</ul>
<p><code>\d</code> 匹配单个数字(Unicode 属性 N) 而 <code>\D</code> 匹配单个不是数字的字符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">ab42</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="se">\d</span><span class="p">/</span> <span class="ow">and</span> <span class="nb">say</span> <span class="o">~</span><span class="nv">$/</span><span class="p">;</span>     <span class="c1"># OUTPUT: «4␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">ab42</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="se">\D</span><span class="p">/</span> <span class="ow">and</span> <span class="nb">say</span> <span class="o">~</span><span class="nv">$/</span><span class="p">;</span>     <span class="c1"># OUTPUT: «a␤» </span>
</span></span></code></pre></div><p>注意, 不仅仅只有阿拉伯数字(通常用于拉丁字母表中)匹配 <code>\d</code>, 还有来自其它下标的数字也匹配 \d。</p>
<pre tabindex="0"><code>U+0035 5 DIGIT FIVE
U+07C2 ߂ NKO DIGIT TWO
U+0E53 ๓ THAI DIGIT THREE
U+1B56 ᭖ BALINESE DIGIT SIX
</code></pre><ul>
<li>\h 和 \H</li>
</ul>
<p><code>\h</code> 匹配单个水平空白符。 <code>\H</code> 匹配单个不是水平空白符的字符。</p>
<p>水平空白符的例子有:</p>
<pre tabindex="0"><code>U+0020 SPACE
U+00A0 NO-BREAK SPACE
U+0009 CHARACTER TABULATION
U+2001 EM QUAD
</code></pre><p>像换行符那样的垂直空白被显式地排除了; 那些可以用 <code>\v</code> 来匹配, 而 <code>\s</code> 匹配任何类型的空白:</p>
<ul>
<li>\n 和 \N</li>
</ul>
<p><code>\n</code> 匹配单个逻辑换行符。<code>\n</code> 也支持匹配 Windows 的 CR LF 代码点对儿;　尽管还不清楚魔法是发生在读取数据时还是在正则表达式匹配时。 <code>\N</code> 匹配单个非逻辑换行符。</p>
<ul>
<li>\s 和 \S</li>
</ul>
<p><code>\s</code> 匹配单个空白符。 <code>\S</code> 匹配单个非空白符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">contains a word starting with &#34;w&#34;</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> w </span><span class="se">\S</span><span class="o">+</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$/</span><span class="p">;</span>        <span class="c1"># OUTPUT: «word␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>\t 和 \T</li>
</ul>
<p><code>\t</code> 匹配单个 tab/制表符, <code>U+0009</code>。(注意这儿不包含诸如 <code>U+000B VERTICAL TABULATION</code> 这样奇异的制表符)。<code>\T</code> 匹配单个非制表符。</p>
<ul>
<li>\v 和 \V</li>
</ul>
<p><code>\v</code> 匹配单个垂直空白符。 <code>\V</code> 匹配单个非垂直空白符。</p>
<p>垂直空白符的例子:</p>
<pre tabindex="0"><code>U+000A LINE FEED
U+000B VERTICAL TABULATION
U+000C FORM FEED
U+000D CARRIAGE RETURN
U+0085 NEXT LINE
U+2028 LINE SEPARATOR
U+2029 PARAGRAPH SEPARATOR
</code></pre><p>使用 <code>\s</code> 去匹配任意空白, 而不仅仅匹配垂直空白。</p>
<ul>
<li>\w 和 \W</li>
</ul>
<p><code>\w</code> 匹配单个单词字符; 例如: 一个字母(Unicode 类别 L), 一个数字或一个下划线。<code>\W</code> 匹配单个非单词字符。</p>
<p>单词字符的例子:</p>
<pre tabindex="0"><code>0041 A LATIN CAPITAL LETTER A
0031 1 DIGIT ONE
03B4 δ GREEK SMALL LETTER DELTA
03F3 ϳ GREEK LETTER YOT
0409 Љ CYRILLIC CAPITAL LETTER LJE
</code></pre><p>预定义的 subrules:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">alnum</span><span class="p">&gt;</span>   \<span class="nb">w</span>       <span class="p">&#39;</span><span class="s1">alpha</span><span class="p">&#39;</span> <span class="nb">plus</span> <span class="p">&#39;</span><span class="s1">digit</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">alpha</span><span class="p">&gt;</span>   <span class="p">&lt;</span><span class="s">:L</span><span class="p">&gt;</span>     <span class="n">Alphabetic</span> <span class="n">characters</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">blank</span><span class="p">&gt;</span>   \<span class="n">h</span>       <span class="n">Horizontal</span> <span class="n">whitespace</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">cntrl</span><span class="p">&gt;</span>            <span class="n">Control</span> <span class="n">characters</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">digit</span><span class="p">&gt;</span>   \<span class="nb">d</span>       <span class="n">Decimal</span> <span class="n">digits</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">graph</span><span class="p">&gt;</span>            <span class="p">&#39;</span><span class="s1">alnum</span><span class="p">&#39;</span> <span class="nb">plus</span> <span class="p">&#39;</span><span class="s1">punct</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">lower</span><span class="p">&gt;</span>   <span class="p">&lt;</span><span class="s">:Ll</span><span class="p">&gt;</span>    <span class="n">Lowercase</span> <span class="n">characters</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">print</span><span class="p">&gt;</span>            <span class="p">&#39;</span><span class="s1">graph</span><span class="p">&#39;</span> <span class="nb">plus</span> <span class="p">&#39;</span><span class="s1">space</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">but</span> <span class="k">no</span> <span class="p">&#39;</span><span class="s1">cntrl</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">punct</span><span class="p">&gt;</span>            <span class="n">Punctuation</span> <span class="ow">and</span> <span class="n">Symbols</span> <span class="p">(</span><span class="n">only</span> <span class="n">Punct</span> <span class="n">beyond</span> <span class="n">ASCII</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">space</span><span class="o">&gt;</span>   \<span class="k">s</span>       <span class="err">Whitespace</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="sr">upper</span><span class="p">&gt;</span>   <span class="p">&lt;</span><span class="s">:Lu</span><span class="p">&gt;</span>    <span class="n">Uppercase</span> <span class="n">characters</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">|wb</span><span class="p">&gt;</span>               <span class="n">Word</span> <span class="n">Boundary</span> <span class="p">(</span><span class="n">zero-width</span> <span class="n">assertion</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">ww</span><span class="o">&gt;</span>               <span class="n">Within</span> <span class="n">Word</span> <span class="p">(</span><span class="n">zero-width</span> <span class="n">assertion</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">xdigit</span><span class="o">&gt;</span>           <span class="n">Hexadecimal</span> <span class="n">digit</span> <span class="o">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="n">A-Fa-f</span><span class="o">]</span>
</span></span></code></pre></div><h3 id="unicode-属性">Unicode 属性&nbsp;<a class="headline-hash no-text-decoration" href="#unicode-属性">#</a> </h3>
<p>目前提到的字符类大多是为了方便; 另一种方法是使用 Unicode 字符属性。这些以 <code>&lt;:property&gt;</code> 的形式出现, 其中 <em>property</em> 可以是短的或长的 Unicode 一般类别名。它们使用 pair 语法。</p>
<p>要匹配一个 Unicode 属性:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">uniprop</span><span class="p">(&#39;</span><span class="s1">Script</span><span class="p">&#39;);</span>                 <span class="c1"># OUTPUT: «Latin␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;:</span><span class="na">Script</span><span class="p">&lt;</span><span class="s">Latin</span><span class="p">&gt;&gt;</span><span class="sr"> </span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">uniprop</span><span class="p">(&#39;</span><span class="s1">Block</span><span class="p">&#39;);</span>                  <span class="c1"># OUTPUT: «Basic Latin␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;:</span><span class="na">Block</span><span class="p">(&#39;</span><span class="s1">Basic Latin</span><span class="p">&#39;)&gt;</span><span class="sr"> </span><span class="p">/;</span>
</span></span></code></pre></div><p>下面的 Unicode 通用类别表是从 Perl 5 的 <a href="http://perldoc.perl.org/perlunicode.html">perlunicode</a> 文档偷来的:</p>
<pre tabindex="0"><code>Short	Long
L	Letter
LC	Cased_Letter
Lu	Uppercase_Letter
Ll	Lowercase_Letter
Lt	Titlecase_Letter
Lm	Modifier_Letter
Lo	Other_Letter
M	Mark
Mn	Nonspacing_Mark
Mc	Spacing_Mark
Me	Enclosing_Mark
N	Number
Nd	Decimal_Number (also Digit)
Nl	Letter_Number
No	Other_Number
P	Punctuation (also punct)
Pc	Connector_Punctuation
Pd	Dash_Punctuation
Ps	Open_Punctuation
Pe	Close_Punctuation
Pi	Initial_Punctuation
        (may behave like Ps or Pe depending on usage)
Pf	Final_Punctuation
        (may behave like Ps or Pe depending on usage)
Po	Other_Punctuation
S	Symbol
Sm	Math_Symbol
Sc	Currency_Symbol
Sk	Modifier_Symbol
So	Other_Symbol
Z	Separator
Zs	Space_Separator
Zl	Line_Separator
Zp	Paragraph_Separator
C	Other
Cc	Control (also cntrl)
Cf	Format
Cs	Surrogate
Co	Private_Use
Cn	Unassigned
</code></pre><p>举个例子: <code>&lt;:Lu&gt;</code> 匹配单个大写字母。</p>
<p>它的反面是这个: <code>&lt;:!property&gt;</code>。所以, <code>&lt;:!Lu&gt;</code> 匹配单个非大写字母的字符。</p>
<p>类别可以使用中缀操作符组合在一起:</p>
<pre tabindex="0"><code>Operator	Meaning
+	        set union
|	        set union
&amp;	        set intersection
-	        set difference (first minus second)
^	        symmetric set intersection / XOR
</code></pre><p>要匹配要么一个小写字母,要么一个数字, 可以写 <code>&lt;:Ll+:N&gt;</code> 或 <code>&lt;:Ll+:Number&gt;</code> 或 <code>&lt;+ :Lowercase_Letter + :Number&gt;</code>。</p>
<p>使用圆括号将类别和一组类别分组也是可以的; 例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">raku</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">{</span><span class="se">\w</span><span class="o">+</span><span class="p">(&lt;:</span><span class="na">Ll</span><span class="o">+</span><span class="p">:</span><span class="na">N</span><span class="p">&gt;)}</span>  <span class="c1"># OUTPUT: «0 =&gt; ｢6｣␤» </span>
</span></span></code></pre></div><h3 id="可枚举的字符类和区间">可枚举的字符类和区间&nbsp;<a class="headline-hash no-text-decoration" href="#可枚举的字符类和区间">#</a> </h3>
<p>有时候, 预先存在的通配符和字符类不够用。幸运的是, 定义你自己的字符类相当简单。在 <code>&lt;[]&gt;</code> 中, 你可以放入任何数量的单个字符和字符区间(两个端点之间有两个点号), 带有或不带有空白。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">abacabadabacaba</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr"> a </span><span class="o">..</span><span class="sr"> c </span><span class="mi">1</span><span class="sr"> </span><span class="mi">2</span><span class="sr"> </span><span class="mi">3</span><span class="sr"> </span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Unicode hex codepoint range </span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">ÀÁÂÃÄÅÆ</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr"> </span><span class="se">\x</span><span class="p">[</span><span class="mh">00C0</span><span class="p">]</span><span class="sr"> </span><span class="o">..</span><span class="sr"> </span><span class="se">\x</span><span class="p">[</span><span class="mh">00C6</span><span class="p">]</span><span class="sr"> </span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Unicode named codepoint range </span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">ÀÁÂÃÄÅÆ</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr"> </span><span class="se">\c</span><span class="p">[</span><span class="s">LATIN CAPITAL LETTER A WITH GRAVE</span><span class="p">]</span><span class="sr"> </span><span class="o">..</span><span class="sr"> </span><span class="se">\c</span><span class="p">[</span><span class="s">LATIN CAPITAL LETTER AE</span><span class="p">]</span><span class="sr"> </span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">/;</span>
</span></span></code></pre></div><p>在 <code>&lt;&gt;</code> 中你可以使用 <code>+</code> 或 <code>-</code> 来添加或移除多个区间定义, 甚至混合某些上面的 unicode 属性。你还可以在 <code>[]</code> 之间写上反斜线形式的字符类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&lt;[</span><span class="se">\d</span><span class="p">]</span> <span class="o">-</span> <span class="p">[</span><span class="mi">13579</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># starts with \d and removes odd ASCII digits, but not quite the same as </span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&lt;[</span><span class="mo">0246</span><span class="mi">8</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># because the first one also contains &#34;weird&#34; unicodey digits </span>
</span></span></code></pre></div><p>解析引号分割的字符串的一个常见模式涉及到对字符类取反:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">&#34;in quotes&#34;</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> &#34; </span><span class="p">]&gt;</span><span class="sr"> </span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;/;</span>
</span></span></code></pre></div><p>这先匹配一个引号, 然后匹配任何不是引号的字符, 再然后还是一个引号。 上面例子中的 <code>*</code> 和 <code>+</code> 会在<a href="https://docs.raku.org/language/regexes#Quantifiers">量词</a>一节中解释。</p>
<p>就像你可以使用 <code>-</code> 用于集合差集和取反单个值, 你也可以在前面显式地放上一个 <code>+</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">+</span><span class="p">[</span><span class="mi">123</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">/</span>  <span class="c1"># same as &lt;[123]&gt; </span>
</span></span></code></pre></div><h2 id="量词">量词&nbsp;<a class="headline-hash no-text-decoration" href="#量词">#</a> </h2>
<p>量词使前面的原子匹配可变次数。例如, <code>a+</code> 匹配一个或多个字符 <em>a</em>。</p>
<p>量词比连结绑定的更紧, 所以 <code>ab+</code> 匹配一个 <em>a</em>, 然后跟着一个或多个 <em>b</em>。对于引号来说, 有点不同, 所以 <code>'ab'+</code> 匹配字符串 <em>ab</em>, <em>abab</em>, <em>ababab</em> 等等。</p>
<h3 id="一次-或多次--">一次 或多次 : +&nbsp;<a class="headline-hash no-text-decoration" href="#一次-或多次--">#</a> </h3>
<p><code>+</code> 量词使它前面的原子匹配一次或多次, 没有次数上限。</p>
<p>例如, 要匹配 <code>form=value</code> 形式的字符串, 你可以这样写正则表达式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">/</span>
</span></span></code></pre></div><h3 id="零次-或-多次-">零次 或 多次: *&nbsp;<a class="headline-hash no-text-decoration" href="#零次-或-多次-">#</a> </h3>
<p><code>*</code> 量词使它前面的原子匹配一次或多次, 没有次数上限。</p>
<p>例如, 要允许 <em>a</em> 和 <em>b</em> 之间出现可选的空白,  你可以这样写:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> a </span><span class="se">\s</span><span class="o">*</span><span class="sr"> b </span><span class="p">/</span>
</span></span></code></pre></div><h3 id="零次-或-一次匹配-">零次 或 一次匹配: ?&nbsp;<a class="headline-hash no-text-decoration" href="#零次-或-一次匹配-">#</a> </h3>
<p><code>?</code> 量词使它前面的原子匹配零次或一次。</p>
<h3 id="常规量词--minmax">常规量词: ** min..max&nbsp;<a class="headline-hash no-text-decoration" href="#常规量词--minmax">#</a> </h3>
<p>要限定原子匹配任意次数,　你可以写出像 <code>a ** 2..5</code> 那样的表达式来匹配字符 <em>a</em> 至少 2 次, 至多 5 次。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">**</span><span class="sr"> </span><span class="mi">2</span><span class="o">..</span><span class="mi">5</span><span class="p">/;</span>        <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span>  <span class="p">&#39;</span><span class="s1">aaa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">**</span><span class="sr"> </span><span class="mi">2</span><span class="o">..</span><span class="mi">5</span><span class="p">/;</span>     <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>如果最小匹配次数和最大匹配次数相同, 那么使用单个整数: <code>a ** 5</code> 精确地匹配 5 次。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">aaaaa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">**</span><span class="sr"> </span><span class="mi">5</span><span class="p">/;</span>       <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>也可以使用 <code>^</code> 脱字符来排除区间的端点:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span>    <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="ni">^</span><span class="o">..</span><span class="ni">^</span><span class="mi">6</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «False␤» -- there are 2 to 5 &#39;a&#39;s in a row </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">aaaa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="ni">^</span><span class="o">..</span><span class="ni">^</span><span class="mi">6</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>下面这个包含从 0 开始的数值区间:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">aaa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">**</span><span class="sr"> </span><span class="ni">^</span><span class="mi">6</span><span class="p">/;</span>        <span class="c1"># OUTPUT: «True␤» -- there are 0 to 5 &#39;a&#39;s in a row </span>
</span></span></code></pre></div><p>或使用一个 Whatever Star <code>*</code> 操作符来表示无限区间:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">aaaa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="ni">^</span><span class="o">..*</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «True␤» -- there are 2 or more &#39;a&#39;s in a row </span>
</span></span></code></pre></div><h3 id="modified-quantifier-">Modified quantifier: %&nbsp;<a class="headline-hash no-text-decoration" href="#modified-quantifier-">#</a> </h3>
<p>为了更容易地匹配逗号分割那样的值, 你可以在以上任何一个量词后面加上一个 <code>%</code> 修饰符以指定某个修饰符必须出现在每一次匹配之间。例如, <code>a+ % ','</code> 会匹配 <em>a</em>, 或 <em>a,a</em> 或 <em>a,a,a</em> 等等, 但是不会匹配 <em>a,</em> 或 <em>a,a,</em> 等。要连这些也要匹配, 那么使用 <code>%%</code> 代替 <code>%</code>。</p>
<h3 id="贪婪量词-vs-非贪婪量词-">贪婪量词 Vs. 非贪婪量词: ?&nbsp;<a class="headline-hash no-text-decoration" href="#贪婪量词-vs-非贪婪量词-">#</a> </h3>
<p>默认地, 量词要求进行贪婪匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">abababa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="ni">.</span><span class="o">*</span><span class="sr"> a</span><span class="p">/</span> <span class="o">&amp;&amp;</span> <span class="nb">say</span> <span class="o">~</span><span class="nv">$/</span><span class="p">;</span>   <span class="c1"># OUTPUT: «abababa␤» </span>
</span></span></code></pre></div><p>你可以给量词附加一个 <code>?</code> 修饰符来开启非贪婪匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">abababa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="ni">.</span><span class="o">*?</span><span class="sr"> a</span><span class="p">/</span> <span class="o">&amp;&amp;</span> <span class="nb">say</span> <span class="o">~</span><span class="nv">$/</span><span class="p">;</span>   <span class="c1"># OUTPUT: «aba␤» </span>
</span></span></code></pre></div><p>你还可以使用 <code>!</code> 修饰符显式地要求贪婪匹配。</p>
<h3 id="阻止回溯-">阻止回溯: :&nbsp;<a class="headline-hash no-text-decoration" href="#阻止回溯-">#</a> </h3>
<p>你可以在正则表达式中通过为量词附加一个 <code>:</code> 修饰符来阻止回溯:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">abababa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="ni">.</span><span class="o">*</span><span class="sr"> aba</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">abababa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="ni">.</span><span class="o">*:</span><span class="sr"> aba</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><h2 id="alternation-">Alternation: ||&nbsp;<a class="headline-hash no-text-decoration" href="#alternation-">#</a> </h2>
<p><a href="https://docs.raku.org/language/regexes#Alternation:_%7C%7C">||</a> 在正则表达式中表示备选分支, 在匹配由 <code>||</code> 分割的几个可能的备选分支之一时, <strong>第一个</strong>匹配的备选分支胜出。例如, <em>ini</em> 文件有如下形式:</p>
<pre tabindex="0"><code>[section]
key = value
</code></pre><p>因此, 如果你解析单行 <em>ini</em> 文件, 那么它要么是一个 section, 要么是一个键值对儿。所以正则表达式可以是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">||</span><span class="sr"> </span><span class="se">\S</span><span class="o">+</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="se">\S</span><span class="o">*</span><span class="sr"> </span><span class="p">/</span>
</span></span></code></pre></div><p>即, 它要么是一个由方括号包围起来的单词, 要么是一个键值对。</p>
<h2 id="longest-alternation-">Longest Alternation: |&nbsp;<a class="headline-hash no-text-decoration" href="#longest-alternation-">#</a> </h2>
<p>如果正则表达式由 <code>|</code> 分割, 则最长的那个匹配胜出。独立于正则表达式中的词法顺序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> a </span><span class="o">|</span><span class="sr"> </span><span class="ni">.</span><span class="sr">b </span><span class="p">/)</span><span class="o">.</span><span class="kt">Str</span><span class="p">;</span>    <span class="c1"># OUTPUT: «ab␤» </span>
</span></span></code></pre></div><h2 id="anchors">Anchors&nbsp;<a class="headline-hash no-text-decoration" href="#anchors">#</a> </h2>
<p>正则表达式引擎尝试在字符串中从左至右地搜索来查找匹配。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">properly</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> perl</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="c1">#          ^^^^ </span>
</span></span></code></pre></div><p>有时候这不是你想要的。相反, 你可能只想匹配整个字符串, 或一整行, 或精确地一个或几个完整的单词。锚或断言能帮助我们。</p>
<p>为了整个正则表达式能够匹配, 断言需要被成功地匹配但是断言在匹配时不消耗字符。</p>
<h3 id="--start-of-string-and---end-of-string">^ , Start of String and $ , End of String&nbsp;<a class="headline-hash no-text-decoration" href="#--start-of-string-and---end-of-string">#</a> </h3>
<p><code>^</code> 断言只匹配字符串的开头:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">properly</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">  perl</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">properly</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr"> perl</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">perly</span><span class="p">&#39;</span>    <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr"> perl</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">perl</span><span class="p">&#39;</span>     <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr"> perl</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p><code>$</code> 断言只匹配字符串的结尾:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">use perl</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">  perl  </span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">use perl</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">  perl </span><span class="ni">$</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">perly</span><span class="p">&#39;</span>    <span class="o">~~</span> <span class="p">/</span><span class="sr">  perl </span><span class="ni">$</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><p>你可以把这两个断言组合起来:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">use perl</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr"> perl </span><span class="ni">$</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">perl</span><span class="p">&#39;</span>     <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr"> perl </span><span class="ni">$</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>记住, <code>^</code> 匹配<strong>字符串</strong>的开头, 而非<strong>行</strong>的开头。同样地, <code>$</code> 匹配<strong>字符串</strong>的结尾, 而非<strong>行</strong>的结尾。</p>
<p>下面的是多行字符串:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOS/;</span><span class="s"> 
</span></span></span><span class="line"><span class="cl"><span class="s">   Keep it secret
</span></span></span><span class="line"><span class="cl"><span class="s">   and keep it safe
</span></span></span><span class="line"><span class="cl"><span class="s">   </span><span class="p">EOS</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">safe   </span><span class="ni">$</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤»  -- &#39;safe&#39; is at the end of the string </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">secret </span><span class="ni">$</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «False␤» -- &#39;secret&#39; is at the end of a line -- not the string </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr">Keep   </span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤»  -- &#39;Keep&#39; is at the start of the string </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr">and    </span><span class="p">/;</span>   <span class="c1"># OUTPUT: «False␤» -- &#39;and&#39; is at the start of a line -- not the string </span>
</span></span></code></pre></div><h3 id="--start-of-line-and---end-of-line">^^ , Start of Line and $$ , End of Line&nbsp;<a class="headline-hash no-text-decoration" href="#--start-of-line-and---end-of-line">#</a> </h3>
<p><code>^^</code> 断言匹配逻辑行的开头。即, 要么在字符串的开头, 要么在换行符之后。然而, 它不匹配字符串的结尾, 即使它以一个换行符结尾。</p>
<p><code>$$</code> 只匹配逻辑换行符的结尾, 即, 在换行符之前, 或在字符串的结尾, 当最后一个字符不是换行符时。</p>
<p>(为了理解下面的示例, 最好先了解 <code>q:to/EOS/...EOS</code> 的 &ldquo;heredoc&rdquo; 语法移除了前置的缩进, 使之与 <code>EOS</code> 标记同级, 以至于第一行, 第二行和最后一行没有前置空格而第三行和第四行各有两个前置空格。)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOS/;</span><span class="s"> 
</span></span></span><span class="line"><span class="cl"><span class="s">    There was a young man of Japan
</span></span></span><span class="line"><span class="cl"><span class="s">    Whose limericks never would scan.
</span></span></span><span class="line"><span class="cl"><span class="s">      When asked why this was,
</span></span></span><span class="line"><span class="cl"><span class="s">      He replied &#34;It&#39;s because
</span></span></span><span class="line"><span class="cl"><span class="s">    I always try to fit as many syllables into the last line as ever I possibly can.&#34;
</span></span></span><span class="line"><span class="cl"><span class="s">    </span><span class="p">EOS</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^^</span><span class="sr"> There</span><span class="p">/;</span>        <span class="c1"># OUTPUT: «True␤»  -- start of string </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^^</span><span class="sr"> limericks</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «False␤» -- not at the start of a line </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^^</span><span class="sr"> I</span><span class="p">/;</span>            <span class="c1"># OUTPUT: «True␤»  -- start of the last line </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^^</span><span class="sr"> When</span><span class="p">/;</span>         <span class="c1"># OUTPUT: «False␤» -- there are blanks between </span>
</span></span><span class="line"><span class="cl">                                  <span class="c1">#                       start of line and the &#34;When&#34; </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> Japan </span><span class="ni">$$</span><span class="p">/;</span>       <span class="c1"># OUTPUT: «True␤»  -- end of first line </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> scan </span><span class="ni">$$</span><span class="p">/;</span>        <span class="c1"># OUTPUT: «False␤» -- there&#39;s a . between &#34;scan&#34; </span>
</span></span><span class="line"><span class="cl">                                  <span class="c1">#                      and the end of line </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">.&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="ni">$$</span><span class="p">/;</span>        <span class="c1"># OUTPUT: «True␤»  -- at the last line </span>
</span></span></code></pre></div><h3 id="w-and-w-word-boundary">&lt;|w&gt; and &lt;!|w&gt;, word boundary&nbsp;<a class="headline-hash no-text-decoration" href="#w-and-w-word-boundary">#</a> </h3>
<p>要匹配单词边界, 使用 <code>&lt;|w&gt;</code>。这与其它语言的 <code>\b</code> 类似，要匹配一个非单词边界, 使用 <code>&lt;!|w&gt;</code>, 类似其它语言的 <code>\B</code>。这些都是零宽断言。</p>
<h3 id="-and---left-and-right-word-boundary">&laquo; and &raquo; , left and right word boundary&nbsp;<a class="headline-hash no-text-decoration" href="#-and---left-and-right-word-boundary">#</a> </h3>
<p><code>&lt;&lt;</code> 匹配左单词边界。它匹配左侧(或者字符串的开头)是非单词字符而右侧是一个单词字符的位置。</p>
<p><code>&gt;&gt;</code> 匹配右单词边界。它匹配左侧有一个单词字符而右侧(或者字符串的结尾)是一个非单词字符的位置。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">The quick brown fox</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">br</span><span class="p">/;</span>              <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="o">&lt;&lt;</span><span class="sr"> br</span><span class="p">/;</span>           <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">br </span><span class="o">&gt;&gt;</span><span class="p">/;</span>           <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">own</span><span class="p">/;</span>             <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="o">&lt;&lt;</span><span class="sr"> own</span><span class="p">/;</span>          <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">own </span><span class="o">&gt;&gt;</span><span class="p">/;</span>          <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>你可以使用变体 <strong>«</strong> 和 <strong>»</strong> :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">The quick brown fox</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="o">«</span><span class="sr"> own</span><span class="p">/;</span>          <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">own </span><span class="o">»</span><span class="p">/;</span>          <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><h2 id="分组和捕获">分组和捕获&nbsp;<a class="headline-hash no-text-decoration" href="#分组和捕获">#</a> </h2>
<p>在普通的(非正则表达式)Raku 代码中, 你可以使用圆括号把东西组织到一块, 通常用于覆盖操作符优先级:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>   <span class="c1"># 9, parsed as 1 + (4*2)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span> <span class="c1"># 输出: 10</span>
</span></span></code></pre></div><p>在正则表达式中也可以使用同样的分组工具:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> a </span><span class="o">||</span><span class="sr"> b c</span><span class="p">/;</span>   <span class="c1"># 匹配 &#39;a&#39; 或 &#39;bc&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="sr">a </span><span class="o">||</span><span class="sr"> b</span><span class="p">)</span><span class="sr"> c</span><span class="p">/;</span> <span class="c1"># 匹配 &#39;ac&#39; 或 &#39;bc&#39;</span>
</span></span></code></pre></div><p>分组可以应用在量词上:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> a b</span><span class="o">+</span><span class="sr"> </span><span class="p">/;</span>      <span class="c1"># 匹配一个 &#39;a&#39;, 后面再跟着一个或多个 &#39;b&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="sr">a b</span><span class="p">)</span><span class="o">+</span><span class="p">/;</span>     <span class="c1"># 匹配一个或多个 &#39;ab&#39; 序列</span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="sr">a </span><span class="o">||</span><span class="sr"> b</span><span class="p">)</span><span class="o">+</span><span class="sr"> </span><span class="p">/;</span> <span class="c1"># 匹配一个 &#39;a&#39; 序列或者 &#39;b&#39; 序列, 至少一次</span>
</span></span></code></pre></div><p>一个非量词化的捕获产生一个 <a href="https://docs.raku.org/type/Match">Match</a>对象。当捕获被量化(除了使用 ? 量词)之后, 该捕获就变成 <a href="https://docs.raku.org/type/Match">Match</a>对象的列表。</p>
<h3 id="捕获">捕获&nbsp;<a class="headline-hash no-text-decoration" href="#捕获">#</a> </h3>
<p>圆括号不仅仅能够分组, 它们也<em>捕获</em>; 也就是说, 它们使分组中匹配到的字符串用作变量，并且还作为生成的 <a href="https://docs.raku.org/type/Match">Match</a> 对象的元素:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">number 42</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/&#39;</span><span class="s1">number</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The number is </span><span class="nv">$0</span><span class="p">&#34;;</span>    <span class="c1"># The number is 42</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># or</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The number is $/[0]</span><span class="p">&#34;;</span> <span class="c1"># The number is 42</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>圆括号对儿是从左到右编号的, 编号从零开始。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/(</span><span class="sr">a</span><span class="p">)</span><span class="sr"> b </span><span class="p">(</span><span class="sr">c</span><span class="p">)/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">0:</span><span class="nv">$0</span><span class="s2">; 1:</span><span class="nv">$1</span><span class="p">&#34;;</span> <span class="c1"># 输出: 0:a; 1:c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>$0</code> 和 <code>$1</code> 等语法是简写的。这些捕获可以从用作列表的匹配对象 <code>$/</code> 中规范地获取到, 所以, <code>$0</code> 实际上是 <code>$/[0]</code> 的语法糖。</p>
<p>将匹配对象强制转换为列表可以方便地以编程方式访问所有元素:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/(</span><span class="sr">a</span><span class="p">)</span><span class="sr"> b </span><span class="p">(</span><span class="sr">c</span><span class="p">)/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">list</span><span class="o">.</span><span class="nb">join</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">,</span><span class="p">&#39;;</span> <span class="c1"># 输出 a,c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="非捕获分组">非捕获分组&nbsp;<a class="headline-hash no-text-decoration" href="#非捕获分组">#</a> </h3>
<p>正则表达式中的圆括号扮演了双重角色: 它们将内部的正则表达式元素分组, 并通过内部的子正则表达式捕获所匹配到的内容。</p>
<p>要仅仅获得分组行为, 可以使用方括号 <code>[...]</code> 代替圆括号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">[</span><span class="sr">a</span><span class="o">||</span><span class="sr">b</span><span class="p">]</span><span class="sr"> </span><span class="p">(</span><span class="sr">c</span><span class="p">)</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$0</span><span class="p">;</span>                <span class="c1"># OUTPUT: «c␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果您不需要捕获, 则使用非捕获分组可提供三个好处: 它们更干净地传达正则表达式; 它们使您更容易对您关心的捕获组计数; 并且它匹配比较快。</p>
<h3 id="捕获编号">捕获编号&nbsp;<a class="headline-hash no-text-decoration" href="#捕获编号">#</a> </h3>
<p>上面已经说明，捕获从左到右编号。 原则上是真的，这也是过于简单的。</p>
<p>为了完整起见，列出了以下规则。 当您发现自己经常使用它们时，考虑命名捕获（可能是 subrules）是值得的。</p>
<p>备选分支会重置捕获计数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="sr">x</span><span class="p">)</span><span class="sr"> </span><span class="p">(</span><span class="sr">y</span><span class="p">)</span><span class="sr">  </span><span class="o">||</span><span class="sr"> </span><span class="p">(</span><span class="sr">a</span><span class="p">)</span><span class="sr"> </span><span class="p">(</span><span class="ni">.</span><span class="p">)</span><span class="sr"> </span><span class="p">(</span><span class="ni">.</span><span class="p">)</span><span class="sr"> </span><span class="p">/</span>
</span></span><span class="line"><span class="cl"><span class="c1"># $0  $1      $0  $1  $2 </span>
</span></span></code></pre></div><p>例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/(</span><span class="sr">x</span><span class="p">)(</span><span class="sr">y</span><span class="p">)</span><span class="sr"> </span><span class="o">||</span><span class="sr"> </span><span class="p">(</span><span class="sr">a</span><span class="p">)(</span><span class="ni">.</span><span class="p">)(</span><span class="ni">.</span><span class="p">)/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$1</span><span class="p">;</span>            <span class="c1"># b </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果两个（或多个）备选分支具有不同的捕获编号，则捕获编号最多的决定了下一个捕获的索引：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">abcd</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">/</span> <span class="n">a</span> <span class="o">[</span> <span class="n">b</span> <span class="ow">(.)</span> <span class="o">||</span> <span class="p">(</span><span class="nb">x</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">]</span> <span class="ow">(.)</span> <span class="o">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#      $0     $0  $1    $2 </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$2</span><span class="p">;</span>           <span class="c1"># d </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>捕获可以嵌套，在这种情况下，它们的每一级都会编号:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="sr"> a </span><span class="p">(</span><span class="ni">.</span><span class="p">)</span><span class="sr"> </span><span class="p">(</span><span class="ni">.</span><span class="p">)</span><span class="sr"> </span><span class="p">)</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Outer: </span><span class="nv">$0</span><span class="p">&#34;;</span>                <span class="c1"># Outer: abc </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Inner: </span><span class="nv">$0</span><span class="s2">[0] and </span><span class="nv">$0</span><span class="s2">[1]</span><span class="p">&#34;;</span>   <span class="c1"># Inner: b and c </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="命名捕获">命名捕获&nbsp;<a class="headline-hash no-text-decoration" href="#命名捕获">#</a> </h3>
<p>除了给捕获编号，你也可以给他们起名字。 命名捕获的通用和略微冗长的方式是这样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="nv">$&lt;myname&gt;</span><span class="sr"> </span><span class="o">=</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$&lt;myname&gt;</span>      <span class="c1"># OUTPUT: «abc␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对命名捕获 <em>$<!-- raw HTML omitted --></em> 的访问是将匹配对象作为哈希索引的简写，换句话说：<code>$/{'myname'}</code> 或 <code>$/&lt;myname&gt;</code>。</p>
<p>命名捕获也可以使用常规捕获分组语法进行嵌套:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc-abc-abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="nv">$&lt;string&gt;</span><span class="o">=</span><span class="p">(</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="nv">$&lt;part&gt;</span><span class="o">=</span><span class="p">[</span><span class="sr">abc</span><span class="p">]</span><span class="sr"> </span><span class="p">]</span><span class="o">*</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">)</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$&lt;string&gt;</span><span class="p">;</span>         <span class="c1"># OUTPUT: «abc-abc-abc␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$&lt;string&gt;</span><span class="p">&lt;</span><span class="s">part</span><span class="p">&gt;;</span>   <span class="c1"># OUTPUT: «[abc, abc, abc]␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>将匹配对象强制为散列可让您轻松地以编程方式访问所有命名捕获:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">count=23</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="nv">$&lt;variable&gt;</span><span class="o">=</span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="nv">$&lt;value&gt;</span><span class="o">=</span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">hash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">%h</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">sort</span><span class="o">.</span><span class="nb">join</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">, </span><span class="p">&#39;;</span>        <span class="c1"># OUTPUT: «value, variable␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">%h</span><span class="o">.</span><span class="nb">values</span><span class="o">.</span><span class="nb">sort</span><span class="o">.</span><span class="nb">join</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">, </span><span class="p">&#39;;</span>      <span class="c1"># OUTPUT: «23, count␤» </span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nv">%h</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$k</span><span class="o">,</span> <span class="nv">$v</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Found value &#39;</span><span class="nv">$v&#39;</span><span class="s2"> with key &#39;</span><span class="nv">$k&#39;</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># outputs two lines: </span>
</span></span><span class="line"><span class="cl">        <span class="c1">#   Found value &#39;count&#39; with key &#39;variable&#39; </span>
</span></span><span class="line"><span class="cl">        <span class="c1">#   Found value &#39;23&#39; with key &#39;value&#39; </span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在 Subrules 部分会讨论获取命名捕获的更方便的方法。</p>
<h3 id="capture-markers--">Capture markers: &lt;( )&gt;&nbsp;<a class="headline-hash no-text-decoration" href="#capture-markers--">#</a> </h3>
<p><code>&lt;(</code> token 表示匹配的整体捕捉的开始，而相应的 <code>)&gt;</code> token 表示其末端。 <code>&lt;(</code> 类似于其他语言的 <code>\K</code> 丢弃 <code>\K</code> 之前找到的任何匹配项。</p>
<h2 id="替换">替换&nbsp;<a class="headline-hash no-text-decoration" href="#替换">#</a> </h2>
<p>正则表达式也可以用来替换另一个文本。 您可以使用它来解决拼写错误(例如, 用 &ldquo;Pearl Jam&rdquo; 替换 &ldquo;Perl Jam&rdquo;), 从 <code>yyyy-mm-ddThh:mm:ssZ</code> 到 <code>mm-dd-yy h:m {AM,PM}</code> 重新格式化 ISO8601 日期及其它。</p>
<p>就像搜索替换编辑器的对话框一样，<code>s///</code> 操作符有两面，左侧和右侧。 左侧是匹配表达式的位置，右侧是您要替换的表达式。</p>
<h3 id="词汇约定">词汇约定&nbsp;<a class="headline-hash no-text-decoration" href="#词汇约定">#</a> </h3>
<p>替换和匹配的写法类似，但替换运算符既有正则表达式匹配的区域，也有替换的文本区域：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">s</span><span class="p">/</span><span class="sr">replace</span><span class="p">/</span><span class="s2">with</span><span class="p">/;</span>           <span class="c1"># a substitution that is applied to $_ </span>
</span></span><span class="line"><span class="cl"><span class="nv">$str</span> <span class="o">~~</span> <span class="k">s</span><span class="p">/</span><span class="sr">replace</span><span class="p">/</span><span class="s2">with</span><span class="p">/;</span>   <span class="c1"># a substitution applied to a scalar </span>
</span></span></code></pre></div><p>替换操作法允许除了斜线之外的分隔符:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">s</span><span class="p">|</span><span class="sr">replace</span><span class="p">|</span><span class="s2">with</span><span class="p">|;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">!</span><span class="sr">replace</span><span class="p">!</span><span class="s2">with</span><span class="p">!;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">,</span><span class="sr">replace</span><span class="p">,</span><span class="s2">with</span><span class="p">,;</span>
</span></span></code></pre></div><p>注意, 冒号和诸如 <code>{}</code> 或 <code>()</code> 的分隔符不能作为替换分割符。带有副词的冒号斜线诸如 <code>s:i/Foo/Bar</code> 和其它分割符有其它用途。</p>
<p>就像 <code>m//</code> 操作符一样, 通常会忽略空白。在 Raku 中, 注释以 <em>#</em> 号开头直到当前行的结尾。</p>
<h3 id="替换字符串字面值">替换字符串字面值&nbsp;<a class="headline-hash no-text-decoration" href="#替换字符串字面值">#</a> </h3>
<p>要替换的最简单的东西就是字符串字面量。你要替换的字符串在替换运算符的左侧, 而替换它的字符串在替换操作符的右侧; 例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">The Replacements</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">/</span><span class="sr">Replace</span><span class="p">/</span><span class="s2">Entrap</span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                    <span class="c1"># OUTPUT: «The Entrapments␤» </span>
</span></span></code></pre></div><p>字母数字字符和下划线是文字匹配，就像其表哥 <code>m//</code> 操作符一样。 所有其他字符都必须使用反斜杠<code>\</code>转义，或包含在引号中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Space: 1999</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">/</span><span class="sr">Space</span><span class="se">\</span><span class="sr">:</span><span class="p">/</span><span class="s2">Party like it&#39;s</span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span>                        <span class="c1"># OUTPUT: «Party like it&#39;s 1999␤» </span>
</span></span></code></pre></div><p>请注意，匹配约束仅适用于替换表达式的左侧。</p>
<p>默认情况下，替换仅在第一匹配中完成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">There can be twly two</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">/</span><span class="sr">tw</span><span class="p">/</span><span class="s2">on</span><span class="p">/;</span>                     <span class="c1"># replace &#39;tw&#39; with &#39;on&#39; once </span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                         <span class="c1"># OUTPUT: «there can be only two␤» </span>
</span></span></code></pre></div><h3 id="通配符和字符类-1">通配符和字符类&nbsp;<a class="headline-hash no-text-decoration" href="#通配符和字符类-1">#</a> </h3>
<p>任何可以进入 <code>m//</code> 操作符的内容都可以进入替换操作符的左侧，包括通配符和字符类。 当您匹配的文本不是静态的时，这很方便，例如尝试匹配字符串中间的数字：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Blake&#39;s 9</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">/</span><span class="se">\d</span><span class="o">+</span><span class="p">/</span><span class="s2">7</span><span class="p">/;</span>         <span class="c1"># replace any sequence of digits with &#39;7&#39; </span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span><span class="p">;</span>             <span class="c1"># OUTPUT: «Blake&#39;s 7␤»</span>
</span></span></code></pre></div><p>当然，你可以使用任何<code>+</code>，<code>*</code>和<code>?</code> 修饰符，它们的行为就像在 <code>m//</code> 操作符的上下文中一样。</p>
<h3 id="捕获组">捕获组&nbsp;<a class="headline-hash no-text-decoration" href="#捕获组">#</a> </h3>
<p>就像在匹配运算符中一样，捕获组在左侧被允许，匹配的内容填充 <code>$0..$n</code> 变量和 <code>$/</code> 对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">2016-01-23 18:09:00</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="se">\</span><span class="sr">-</span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="se">\</span><span class="sr">-</span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">/</span><span class="s2">today</span><span class="p">/;</span>   <span class="c1"># replace YYYY-MM-DD with &#39;today&#39; </span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                             <span class="c1"># OUTPUT: «today 18:09:00␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="nv">$1-$2-$0</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                   <span class="c1"># OUTPUT: «01-23-2016␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">$/[1]-$/[2]-$/[0]</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>          <span class="c1"># OUTPUT: «01-23-2016␤» </span>
</span></span></code></pre></div><p>任何这些变量 <code>$0</code>，<code>$1</code>，<code>$/</code> 也可以在运算符的右侧使用，所以你可以操纵你刚刚匹配的内容。 这样，您可以将日期的YYYY，MM和DD部分分开，并将其重新格式化为 <code>MM-DD-YYYY</code> 顺序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">2016-01-23 18:09:00</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="se">\</span><span class="sr">-</span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="se">\</span><span class="sr">-</span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">/</span><span class="nv">$1-$2-$0</span><span class="p">/;</span>    <span class="c1"># transform YYYY-MM-DD to MM-DD-YYYY </span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                                 <span class="c1"># OUTPUT: «01-23-2016 18:09:00␤» </span>
</span></span></code></pre></div><p>由于右侧实际上是一个常规的 Raku 内插字符串，因此可以将时间从 <code>HH:MM</code> 重新格式化为 `h:MM {AM,PM} 格式, 如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">18:38</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">/(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="se">\</span><span class="sr">:</span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)/{</span><span class="nv">$0</span> <span class="nv">%</span> <span class="mi">12</span><span class="p">}</span><span class="s2">\:</span><span class="nv">$1</span><span class="s2"> </span><span class="p">{</span><span class="nv">$0</span> <span class="o">&lt;</span> <span class="mi">12</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">AM</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">PM</span><span class="p">&#39;}/;</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                                                    <span class="c1"># OUTPUT: «6:38 PM␤» </span>
</span></span></code></pre></div><p>使用上面的模数 <code>%</code> 运算符将样本代码保留在80个字符以下，否则就是 <code>$0 &lt;12 ?? $0 !! $0 - 12</code>。 结合解析器表达式语法的强大功能，真正使您在这里看到的内容成为可能，您可以使用“正则表达式”来解析任何文本。</p>
<h3 id="common-adverbs">Common adverbs&nbsp;<a class="headline-hash no-text-decoration" href="#common-adverbs">#</a> </h3>
<h2 id="tilde-for-nesting-structures">Tilde for nesting structures&nbsp;<a class="headline-hash no-text-decoration" href="#tilde-for-nesting-structures">#</a> </h2>
<p><code>~</code> 运算符是一个帮助器，用于匹配具有特定终结符的嵌套子规则作为目标。 它被设计为放置在开口和闭合括号之间，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">~</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">expression</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/</span>
</span></span></code></pre></div><p>然而, 它主要忽略左侧的参数, 并且在接下来的两个原子（可以被量化）上操作。 它对下两个原子的操作是“旋转”它们，使得它们实际上以相反的顺序匹配。 因此，上面的表达式，起初是腮红，只不过是下面的简写:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">expression</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">/</span>
</span></span></code></pre></div><p>但是除此之外，当它重写原子时，它还会插入将设置内部表达式以识别终止符的设备，并且如果内部表达式不在所需的闭合原子上终止，则产生适当的错误消息。 所以它确实也注意了左边的括号，它实际上把我们的例子改写成更像:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$&lt;OPEN&gt;</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">SETGOAL: &#39;)&#39;</span><span class="p">&gt;</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="o">[</span> <span class="nv">$GOAL</span> <span class="o">||</span> <span class="p">&lt;</span><span class="s">FAILGOAL</span><span class="p">&gt;</span> <span class="o">]</span>
</span></span></code></pre></div><p>FAILGOAL 是一种可以由用户定义的特殊方法，它将在解析失败时被调用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">A</span> <span class="p">{</span> <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">~</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">  </span><span class="p">};</span>
</span></span><span class="line"><span class="cl">            <span class="k">method</span> <span class="nf">FAILGOAL</span><span class="p">(</span><span class="nv">$goal</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Cannot find </span><span class="nv">$goal</span><span class="s2"> near position </span><span class="p">{</span><span class="nb">self</span><span class="o">.</span><span class="nb">pos</span><span class="p">}&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="o">.</span><span class="nb">parse</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">[good]</span><span class="p">&#39;;</span>  <span class="c1"># OUTPUT: «｢[good]｣␤» </span>
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="o">.</span><span class="nb">parse</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">[bad</span><span class="p">&#39;;</span>    <span class="c1"># will throw FAILGOAL exception </span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::AdHoc: Cannot find &#39;]&#39;  near position 5␤» </span>
</span></span></code></pre></div><p>请注意，即使没有开头括号，也可以使用此构造来设置闭合结构的期望值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">3)</span><span class="p">&#34;</span>  <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">~</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">/;</span>  <span class="c1"># RESULT: «｢3)｣» </span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">(3)</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">~</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">/;</span>  <span class="c1"># RESULT: «｢3)｣» </span>
</span></span></code></pre></div><p>这里 <code>&lt;?&gt;</code> 在第一个空字符串中返回true。</p>
<p>正则表达式捕获的顺序是原始的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">abc</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">~</span><span class="sr"> </span><span class="p">(</span><span class="sr">c</span><span class="p">)</span><span class="sr"> </span><span class="p">(</span><span class="sr">b</span><span class="p">)/;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$0</span><span class="p">;</span> <span class="c1"># OUTPUT: «｢c｣␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$1</span><span class="p">;</span> <span class="c1"># OUTPUT: «｢b｣␤» </span>
</span></span></code></pre></div><h2 id="subrules">Subrules&nbsp;<a class="headline-hash no-text-decoration" href="#subrules">#</a> </h2>
<p>就像你可以把代码片段放进子例程中一样, 你同样可以把正则表达式片段放进命名规则中(named rules)。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">line</span> <span class="p">{</span><span class="sr"> </span><span class="se">\N</span><span class="o">*</span><span class="se">\n</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#34;</span><span class="s2">abc</span><span class="se">\n</span><span class="s2">def</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/&lt;</span><span class="nf">line</span><span class="p">&gt;</span><span class="sr"> def</span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">First line:</span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$&lt;line&gt;</span><span class="o">.</span><span class="nb">chomp</span><span class="p">;</span> <span class="c1"># OUTPUT:«First line: abc␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>命名正则可以使用 <code>my regex_name { body here }</code> 来声明, 并使用 <code>&lt;regex_name&gt;</code> 来调用。与此同时, 调用命名正则的时候会安装一个同名的命名捕获。</p>
<p>要给捕获起一个和 regex 不同的名字, 那么使用 <code>&lt;capture_name=regex_name&gt;</code> 语法。如果不想捕获, 那么使用一个前置的点号来抑制捕获: <code>&lt;.regex_name&gt;</code>。</p>
<p>下面是一个更完善的解析 ini 文件的例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">header</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">(</span><span class="se">\w</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">identifier</span>  <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">kvpair</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">section</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">header</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">kvpair</span><span class="p">&gt;</span><span class="o">*</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$contents</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOI/;</span><span class="s"> 
</span></span></span><span class="line"><span class="cl"><span class="s">    [passwords]
</span></span></span><span class="line"><span class="cl"><span class="s">        jack=password1
</span></span></span><span class="line"><span class="cl"><span class="s">        joy=muchmoresecure123
</span></span></span><span class="line"><span class="cl"><span class="s">    [quotas]
</span></span></span><span class="line"><span class="cl"><span class="s">        jack=123
</span></span></span><span class="line"><span class="cl"><span class="s">        joy=42
</span></span></span><span class="line"><span class="cl"><span class="s"></span><span class="p">EOI</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%config</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$contents</span> <span class="o">~~</span> <span class="p">/&lt;</span><span class="nf">section</span><span class="p">&gt;</span><span class="o">*</span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nv">$&lt;section&gt;</span><span class="o">.</span><span class="nb">list</span> <span class="k">-&gt;</span> <span class="nv">$section</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">%section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nv">$section</span><span class="p">&lt;</span><span class="s">kvpair</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">list</span> <span class="k">-&gt;</span> <span class="nv">$p</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="nv">$p</span><span class="p">&lt;</span><span class="s">value</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%section</span><span class="p">{</span> <span class="nv">$p</span><span class="p">&lt;</span><span class="s">key</span><span class="p">&gt;</span> <span class="p">}</span> <span class="o">=</span> <span class="o">~</span><span class="nv">$p</span><span class="p">&lt;</span><span class="s">value</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nv">%config</span><span class="p">{</span> <span class="nv">$section</span><span class="p">&lt;</span><span class="s">header</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="p">}</span> <span class="o">=</span> <span class="nv">%section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%config</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «(&#34;passwords&#34; =&gt; {&#34;jack&#34; =&gt; &#34;password1&#34;, &#34;joy&#34; =&gt; &#34;muchmoresecure123&#34;},␤ </span>
</span></span><span class="line"><span class="cl"><span class="c1">#          &#34;quotas&#34; =&gt; {&#34;jack&#34; =&gt; &#34;123&#34;, &#34;joy&#34; =&gt; &#34;42&#34;}).hash» </span>
</span></span></code></pre></div><p>命名正则可以规整到 <a href="https://docs.raku.org/language/grammars">gramamrs</a> 中。<a href="https://design.raku.org/S05.html#Predefined_Subrules">S05</a>中有一组预定义的 subrules。</p>
<h2 id="副词">副词&nbsp;<a class="headline-hash no-text-decoration" href="#副词">#</a> </h2>
<p>副词修改正则表达式的工作方式, 并为某些类型的循环任务提供方便的快捷方式。</p>
<p>有两种副词: 正则表达式副词适用于定义正则表达式时, 匹配副词适用于正则表达式与字符串匹配时。</p>
<p>这种区别往往是模糊的, 因为匹配和声明通常是文本上关闭的, 但使用方法形式的匹配使得区分清晰一点。</p>
<p><code>'abc' ~~ /../</code> 大致相当于 <code>'abc'.match(/../)</code>, 甚至可以更清楚地单独写成一行:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$regex</span> <span class="o">=</span> <span class="p">/</span><span class="o">..</span><span class="p">/;</span>           <span class="c1"># definition </span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">match</span><span class="p">(</span><span class="nv">$regex</span><span class="p">)</span> <span class="p">{</span>    <span class="c1"># matching </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">&#39;abc&#39; has at least two characters</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>正则表达式副词像 <code>:i</code> 会进入定义行而匹配副词像 <code>:overlap</code> 会附加到匹配调用上:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$regex</span> <span class="o">=</span> <span class="p">/:</span><span class="na">i</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> a</span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">&#39;</span><span class="s1">baA</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">match</span><span class="p">(</span><span class="nv">$regex</span><span class="o">,</span> <span class="p">:</span><span class="s">overlap</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$m</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «ba␤aA␤» </span>
</span></span></code></pre></div><h3 id="regex-adverbs">Regex Adverbs&nbsp;<a class="headline-hash no-text-decoration" href="#regex-adverbs">#</a> </h3>
<p>在正则表达式声明时出现的副词是实际正则表达式的一部分, 并影响 Raku 编译器如何将正则表达式转换为二进制代码。</p>
<p>例如: <code>:ignorecase (:i)</code> 副词告诉编译器忽略大写, 小写和标题大小写字母之间的区别。</p>
<p>所以 <code>'a'~~ /A/</code> 是假的, 但 `&lsquo;a&rsquo; ~~ /:i A /是一个成功的匹配。</p>
<p>正则表达式副词可以在正则表达式声明之前或之内, 并且仅在词法上影响其后的正则表达式部分。 请注意, 在正则表达式之前出现的正则表达式副词必须出现在将正则表达式引入解析器之后, 如 &lsquo;rx&rsquo; 或 &rsquo;m&rsquo; 或裸的 &lsquo;/&rsquo;。 但是这样是无效的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rx1</span> <span class="o">=</span> <span class="p">:</span><span class="s">i</span><span class="o">/</span><span class="n">a</span><span class="o">/</span><span class="p">;</span>      <span class="c1"># adverb is before the regex is recognized =&gt; exception </span>
</span></span></code></pre></div><p>下面这些是等价的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rx1</span> <span class="o">=</span> <span class="k">rx</span><span class="p">:</span><span class="na">i</span><span class="p">/</span><span class="sr">a</span><span class="p">/;</span>      <span class="c1"># before </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rx2</span> <span class="o">=</span> <span class="k">rx</span><span class="p">/:</span><span class="na">i</span><span class="sr"> a</span><span class="p">/;</span>     <span class="c1"># inside </span>
</span></span></code></pre></div><p>而下面这两种是不等价的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rx3</span> <span class="o">=</span> <span class="k">rx</span><span class="p">/</span><span class="sr">a </span><span class="p">:</span><span class="na">i</span><span class="sr"> b</span><span class="p">/;</span>   <span class="c1"># matches only the b case insensitively </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rx4</span> <span class="o">=</span> <span class="k">rx</span><span class="p">/:</span><span class="na">i</span><span class="sr"> a b</span><span class="p">/;</span>   <span class="c1"># matches completely case insensitively </span>
</span></span></code></pre></div><p>方括号和圆括号约束副词的作用域:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">(:</span><span class="na">i</span><span class="sr"> a b</span><span class="p">)</span><span class="sr"> c </span><span class="p">/;</span>         <span class="c1"># matches &#39;ABc&#39; but not &#39;ABC&#39; </span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">[:</span><span class="na">i</span><span class="sr"> a b</span><span class="p">]</span><span class="sr"> c </span><span class="p">/;</span>         <span class="c1"># matches &#39;ABc&#39; but not &#39;ABC&#39; </span>
</span></span></code></pre></div><h3 id="ratchet">Ratchet&nbsp;<a class="headline-hash no-text-decoration" href="#ratchet">#</a> </h3>
<p><code>:ratchet</code> 或 <code>:r</code> 副词会导致正则表达式引擎不回溯。</p>
<p>假如没有这个副词, 那么正则表达式的一部分将尝试不同的路径来匹配字符串, 以使正则表达式的其他部分可以匹配。 例如, 在 <code>'abc' ~~ / \w+ ./</code> 中, <code>\w+</code> 首先吃光整个字符串 abc, 然后 <code>.</code> 就失败了。 因此 <code>\w+</code> 放弃一个字符, 只匹配 ab 而 <code>.</code> 可以成功匹配字符串 c。 放弃字符的过程(或在轮试的情况下, 尝试不同的分支)被称为回溯。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> </span><span class="p">/;</span>        <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">:</span><span class="na">r</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> </span><span class="p">/;</span>     <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><p>Ratcheting 是一种优化, 因为回溯是昂贵的。 但更重要的是, 它与人类解析文本的方式密切相关。 如果你有一个正则表达式 <code>my regex identifier { \w+ } </code> 和 <code>my regex keyword { if | else | endif }</code>, 你直观地期望 <code>identifier</code> 吞噬整个单词，而不是放弃结束下一个规则，如果下一个 rule 失败时。</p>
<p>例如，你不想让单词 <code>motif</code> 被解析为标识符 mot 后面跟着关键字 if。 相反, 你想将 <code>motif</code> 解析为标识符; 并且如果解析器期望之后有一个 <code>if</code>, 那么最好让它失败, 而不是以你不期望的方式解析输入。</p>
<p>由于 ratcheting 行为在解析器中通常是需要的, 所以有一个快捷方式来声明一个 ratcheting 正则表达式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">token</span> <span class="nf">thing</span> <span class="p">{</span><span class="sr"> </span><span class="o">....</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># short for </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">thing</span> <span class="p">{</span><span class="sr"> </span><span class="p">:</span><span class="na">r</span><span class="sr"> </span><span class="o">..</span><span class="ni">.</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><h3 id="sigspace">Sigspace&nbsp;<a class="headline-hash no-text-decoration" href="#sigspace">#</a> </h3>
<p><code>:sigspace</code> 或 <code>:s</code> 副词使空白在正则表达式中有意义。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#34;</span><span class="s2">I used Photoshop®</span><span class="p">&#34;</span>   <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">i</span><span class="p">/</span><span class="sr">   photo shop </span><span class="p">/;</span>      <span class="c1"># OUTPUT: «True␤»</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#34;</span><span class="s2">I used a photo shop</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">i</span><span class="p">:</span><span class="na">s</span><span class="p">/</span><span class="sr"> photo shop </span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤»</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#34;</span><span class="s2">I used Photoshop®</span><span class="p">&#34;</span>   <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">i</span><span class="p">:</span><span class="na">s</span><span class="p">/</span><span class="sr"> photo shop </span><span class="p">/;</span>   <span class="c1"># OUTPUT: «False␤»</span>
</span></span></code></pre></div><p><code>m:s/ photo shop /</code> 的作用和 <code>m/ photo &lt;.ws&gt; shop &lt;.ws&gt; /</code> 一样。默认地, <code>&lt;.ws&gt;</code> 确保单词是分开的, 所以 <code>a b</code> 和 <code>^$</code> 会匹配中间的 <code>&lt;.ws&gt;</code>, 但是 <code>ab</code> 不会。</p>
<p>正则表达式中哪里的空白会被转换为 <code>&lt;.ws&gt;</code> 取决于空白前面是什么。在上面的例子中, 正则表达式开头的空白不会被转换为 <code>&lt;.ws&gt;</code>, 但是字符后面的空白会被转换为 <code>&lt;.ws&gt;</code>。通常, 规则就是, 如果某一项可能匹配某个东西, 那么它后面的空白会被转换为 <code>&lt;.ws&gt;</code>。</p>
<p>此外, 如果空白跟在某个 term 之后, 量词(+,* 或 ?)之前, 那么 <code>&lt;.ws&gt;</code> 会在每次 term 匹配后匹配。 所以, <code>foo +</code> 变为 <code>[foo &lt;.ws&gt;]+</code>。另一方面, 量词后面的空白和普通的空白作用一样; 例如: &ldquo;foo+&rdquo; 变为 <code>foo+&lt;.ws&gt;</code></p>
<h3 id="matching-adverbs">Matching adverbs&nbsp;<a class="headline-hash no-text-decoration" href="#matching-adverbs">#</a> </h3>
<p>和正则表达式副词对比, 其与正则表达式声明有关, 匹配副词只有在将字符串与正则表达式匹配时才有意义。</p>
<p>它们永远不会出现在正则表达式内部, 只能在外部 - 作为 <code>m/.../</code> 匹配的一部分或作为匹配方法的参数。</p>
<h3 id="continue">Continue&nbsp;<a class="headline-hash no-text-decoration" href="#continue">#</a> </h3>
<p><code>:continue</code> 或短的 <code>:c</code> 副词接收一个参数。 这个参数是正则表达式开始搜索的位置。 默认情况下, 它从字符串的开头搜索, 但是 <code>:c</code> 覆盖该位置。 如果没有为 <code>:c</code> 指定位置, 它将默认为 0, 除非设置了 <code>$/</code>, 在这种情况下, 它默认为 <code>$/.to</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">a1xa2</span><span class="p">&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="k">m</span><span class="p">/</span><span class="sr">a</span><span class="ni">.</span><span class="p">/;</span>         <span class="c1"># OUTPUT: «a1␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="k">m</span><span class="p">:</span><span class="na">c</span><span class="p">(</span><span class="mi">2</span><span class="p">)/</span><span class="sr">a</span><span class="ni">.</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «a2␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意: 不同于 <code>:pos</code>, 使用 <code>:continue()</code> 的匹配将尝试在字符串中进一步匹配, 而不是马上失败:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">abcdefg</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">c</span><span class="p">(</span><span class="mi">3</span><span class="p">)/</span><span class="sr">e</span><span class="ni">.</span><span class="o">+</span><span class="p">/;</span> <span class="c1"># OUTPUT: «｢efg｣␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">abcdefg</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">p</span><span class="p">(</span><span class="mi">3</span><span class="p">)/</span><span class="sr">e</span><span class="ni">.</span><span class="o">+</span><span class="p">/;</span> <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><h3 id="exhaustive">Exhaustive&nbsp;<a class="headline-hash no-text-decoration" href="#exhaustive">#</a> </h3>
<p>要找到正则表达式的所有可能的匹配 - 包括重叠的 - 和几个从同一位置开始的匹配, 请使用 <code>:exhaustive</code>(short: <code>ex</code>) 副词。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">abracadabra</span><span class="p">&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="k">m</span><span class="p">:</span><span class="na">exhaustive</span><span class="p">/</span><span class="sr"> a </span><span class="ni">.</span><span class="o">*</span><span class="sr"> a </span><span class="p">/</span> <span class="k">-&gt;</span> <span class="nv">$match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span> <span class="nb">x</span> <span class="nv">$match</span><span class="o">.</span><span class="nb">from</span><span class="o">,</span> <span class="o">~</span><span class="nv">$match</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面的代码产生这样的输出:</p>
<pre tabindex="0"><code>abracadabra
abracada
abraca
abra
   acadabra
   acada
   aca
     adabra
     ada
       abra
</code></pre><h3 id="global">Global&nbsp;<a class="headline-hash no-text-decoration" href="#global">#</a> </h3>
<p>不是搜索一个匹配并返回一个 <a href="https://docs.raku.org/type/Match">Match 对象</a>, Global 搜索每个不重叠的匹配, 并将其返回到<a href="https://docs.raku.org/type/List">列表</a>中。 为此, 请使用 <code>:global</code> 副词:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">several words here</span><span class="p">&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">@matches</span> <span class="o">=</span> <span class="k">m</span><span class="p">:</span><span class="na">global</span><span class="p">/</span><span class="se">\w</span><span class="o">+</span><span class="p">/;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">@matches</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>         <span class="c1"># OUTPUT: «3␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">@matches</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>           <span class="c1"># OUTPUT: «here␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>:g</code> 是 <code>:global</code> 的简写。</p>
<h3 id="pos">Pos&nbsp;<a class="headline-hash no-text-decoration" href="#pos">#</a> </h3>
<p>在字符串的特定位置锚定匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">abcdef</span><span class="p">&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$match</span> <span class="o">=</span> <span class="k">m</span><span class="p">:</span><span class="na">pos</span><span class="p">(</span><span class="mi">2</span><span class="p">)/</span><span class="ni">.</span><span class="o">*</span><span class="p">/;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$match</span><span class="o">.</span><span class="nb">from</span><span class="p">;</span>        <span class="c1"># OUTPUT: «2␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$match</span><span class="p">;</span>            <span class="c1"># OUTPUT: «cdef␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>:p</code> 是 <code>:pos</code> 的简写。</p>
<p>注意: 不同于 <code>:continue</code>, 使用 <code>:pos()</code> 锚定的匹配在不匹配时将立即失败, 而不是尝试进一步匹配字符串:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">abcdefg</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">c</span><span class="p">(</span><span class="mi">3</span><span class="p">)/</span><span class="sr">e</span><span class="ni">.</span><span class="o">+</span><span class="p">/;</span> <span class="c1"># OUTPUT: «｢efg｣␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">abcdefg</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">p</span><span class="p">(</span><span class="mi">3</span><span class="p">)/</span><span class="sr">e</span><span class="ni">.</span><span class="o">+</span><span class="p">/;</span> <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><h3 id="overlap">Overlap&nbsp;<a class="headline-hash no-text-decoration" href="#overlap">#</a> </h3>
<p>要获得多个匹配, 包括重叠的匹配, 但每个起始位置只有一个(最长的)匹配, 请指定 <code>:overlap</code> (short <code>:ov</code>) 副词:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">abracadabra</span><span class="p">&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="k">m</span><span class="p">:</span><span class="na">overlap</span><span class="p">/</span><span class="sr"> a </span><span class="ni">.</span><span class="o">*</span><span class="sr"> a </span><span class="p">/</span> <span class="k">-&gt;</span> <span class="nv">$match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span> <span class="nb">x</span> <span class="nv">$match</span><span class="o">.</span><span class="nb">from</span><span class="o">,</span> <span class="o">~</span><span class="nv">$match</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>产生:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">abracadabra</span>
</span></span><span class="line"><span class="cl">   <span class="n">acadabra</span>
</span></span><span class="line"><span class="cl">     <span class="n">adabra</span>
</span></span><span class="line"><span class="cl">       <span class="n">abra</span>
</span></span></code></pre></div><h2 id="look-around-assertions">Look-around assertions&nbsp;<a class="headline-hash no-text-decoration" href="#look-around-assertions">#</a> </h2>
<h3 id="lookahead-assertions">Lookahead assertions&nbsp;<a class="headline-hash no-text-decoration" href="#lookahead-assertions">#</a> </h3>
<p>要检查一个模式是否出现在另一个模式之前，请通过 <code>before</code> 断言使用 lookahead 断言。形式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">?before pattern</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>因此，要搜索字符串 foo 后面紧跟着字符串 bar, 请使用以下 regexp:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">rx</span><span class="p">{</span><span class="sr"> foo </span><span class="p">&lt;</span><span class="o">?</span><span class="ow">before</span><span class="sr"> bar</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foobar</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="k">rx</span><span class="p">{</span><span class="sr"> foo </span><span class="p">&lt;</span><span class="o">?</span><span class="ow">before</span><span class="sr"> bar</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">};</span>   <span class="c1"># OUTPUT: «foo␤» </span>
</span></span></code></pre></div><p>但是，如果要搜索一个不紧随某个模式的模式, 那么您需要使用反向向前查看断言, 其形式如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">!before pattern</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>因此，所有出现的不在 bar 之前的 foo 都会匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">rx</span><span class="p">{</span><span class="sr"> foo </span><span class="p">&lt;</span><span class="o">!</span><span class="ow">before</span><span class="sr"> bar</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><h3 id="lookbehind-assertions">Lookbehind assertions&nbsp;<a class="headline-hash no-text-decoration" href="#lookbehind-assertions">#</a> </h3>
<p>要检查一个模式是否出现在另一个模式之后，请通过 <code>after</code> 断言使用 <code>lookbehind</code> 断言。 其形式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">?after pattern</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>因此, 要搜索字符串 foo 立即跟着的 bar 字符串, 使用如下正则表达式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">rx</span><span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="ow">after</span><span class="sr"> foo</span><span class="p">&gt;</span><span class="sr"> bar </span><span class="p">}</span> <span class="c1"># read as after foo is bar</span>
</span></span></code></pre></div><p>例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foobar</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="k">rx</span><span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="ow">after</span><span class="sr"> foo</span><span class="p">&gt;</span><span class="sr"> bar </span><span class="p">};</span> <span class="c1">#  OUTPUT: «bar␤» </span>
</span></span></code></pre></div><p>但是, 如果要搜索的模式不是紧随其后的模式, 那么您需要使用反向的 lookbehind 断言, 其形式如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">!after pattern</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>因此, bar 前面不是 foo 的所有 bar 将被匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">rx</span><span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="ow">after</span><span class="sr"> foo</span><span class="p">&gt;</span><span class="sr"> bar </span><span class="p">}</span>
</span></span></code></pre></div><h2 id="best-practices-and-gotchas">Best practices and gotchas&nbsp;<a class="headline-hash no-text-decoration" href="#best-practices-and-gotchas">#</a> </h2>
<p>为了帮助强大的正则表达式和 Grammar, 以下是代码布局和可读性的最佳实践，实际匹配的内容，并避免常见的陷阱。</p>
<h3 id="code-layout">Code layout&nbsp;<a class="headline-hash no-text-decoration" href="#code-layout">#</a> </h3>
<p>没有 <code>:sigspace</code> 副词, 空白在 Raku 正则表达式中就是没有意义的。 在能增加可读性的地方插入空格。 此外, 必要时插入注释。</p>
<p>比较下面这个比较紧凑的正则表达式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">float</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="se">\d</span><span class="o">*</span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="se">\d</span><span class="o">+</span><span class="p">[</span><span class="sr">e</span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="se">\d</span><span class="o">+</span><span class="p">]</span><span class="o">?</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>和可读性更好的版本:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">float</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="sr">        </span><span class="c1"># optional sign 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">     </span><span class="se">\d</span><span class="o">*</span><span class="sr">            </span><span class="c1"># leading digits, optional 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">     </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="se">\d</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">[</span><span class="sr">              </span><span class="c1"># optional exponent 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">        e </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="sr">  </span><span class="se">\d</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">]</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><p>根据经验，在原子周围和分组内部使用空格; 将量词直接置于原子之后; 并垂直对齐开口和闭合方括号和圆括号。</p>
<p>当你在方括号或圆括号中使用一组备选分支时, 请对齐垂直条:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">example</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">preamble</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">[</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">choice_1</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">choice_2</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">choice_3</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">]</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">postamble</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="keep-it-small">Keep it small&nbsp;<a class="headline-hash no-text-decoration" href="#keep-it-small">#</a> </h3>
<p>正则表达式通常比常规代码更紧凑。 因为他们短小精悍, 保持正则表达式很短。</p>
<p>当你可以命名正则表达式的一部分时, 通常最好将其放入单独的命名正则表达式中。</p>
<p>例如, 您可以从前面获取 float 正则表达式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">float</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="sr">        </span><span class="c1"># optional sign 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">     </span><span class="se">\d</span><span class="o">*</span><span class="sr">            </span><span class="c1"># leading digits, optional 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">     </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="se">\d</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">[</span><span class="sr">              </span><span class="c1"># optional exponent 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">        e </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="sr">  </span><span class="se">\d</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">]</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><p>并把它分解成几部分:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">token</span> <span class="nf">sign</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">token</span> <span class="nf">decimal</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">token</span> <span class="nf">exponent</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">e</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sign</span><span class="p">&gt;</span><span class="o">?</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">float</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">sign</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">exponent</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><p>这很有用, 特别是当正则表达式变得更加复杂时。 例如, 你可能希望在存在指数的情况下使小数点可选。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">float</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">sign</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">[</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">  </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">exponent</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">exponent</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">]</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="what-to-match">What to match&nbsp;<a class="headline-hash no-text-decoration" href="#what-to-match">#</a> </h3>
<p>通常，输入数据格式没有明确的规范，或规范对编程人员来说是未知的。 那么，在你期望的时候是自由的，只要没有可能的含糊不清就行了。</p>
<p>例如，在 ini 文件中:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">[</span><span class="n">section</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">key</span><span class="o">=</span><span class="nb">value</span>
</span></span></code></pre></div><p>什么可以在 section 标题内? 只允许一个单词可能太限制了。 有人会写 <code>[two words]</code>, 或用破折号等等。 而不是询问内部允许的内容, 可能这样问比较好: 什么是不允许的？</p>
<p>显然, 不允许使用括号，因为 <code>[a] b]</code> 是不明确的。 同样的论据, 应禁止开口方括号。 这让我们有了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">header</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> </span><span class="se">\</span><span class="sr">[</span><span class="se">\</span><span class="sr">] </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>如果你只处理一行就行了。 但是，如果你正在处理整个文件，突然间正则表达式解析到一句</p>
<pre tabindex="0"><code>[with a
newline in between]
</code></pre><p>这可能不是一个好方法。折中的方式是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">header</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> </span><span class="se">\</span><span class="sr">[</span><span class="se">\</span><span class="sr">] </span><span class="se">\n</span><span class="sr"> </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>然后在扫尾处理中, 从 section 标题中移除前导和尾部空格和制表符。</p>
<h3 id="matching-whitespace">Matching Whitespace&nbsp;<a class="headline-hash no-text-decoration" href="#matching-whitespace">#</a> </h3>
<p><code>:sigspace</code> 副词(或使用 <code>rule</code> 声明符, 而不是 <code>token</code> 或 <code>regex</code>) 非常适用于隐式解析许多地方可能出现的空格。</p>
<p>回到解析 ini 文件的例子, 我们有</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">kvpair</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>这可能不像我们想要的那样自由, 因为用户可能会在等号周围放置空格。 那么我们可以试试这个:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">kvpair</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>但这看起来很笨重, 所以我们尝试其他方式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">rule</span> <span class="nf">kvpair</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>可是等等! <code>value</code> 之后，隐含的空白匹配用光了所有的空白, 包括换行符, 所以 <code>\n+</code> 没有什么可以匹配的(rule 也禁止回溯, 所以运气不佳)。</p>
<p>因此, 重要的是将隐式空白的定义重新定义为输入格式无意义的空白。</p>
<p>这通过重新定义 token <code>ws</code>; 但是，它只适用于 <a href="https://docs.raku.org/language/grammars">Grammars</a>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">IniFormat</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">ws</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="ow">ww</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">header</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">(</span><span class="se">\w</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">identifier</span>  <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">kvpair</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">section</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">&lt;</span><span class="nf">header</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">&lt;</span><span class="nf">kvpair</span><span class="p">&gt;</span><span class="o">*</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">&lt;</span><span class="nf">section</span><span class="p">&gt;</span><span class="o">*</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$contents</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOI/;</span><span class="s"> 
</span></span></span><span class="line"><span class="cl"><span class="s">    [passwords]
</span></span></span><span class="line"><span class="cl"><span class="s">        jack = password1
</span></span></span><span class="line"><span class="cl"><span class="s">        joy = muchmoresecure123
</span></span></span><span class="line"><span class="cl"><span class="s">    [quotas]
</span></span></span><span class="line"><span class="cl"><span class="s">        jack = 123
</span></span></span><span class="line"><span class="cl"><span class="s">        joy = 42
</span></span></span><span class="line"><span class="cl"><span class="s"></span><span class="p">EOI</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="n">IniFormat</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$contents</span><span class="p">);</span>
</span></span></code></pre></div><p>除了把所有的正则表达式都放在一个 Grammar 中并把它们变成了 tokens(因为他们不需要回溯) 之外, 有趣的新花样是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">ws</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="ow">ww</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>这被称为隐式空白解析。 当它不在两个字符之间 (<code>&lt;ww&gt;</code>, 反向的&quot;within word&quot; 断言)时匹配, 以及零个或多个水平空格字符。 对水平空白的限制很重要, 因为换行符(它们是垂直空白)定界记录, 不应该被隐式地匹配。</p>
<p>还有一些与空白有关的麻烦潜伏着。 正则表达式 <code>\n+</code> 将不会匹配 <code>\n \n</code> 这样的字符串, 因为两个换行符之间有空白。 要允许这样的输入字符串, 用 <code>\n\s*</code> 代替 <code>\n+</code>。</p>


        </div>
    </div>
</article>



                <footer>
                    




<div class="no-text-decoration">
    <div class="jump top"><a href="#" title="Top of this page">⮉</a></div>
    <div class="jump bottom"><a href="#bottom" title="Bottom of this page">⮋</a></div>
</div>


 
    
        <div class="hugotoc no-text-decoration">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#词法约定">词法约定</a></li>
    <li><a href="#字面值">字面值</a></li>
    <li><a href="#通配符和字符类">通配符和字符类</a>
      <ul>
        <li><a href="#点号匹配任意字符-">点号匹配任意字符: .</a></li>
        <li><a href="#反斜杠-预定义字符类">反斜杠, 预定义字符类</a></li>
        <li><a href="#unicode-properties">Unicode properties</a></li>
        <li><a href="#unicode-属性">Unicode 属性</a></li>
        <li><a href="#可枚举的字符类和区间">可枚举的字符类和区间</a></li>
      </ul>
    </li>
    <li><a href="#量词">量词</a>
      <ul>
        <li><a href="#一次-或多次--">一次 或多次 : +</a></li>
        <li><a href="#零次-或-多次-">零次 或 多次: *</a></li>
        <li><a href="#零次-或-一次匹配-">零次 或 一次匹配: ?</a></li>
        <li><a href="#常规量词--minmax">常规量词: ** min..max</a></li>
        <li><a href="#modified-quantifier-">Modified quantifier: %</a></li>
        <li><a href="#贪婪量词-vs-非贪婪量词-">贪婪量词 Vs. 非贪婪量词: ?</a></li>
        <li><a href="#阻止回溯-">阻止回溯: :</a></li>
      </ul>
    </li>
    <li><a href="#alternation-">Alternation: ||</a></li>
    <li><a href="#longest-alternation-">Longest Alternation: |</a></li>
    <li><a href="#anchors">Anchors</a>
      <ul>
        <li><a href="#--start-of-string-and---end-of-string">^ , Start of String and $ , End of String</a></li>
        <li><a href="#--start-of-line-and---end-of-line">^^ , Start of Line and $$ , End of Line</a></li>
        <li><a href="#w-and-w-word-boundary">&lt;|w&gt; and &lt;!|w&gt;, word boundary</a></li>
        <li><a href="#-and---left-and-right-word-boundary">&laquo; and &raquo; , left and right word boundary</a></li>
      </ul>
    </li>
    <li><a href="#分组和捕获">分组和捕获</a>
      <ul>
        <li><a href="#捕获">捕获</a></li>
        <li><a href="#非捕获分组">非捕获分组</a></li>
        <li><a href="#捕获编号">捕获编号</a></li>
        <li><a href="#命名捕获">命名捕获</a></li>
        <li><a href="#capture-markers--">Capture markers: &lt;( )&gt;</a></li>
      </ul>
    </li>
    <li><a href="#替换">替换</a>
      <ul>
        <li><a href="#词汇约定">词汇约定</a></li>
        <li><a href="#替换字符串字面值">替换字符串字面值</a></li>
        <li><a href="#通配符和字符类-1">通配符和字符类</a></li>
        <li><a href="#捕获组">捕获组</a></li>
        <li><a href="#common-adverbs">Common adverbs</a></li>
      </ul>
    </li>
    <li><a href="#tilde-for-nesting-structures">Tilde for nesting structures</a></li>
    <li><a href="#subrules">Subrules</a></li>
    <li><a href="#副词">副词</a>
      <ul>
        <li><a href="#regex-adverbs">Regex Adverbs</a></li>
        <li><a href="#ratchet">Ratchet</a></li>
        <li><a href="#sigspace">Sigspace</a></li>
        <li><a href="#matching-adverbs">Matching adverbs</a></li>
        <li><a href="#continue">Continue</a></li>
        <li><a href="#exhaustive">Exhaustive</a></li>
        <li><a href="#global">Global</a></li>
        <li><a href="#pos">Pos</a></li>
        <li><a href="#overlap">Overlap</a></li>
      </ul>
    </li>
    <li><a href="#look-around-assertions">Look-around assertions</a>
      <ul>
        <li><a href="#lookahead-assertions">Lookahead assertions</a></li>
        <li><a href="#lookbehind-assertions">Lookbehind assertions</a></li>
      </ul>
    </li>
    <li><a href="#best-practices-and-gotchas">Best practices and gotchas</a>
      <ul>
        <li><a href="#code-layout">Code layout</a></li>
        <li><a href="#keep-it-small">Keep it small</a></li>
        <li><a href="#what-to-match">What to match</a></li>
        <li><a href="#matching-whitespace">Matching Whitespace</a></li>
      </ul>
    </li>
  </ul>
</nav>
            <a href="#" class="back-to-top">Back to top</a>
        </div>
    
    
<script src="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js"></script>

<link rel="preload" href="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js" as="script">

<script type="application/javascript">(function() {
     var $window = $(window);
     if ($window.width() >= 1400) { 
         var $toc = $('#TableOfContents');
         if ($toc.length > 0) {
             function onScroll(){
                 var currentScroll = $window.scrollTop();
                 var h = $('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .h-feed h2');
                 var id = "";
                 h.each(function (i, e) {
                     e = $(e);
                     if (e.offset().top - 10 <= currentScroll) {
                         id = e.attr('id');
                     }
                 });
                 var current = $toc.find('a.current');
                 if (current.length == 1 && current.eq(0).attr('href') == '#' + id) return true;

                 current.each(function (i, e) {
                     $(e).removeClass('current').siblings('ul').hide();
                 });
                 $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                     $(e).children('a').addClass('current').siblings('ul').show();
                 });
             }
             $window.on('scroll', onScroll);
             $(document).ready(function() {
                 $toc.find('a').parent('li').find('ul').hide();
                 onScroll();
                 document.getElementsByClassName('hugotoc')[0].style.display = '';
             });}}})();</script>








<div class="backtotop center no-text-decoration">
    <a href="#">back to <span class="top">top</span></a>
</div>


<div class="right">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="http://localhost:1313/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="http://localhost:1313/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>
<div class="clear-float"></div>



<div class="prev-next-navigator clear-float">
    
        <span class="prev-post left no-text-decoration">
            <a href="http://localhost:1313/notes/what-s-the-date-today/" class="nobr">« 🎄 5/25. 在 Raku 中今天是什么日期?</a>
        </span>
    
    
        <span class="next-post right no-text-decoration">
            <a href="http://localhost:1313/notes/test-hooks-and-helpers/" class="nobr">第四天 - 测试钩子和助手 »</a>
        </span>
    
</div>


<a id="bottom"></a>









                       







                    <ul class="no-bullets feed right inline">
    
        
        
    
</ul>
<div class="clear-float"></div>

                </footer>
                <hr />
            </div>               

            <footer> 
                

<ul class="social no-text-decoration">
    
</ul>










 
    
    



<p class="generated no-text-decoration">
    Generated using  <a href="https://gitlab.com/kaushalmodi/hugo-theme-refined"><code class="nobr">hugo-theme-refined</code></a> + <span class="nobr">Hugo <a href="https://github.com/gohugoio/hugo/commit/312735366b20d64bd61bff8627f593749f86c964">0.123.7</a></span>
</p>

<p>
    
</p>




<div class="badges no-text-decoration">
    
    

    
</div>




<script type="application/javascript">var nav=responsiveNav("#nav");</script>




<script defer src="/js/libs/fragmentions/wrapper.min.e8c468c89edc4f5dccaa8c720c6b220b3088a16cd7b1e4a1e3345985788260c9.js"></script>









            </footer>
        </div> 
    </body>
</html>
