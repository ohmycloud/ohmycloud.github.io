{"author":{"name":null,"type":"card","url":"http://localhost:1313/"},"content":{"html":"\u003cp\u003e不同的操作系统使用不同的字符或字符的组合来表示换行符。每种语言都有自己的一套规则来处理这个问题。 Raku 有以下几个规则：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e字符串字面量中的 \u003ccode\u003e\\n\u003c/code\u003e 表示 Unicode 代码点 10。\u003c/li\u003e\n\u003cli\u003e由 \u003ccode\u003esay\u003c/code\u003e 附加到字符串的默认 \u003ca href=\"https://docs.raku.org/routine/nl-out\"\u003enl-out\u003c/a\u003e 也是 \u003ccode\u003e\\n\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e在输出时，当在 Windows 上时，编码器默认将 \u003ccode\u003e\\n\u003c/code\u003e 转换为 \u003ccode\u003e\\r\\n\u003c/code\u003e，当它转到文件，进程或终端时（但它不会在套接字上执行此操作）。\u003c/li\u003e\n\u003cli\u003e在输入时，在任何平台上，解码器默认将 \u003ccode\u003e\\r\\n\u003c/code\u003e 标准化为 \u003ccode\u003e\\n\u003c/code\u003e，以便从文件，进程或终端（同样不是套接字）输入。\u003c/li\u003e\n\u003cli\u003e以上两点一起意味着你可以 - 把套接字编程放在一边 - 期望永远不会在你的程序中看到 \u003ccode\u003e\\r\\n\u003c/code\u003e（这也是许多其他语言的工作原理）。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.raku.org/type/Encoding#method_decoder\"\u003e:$translate-nl\u003c/a\u003e 命名参数存在于控制此转换的各个位置，例如，在 \u003ca href=\"https://docs.raku.org/type/Proc::Async#method_new\"\u003eProc::Async.new\u003c/a\u003e 和 \u003ca href=\"https://docs.raku.org/type/Proc::Async#method_Supply\"\u003eProc::Async.Supply\u003c/a\u003e 中。\u003c/li\u003e\n\u003cli\u003e正则表达式语言中的 \u003ccode\u003e\\n\u003c/code\u003e 是合乎逻辑的，并且匹配 \u003ccode\u003e\\r\\n\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e您可以通过在创建该句柄时设置 \u003ccode\u003e:nl-out\u003c/code\u003e 属性来更改特定句柄的默认行为。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$crlf-out\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eopen\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eIO::Special\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003enew\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026lt;STDOUT\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;)\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003enl-out\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003e\\\\\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\\r\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"vg\"\u003e$*OUT\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e     \u003cspan class=\"c1\"\u003e#OUTPUT: «1␤» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$crlf-out\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e#OUTPUT: «1\\␤␍» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在这个例子中，我们通过使用 \u003ca href=\"https://docs.raku.org/type/IO::Special\"\u003eIO::Special\u003c/a\u003e 将标准输出复制到新句柄，我们在字符串的末尾附加一个 \u003ccode\u003e\\\u003c/code\u003e，然后是换行符 \u003ccode\u003e␤\u003c/code\u003e 和回车符 \u003ccode\u003e␍\u003c/code\u003e; 我们打印到该句柄的所有内容都会在行尾添加这些字符，如图所示。\u003c/p\u003e\n\u003cp\u003e在正则表达式中，\u003ca href=\"https://docs.raku.org/language/regexes#index-entry-regex_%5Cn-regex_%5CN-%5Cn_and_%5CN\"\u003e\\n\u003c/a\u003e 是根据\u003ca href=\"https://unicode.org/reports/tr18/#Line_Boundaries\"\u003e逻辑换行符的Unicode定义\u003c/a\u003e定义的。它会匹配 \u003ccode\u003e.\u003c/code\u003e, 还有 \u003ccode\u003e\\v\u003c/code\u003e，以及包含空格的任何类。\u003c/p\u003e\n","text":"不同的操作系统使用不同的字符或字符的组合来表示换行符。每种语言都有自己的一套规则来处理这个问题。 Raku 有以下几个规则：\n字符串字面量中的 \\n 表示 Unicode 代码点 10。 由 say 附加到字符串的默认 nl-out 也是 \\n。 在输出时，当在 Windows 上时，编码器默认将 \\n 转换为 \\r\\n，当它转到文件，进程或终端时（但它不会在套接字上执行此操作）。 在输入时，在任何平台上，解码器默认将 \\r\\n 标准化为 \\n，以便从文件，进程或终端（同样不是套接字）输入。 以上两点一起意味着你可以 - 把套接字编程放在一边 - 期望永远不会在你的程序中看到 \\r\\n（这也是许多其他语言的工作原理）。 :$translate-nl 命名参数存在于控制此转换的各个位置，例如，在 Proc::Async.new 和 Proc::Async.Supply 中。 正则表达式语言中的 \\n 是合乎逻辑的，并且匹配 \\r\\n。 您可以通过在创建该句柄时设置 :nl-out 属性来更改特定句柄的默认行为。\nmy $crlf-out = open(IO::Special.new(\u0026#39;\u0026lt;STDOUT\u0026gt;\u0026#39;), :nl-out(\u0026#34;\\\\\\n\\r\u0026#34;)); $*OUT.say: 1; #OUTPUT: «1␤» $crlf-out.say: 1; #OUTPUT: «1\\␤␍» 在这个例子中，我们通过使用 IO::Special 将标准输出复制到新句柄，我们在字符串的末尾附加一个 \\，然后是换行符 ␤ 和回车符 ␍; 我们打印到该句柄的所有内容都会在行尾添加这些字符，如图所示。\n在正则表达式中，\\n 是根据逻辑换行符的Unicode定义定义的。它会匹配 ., 还有 \\v，以及包含空格的任何类。\n"},"name":"Raku 中的换行处理","published":"2018-11-26T21:13:31+08:00","summary":"不同的操作系统使用不同的字符或字符的组合来表示换行符。每种语言都有自己的一套规则来处理这个问题。 Raku 有以下几个规则：\n字符串字面量中的 \\n 表示 Unicode 代码点 10。 由 say 附加到字符串的默认 nl-out 也是 \\n。 在输出时，当在 Windows 上时，编码器默认将 \\n 转换为 \\r\\n，当它转到文件，进程或终端时（但它不会在套接字上执行此操作）。 在输入时，在任何平台上，解码器默认将 \\r\\n 标准化为 \\n，以便从文件，进程或终端（同样不是套接字）输入。 以上两点一起意味着你可以 - 把套接字编程放在一边 - 期望永远不会在你的程序中看到 \\r\\n（这也是许多其他语言的工作原理）。 :$translate-nl 命名参数存在于控制此转换的各个位置，例如，在 Proc::Async.new 和 Proc::Async.Supply 中。 正则表达式语言中的 \\n 是合乎逻辑的，并且匹配 \\r\\n。 您可以通过在创建该句柄时设置 :nl-out 属性来更改特定句柄的默认行为。\nmy $crlf-out = open(IO::Special.new(\u0026#39;\u0026lt;STDOUT\u0026gt;\u0026#39;), :nl-out(\u0026#34;\\\\\\n\\r\u0026#34;)); $*OUT.say: 1; #OUTPUT: «1␤» $crlf-out.say: 1; #OUTPUT: «1\\␤␍» 在这个例子中，我们通过使用 IO::Special 将标准输出复制到新句柄，我们在字符串的末尾附加一个 \\，然后是换行符 ␤ 和回车符 ␍; 我们打印到该句柄的所有内容都会在行尾添加这些字符，如图所示。\n在正则表达式中，\\n 是根据逻辑换行符的Unicode定义定义的。它会匹配 ., 还有 \\v，以及包含空格的任何类。","type":"entry","url":"http://localhost:1313/rakulang/51.newline-handling-in-perl-6/"}