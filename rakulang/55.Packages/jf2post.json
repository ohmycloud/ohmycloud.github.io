{"author":{"name":null,"type":"card","url":"http://localhost:1313/"},"content":{"html":"\u003cblockquote\u003e\n\u003cp\u003ePackages - Organizing and referencing namespaced program elements\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e包是指定程序元素的嵌套命名空间。 模块，类，Grammar是包类型。 像目录中的文件一样，通常可以使用其短名称（如果它们是本地的）或使用较长的名称来消除歧义的引用具名元素。\u003c/p\u003e\n\u003ch2 id=\"names\"\u003eNames\u003c/h2\u003e\n\u003cp\u003e名称是作为变量名称的合法部分的任何东西（不包括sigil符号）。 这包括：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e                \u003cspan class=\"c1\"\u003e# 简单标识符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$Foo::Bar::baz\u003c/span\u003e      \u003cspan class=\"c1\"\u003e# 通过 :: 分割的组合标识符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$Foo::\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$bar\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003ebaz\u003c/span\u003e   \u003cspan class=\"c1\"\u003e# 执行插值的组合标识符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$42\u003c/span\u003e                 \u003cspan class=\"c1\"\u003e# numeric names\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$!\u003c/span\u003e                  \u003cspan class=\"c1\"\u003e# 某些标点符号变量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003e::\u003c/code\u003e 用于分割嵌套的包名。\u003c/p\u003e\n\u003ch3 id=\"包限定名\"\u003e包限定名\u003c/h3\u003e\n\u003cp\u003e普通的包限定名像这样:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$Foo::Bar::baz\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# 包 Foo::Bar 中的 $baz 变量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e有时保持sigil与变量名很清晰，所以来写这个的一个替代方式是：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eFoo::Bar::\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003e$baz\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这在编译时解决，因为变量名是一个常量。\u003c/p\u003e\n\u003cp\u003e如果 \u003ccode\u003e::\u003c/code\u003e 之前的名称部分为 null，则意味着包未指定并且必须搜索。 一般来说，这意味着跟在主sigil后面的初始 \u003ccode\u003e::\u003c/code\u003e 是对编译时已知的名字的无操作(no-op)，但 \u003ccode\u003e::()\u003c/code\u003e 也可以用来引入插值。 另外，在没有另一个sigil的情况下，\u003ccode\u003e::\u003c/code\u003e 可以作为它自己的sigil，表明有意使用一个尚未声明的包名。\u003c/p\u003e\n\u003ch2 id=\"伪包\"\u003e伪包\u003c/h2\u003e\n\u003cp\u003e在名称前面保留以下伪包名称：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eMY\u003c/span\u003e          \u003cspan class=\"c1\"\u003e# 当前词法作用域中的符号 (aka $?SCOPE)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eOUR\u003c/span\u003e         \u003cspan class=\"c1\"\u003e# 当前包中的符号 (aka $?PACKAGE)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eCORE\u003c/span\u003e        \u003cspan class=\"c1\"\u003e# 最外层词法作用域, 定义标准 Perl\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eGLOBAL\u003c/span\u003e      \u003cspan class=\"c1\"\u003e# Interpreter-wide package symbols, really UNIT::GLOBAL\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ePROCESS\u003c/span\u003e     \u003cspan class=\"c1\"\u003e# 进程相关的全局变量 (superglobals)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eCOMPILING\u003c/span\u003e   \u003cspan class=\"c1\"\u003e# 正在编译的作用域中的词法符号\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e以下相对名称也保留，但可以在名称中的任何位置使用：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eCALLER\u003c/span\u003e      \u003cspan class=\"c1\"\u003e# Contextual symbols in the immediate caller\u0026#39;s lexical scope\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eCALLERS\u003c/span\u003e     \u003cspan class=\"c1\"\u003e# Contextual symbols in any caller\u0026#39;s lexical scope\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eDYNAMIC\u003c/span\u003e     \u003cspan class=\"c1\"\u003e# Contextual symbols in my or any caller\u0026#39;s lexical scope\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eOUTER\u003c/span\u003e       \u003cspan class=\"c1\"\u003e# Symbols in the next outer lexical scope\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eOUTERS\u003c/span\u003e      \u003cspan class=\"c1\"\u003e# Symbols in any outer lexical scope\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eLEXICAL\u003c/span\u003e     \u003cspan class=\"c1\"\u003e# Contextual symbols in my or any outer\u0026#39;s lexical scope\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eUNIT\u003c/span\u003e        \u003cspan class=\"c1\"\u003e# Symbols in the outermost lexical scope of compilation unit\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eSETTING\u003c/span\u003e     \u003cspan class=\"c1\"\u003e# Lexical symbols in the unit\u0026#39;s DSL (usually CORE)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ePARENT\u003c/span\u003e      \u003cspan class=\"c1\"\u003e# Symbols in this package\u0026#39;s parent package (or lexical scope)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eCLIENT\u003c/span\u003e      \u003cspan class=\"c1\"\u003e# The nearest CALLER that comes from a different package\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e文件的作用域称为 \u003ccode\u003eUNIT\u003c/code\u003e，但在对应于语言设置的外面有一个或多个词法作用域（其他文化中通常称为序幕）。 因此，\u003ccode\u003eSETTING\u003c/code\u003e 作用域等价于 \u003ccode\u003eUNIT::OUTERS\u003c/code\u003e。 对于标准的Perl程序，\u003ccode\u003eSETTING\u003c/code\u003e 与 \u003ccode\u003eCORE\u003c/code\u003e 相同，但是各种启动选项（如 \u003ccode\u003e-n\u003c/code\u003e 或 \u003ccode\u003e-p\u003c/code\u003e）可以使您进入特定领域语言，在这种情况下，\u003ccode\u003eCORE\u003c/code\u003e 仍然是标准语言的作用域，而 \u003ccode\u003eSETTING\u003c/code\u003e 表示定义用作当前文件的设置的DSL的作用域。 当作为名称中间的搜索项使用时，SETTING包括其所有外部作用域，直到 \u003ccode\u003eCORE\u003c/code\u003e。 要仅获取设置的最外层作用域，请改用 \u003ccode\u003eUNIT::OUTER\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"查找名字\"\u003e查找名字\u003c/h2\u003e\n\u003ch3 id=\"插值到名字中\"\u003e插值到名字中\u003c/h3\u003e\n\u003cp\u003e您可以使用 \u003ccode\u003e::($expr)\u003c/code\u003e 将字符串插入到包或变量名中，\u003ccode\u003e$expr\u003c/code\u003e 表达式中通常放置包或变量名。 该字符串允许包含额外的 \u003ccode\u003e::\u003c/code\u003e 实例，这将被解释为包嵌套。 您只能内插整个名称，因为结构以 \u003ccode\u003e::\u003c/code\u003e 开头，并且立即结束或用括号之外的另一个 \u003ccode\u003e::\u003c/code\u003e 继续。 大多数符号引用使用这种记法：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eBar\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$foobar\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eFoo::Bar\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$::\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e           \u003cspan class=\"c1\"\u003e# lexically-scoped $Bar\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$::\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eMY::\u003c/span\u003e\u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;)\u003c/span\u003e     \u003cspan class=\"c1\"\u003e# lexically-scoped $Bar\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$::\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eOUR::\u003c/span\u003e\u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;)\u003c/span\u003e    \u003cspan class=\"c1\"\u003e# package-scoped $Bar\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$::\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eGLOBAL::\u003c/span\u003e\u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;)\u003c/span\u003e \u003cspan class=\"c1\"\u003e# global $Bar\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$::\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003ePROCESS::\u003c/span\u003e\u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;)\u003c/span\u003e\u003cspan class=\"c1\"\u003e# process $Bar\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$::\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003ePARENT::\u003c/span\u003e\u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;)\u003c/span\u003e \u003cspan class=\"c1\"\u003e# current package\u0026#39;s parent\u0026#39;s $Bar\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$::\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$foobar\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e        \u003cspan class=\"c1\"\u003e# $Foo::Bar\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$::\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$foobar\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003ebaz\u003c/span\u003e   \u003cspan class=\"c1\"\u003e# $Foo::Bar::baz\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$::\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003eBar\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003ebaz\u003c/span\u003e \u003cspan class=\"c1\"\u003e# $Bar::Bar::baz\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$::\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$foobar\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003ebaz\u003c/span\u003e     \u003cspan class=\"c1\"\u003e# ILLEGAL at compile time (no operator baz)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e初始 \u003ccode\u003e::\u003c/code\u003e 不表明全局。 这里作为插值语法的一部分，它甚至不暗示包。 \u003ccode\u003e::()\u003c/code\u003e 组件插值之后，间接名称被查找，就像它在原始源代码中一样，优先级首先指定为前导伪包名称，然后指向词法作用域中的名称（搜索 向外扩展，以\u003ccode\u003eCORE\u003c/code\u003e结束）。 最后搜索当前包。\u003c/p\u003e\n\u003cp\u003e使用 \u003ccode\u003eMY\u003c/code\u003e 伪包将查找限制为当前词法作用域，\u003ccode\u003eOUR\u003c/code\u003e 将作用域限制为当前包作用域。\u003c/p\u003e\n\u003ch3 id=\"直接查找\"\u003e直接查找\u003c/h3\u003e\n\u003cp\u003e要在包的符号表中直接查找而不进行扫描，请将包名视为哈希：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eFoo::Bar::\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026amp;baz\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;}\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# same as \u0026amp;Foo::Bar::baz\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ePROCESS::\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003e$IN\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e      \u003cspan class=\"c1\"\u003e# Same as $*IN\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eFoo::\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003e::Bar\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003e::Baz\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"c1\"\u003e# same as Foo::Bar::Baz\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e不像 \u003ccode\u003e::()\u003c/code\u003e 符号引用，这不解析\u003ccode\u003e::\u003c/code\u003e的参数，也不从该初始点启动命名空间扫描。 此外，对于常量下标，保证在编译时解析符号。\u003c/p\u003e\n\u003cp\u003e空伪包是与普通名称搜索有相同的搜索列表。 也就是说，以下各项在意义上是相同的：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$::\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$::\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e它们中的每一个都向外扫描词法作用域，然后扫描当前的包作用域（虽然当“strict”有效时包作用域被禁止，）。\u003c/p\u003e\n\u003cp\u003e作为这些规则的结果，您可以把变量名写的很随意：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$::\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e!@#$#@\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e$!@#$#@\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e只要名字中没有空格, 您也可以使用 \u003ccode\u003e::\u0026lt;\u0026gt;\u003c/code\u003e 形式。\u003c/p\u003e\n\u003ch3 id=\"包查找\"\u003e包查找\u003c/h3\u003e\n\u003cp\u003e将包对象本身下标为哈希对象，其键是变量名，包括任何sigil。 包对象可以通过使用 \u003ccode\u003e::\u003c/code\u003e 后缀从类型名中派生：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eMyType::\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"全局\"\u003e全局\u003c/h2\u003e\n\u003cp\u003e解释器全局变量存在于 \u003ccode\u003eGLOBAL\u003c/code\u003e 包中。 用户程序在 \u003ccode\u003eGLOBAL\u003c/code\u003e 包中启动，因此默认情况下，主线代码中的“our”声明会进入该包。 进程范围的变量存在于 \u003ccode\u003ePROCESS\u003c/code\u003e包中。 大多数预定义的全局变量，例如 \u003ccode\u003e$*UID\u003c/code\u003e 和 \u003ccode\u003e$*PID\u003c/code\u003e 实际上是进程全局变量。\u003c/p\u003e\n\u003ch2 id=\"版本\"\u003e版本\u003c/h2\u003e\n\u003cp\u003e任何包都可以有一个 \u003ca href=\"https://docs.raku.org/type/Version\"\u003eVersion\u003c/a\u003e 对象。 这个对象可以通过 \u003ccode\u003e$PACKAGE.^ver\u003c/code\u003e 或从包 \u003ccode\u003eFully::Qualified::Name.^ver\u003c/code\u003e 外部访问。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://docs.raku.org/language/packages\"\u003ePackages\u003c/a\u003e\u003c/p\u003e\n","text":" Packages - Organizing and referencing namespaced program elements\n包是指定程序元素的嵌套命名空间。 模块，类，Grammar是包类型。 像目录中的文件一样，通常可以使用其短名称（如果它们是本地的）或使用较长的名称来消除歧义的引用具名元素。\nNames 名称是作为变量名称的合法部分的任何东西（不包括sigil符号）。 这包括：\n$foo # 简单标识符 $Foo::Bar::baz # 通过 :: 分割的组合标识符 $Foo::($bar)::baz # 执行插值的组合标识符 $42 # numeric names $! # 某些标点符号变量 :: 用于分割嵌套的包名。\n包限定名 普通的包限定名像这样:\n$Foo::Bar::baz # 包 Foo::Bar 中的 $baz 变量 有时保持sigil与变量名很清晰，所以来写这个的一个替代方式是：\nFoo::Bar::\u0026lt;$baz\u0026gt; 这在编译时解决，因为变量名是一个常量。\n如果 :: 之前的名称部分为 null，则意味着包未指定并且必须搜索。 一般来说，这意味着跟在主sigil后面的初始 :: 是对编译时已知的名字的无操作(no-op)，但 ::() 也可以用来引入插值。 另外，在没有另一个sigil的情况下，:: 可以作为它自己的sigil，表明有意使用一个尚未声明的包名。\n伪包 在名称前面保留以下伪包名称：\nMY # 当前词法作用域中的符号 (aka $?SCOPE) OUR # 当前包中的符号 (aka $?PACKAGE) CORE # 最外层词法作用域, 定义标准 Perl GLOBAL # Interpreter-wide package symbols, really UNIT::GLOBAL PROCESS # 进程相关的全局变量 (superglobals) COMPILING # 正在编译的作用域中的词法符号 以下相对名称也保留，但可以在名称中的任何位置使用：\nCALLER # Contextual symbols in the immediate caller\u0026#39;s lexical scope CALLERS # Contextual symbols in any caller\u0026#39;s lexical scope DYNAMIC # Contextual symbols in my or any caller\u0026#39;s lexical scope OUTER # Symbols in the next outer lexical scope OUTERS # Symbols in any outer lexical scope LEXICAL # Contextual symbols in my or any outer\u0026#39;s lexical scope UNIT # Symbols in the outermost lexical scope of compilation unit SETTING # Lexical symbols in the unit\u0026#39;s DSL (usually CORE) PARENT # Symbols in this package\u0026#39;s parent package (or lexical scope) CLIENT # The nearest CALLER that comes from a different package 文件的作用域称为 UNIT，但在对应于语言设置的外面有一个或多个词法作用域（其他文化中通常称为序幕）。 因此，SETTING 作用域等价于 UNIT::OUTERS。 对于标准的Perl程序，SETTING 与 CORE 相同，但是各种启动选项（如 -n 或 -p）可以使您进入特定领域语言，在这种情况下，CORE 仍然是标准语言的作用域，而 SETTING 表示定义用作当前文件的设置的DSL的作用域。 当作为名称中间的搜索项使用时，SETTING包括其所有外部作用域，直到 CORE。 要仅获取设置的最外层作用域，请改用 UNIT::OUTER。\n查找名字 插值到名字中 您可以使用 ::($expr) 将字符串插入到包或变量名中，$expr 表达式中通常放置包或变量名。 该字符串允许包含额外的 :: 实例，这将被解释为包嵌套。 您只能内插整个名称，因为结构以 :: 开头，并且立即结束或用括号之外的另一个 :: 继续。 大多数符号引用使用这种记法：\n$foo = \u0026#34;Bar\u0026#34;; $foobar = \u0026#34;Foo::Bar\u0026#34;; $::($foo) # lexically-scoped $Bar $::(\u0026#34;MY::$foo\u0026#34;) # lexically-scoped $Bar $::(\u0026#34;OUR::$foo\u0026#34;) # package-scoped $Bar $::(\u0026#34;GLOBAL::$foo\u0026#34;) # global $Bar $::(\u0026#34;PROCESS::$foo\u0026#34;)# process $Bar $::(\u0026#34;PARENT::$foo\u0026#34;) # current package\u0026#39;s parent\u0026#39;s $Bar $::($foobar) # $Foo::Bar $::($foobar)::baz # $Foo::Bar::baz $::($foo)::Bar::baz # $Bar::Bar::baz $::($foobar)baz # ILLEGAL at compile time (no operator baz) 初始 :: 不表明全局。 这里作为插值语法的一部分，它甚至不暗示包。 ::() 组件插值之后，间接名称被查找，就像它在原始源代码中一样，优先级首先指定为前导伪包名称，然后指向词法作用域中的名称（搜索 向外扩展，以CORE结束）。 最后搜索当前包。\n使用 MY 伪包将查找限制为当前词法作用域，OUR 将作用域限制为当前包作用域。\n直接查找 要在包的符号表中直接查找而不进行扫描，请将包名视为哈希：\nFoo::Bar::{\u0026#39;\u0026amp;baz\u0026#39;} # same as \u0026amp;Foo::Bar::baz PROCESS::\u0026lt;$IN\u0026gt; # Same as $*IN Foo::\u0026lt;::Bar\u0026gt;\u0026lt;::Baz\u0026gt; # same as Foo::Bar::Baz 不像 ::() 符号引用，这不解析::的参数，也不从该初始点启动命名空间扫描。 此外，对于常量下标，保证在编译时解析符号。\n空伪包是与普通名称搜索有相同的搜索列表。 也就是说，以下各项在意义上是相同的：\n$foo $::{\u0026#39;foo\u0026#39;} ::{\u0026#39;$foo\u0026#39;} $::\u0026lt;foo\u0026gt; ::\u0026lt;$foo\u0026gt; 它们中的每一个都向外扫描词法作用域，然后扫描当前的包作用域（虽然当“strict”有效时包作用域被禁止，）。\n作为这些规则的结果，您可以把变量名写的很随意：\n$::{\u0026#39;!@#$#@\u0026#39;} ::{\u0026#39;$!@#$#@\u0026#39;} 只要名字中没有空格, 您也可以使用 ::\u0026lt;\u0026gt; 形式。\n包查找 将包对象本身下标为哈希对象，其键是变量名，包括任何sigil。 包对象可以通过使用 :: 后缀从类型名中派生：\nMyType::\u0026lt;$foo\u0026gt; 全局 解释器全局变量存在于 GLOBAL 包中。 用户程序在 GLOBAL 包中启动，因此默认情况下，主线代码中的“our”声明会进入该包。 进程范围的变量存在于 PROCESS包中。 大多数预定义的全局变量，例如 $*UID 和 $*PID 实际上是进程全局变量。\n版本 任何包都可以有一个 Version 对象。 这个对象可以通过 $PACKAGE.^ver 或从包 Fully::Qualified::Name.^ver 外部访问。\nPackages\n"},"name":"包","published":"2018-11-30T21:13:31+08:00","summary":"Packages - Organizing and referencing namespaced program elements\n包是指定程序元素的嵌套命名空间。 模块，类，Grammar是包类型。 像目录中的文件一样，通常可以使用其短名称（如果它们是本地的）或使用较长的名称来消除歧义的引用具名元素。\nNames 名称是作为变量名称的合法部分的任何东西（不包括sigil符号）。 这包括：\n$foo # 简单标识符 $Foo::Bar::baz # 通过 :: 分割的组合标识符 $Foo::($bar)::baz # 执行插值的组合标识符 $42 # numeric names $! # 某些标点符号变量 :: 用于分割嵌套的包名。\n包限定名 普通的包限定名像这样:\n$Foo::Bar::baz # 包 Foo::Bar 中的 $baz 变量 有时保持sigil与变量名很清晰，所以来写这个的一个替代方式是：\nFoo::Bar::\u0026lt;$baz\u0026gt; 这在编译时解决，因为变量名是一个常量。\n如果 :: 之前的名称部分为 null，则意味着包未指定并且必须搜索。 一般来说，这意味着跟在主sigil后面的初始 :: 是对编译时已知的名字的无操作(no-op)，但 ::() 也可以用来引入插值。 另外，在没有另一个sigil的情况下，:: 可以作为它自己的sigil，表明有意使用一个尚未声明的包名。\n伪包 在名称前面保留以下伪包名称：\nMY # 当前词法作用域中的符号 (aka $?SCOPE) OUR # 当前包中的符号 (aka $?PACKAGE) CORE # 最外层词法作用域, 定义标准 Perl GLOBAL # Interpreter-wide package symbols, really UNIT::GLOBAL PROCESS # 进程相关的全局变量 (superglobals) COMPILING # 正在编译的作用域中的词法符号 以下相对名称也保留，但可以在名称中的任何位置使用：","type":"entry","url":"http://localhost:1313/rakulang/55.packages/"}