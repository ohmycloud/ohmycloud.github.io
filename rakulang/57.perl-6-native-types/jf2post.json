{"author":{"name":null,"type":"card","url":"http://localhost:1313/"},"content":{"html":"\u003cp\u003eRaku 提供了一组原生类型，在内存中具有固定且已知的表示。此页面显示了存在哪些原生类型以及如何使用它们。有关它们的更多信息，请查看有关\u003ca href=\"https://docs.raku.org/language/numerics#Native_numerics\"\u003e原生数字\u003c/a\u003e 的页面。\u003c/p\u003e\n\u003ch1 id=\"types-with-native-representationhttpsdocsrakuorglanguagenativetypes___top\"\u003e\u003ca href=\"https://docs.raku.org/language/nativetypes#___top\"\u003eTypes with native representation\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003eRaku 中的一些简单类型具有原生表示，表示它们将使用编译器，操作系统和原生提供的 C 语言表示。这些是可用的四种原生类型：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eint\u003c/th\u003e\n\u003cth\u003eEquivalent to Int (with limited range)\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003euint\u003c/td\u003e\n\u003ctd\u003eEquivalent to Int (with limited range) with the unsigned trait\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003enum\u003c/td\u003e\n\u003ctd\u003eEquivalent to Num\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003estr\u003c/td\u003e\n\u003ctd\u003eEquivalent to Str\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e但是，这些类型不一定具有 \u003ca href=\"https://docs.raku.org/language/nativecall\"\u003eNativeCall\u003c/a\u003e 接口所需的大小（例如，Raku 的 \u003ccode\u003eint\u003c/code\u003e 可以是 8 个字节，但 C 的 \u003ccode\u003eint\u003c/code\u003e 只有 4 个字节）; 必须使用以下类型而不是上面列出的 \u003ccode\u003eint\u003c/code\u003e 或 \u003ccode\u003enum\u003c/code\u003e 类型。\u003c/p\u003e\n\u003cp\u003e通常，这些变量的行为与常规标量变量的行为方式相同，称为\u003ca href=\"https://docs.raku.org/language/numerics#Auto-boxing\"\u003e\u003cem\u003e自动装箱\u003c/em\u003e\u003c/a\u003e; 然而，存在一些差异，因为您实际宣称的是如何表示它们，而不是它们的实际类型。第一个是它们的类型实际上是它们的等效类型，而不是它们的原生类型。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nv\"\u003e$intillo\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e$intillo\u003c/span\u003e\u003cspan class=\"o\"\u003e.^\u003c/span\u003e\u003cspan class=\"nb\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e# OUTPUT: «Int␤» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这显然意味着他们将智能匹配他们的等效（自动装箱）类型，而不是他们的原生类型：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"kt\"\u003estr\u003c/span\u003e \u003cspan class=\"nv\"\u003e$strillo\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003etres\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e$strillo\u003c/span\u003e \u003cspan class=\"o\"\u003e~~\u003c/span\u003e \u003cspan class=\"kt\"\u003estr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e# OUTPUT: «False␤» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e$strillo\u003c/span\u003e \u003cspan class=\"o\"\u003e~~\u003c/span\u003e \u003cspan class=\"kt\"\u003eStr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e# OUTPUT: «True␤» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e并且与非原生对应物不同，他们将始终具有默认值：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"kt\"\u003eStr\u003c/span\u003e \u003cspan class=\"nv\"\u003e$\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e# OUTPUT: «(Str)␤» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"kt\"\u003estr\u003c/span\u003e \u003cspan class=\"nv\"\u003e$\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e# OUTPUT: «␤» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"n\"\u003enum\u003c/span\u003e \u003cspan class=\"nv\"\u003e$\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e# OUTPUT: «0␤» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e注意\u003c/strong\u003e: 在 v6.c 中，\u003ccode\u003enum\u003c/code\u003e 的默认值是 NaN。\u003c/p\u003e\n\u003cp\u003e这是因为 Natives 不知道他们的类型，因为他们只是值，没有任何元数据。在\u003ca href=\"https://docs.raku.org/language/glossary#Multi-Dispatch\"\u003e多重分派\u003c/a\u003e 中，您可以拥有原生候选者，但无法区分相同原生类型的不同大小。也就是说，你可以有一个 \u003ca href=\"https://docs.raku.org/type/Int\"\u003eInt\u003c/a\u003e 和 \u003ca href=\"https://docs.raku.org/type/int\"\u003eint\u003c/a\u003e 候选者，但是 \u003ca href=\"https://docs.raku.org/type/int\"\u003eint\u003c/a\u003e, \u003ca href=\"https://docs.raku.org/type/atomicint\"\u003eatomicint\u003c/a\u003e, \u003ca href=\"https://docs.raku.org/type/int64\"\u003eint64\u003c/a\u003e 等候选者之间会有歧义。\u003c/p\u003e\n\u003cp\u003e它们也不能被绑定。尝试做 \u003ccode\u003emy num $numillo := 3.5\u003c/code\u003e 会发出异常 \u003ccode\u003eCannot bind to natively typed variable '$variable-name'; use assignment instead\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e原生类型也可以是复合的。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nv\"\u003e@intillos\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e^\u003c/span\u003e\u003cspan class=\"mi\"\u003e10_000_000\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"o\"\u003e[+]\u003c/span\u003e \u003cspan class=\"nv\"\u003e@intillos\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e# OUTPUT: «49999995000000␤» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在这种情况下，\u003cem\u003enative\u003c/em\u003eness 扩展到复合类型，它将是 \u003ccode\u003earray\u003c/code\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"n\"\u003enum\u003c/span\u003e \u003cspan class=\"nv\"\u003e@many-pi\u003c/span\u003e  \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e^\u003c/span\u003e\u003cspan class=\"mi\"\u003e8\u003c/span\u003e \u003cspan class=\"o\"\u003e»*»\u003c/span\u003e \u003cspan class=\"no\"\u003eπ\u003c/span\u003e \u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e@many-pi\u003c/span\u003e\u003cspan class=\"o\"\u003e.^\u003c/span\u003e\u003cspan class=\"nb\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# OUTPUT: «array[num]␤» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e原生\u003ccode\u003e数组\u003c/code\u003e是 \u003ca href=\"https://docs.raku.org/type/Iterable\"\u003eIterable\u003c/a\u003e，但它们不是 List 的子类。但是，它们的行为类似于 \u003ca href=\"https://docs.raku.org/type/Array\"\u003eArray\u003c/a\u003e; 例如，它们可以成形\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"kt\"\u003estr\u003c/span\u003e \u003cspan class=\"nv\"\u003e@letter-pairs\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e..\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e \u003cspan class=\"ow\"\u003eZ\u003c/span\u003e\u003cspan class=\"o\"\u003e~\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e..\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003eJ\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e@letter-pairs\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eperl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# OUTPUT: «array[str].new(:shape(10,), [\u0026#34;aA\u0026#34;, \u0026#34;bB\u0026#34;, \u0026#34;cC\u0026#34;, \u0026#34;dD\u0026#34;, \u0026#34;eE\u0026#34;, \u0026#34;fF\u0026#34;, \u0026#34;gG\u0026#34;, \u0026#34;hH\u0026#34;, \u0026#34;iI\u0026#34;, \u0026#34;jJ\u0026#34;])␤» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"types-with-native-representation-and-sizehttpsdocsrakuorglanguagenativetypes___top\"\u003e\u003ca href=\"https://docs.raku.org/language/nativetypes#___top\"\u003eTypes with native representation and size\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e关于具有原生表示的类型的提及也适用于此;它们将自动装入 Raku 类型，并且不受限制。但是，下表中列出的这些类型具有可在 NativeCall](\u003ca href=\"https://docs.raku.org/language/nativecall#Passing_and_returning_values\"\u003ehttps://docs.raku.org/language/nativecall#Passing_and_returning_values\u003c/a\u003e) 函数中使用的特性：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eint8\u003c/th\u003e\n\u003cth\u003e(int8_t in C, also used for char)\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eint16\u003c/td\u003e\n\u003ctd\u003e(int16_t in C, also used for short)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eint32\u003c/td\u003e\n\u003ctd\u003e(int32_t in C, also used for int)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eint64\u003c/td\u003e\n\u003ctd\u003e(int64_t in C)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ebyte, uint8\u003c/td\u003e\n\u003ctd\u003e(uint8_t in C, also used for unsigned char)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003euint16\u003c/td\u003e\n\u003ctd\u003e(uint16_t in C, also used for unsigned short)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003euint32\u003c/td\u003e\n\u003ctd\u003e(uint32_t in C, also used for unsigned int)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003euint64\u003c/td\u003e\n\u003ctd\u003e(uint64_t in C)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003enum32\u003c/td\u003e\n\u003ctd\u003e(float in C)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003enum64\u003c/td\u003e\n\u003ctd\u003e(double in C)\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e这些类型具有固定大小的表示，它独立于平台，因此可以安全地用于那些原生调用。如果我们愿意，没有什么能阻止我们在任何其他环境中使用它们。与上述类型相同，在为此类型的变量赋值时，必须考虑此大小：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"n\"\u003ebyte\u003c/span\u003e \u003cspan class=\"nv\"\u003e$intillo\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e257\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e$intillo\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e# OUTPUT: «1␤» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e由于 \u003ccode\u003ebyte\u003c/code\u003e 只能容纳 8 位，因此它将换行并分配模值为 256 的原始值的结果，这就是所示的内容。\u003c/p\u003e\n\u003cp\u003e声明原生大小的类型与没有声明原生大小的类型之间的主要区别是在声明中使用了 nativesize。例如，\u003ccode\u003eint8\u003c/code\u003e 以这种方式声明：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"k\"\u003enative\u003c/span\u003e \u003cspan class=\"kt\"\u003eint8\u003c/span\u003e \u003cspan class=\"k\"\u003eis\u003c/span\u003e \u003cspan class=\"k\"\u003erepr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003eP6int\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;)\u003c/span\u003e \u003cspan class=\"k\"\u003eis\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e \u003cspan class=\"k\"\u003eis\u003c/span\u003e \u003cspan class=\"nc\"\u003enativesize\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"mi\"\u003e8\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e表示除了整数表示（\u003ccode\u003eP6int\u003c/code\u003e）之外，它还将使用仅 8 位的原生大小。但是，这个特性并不打算在您的程序中使用，因为它不是 Raku 规范的一部分。\u003c/p\u003e\n\u003ch1 id=\"void-类型httpsdocsrakuorglanguagenativetypes___top\"\u003e\u003ca href=\"https://docs.raku.org/language/nativetypes#___top\"\u003e\u003ccode\u003evoid\u003c/code\u003e 类型\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e原生 \u003ccode\u003evoid\u003c/code\u003e 类型对应于 C 的 \u003ccode\u003evoid\u003c/code\u003e 类型。虽然是有效类型，但您可以在表达式中使用它\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"kt\"\u003eNativeCall\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"n\"\u003evoid\u003c/span\u003e \u003cspan class=\"nv\"\u003e$nothing\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e$nothing\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eperl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e# OUTPUT: «NativeCall::Types::void␤» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e实际上，它是一个很难单独使用的 \u003ccode\u003eUninstantiable\u003c/code\u003e 类型，实际上它在 \u003ca href=\"(https://docs.raku.org/language/nativecall#Passing_and_returning_values)\"\u003e\u003ccode\u003ereturn\u003c/code\u003e\u003c/a\u003e 类型中被明确禁止。但是，它通常在类型指针中找到，表示等效于 C 中的 \u003ccode\u003evoid *\u003c/code\u003e 指针。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003emalloc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"kt\"\u003eint32\u003c/span\u003e \u003cspan class=\"nv\"\u003e$size\u003c/span\u003e \u003cspan class=\"k\"\u003e--\u0026gt;\u003c/span\u003e \u003cspan class=\"kt\"\u003ePointer\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eis\u003c/span\u003e \u003cspan class=\"k\"\u003enative\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"kt\"\u003ePointer\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"nv\"\u003e$for-malloc\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nf\"\u003emalloc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"mi\"\u003e32\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e$for-malloc\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eperl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果您需要在使用该类型的原生函数中使用它们，您还可以将 \u003ca href=\"https://docs.raku.org/type/Blob\"\u003eBlob\u003c/a\u003e \u003ca href=\"https://docs.raku.org/routine/nativecast\"\u003enativecast\u003c/a\u003e  到此类指针上。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"kt\"\u003eNativeCall\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"kt\"\u003ePointer\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"nv\"\u003e$native\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003enativecast\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003ePointer\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e],\u003c/span\u003e \u003cspan class=\"kt\"\u003eBlob\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003enew\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x22\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x33\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e但是，除此之外，它提供的功能非常有限，因为指向 \u003ccode\u003evoid\u003c/code\u003e 的指针无法解引用：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"kt\"\u003eNativeCall\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"kt\"\u003ePointer\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"nv\"\u003e$native\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003enativecast\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003ePointer\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e],\u003c/span\u003e \u003cspan class=\"kt\"\u003eBuf\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003enew\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x22\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x33\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e$native\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ederef\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e# ERROR OUTPUT: «Internal error: unhandled target type␤» \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"atomic-typeshttpsdocsrakuorglanguagenativetypes___top\"\u003e\u003ca href=\"https://docs.raku.org/language/nativetypes#___top\"\u003e\u003cem\u003eAtomic\u003c/em\u003e types\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e在这种情况下，\u003cem\u003eatomic\u003c/em\u003e 指的是线程下的安全操作。 Raku 提供了一个类型，\u003ca href=\"https://docs.raku.org/type/atomicint\"\u003e\u003ccode\u003eatomicint\u003c/code\u003e\u003c/a\u003e 和\u003ca href=\"https://docs.raku.org/type/atomicint#Routines\"\u003e一些操作\u003c/a\u003e，它们共同保证了这一点。有关详细信息，请查看 \u003ca href=\"(https://docs.raku.org/language/numerics#Atomic_operations)\"\u003eNumerics\u003c/a\u003e 页面上的原子操作部分。\u003c/p\u003e\n\u003ch1 id=\"rakudo-specific-native-typeshttpsdocsrakuorglanguagenativetypes___top\"\u003e\u003ca href=\"https://docs.raku.org/language/nativetypes#___top\"\u003eRakudo specific native types\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e本节中描述的类型是特定于 Rakudo 的，因此不保证它们在其他实现中或在将来的版本中保持不变。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003elong\u003c/th\u003e\n\u003cth\u003e(long in C)\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003elonglong\u003c/td\u003e\n\u003ctd\u003e(longlong in C)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eulong\u003c/td\u003e\n\u003ctd\u003e(long and unsigned in C)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eulonglong\u003c/td\u003e\n\u003ctd\u003e(longlong and unsigned in C)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003esize_t\u003c/td\u003e\n\u003ctd\u003e(size_t and unsigned in C)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003essize_t\u003c/td\u003e\n\u003ctd\u003e(size_t in C)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ebool\u003c/td\u003e\n\u003ctd\u003e(bool in C)\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e您可以像在本机 C 中使用它们一样使用它们：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"kt\"\u003eNativeCall\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$just-an-array\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kt\"\u003eCArray\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eint32\u003c/span\u003e\u003cspan class=\"o\"\u003e].\u003c/span\u003e\u003cspan class=\"nb\"\u003enew\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e5\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eloop\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"kt\"\u003esize_t\u003c/span\u003e \u003cspan class=\"nv\"\u003e$i\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$i\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$just-an-array\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eelems\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$i\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e$just-an-array\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"nv\"\u003e$i\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这将打印数组的五个元素，因为它应该是你期望的。\u003c/p\u003e\n","text":"Raku 提供了一组原生类型，在内存中具有固定且已知的表示。此页面显示了存在哪些原生类型以及如何使用它们。有关它们的更多信息，请查看有关原生数字 的页面。\nTypes with native representation Raku 中的一些简单类型具有原生表示，表示它们将使用编译器，操作系统和原生提供的 C 语言表示。这些是可用的四种原生类型：\nint Equivalent to Int (with limited range) uint Equivalent to Int (with limited range) with the unsigned trait num Equivalent to Num str Equivalent to Str 但是，这些类型不一定具有 NativeCall 接口所需的大小（例如，Raku 的 int 可以是 8 个字节，但 C 的 int 只有 4 个字节）; 必须使用以下类型而不是上面列出的 int 或 num 类型。\n通常，这些变量的行为与常规标量变量的行为方式相同，称为自动装箱; 然而，存在一些差异，因为您实际宣称的是如何表示它们，而不是它们的实际类型。第一个是它们的类型实际上是它们的等效类型，而不是它们的原生类型。\nmy int $intillo = 3; say $intillo.^name; # OUTPUT: «Int␤» 这显然意味着他们将智能匹配他们的等效（自动装箱）类型，而不是他们的原生类型：\nmy str $strillo = \u0026#34;tres\u0026#34;; say $strillo ~~ str; # OUTPUT: «False␤» say $strillo ~~ Str; # OUTPUT: «True␤» 并且与非原生对应物不同，他们将始终具有默认值：\nsay (my Str $); # OUTPUT: «(Str)␤» say (my str $); # OUTPUT: «␤» say (my num $); # OUTPUT: «0␤» 注意: 在 v6.c 中，num 的默认值是 NaN。\n这是因为 Natives 不知道他们的类型，因为他们只是值，没有任何元数据。在多重分派 中，您可以拥有原生候选者，但无法区分相同原生类型的不同大小。也就是说，你可以有一个 Int 和 int 候选者，但是 int, atomicint, int64 等候选者之间会有歧义。\n它们也不能被绑定。尝试做 my num $numillo := 3.5 会发出异常 Cannot bind to natively typed variable '$variable-name'; use assignment instead。\n原生类型也可以是复合的。\nmy int @intillos = ^10_000_000; say [+] @intillos; # OUTPUT: «49999995000000␤» 在这种情况下，nativeness 扩展到复合类型，它将是 array。\nmy num @many-pi = ^8 »*» π ; say @many-pi.^name; # OUTPUT: «array[num]␤» 原生数组是 Iterable，但它们不是 List 的子类。但是，它们的行为类似于 Array; 例如，它们可以成形\nmy str @letter-pairs[10] = \u0026#39;a\u0026#39;..\u0026#39;j\u0026#39; Z~ \u0026#39;A\u0026#39;..\u0026#39;J\u0026#39;; say @letter-pairs.perl; # OUTPUT: «array[str].new(:shape(10,), [\u0026#34;aA\u0026#34;, \u0026#34;bB\u0026#34;, \u0026#34;cC\u0026#34;, \u0026#34;dD\u0026#34;, \u0026#34;eE\u0026#34;, \u0026#34;fF\u0026#34;, \u0026#34;gG\u0026#34;, \u0026#34;hH\u0026#34;, \u0026#34;iI\u0026#34;, \u0026#34;jJ\u0026#34;])␤» Types with native representation and size 关于具有原生表示的类型的提及也适用于此;它们将自动装入 Raku 类型，并且不受限制。但是，下表中列出的这些类型具有可在 NativeCall](https://docs.raku.org/language/nativecall#Passing_and_returning_values) 函数中使用的特性：\nint8 (int8_t in C, also used for char) int16 (int16_t in C, also used for short) int32 (int32_t in C, also used for int) int64 (int64_t in C) byte, uint8 (uint8_t in C, also used for unsigned char) uint16 (uint16_t in C, also used for unsigned short) uint32 (uint32_t in C, also used for unsigned int) uint64 (uint64_t in C) num32 (float in C) num64 (double in C) 这些类型具有固定大小的表示，它独立于平台，因此可以安全地用于那些原生调用。如果我们愿意，没有什么能阻止我们在任何其他环境中使用它们。与上述类型相同，在为此类型的变量赋值时，必须考虑此大小：\nmy byte $intillo = 257; say $intillo; # OUTPUT: «1␤» 由于 byte 只能容纳 8 位，因此它将换行并分配模值为 256 的原始值的结果，这就是所示的内容。\n声明原生大小的类型与没有声明原生大小的类型之间的主要区别是在声明中使用了 nativesize。例如，int8 以这种方式声明：\nmy native int8 is repr(\u0026#39;P6int\u0026#39;) is Int is nativesize( 8) { } 表示除了整数表示（P6int）之外，它还将使用仅 8 位的原生大小。但是，这个特性并不打算在您的程序中使用，因为它不是 Raku 规范的一部分。\nvoid 类型 原生 void 类型对应于 C 的 void 类型。虽然是有效类型，但您可以在表达式中使用它\nuse NativeCall; my void $nothing; say $nothing.perl; # OUTPUT: «NativeCall::Types::void␤» 实际上，它是一个很难单独使用的 Uninstantiable 类型，实际上它在 return 类型中被明确禁止。但是，它通常在类型指针中找到，表示等效于 C 中的 void * 指针。\nsub malloc( int32 $size --\u0026gt; Pointer[void] ) is native { * }; my Pointer[void] $for-malloc = malloc( 32 ); say $for-malloc.perl; 如果您需要在使用该类型的原生函数中使用它们，您还可以将 Blob nativecast 到此类指针上。\nuse NativeCall; my Pointer[void] $native = nativecast(Pointer[void], Blob.new(0x22, 0x33)); 但是，除此之外，它提供的功能非常有限，因为指向 void 的指针无法解引用：\nuse NativeCall; my Pointer[void] $native = nativecast(Pointer[void], Buf.new(0x22, 0x33)); say $native.deref; # ERROR OUTPUT: «Internal error: unhandled target type␤» Atomic types 在这种情况下，atomic 指的是线程下的安全操作。 Raku 提供了一个类型，atomicint 和一些操作，它们共同保证了这一点。有关详细信息，请查看 Numerics 页面上的原子操作部分。\nRakudo specific native types 本节中描述的类型是特定于 Rakudo 的，因此不保证它们在其他实现中或在将来的版本中保持不变。\nlong (long in C) longlong (longlong in C) ulong (long and unsigned in C) ulonglong (longlong and unsigned in C) size_t (size_t and unsigned in C) ssize_t (size_t in C) bool (bool in C) 您可以像在本机 C 中使用它们一样使用它们：\nuse NativeCall; my $just-an-array = CArray[int32].new( 1, 2, 3, 4, 5 ); loop ( my size_t $i = 0; $i \u0026lt; $just-an-array.elems; $i++ ) { say $just-an-array[$i]; } 这将打印数组的五个元素，因为它应该是你期望的。\n"},"name":"Raku 原生类型","published":"2018-12-02T21:13:31+08:00","summary":"Raku 提供了一组原生类型，在内存中具有固定且已知的表示。此页面显示了存在哪些原生类型以及如何使用它们。有关它们的更多信息，请查看有关原生数字 的页面。\nTypes with native representation Raku 中的一些简单类型具有原生表示，表示它们将使用编译器，操作系统和原生提供的 C 语言表示。这些是可用的四种原生类型：\nint Equivalent to Int (with limited range) uint Equivalent to Int (with limited range) with the unsigned trait num Equivalent to Num str Equivalent to Str 但是，这些类型不一定具有 NativeCall 接口所需的大小（例如，Raku 的 int 可以是 8 个字节，但 C 的 int 只有 4 个字节）; 必须使用以下类型而不是上面列出的 int 或 num 类型。\n通常，这些变量的行为与常规标量变量的行为方式相同，称为自动装箱; 然而，存在一些差异，因为您实际宣称的是如何表示它们，而不是它们的实际类型。第一个是它们的类型实际上是它们的等效类型，而不是它们的原生类型。\nmy int $intillo = 3; say $intillo.^name; # OUTPUT: «Int␤» 这显然意味着他们将智能匹配他们的等效（自动装箱）类型，而不是他们的原生类型：\nmy str $strillo = \u0026#34;tres\u0026#34;; say $strillo ~~ str; # OUTPUT: «False␤» say $strillo ~~ Str; # OUTPUT: «True␤» 并且与非原生对应物不同，他们将始终具有默认值：","type":"entry","url":"http://localhost:1313/rakulang/57.perl-6-native-types/"}