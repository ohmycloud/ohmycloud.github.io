<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.123.7">Hugo</generator><title type="html"><![CDATA[Rakulangs on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[Wait the light to fall]]></subtitle>
    
    
    
            <link href="http://localhost:1313/rakulang/" rel="alternate" type="text/html" title="html" />
            <link href="http://localhost:1313/rakulang/index.xml" rel="alternate" type="application/rss+xml" title="rss" />
            <link href="http://localhost:1313/rakulang/atom.xml" rel="self" type="application/atom+xml" title="atom" />
            <link href="http://localhost:1313/rakulang/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2024-03-02T15:58:50+08:00</updated>
    
    
    
    
        <id>http://localhost:1313/rakulang/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 文档翻译]]></title>
            <link href="http://localhost:1313/rakulang/2019-07-14-perldoc-translation/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/yet-another-udaf/?utm_source=atom_feed" rel="related" type="text/html" title="Spark 中的 UDAF 函数" />
                <link href="http://localhost:1313/notes/udaf/?utm_source=atom_feed" rel="related" type="text/html" title="用户自定义聚合函数" />
                <link href="http://localhost:1313/notes/google-guice/?utm_source=atom_feed" rel="related" type="text/html" title="Google Guice - 依赖注入" />
                <link href="http://localhost:1313/notes/running-raku-on-my-phone/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Termux 在手机中运行 Raku" />
                <link href="http://localhost:1313/notes/delete-all-history-commit-in-git/?utm_source=atom_feed" rel="related" type="text/html" title="删除 git 中所有历史提交" />
            
                <id>http://localhost:1313/rakulang/2019-07-14-perldoc-translation/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2019-07-14T21:13:31+08:00</published>
            <updated>2019-07-14T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="raku-文档之---语言">Raku 文档之 - 语言</h1>
<h2 id="起步">起步</h2>
<table>
<thead>
<tr>
<th style="text-align:left">number</th>
<th style="text-align:left">title</th>
<th style="text-align:left">subtitle</th>
<th style="text-align:left">progress</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/1.Brief%20introduction.md">简介</a></td>
<td style="text-align:left">使用 Raku 官方文档</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/2.Perl%206%20by%20example%20P6-101.md">通过例子学 Raku 之 P6-101</a></td>
<td style="text-align:left">Raku程序的基本介绍示例</td>
<td style="text-align:left">✓</td>
</tr>
</tbody>
</table>
<h2 id="迁移指南">迁移指南</h2>
<table>
<thead>
<tr>
<th style="text-align:left">number</th>
<th style="text-align:left">title</th>
<th style="text-align:left">subtitle</th>
<th style="text-align:left">progress</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/3.Perl%205%20to%20Perl%206%20guide%20-%20in%20a%20nutshell.md">从 Perl 5 到 Raku 指南 - 简介</a></td>
<td style="text-align:left">我怎么做我以前做的事情？ （简而言之，Raku）</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/4.Perl%205%20to%20Perl%206%20guide%20-%20overview.md">从 Perl 5 到 Raku 指南 - 概览</a></td>
<td style="text-align:left">我怎么做我以前做的事情？</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/5.Perl%205%20to%20Perl%206%20guide%20-%20functions.md">从 Perl 5 到 Raku 指南 - 函数</a></td>
<td style="text-align:left">Perl 5 到 Raku 中的内置函数</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/6.Perl%205%20to%20Perl%206%20guide%20-%20operators.md">从 Perl 5 到 Raku 指南 - 运算符</a></td>
<td style="text-align:left">Perl 5 到 Raku 中的运算符：等价物和变体</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/7.Perl%205%20to%20Perl%206%20guide%20-%20syntax.md">从 Perl 5 到 Raku 指南 - 语法</a></td>
<td style="text-align:left">Perl 5 和 Raku 之间的语法差异</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/8.Perl%205%20to%20Perl%206%20guide%20-%20special%20variables.md">从 Perl 5 到 Raku 指南 - 特殊变量</a></td>
<td style="text-align:left">Perl 5  Raku 中特殊变量的比较</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/9.Haskell%20to%20Perl%206%20-%20nutshell.md">从 Haskell 到 Raku - 简介</a></td>
<td style="text-align:left">从 Haskell 学习 Raku，简而言之：我已经知道了什么？</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/10.Javascript%20(Node.js)%20to%20Perl%206%20-%20nutshell.md">从 Javascript (Node.js) 到 Raku - 简介</a></td>
<td style="text-align:left">从 Node.js 学习 Raku，简而言之</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/11.Python%20to%20Raku%20-%20nutshell.md">从 Python 到 Raku - 简介</a></td>
<td style="text-align:left">从 Python 学习 Raku，简而言之</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/12.Ruby%20to%20Perl%206.md">从 Ruby 到 Raku</a></td>
<td style="text-align:left">从Ruby学习Raku，简而言之：我已经知道了什么？</td>
<td style="text-align:left">✓</td>
</tr>
</tbody>
</table>
<h2 id="指南">指南</h2>
<table>
<thead>
<tr>
<th style="text-align:left">number</th>
<th style="text-align:left">title</th>
<th style="text-align:left">subtitle</th>
<th style="text-align:left">progress</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/13.Classes%20and%20objects.md">类和对象</a></td>
<td style="text-align:left">关于在 Raku 中创建和使用类的教程</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/14.Command%20line%20interface.md">命令行接口</a></td>
<td style="text-align:left">在 Raku 中创建自己的 CLI</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/15.Concurrency.md">并发</a></td>
<td style="text-align:left">并发和异步编程</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/16.Core%20modules.md">核心模块</a></td>
<td style="text-align:left">可能对模块作者有用的核心模块</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/17.Doing%20math%20with%20Perl%206.md">使用 Raku 做算术</a></td>
<td style="text-align:left">不同的数学范例以及如何用这种语言实现它们</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left"><a href="https%253A%252F%252Fgithub.com%252Fohmycloud%252Frakudoc-zh%252Fblob%252Fmaster%252F18.Entering%2520unicode%2520characters.md">输入 unicode 字符</a></td>
<td style="text-align:left">编辑器和 shell 中的 unicode 字符的输入方法</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/19.Grammar%20tutorial.md">Grammar 指南</a></td>
<td style="text-align:left">Grammars 简介</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/20.Input%20and%20Output.md">输入和输出</a></td>
<td style="text-align:left">与文件相关的操作</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/21.Inter-process%20communication.md">进程间通信</a></td>
<td style="text-align:left">运行其他程序并与之通信的程序</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/22.Iterating.md">迭代</a></td>
<td style="text-align:left">可用于访问复杂数据结构中所有项的函数</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/23.Module%20development%20utilities.md">模块开发工具</a></td>
<td style="text-align:left">什么可以帮助您编写/测试/改进您的模块</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">24</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/24.Module%20packages.md">模块包</a></td>
<td style="text-align:left">创建用于代码重用的模块包</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">25</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/25.Modules.md">模块</a></td>
<td style="text-align:left">如何创建，使用和分发 Raku 模块</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">26</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/26.Creating%20operators.md">创建运算符</a></td>
<td style="text-align:left">关于如何声明运算符和创建新运算符的简短教程</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">27</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/27.Regexes%3A%20best%20practices%20and%20gotchas.md">正则表达式: 最佳实践和陷阱</a></td>
<td style="text-align:left">有关正则表达式和 grammar 的一些提示</td>
<td style="text-align:left">✓</td>
</tr>
</tbody>
</table>
<h2 id="一般参考">一般参考</h2>
<table>
<thead>
<tr>
<th style="text-align:left">number</th>
<th style="text-align:left">title</th>
<th style="text-align:left">subtitle</th>
<th style="text-align:left">progress</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">28</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/28.About%20the%20docs.md">关于文档</a></td>
<td style="text-align:left">元文档</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">29</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/29.Community.md">社区</a></td>
<td style="text-align:left">有关使用 Raku 的人员的信息</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">30</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/30.FAQ.md">FAQ</a></td>
<td style="text-align:left">关于 Raku 的常见问题</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">31</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/31.glossary.md">词汇表</a></td>
<td style="text-align:left">Raku 术语表</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">32</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/32.Perl%206%20pod.md">Raku pod</a></td>
<td style="text-align:left">一种易于使用的标记语言，用于记录 Perl 模块和程序</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">33</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/33.Pod%206%20tables.md">Pod 6 表格</a></td>
<td style="text-align:left">黄金三镖客</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">34</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/34.Terms.md">项</a></td>
<td style="text-align:left">Raku 中的项</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">35</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/35.Testing.md">测试</a></td>
<td style="text-align:left">在 Raku 中编写和运行测试</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">36</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/36.Traps%20to%20avoid.md">避免陷阱</a></td>
<td style="text-align:left">开始使用 Raku 时要避免的陷阱</td>
<td style="text-align:left">✓</td>
</tr>
</tbody>
</table>
<h2 id="基本主题">基本主题</h2>
<table>
<thead>
<tr>
<th style="text-align:left">number</th>
<th style="text-align:left">title</th>
<th style="text-align:left">subtitle</th>
<th style="text-align:left">progress</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">37</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/37.Containers.md">容器</a></td>
<td style="text-align:left">Raku 容器的低级解释</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">38</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/38.Contexts%20and%20contextualizers.md">上下文和上下文相关者</a></td>
<td style="text-align:left">什么是上下文以及如何深入它们</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">39</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/39.Control%20flow.md">控制流</a></td>
<td style="text-align:left">用于控制执行流程的语句</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">40</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/40.Data%20structures.md">数据结构</a></td>
<td style="text-align:left">Raku 如何处理数据结构以及我们对它们的期望</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">41</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/41.Date%20and%20time%20functions.md">日期和时间函数</a></td>
<td style="text-align:left">在 Raku 中处理日期和时间</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">42</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/42.Enumeration.md">枚举</a></td>
<td style="text-align:left">使用枚举类型的示例</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">43</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/43.Exceptions.md">异常</a></td>
<td style="text-align:left">在 Raku 中使用异常</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">44</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/44.Functions.md">函数</a></td>
<td style="text-align:left">Raku 中的函数和函数式编程</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">45</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/45.Grammars.md">Grammars</a></td>
<td style="text-align:left">解析和解释文本</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">46</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/46.Hashes%20and%20maps.md">散列和 map</a></td>
<td style="text-align:left">使用关联数组/字典/散列</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">47</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/47.Input%20and%20Output%20the%20definitive%20guide.md">输入和输出权威指南</a></td>
<td style="text-align:left">正确使用 Raku IO</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">48</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/48.Lists%2C%20sequences%2C%20and%20arrays.md">列表、序列和数组</a></td>
<td style="text-align:left">位置数据结构</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">49</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/49.Meta-object%20protocol%20(MOP).md">元对象协议 (MOP)</a></td>
<td style="text-align:left">内省和 Raku 对象系统</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">50</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/50.Native%20calling%20interface.md">原生调用接口</a></td>
<td style="text-align:left">调用遵循C调用约定的动态库</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">51</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/51.Newline%20handling%20in%20Perl%206.md">Raku 中的换行处理</a></td>
<td style="text-align:left">如何处理不同的换行符，以及如何更改行为</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">52</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/52.Numerics.md">数字</a></td>
<td style="text-align:left">Raku 中提供的数字类型</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">53</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/53.Object%20orientation.md">面向对象</a></td>
<td style="text-align:left">Raku 中的面向对象</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">54</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/54.Operators.md">运算符</a></td>
<td style="text-align:left">常见的 Raku 中缀，前缀，后缀等等！</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">55</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/55.Packages.md">包</a></td>
<td style="text-align:left">组织和引用命名空间的程序元素</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">56</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/56.Performance.md">性能</a></td>
<td style="text-align:left">测量和改进运行时或编译时性能</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">57</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/57.Perl%206%20native%20types.md">Raku 原生类型</a></td>
<td style="text-align:left">使用编译器和硬件可用的类型</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">58</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/58.Phasers.md">Phasers</a></td>
<td style="text-align:left">程序执行阶段和相应的 Phasers 块</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">59</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/59.Pragmas.md">指令</a></td>
<td style="text-align:left">特殊用途的特殊模块</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">60</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/60.Quoting%20constructs.md">引号结构</a></td>
<td style="text-align:left">在 Raku 中编写字符串，单词列表和正则表达式</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">61</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/61.Regexes.md">正则表达式</a></td>
<td style="text-align:left">与字符串匹配的模式</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">62</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/62.Routines.md">例程</a></td>
<td style="text-align:left">在任何类之外定义的常见 Raku 例程</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">63</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/63.Sets%2C%20bags%2C%20and%20mixes.md">集合、包和 mixes</a></td>
<td style="text-align:left">Raku 中唯一和加权对象的无序集合</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">64</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/64.Subscripts.md">下标</a></td>
<td style="text-align:left">按索引或键访问数据结构元素</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">65</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/65.Syntax.md">语法</a></td>
<td style="text-align:left">Raku 语法的一般规则</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">66</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/66.System%20interaction.md">系统交互</a></td>
<td style="text-align:left">使用底层操作系统和运行应用程序</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">67</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/67.Traits.md">Traits</a></td>
<td style="text-align:left">编译时行为规范变得简单</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">68</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/68.Type%20system.md">类型系统</a></td>
<td style="text-align:left">Raku 类型系统简介</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">69</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/69.Unicode.md">Unicode</a></td>
<td style="text-align:left">Raku 中的 Unicode 支持</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">70</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/70.Unicode%20versus%20ASCII%20symbols.md">Unicode Vs. ASCII 符号</a></td>
<td style="text-align:left">Unicode 符号及其 ASCII 等价物</td>
<td style="text-align:left">✓</td>
</tr>
<tr>
<td style="text-align:left">71</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/71.Variables.md">变量</a></td>
<td style="text-align:left">Raku 中的变量</td>
<td style="text-align:left">✓</td>
</tr>
</tbody>
</table>
<h2 id="高级主题">高级主题</h2>
<table>
<thead>
<tr>
<th style="text-align:left">number</th>
<th style="text-align:left">title</th>
<th style="text-align:left">subtitle</th>
<th style="text-align:left">progress</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">72</td>
<td style="text-align:left"><a href="https://github.com/ohmycloud/rakudoc-zh/blob/master/72.Experimental%20features.md">实验功能</a></td>
<td style="text-align:left">即将推出的新语言功能可供用户评估</td>
<td style="text-align:left">✓</td>
</tr>
</tbody>
</table>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[实验功能]]></title>
            <link href="http://localhost:1313/rakulang/72.experimental-features/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/playing-with-fibonacci-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 15/25. 在 Raku 中使用斐波那契数" />
                <link href="http://localhost:1313/notes/red%E4%B8%AD%E7%9A%84parse/?utm_source=atom_feed" rel="related" type="text/html" title="Red 中的 Parse" />
                <link href="http://localhost:1313/rakulang/71.variables/?utm_source=atom_feed" rel="related" type="text/html" title="变量" />
                <link href="http://localhost:1313/notes/a-practical-example-of-mojo-dom/?utm_source=atom_feed" rel="related" type="text/html" title="第十四天 - Mojo::DOM 实例" />
                <link href="http://localhost:1313/notes/another-solution-of-yesterday-problem/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 14/25. 昨天问题的另一个解决方案" />
            
                <id>http://localhost:1313/rakulang/72.experimental-features/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-15T21:13:31+08:00</published>
            <updated>2018-12-15T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>在 Raku 开发期间，通常可以在设计完成之前为用户提供新功能。最终，这些功能可能成为 Raku 规范的一部分。要使用这些功能，可以在程序源代码中使用  <code>experimental</code> 指令，例如，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">experimental</span> <span class="p">:</span><span class="s">macros</span><span class="p">;</span>
</span></span></code></pre></div><p>这些功能暂时是实验性的。</p>
<h2 id="pack"><strong>pack</strong></h2>
<p>Pack 是一种允许二进制序列化一般数据结构的功能，并且继承自 Perl 的<a href="http://perldoc.perl.org/functions/pack.html">pack</a>。<code>pack</code> 命令通过以包装字符串给出的特定方式打包数据结构来创建Buf，其中包含 <a href="https://docs.raku.org/type/Blob#method_unpack"><code>unpack</code></a> 描述中显示的选项。你可以通过在程序开头插入这个指令来打开它：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">experimental</span> <span class="p">:</span><span class="s">pack</span><span class="p">;</span>
</span></span></code></pre></div><p>例如，我们可以打包数字，将它们解释为十六进制（<code>H</code>），重复模式，直到没有更多的元素（<code>*</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">experimental</span> <span class="p">:</span><span class="s">pack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">pack</span><span class="p">(&#34;</span><span class="s2">H*</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">414243</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">contents</span><span class="p">;</span><span class="c1">#  OUTPUT: «(65 66 67)␤» </span>
</span></span></code></pre></div><p>有一个相应的 <code>unpack</code> 例程正好相反。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">experimental</span> <span class="p">:</span><span class="s">pack</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$buf</span><span class="o">=</span><span class="kt">Buf</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">65</span><span class="o">,</span><span class="mi">66</span><span class="o">,</span><span class="mi">67</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$buf</span><span class="o">.</span><span class="nb">unpack</span><span class="p">(&#34;</span><span class="s2">H*</span><span class="p">&#34;);</span> <span class="c1"># OUTPUT: «414243␤» </span>
</span></span></code></pre></div><p>并非所有上述符号都可以保证实现，并且路线图不包含退出该阶段的固定日期。</p>
<p>请参阅 <code>Blob</code> 页面中的 <a href="https://docs.raku.org/type/Blob#sub_pack"><code>pack</code></a> 和 <a href="https://docs.raku.org/type/Blob#method_unpack"><code>unpack</code></a> 文档。</p>
<h2 id="宏"><strong>宏</strong></h2>
<p><a href="https://en.wikipedia.org/wiki/Macro_(computer_science)">宏</a> 是代码生成例程，它们在程序执行之前在编译时生成代码。在 Raku 中，它的使用仍然是实验性的，它需要通过编译指示打开</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">experimental</span> <span class="p">:</span><span class="s">macros</span><span class="p">;</span>
</span></span></code></pre></div><p>宏处理在解析时发生。宏生成抽象语法树，将其移植到程序语法树中。 <code>quasi</code> 是执行此任务的例程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">macro</span> <span class="nf">does-nothing</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">quasi</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">does-nothing</span><span class="p">;</span> <span class="c1"># OUTPUT: «» </span>
</span></span></code></pre></div><p>宏是一种例程，因此它们可以以完全相同的方式接受参数，并且也以几乎相同的方式起作用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">macro</span> <span class="nf">is-mighty</span><span class="p">(</span> <span class="nv">$who</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">quasi</span> <span class="p">{</span> <span class="p">&#34;</span><span class="nv">$who</span><span class="s2"> is mighty!</span><span class="p">&#34;}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">is-mighty</span> <span class="p">&#34;</span><span class="s2">Freija</span><span class="p">&#34;;</span> <span class="c1"># OUTPUT: « &#34;Freija&#34; is mighty!␤» </span>
</span></span></code></pre></div><p>“几乎”说明了参数作为文字插入的事实，包括引号。请注意，我们也可以按照与例程相同的规则消除宏调用的括号。你可以使用unquoting构造  <code>{{{}}}</code>  来摆脱这种事情：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">macro</span> <span class="nf">is-mighty</span><span class="p">(</span> <span class="nv">$who</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">quasi</span> <span class="p">{</span> <span class="p">{{{</span><span class="nv">$who</span><span class="p">}}}</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> is mighty!</span><span class="p">&#34;}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">is-mighty</span> <span class="p">&#34;</span><span class="s2">Freija</span><span class="p">&#34;;</span>  <span class="c1"># OUTPUT: «Freija is mighty!␤» </span>
</span></span></code></pre></div><p>由于宏扩展是在解析时发生的，因此在使用外部变量时必须小心：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">experimental</span> <span class="p">:</span><span class="s">macros</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$called</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">macro</span> <span class="nf">called</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$called</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">quasi</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Called</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">called</span><span class="p">()</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> </span><span class="nv">$called</span><span class="s2"> times</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">called</span><span class="p">()</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> </span><span class="nv">$called</span><span class="s2"> times</span><span class="p">&#34;;</span> <span class="c1"># OUTPUT: «Called 2 times␤Called 2 times␤» </span>
</span></span></code></pre></div><p>由于宏在分析时被扩展，因此 <code>$called</code> 将是运行时启动时的结果，已打印为 <code>2</code>。 但是，使用 0 初始化 <code>$called</code> 将使此打印调用 0 次，因为在扩展宏的解析阶段之后运行初始化。</p>
<p>当需要进行复杂的计算初始化时，宏非常有用。 然而，他们仍然处于试验中，这是有充分理由的。 虽然上面显示的功能不太可能发生变化，但任何事情，甚至它们的存在，都可能在任何时候都有所改变，这取决于必需品，因此最好让它们远离生产代码。 与此同时，看看 Masak 和 <a href="https://github.com/masak/007">007</a> 的<a href="https://rakuadvent.wordpress.com/2012/12/23/day-23-macros/">这篇文章</a>，这是一种新的宏观语言，可能会显示未来的形状。</p>
<h2 id="cached"><strong>cached</strong></h2>
<p>以下指令:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">experimental</span> <span class="p">:</span><span class="s">cached</span><span class="p">;</span>
</span></span></code></pre></div><p>打开 <code>is cached</code> trait，它存储例程调用的结果，如果使用相同的参数调用，则返回相同的值。</p>
<p>它可以在涉及大量计算时使用，如本示例中使用的<a href="https://rakuadvent.wordpress.com/2018/12/25/calling-numbers-names/#more-7528">友好数字</a>，取自 2018 年 Advent 日历：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">experimental</span> <span class="p">:</span><span class="s">cached</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">aliquot-parts</span><span class="p">(</span> <span class="nv">$number</span> <span class="p">)</span> <span class="k">is</span> <span class="k">cached</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="o">^</span><span class="nv">$number</span><span class="p">)</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="nv">$number</span> <span class="nv">%%</span> <span class="o">*</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">amic</span><span class="p">&gt;(</span> <span class="nv">$m</span><span class="o">,</span> <span class="nv">$n</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$m</span> <span class="o">==</span> <span class="nf">aliquot-parts</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span><span class="o">.</span><span class="nb">sum</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$n</span> <span class="o">==</span> <span class="nf">aliquot-parts</span><span class="p">(</span><span class="nv">$m</span><span class="p">)</span><span class="o">.</span><span class="nb">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Taken from https://en.wikipedia.org/wiki/Amicable_numbers </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@numbers</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2620</span><span class="o">,</span> <span class="mi">2924</span><span class="o">,</span> <span class="mi">5020</span><span class="o">,</span> <span class="mi">5564</span><span class="o">,</span> <span class="mi">6232</span><span class="o">,</span> <span class="mi">6368</span><span class="o">,</span> <span class="mi">66928</span><span class="o">,</span> <span class="mi">66992</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Aliquot parts of </span><span class="nv">$_</span><span class="s2"> are </span><span class="p">&#34;</span><span class="o">,</span> <span class="n">aliquot-parts</span> <span class="nv">$_</span> <span class="k">for</span> <span class="nv">@numbers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@numbers</span> <span class="ow">X</span> <span class="nv">@numbers</span> <span class="k">-&gt;</span> <span class="nv">@pair</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">@pair</span><span class="s2">[0] and </span><span class="nv">@pair</span><span class="s2">[1] are </span><span class="p">&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="nv">@pair</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="n">amic</span> <span class="nv">@pair</span><span class="o">[</span><span class="mi">1</span><span class="o">]??</span><span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span><span class="o">!!</span><span class="p">&#34;</span><span class="s2">not </span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">amicable</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这段代码缓存了等分部分的计算，因此当调用 <code>amic</code> 运算符时，它只计算一次;事实上，打印这些等分部件的第一个循环将是唯一一个实际执行计算的循环。</p>
<p>有关其他信息和示例，另请参见<a href="https://docs.raku.org/routine/is%20cached">特征描述</a> 。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[变量]]></title>
            <link href="http://localhost:1313/rakulang/71.variables/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/a-practical-example-of-mojo-dom/?utm_source=atom_feed" rel="related" type="text/html" title="第十四天 - Mojo::DOM 实例" />
                <link href="http://localhost:1313/notes/another-solution-of-yesterday-problem/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 14/25. 昨天问题的另一个解决方案" />
                <link href="http://localhost:1313/notes/%E4%BD%BF%E7%94%A8-spark-hbase-connector-%E8%AF%BB%E5%8F%96-hbase/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Spark HBase Connector 读取 HBase" />
                <link href="http://localhost:1313/rakulang/70.unicode-versus-ascii-symbols/?utm_source=atom_feed" rel="related" type="text/html" title="Unicode vs. ASCII 符号" />
                <link href="http://localhost:1313/notes/taking-on-roles/?utm_source=atom_feed" rel="related" type="text/html" title="第十三天 - 承担角色" />
            
                <id>http://localhost:1313/rakulang/71.variables/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-14T21:13:31+08:00</published>
            <updated>2018-12-14T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>变量名以一个叫做魔符 sigil 的特殊字符开头, 后面跟着一个可选的第二个叫做 <code>twigil</code> 的特殊字符, 然后是一个标识符.</p>
<h2 id="sigils">Sigils</h2>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">类型约束</th>
<th style="text-align:center">默认类型</th>
<th style="text-align:center">Flattens</th>
<th style="text-align:center">Assignment</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:left">Mu (no type constraint)</td>
<td style="text-align:center">Any</td>
<td style="text-align:center">No</td>
<td style="text-align:center">item</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:left">Callable</td>
<td style="text-align:center">Callable</td>
<td style="text-align:center">No</td>
<td style="text-align:center">item</td>
</tr>
<tr>
<td style="text-align:center">@</td>
<td style="text-align:left">Positional</td>
<td style="text-align:center">Array</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">list</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:left">Associative</td>
<td style="text-align:center">Hash</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">list</td>
</tr>
</tbody>
</table>
<p>例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$square</span> <span class="o">=</span> <span class="mi">9</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@array</span>  <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>   <span class="c1"># Array variable with three elements</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%hash</span>   <span class="o">=</span> <span class="s">London</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">UK</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">Berlin</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Germany</span><span class="p">&#39;;</span>
</span></span></code></pre></div><p>默认类型可以使用 <code>is</code> 关键字设置。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">FailHash</span> <span class="k">is</span> <span class="kt">Hash</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Bool</span> <span class="nv">$!final</span> <span class="o">=</span> <span class="kt">False</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nb">AT-KEY</span> <span class="p">(</span> <span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="kt">Str:D</span> \<span class="nb">key</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nb">fail</span> <span class="ne">X::OutOfRange</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">what</span><span class="p">(&#34;</span><span class="s2">Hash key</span><span class="p">&#34;)</span><span class="o">,</span> <span class="p">:</span><span class="s">got</span><span class="p">(</span><span class="nb">key</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">range</span><span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="nb">keys</span><span class="p">))</span> <span class="k">if</span> <span class="nv">$!final</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nb">self</span><span class="o">.</span><span class="nb">EXISTS-KEY</span><span class="p">(</span><span class="nb">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nb">callsame</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">finalize</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!final</span> <span class="o">=</span> <span class="kt">True</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span> <span class="k">is</span> <span class="nc">FailHash</span> <span class="o">=</span> <span class="s">oranges</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">round</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">bananas</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">bendy</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">oranges</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT «round␤»</span>
</span></span><span class="line"><span class="cl"><span class="nv">%h</span><span class="o">.</span><span class="nf">finalize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">cherry</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT «X::OutOfRange: Hash key out of range. Is: cherry, should be in (oranges bananas)»</span>
</span></span></code></pre></div><p>不带符号的变量也是可行的, 查看 <a href="http://doc.raku.org/language/variables#Sigilless_variables">无符号变量</a>.</p>
<h2 id="项和列表赋值">项和列表赋值</h2>
<p>有两种类型的赋值, item 赋值和 list 赋值. 两者都使用 = 号操作符. 根据 = 号左边的语法来区别 = 是 item 赋值还是 list 赋值.</p>
<p>Item 赋值把等号右侧的值放到左侧的变量(容器)中.</p>
<p>例如, <a href="https://docs.raku.org/type/Array">数组</a>变量(@符号)在列表赋值时清空数组自身, 然后把等号右侧的值都放进数组自身中. 跟 Item 赋值相比, 这意味着等号左侧的变量类型始终是 Array, 不管右侧是什么类型.</p>
<p>赋值类型(item 或 list)取决于当前表达式或声明符看到的第一个上下文:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>            <span class="c1"># item assignment</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$foo</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>          <span class="c1"># 5</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@bar</span> <span class="o">=</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="p">;</span>         <span class="c1"># list assignment</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@bar</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>          <span class="c1"># Array</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@bar</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>          <span class="c1"># [7, 9]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="k">my</span> <span class="nv">$baz</span><span class="p">)</span> <span class="o">=</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">13</span><span class="p">;</span>     <span class="c1"># list assignment</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$baz</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>          <span class="c1"># Parcel</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$baz</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>          <span class="c1"># (11, 13)</span>
</span></span></code></pre></div><p>因此, 包含在列表赋值中的赋值行为依赖于表达式或包含表达式的声明符。
例如, 如果内部赋值是一个声明符(例如 my), 就使用 item 赋值, 它比逗号和列表赋值的优先级更高:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@array</span> <span class="o">=</span> <span class="k">my</span> <span class="nv">$num</span> <span class="o">=</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">str</span><span class="p">&#34;;</span>   <span class="c1"># item assignment: uses declarator</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@array</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>                <span class="c1"># [42, &#34;str&#34;] (an Array)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$num</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>                  <span class="c1"># 42 (a Num)</span>
</span></span></code></pre></div><p>类似地, 如果内部赋值是一个用于声明符初始化的表达式, 则内部表达式的上下文决定赋值的类型:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="nv">$num</span> <span class="o">=</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">str</span><span class="p">&#34;;</span>    <span class="c1"># item assignment: uses expression</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@array</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>                 <span class="c1"># [42, &#34;str&#34;] (an Array)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$num</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>                   <span class="c1"># 42 (a Num)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span> <span class="nv">@foo</span><span class="o">,</span> <span class="nv">$bar</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">@foo</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$bar</span><span class="p">)</span> <span class="o">=</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">str</span><span class="p">&#34;;</span>       <span class="c1"># list assignment: uses parens</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>                   <span class="c1"># [42, &#34;str&#34;] (an Array)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$bar</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>                   <span class="c1"># $(42, &#34;str&#34;)  (a Parcel)</span>
</span></span></code></pre></div><p>然而, 如果内部赋值既不是声明符又不是表达式, 而是更大的表达式的一部分, 更大的表达式的上下文决定赋值的类型:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span> <span class="nv">@array</span><span class="o">,</span> <span class="nv">$num</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">@array</span> <span class="o">=</span> <span class="nv">$num</span> <span class="o">=</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">str</span><span class="p">&#34;;</span>    <span class="c1"># list assignment</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@array</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>              <span class="c1"># [42, &#34;str&#34;] (an Array)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$num</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>                <span class="c1"># [42, &#34;str&#34;] (an Array)</span>
</span></span></code></pre></div><p>这是因为整个表达式是 <code>@array = $num = 42, &quot;str&quot;</code>, 而 <code>$num = 42</code> 不是单独的表达式.</p>
<p>查看<a href="https://docs.raku.org/language/operators">操作符</a>获取关于优先级的更多详情。</p>
<h2 id="无符号变量">无符号变量</h2>
<p>在 Raku 中创建不带符号的变量也是可能的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\degrees</span> <span class="o">=</span> <span class="no">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\θ</span>       <span class="o">=</span> <span class="mi">15</span> <span class="o">*</span> <span class="n">degrees</span><span class="p">;</span>
</span></span></code></pre></div><p>然而, 这些无符号变量并不创建<a href="https://docs.raku.org/language/containers">容器</a>. 那意味着上面的 <code>degrees</code> 和 <code>θ</code> 实际上直接代表 <code>Nums</code>. 为了说明, 我们定义一个无符号变量后再赋值:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">θ</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1"># Dies with the error &#34;Cannot modify an immutable Num&#34;</span>
</span></span></code></pre></div><p>无符号变量不强制上下文, 所以它们可被用于原样地传递某些东西:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">logged</span><span class="p">(</span><span class="nv">&amp;f</span><span class="o">,</span> <span class="o">|</span><span class="nb">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span><span class="p">(&#39;</span><span class="s1">Calling </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">&amp;f</span><span class="o">.</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> with arguments </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nb">args</span><span class="o">.</span><span class="nb">perl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">\result</span> <span class="o">=</span> <span class="nb">f</span><span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#  ^^^^^^^ not enforcing any context here</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span><span class="p">(</span><span class="nv">&amp;f</span><span class="o">.</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> returned </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nb">result</span><span class="o">.</span><span class="nb">perl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">|</span><span class="nb">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="twigils">Twigils</h2>
<p><code>Twigils</code> 影响变量的<code>作用域</code>。请记住 twigils 对基本的魔符插值没有影响，那就是，如果  <code>$a</code> 内插， <code>$^a</code>, <code>$*a</code>, <code>$=a</code>, <code>$?a</code>, <code>$.a</code>, 等等也会内插. 它仅仅取决于 <code>$</code>.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Twigil</th>
<th style="text-align:left">Scope</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:left">动态的</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:left">属性(类成员)</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:left">编译时变量</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:left">方法(并非真正的变量)</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:left">匹配对象索引(并非真正的变量)</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:left">自我声明的形式位置参数</td>
</tr>
<tr>
<td style="text-align:center">:</td>
<td style="text-align:left">自我声明的形式命名参数</td>
</tr>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:left">Pod 变量</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:left">子语言</td>
</tr>
</tbody>
</table>
<h2 id="-twigil">* Twigil</h2>
<p>动态变量通过 caller 查找, 不是通过外部作用域。例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$lexical</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="vg">$*dynamic1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="vg">$*dynamic2</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nf">say-all</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$lexical</span><span class="s2">, </span><span class="nv">$*dynamic1</span><span class="s2">, </span><span class="nv">$*dynamic2</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># prints 1, 10, 100</span>
</span></span><span class="line"><span class="cl">    <span class="nf">say-all</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$lexical</span>   <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="vg">$*dynamic1</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="vg">$*dynamic2</span>    <span class="o">=</span> <span class="mi">101</span><span class="p">;</span> <span class="c1"># 注意,这儿没有使用 my 来声明</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># prints 1, 11, 101</span>
</span></span><span class="line"><span class="cl">        <span class="nf">say-all</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># prints 1, 10, 101</span>
</span></span><span class="line"><span class="cl">    <span class="nf">say-all</span><span class="p">();</span>
</span></span></code></pre></div><p>第一次调用 <code>&amp;say-all</code> 时, 就像你期望的一样, 它打印 &ldquo;1, 10, 100&rdquo;。可是第二次它打印 &ldquo;1, 11, 101&rdquo;。 这是因为 <code>$lexical</code> 不是在调用者的作用域内被查找, 而是在 <code>&amp;say-all</code> 被定义的作用域里被查找的。这两个动态作用域变量在调用者的作用域内被查找, 所以值为 <code>11</code> 和 <code>101</code>。第三次调用 <code>&amp;say-all</code> 后,  <code>$*dynamic1</code> 不再是 11 了. 但是 <code>$*dynamic2</code> 仍然是 101。这源于我们在块中声明了一个新的动态变量 <code>$*dynamic1</code> 的事实并且没有像我们对待 <code>$*dynamic2</code> 那样把值赋值给旧的变量。</p>
<p>动态变量与其他变量类型在引用一个未声明的动态变量上不同的是前者不是一个编译时错误，而是运行时 <a href="https://docs.raku.org/type/Failure">failure</a>，这样一个动态变量可以在未定义时使用只要在把它用作任何其它东西的时候检查它是否定义过:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="vg">$*FOO</span> <span class="o">//</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">foo</span><span class="p">;</span> <span class="c1"># -&gt; &#39;foo&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="vg">$*FOO</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">bar</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">foo</span><span class="p">;</span> <span class="c1"># -&gt; &#39;bar&#39;</span>
</span></span></code></pre></div><h2 id="-twigil-1">! Twigil</h2>
<p>属性是变量, 存在于每个类的实例中. 通过 <code>!</code> 符号它们可以从类的里面直接被访问到:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">method</span> <span class="kt">Str</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="p">&#34;</span><span class="s2">(</span><span class="nv">$!x</span><span class="s2">, </span><span class="nv">$!y</span><span class="s2">)</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>注意属性是怎样被声明为 <code>$.x</code> 和 <code>$.y</code> 的, 但是仍然能够通过 <code>$!x</code> 和 <code>$!y</code> 访问到属性. 这是因为 在 Raku 中, 所有的属性都是<code>私有的</code>, 并且在类中能使用 <code>$!attribute-name</code> 直接访问这些属性. Raku 能自动为你生成访问方法. 关于对象、类和它们的属性和方法的详情, 请查看<a href="https://docs.raku.org/language/objects">面向对象</a>.</p>
<h2 id="-twigil-2">? Twigil</h2>
<p>编译时&quot;常量&quot;, 可通过 <code>?</code> twigil 访问. 编译器对它们很熟悉, 并且编译后不能被修改. 常用的一个例子如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$?FILE:</span><span class="s2"> </span><span class="nv">$?LINE</span><span class="p">&#34;;</span> <span class="c1"># prints &#34;hello.pl: 23&#34; if this is the 23 line of a</span>
</span></span><span class="line"><span class="cl">                      <span class="c1"># file named &#34;hello.pl&#34;.</span>
</span></span></code></pre></div><p>关于这些特殊变量的列表请查看<a href="https://docs.raku.org/language/variables#Compile-time_variables">编译时变量</a>。</p>
<p>尽管不能在运行时改变它们, 用户可以(重新)定义这种常量.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">constant</span> <span class="nv">$?TABSTOP</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1"># this causes leading tabs in a heredoc or in a POD</span>
</span></span><span class="line"><span class="cl">                        <span class="c1"># block&#39;s virtual margin to be counted as 4 spaces.</span>
</span></span></code></pre></div><h2 id="-twigil-3">. Twigil</h2>
<p><code>.</code> twigil 真的不是用于变量的. 实际上, 看下面的代码:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">method</span> <span class="kt">Str</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="p">&#34;</span><span class="s2">(</span><span class="nv">$.x</span><span class="s2">, </span><span class="nv">$.y</span><span class="s2">)</span><span class="p">&#34;</span> <span class="c1"># 注意我们这次使用 . 而不是 !</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>对 <code>self</code>(自身)调用了方法 <code>x</code> 和方法 <code>y</code>, 这是自动为你生成的, 因为在你声明你的属性的时候, 你使用的是 <code>.</code> twigil 。 注意,  子类可能会覆盖那些方法. 如果你不想这个发生, 请使用 <code>$!x</code> 和 <code>$!y</code> 代替。</p>
<p><code>.</code> twigil 只是调用了一个方法也表明下面是可能的</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">SaySomething</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">method</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">method</span> <span class="nf">b</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$.a</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">SaySomething</span><span class="o">.</span><span class="nf">b</span><span class="p">;</span> <span class="c1"># prints &#34;a&#34;</span>
</span></span></code></pre></div><p>关于对象、类和它们的属性和方法的详情, 请查看<a href="https://docs.raku.org/language/objects">面向对象</a>.</p>
<h2 id="-twigil-4">&lt; Twigil</h2>
<p><code>&lt;</code> twigil 是 <code>$/&lt;...&gt;</code> 的别名, 其中,  <code>$/</code> 是匹配变量. 关于匹配变量的更多详情请查看 <a href="https://docs.raku.org/language/variables#The_%24%2F_Variable">$/变量</a>和<a href="https://docs.raku.org/type/Match">类型匹配</a></p>
<h2 id="-twigil-5">^ Twigil</h2>
<p><code>^</code> twigil 为 block 块 或 子例程 声明了一个形式位置参数.  形如 <code>$^variable</code> 的变量是一种占位变量. 它们可用在裸代码块中来声明代码块的形式参数. 看下面代码中的块:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="o">^</span><span class="mi">4</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$^seconds</span><span class="s2"> follows </span><span class="nv">$^first</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>它打印出:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">1</span> <span class="n">follows</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="n">follows</span> <span class="mi">2</span>
</span></span></code></pre></div><p>有两个形式参数，就是 <code>$first</code> 和 <code>$second</code>.  注意, 尽管 <code>$^second</code> 在代码中出现的比 <code>$^first</code> 早,  <code>$^first</code> 依然是代码块中的第一个形式参数. 这是因为占位符变量是以 Unicode 顺序排序的.</p>
<p>子例程也能使用占位符变量, 但是只有在子例程没有显式的参数列表时才行. 这对普通的块也适用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">say-it</span>    <span class="p">{</span> <span class="nb">say</span> <span class="nv">$^a</span><span class="p">;</span> <span class="p">}</span> <span class="c1"># valid</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">say-it</span><span class="p">()</span>  <span class="p">{</span> <span class="nb">say</span> <span class="nv">$^a</span><span class="p">;</span> <span class="p">}</span> <span class="c1"># invalid</span>
</span></span><span class="line"><span class="cl">              <span class="p">{</span> <span class="nb">say</span> <span class="nv">$^a</span><span class="p">;</span> <span class="p">}</span> <span class="c1"># valid</span>
</span></span><span class="line"><span class="cl"><span class="k">-&gt;</span> <span class="nv">$x</span><span class="o">,</span> <span class="nv">$y</span><span class="o">,</span> <span class="nv">$x</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$^a</span><span class="p">;</span> <span class="p">}</span> <span class="c1"># 非法, 已经有参数列表 $x,$y,$x 了</span>
</span></span></code></pre></div><p>占位符变量语法上不能有类型限制. 也注意, 也不能使用单个大写字母的占位符变量, 如 <code>$^A</code></p>
<h2 id="-twigil-6">: Twigil</h2>
<p><code>:</code> twigil 为块或子例程声明了一个形式<strong>命名参数</strong>。使用这种形式声明的变量也是占位符变量的一种类型。因此适用于使用 <code>^</code> twigil 声明的变量的东西在这儿也适用(除了它们不是位置的以外, 因此没有使用 Unicode 顺序排序)。所以这个:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">{</span> <span class="nv">$:add</span> <span class="o">??</span> <span class="nv">$^a</span> <span class="o">+</span> <span class="nv">$^b</span> <span class="o">!!</span> <span class="nv">$^a</span> <span class="o">-</span> <span class="nv">$^b</span> <span class="p">}(</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span> <span class="p">)</span> <span class="p">:</span><span class="o">!</span><span class="s">add</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># -1</span>
</span></span></code></pre></div><p>查看 <a href="https://docs.raku.org/routine/%5E">^</a>获取关于占位符变量的更多细节。</p>
<h2 id="-twigil-7">= Twigil</h2>
<p><code>=</code> twigil 用于访问 Pod 变量。当前文件中的每个 Pod 块都能通过一个 Pod 对象访问到, 例如 <code>$=data</code>, <code>$=SYNOPSIS</code> 或 <code>=UserBlock</code>, 即：一个和想要的块同名的变量加上一个 <code>=</code> twigil。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">=begin</span><span class="sd"> </span><span class="k">Foo</span><span class="sd">
</span></span></span><span class="line"><span class="cl"><span class="sd">...
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">=end Foo</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#after that, $=Foo gives you all Foo-Pod-blocks</span>
</span></span></code></pre></div><p>您可以通过 <code>$=pod</code>访问 Pod 树，它包含所有作为分级数据结构的Pod结构。</p>
<p>请注意，所有这些 <code>$=someBlockName</code> 都支持位置和关联角色。</p>
<h2 id="-twigil-8">~ Twigil</h2>
<p>注意: Slangs（俚语）在 Rakudo 中还没有被实现。 NYI = Not Yet Implemented.</p>
<p><code>~</code> twigil 是指子语言（称为俚语）。下面是有用的：</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量名</th>
<th style="text-align:left">说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$~MAIN</td>
<td style="text-align:left">the current main language (e.g. Perl statements)</td>
</tr>
<tr>
<td style="text-align:center">$~Quote</td>
<td style="text-align:left">the current root of quoting language</td>
</tr>
<tr>
<td style="text-align:center">$~Quasi</td>
<td style="text-align:left">the current root of quasiquoting language</td>
</tr>
<tr>
<td style="text-align:center">$~Regex</td>
<td style="text-align:left">the current root of regex language</td>
</tr>
<tr>
<td style="text-align:center">$~Trans</td>
<td style="text-align:left">the current root of transliteration language</td>
</tr>
<tr>
<td style="text-align:center">$~P5Regex</td>
<td style="text-align:left">the current root of the Perl 5 regex language</td>
</tr>
</tbody>
</table>
<p>你在你当前的词法作用域中扩充这些语言。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">MONKEY-TYPING</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">augment</span> <span class="n">slang</span> <span class="kt">Regex</span> <span class="p">{</span>  <span class="c1"># derive from $~Regex and then modify $~Regex</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">backslash</span><span class="p">:</span><span class="na">std</span><span class="p">&lt;</span><span class="s">\Y</span><span class="p">&gt;</span> <span class="p">{</span><span class="sr"> YY </span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="变量声明符和作用域">变量声明符和作用域</h2>
<p>通常, 使用 <code>my</code> 关键字创建一个新的变量就足够了:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$amazing-variable</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">World</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello </span><span class="nv">$amazing-variable</span><span class="s2">!</span><span class="p">&#34;;</span> <span class="c1"># Hello World!</span>
</span></span></code></pre></div><p>然而, 有很多声明符能在 <a href="https://docs.raku.org/language/variables#Twigils">Twigils</a> 的能力之外改变作用域的细节。</p>
<table>
<thead>
<tr>
<th style="text-align:center">声明符</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">my</td>
<td style="text-align:left">作为词法作用域名字的开头</td>
</tr>
<tr>
<td style="text-align:center">our</td>
<td style="text-align:left">作为包作用域名字的开头</td>
</tr>
<tr>
<td style="text-align:center">has</td>
<td style="text-align:left">作为属性名的开头</td>
</tr>
<tr>
<td style="text-align:center">anon</td>
<td style="text-align:left">作为私有名字的开头</td>
</tr>
<tr>
<td style="text-align:center">state</td>
<td style="text-align:left">作为词法作用域但是持久名字的开头</td>
</tr>
<tr>
<td style="text-align:center">augment</td>
<td style="text-align:left">给已存在的名字添加定义</td>
</tr>
<tr>
<td style="text-align:center">supersede</td>
<td style="text-align:left">替换已存在名字的定义</td>
</tr>
</tbody>
</table>
<p>还有两个类似于声明符的前缀, 但是作用于预定义变量:</p>
<table>
<thead>
<tr>
<th style="text-align:center">前缀</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">temp</td>
<td style="text-align:left">在作用域的最后恢复变量的值</td>
</tr>
<tr>
<td style="text-align:center">let</td>
<td style="text-align:left">如果 block 成功退出就恢复变量的值</td>
</tr>
</tbody>
</table>
<h3 id="my-声明符">my 声明符</h3>
<p>使用 <code>my</code> 声明一个变量给变量一个词法作用域. 这意味着变量只在当前块中存在.例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">bar</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span> <span class="c1"># -&gt; &#34;bar&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span> <span class="c1"># !!! &#34;Variable &#39;$foo&#39; is not declared&#34;</span>
</span></span></code></pre></div><p>它抛出异常,因为只要我们在同一个作用域内 <code>$foo</code> 才被定义. 此外, 词法作用域意味着变量能在新的作用域内被临时地重新定义:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$location</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">outside</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">outer-location</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Not redefined:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$location</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">outer-location</span><span class="p">;</span> <span class="c1"># -&gt; &#34;outside&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">in-building</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$location</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">inside</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$location</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">in-building</span><span class="p">;</span>    <span class="c1"># -&gt; &#34;inside&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">outer-location</span><span class="p">;</span> <span class="c1"># -&gt; &#34;outside&#34;</span>
</span></span></code></pre></div><p>如果变量被重新定义了, 任何引用外部变量的代码会继续引用外部变量.
所以, 在这儿, <code>&amp;outer-location</code> 仍然打印外部的 <code>$location</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">new-location</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$location</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">nowhere</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">outer-location</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">new-location</span><span class="p">;</span> <span class="c1"># -&gt; &#34;outside&#34;</span>
</span></span></code></pre></div><p>为了让 <code>new-location()</code> 能打印 <code>nowwhere</code>, 需要使用 <code>*</code> <a href="https://docs.raku.org/language/variables#The_%2A_Twigil">twigil</a> 让 <code>$location</code> 变为动态变量.
对于子例程来说, <code>my</code> 是默认作用域, 所以 <code>my sub x( ) { }</code> 和 <code>sub x( ) { }</code> 是一样的.</p>
<h3 id="our-声明符">our 声明符</h3>
<p>our 跟 <code>my</code> 的作用类似, 除了把别名引入到符号表之外:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">module</span> <span class="nn">M</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">our</span> <span class="nv">$Var</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># $Var available here</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Available as $M::Var here.</span>
</span></span></code></pre></div><h3 id="声明一组变量">声明一组变量</h3>
<p>声明符 <code>my</code> 和 <code>our</code> 接收一组扩在圆括号中的变量作为参数来一次性声明多个变量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">@a</span><span class="o">,</span> <span class="nv">$s</span><span class="o">,</span> <span class="nv">%h</span><span class="p">);</span>
</span></span></code></pre></div><p>这可以和解构赋值结合使用。任何对这样一个列表的赋值会取得左侧列表中提供的元素数量并且从右侧列表中把对应的值赋值给它们。没有得到赋值的元素会根据变量的类型得到一个未定义值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="kt">Str</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Str</span> <span class="nv">$b</span><span class="o">,</span> <span class="kt">Int</span> <span class="nv">$c</span><span class="p">)</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="o">,</span> <span class="nv">$c</span><span class="o">].</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«[&#34;a&#34;, &#34;b&#34;, Int]␤»</span>
</span></span></code></pre></div><p>要把列表解构到一个单个的值中, 通过使用 <code>($var,)</code> 创建一个带有一个值的列表字面值。当使用了一个变量声明符时只在单个变量周围提供一个圆括号就足够了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span> <span class="p">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="o">=</span> <span class="nb">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«1␤»</span>
</span></span></code></pre></div><p>要跳过列表中的元素, 使用匿名状态变量 <code>$</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">$</span><span class="o">,</span><span class="nv">$a</span><span class="o">,</span><span class="nv">$</span><span class="o">,</span><span class="nv">%h</span><span class="p">)</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span> <span class="p">{:</span><span class="mi">1</span><span class="s">th</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">%h</span><span class="o">].</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«[&#34;b&#34;, {:th(1)}]␤»</span>
</span></span></code></pre></div><h3 id="has-声明符">has 声明符</h3>
<p><code>has</code> 作用在类的实例或 role 的属性上, 还有类或 roles 的方法上. has 隐式作用于方法上, 所以 <code>has method x() {}</code> 和 <code>method x() {}</code> 做得是相同的事情。</p>
<p>查看<a href="https://docs.raku.org/language/objects">面向对象</a>获取更多文档和例子。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">has</span> <span class="k">method</span> <span class="nb">x</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></div><p>等价于:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">method</span> <span class="nb">x</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></div><h3 id="anon-声明符">anon 声明符</h3>
<p><code>anon</code> 声明符阻止符号本安装在词法作用域内, 还有方法表中, 和其它任何地方.
例如, 你可以使用 <code>anon</code> 声明一个知道自己名字的子例程, 但是仍然不会被安装到作用域内:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%operations</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="s">half</span>   <span class="o">=&gt;</span> <span class="k">anon</span> <span class="k">sub</span> <span class="nf">half</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span>   <span class="p">{</span> <span class="nv">$x</span> <span class="o">/</span> <span class="mi">2</span>  <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">square</span> <span class="o">=&gt;</span> <span class="k">anon</span> <span class="k">sub</span> <span class="nf">square</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%operations</span><span class="p">&lt;</span><span class="s">square</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">name</span><span class="p">;</span>       <span class="c1"># square</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%operations</span><span class="p">&lt;</span><span class="s">square</span><span class="p">&gt;(</span><span class="mi">8</span><span class="p">);</span>         <span class="c1"># 64</span>
</span></span></code></pre></div><h3 id="state-声明符">state 声明符</h3>
<p><code>state</code> 声明词法作用域变量, 就像 my 那样。然而, <strong>初始化只发生一次</strong>, 就在正常执行流中第一次遇见初始化的时候。因此, state 变量会在闭合块或 程序的多次执行<strong>之间</strong>保留它们的值。</p>
<p>因此, 下面这个子例程:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">a</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">state</span> <span class="nv">@x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">state</span> <span class="nv">$l</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">A</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">@x</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span><span class="nv">$l</span><span class="o">++</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">a</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">6</span><span class="p">;</span>
</span></span></code></pre></div><p>会持续增加 <code>$l</code> 并在每次被调用时把它追加到 @x 中, 所以它会打印出:</p>
<pre tabindex="0"><code>[A]
[A B]
[A B C]
[A B C D]
[A B C D E]
[A B C D E F]
</code></pre><p>This works per &ldquo;clone&rdquo; of the containing code object, as in this example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">({</span> <span class="k">state</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nv">$i</span><span class="o">++.</span><span class="nb">say</span><span class="p">;</span> <span class="p">}</span> <span class="ow">xx</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span><span class="nv">$_</span><span class="p">()</span><span class="o">,</span> <span class="nv">$_</span><span class="p">()};</span> <span class="c1"># says 1 then 2 thrice</span>
</span></span></code></pre></div><p>注意，这不是一个线程安全的解构, 当同一个 block 的同一个克隆运行在多个线程中时。要知道方法只有每个类一个克隆，而不是每个对象。</p>
<p>至于 <code>my</code>，声明多个状态变量必须放置在圆括号中, 而声明一个单一变量，圆括号可以省略。</p>
<p>请注意，许多操作符都伴随着隐式绑定，什么会导致超距作用。使用 <code>.clone</code> 或强迫创建一个可以绑定的新容器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">state</span> <span class="nv">$i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">@a</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">k</span><span class="nv">$i</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="nv">$i</span> <span class="c1"># &lt;-- .clone goes here</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@a</span><span class="p">;</span> <span class="c1"># «Array $var = $[:k1(3), :k2(3), :k3(3)]»</span>
</span></span></code></pre></div><p>所有的状态变量都是线程间共享的。这个结果可能是你不希望得到的或危险的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">code</span><span class="p">(){</span> <span class="k">state</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">say</span> <span class="o">++</span><span class="nv">$i</span><span class="p">;</span> <span class="nv">$i</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">await</span>
</span></span><span class="line"><span class="cl">    <span class="k">start</span> <span class="p">{</span> <span class="k">loop</span> <span class="p">{</span> <span class="nb">last</span> <span class="k">if</span> <span class="nb">code</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="p">}</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">start</span> <span class="p">{</span> <span class="k">loop</span> <span class="p">{</span> <span class="nb">last</span> <span class="k">if</span> <span class="nb">code</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«1␤2␤3␤4␤4␤3␤5␤»</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«2␤1␤3␤4␤5␤»</span>
</span></span><span class="line"><span class="cl"><span class="c1"># many other more or less odd variations can be produced</span>
</span></span></code></pre></div><h3 id="-变量">$ 变量</h3>
<p>和显式地声明命名状态变量一样, <code>$</code> 能够用作不带显式状态声明的匿名状态变量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">1-a 2-b 3-c</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">subst</span><span class="p">(:</span><span class="s">g</span><span class="o">,</span> <span class="p">/</span><span class="se">\d</span><span class="p">/</span><span class="o">,</span> <span class="p">{&lt;</span><span class="s">one two three</span><span class="p">&gt;</span><span class="o">[</span><span class="nv">$</span><span class="o">++]</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«one-a two-b three-c␤»</span>
</span></span></code></pre></div><p>更进一步, 状态变量不需要存在于子例程中。你可以, 举个例子, 在单行程序中使用 <code>$</code> 在文件中编号行号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">raku</span> <span class="o">-</span><span class="ow">ne</span> <span class="p">&#39;</span><span class="s1">say ++$ ~ &#34; $_&#34;</span><span class="p">&#39;</span> <span class="n">example</span><span class="o">.</span><span class="nf">txt</span>
</span></span></code></pre></div><p>实际上词法范围内每个对 <code>$</code> 的引用都是是一个<strong>单独的</strong>变量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">{ say ++$; say $++  } for ^5</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«1␤0␤2␤1␤3␤2␤4␤3␤5␤4␤»</span>
</span></span></code></pre></div><p>如果在作用域内你需要多次引用 <code>$</code> 的值, 那么它应该被拷贝到一个新的变量中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">given</span> <span class="o">++</span><span class="nv">$</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">one</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">two</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="mi">3</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">three</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">many</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">()</span> <span class="k">for</span> <span class="o">^</span><span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«one␤two␤three␤»</span>
</span></span></code></pre></div><h3 id="-变量-1">@ 变量</h3>
<p>和 <code>$</code> 变量类似, 也有一个位置匿名状态变量 <code>@</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">(</span><span class="nv">@</span><span class="p">)</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span><span class="nv">$x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="o">^</span><span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [0]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [0 1]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [0 1 2]</span>
</span></span></code></pre></div><p>这里的 <code>@</code> 是用圆括号括起来了以和名为 <code>@.push</code> 的类成员变量消除歧义。索引访问并不需要这种歧义，但你需要拷贝这个值，以便用它做任何有用的事情。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$v</span> <span class="o">=</span> <span class="nv">@</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$v</span><span class="o">[</span><span class="nv">$x</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="o">^</span><span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [0]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [0 1]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [0 1 2]</span>
</span></span></code></pre></div><p>就和 <code>$</code> 一样, 作用域中的每次提及 <code>@</code> 就引入了一个新的匿名数组。</p>
<h3 id="-变量-2">% 变量</h3>
<p>最后, 还有一个关联匿名状态变量 <code>%</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">(</span><span class="nv">%</span><span class="p">)</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span><span class="nv">$x</span> <span class="o">=&gt;</span> <span class="nv">$x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="o">^</span><span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 0 =&gt; 0</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 0 =&gt; 0, 1 =&gt; 1</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 0 =&gt; 0, 1 =&gt; 1, 2 =&gt; 2</span>
</span></span></code></pre></div><p>关于歧义的同样警告适用。正如你可能期望，索引访问也有可能（使用复制以使之有用）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$v</span> <span class="o">=</span> <span class="nv">%</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$v</span><span class="p">{</span><span class="nv">$x</span><span class="p">}</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="o">^</span><span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 0 =&gt; 0</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 0 =&gt; 0, 1 =&gt; 1</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 0 =&gt; 0, 1 =&gt; 1, 2 =&gt; 2</span>
</span></span></code></pre></div><p>就像其它的匿名状态变量一样, 在给定作用域中每次提及 <code>%</code> 最终都会引入一个单独的变量。</p>
<h3 id="augment-声明符">augment 声明符</h3>
<p>使用 <code>augment</code>, 你可以给已经存在的类或 grammars 增加属性和方法.</p>
<p>因为类通常使用 our 作用域, 因此是全局的, 这意味着修改全局状态, 这是强烈不鼓励的, 对于大部分情况, 有更好的方法.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># don&#39;t do this</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">MONKEY-TYPING</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">augment</span> <span class="k">class</span> <span class="kt">Int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">is-answer</span> <span class="p">{</span> <span class="nb">self</span> <span class="o">==</span> <span class="mi">42</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">42</span><span class="o">.</span><span class="nf">is-answer</span><span class="p">;</span>       <span class="c1"># True</span>
</span></span></code></pre></div><h3 id="temp-前缀">temp 前缀</h3>
<p>像 my 一样, temp 在作用域的末尾恢复旧的变量值. 然而, temp 不创建新的变量.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1"># temp will &#34;entangle&#34; the global variable with the call stack</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># that keeps the calls at the bottom in order.</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="o">*</span><span class="nv">@c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="k">temp</span> <span class="nv">$in</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="p">&#34;</span><span class="s2">&lt;f&gt;</span><span class="se">\n</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">     <span class="o">~</span> <span class="nv">@c</span><span class="o">&gt;&gt;.</span><span class="nb">indent</span><span class="p">(</span><span class="nv">$in</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="se">\n</span><span class="p">&#34;)</span>
</span></span><span class="line"><span class="cl">     <span class="o">~</span> <span class="p">(</span><span class="o">+</span><span class="nv">@c</span> <span class="o">??</span> <span class="p">&#34;</span><span class="se">\n</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;&#34;)</span>
</span></span><span class="line"><span class="cl">     <span class="o">~</span> <span class="p">&#39;</span><span class="s1">&lt;/f&gt;</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">g</span><span class="p">(</span><span class="o">*</span><span class="nv">@c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="k">temp</span> <span class="nv">$in</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&#34;</span><span class="s2">&lt;g&gt;</span><span class="se">\n</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span> <span class="nv">@c</span><span class="o">&gt;&gt;.</span><span class="nb">indent</span><span class="p">(</span><span class="nv">$in</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="se">\n</span><span class="p">&#34;)</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span> <span class="p">(</span><span class="o">+</span><span class="nv">@c</span> <span class="o">??</span> <span class="p">&#34;</span><span class="se">\n</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;&#34;)</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span> <span class="p">&#34;</span><span class="s2">&lt;/g&gt;</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="nf">g</span><span class="p">(</span><span class="nf">g</span><span class="p">(</span><span class="nb">f</span><span class="p">(</span><span class="nf">g</span><span class="p">())</span><span class="o">,</span> <span class="nf">g</span><span class="p">()</span><span class="o">,</span> <span class="nb">f</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># &lt;g&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  &lt;g&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#   &lt;f&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#    &lt;g&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#    &lt;/g&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#   &lt;/f&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#   &lt;g&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#   &lt;/g&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#   &lt;f&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#   &lt;/f&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  &lt;/g&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># &lt;/g&gt;</span>
</span></span></code></pre></div><h3 id="let-前缀">let 前缀</h3>
<p>跟 temp 类似, 如果 block 没有成功退出则恢复之前的值。成功的退出意味着该 block 返回了一个定义过的值或一个列表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$answer</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">let</span> <span class="nv">$answer</span> <span class="o">=</span> <span class="mi">84</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">die</span> <span class="k">if</span> <span class="nb">not</span> <span class="kt">Bool</span><span class="o">.</span><span class="nb">pick</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">CATCH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">it&#39;s been reset :(</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we made it 84 sticks!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$answer</span><span class="p">;</span>
</span></span></code></pre></div><p>在上面的例子中, 如果 <code>Bool.pick</code> 返回 true, 那么答案会保持为 84, 因为那个 block 返回了一个定义了的值(say 返回 true)。
否则那个 <code>die</code> 语句会让那个 block 不成功地退出, 把答案重新设置为 42。</p>
<h2 id="类型约束和初始化">类型约束和初始化</h2>
<p>变量可以有类型约束, 约束在声明符和变量名之间:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a string</span><span class="p">&#39;;</span> <span class="c1"># throws an X::TypeCheck::Assignment error</span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: X::TypeCheck::Assignment: Type check failed in assignment to $x; expected Int but got Str (&#34;a string&#34;)</span>
</span></span></code></pre></div><p>如果一个标量有类型约束但是没有初始值, 它会使用类型约束的类型对象来初始化.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>    <span class="c1"># Int</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>  <span class="c1"># False</span>
</span></span></code></pre></div><p>没有显式类型约束的标量的类型为 Mu, 但是默认会是 Any 类型的对象.</p>
<p>带有 @ 符号的变量会被初始化为空的数组; 带有 % 符号的变量会被初始化为空的散列.</p>
<p>变量的默认值可以使用 <code>is default</code> 特性设置, 通过把 Nil 赋值给变量来重新应用默认值:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Real</span> <span class="nv">$product</span> <span class="k">is</span> <span class="k">default</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$product</span><span class="p">;</span>                       <span class="c1"># 1</span>
</span></span><span class="line"><span class="cl"><span class="nv">$produce</span> <span class="o">*=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$product</span><span class="p">;</span>                       <span class="c1"># 5</span>
</span></span><span class="line"><span class="cl"><span class="nv">$product</span> <span class="o">=</span> <span class="kt">Nil</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$product</span><span class="p">;</span>                       <span class="c1"># 1</span>
</span></span></code></pre></div><h2 id="默认的有定义的变量指令">默认的有定义的变量指令</h2>
<p>为了强制所有的变量拥有一个有定义的约束, 使用 <code>use variables :D</code> 指令。这个指令是词法作用域的并且可以使用 <code>use variables :_</code> 指令进行切换。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">variables</span> <span class="p">:</span><span class="s">D</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">$i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«===SORRY!=== Error while compiling &lt;tmp&gt;␤Variable definition of type Int:D (implicit :D by pragma) requires an initializer ...</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1"># that works</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">use</span> <span class="kt">variables</span> <span class="p">:</span><span class="s">_</span><span class="p">;</span> <span class="k">my</span> <span class="kt">Int</span> <span class="nv">$i</span><span class="p">;</span> <span class="p">}</span> <span class="c1"># 在这个 block 中关掉它</span>
</span></span></code></pre></div><p>请注意, 赋值 Nil 会把这个变量恢复为它的默认值。一个有定义的约束类型的默认值是类型名加上 <code>:D</code>(例如 <code>Int:D</code>)。That means a definedness contraint is no guarantee of definedness. 这只适用于变量初始化, 不适用于签名。</p>
<h2 id="特殊变量">特殊变量</h2>
<p><strong>Pre-defined lexical variables</strong></p>
<p>每个代码块中都有3个特别的变量:</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$_</td>
<td style="text-align:left">特殊变量</td>
</tr>
<tr>
<td style="text-align:center">$/</td>
<td style="text-align:left">正则匹配</td>
</tr>
<tr>
<td style="text-align:center">$!</td>
<td style="text-align:left">异常</td>
</tr>
</tbody>
</table>
<h3 id="_">$_</h3>
<p><code>$_</code> 是特殊变量，在没有显式标识的代码块中，它是默认参数。所以诸如 <code>for @array { ... }</code> 和 <code>given $var { ... }</code> 之类的结构会将变量绑定给 <code>$_</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$_</span> <span class="p">}</span>  <span class="c1"># sets $_ to &#39;a&#39;, &#39;b&#39; and &#39;c&#39; in turn</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$_</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;;</span>     <span class="c1"># same, even though it&#39;s not a block</span>
</span></span><span class="line"><span class="cl"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span>   <span class="p">{</span> <span class="nb">say</span> <span class="nv">$_</span> <span class="p">}</span>  <span class="c1"># sets $_ to &#39;a&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$_</span> <span class="k">given</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>       <span class="c1"># same, 尽管这不是一个块</span>
</span></span></code></pre></div><p>CATCH 块将 <code>$_</code> 设置为捕获到的异常。 <code>~~</code> 智能匹配操作符。
对 <code>$_</code> 调用一个方法可以省略特殊变量 <code>$_</code> 的名字，从而写的更短：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                   <span class="c1"># 与 $_.say 相同</span>
</span></span></code></pre></div><p><code>m/regex/</code> 和 <code>/regex/</code> 正则匹配 和 <code>s/regex/subst/</code> 替换是作用于 <code>$_</code> 上的.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Looking for strings with non-alphabetic characters...</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">&lt;</span><span class="s">ab:c d$e fgh ij*</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="k">m</span><span class="p">/&lt;</span><span class="o">!</span><span class="nf">alpha</span><span class="p">&gt;/;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">Looking</span> <span class="k">for</span> <span class="n">strings</span> <span class="k">with</span> <span class="n">non-alphabetic</span> <span class="n">characters</span><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="n">ab:c</span>
</span></span><span class="line"><span class="cl"><span class="nb">d</span><span class="nv">$e</span>
</span></span><span class="line"><span class="cl"><span class="n">ij</span><span class="o">*</span>
</span></span></code></pre></div><h3 id="heading">$/</h3>
<p><code>$/</code> 是匹配变量。它存储着最近一次<a href="https://docs.raku.org/language/regexes">正则</a>匹配的结果，通常包含 <a href="https://docs.raku.org/type/Match">Match</a> 类型的对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">abc 12</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="se">\w</span><span class="o">+</span><span class="p">/;</span>  <span class="c1"># 设置 $/ 为一个Match 对象</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$/</span><span class="o">.</span><span class="kt">Str</span><span class="p">;</span>         <span class="c1"># abc</span>
</span></span></code></pre></div><p><code>Grammar.parse</code> 方法会把调用者的 <code>$/</code> 设置为 <code>Match object</code> 的结果。看下面的代码:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">XML::Grammar</span><span class="p">;</span> <span class="c1"># panda install XML</span>
</span></span><span class="line"><span class="cl"><span class="n">XML</span><span class="o">.</span><span class="kt">Grammar</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#34;</span><span class="s2">&lt;p&gt;some text&lt;/p&gt;</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ｢&lt;p&gt;some text&lt;/p&gt;｣</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  root =&gt; ｢&lt;p&gt;some text&lt;/p&gt;｣</span>
</span></span><span class="line"><span class="cl"><span class="c1">#   name =&gt; ｢p｣</span>
</span></span><span class="line"><span class="cl"><span class="c1">#   child =&gt; ｢some text｣</span>
</span></span><span class="line"><span class="cl"><span class="c1">#    text =&gt; ｢some text｣</span>
</span></span><span class="line"><span class="cl"><span class="c1">#    textnode =&gt; ｢some text｣</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  element =&gt; ｢&lt;p&gt;some text&lt;/p&gt;｣</span>
</span></span><span class="line"><span class="cl"><span class="c1">#   name =&gt; ｢p｣</span>
</span></span><span class="line"><span class="cl"><span class="c1">#   child =&gt; ｢some text｣</span>
</span></span><span class="line"><span class="cl"><span class="c1">#    text =&gt; ｢some text｣</span>
</span></span><span class="line"><span class="cl"><span class="c1">#    textnode =&gt; ｢some text｣</span>
</span></span></code></pre></div><p>其他匹配变量是 <code>$/</code> 元素的别名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$0</span>          <span class="c1"># same as $/[0]</span>
</span></span><span class="line"><span class="cl"><span class="nv">$1</span>          <span class="c1"># same as $/[1]</span>
</span></span><span class="line"><span class="cl"><span class="nv">$&lt;named&gt;</span>    <span class="c1"># same as $/&lt;named&gt;</span>
</span></span></code></pre></div><h3 id="位置属性">位置属性</h3>
<p>如果正则中有捕获分组, <code>$/</code> 中会有位置属性. 它们由圆括号组成.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">abbbbbcdddddeffg</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> a </span><span class="p">(</span><span class="sr">b</span><span class="o">+</span><span class="p">)</span><span class="sr"> c </span><span class="p">(</span><span class="sr">d</span><span class="o">+</span><span class="sr">ef</span><span class="o">+</span><span class="p">)</span><span class="sr"> g </span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$/</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span> <span class="c1"># ｢bbbbb｣</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$/</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span> <span class="c1"># ｢dddddeff｣</span>
</span></span></code></pre></div><p>这些捕获分组也能使用 <code>$0</code>,<code>$1</code>,<code>$2</code> 等便捷形式取得:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$0</span><span class="p">;</span> <span class="c1"># ｢bbbbb｣</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$1</span><span class="p">;</span> <span class="c1"># ｢dddddeff｣</span>
</span></span></code></pre></div><p>要获取所有的位置属性, 使用 <code>$/.list</code>, <code>@$/</code>,<code>@( )</code> 中的任意一个都可以:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@</span><span class="p">()</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span> <span class="c1"># bbbbbdddddeff</span>
</span></span></code></pre></div><h3 id="命名属性">命名属性</h3>
<p>如果正则中有命名捕获分组, <code>$/</code> 可以有命名属性, 或者正则调用了另一个正则:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">I.... see?</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="nv">$&lt;punctuation&gt;</span><span class="o">=</span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="se">\w\s</span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="nv">$&lt;final-word&gt;</span><span class="sr"> </span><span class="o">=</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">punctuation</span><span class="p">&gt;;</span> <span class="c1"># ｢....｣</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">final-word</span><span class="p">&gt;;</span>  <span class="c1"># ｢see?｣</span>
</span></span></code></pre></div><p>这些命名捕获分组也能使用便捷形式的 <code>$&lt;named&gt;</code> 获取:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$&lt;punctuation&gt;</span><span class="p">;</span> <span class="c1"># ｢....｣</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$&lt;final-word&gt;</span><span class="p">;</span>  <span class="c1"># ｢see?｣</span>
</span></span></code></pre></div><p>要获取所有的命名属性, 使用 <code>$/.hash</code>,  <code>%$/</code>, <code>%()</code>中的任何一个:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%</span><span class="p">()</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>  <span class="c1"># &#34;punctuation     ....final-word  see?&#34;</span>
</span></span></code></pre></div><h3 id="-变量-3">$! 变量</h3>
<p><code>$!</code> 是错误变量. 如果 <code>try</code> block 或语句前缀捕获到异常, 那个异常就会被存储在 <code>$!</code> 中。如果没有捕获到异常, 那么 <code>$!</code> 会被设置为 Any 类型对象。
注意, <code>CATCH</code> 块不设置 <code>$!</code>。CATCH 在 block 中把 <code>$_</code> 设置为捕获到的异常。</p>
<h2 id="编译时变量">编译时变量</h2>
<table>
<thead>
<tr>
<th style="text-align:center">Compile-time Variables</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$?FILE</td>
<td style="text-align:left">所在文件</td>
</tr>
<tr>
<td style="text-align:center">$?LINE</td>
<td style="text-align:left">所在行</td>
</tr>
<tr>
<td style="text-align:center">::?CLASS</td>
<td style="text-align:left">所在类</td>
</tr>
<tr>
<td style="text-align:center">&amp;?ROUTINE</td>
<td style="text-align:left">所在子例程</td>
</tr>
<tr>
<td style="text-align:center">&amp;?BLOCK</td>
<td style="text-align:left">所在块</td>
</tr>
<tr>
<td style="text-align:center">%?LANG</td>
<td style="text-align:left">What is the current set of interwoven languages?</td>
</tr>
<tr>
<td style="text-align:center">%?RESOURCES</td>
<td style="text-align:left">The files associated with the &ldquo;Distribution&rdquo; of the current compilation unit.</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="kt">Str</span><span class="o">.</span><span class="nb">say</span> <span class="k">when</span> <span class="o">!.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">dir</span><span class="p">()</span><span class="o">&gt;&gt;.</span><span class="nv">&amp;?BLOCK</span> <span class="k">when</span> <span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">d</span> <span class="c1"># lets recurse a little!</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其它编译时变量：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Compile-time Variables</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$?PACKAGE</td>
<td style="text-align:left">所在包</td>
</tr>
<tr>
<td style="text-align:center">$?MODULE</td>
<td style="text-align:left">所在模块</td>
</tr>
<tr>
<td style="text-align:center">$?CLASS</td>
<td style="text-align:left">所在类(as variable)</td>
</tr>
<tr>
<td style="text-align:center">$?ROLE</td>
<td style="text-align:left">所在角色(as variable)</td>
</tr>
<tr>
<td style="text-align:center">$?GRAMMAR</td>
<td style="text-align:left">所在 grammar</td>
</tr>
<tr>
<td style="text-align:center">$?TABSTOP</td>
<td style="text-align:left">在 heredoc 或 虚拟边距中 tab 有多少空格</td>
</tr>
<tr>
<td style="text-align:center">$?USAGE</td>
<td style="text-align:left">从 MAIN 程序的签名中生成的使用信息</td>
</tr>
<tr>
<td style="text-align:center">$?ENC</td>
<td style="text-align:left">Str.encode/Buf.decode/various IO 方法的默认编码.</td>
</tr>
</tbody>
</table>
<h2 id="动态变量">动态变量</h2>
<table>
<thead>
<tr>
<th style="text-align:center">Dynamic Variable</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$*ARGFILES</td>
<td style="text-align:left">神奇的命令行输入句柄</td>
</tr>
<tr>
<td style="text-align:center">@*ARGS</td>
<td style="text-align:left">来自命令行的参数</td>
</tr>
<tr>
<td style="text-align:center">$*IN</td>
<td style="text-align:left">标准输入文件句柄, AKA stdin</td>
</tr>
<tr>
<td style="text-align:center">$*OUT</td>
<td style="text-align:left">标准输出文件句柄, AKA stdout</td>
</tr>
<tr>
<td style="text-align:center">$*ERR</td>
<td style="text-align:left">标准错误文件句柄, AKA stderr</td>
</tr>
<tr>
<td style="text-align:center">%*ENV</td>
<td style="text-align:left">环境变量</td>
</tr>
<tr>
<td style="text-align:center">$*REPO</td>
<td style="text-align:left">存储安装过的/加载了的模块信息的变量</td>
</tr>
<tr>
<td style="text-align:center">$*TZ</td>
<td style="text-align:left">系统的本地时区.</td>
</tr>
<tr>
<td style="text-align:center">$*CWD</td>
<td style="text-align:left">当前工作目录.</td>
</tr>
<tr>
<td style="text-align:center">$*KERNEL</td>
<td style="text-align:left">在哪个内核下运行</td>
</tr>
<tr>
<td style="text-align:center">$*DISTRO</td>
<td style="text-align:left">在哪个操作系统分发下运行</td>
</tr>
<tr>
<td style="text-align:center">$*VM</td>
<td style="text-align:left">在哪个虚拟机下运行</td>
</tr>
<tr>
<td style="text-align:center">$*PERL</td>
<td style="text-align:left">在哪个 Perl 下运行</td>
</tr>
<tr>
<td style="text-align:center">$*PID</td>
<td style="text-align:left">当前进程的进程 ID</td>
</tr>
<tr>
<td style="text-align:center">$*PROGRAM-NAME</td>
<td style="text-align:left">当前可执行程序的路径就像它通过命令行键入一样, 或 -e 如果 perl 引用了 -e 标记</td>
</tr>
<tr>
<td style="text-align:center">$*PROGRAM</td>
<td style="text-align:left">正被执行的 Perl 程序的位置( 以 IO::Path 对象的形式)</td>
</tr>
<tr>
<td style="text-align:center">$*EXECUTABLE</td>
<td style="text-align:left">当前运行的可执行 perl 的绝对路径</td>
</tr>
<tr>
<td style="text-align:center">$*EXECUTABLE-NAME</td>
<td style="text-align:left">当前运行的可执行 perl 程序的名字。(e.g. raku-p, raku-m, Niecza.exe)</td>
</tr>
<tr>
<td style="text-align:center">$*USER</td>
<td style="text-align:left">正在运行该程序的用户. 它是一个被求值为 &ldquo;username (uid)&rdquo; 的对象. 它只有在被当作字符串时才被求值为用户名, 如果被当作数字则被求值为数值化的用户 id。</td>
</tr>
<tr>
<td style="text-align:center">$*GROUP</td>
<td style="text-align:left">运行程序的用户的主要组. 它是被计算为  &ldquo;groupname (gid)&rdquo; 的对象.它只有在被当作字符串时才被求值为组名, 如果被当作数字则被求值为数值化的组 id。</td>
</tr>
<tr>
<td style="text-align:center">$*HOME</td>
<td style="text-align:left">代表当前运行程序的用户家目录的 IO::Path 对象。如果家目录不确定则为 Nil。</td>
</tr>
<tr>
<td style="text-align:center">$*SPEC</td>
<td style="text-align:left">程序运行的平台的合适的 IO::Spec 子类, 对于特定操作系统代码,使用智能匹配: say &ldquo;We are on Windows!&rdquo; if $*SPEC ~~ IO::Spec::Win32</td>
</tr>
<tr>
<td style="text-align:center">$*TMPDIR</td>
<td style="text-align:left">代表着 &ldquo;系统临时目录&rdquo; 的 IO::Path 对象</td>
</tr>
<tr>
<td style="text-align:center">$*TOLERANCE</td>
<td style="text-align:left">由 &lt;=~=&gt; 操作符使用并且任何依赖它的操作, 来决定两个值是否近似地相等, 默认为 1e-15。</td>
</tr>
<tr>
<td style="text-align:center">$*THREAD</td>
<td style="text-align:left">代表当前执行线程的 Thread 对象。</td>
</tr>
<tr>
<td style="text-align:center">$*SCHEDULER</td>
<td style="text-align:left">代表当前默认调度程序的 ThreadPoolScheduler 对象。</td>
</tr>
</tbody>
</table>
<p>注意 <code>$*SCHEDULER</code> 的用法:</p>
<p>对于当前的 Rakudo, 这个默认在方法 <code>.hyper</code> 和 <code>.race</code> 上采用最大 16 个线程。要更改线程的最大数量, 要么在运行 perl 之前设置环境变量  RAKUDO_MAX_THREADS 的值, 要么在使用 .hyper 或 .race 之前创建一个默认改变了的作用域的拷贝:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="vg">$*SCHEDULER</span> <span class="o">=</span> <span class="kt">ThreadPoolScheduler</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">max_threads</span> <span class="o">=&gt;</span> <span class="mi">64</span> <span class="p">);</span>
</span></span></code></pre></div><p>这种行为在 spec 测试中没有被测试并且还会变化。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Unicode vs. ASCII 符号]]></title>
            <link href="http://localhost:1313/rakulang/70.unicode-versus-ascii-symbols/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/taking-on-roles/?utm_source=atom_feed" rel="related" type="text/html" title="第十三天 - 承担角色" />
                <link href="http://localhost:1313/notes/how-many-days-in-the-century-match-the-condition/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 13/25. 本世纪多少天符合条件?" />
                <link href="http://localhost:1313/notes/%E4%BD%BF%E7%94%A8-phoenix-%E8%AF%BB%E5%8F%96-hbase/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Phoenix 读取 HBase" />
                <link href="http://localhost:1313/notes/using-minion-in-dancer-apps/?utm_source=atom_feed" rel="related" type="text/html" title="第十二天 - 在 Dancer 应用程序中使用 Minion" />
                <link href="http://localhost:1313/rakulang/69.unicode/?utm_source=atom_feed" rel="related" type="text/html" title="Unicode" />
            
                <id>http://localhost:1313/rakulang/70.unicode-versus-ascii-symbols/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-13T21:13:31+08:00</published>
            <updated>2018-12-13T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>可以在 Raku 中使用以下 Unicode 符号，而无需加载任何其他模块。其中一些具有可以使用 ASCII 独有字符键入的等效物。这些变体通常由比 Unicode 版本更多的字符组成，因此它们看起来更大。</p>
<p>下面参考 unicode 码点的各种属性。最终列表可以在这里找到：<a href="https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt">https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt</a>.</p>
<h1 id="字母字符httpsdocsrakuorglanguageunicode_ascii___top"><a href="https://docs.raku.org/language/unicode_ascii#___top">字母字符</a></h1>
<p>任何具有 <code>Ll</code>（字母，小写），<code>Lu</code>（字母，大写），<code>Lt</code>（字母，标题），<code>Lm</code>（字母，修饰符）或 <code>Lo</code>（字母，其他）属性的代码点都可以像任何其他字母一样使用 ASCII 范围内的字符。</p>
<h1 id="数字字符httpsdocsrakuorglanguageunicode_ascii___top"><a href="https://docs.raku.org/language/unicode_ascii#___top">数字字符</a></h1>
<p>任何具有 <code>Nd</code>（数字，十进制数字）属性的代码点都可以用作任何数字的数字。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$var</span> <span class="o">=</span> <span class="mi">１９</span><span class="p">;</span> <span class="c1"># U+FF11 U+FF19 </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$var</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1"># OUTPUT: «21␤» </span>
</span></span></code></pre></div><h1 id="数字值httpsdocsrakuorglanguageunicode_ascii___top"><a href="https://docs.raku.org/language/unicode_ascii#___top">数字值</a></h1>
<p>任何具有 <code>No</code>（Number，other）或 <code>Nl</code>（Number，letter）属性的代码点都可以单独用作数值，例如 ½ 和 ⅓。 （这些不是十进制数字，因此不能组合。）例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$var</span> <span class="o">=</span> ⅒ <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> Ⅻ<span class="p">;</span> <span class="c1"># here ⅒ is No and Rat and Ⅻ is Nl and Int </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$var</span><span class="p">;</span>            <span class="c1"># OUTPUT: «14.1␤» </span>
</span></span></code></pre></div><h1 id="空白字符httpsdocsrakuorglanguageunicode_ascii___top"><a href="https://docs.raku.org/language/unicode_ascii#___top">空白字符</a></h1>
<p>除了空格和制表符，您还可以使用具有 <code>Zs</code>（分隔符，空格），<code>Zl</code>（分隔符，行）或 <code>Zp</code>（分隔符，段落）属性的任何其他 unicode 空白字符。</p>
<h1 id="其它可接受的单代码点httpsdocsrakuorglanguageunicode_ascii___top"><a href="https://docs.raku.org/language/unicode_ascii#___top">其它可接受的单代码点</a></h1>
<p>此列表包含 Raku 中具有特殊含义的单个代码点及其 ASCII 等价物。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Symbol</th>
<th style="text-align:left">Codepoint</th>
<th style="text-align:left">ASCII</th>
<th style="text-align:left">Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">«</td>
<td style="text-align:left">U+00AB</td>
<td style="text-align:left">&laquo;</td>
<td style="text-align:left">as part of «» or .« or regex left word boundary</td>
</tr>
<tr>
<td style="text-align:left">¯</td>
<td style="text-align:left">U+00AF</td>
<td style="text-align:left">-</td>
<td style="text-align:left">(must use explicit number) as part of exponentiation (macron is an alternative way of writing a minus)</td>
</tr>
<tr>
<td style="text-align:left">²</td>
<td style="text-align:left">U+00B2</td>
<td style="text-align:left">**2</td>
<td style="text-align:left">can be combined with ⁰..⁹</td>
</tr>
<tr>
<td style="text-align:left">³</td>
<td style="text-align:left">U+00B3</td>
<td style="text-align:left">**3</td>
<td style="text-align:left">can be combined with ⁰..⁹</td>
</tr>
<tr>
<td style="text-align:left">¹</td>
<td style="text-align:left">U+00B9</td>
<td style="text-align:left">**1</td>
<td style="text-align:left">can be combined with ⁰..⁹</td>
</tr>
<tr>
<td style="text-align:left">»</td>
<td style="text-align:left">U+00BB</td>
<td style="text-align:left">&raquo;</td>
<td style="text-align:left">as part of «» or .» or regex right word boundary</td>
</tr>
<tr>
<td style="text-align:left">×</td>
<td style="text-align:left">U+00D7</td>
<td style="text-align:left">*</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">÷</td>
<td style="text-align:left">U+00F7</td>
<td style="text-align:left">/</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">π</td>
<td style="text-align:left">U+03C0</td>
<td style="text-align:left">pi</td>
<td style="text-align:left">3.14159_26535_89793_238e0</td>
</tr>
<tr>
<td style="text-align:left">τ</td>
<td style="text-align:left">U+03C4</td>
<td style="text-align:left">tau</td>
<td style="text-align:left">6.28318_53071_79586_476e0</td>
</tr>
<tr>
<td style="text-align:left">‘</td>
<td style="text-align:left">U+2018</td>
<td style="text-align:left">'</td>
<td style="text-align:left">as part of ‘’ or ’‘</td>
</tr>
<tr>
<td style="text-align:left">’</td>
<td style="text-align:left">U+2019</td>
<td style="text-align:left">'</td>
<td style="text-align:left">as part of ‘’ or ‚’ or ’‘</td>
</tr>
<tr>
<td style="text-align:left">‚</td>
<td style="text-align:left">U+201A</td>
<td style="text-align:left">'</td>
<td style="text-align:left">as part of ‚‘ or ‚’</td>
</tr>
<tr>
<td style="text-align:left">“</td>
<td style="text-align:left">U+201C</td>
<td style="text-align:left">&quot;</td>
<td style="text-align:left">as part of “” or ”“</td>
</tr>
<tr>
<td style="text-align:left">”</td>
<td style="text-align:left">U+201D</td>
<td style="text-align:left">&quot;</td>
<td style="text-align:left">as part of “” or ”“ or ””</td>
</tr>
<tr>
<td style="text-align:left">„</td>
<td style="text-align:left">U+201E</td>
<td style="text-align:left">&quot;</td>
<td style="text-align:left">as part of „“ or „”</td>
</tr>
<tr>
<td style="text-align:left">…</td>
<td style="text-align:left">U+2026</td>
<td style="text-align:left">&hellip;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⁰</td>
<td style="text-align:left">U+2070</td>
<td style="text-align:left">**0</td>
<td style="text-align:left">can be combined with ⁰..⁹</td>
</tr>
<tr>
<td style="text-align:left">⁴</td>
<td style="text-align:left">U+2074</td>
<td style="text-align:left">**4</td>
<td style="text-align:left">can be combined with ⁰..⁹</td>
</tr>
<tr>
<td style="text-align:left">⁵</td>
<td style="text-align:left">U+2075</td>
<td style="text-align:left">**5</td>
<td style="text-align:left">can be combined with ⁰..⁹</td>
</tr>
<tr>
<td style="text-align:left">⁶</td>
<td style="text-align:left">U+2076</td>
<td style="text-align:left">**6</td>
<td style="text-align:left">can be combined with ⁰..⁹</td>
</tr>
<tr>
<td style="text-align:left">⁷</td>
<td style="text-align:left">U+2077</td>
<td style="text-align:left">**7</td>
<td style="text-align:left">can be combined with ⁰..⁹</td>
</tr>
<tr>
<td style="text-align:left">⁸</td>
<td style="text-align:left">U+2078</td>
<td style="text-align:left">**8</td>
<td style="text-align:left">can be combined with ⁰..⁹</td>
</tr>
<tr>
<td style="text-align:left">⁹</td>
<td style="text-align:left">U+2079</td>
<td style="text-align:left">**9</td>
<td style="text-align:left">can be combined with ⁰..⁹</td>
</tr>
<tr>
<td style="text-align:left">⁺</td>
<td style="text-align:left">U+207A</td>
<td style="text-align:left">|</td>
<td style="text-align:left">(must use explicit number) as part of exponentiation</td>
</tr>
<tr>
<td style="text-align:left">⁻</td>
<td style="text-align:left">U+207B</td>
<td style="text-align:left">-</td>
<td style="text-align:left">(must use explicit number) as part of exponentiation</td>
</tr>
<tr>
<td style="text-align:left">∅</td>
<td style="text-align:left">U+2205</td>
<td style="text-align:left">set()</td>
<td style="text-align:left">(empty set)</td>
</tr>
<tr>
<td style="text-align:left">∈</td>
<td style="text-align:left">U+2208</td>
<td style="text-align:left">(elem)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">∉</td>
<td style="text-align:left">U+2209</td>
<td style="text-align:left">!(elem)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">∋</td>
<td style="text-align:left">U+220B</td>
<td style="text-align:left">(cont)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">∌</td>
<td style="text-align:left">U+220C</td>
<td style="text-align:left">!(cont)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">−</td>
<td style="text-align:left">U+2212</td>
<td style="text-align:left">-</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">∖</td>
<td style="text-align:left">U+2216</td>
<td style="text-align:left">(-)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">∘</td>
<td style="text-align:left">U+2218</td>
<td style="text-align:left">o</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">∞</td>
<td style="text-align:left">U+221E</td>
<td style="text-align:left">Inf</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">∩</td>
<td style="text-align:left">U+2229</td>
<td style="text-align:left">(&amp;)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">∪</td>
<td style="text-align:left">U+222A</td>
<td style="text-align:left">(|)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">≅</td>
<td style="text-align:left">U+2245</td>
<td style="text-align:left">=~=</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">≠</td>
<td style="text-align:left">U+2260</td>
<td style="text-align:left">!=</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">≤</td>
<td style="text-align:left">U+2264</td>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">≥</td>
<td style="text-align:left">U+2265</td>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊂</td>
<td style="text-align:left">U+2282</td>
<td style="text-align:left">(&lt;)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊃</td>
<td style="text-align:left">U+2283</td>
<td style="text-align:left">(&gt;)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊄</td>
<td style="text-align:left">U+2284</td>
<td style="text-align:left">!(&lt;)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊅</td>
<td style="text-align:left">U+2285</td>
<td style="text-align:left">!(&gt;)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊆</td>
<td style="text-align:left">U+2286</td>
<td style="text-align:left">(&lt;=)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊇</td>
<td style="text-align:left">U+2287</td>
<td style="text-align:left">(&gt;=)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊈</td>
<td style="text-align:left">U+2288</td>
<td style="text-align:left">!(&lt;=)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊉</td>
<td style="text-align:left">U+2289</td>
<td style="text-align:left">!(&gt;=)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊍</td>
<td style="text-align:left">U+228D</td>
<td style="text-align:left">(.)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊎</td>
<td style="text-align:left">U+228E</td>
<td style="text-align:left">(+)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊖</td>
<td style="text-align:left">U+2296</td>
<td style="text-align:left">(^)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">𝑒</td>
<td style="text-align:left">U+1D452</td>
<td style="text-align:left">e</td>
<td style="text-align:left">2.71828_18284_59045_235e0</td>
</tr>
<tr>
<td style="text-align:left">｢</td>
<td style="text-align:left">U+FF62</td>
<td style="text-align:left">Q//</td>
<td style="text-align:left">as part of ｢｣ (Note: Q// variant cannot be used bare in regexes)</td>
</tr>
<tr>
<td style="text-align:left">｣</td>
<td style="text-align:left">U+FF63</td>
<td style="text-align:left">Q//</td>
<td style="text-align:left">as part of ｢｣ (Note: Q// variant cannot be used bare in regexes)</td>
</tr>
</tbody>
</table>
<h2 id="原子运算符httpsdocsrakuorglanguageunicode_ascii___top"><a href="https://docs.raku.org/language/unicode_ascii#___top">原子运算符</a></h2>
<p>原子运算符将 <code>U+269B</code> ⚛ ATOM SYMBOL 合并到其中。它们的 ASCII 等价物是普通的子程序，而不是运算符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">atomicint</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span>⚛<span class="o">++</span><span class="p">;</span>                <span class="c1"># Unicode version </span>
</span></span><span class="line"><span class="cl"><span class="nb">atomic-fetch-inc</span><span class="p">(</span><span class="nv">$x</span><span class="p">);</span> <span class="c1"># ASCII version </span>
</span></span></code></pre></div><p>ASCII 替代方案如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Symbol</th>
<th style="text-align:left">ASCII</th>
<th style="text-align:left">Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">⚛=</td>
<td style="text-align:left">atomic-assign</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⚛</td>
<td style="text-align:left">atomic-fetch</td>
<td style="text-align:left">this is the prefix:&lt;⚛&gt; operator</td>
</tr>
<tr>
<td style="text-align:left">⚛+=</td>
<td style="text-align:left">atomic-add-fetch</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⚛-=</td>
<td style="text-align:left">atomic-sub-fetch</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⚛−=</td>
<td style="text-align:left">atomic-sub-fetch</td>
<td style="text-align:left">this operator uses U+2212 minus sign</td>
</tr>
<tr>
<td style="text-align:left">++⚛</td>
<td style="text-align:left">atomic-inc-fetch</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⚛++</td>
<td style="text-align:left">atomic-fetch-inc</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">&ndash;⚛</td>
<td style="text-align:left">atomic-dec-fetch</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⚛&ndash;</td>
<td style="text-align:left">atomic-fetch-dec</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h1 id="多代码点httpsdocsrakuorglanguageunicode_ascii___top"><a href="https://docs.raku.org/language/unicode_ascii#___top">多代码点</a></h1>
<p>此列表包含多个代码点运算符，这些运算符需要对其 ASCII 等价物项进行特殊组合。请注意，代码点以空格分隔显示，但在使用时应作为相邻代码点输入。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Symbol</th>
<th style="text-align:left">Codepoints</th>
<th style="text-align:left">ASCII</th>
<th style="text-align:left">Since</th>
<th style="text-align:left">Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">»=»</td>
<td style="text-align:left">U+00BB = U+00BB</td>
<td style="text-align:left">&raquo;[=]&raquo;</td>
<td style="text-align:left">v6.c</td>
<td style="text-align:left">uses ASCII &lsquo;=&rsquo;</td>
</tr>
<tr>
<td style="text-align:left">«=«</td>
<td style="text-align:left">U+00AB = U+00AB</td>
<td style="text-align:left">&laquo;[=]&laquo;</td>
<td style="text-align:left">v6.c</td>
<td style="text-align:left">uses ASCII &lsquo;=&rsquo;</td>
</tr>
<tr>
<td style="text-align:left">«=»</td>
<td style="text-align:left">U+00AB = U+00BB</td>
<td style="text-align:left">&laquo;[=]&raquo;</td>
<td style="text-align:left">v6.c</td>
<td style="text-align:left">uses ASCII &lsquo;=&rsquo;</td>
</tr>
<tr>
<td style="text-align:left">»=«</td>
<td style="text-align:left">U+00BB = U+00AB</td>
<td style="text-align:left">&raquo;[=]&laquo;</td>
<td style="text-align:left">v6.c</td>
<td style="text-align:left">uses ASCII &lsquo;=&rsquo;</td>
</tr>
</tbody>
</table>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Unicode]]></title>
            <link href="http://localhost:1313/rakulang/69.unicode/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/68.type-system/?utm_source=atom_feed" rel="related" type="text/html" title="类型系统" />
                <link href="http://localhost:1313/notes/five-spark-sql-helper-utility-functions-to-extract-and-explore-complex-data-types/?utm_source=atom_feed" rel="related" type="text/html" title="五个用于提取和探索复杂数据类型的 Spark SQL Helper 实用程序函数" />
                <link href="http://localhost:1313/notes/whats-behind-0-dot-1-plus-0-dot2-in-perl6/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 12/25. 在 Raku 中, 0.1 &#43; 0.2 背后的东西" />
                <link href="http://localhost:1313/notes/who-watches-the-minions/?utm_source=atom_feed" rel="related" type="text/html" title="第十一天 - 谁在看着 Minions" />
                <link href="http://localhost:1313/notes/%E4%BD%BF%E7%94%A8-hbase-%E7%9A%84-filterlist-%E8%BF%87%E6%BB%A4%E5%99%A8/?utm_source=atom_feed" rel="related" type="text/html" title="使用 HBase 的 FilterList 过滤器" />
            
                <id>http://localhost:1313/rakulang/69.unicode/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-12T21:13:31+08:00</published>
            <updated>2018-12-12T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>Raku 对 Unicode 有很高的支持。本文档旨在概述和描述不属于例程和方法文档的 Unicode 功能。</p>
<p>有关 MoarVM 内部字符串表示的概述，请参阅 <a href="https://github.com/MoarVM/MoarVM/blob/master/docs/strings.asciidoc">MoarVM 字符串文档</a>。</p>
<h1 id="文件句柄和输入输出httpsdocsrakuorglanguageunicode___top"><a href="https://docs.raku.org/language/unicode#___top">文件句柄和输入输出</a></h1>
<h2 id="标准化httpsdocsrakuorglanguageunicode___top"><a href="https://docs.raku.org/language/unicode#___top">标准化</a></h2>
<p>默认情况下，Raku 对所有输入和输出应用标准化，但存储为 <a href="(https://docs.raku.org/language/unicode#UTF8-C8)">UTF8-C8</a> 的文件名除外;字形是用户可见的字符形式，将使用标准化表示。这是什么意思？例如，字形数字 <code>á</code> 可以用两种方式表示，或者使用一个代码点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">á</span> <span class="p">(</span><span class="n">U</span><span class="o">+</span><span class="n">E1</span> <span class="p">&#34;</span><span class="s2">LATIN SMALL LETTER A WITH ACUTE</span><span class="p">&#34;)</span>
</span></span></code></pre></div><p>或两个代码点:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">a</span> <span class="o">+</span>  <span class="n">́</span> <span class="p">(</span><span class="n">U</span><span class="o">+</span><span class="mi">61</span> <span class="p">&#34;</span><span class="s2">LATIN SMALL LETTER A</span><span class="p">&#34;</span> <span class="o">+</span> <span class="n">U</span><span class="o">+</span><span class="mi">301</span> <span class="p">&#34;</span><span class="s2">COMBINING ACUTE ACCENT</span><span class="p">&#34;)</span>
</span></span></code></pre></div><p>Raku 将这两个输入转换为一个代码点，如规范化形式 C（NFC）所指定的那样。在大多数情况下，这很有用，意味着两个相同的输入都被视为相同。 Unicode 具有规范等价的概念，它允许我们确定字符串的规范形式，允许我们正确地比较字符串并操纵它们，而不必担心文本丢失这些属性。默认情况下，您处理或从 Raku 输出的任何文本都将采用此“规范”形式，即使在对字符串进行修改或连接时也是如此（请参阅下文，了解如何避免这种情况）。有关规范化表单C和规范等效性的更多详细信息，请参阅Unicode Foundation 的<a href="https://unicode.org/reports/tr15/#Canon_Compat_Equivalence">规范化和规范等效性</a>页面。</p>
<p>我们不默认的一种情况是文件名。这是因为必须完全访问文件的名称，就像在磁盘上写入字节一样。</p>
<p>为避免规范化，您可以使用名为 <a href="https://docs.raku.org/language/unicode#UTF8-C8">UTF8-C8</a> 的特殊编码格式。将此编码与任何文件句柄一起使用将允许您读取磁盘上的确切字节，而不进行规范化。如果使用 UTF8 句柄打印出来，打印出来时看起来会很滑稽。如果将其打印到输出编码为 <a href="https://docs.raku.org/language/unicode#UTF8-C8">UTF8-C8</a> 的句柄，则它将按照您通常的预期进行渲染，并且是字节精确复制的字节。有关 MoarVM 上 UTF8-C8 的更多技术细节, 请参见下文。</p>
<h2 id="utf8-c8httpsdocsrakuorglanguageunicode___top"><a href="https://docs.raku.org/language/unicode#___top">UTF8-C8</a></h2>
<p>UTF-8 Clean-8 是一种编码器/解码器，主要用作 UTF-8。但是，遇到一个不能解码为有效 UTF-8 的字节序列，或者由于规范化而不会往返的字节序列时，它将使用 <a href="(https://docs.raku.org/language/glossary#NFG)">NFG</a> 合成来跟踪所涉及的原始字节。这意味着编码回 UTF-8 Clean-8 将能够重新创建它们最初存在的字节。合成物包含4个代码点：</p>
<ul>
<li>代码点 0x10FFFD (这是一个私用的代码点)</li>
<li>代码点 &lsquo;x&rsquo;</li>
<li>高4位作为十六进制字符的不可解码字节 (0..9A..F)</li>
<li>低4位作为十进制字符的不可解码字节 (0..9A..F)</li>
</ul>
<p>在正常的 UTF-8 编码下，这意味着不可代表的字符会像 <code>?xFF</code> 那样出现。</p>
<p>UTF-8 Clean-8 用于 MoarVM 从环境，命令行参数和文件系统查询接收字符串的地方，例如解码缓冲区时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="kt">Buf</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nb">ord</span><span class="p">(&#39;</span><span class="s1">A</span><span class="p">&#39;)</span><span class="o">,</span> <span class="mh">0xFE</span><span class="o">,</span> <span class="nb">ord</span><span class="p">(&#39;</span><span class="s1">Z</span><span class="p">&#39;))</span><span class="o">.</span><span class="nb">decode</span><span class="p">(&#39;</span><span class="s1">utf8-c8</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  OUTPUT: «A􏿽xFEZ␤» </span>
</span></span></code></pre></div><p>您可以看到 UTF8-C8 使用的两个初始代码点如何显示在此处，就在“FE”之前。您可以使用此类编码来读取具有未知编码的文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$test-file</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">/tmp/test</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">given</span> <span class="nb">open</span><span class="p">(</span><span class="nv">$test-file</span><span class="o">,</span> <span class="p">:</span><span class="s">w</span><span class="o">,</span> <span class="p">:</span><span class="s">bin</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="nb">write</span><span class="o">:</span> <span class="kt">Buf</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nb">ord</span><span class="p">(&#39;</span><span class="s1">A</span><span class="p">&#39;)</span><span class="o">,</span> <span class="mh">0xFA</span><span class="o">,</span> <span class="nb">ord</span><span class="p">(&#39;</span><span class="s1">B</span><span class="p">&#39;)</span><span class="o">,</span> <span class="mh">0xFB</span><span class="o">,</span> <span class="mh">0xFC</span><span class="o">,</span> <span class="nb">ord</span><span class="p">(&#39;</span><span class="s1">C</span><span class="p">&#39;)</span><span class="o">,</span> <span class="mh">0xFD</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">slurp</span><span class="p">(</span><span class="nv">$test-file</span><span class="o">,</span> <span class="s">enc</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">utf8-c8</span><span class="p">&#39;);</span> <span class="c1"># OUTPUT: «(65 250 66 251 252 67 253)» </span>
</span></span></code></pre></div><p>使用这种类型的编码进行读取并将它们编码回 UTF8-C8 将返回原始字节;使用默认的 UTF8-C8 是不可能的。</p>
<p>请注意，到目前为止，这种编码在 Rakudo 的 JVM 实现中不受支持。</p>
<h1 id="输入-unicode-代码点和代码点序列httpsdocsrakuorglanguageunicode___top"><a href="https://docs.raku.org/language/unicode#___top">输入 unicode 代码点和代码点序列</a></h1>
<p>您可以按编号（十进制和十六进制）输入 Unicode 代码点。例如，名为“带有macron的拉丁大写字母ae”的字符具有十进制代码点482和十六进制代码点0x1E2：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">482</span><span class="p">]&#34;;</span> <span class="c1"># OUTPUT: «Ǣ␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\x</span><span class="mh">1E2</span><span class="p">&#34;;</span>   <span class="c1"># OUTPUT: «Ǣ␤» </span>
</span></span></code></pre></div><p>您还可以按名称访问 Unicode 代码点：Rakudo 支持所有 Unicode 9.0 名称。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">PENGUIN</span><span class="p">]&#34;;</span> <span class="c1"># OUTPUT: «🐧␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">BELL</span><span class="p">]&#34;;</span>    <span class="c1"># OUTPUT: «🔔␤» (U+1F514 BELL) </span>
</span></span></code></pre></div><p>所有 Unicode 代码点名称/命名seq /emoji 序列现在都不区分大小写：[从2017.02开始]</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">latin capital letter ae with macron</span><span class="p">]&#34;;</span> <span class="c1"># OUTPUT: «Ǣ␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">latin capital letter E</span><span class="p">]&#34;;</span>              <span class="c1"># OUTPUT: «E␤» (U+0045) </span>
</span></span></code></pre></div><p>您可以使用带有 <code>\c[]</code> 的逗号分隔列表来指定多个字符。 您也可以组合数字和命名样式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">482,PENGUIN</span><span class="p">]&#34;;</span> <span class="c1"># OUTPUT: «Ǣ🐧␤» </span>
</span></span></code></pre></div><p>除了在内插字符串中使用 <code>\c[]</code> 之外，您还可以使用 <a href="https://docs.raku.org/routine/uniparse">uniparse</a>:：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">DIGIT ONE</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">uniparse</span><span class="p">;</span>  <span class="c1"># OUTPUT: «1␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">uniparse</span><span class="p">(&#34;</span><span class="s2">DIGIT ONE</span><span class="p">&#34;);</span> <span class="c1"># OUTPUT: «1␤» </span>
</span></span></code></pre></div><h2 id="名称别名httpsdocsrakuorglanguageunicode___top"><a href="https://docs.raku.org/language/unicode#___top">名称别名</a></h2>
<p>按名称别名。名称别名主要用于没有正式名称的代码点，缩写或更正（Unicode 名称永远不会更改）。有关它们的完整列表，请参见<a href="https://www.unicode.org/Public/UCD/latest/ucd/NameAliases.txt">此处</a>。</p>
<p>没有任何官方名称的控制代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">ALERT</span><span class="p">]&#34;;</span>     <span class="c1"># Not visible (U+0007 control code (also accessible as \a)) </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">LINE FEED</span><span class="p">]&#34;;</span> <span class="c1"># Not visible (U+000A same as &#34;\n&#34;) </span>
</span></span></code></pre></div><p>更正:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">LATIN CAPITAL LETTER GHA</span><span class="p">]&#34;;</span> <span class="c1"># OUTPUT: «Ƣ␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Ƣ</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">uniname</span><span class="p">;</span> <span class="c1"># OUTPUT: «LATIN CAPITAL LETTER OI␤» </span>
</span></span><span class="line"><span class="cl"><span class="c1"># This one is a spelling mistake that was corrected in a Name Alias: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">PRESENTATION FORM FOR VERTICAL RIGHT WHITE LENTICULAR BRACKET</span><span class="p">]&#34;</span><span class="o">.</span><span class="nb">uniname</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «PRESENTATION FORM FOR VERTICAL RIGHT WHITE LENTICULAR BRAKCET␤» </span>
</span></span></code></pre></div><p>缩写:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">ZWJ</span><span class="p">]&#34;</span><span class="o">.</span><span class="nb">uniname</span><span class="p">;</span>  <span class="c1"># OUTPUT: «ZERO WIDTH JOINER␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">NBSP</span><span class="p">]&#34;</span><span class="o">.</span><span class="nb">uniname</span><span class="p">;</span> <span class="c1"># OUTPUT: «NO-BREAK SPACE␤» </span>
</span></span></code></pre></div><h2 id="命名序列httpsdocsrakuorglanguageunicode___top"><a href="https://docs.raku.org/language/unicode#___top">命名序列</a></h2>
<p>您也可以使用任何<a href="https://www.unicode.org/Public/UCD/latest/ucd/NamedSequences.txt">命名序列</a>，这些不是单个代码点，而是它们的序列。 [从2017.02开始]</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">LATIN CAPITAL LETTER E WITH VERTICAL LINE BELOW AND ACUTE</span><span class="p">]&#34;;</span>      <span class="c1"># OUTPUT: «É̩␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">LATIN CAPITAL LETTER E WITH VERTICAL LINE BELOW AND ACUTE</span><span class="p">]&#34;</span><span class="o">.</span><span class="nb">ords</span><span class="p">;</span> <span class="c1"># OUTPUT: «(201 809)␤» </span>
</span></span></code></pre></div><h3 id="emoji-序列httpsdocsrakuorglanguageunicode___top"><a href="https://docs.raku.org/language/unicode#___top">Emoji 序列</a></h3>
<p>Rakudo 支持表情符号 4.0（最新的非草稿版本）序列。 对于他们所有人看到：<a href="(https://www.unicode.org/Public/emoji/4.0/emoji-zwj-sequences.txt)">表情符号 ZWJ 序列</a>和<a href="https://www.unicode.org/Public/emoji/4.0/emoji-sequences.txt">表情符号序列</a>。 请注意，任何带逗号的名称都应删除逗号，因为 Raku 使用逗号分隔同一 <code>\c</code> 序列中的不同代码点/序列。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">woman gesturing OK</span><span class="p">]&#34;;</span>         <span class="c1"># OUTPUT: «🙆‍♀️␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">family: man woman girl boy</span><span class="p">]&#34;;</span> <span class="c1"># OUTPUT: «👨‍👩‍👧‍👦␤» </span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[类型系统]]></title>
            <link href="http://localhost:1313/rakulang/68.type-system/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/69.unicode/?utm_source=atom_feed" rel="related" type="text/html" title="Unicode" />
                <link href="http://localhost:1313/notes/five-spark-sql-helper-utility-functions-to-extract-and-explore-complex-data-types/?utm_source=atom_feed" rel="related" type="text/html" title="五个用于提取和探索复杂数据类型的 Spark SQL Helper 实用程序函数" />
                <link href="http://localhost:1313/notes/whats-behind-0-dot-1-plus-0-dot2-in-perl6/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 12/25. 在 Raku 中, 0.1 &#43; 0.2 背后的东西" />
                <link href="http://localhost:1313/notes/who-watches-the-minions/?utm_source=atom_feed" rel="related" type="text/html" title="第十一天 - 谁在看着 Minions" />
                <link href="http://localhost:1313/notes/%E4%BD%BF%E7%94%A8-hbase-%E7%9A%84-filterlist-%E8%BF%87%E6%BB%A4%E5%99%A8/?utm_source=atom_feed" rel="related" type="text/html" title="使用 HBase 的 FilterList 过滤器" />
            
                <id>http://localhost:1313/rakulang/68.type-system/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-12T21:13:31+08:00</published>
            <updated>2018-12-12T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="raku类型的定义httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">Raku类型的定义</a></h1>
<p>类型通过创建类型对象来定义新对象，该类型对象提供用于创建对象实例或检查值的接口。任何类型对象都是 <a href="https://docs.raku.org/type/Any">Any</a> 或 <a href="https://docs.raku.org/type/Mu">Mu</a> 的子类。通过从这些基类和内省后缀 <a href="https://docs.raku.org/language/operators#postfix_.%5E">.^</a> 继承来提供内省方法。在编译时由以下类型声明符之一或在运行时使用<a href="https://docs.raku.org/language/mop">元对象协议</a>将新类型引入当前作用域。所有类型名称的作用域必须是唯一的。</p>
<h2 id="默认类型httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">默认类型</a></h2>
<p>如果用户没有提供类型，则 Raku 假定类型为 <code>Any</code>。这包括<a href="https://docs.raku.org/language/containers">容器</a>，基类，<a href="https://docs.raku.org/type/Signature#Type_constraints">参数</a>和返回类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$a</span> <span class="o">=</span> <span class="kt">Nil</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Any» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">C</span><span class="o">.^</span><span class="nb">parents</span><span class="p">(:</span><span class="s">all</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «((Any) (Mu))» </span>
</span></span></code></pre></div><p>对于容器，默认类型为 <code>Any</code>，但默认类型约束为 <code>Mu</code>。请注意，绑定会替换容器，而不仅仅是值。在这种情况下，类型约束可能会变。</p>
<h2 id="类型对象httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">类型对象</a></h2>
<p>要测试对象是否为类型对象，请对使用类型为 <a href="https://docs.raku.org/type/Signature#Constraining_defined_and_undefined_values">smiley</a> 或 <a href="https://docs.raku.org/language/mop#index-entry-syntax_DEFINITE-DEFINITE"><code>.DEFINITE</code></a> 方法约束的类型使用 <a href="https://docs.raku.org/language/operators#index-entry-smartmatch_operator">smartmatch</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span> <span class="o">~~</span> <span class="kt">Mu:U</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «True» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">not</span> <span class="nv">$a</span><span class="o">.</span><span class="nb">DEFINITE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «True» </span>
</span></span></code></pre></div><p>如果调用者是实例，则 <code>.DEFINITE</code> 将返回 <code>True</code>。如果它返回 <code>False</code>，则调用者是一个类型对象。</p>
<h3 id="undefinednesshttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">Undefinedness</a></h3>
<p>未定义的对象在 Raku 中维护类型信息。类型对象用于表示未定义值和未定义值的类型。要提供一般的未定义值，请使用 <a href="https://docs.raku.org/type/Any">Any</a>。如果要区分容器和参数的默认类型 <code>Any</code>，则需要使用 <code>Mu</code>。</p>
<p>由 <a href="https://docs.raku.org/type/Mu#method_CREATE">.CREATE</a> 创建的对象实例是按惯例定义的。方法 <a href="https://docs.raku.org/type/Mu#routine_defined">.defined</a> 将返回 <code>Bool::True</code> 以指示定义。该规则的例外是 <a href="https://docs.raku.org/type/Nil">Nil</a> 和 <a href="https://docs.raku.org/type/Failure">Failure</a>。请注意，任何对象都可以重载 <code>.defined</code>，因此可以携带其他信息。此外，Raku 明确区分了定义和真假。很多值是有定义的, 即使它们具有错误或空值的含义。这些值为 <code>0</code>，<a href="https://docs.raku.org/type/Bool">Bool::False</a>, <a href="https://docs.raku.org/language/operators#term_%28_%29">()</a> (空列表) 和 <a href="https://docs.raku.org/type/Num#NaN">NaN</a>。</p>
<p>值可以在运行时通过 <a href="https://docs.raku.org/language/operators#infix_but">mixin</a> 变为未定义。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">but</span> <span class="nb">role</span><span class="o">::</span><span class="p">{</span> <span class="k">method</span> <span class="nb">defined</span> <span class="p">{</span> <span class="kt">False</span> <span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$i</span> <span class="o">//</span> <span class="p">&#34;</span><span class="s2">undefined</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «undefined» </span>
</span></span></code></pre></div><p>要测试定义需调用 <code>.defined</code>，请使用 <a href="https://docs.raku.org/language/operators#infix_%2F%2F">//</a>，<a href="https://docs.raku.org/language/control#with%2C_orwith%2C_without">with/without</a> 和 <a href="https://docs.raku.org/type/Signature#Constraining_defined_and_undefined_values">signatures</a>。</p>
<h3 id="强制转换httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">强制转换</a></h3>
<p>将一种类型转换为另一种类型是使用与目标类型同名的强制方法完成的。<a href="https://docs.raku.org/type/Signature#Coercion_type">Signatures</a> 强制要求此约定。源类型必须知道如何将自身转换为目标类型。要允许内置类型将自己转换为用户定义的类型，请使用 <a href="https://docs.raku.org/language/variables#The_augment_declarator">augment</a> 或者 <a href="https://docs.raku.org/language/mop">MOP</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.int</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">this-is-c</span> <span class="p">{</span> <span class="nb">put</span> <span class="p">&#39;</span><span class="s1">oi</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="nv">$!int</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">‽</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">MONKEY-TYPING</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">augment</span> <span class="k">class</span> <span class="kt">Int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">C</span> <span class="p">{</span> <span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">int</span><span class="p">(</span><span class="nb">self</span><span class="p">))}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$i</span><span class="o">.=</span><span class="n">C</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$i</span><span class="o">.</span><span class="nf">this-is-c</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «oioioioioioioioioioi‽» </span>
</span></span></code></pre></div><p>Raku 提供了在 <a href="https://docs.raku.org/type/Cool">Cool</a> 中定义的方法，以便在应用进一步操作之前转换为目标类型。大多数内置类型都来自 <code>Cool</code>，因此可能会提供可能不需要的隐式强制。用户有责任关心这些方法的无陷阱使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$whatever</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">123.6</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$whatever</span><span class="o">.</span><span class="nb">round</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «124» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">starts-with</span><span class="p">(&#34;</span><span class="s2">ab</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «False» </span>
</span></span></code></pre></div><h1 id="类型声明符httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">类型声明符</a></h1>
<p>类型声明符将新类型引入给定作用域。嵌套作用域可以用 <code>::</code> 分隔。如果不存在此类作用域，则会自动创建新 <a href="https://docs.raku.org/language/packages">packages</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Foo::Bar::C</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nb">put</span> <span class="n">Foo::Bar::</span><span class="o">.</span><span class="nb">keys</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «C» </span>
</span></span></code></pre></div><p>可以使用仅包含 <code>...</code> 的块来提供前置声明。如果定义了类型，编译器将在当前作用域的末尾检查。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># many lines later </span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="k">has</span> <span class="nv">$.attr</span> <span class="p">}</span>
</span></span></code></pre></div><h2 id="类httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top"><code>类</code></a></h2>
<p><code>class</code> 声明符创建一个编译为类型对象的编译时构造。后者是一个简单的 Raku 对象，它提供了通过执行初始化程序和子方法来构造实例的方法，以填充在类中声明的所有属性，以及任何具有值的父类。初始化程序可以提供属性声明或构造函数。 <a href="https://docs.raku.org/type/Metamodel::ClassHOW">Metamodel::ClassHOW</a> 负责知道如何运行它们。这是在 Raku 中构建对象的唯一神奇部分。默认父类型是 <code>Any</code>，它继承自 <code>Mu</code>。后者提供了默认的按照惯例命名的构造函数 <code>.new</code>。除此之外，<code>.new</code> 不具有任何特殊含义，也不以任何特殊方式对待。</p>
<p>有关如何使用类的更多信息，请参阅<a href="https://docs.raku.org/language/classtut">类和对象</a>教程。</p>
<h3 id="mixinshttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">Mixins</a></h3>
<p><code>class</code> 引入的类型可以在运行时使用 <a href="https://docs.raku.org/language/operators#infix_but">infix:</a> 进行扩展。原始类型不会被修改，而是返回一个新的类型对象，并且可以存储在一个容器中，该容器对原始类型或混合的角色进行成功类型检查。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">R</span> <span class="p">{</span> <span class="k">method</span> <span class="nf">m</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">oi‽</span><span class="p">&#39;</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="ow">R</span> <span class="nv">$A</span> <span class="o">=</span> <span class="n">A</span> <span class="k">but</span> <span class="ow">R</span><span class="err">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a1</span> <span class="o">=</span> <span class="nv">$A</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$a1</span><span class="o">.</span><span class="k">m</span><span class="p">;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">say </span><span class="p">[</span><span class="nv">$A</span><span class="sr"> </span><span class="o">~~</span><span class="sr"> R, </span><span class="nv">$a1</span><span class="sr"> </span><span class="o">~~</span><span class="sr"> R</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «oi‽[True True]» </span>
</span></span></code></pre></div><h3 id="自省httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">自省</a></h3>
<h4 id="元类httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">元类</a></h4>
<p>要测试给定类型对象是否为类，请针对 <a href="https://docs.raku.org/type/Metamodel::ClassHOW">Metamodel::ClassHOW</a> 测试元对象方法 <code>.HOW</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">C</span><span class="o">.</span><span class="nb">HOW</span> <span class="o">~~</span> <span class="kt">Metamodel::ClassHOW</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «True» </span>
</span></span></code></pre></div><h3 id="私有属性httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">私有属性</a></h3>
<p>私有<a href="https://docs.raku.org/type/Attribute">属性</a>用任何一个 <code>$!</code>，<code>@!</code> 和 <code>%!</code> twigils 来处理。它们没有自动生成的公共访问器方法。因此，它们不能从它们所定义的类的外面进行更改。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!priv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">submethod</span> <span class="nb">BUILD</span> <span class="p">{</span> <span class="nv">$!priv</span> <span class="o">=</span> <span class="mi">42</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="o">.</span><span class="nb">name</span><span class="o">,</span> <span class="o">.</span><span class="nb">package</span><span class="o">,</span> <span class="o">.</span><span class="nb">has_accessor</span><span class="p">)</span> <span class="k">for</span> <span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="o">.^</span><span class="nb">attributes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «($!priv (C) False)» </span>
</span></span></code></pre></div><h3 id="方法httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">方法</a></h3>
<p><code>method</code> 声明符定义 <a href="https://docs.raku.org/type/Method">Method</a> 类型的对象，并将其绑定到类的作用域中提供的名称上。默认情况下，类中的方法具有 <code>has</code> 作用域。<code>our</code> 作用域的那些方法默认不会添加到方法缓存中，因此不能使用访问器符号 <code>$.</code> 来调用。使用完全限定名称和调用者作为第一个参数来调用它们。</p>
<h4 id="继承和-multishttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">继承和 multis</a></h4>
<p>子类中的普通方法不与父类中的 multis 竞争。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nf">m</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$i</span><span class="p">){</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Int</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nf">m</span><span class="p">(</span><span class="kt">int</span> <span class="nv">$i</span><span class="p">){</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">int</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="k">is</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">m</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$i</span><span class="p">){</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">B::Int</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">int</span> <span class="nv">$i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="k">m</span><span class="p">(</span><span class="nv">$i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «B::Int» </span>
</span></span></code></pre></div><h4 id="only-方法httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">Only 方法</a></h4>
<p>要明确声明方法不是 multi 方法，请使用 <code>only</code> 方法声明符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">only</span> <span class="k">method</span> <span class="nf">m</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nf">m</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::Comp::AdHoc: Cannot have a multi candidate for &#39;m&#39; when an only method is also in the package &#39;C&#39;» </span>
</span></span></code></pre></div><h4 id="submethod-buildhttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">Submethod BUILD</a></h4>
<p><a href="https://docs.raku.org/type/Submethod">submethod</a> <code>BUILD</code> 是（间接地）由被称为 <a href="https://docs.raku.org/type/Mu#method_bless">.bless</a> 的方法调用的。它旨在设置类的私有和公共属性，并接收传入 <code>.bless</code> 的所有名称属性。定义在 <code>Mu</code> 中的默认构造函数 <a href="https://docs.raku.org/type/Mu#method_new">.new</a> 是调用它的方法。鉴于公共访问器方法在 <code>BUILD</code> 中不可用，您必须使用私有属性表示法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.attr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">submethod</span> <span class="nb">BUILD</span> <span class="p">(</span><span class="o">:</span><span class="nv">$attr</span> <span class="o">=</span> <span class="mi">42</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!attr</span> <span class="o">=</span> <span class="nv">$attr</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nb">new</span><span class="p">(</span><span class="nv">$positional</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(:</span><span class="s">attr</span><span class="p">(</span><span class="nv">$positional</span><span class="p">)</span><span class="o">,</span> <span class="o">|</span><span class="nv">%_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">answer</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «C.new(attr =&gt; 42)</span>
</span></span><span class="line"><span class="cl"><span class="c1">#          C.new(attr =&gt; &#34;answer&#34;)» </span>
</span></span></code></pre></div><h4 id="fallback-方法-httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">Fallback 方法 </a></h4>
<p>当其他解析名称的方法不产生结果时，将调用具有特殊名称的 <code>FALLBACK</code> 方法。第一个参数保存名称，所有后续参数都从原始调用转发。支持 multi 方法和<a href="https://docs.raku.org/type/Signature#Destructuring_arguments">子签名</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Magic</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">FALLBACK</span> <span class="p">(</span><span class="nv">$name</span><span class="o">,</span> <span class="o">|</span><span class="nf">c</span><span class="p">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Str</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">put</span> <span class="p">&#34;</span><span class="nv">$name</span><span class="s2"> called with parameters </span><span class="p">{</span><span class="n">c</span><span class="o">.</span><span class="nb">perl</span><span class="p">}&#34;</span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Magic</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">simsalabim</span><span class="p">(</span><span class="mi">42</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">answer</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «simsalabim called with parameters ⌈\(42, &#34;answer&#34;)⌋» </span>
</span></span></code></pre></div><h4 id="保留方法名httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">保留方法名</a></h4>
<p>一些内置的内省方法实际上是由编译器提供的特殊语法, 即 <code>WHAT</code>，<code>WHO</code>，<code>HOW</code> 和 <code>VAR</code>。使用这些名称声明的方法将无声地失败。动态调用将起作用，允许从外部对象调用方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">WHAT</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">ain&#39;t gonna happen</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>    <span class="c1"># OUTPUT: «(A)» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="p">&#34;</span><span class="s2">WHAT</span><span class="p">&#34;()</span> <span class="c1"># OUTPUT: «ain&#39;t gonna happen» </span>
</span></span></code></pre></div><h4 id="包作用域中的方法httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">包作用域中的方法</a></h4>
<p>任何 <code>our</code> 作用域方法都将在类的包作用域内可见。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">our</span> <span class="k">method</span> <span class="nf">packaged</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">loose</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">C::</span><span class="o">.</span><span class="nb">keys</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «(&amp;packaged)» </span>
</span></span></code></pre></div><h4 id="使用同名变量和方法设置属性httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">使用同名变量和方法设置属性</a></h4>
<p>如果您用和属性属性同名的名字设置属性的变量（或方法调用），则可以节省一些输入，例如 <code>attr =&gt; $attr </code> 或 <code>:attr($attr)</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="k">has</span> <span class="nv">$.i</span> <span class="o">=</span> <span class="mi">42</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.i</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">answer</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">m</span><span class="p">()</span> <span class="p">{</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">:</span><span class="nv">$.i</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#                  ^^^^  Instead of i =&gt; $.i or :i($.i) </span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="k">m</span><span class="p">;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">say </span><span class="nv">$a</span><span class="ni">.</span><span class="sr">i</span><span class="p">;</span> <span class="c1"># OUTPUT: «answer» </span>
</span></span></code></pre></div><p>由于 <code>$.i</code> 方法调用名字叫 <code>i</code> 且属性也叫 <code>i</code>，因此 Raku 允许我们使用快捷方式。这同样适用于 <code>:$var</code>，<code>:$!private-attribute</code>，<code>:&amp;attr-with-code-in-it</code>，等等。</p>
<h3 id="trait-is-nodalhttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">trait <code>is nodal</code></a></h3>
<p>标记一个<a href="https://docs.raku.org/type/List">List</a>方法，指示 hyperoperator 不要进入内部 <a href="https://docs.raku.org/type/Iterable">Iterables</a> 以调用此方法。这个特性通常不是终端用户会使用的东西，除非他们子类化或扩展核心 <a href="https://docs.raku.org/type/List">List</a> 类型。</p>
<p>为了证明差异，请考虑以下示例，第一个使用 <code>is nodal</code> 方法（<code>elems</code>），第二个使用方法 <code>Int</code> , 它不是节点方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">((</span><span class="mf">1.0</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">2</span><span class="p">&#34;</span><span class="o">,</span> <span class="mf">3e0</span><span class="p">)</span><span class="o">,</span> <span class="o">[^</span><span class="mi">4</span><span class="o">],</span> <span class="p">&#39;</span><span class="s1">5</span><span class="p">&#39;)</span><span class="o">».</span><span class="nb">elems</span><span class="p">;</span> <span class="c1"># OUTPUT: «(3, 4, 1)» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">((</span><span class="mf">1.0</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">2</span><span class="p">&#34;</span><span class="o">,</span> <span class="mf">3e0</span><span class="p">)</span><span class="o">,</span> <span class="o">[^</span><span class="mi">4</span><span class="o">],</span> <span class="p">&#39;</span><span class="s1">5</span><span class="p">&#39;)</span><span class="o">».</span><span class="kt">Int</span>    <span class="c1"># OUTPUT: «((1 2 3) [0 1 2 3] 5)» </span>
</span></span></code></pre></div><h3 id="trait-handleshttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">trait <code>handles</code></a></h3>
<p>定义为:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">trait_mod</span><span class="o">:</span><span class="p">&lt;</span><span class="s">handles</span><span class="p">&gt;(</span><span class="kt">Attribute:D</span> <span class="nv">$target</span><span class="o">,</span> <span class="nv">$thunk</span><span class="p">)</span>
</span></span></code></pre></div><p><a href="https://docs.raku.org/type/Sub#Traits">trait</a> <code>handles</code> 应用于类的属性，会将对提供的方法名称的所有调用代理给和属性同名名的方法。必须初始化属性引用的对象。可以提供代理调用的对象的类型约束。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span>      <span class="p">{</span> <span class="k">method</span> <span class="nf">m</span><span class="p">(){</span> <span class="p">&#39;</span><span class="s1">A::m has been called.</span><span class="p">&#39;</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="k">is</span> <span class="nc">A</span> <span class="p">{</span> <span class="k">method</span> <span class="nf">m</span><span class="p">(){</span> <span class="p">&#39;</span><span class="s1">B::m has been called.</span><span class="p">&#39;</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="n">A</span> <span class="nv">$.delegate</span> <span class="nb">handles</span> <span class="p">&#39;</span><span class="s1">m</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span><span class="nv">$delegate</span><span class="p">){</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span><span class="s">delegate</span> <span class="o">=&gt;</span> <span class="nv">$delegate</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="nb">new</span><span class="p">)</span><span class="o">.</span><span class="k">m</span><span class="p">();</span> <span class="c1"># OUTPUT: «B::m has been called.» </span>
</span></span></code></pre></div><p>可以提供一个 <code>Pair</code>（或用于重命名）或一个 <code>Pair</code>，<code>Regex</code> 或 <code>Whatever</code> 的列表而不是一个方法名。在后一种情况下，在类本身及其继承链中的现有方法将优先。如果 <code>FALLBACK</code> 要搜索本地，请使用 <code>HyperWhatever</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">m1</span><span class="p">(){}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">m2</span><span class="p">(){}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.delegate</span> <span class="nb">handles</span> <span class="p">&lt;</span><span class="s">m1 m2</span><span class="p">&gt;</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">m2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">D</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.delegate</span> <span class="nb">handles</span> <span class="o">/</span><span class="k">m</span><span class="p">\</span><span class="sr">d/ </span><span class="o">=</span><span class="sr"> A</span><span class="ni">.</span><span class="sr">new</span><span class="p">()</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">}
</span></span></span><span class="line"><span class="cl"><span class="sr">D</span><span class="ni">.</span><span class="sr">new</span><span class="ni">.</span><span class="sr">m</span><span class="mi">1</span><span class="sr">;
</span></span></span><span class="line"><span class="cl"><span class="sr"> 
</span></span></span><span class="line"><span class="cl"><span class="sr">class E </span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.delegate</span> <span class="nb">handles</span> <span class="p">(</span><span class="s">em1</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">m1</span><span class="p">&#39;)</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">E</span><span class="ni">.</span><span class="sr">new</span><span class="ni">.</span><span class="sr">em</span><span class="mi">1</span><span class="sr">;
</span></span></span></code></pre></div><h3 id="trait-is">trait <code>is</code></h3>
<p>定义为:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">trait_mod</span><span class="o">:</span><span class="p">&lt;</span><span class="s">is</span><span class="p">&gt;(</span><span class="kt">Mu:U</span> <span class="nv">$child</span><span class="o">,</span> <span class="kt">Mu:U</span> <span class="nv">$parent</span><span class="p">)</span>
</span></span></code></pre></div><p><a href="https://docs.raku.org/type/Sub#Traits">trait</a> <code>is</code> 接受一个类型对象，该类型对象在其定义中被添加为类的父类。为了允许多重继承，可以多次应用 <code>is</code> trait。将父类添加到类中会将其方法导入目标类。如果在多个父类中出现同名方法，则第一个添加的父类将胜出。</p>
<p>如果没有提供 <code>is</code> trait，则默认值 <a href="https://docs.raku.org/type/Any"><code>Any</code></a> 将用作父类。这迫使所有 Raku 对象具有相同的基本方法集，以提供内省和强制到基本类型的接口。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nf">from-a</span><span class="p">(){</span> <span class="p">&#39;</span><span class="s1">A::from-a</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="o">.^</span><span class="nb">parents</span><span class="p">(:</span><span class="s">all</span><span class="p">)</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «(Any, Mu)» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">from-b</span><span class="p">(){</span> <span class="p">&#39;</span><span class="s1">B::from-b </span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nf">from-a</span><span class="p">(){</span> <span class="p">&#39;</span><span class="s1">B::from-A</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="k">is</span> <span class="nc">A</span> <span class="k">is</span> <span class="nc">B</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">from-a</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «A::from-a» </span>
</span></span></code></pre></div><h3 id="trait-is-rwhttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">trait <code>is rw</code></a></h3>
<p>定义为:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">trait_mod</span><span class="o">:</span><span class="p">&lt;</span><span class="s">is</span><span class="p">&gt;(</span><span class="kt">Mu:U</span> <span class="nv">$type</span><span class="o">,</span> <span class="o">:</span><span class="nv">$rw</span><span class="o">!</span><span class="p">)</span>
</span></span></code></pre></div><p>类的<a href="https://docs.raku.org/type/Sub#Traits">trait</a> <code>is rw</code> 在该类的所有公共属性上创建可写的访问器方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$c</span><span class="p">;</span> <span class="c1"># OUTPUT: «42» </span>
</span></span></code></pre></div><h3 id="trait-is-requiredhttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">trait <code>is required</code></a></h3>
<p>定义为:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">trait_mod</span><span class="o">:</span><span class="p">&lt;</span><span class="s">is</span><span class="p">&gt;(</span><span class="kt">Attribute</span> <span class="nv">$attr</span><span class="o">,</span> <span class="o">:</span><span class="nv">$required</span><span class="o">!</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">trait_mod</span><span class="o">:</span><span class="p">&lt;</span><span class="s">is</span><span class="p">&gt;(</span><span class="kt">Parameter:D</span> <span class="nv">$param</span><span class="o">,</span> <span class="o">:</span><span class="nv">$required</span><span class="o">!</span><span class="p">)</span>
</span></span></code></pre></div><p>将类或角色属性标记为必要的。如果在对象构造时未初始化该属性，则抛出 <a href="https://docs.raku.org/type/X::Attribute::Required">X::Attribute::Required</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Correct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.attr</span> <span class="k">is</span> <span class="k">required</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">submethod</span> <span class="nb">BUILD</span> <span class="p">(</span><span class="o">:</span><span class="nv">$attr</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$!attr</span> <span class="o">=</span> <span class="nv">$attr</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Correct</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">attr</span> <span class="o">=&gt;</span> <span class="mi">42</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Correct.new(attr =&gt; 42)» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.attr</span> <span class="k">is</span> <span class="k">required</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="o">.^</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::Attribute::Required =&gt; The attribute &#39;$!attr&#39; is required, but you did not provide a value for it.» </span>
</span></span></code></pre></div><p>你可以为 <code>is required</code> 提供一个理由作为参数，说明它为什么是必须的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Correct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.attr</span> <span class="k">is</span> <span class="k">required</span><span class="p">(&#34;</span><span class="s2">it&#39;s so cool</span><span class="p">&#34;)</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Correct</span><span class="o">.</span><span class="nb">new</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «The attribute &#39;$!attr&#39; is required because it&#39;s so cool,but you did not provide a value for it.» </span>
</span></span></code></pre></div><h3 id="trait-hideshttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">trait <code>hides</code></a></h3>
<p>trait <code>hides</code> 提供继承而不需要<a href="https://docs.raku.org/language/functions#Re-dispatching">重新分派</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">m</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">i am hidden</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="nb">hides</span> <span class="n">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">m</span> <span class="p">{</span> <span class="nb">nextsame</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">n</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nf">A::m</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="k">m</span><span class="p">;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">B</span><span class="ni">.</span><span class="sr">new</span><span class="ni">.</span><span class="sr">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «i am hidden» </span>
</span></span></code></pre></div><p>trait <code>is hidden</code> 允许类从 <a href="https://docs.raku.org/language/functions#Re-dispatching">重新分派</a> 中隐藏自己。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="k">is</span> <span class="nb">hidden</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">m</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">i am hidden</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="k">is</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">m</span> <span class="p">{</span> <span class="nb">nextsame</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">n</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nf">A::m</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="k">m</span><span class="p">;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">B</span><span class="ni">.</span><span class="sr">new</span><span class="ni">.</span><span class="sr">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «i am hidden» </span>
</span></span></code></pre></div><h3 id="trait-trustshttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">trait <code>trusts</code></a></h3>
<p>要允许一个类访问另一个类的私有方法，请使用该 trait <code>trusts</code>。可能需要可信类的前置声明。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="p">{</span><span class="o">...</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">trusts</span> <span class="n">B</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">!foo</span> <span class="p">{</span> <span class="k">return-rw</span> <span class="nv">$!foo</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">perl</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">A.new(foo =&gt; </span><span class="nv">$!foo</span><span class="s2">)</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="n">A</span> <span class="nv">$.a</span> <span class="o">.=</span> <span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">change</span> <span class="p">{</span> <span class="nv">$!a</span><span class="o">!</span><span class="n">A::foo</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="nb">self</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">B</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">change</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «B.new(a =&gt; A.new(foo =&gt; 42))» </span>
</span></span></code></pre></div><h3 id="扩展类httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">扩展类</a></h3>
<p>要在编译时向类添加方法和属性，请在类定义片段前面使用 <code>augment</code>。编译器将要求编译指令 <code>use MONKEY-TYPING</code> 或 <code>use MONKEY</code> 早一点出现在同一作用域中。请注意，可能会对性能产生影响，因此可能会出现问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">MONKEY</span><span class="p">;</span> <span class="k">augment</span> <span class="k">class</span> <span class="kt">Str</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">mark</span><span class="p">(</span><span class="kt">Any</span> <span class="o">:</span><span class="nv">$set</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">state</span> <span class="nv">$mark</span> <span class="o">//=</span> <span class="nv">$set</span><span class="p">;</span> <span class="nv">$mark</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">42</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$s</span><span class="o">.</span><span class="nf">mark</span><span class="p">(</span><span class="s">set</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">answer</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$s</span><span class="o">.</span><span class="nf">mark</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «answer» </span>
</span></span></code></pre></div><p>在类片段内可以做什么的限制很少。其中之一是将方法或子方法重新声明为 <code>multi</code> 方法。使用添加的属性尚未被实现。请注意，添加仅在其命名参数方面不同的多候选项将在已定义的候选项后面添加该候选项，因此调度程序不会选择该候选项。</p>
<h3 id="版本和作者httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">版本和作者</a></h3>
<p>版权和作者身份可以通过副词 <code>:ver&lt;&gt;</code> 和 <code>:auth&lt;&gt;</code> 应用。两者都以字符串作为参数，对于 <code>:ver</code>, 字符串被转换为 <a href="https://docs.raku.org/type/Version">Version</a> 对象。查询类版本和作者请使用 <code>.^ver</code> 和 <code>^.auth</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span><span class="p">:</span><span class="na">ver</span><span class="p">&lt;</span><span class="s">4.2.3</span><span class="p">&gt;:</span><span class="na">auth</span><span class="p">&lt;</span><span class="s">me@here.local</span><span class="p">&gt;</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[</span><span class="n">C</span><span class="o">.^</span><span class="nb">ver</span><span class="o">,</span> <span class="n">C</span><span class="o">.^</span><span class="nb">auth</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «[v4.2.3 me@here.local]» </span>
</span></span></code></pre></div><h2 id="rolehttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top"><code>role</code></a></h2>
<p>角色是类片段，它允许定义类共享的接口。<code>role</code> 声明符还引入了可用于类型检查的类型对象。角色可以在运行时和编译时混合到类和对象中。<code>role</code> 声明符返回创建的类型对象因而允许匿名角色和就地混入定义。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">Serialize</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">to-string</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="kt">Str</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">to-number</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="kt">Num</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="k">does</span> <span class="nc">Serialize</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="k">does</span> <span class="nc">Serialize</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">Serialize</span> <span class="nv">@list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@list</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@list</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="n">B</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@list</span><span class="o">».</span><span class="nf">to-string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «[A&lt;57192848&gt; B&lt;57192880&gt;]» </span>
</span></span></code></pre></div><p>使用 <code>...</code> 作为方法体的唯一元素声明一个要抽象的方法。任何混合使用这种方法的类都必须重载它。如果在编译单元结束之前该方法没有被重载，则抛出 <code>X::Comp::AdHoc</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">EVAL</span> <span class="p">&#39;</span><span class="s1">role R { method overload-this(){...} }; class A does R {}; </span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::Comp::AdHoc Method &#39;overload-this&#39; must be implemented by A because it is required by roles: R.» </span>
</span></span></code></pre></div><h3 id="自动双关httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">自动双关</a></h3>
<p>可以使用角色而不是类来创建对象。由于角色在运行时不能存在，因此会创建一个同名的类，该类将对角色类型检查成功。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">R</span> <span class="p">{</span> <span class="k">method</span> <span class="nf">m</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">oi‽</span><span class="p">&#39;</span> <span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="ow">R</span><span class="o">.</span><span class="err">new</span><span class="o">.^</span><span class="err">mro</span><span class="o">.</span><span class="err">say;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «((R) (Any) (Mu))» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="ow">R</span><span class="o">.</span><span class="err">new</span><span class="o">.^</span><span class="err">mro[0</span><span class="o">].</span><span class="nb">HOW</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Raku::Metamodel::ClassHOW» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="ow">R</span><span class="o">.</span><span class="err">new</span> <span class="o">~~</span> <span class="ow">R</span><span class="err">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «True» </span>
</span></span></code></pre></div><h3 id="trait-doeshttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">trait <code>does</code></a></h3>
<p>trait <code>does</code> 可以应用于提供编译时混合的角色和类。要引用尚未定义的角色，请使用前置声明。混合角色的类的类型名称不反射 mixin，类型检查反射。如果在多个混合角色中提供方法，则首先定义的方法优先。可以提供以逗号分隔的角色列表。在这种情况下，将在编译时报告冲突。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">R2</span> <span class="p">{</span><span class="o">...</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">R1</span> <span class="k">does</span> <span class="nc">R2</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">R2</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="k">does</span> <span class="nc">R1</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[</span><span class="n">C</span> <span class="o">~~</span> <span class="n">R1</span><span class="o">,</span> <span class="n">C</span> <span class="o">~~</span> <span class="n">R2</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «[True True]» </span>
</span></span></code></pre></div><p>对于运行时混入请参阅<a href="https://docs.raku.org/language/operators#infix_but">but</a> 和 <a href="https://docs.raku.org/language/operators#infix_does">does</a>。</p>
<h3 id="参数化httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">参数化</a></h3>
<p>可以在角色名称后面的 <code>[]</code> 之间提供角色的参数。支持<a href="https://docs.raku.org/type/Signature#Type_captures">类型捕获</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">role</span> <span class="ow">R</span><span class="p">[</span><span class="nv">$d</span><span class="p">]</span> <span class="p">{</span> <span class="k">has</span> <span class="nv">$.a</span> <span class="o">=</span> <span class="nv">$d</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="k">does</span> <span class="ow">R</span><span class="p">[&#34;</span><span class="s2">default</span><span class="p">&#34;]</span> <span class="p">{</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «C.new(a =&gt; &#34;default&#34;)» </span>
</span></span></code></pre></div><p>参数可以有类型约束，类型不支持 <code>where</code> 子句，但可以通过 <code>subset</code> 实现。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">subset</span> <span class="nc">A-or-B</span> <span class="k">where</span> <span class="o">*</span> <span class="o">~~</span> <span class="n">A</span><span class="o">|</span><span class="n">B</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="ow">R</span><span class="err">[A</span><span class="o">-</span><span class="ow">or</span><span class="o">-</span><span class="err">B</span> <span class="o">:</span><span class="p">:</span><span class="s">T</span><span class="o">]</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="ow">R</span><span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">]</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span></code></pre></div><p>可以提供默认参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">role</span> <span class="ow">R</span><span class="err">[$p</span> <span class="o">=</span> <span class="nb">fail</span><span class="p">(&#34;</span><span class="s2">Please provide a parameter to role R</span><span class="p">&#34;)</span><span class="o">]</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">does</span> <span class="ow">R</span><span class="err">;</span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span><span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::AdHoc: Could not instantiate role &#39;R&#39;:Please provide a parameter to role R» </span>
</span></span></code></pre></div><h3 id="as-类型约束httpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">As 类型约束</a></h3>
<p>在期望类型的任何地方，角色都可以用作类型约束。如果使用 <code>does</code> 或 <code>but</code> 混合角色，则其 type-object 将添加到相关对象的 type-object 列表中。如果使用角色而不是类（使用自动生成），则自动生成的类与角色同名的类型对象将添加到继承链中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">Unitish</span><span class="o">[</span><span class="nv">$unit</span> <span class="o">=</span> <span class="nb">fail</span><span class="p">(&#39;</span><span class="s1">Please provide a SI unit quantifier as a parameter to the role Unitish</span><span class="p">&#39;)</span><span class="o">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.SI-unit-symbol</span> <span class="o">=</span> <span class="nv">$unit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">gist</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">given</span> <span class="nb">self</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># ... </span>
</span></span><span class="line"><span class="cl">            <span class="k">when</span> <span class="o">*</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">self</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">m</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$.SI-unit-symbol</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">when</span> <span class="o">*</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">self</span> <span class="o">~</span> <span class="nv">$.SI-unit-symbol</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">when</span> <span class="o">*</span> <span class="o">&lt;</span> <span class="mi">1_000_000</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">self</span> <span class="o">/</span> <span class="mi">1_000</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">k</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$.SI-unit-symbol</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># ... </span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">SI-second</span>   <span class="k">does</span> <span class="nc">Unitish</span><span class="o">[</span><span class="p">&lt;</span><span class="s">s</span><span class="p">&gt;</span><span class="o">]</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">SI-meter</span>    <span class="k">does</span> <span class="nc">Unitish</span><span class="o">[</span><span class="p">&lt;</span><span class="s">m</span><span class="p">&gt;</span><span class="o">]</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">SI-kilogram</span> <span class="k">does</span> <span class="nc">Unitish</span><span class="o">[</span><span class="p">&lt;</span><span class="s">g</span><span class="p">&gt;</span><span class="o">]</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">s</span><span class="p">&gt;(</span><span class="kt">Numeric</span> <span class="nv">$num</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="nv">$num</span><span class="p">)</span> <span class="k">does</span> <span class="nc">SI-second</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">m</span><span class="p">&gt;(</span><span class="kt">Numeric</span> <span class="nv">$num</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="nv">$num</span><span class="p">)</span> <span class="k">does</span> <span class="nc">SI-meter</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">g</span><span class="p">&gt;(</span><span class="kt">Numeric</span> <span class="nv">$num</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="nv">$num</span><span class="p">)</span> <span class="k">does</span> <span class="nc">SI-kilogram</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">kg</span><span class="p">&gt;(</span><span class="kt">Numeric</span> <span class="nv">$num</span><span class="p">){</span> <span class="p">(</span><span class="nv">$num</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="k">does</span> <span class="nc">SI-kilogram</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">constant</span> <span class="no">g</span> <span class="o">=</span> <span class="mf">9.806_65</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">SI-Newton</span> <span class="k">does</span> <span class="nc">Unitish</span><span class="o">[</span><span class="p">&lt;</span><span class="s">N</span><span class="p">&gt;</span><span class="o">]</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">N</span><span class="p">(</span><span class="n">SI-kilogram</span> <span class="nv">$kg</span><span class="o">,</span> <span class="n">SI-meter</span> <span class="nv">$m</span><span class="o">,</span> <span class="n">SI-second</span> <span class="nv">$s</span> <span class="k">--&gt;</span> <span class="n">SI-Newton</span> <span class="p">){</span> <span class="p">(</span><span class="nv">$kg</span> <span class="o">*</span> <span class="p">(</span><span class="nv">$m</span> <span class="o">/</span> <span class="nv">$s</span>²<span class="p">))</span> <span class="k">does</span> <span class="nc">SI-Newton</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">N</span><span class="p">(</span><span class="n">SI-kilogram</span> <span class="nv">$kg</span> <span class="k">--&gt;</span> <span class="n">SI-Newton</span><span class="p">)</span>                            <span class="p">{</span> <span class="p">(</span><span class="nv">$kg</span> <span class="o">*</span> <span class="n">g</span><span class="p">)</span> <span class="k">does</span> <span class="nc">SI-Newton</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[</span><span class="mi">75</span><span class="n">kg</span><span class="o">,</span> <span class="nf">N</span><span class="p">(</span><span class="mi">75</span><span class="n">kg</span><span class="p">)</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «[75kg 735.49875kN]» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[</span><span class="p">(</span><span class="mi">75</span><span class="n">kg</span><span class="p">)</span><span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="nf">N</span><span class="p">(</span><span class="mi">75</span><span class="n">kg</span><span class="p">)</span><span class="o">.^</span><span class="nb">name</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «[Int+{SI-kilogram} Rat+{SI-Newton}]» </span>
</span></span></code></pre></div><h2 id="enumhttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top"><code>enum</code></a></h2>
<p>枚举提供具有关联类型的常量键-值对。任何键都属于该类型，并作为符号注入当前作用域。如果使用该符号，则将其视为常量表达式，并将该符号替换为枚举对的值。任何枚举都从角色 <a href="https://docs.raku.org/type/Enumeration"><code>Enumeration</code></a> 继承方法。不支持用于生成键值对的复杂表达式。通常，<code>enum</code> 是一个 <a href="https://docs.raku.org/type/Map">Map</a> 其元素具有混合的<code>Enumeration</code> 角色; 对于每个元素，此角色包括在 map 上创建顺序的索引。</p>
<p>符号的字符串化，在字符串上下文中自动完成，并且与其名称完全相同，这也是枚举对的键。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">Names</span> <span class="p">(</span> <span class="s">name1</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">name2</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">name1</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="o">,</span> <span class="n">name2</span><span class="p">;</span> <span class="c1"># OUTPUT: «name1 name2» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">name1</span><span class="o">.</span><span class="nb">value</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="o">,</span> <span class="n">name2</span><span class="o">.</span><span class="nb">value</span><span class="p">;</span> <span class="c1"># OUTPUT: «1 2» </span>
</span></span></code></pre></div><p>比较符号将使用类型信息和枚举对的值。支持 <code>Num</code> 类型和 <code>Str</code> 类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">Names</span> <span class="p">(</span> <span class="s">name1</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">name2</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">same</span><span class="p">(</span><span class="n">Names</span> <span class="nv">$a</span><span class="o">,</span> <span class="n">Names</span> <span class="nv">$b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="nv">$a</span> <span class="ow">eqv</span> <span class="nv">$b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">same</span><span class="p">(</span><span class="n">name1</span><span class="o">,</span> <span class="n">name1</span><span class="p">);</span> <span class="c1"># OUTPUT: «True» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">same</span><span class="p">(</span><span class="n">name1</span><span class="o">,</span> <span class="n">name2</span><span class="p">);</span> <span class="c1"># OUTPUT: «False» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="n">name1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span> <span class="o">~~</span> <span class="n">Names</span><span class="p">;</span> <span class="c1"># OUTPUT: «True» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>    <span class="c1"># OUTPUT: «Names» </span>
</span></span></code></pre></div><p>所有键必须属于同一类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">Mass</span> <span class="p">(</span> <span class="s">mg</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1000</span><span class="o">,</span> <span class="s">g</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">,</span> <span class="s">kg</span> <span class="o">=&gt;</span> <span class="mi">1000</span><span class="o">/</span><span class="mi">1</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Mass</span><span class="o">.</span><span class="nb">enums</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Map.new((g =&gt; 1, kg =&gt; 1000, mg =&gt; 0.001))» </span>
</span></span></code></pre></div><p>如果没有给出值，则 <code>Int</code> 将假定为值类型，并且每个键从零开始递增 1。作为枚举键类型 <code>Int</code>，<code>Num</code>，<code>Rat</code> 和 <code>Str</code> 都被支持。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">Numbers</span> <span class="p">&lt;</span><span class="s">one two three four</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Numbers</span><span class="o">.</span><span class="nb">enums</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Map.new((four =&gt; 3, one =&gt; 0, three =&gt; 2, two =&gt; 1))» </span>
</span></span></code></pre></div><p>可以提供不同的起始值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">Numbers</span> <span class="p">«</span><span class="s2">:one(1) two three four</span><span class="p">»;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Numbers</span><span class="o">.</span><span class="nb">enums</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Map.new((four =&gt; 4, one =&gt; 1, three =&gt; 3, two =&gt; 2))» </span>
</span></span></code></pre></div><p>枚举也可以是匿名的，和具名 <code>enum</code> 的唯一的区别在于您不能在签名中使用它或用它声明变量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$e</span> <span class="o">=</span> <span class="k">enum</span> <span class="p">&lt;</span><span class="s">one two three</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">two</span><span class="p">;</span>       <span class="c1"># OUTPUT: «two» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">one</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># OUTPUT: «» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$e</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>  <span class="c1"># OUTPUT: «Map» </span>
</span></span></code></pre></div><p>有多种方法可以访问已定义的符号的键和值。所有这些都将值转换为 <code>Str</code>，这可能是不可取的。通过将枚举视为包，我们可以获得键的类型列表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nf">E</span><span class="p">(&lt;</span><span class="s">one two</span><span class="p">&gt;);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@keys</span> <span class="o">=</span> <span class="n">E::</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@keys</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="o">*.</span><span class="nb">enums</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «(Map.new((one =&gt; 0, two =&gt; 1)) Map.new((one =&gt; 0, two =&gt; 1)))» </span>
</span></span></code></pre></div><h3 id="元类httpsdocsrakuorglanguagetypesystem___top-1"><a href="https://docs.raku.org/language/typesystem#___top">元类</a></h3>
<p>要测试给定类型对象是否为 <code>enum</code>，请 <code>.HOW</code> 针对 <a href="https://docs.raku.org/type/Metamodel::EnumHOW">Metamodel::EnumHOW</a> 测试元对象方法，或者仅针对该 <code>Enumeration</code> 角色进行测试。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nf">E</span><span class="p">(&lt;</span><span class="s">a b c</span><span class="p">&gt;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">E</span><span class="o">.</span><span class="nb">HOW</span> <span class="o">~~</span> <span class="kt">Metamodel::EnumHOW</span><span class="p">;</span> <span class="c1"># OUTPUT: «True» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">E</span> <span class="o">~~</span> <span class="kt">Enumeration</span><span class="p">;</span>            <span class="c1"># OUTPUT: «True» </span>
</span></span></code></pre></div><h3 id="methodshttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">Methods</a></h3>
<h4 id="method-enumshttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">method enums</a></h4>
<p>定义为:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">method</span> <span class="nb">enums</span><span class="p">()</span>
</span></span></code></pre></div><p>返回枚举对列表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">Mass</span> <span class="p">(</span> <span class="s">mg</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1000</span><span class="o">,</span> <span class="s">g</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1</span><span class="o">,</span> <span class="s">kg</span> <span class="o">=&gt;</span> <span class="mi">1000</span><span class="o">/</span><span class="mi">1</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Mass</span><span class="o">.</span><span class="nb">enums</span><span class="p">;</span> <span class="c1"># OUTPUT: «{g =&gt; 1, kg =&gt; 1000, mg =&gt; 0.001}» </span>
</span></span></code></pre></div><h3 id="coercionhttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top">Coercion</a></h3>
<p>如果要将枚举元素的值强制转换为其合适的枚举对象，请使用带有枚举名称的 coercer：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">enum</span> <span class="n">A</span> <span class="p">(</span><span class="s">sun</span> <span class="o">=&gt;</span> <span class="mi">42</span><span class="o">,</span> <span class="s">mon</span> <span class="o">=&gt;</span> <span class="mi">72</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">A</span><span class="p">(</span><span class="mi">72</span><span class="p">)</span><span class="o">.</span><span class="nb">pair</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>   <span class="c1"># OUTPUT: «mon =&gt; 72» </span>
</span></span><span class="line"><span class="cl"><span class="nf">A</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># OUTPUT: «(A)» </span>
</span></span></code></pre></div><p>最后一个示例显示了如果没有枚举对包含它作为值会发生什么。</p>
<h2 id="modulehttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top"><code>module</code></a></h2>
<p>模块通常是一个或多个公开 Raku 结构的源文件，例如类，角色，grammars，子例程和变量。模块通常用于将 Raku 代码分发为可在另一个 Raku 程序中使用的库。</p>
<p>有关完整说明，请参阅<a href="https://docs.raku.org/language/modules">模块</a>。</p>
<h2 id="packagehttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top"><code>package</code></a></h2>
<p>Packages are nested namespaces of named program elements. Modules, classes and grammars are all types of package.</p>
<p>For a full explanation see <a href="https://docs.raku.org/language/packages">Packages</a>.</p>
<p>包是命名程序元素的嵌套命名空间。模块，类和语法都是所有类型的包。</p>
<p>有关完整说明，请参阅<a href="https://docs.raku.org/language/packages">包</a>。</p>
<h2 id="grammarhttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top"><code>grammar</code></a></h2>
<p>Grammar 是用于解析文本的特定类型。Grammars 由 rule，token 和 regex 组成，它们实际上是方法，因为 grammars 是类。</p>
<p>有关完整说明，请参阅<a href="https://docs.raku.org/language/grammars">Grammars</a>。</p>
<h3 id="版本和作者httpsdocsrakuorglanguagetypesystem___top-1"><a href="https://docs.raku.org/language/typesystem#___top">版本和作者</a></h3>
<p>版权和作者身份可以通过副词 <code>:ver&lt;&gt;</code> 和 <code>:auth&lt;&gt;</code> 应用。两者都以字符串作为参数，对于 <code>:ver</code>, 字符串被转换为 <a href="https://docs.raku.org/type/Version">Version</a>对象。查询语法版本和作者使用 <code>.^ver</code> 和 <code>^.auth</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">G</span><span class="p">:</span><span class="na">ver</span><span class="p">&lt;</span><span class="s">4.2.3</span><span class="p">&gt;:</span><span class="na">auth</span><span class="p">&lt;</span><span class="s">me@here.local</span><span class="p">&gt;</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[</span><span class="n">G</span><span class="o">.^</span><span class="nb">ver</span><span class="o">,</span> <span class="n">G</span><span class="o">.^</span><span class="nb">auth</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «[v4.2.3 me@here.local]» </span>
</span></span></code></pre></div><h2 id="subsethttpsdocsrakuorglanguagetypesystem___top"><a href="https://docs.raku.org/language/typesystem#___top"><code>subset</code></a></h2>
<p><code>subset</code> 声明一个会重新分配到其基类型的新类型。如果提供了 <a href="https://docs.raku.org/type/Signature#where"><code>where</code></a> 子句，则将针对给定的代码对象检查任何赋值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">subset</span> <span class="nc">Positive</span> <span class="k">of</span> <span class="kt">Int</span> <span class="k">where</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">Positive</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $i; expected Positive but got Int (-42)» </span>
</span></span></code></pre></div><p>Subsets 可用于签名，例如通过键入下面的输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">subset</span> <span class="nc">Foo</span> <span class="k">of</span> <span class="kt">List</span> <span class="k">where</span> <span class="p">(</span><span class="kt">Int</span><span class="o">,</span><span class="kt">Str</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">a</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="o">,</span> <span class="k">--&gt;</span> <span class="n">Foo</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Only a List with the first element being an Int and the second a Str will pass the type check. </span>
</span></span><span class="line"><span class="cl"><span class="nf">a</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;);</span>  <span class="c1"># passes </span>
</span></span><span class="line"><span class="cl"><span class="nf">a</span><span class="p">(&#34;</span><span class="s2">foo</span><span class="p">&#34;</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1"># fails </span>
</span></span></code></pre></div><p>Subsets 可以是匿名的，允许在需要 subset 的情况下进行内联放置，但名字既不需要也不值得。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">enum</span> <span class="n">E1</span> <span class="o">&lt;</span><span class="n">A</span> <span class="n">B</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">enum</span> <span class="n">E2</span> <span class="o">&lt;</span><span class="n">C</span> <span class="n">D</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">g</span><span class="p">(</span><span class="nv">@a</span> <span class="k">where</span> <span class="p">{</span> <span class="o">.</span><span class="nb">all</span> <span class="o">~~</span> <span class="n">subset::where</span> <span class="n">E1</span><span class="o">|</span><span class="n">E2</span> <span class="p">}</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">@a</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">g</span><span class="p">(</span><span class="o">[</span><span class="n">A</span><span class="o">,</span> <span class="n">C</span><span class="o">]</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «[A C]» </span>
</span></span></code></pre></div><p>Subsets 可用于动态检查类型，这可以与 <a href="https://docs.raku.org/language/modules#require">require</a> 结合使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">require</span> <span class="o">::</span><span class="p">(&#39;</span><span class="s1">YourModule</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="k">subset</span> <span class="nc">C</span> <span class="k">where</span> <span class="o">::</span><span class="p">(&#39;</span><span class="s1">YourModule::C</span><span class="p">&#39;);</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Traits]]></title>
            <link href="http://localhost:1313/rakulang/67.traits/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/solving-the-problem-34-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 11/25. 在 Raku 中解决34号问题" />
                <link href="http://localhost:1313/notes/minion-stands-alone/?utm_source=atom_feed" rel="related" type="text/html" title="第十天 - Minion Stands Alone" />
                <link href="http://localhost:1313/notes/use-spark-to-read-hbase/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Spark 读取 HBase" />
                <link href="http://localhost:1313/rakulang/66.system-interaction/?utm_source=atom_feed" rel="related" type="text/html" title="系统交互" />
                <link href="http://localhost:1313/notes/reduction-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 10/25. Raku 中的化简运算符" />
            
                <id>http://localhost:1313/rakulang/67.traits/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-11T21:13:31+08:00</published>
            <updated>2018-12-11T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>在 Raku 中，<em>traits</em>是附加到对象和类的编译器钩子，它们修改了类和对象的默认行为，功能或表示。作为这样的编译器钩子，它们是在编译时定义的，尽管它们可以用于运行时。</p>
<p>通过使用 <code>trait_mod</code> 关键字，已经将几个 traits 定义为语言或 Rakudo 编译器的一部分。接下来列出并解释它们。</p>
<h1 id="is-traithttpsdocsrakuorglanguagetraits___top"><a href="https://docs.raku.org/language/traits#___top">is trait</a></h1>
<p>定义为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">trait_mod</span><span class="o">:</span><span class="p">&lt;</span><span class="s">is</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$</span><span class="o">,</span> <span class="o">|</span><span class="p">)</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
</span></span></code></pre></div><p><code>is</code> 适用于任何类型的标量对象，并且可以接收任意数量的命名参数或位置参数。它是最常用的 trait，取决于第一个参数的类型，采用以下形式。</p>
<h2 id="is-应用于类httpsdocsrakuorglanguagetraits___top"><a href="https://docs.raku.org/language/traits#___top"><code>is</code> 应用于类</a></h2>
<p>最常见的形式涉及两个类，一个正在定义，另一个现有，定义为 <a href="https://docs.raku.org/syntax/is">defines parenthood</a>。  <code>A is B</code>, 如果两个都是类，则将 A 定义为 B 的子类。</p>
<p><code>is DEPRECATED</code> 可以应用于类，属性或例程，将它们标记为已弃用并发出警告消息（如果提供了的话）。</p>
<p><code>is</code> 的几个实例被直接转换为它们引用的类的属性：<code>rw</code>，<code>nativesize</code>，<code>ctype</code>，<code>unsigned</code>，<code>hidden</code>，<code>array_type</code>。</p>
<p>不可实例化的表示 trait 与表示没有多大关系，与特定类可以做什么有关; 它有效地防止以任何可能的方式创建类的实例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">constant</span> <span class="nv">@IMM</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">Innie Minnie Moe</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">don&#39;t-instantiate</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">Uninstantiable</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$.counter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">imm</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">@IMM</span><span class="o">[</span> <span class="nv">$.counter</span><span class="o">++</span> <span class="ow">mod</span> <span class="nv">@IMM</span><span class="o">.</span><span class="nb">elems</span> <span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">don&#39;t-instantiate</span><span class="o">.</span><span class="nf">imm</span> <span class="k">for</span> <span class="o">^</span><span class="mi">10</span><span class="p">;</span>
</span></span></code></pre></div><p>不能实例化的类仍然可以通过它们的类变量和方法使用, 如上所示。尝试这样: <code>my $do-instantiate = don't-instantiate.new;</code> 来实例化它们会产生错误。</p>
<h2 id="is-repr-和原生表示httpsdocsrakuorglanguagetraits___top"><a href="https://docs.raku.org/language/traits#___top"><code>is repr</code> 和原生表示</a></h2>
<p>由于 <code>is</code> trait 通常指的是它们所应用的类或对象的性质，因此它们在<a href="(https://docs.raku.org/language/nativecall)">原生调用</a>中被广泛使用，以指定将由原生函数通过 <code>is repr</code> 后缀处理的数据结构的<a href="https://docs.raku.org/language/nativecall#Specifying_the_native_representation">表示</a>。同时，<code>is native</code> 用于通过原生函数实际实现的例程。这些是可以使用的表示：</p>
<ul>
<li>CStruct 对应于 C 语言中的 <code>struct</code>。它是一种复合数据结构，包括不同的异构和低级数据结构;请参阅<a href="https://docs.raku.org/language/nativecall#Structs">此示例</a>和进一步说明。</li>
<li>类似地，CPPStruct 对应于 C++ 中的 <code>struct</code>。但是，这是暂时是 Rakudo 特定的。</li>
<li>CPointer 是任何这些语言的指针。它是一个动态数据结构，必须在使用之前进行实例化，可<a href="https://docs.raku.org/language/nativecall#Basic_use_of_pointers">用于</a>其方法也是原生的类。</li>
<li>CUnion 将使用与 C 中的 <code>union</code> 相同的表示形式; 看一下<a href="https://docs.raku.org/language/nativecall#CUnions">这个例子</a>。</li>
</ul>
<p>另一方面，P6opaque 是用于 Raku 中所有对象的默认表示。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Thar</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Thar</span><span class="o">.</span><span class="nf">REPR</span><span class="p">;</span>    <span class="c1">#OUTPUT: «P6opaque␤» </span>
</span></span></code></pre></div><p>除非另有说明，否则<a href="https://docs.raku.org/language/mop">元对象协议</a>默认对每个对象和类使用它;因此，除非您有效地使用该接口，否则通常没有必要。</p>
<h2 id="is-作用于例程httpsdocsrakuorglanguagetraits___top"><a href="https://docs.raku.org/language/traits#___top"><code>is</code> 作用于例程</a></h2>
<p><code>is</code> trait 可用于定义方法和例程以建立<a href="https://docs.raku.org/language/functions#Precedence">优先级</a>和<a href="https://docs.raku.org/language/functions#Associativity">关联性</a>。它们充当使用 <a href="https://docs.raku.org/type/Sub#Traits">trait_mod</a> 定义的子元素，该元素将要添加的 trait 的类型和名称作为参数。在子例程的情况下，trait 将是添加跨越类和角色层次结构的功能的一种方式，或者甚至可以用于向独立定义的例程添加行为。s</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[系统交互]]></title>
            <link href="http://localhost:1313/rakulang/66.system-interaction/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/reduction-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 10/25. Raku 中的化简运算符" />
                <link href="http://localhost:1313/notes/add-a-theme-system-to-your-mojolicious-app/?utm_source=atom_feed" rel="related" type="text/html" title="第九天 - 为你的 Mojolicious 应用添加主题系统" />
                <link href="http://localhost:1313/rakulang/65.syntax/?utm_source=atom_feed" rel="related" type="text/html" title="语法" />
                <link href="http://localhost:1313/notes/more-one-x/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 9/25. 关于 X 的更多东西, Raku 中的 .. 和 …" />
                <link href="http://localhost:1313/notes/authenticating-with-ldap/?utm_source=atom_feed" rel="related" type="text/html" title="第八天 - 使用 LDAP 进行身份验证" />
            
                <id>http://localhost:1313/rakulang/66.system-interaction/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-10T21:13:31+08:00</published>
            <updated>2018-12-10T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="通过命令行获取参数httpsdocsrakuorglanguagesystem___top"><a href="https://docs.raku.org/language/system#___top">通过命令行获取参数</a></h1>
<p>最简单的方法是使用 <a href="https://docs.raku.org/language/variables#%2524%252AARGS"><code>@*ARGS</code></a> 变量从命令行获取参数;此数组将包含程序名称后面的字符串。 <a href="https://docs.raku.org/language/variables#Runtime_environment"><code>%*ENV</code></a> 将包含环境变量，因此如果您使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">export</span> <span class="n">API_KEY</span><span class="o">=</span><span class="mi">1967196417966160761</span><span class="n">fabc1511067</span>
</span></span><span class="line"><span class="cl"><span class="o">./</span><span class="n">consume_api</span><span class="o">.</span><span class="nf">p6</span>
</span></span></code></pre></div><p>您可以通过以下方式在程序中使用它们：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$api-key</span> <span class="o">=</span> <span class="vg">%*ENV</span><span class="p">&lt;</span><span class="s">API_KEY</span><span class="p">&gt;</span> <span class="o">//</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Need the API key</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>如果先前未定义环境变量 <code>API_KEY</code>，则此操作将失败。</p>
<p>Raku 有一个更好的方法来处理命令行参数，如果它们代表文件名：那么使用 <a href="https://docs.raku.org/language/variables#%2524%252AARGFILES"><code>$*ARGFILES</code></a> 动态变量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="vg">$*ARGFILES</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$l</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Long lines in </span><span class="p">{</span><span class="vg">$*ARGFILES</span><span class="o">.</span><span class="nb">path</span><span class="p">}&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nv">$l</span><span class="o">.</span><span class="nb">chars</span> <span class="o">&gt;</span> <span class="mi">72</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>例如，你可以用 <code>argf​​iles.p6 *.p6</code> 的方式运行这个程序，每次找到一个超过72个字符的行时，它就会打印一个文件名。 <code>$*ARGFILES</code> 包含命令行中描述的所有文件的文件句柄 -  <code>.lines</code> 将依次读取每行文件的一行，每次处理新句柄时都会更改 <code>$*ARGFILES.path</code> 的值。通常，它为处理文件集的脚本提供了非常方便的 API。</p>
<h1 id="以交互方式获取参数httpsdocsrakuorglanguagesystem___top"><a href="https://docs.raku.org/language/system#___top">以交互方式获取参数</a></h1>
<p>使用 <code>prompt</code> 让一个正在运行的程序向用户查询数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">UInt</span> <span class="nv">$num-iters</span> <span class="o">=</span> <span class="nb">prompt</span> <span class="p">&#34;</span><span class="s2">How many iterations to run: </span><span class="p">&#34;;</span>
</span></span></code></pre></div><h1 id="同步和异步运行程序httpsdocsrakuorglanguagesystem___top"><a href="https://docs.raku.org/language/system#___top">同步和异步运行程序</a></h1>
<p>运行外部程序有两个例程：<a href="https://docs.raku.org/routine/run"><code>run</code></a> 和 <a href="https://docs.raku.org/routine/shell"><code>shell</code></a>。两者都存在于 <a href="https://docs.raku.org/type/IO"><code>IO</code></a> 角色中，因此包含在混合该角色的所有类中，如 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a>。两者都返回一个 <a href="https://docs.raku.org/type/Proc">Proc</a> 对象，但主要区别在于 <code>run</code> 会尽可能避免系统 shell，而 <code>shell</code> 会通过默认系统 shell 运行命令。</p>
<p>运行所有外部程序的关键类是 <a href="https://docs.raku.org/type/Proc::Async">Proc::Async</a>，它以异步方式运行进程，并允许与正在运行的进程进行<a href="https://docs.raku.org/language/concurrency#Proc%3A%3AAsync">并发</a>交互。通常，通过这些高级抽象接口与系统进行交互是一种很好的做法。但是，Raku 提供了通过低级接口与系统交互的其他方式。</p>
<h1 id="通过原生-api-进行操作系统调用httpsdocsrakuorglanguagesystem___top"><a href="https://docs.raku.org/language/system#___top">通过原生 API 进行操作系统调用</a></h1>
<p><a href="https://docs.raku.org/language/nativecall"><code>NativeCall</code></a> 可用于与系统库以及任何其他可访问库进行交互。这个<a href="(https://docs.raku.org/language/nativecall#Short_tutorial_on_calling_a_C_function)">简短的教程</a>解释了，例如，如何使用该接口调用系统函数，如 <code>getaddrinfo</code>;通过使用 NativeCall 接口的声明，也可以通过这种方式访问​​其他一些函数，例如 <a href="https://docs.raku.org/language/5to6-perlfunc#kill"><code>kill</code></a>。</p>
<p>幸运的是，您不必为所有原生功能执行此操作。作为将 Perl 5 作为生态系统的一部分移植到 Raku 的蝴蝶项目的一部分，<a href="https://github.com/lizmat">Elizabeth Mattijsen</a> 正在将许多系统功能移植到 <a href="https://github.com/lizmat/P5getprotobyname"><code>P5getprotobyname</code></a> 等模块中，这些功能包括 <code>endprotoent</code>，<code>getprotoent</code>，<code>getprotobyname</code> 等功能。 <code>getprotobynumber</code> 和 <code>setprotoent</code>。如果要使用p6y形式的那些功能，请搜索并安装<a href="https://modules.raku.org/search/?q=p5">P5模块</a>。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[语法]]></title>
            <link href="http://localhost:1313/rakulang/65.syntax/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/more-one-x/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 9/25. 关于 X 的更多东西, Raku 中的 .. 和 …" />
                <link href="http://localhost:1313/notes/authenticating-with-ldap/?utm_source=atom_feed" rel="related" type="text/html" title="第八天 - 使用 LDAP 进行身份验证" />
                <link href="http://localhost:1313/rakulang/64.subscripts/?utm_source=atom_feed" rel="related" type="text/html" title="下标" />
                <link href="http://localhost:1313/notes/adding-up-even-fibonacci-numbers-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 8/25. 在 Raku 中加总偶数斐波纳契数" />
                <link href="http://localhost:1313/notes/metacpan-mojolicious-and-openapi/?utm_source=atom_feed" rel="related" type="text/html" title="第七天 - MetaCPAN, Mojolicious 和 OpenAPI" />
            
                <id>http://localhost:1313/rakulang/65.syntax/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-09T21:13:31+08:00</published>
            <updated>2018-12-09T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>Raku 借用了人类语言中的许多概念。考虑到它是由语言学家设计的，这并不奇怪。</p>
<p>它重用不同语境中的共同元素，具有名词（术语）和动词（运算符）的概念，是上下文敏感的（在日常意义上，不一定在计算机科学解释中），因此符号可以具有不同的含义取决于名词或动词是否是预期的。</p>
<p>它也是自同步的，因此解析器可以检测大多数常见错误并提供良好的错误消息。</p>
<h2 id="词法约定">词法约定</h2>
<p>Raku 代码是 Unicode 文本。当前的实现支持 UTF-8 作为输入编码。</p>
<p>也参阅 <a href="https://docs.raku.org/language/unicode_ascii">Unicode versus ASCII symbols</a>.</p>
<h3 id="自由形式">自由形式</h3>
<p>Raku 代码也是自由格式的，从某种意义上说，你可以自由选择你使用的空格量，尽管在某些情况下，空格的存在与否具有意义。</p>
<p>所以你可以写</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="kt">True</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>或</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">    <span class="k">if</span> <span class="kt">True</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;;</span> <span class="c1"># Bad indentation intended </span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span></code></pre></div><p>或</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="kt">True</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span></code></pre></div><p>或者甚至</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="kt">True</span> <span class="p">{</span><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;}</span>
</span></span></code></pre></div><p>虽然你不能省略任何剩余的空白。</p>
<h3 id="unspace">Unspace</h3>
<p>在编译器不允许空格的许多地方，只要用反斜杠引用，就可以使用任意数量的空格。不支持 token 中的空格。当编译器生成行号时，未空格的换行仍然计算。用于非空格的用例是后缀运算符和例程参数列表的分离。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">alignment</span><span class="p">(</span><span class="o">+</span><span class="nv">@l</span><span class="p">)</span> <span class="p">{</span> <span class="o">+</span><span class="nv">@l</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">long-name-alignment</span><span class="p">(</span><span class="o">+</span><span class="nv">@l</span><span class="p">)</span> <span class="p">{</span> <span class="o">+</span><span class="nv">@l</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">alignment</span>\         <span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">long-name-alignment</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="p">)</span>\   <span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="no">Inf</span><span class="o">+</span><span class="no">Inf</span>\<span class="no">i</span><span class="p">;</span>
</span></span></code></pre></div><p>在这种情况下，我们的目的是让 <code>.</code> 两个语句以及括号都对齐，所以我们在用于填充的空格之前加上 <code>\</code>。</p>
<h3 id="用分号分割语句">用分号分割语句</h3>
<p>Raku 程序是一组由分号 <code>;</code> 分割的语句。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">world</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>最后一个语句之后（或在块内的最终语句之后）的分号是可选的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">world</span><span class="p">&#34;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="kt">True</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">world</span><span class="p">&#34;</span>
</span></span></code></pre></div><h3 id="隐式分隔符规则对于以块结尾的语句">隐式分隔符规则（对于以块结尾的语句）</h3>
<p>以裸块结尾的完整语句可以省略尾随分号，如果同一行上没有其他语句跟随块的结束大括号 <code>}</code>。 这称为“隐式分隔符规则”。例如，您不需要在 <code>if</code> 语句块之后写一个分号，如上所示，以及下面所示。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="kt">True</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">world</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>但是，需要使用分号将块与同一行中的尾随语句分开。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="kt">True</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;</span> <span class="p">};</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">world</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#                     ^^^ this ; is required </span>
</span></span></code></pre></div><p>此隐式语句分隔符规则除了控制语句之外还以其他方式应用，可能以裸块结束。例如，结合冒号：方法调用的语法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">Foo Bar Baz</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@upper-case-names</span> <span class="o">=</span> <span class="nv">@names</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span> <span class="o">.</span><span class="nb">uc</span> <span class="p">}</span>    <span class="c1"># OUTPUT: [FOO BAR BAZ] </span>
</span></span></code></pre></div><p>对于属于同一 <code>if/elsif/else</code>（或类似）构造的一系列块，隐式分隔符规则仅适用于该系列的最后一个块的末尾。这三个是等价的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="kt">True</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Goodbye</span><span class="p">&#34;</span> <span class="p">};</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">world</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#                                            ^^^ this ; is required </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="kt">True</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Goodbye</span><span class="p">&#34;</span> <span class="p">}</span> <span class="c1"># &lt;- implied statement separator </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">world</span><span class="p">&#34;;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="kt">True</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;</span> <span class="p">}</span>   <span class="c1"># still in the middle of an if/else statement </span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>    <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Goodbye</span><span class="p">&#34;</span> <span class="p">}</span> <span class="c1"># &lt;- no semicolon required because it ends in a block </span>
</span></span><span class="line"><span class="cl">                          <span class="c1">#    without trailing statements in the same line </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">world</span><span class="p">&#34;;</span>
</span></span></code></pre></div><h3 id="注释">注释</h3>
<p>注释是程序文本的一部分，仅供人类读者阅读; Raku 编译器不会将它们当作程序文本。</p>
<p>在缺少或存在空白消除可能的解析的地方，注释计为空格。</p>
<h4 id="单行注释">单行注释</h4>
<p>Raku 中最常见的注释形式以单个哈希字符 <code>#</code> 开头，直到该行的结尾。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$age</span> <span class="o">&gt;</span> <span class="mi">250</span> <span class="p">{</span>     <span class="c1"># catch obvious outliers </span>
</span></span><span class="line"><span class="cl">    <span class="c1"># this is another comment! </span>
</span></span><span class="line"><span class="cl">    <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">That doesn&#39;t look right</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="多行--嵌套注释">多行 / 嵌套注释</h4>
<p>多行和嵌入式注释以井号字符开头，然后是反引号，然后是一些开口括号字符，并以匹配的闭合括号字符结束。内容不仅可以跨越多行，还可以嵌入内联。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="cm">#`( why would I ever write an inline comment here? )</span> <span class="kt">True</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">something stupid</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这些注释可以扩展到多行</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="cm">#`[
</span></span></span><span class="line"><span class="cl"><span class="cm">And this is how a multi would work.
</span></span></span><span class="line"><span class="cl"><span class="cm">That says why we do what we do below.
</span></span></span><span class="line"><span class="cl"><span class="cm">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No more</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>注释中的大括号可以嵌套，因此在  #<code>{ a { b } c }, 中，注释一直持续到字符串的最后。 您也可以使用多个花括号，例如 #</code>{{ double-curly-brace }}，这可能有助于消除嵌套分隔符的歧义。 您可以在表达式中嵌入这些注释，只要不将它们插入关键字或标识符的中间即可。</p>
<h4 id="pod-注释">Pod 注释</h4>
<p>Pod 语法可用于多行注释</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">this is code</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">=begin</span><span class="sd"> </span><span class="k">comment</span><span class="sd">
</span></span></span><span class="line"><span class="cl"><span class="sd"> 
</span></span></span><span class="line"><span class="cl"><span class="sd">Here are several
</span></span></span><span class="line"><span class="cl"><span class="sd">lines
</span></span></span><span class="line"><span class="cl"><span class="sd">of comment
</span></span></span><span class="line"><span class="cl"><span class="sd"> 
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">=end comment</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">code again</span><span class="p">&#39;;</span>
</span></span></code></pre></div><h3 id="标识符">标识符</h3>
<p>标识符是语法构建块，可用于为实体/对象赋予名称，例如常量，变量（例如标量）和例程（例如，Subs 和方法）。在变量名中，任何sigil（和twigil）都在标识符之前，并且不形成其一部分。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">constant</span> <span class="no">c</span> <span class="o">=</span> <span class="mi">299792458</span><span class="p">;</span>     <span class="c1"># identifier &#34;c&#34; names an Int </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>                <span class="c1"># identifier &#34;a&#34; in the name &#34;$a&#34; of a Scalar </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">hello</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello!</span><span class="p">&#34;</span> <span class="p">};</span> <span class="c1"># identifier &#34;hello&#34; names a Sub </span>
</span></span></code></pre></div><p>标识符有不同的形式：普通标识符，扩展标识符和复合标识符。</p>
<h4 id="普通标识符">普通标识符</h4>
<p>普通标识符由前导字母字符组成，后面可以跟着一个或多个字母数字字符。它也可能包含单独的，嵌入的撇号 <code>'</code> 和/或连字符 <code>-</code>,  前提是下一个字符每次都是字母。</p>
<p>“字母”和“字母数字”的定义包括适当的 Unicode 字符。哪些字符“合适”取决于实现。在 Rakudo/MoarVM Raku 实现中，字母字符包括具有 Unicode 通用类别值 Letter(L) 和下划线 <code>_</code> 的字符。字母数字字符还包括具有 Unicode 通用类别值编号，十进制数字(Nd) 的字符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># valid ordinary identifiers: </span>
</span></span><span class="line"><span class="cl"><span class="nb">x</span>
</span></span><span class="line"><span class="cl"><span class="n">_snake_oil</span>
</span></span><span class="line"><span class="cl"><span class="n">something-longer</span>
</span></span><span class="line"><span class="cl"><span class="n">with-numbers1234</span>
</span></span><span class="line"><span class="cl"><span class="n">don&#39;t-do-that</span>
</span></span><span class="line"><span class="cl"><span class="n">piece_of_π</span>
</span></span><span class="line"><span class="cl"><span class="n">駱駝道</span>              <span class="c1"># &#34;Rakuda-dō&#34;, Japanese for &#34;Way of the camel&#34; </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># invalid ordinary identifiers: </span>
</span></span><span class="line"><span class="cl"><span class="mi">42</span>                 <span class="c1"># identifier does not start with alphabetic character </span>
</span></span><span class="line"><span class="cl"><span class="n">with-numbers1234-5</span> <span class="c1"># embedded hyphen not followed by alphabetic character </span>
</span></span><span class="line"><span class="cl"><span class="nb">is-prime</span><span class="o">?</span>          <span class="c1"># question mark is not alphanumeric </span>
</span></span><span class="line"><span class="cl"><span class="nb">x</span>²                 <span class="c1"># superscript 2 is not alphanumeric (explained above) </span>
</span></span></code></pre></div><h4 id="扩展标识符">扩展标识符</h4>
<p>使名称包含普通标识符中不允许的字符通常很方便。用例包括一组实体共享一个共同的“短”名称但仍需要单独识别其每个元素的情况。例如，您可以使用短名称为 <code>Dog</code> 的模块，而其长名称包括其命名所有权和版本号：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">Dog</span><span class="p">:</span><span class="na">auth</span><span class="p">&lt;</span><span class="s">Somebody</span><span class="p">&gt;:</span><span class="na">ver</span><span class="p">&lt;</span><span class="s">1.0</span><span class="p">&gt;</span>  <span class="c1"># long module names including author and version </span>
</span></span><span class="line"><span class="cl"><span class="n">Dog</span><span class="p">:</span><span class="na">auth</span><span class="p">&lt;</span><span class="s">Somebody</span><span class="p">&gt;:</span><span class="na">ver</span><span class="p">&lt;</span><span class="s">2.0</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Dog</span><span class="p">:</span><span class="na">auth</span><span class="p">&lt;</span><span class="s">Somebody</span><span class="p">&gt;:</span><span class="na">ver</span><span class="p">&lt;</span><span class="s">2.0</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Selection of second module causes its full name to be aliased to the </span>
</span></span><span class="line"><span class="cl"><span class="c1"># short name for the rest of # the lexical scope, allowing a declaration </span>
</span></span><span class="line"><span class="cl"><span class="c1"># like this. </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">Dog</span> <span class="nv">$spot</span> <span class="o">.=</span> <span class="nb">new</span><span class="p">(&#34;</span><span class="s2">woof</span><span class="p">&#34;);</span>
</span></span></code></pre></div><p>类似地，运算符集在各种语法类别中一起工作，其名称如 prefix，infix 和 postfix。这些运算符的官方名称通常包含从普通标识符中排除的字符。长名称是扩展标识符的构成，包括这个句法类别;短名称将包含在定义中的引号中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;</span>                 <span class="c1"># the official name of the operator in $a + $b </span>
</span></span><span class="line"><span class="cl"><span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">*</span><span class="p">&gt;</span>                 <span class="c1"># the official name of the operator in $a * $b </span>
</span></span><span class="line"><span class="cl"><span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=</span><span class="p">»</span>                <span class="c1"># the official name of the operator in $a &lt;= $b </span>
</span></span></code></pre></div><p>对于所有此类用途，您可以将一个或多个冒号分隔的字符串附加到普通标识符，以创建所谓的扩展标识符。 附加到标识符（即后缀位置）时，此冒号分隔的字符串会生成该标识符的唯一变体。</p>
<p>这些字符串的格式为 <code>:key&lt;value&gt;</code>，其中 key 或 value 是可选的; 也就是说，在将它与常规标识符分开的冒号之后，将存在一个键和/或引用包围结构，例如 &lt;&gt;，«» 或 [&rsquo; &lsquo;]，它引用一个或多个任意字符值。[1]</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># exemplary valid extended identifiers: </span>
</span></span><span class="line"><span class="cl"><span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">²</span><span class="p">&gt;</span>               <span class="c1"># the official long name of the operator in $x² </span>
</span></span><span class="line"><span class="cl"><span class="n">WOW:That&#39;sAwesome</span>
</span></span><span class="line"><span class="cl"><span class="n">WOW</span><span class="p">:</span><span class="na">That&#39;s</span><span class="p">&lt;&lt;</span><span class="s2">🆒</span><span class="p">&gt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">party</span><span class="p">:</span><span class="na">sweet</span><span class="p">&lt;</span><span class="s">16</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># exemplary invalid extended identifiers: </span>
</span></span><span class="line"><span class="cl"><span class="n">party</span><span class="p">:</span><span class="na">16</span><span class="p">&lt;</span><span class="s">sweet</span><span class="p">&gt;</span>           <span class="c1"># 16 is not an ordinary identifier </span>
</span></span><span class="line"><span class="cl"><span class="nf">party:16sweet</span>
</span></span><span class="line"><span class="cl"><span class="n">party:</span><span class="o">!</span><span class="n">a</span>                  <span class="c1"># ...and neither is !a </span>
</span></span><span class="line"><span class="cl"><span class="n">party:</span><span class="nv">$a</span>                  <span class="c1"># ...nor $a </span>
</span></span></code></pre></div><p>在扩展标识符中，后缀字符串被视为名称的组成部分，因此 <code>infix:&lt;+&gt;</code> 和 <code>infix:&lt;-&gt;</code> 是两个不同的运算符。但是，使用的包围字符不算作其中的一部分;只有引用的数据很重要。所以这些都是同一个名字：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2">+</span><span class="p">&gt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">+</span><span class="p">»</span>
</span></span><span class="line"><span class="cl"><span class="nb">infix</span><span class="o">:[</span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">infix</span><span class="o">:</span><span class="p">(&#39;</span><span class="s1">+</span><span class="p">&#39;)</span>
</span></span></code></pre></div><p>同样，所有这些都有效：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$foo</span><span class="p">:</span><span class="na">bar</span><span class="p">&lt;</span><span class="s">baz</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">quux</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$foo</span><span class="p">:</span><span class="na">bar</span><span class="p">«</span><span class="s2">baz</span><span class="p">»;</span>                               <span class="c1"># OUTPUT: «quux␤» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$take-me:</span><span class="p">&lt;</span><span class="s">home</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Where the glory has no end</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$take-me:</span><span class="o">[</span><span class="p">&#39;</span><span class="s1">home</span><span class="p">&#39;</span><span class="o">]</span><span class="p">;</span>                           <span class="c1"># OUTPUT: «Where [...]␤» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$foo</span><span class="p">:</span><span class="na">bar</span><span class="p">&lt;</span><span class="s">2</span><span class="p">&gt;</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$foo</span><span class="p">:</span><span class="na">bar</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>                               <span class="c1"># OUTPUT: «5␤» </span>
</span></span></code></pre></div><p>如果扩展标识符包含两个或更多个冒号对，则它们的顺序通常很重要：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span><span class="p">:</span><span class="na">b</span><span class="p">&lt;</span><span class="s">c</span><span class="p">&gt;:</span><span class="na">d</span><span class="p">&lt;</span><span class="s">e</span><span class="p">&gt;</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span><span class="p">:</span><span class="na">d</span><span class="p">&lt;</span><span class="s">e</span><span class="p">&gt;:</span><span class="na">b</span><span class="p">&lt;</span><span class="s">c</span><span class="p">&gt;</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="p">:</span><span class="na">b</span><span class="p">&lt;</span><span class="s">c</span><span class="p">&gt;:</span><span class="na">d</span><span class="p">&lt;</span><span class="s">e</span><span class="p">&gt;;</span>               <span class="c1"># OUTPUT: «100␤», NOT: «200␤» </span>
</span></span></code></pre></div><p>此规则的一个例外是模块版本控制;所以这些标识符有效地命名相同的模块：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">ThatModule</span><span class="p">:</span><span class="na">auth</span><span class="p">&lt;</span><span class="s">Somebody</span><span class="p">&gt;:</span><span class="na">ver</span><span class="p">&lt;</span><span class="s">2.7.18.28.18</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">ThatModule</span><span class="p">:</span><span class="na">ver</span><span class="p">&lt;</span><span class="s">2.7.18.28.18</span><span class="p">&gt;:</span><span class="na">auth</span><span class="p">&lt;</span><span class="s">Somebody</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>此外，扩展标识符支持编译时插值;这需要使用常量作为插值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">constant</span> <span class="nv">$c</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>  <span class="c1"># Constant binds to Int; $-sigil enables interpolation </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span><span class="p">:</span><span class="na">foo</span><span class="p">&lt;</span><span class="s">42</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">answer</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="p">:</span><span class="na">foo</span><span class="p">«</span><span class="nv">$c</span><span class="p">»;</span>    <span class="c1"># OUTPUT: «answer␤» </span>
</span></span></code></pre></div><p>虽然引用包围结构在标识符的上下文中通常是可互换的，但它们并不相同。特别是，尖括号 <code>&lt;&gt;</code>（模仿单引号插值特征）不能用于常量名称的插值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">constant</span> <span class="nv">$what</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">are</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@we:</span><span class="p">&lt;</span><span class="s">are</span><span class="p">&gt;</span><span class="o">=</span> <span class="p">&lt;</span><span class="s">the champions</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@we:</span><span class="p">«</span><span class="nv">$what</span><span class="p">»;</span>     <span class="c1"># OUTPUT: «[the champions]␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@we:</span><span class="p">&lt;</span><span class="s">$what</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Compilation error: Variable &#39;@we:&lt;$what&gt;&#39; is not declared </span>
</span></span></code></pre></div><h4 id="组合标识符">组合标识符</h4>
<p>复合标识符是由两个或多个普通和/或扩展标识符组成的标识符，这些标识符通过双冒号 <code>::</code> 彼此分开。</p>
<p>双冒号 <code>::</code> 被称为命名空间分隔符或包分隔符，它在名称中阐明了它的语义功能：强制将名称的前一部分视为包名/命名空间，名称的后续部分通过该包/命名空间位于：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">module</span> <span class="nn">MyModule</span> <span class="p">{</span>               <span class="c1"># declare a module package </span>
</span></span><span class="line"><span class="cl">    <span class="k">our</span> <span class="nv">$var</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;;</span>         <span class="c1"># declare package-scoped variable </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$MyModule::var</span>              <span class="c1"># OUTPUT: «Hello␤» </span>
</span></span></code></pre></div><p>在上面的示例中，<code>MyModule::var</code> 是一个复合标识符，由包名称标识符 <code>MyModule</code> 和变量名称 <code>var</code> 的标识符部分组成。加在一块, <code>$MyModule::var</code> 通常被称为包限定名。</p>
<p>使用双冒号分隔标识符会导致最右边的名称插入到现有包（参见上面的示例）或自动创建的包中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$foo::bar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">OUR::</span><span class="o">.</span><span class="nb">keys</span><span class="p">;</span>           <span class="c1"># OUTPUT: «(foo)␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">OUR::foo</span><span class="o">.</span><span class="nb">HOW</span>          <span class="c1"># OUTPUT: «Raku::Metamodel::PackageHOW.new␤» </span>
</span></span></code></pre></div><p>最后几行显示了如何自动创建 <code>foo</code> 包，作为该命名空间中变量的存放。</p>
<p>双冒号语法允许使用 <code>::($expr)</code> 将字符串运行时插入到包或变量名中，您通常会在其中放置包或变量名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$buz</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">quux</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$bur::quux</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$bur::</span><span class="p">(</span><span class="nv">$buz</span><span class="p">);</span>               <span class="c1"># OUTPUT: «7␤» </span>
</span></span></code></pre></div><h3 id="项-term">项 term:&lt;&gt;</h3>
<p>您可以使用 <code>term:&lt;&gt;</code> 来引入新的项，这对于引入违反常规标识符规则的常量非常方便：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">Test</span><span class="p">;</span> <span class="nb">plan</span> <span class="mi">1</span><span class="p">;</span> <span class="k">constant</span> <span class="nv">&amp;term:</span><span class="p">&lt;</span><span class="s">👍</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nv">&amp;ok</span><span class="o">.</span><span class="nb">assuming</span><span class="p">(</span><span class="kt">True</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">👍
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «1..1␤ok 1 - ␤» </span>
</span></span></code></pre></div><p>但是项不必是常量：您也可以将它们用于不带任何参数的函数，并强制解析器在它们之后期望运算符。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">term</span><span class="o">:</span><span class="p">&lt;</span><span class="s">dice</span><span class="p">&gt;</span> <span class="p">{</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="nb">pick</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">dice</span> <span class="o">+</span> <span class="n">dice</span><span class="p">;</span>
</span></span></code></pre></div><p>可以打印 2 到 12 之间的任何数字。</p>
<p>相反，我们已经声明 dice 为常规子例程</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">dice</span><span class="p">()</span> <span class="p">{(</span><span class="mi">1</span><span class="o">...</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="nb">pick</span> <span class="p">}</span>
</span></span></code></pre></div><p>表达式 <code>dice + dice</code> 将被解析为 <code>dice(+(dice()))</code>，导致错误，因为子 <code>dice</code> 需要零个参数。</p>
<h2 id="语句和表达式">语句和表达式</h2>
<p>Raku 程序由一组组成。语句的一个特例是表达式，它返回一个值。例如，<code> if True { say 42 }</code> 在语法上是一个语句，而不是一个表达式，而 <code>1 + 2</code> 是一个表达式（因此也是一个语句）。</p>
<p><code>do</code> 前缀将语句转换为表达式。所以虽然</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="k">if</span> <span class="kt">True</span> <span class="p">{</span> <span class="mi">42</span> <span class="p">};</span>     <span class="c1"># Syntax error! </span>
</span></span></code></pre></div><p>是一个错误,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="nb">do</span> <span class="k">if</span> <span class="kt">True</span> <span class="p">{</span> <span class="mi">42</span> <span class="p">};</span>
</span></span></code></pre></div><p>将 <code>if</code> 语句（此处为 42）的返回值赋给变量 <code>$x</code>。</p>
<h2 id="项">项</h2>
<p>项是基本名词，可选地与运算符一起形成表达式。项的示例是变量（<code>$x</code>），诸如类型名称（Int），字面量（42），声明（<code>sub f() { }</code>）和调用（<code>f()</code>）之类的裸字。</p>
<p>例如，在表达式 <code>2 * $salary</code> 中，<code>2</code> 和 <code>$salary</code> 是两个项（整数字面量和变量）。</p>
<h3 id="变量">变量</h3>
<p>变量通常以称为 sigil 的特殊字符开头，后跟一个标识符。必须先声明变量才能使用它们。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># declaration: </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$number</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># usage: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$number</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span></code></pre></div><p>有关更多详细信息，请参阅变量文档。</p>
<h3 id="裸字-常量类型名">裸字 (常量,类型名)</h3>
<p>预先声明的标识符可以是它们自己的术语。这些通常是类型名称或常量，但也是术语 <code>self</code>，它指的是调用方法的对象（请参阅对象）和无符号变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="kt">Int</span><span class="p">;</span>                <span class="c1"># OUTPUT: «(Int)␤» </span>
</span></span><span class="line"><span class="cl"><span class="c1">#   ^^^ type name (built in) </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">constant</span> <span class="no">answer</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">answer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#   ^^^^^^ constant </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">type-name</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">self</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1"># ^^^^ built-in term &#39;self&#39; </span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Foo</span><span class="o">.</span><span class="nf">type-name</span><span class="p">;</span>     <span class="c1"># OUTPUT: «Foo␤» </span>
</span></span><span class="line"><span class="cl"><span class="c1">#   ^^^ type name </span>
</span></span></code></pre></div><h3 id="包和限定名">包和限定名</h3>
<p>命名实体（如变量，常量，类，模块或子）是命名空间的一部分。名称的嵌套部分使用 <code>::</code> 来分隔层次结构。一些例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$foo</span>                <span class="c1"># simple identifiers </span>
</span></span><span class="line"><span class="cl"><span class="nv">$Foo::Bar::baz</span>      <span class="c1"># compound identifiers separated by :: </span>
</span></span><span class="line"><span class="cl"><span class="nv">$Foo::</span><span class="p">(</span><span class="nv">$bar</span><span class="p">)</span><span class="o">:</span><span class="p">:</span><span class="s">baz</span>   <span class="c1"># compound identifiers that perform interpolations </span>
</span></span><span class="line"><span class="cl"><span class="nf">Foo::Bar::bob</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span>   <span class="c1"># function invocation given qualified name </span>
</span></span></code></pre></div><p>有关更多详细信息，请参阅包中的文档。</p>
<h3 id="字面量">字面量</h3>
<p>字面量是源代码中常量值的表示。 Raku 具有几种内置类型的字面量，如字符串，几种数字类型，pair 对儿等等。</p>
<h4 id="字符串字面量">字符串字面量</h4>
<p>字符串字面量用引号括起来：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a string literal</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">a string literal</span><span class="se">\n</span><span class="s2">that interprets escape sequences</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>请参阅引用以获取更多选项，包括转义引用 <code>q</code>。 Raku 在字面量中使用标准转义字符 \a \b \t \n \f \r \e, 与设计文档中指定的 ASCII 转义码具有相同的含义。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">🔔</span><span class="se">\a</span><span class="p">&#34;;</span>  <span class="c1"># OUTPUT: «🔔␇␤» </span>
</span></span></code></pre></div><h4 id="数字字面量">数字字面量</h4>
<p>数字字面量通常用十进制表示（除非前缀为 <code>0x</code>（十六进制，基数为16），<code>0o</code>（八进制，基数为8）或 <code>0b</code>（二进制，基数为2），否则可以通过前缀0d逐字地使用（如果需要，可以使用前缀 <code>0d</code>）。 ）或状语符号中的显式基数，如 <code>:16&lt;A0&gt;</code> 另有说明。与其他编程语言不同，前导零不表示基数 8;而是发出编译时警告。</p>
<p>在所有字面量格式中，你可以使用下划线来分组数字;他们没有任何语义信息;以下字面量都计算为相同的数字：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">1000000</span>
</span></span><span class="line"><span class="cl"><span class="mi">1_000_000</span>
</span></span><span class="line"><span class="cl"><span class="mi">10_00000</span>
</span></span><span class="line"><span class="cl"><span class="mi">100_00_00</span>
</span></span></code></pre></div><h5 id="int-字面量">Int 字面量</h5>
<p>整数默认为有符号十进制的，但您可以使用其他基数。有关详细信息，请参阅 Int。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># actually not a literal, but unary - operator applied to numeric literal 2 </span>
</span></span><span class="line"><span class="cl"><span class="o">-</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">12345</span>
</span></span><span class="line"><span class="cl"><span class="mh">0xBEEF</span>      <span class="c1"># base 16 </span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span><span class="n">o755</span>       <span class="c1"># base 8 </span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="mi">3</span><span class="p">&lt;</span><span class="s">1201</span><span class="p">&gt;</span>    <span class="c1"># arbitrary base, here base 3 </span>
</span></span></code></pre></div><h5 id="rat-字面量">Rat 字面量</h5>
<p>Rat 字面量（有理数）非常常见，取代许多其他语言中的小数或浮点数。整除也会产生 Rat。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mf">1.0</span>
</span></span><span class="line"><span class="cl"><span class="mf">3.14159</span>
</span></span><span class="line"><span class="cl"><span class="o">-</span><span class="mf">2.5</span>        <span class="c1"># Not actually a literal, but still a Rat </span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="mi">3</span><span class="p">&lt;</span><span class="s">21.0012</span><span class="p">&gt;</span> <span class="c1"># Base 3 rational </span>
</span></span><span class="line"><span class="cl">⅔
</span></span><span class="line"><span class="cl"><span class="mi">2</span><span class="o">/</span><span class="mi">3</span>         <span class="c1"># Not actually a literal, but still a Rat </span>
</span></span></code></pre></div><h5 id="num-字面量">Num 字面量</h5>
<p>在 <code>e</code> 产生浮点数后，使用整数指数到十进制的科学记数法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mf">1e0</span>
</span></span><span class="line"><span class="cl"><span class="mf">6.022e23</span>
</span></span><span class="line"><span class="cl"><span class="mf">1e-9</span>
</span></span><span class="line"><span class="cl"><span class="o">-</span><span class="mf">2e48</span>
</span></span><span class="line"><span class="cl"><span class="mf">2e2.5</span>       <span class="c1"># error </span>
</span></span></code></pre></div><h5 id="complex-字面量">Complex 字面量</h5>
<p>复数可以写为虚数（只是附加后缀 <code>i</code> 的有理数），也可以是实数和虚数之和：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="no">i</span>
</span></span><span class="line"><span class="cl"><span class="mf">6.123e5</span><span class="no">i</span>    <span class="c1"># note that this is 6.123e5 * i, not 6.123 * 10 ** (5i) </span>
</span></span></code></pre></div><h4 id="pair-字面量">Pair 字面量</h4>
<p>对由键和值组成，构造它们有两种基本形式：<code>key =&gt; 'value'</code> 和 <code>:key('value')</code>。</p>
<h5 id="arrow-pairs">Arrow pairs</h5>
<p>箭头对可以有一个表达式，一个字符串字面量或一个“裸标识符”，这是一个普通标识符语法的字符串，左侧不需要引号：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="s">like-an-identifier-ain&#39;t-it</span> <span class="o">=&gt;</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">key</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;)</span> <span class="o">=&gt;</span> <span class="mi">1</span>
</span></span></code></pre></div><h5 id="副词对儿-colon-pairs">副词对儿 (colon pairs)</h5>
<p>没有显式值的简短形式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$thing</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span><span class="nv">$thing</span>                 <span class="c1"># same as  thing =&gt; $thing </span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="s">thing</span>                  <span class="c1"># same as  thing =&gt; True </span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="o">!</span><span class="s">thing</span>                 <span class="c1"># same as  thing =&gt; False </span>
</span></span></code></pre></div><p>变量形式也适用于其他符号，例如：<code>:&amp;callback</code> 或 <code>:@elements</code>。如果值是数字字面量，它也可以用这种简短形式表示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">:</span><span class="mi">42</span><span class="s">thing</span>            <span class="c1"># same as  thing =&gt; 42 </span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="mi">٤٢</span><span class="s">thing</span>            <span class="c1"># same as  thing =&gt; 42 </span>
</span></span></code></pre></div><p>如果您使用其他字母，则此顺序将被反转：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">:</span><span class="mi">٤٢</span><span class="s">ث</span>              <span class="c1"># same as   ث =&gt; ٤٢ </span>
</span></span></code></pre></div><p>thaa 字母在数字之前。</p>
<p>具有显式值的长形式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">:</span><span class="s">thing</span><span class="p">(</span><span class="nv">$value</span><span class="p">)</span>              <span class="c1"># same as  thing =&gt; $value </span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="s">thing</span><span class="p">&lt;</span><span class="s">quoted list</span><span class="p">&gt;</span>         <span class="c1"># same as  thing =&gt; &lt;quoted list&gt; </span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="s">thing</span><span class="p">[&#39;</span><span class="s1">some</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">values</span><span class="p">&#39;]</span>    <span class="c1"># same as  thing =&gt; [&#39;some&#39;, &#39;values&#39;] </span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="s">thing</span><span class="p">{</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;}</span>            <span class="c1"># same as  thing =&gt; { a =&gt; &#39;b&#39; } </span>
</span></span></code></pre></div><h4 id="boolean-字面量">Boolean 字面量</h4>
<p>True 和 False 是 Boolean 字面量; 他们始终是首字母大写的。</p>
<h4 id="array-字面量">Array 字面量</h4>
<p>一对方括号可以围绕表达式以形成逐项数组字面量; 通常在里面有一个以逗号分隔的列表：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[</span><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">42</span><span class="o">].</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;);</span>   <span class="c1"># OUTPUT: «a b 42␤» </span>
</span></span><span class="line"><span class="cl"><span class="c1">#   ^^^^^^^^^^^^^^ Array constructor </span>
</span></span></code></pre></div><p>如果构造函数被赋予单个 Iterable，它将克隆并展平它。如果你想要一个只有 1 个 Iterable 元素的数组，请确保在它之后使用逗号：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[</span><span class="nv">@a</span><span class="o">].</span><span class="nb">perl</span><span class="p">;</span>  <span class="c1"># OUTPUT: «[1, 2]␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[</span><span class="nv">@a</span><span class="o">,].</span><span class="nb">perl</span><span class="p">;</span> <span class="c1"># OUTPUT: «[[1, 2],]␤» </span>
</span></span></code></pre></div><p>Array 构造函数不会展平其他类型的内容。使用 Slip 前缀运算符(<code>|</code>)展平所需项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[</span><span class="nv">@a</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">].</span><span class="nb">perl</span><span class="p">;</span>  <span class="c1"># OUTPUT: «[[1, 2], 3, 4]␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[|</span><span class="nv">@a</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">].</span><span class="nb">perl</span><span class="p">;</span> <span class="c1"># OUTPUT: «[1, 2, 3, 4]␤» </span>
</span></span></code></pre></div><h4 id="hash-字面量">Hash 字面量</h4>
<p>一个前导的关联符号和一对括号 <code>%( )</code> 可以包围一对列表以形成一个哈希字面量; 通常在里面有一个以逗号分隔的 Pairs 列表。如果使用非 pair 对，则假定它是一个键，下一个元素是值。大多数情况下，它与简单的箭头对一起使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%</span><span class="p">(</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="o">,</span> <span class="s">b</span> <span class="o">=&gt;</span> <span class="mi">23</span><span class="o">,</span> <span class="p">:</span><span class="s">foo</span><span class="o">,</span> <span class="p">:</span><span class="s">dog</span><span class="p">&lt;</span><span class="s">cat</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">french</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">fries</span><span class="p">&#34;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «a =&gt; 3, b =&gt; 23, dog =&gt; cat, foo =&gt; True, french =&gt; fries␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%</span><span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">73</span><span class="o">,</span> <span class="s">foo</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">fish</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2"> </span><span class="p">&#34;);</span>   <span class="c1"># OUTPUT: «a foo␤» </span>
</span></span><span class="line"><span class="cl"><span class="c1">#   ^^^^^^^^^^^^^^^^^^^^^^^^^ Hash constructor </span>
</span></span></code></pre></div><p>当赋值给左侧的 <code>%</code> sigiled 变量时，右侧 Pairs 周围的符号和括号是可选的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%ages</span> <span class="o">=</span> <span class="s">fred</span> <span class="o">=&gt;</span> <span class="mi">23</span><span class="o">,</span> <span class="s">jean</span> <span class="o">=&gt;</span> <span class="mi">87</span><span class="o">,</span> <span class="s">ann</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
</span></span></code></pre></div><p>默认情况下, <code>%( )</code> 中的键被强制为字符串。要使用非字符串键组合散列，请使用带有冒号前缀的花括号分隔符 <code>:{}</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$when</span> <span class="o">=</span> <span class="o">:</span><span class="p">{</span> <span class="p">(</span><span class="nb">now</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Instant</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">(</span><span class="kt">DateTime</span><span class="o">.</span><span class="nb">now</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">DateTime</span><span class="p">&#34;</span> <span class="p">};</span>
</span></span></code></pre></div><p>请注意，将对象作为键，您不能将非字符串键作为字符串访问：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">:</span><span class="p">{</span> <span class="o">-</span><span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">41</span><span class="o">,</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">43</span> <span class="p">}&lt;</span><span class="s">0</span><span class="p">&gt;;</span>  <span class="c1"># OUTPUT: «(Any)␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">:</span><span class="p">{</span> <span class="o">-</span><span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">41</span><span class="o">,</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">43</span> <span class="p">}{</span><span class="mi">0</span><span class="p">};</span>  <span class="c1"># OUTPUT: «42␤» </span>
</span></span></code></pre></div><h4 id="regex-字面量">Regex 字面量</h4>
<p>使用 <code>/foo/</code> 等斜杠声明正则表达式。请注意，此 <code>//</code> 语法是完整的 <code>rx//</code> 语法的简写。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr">foo</span><span class="p">/</span>          <span class="c1"># Short version </span>
</span></span><span class="line"><span class="cl"><span class="k">rx</span><span class="p">/</span><span class="sr">foo</span><span class="p">/</span>        <span class="c1"># Longer version </span>
</span></span><span class="line"><span class="cl"><span class="n">Q</span> <span class="p">:</span><span class="s">regex</span> <span class="o">/</span><span class="n">foo</span><span class="o">/</span> <span class="c1"># Even longer version</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$r</span> <span class="o">=</span> <span class="p">/</span><span class="sr">foo</span><span class="p">/;</span> <span class="c1"># Regexes can be assigned to variables</span>
</span></span></code></pre></div><h4 id="签名字面量">签名字面量</h4>
<p>除了 sub 和块声明中的典型用法之外，签名可以单独用于模式匹配。从冒号开始声明独立签名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">match!</span><span class="p">&#34;</span> <span class="k">if</span> <span class="mi">5</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">fish</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="o">:</span><span class="p">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Str</span><span class="p">);</span> <span class="c1"># OUTPUT: «match!␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$sig</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Str</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">match!</span><span class="p">&#34;</span> <span class="k">if</span> <span class="p">(</span><span class="mi">5</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">fish</span><span class="p">&#34;)</span> <span class="o">~~</span> <span class="nv">$sig</span><span class="p">;</span> <span class="c1"># OUTPUT: «match!␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">given</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span><span class="o">,</span> <span class="mi">42</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">when</span> <span class="o">:</span><span class="p">(</span><span class="kt">Str</span><span class="o">,</span> <span class="kt">Str</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">This won&#39;t match</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">when</span> <span class="o">:</span><span class="p">(</span><span class="kt">Str</span><span class="o">,</span> <span class="kt">Int</span> <span class="nv">$n</span> <span class="k">where</span> <span class="nv">$n</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">This will!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>有关签名的更多信息，请参阅签名文档。</p>
<h3 id="声明">声明</h3>
<h4 id="变量声明">变量声明</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span><span class="p">;</span>                          <span class="c1"># simple lexical variable </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>                      <span class="c1"># initialize the variable </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>                  <span class="c1"># declare the type </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int:D</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>                <span class="c1"># specify that the value must be defined (not undef) </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">$x</span> <span class="k">where</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="p">}</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="c1"># constrain the value based on a function </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">$x</span> <span class="k">where</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>      <span class="c1"># same constraint, but using Whatever shorthand </span>
</span></span></code></pre></div><p>有关其他作用域的更多详细信息，请参阅变量声明符和作用域（<code>our</code>，<code>has</code>）。</p>
<h4 id="子例程声明">子例程声明</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># The signature is optional </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">say-hello</span><span class="p">(</span><span class="nv">$to-whom</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello </span><span class="nv">$to-whom</span><span class="s2">!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span></code></pre></div><p>您还可以将子例程赋值给变量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">&amp;f</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello!</span><span class="p">&#34;</span> <span class="p">}</span> <span class="c1"># Un-named sub </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">&amp;f</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello!</span><span class="p">&#34;</span> <span class="p">}</span>  <span class="c1"># Lambda style syntax. The &amp; sigil indicates the variable holds a function </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$f</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello!</span><span class="p">&#34;</span> <span class="p">}</span>  <span class="c1"># Functions can also be put into scalars </span>
</span></span></code></pre></div><h4 id="包-模块-类-角色-和-grammar-声明">包, 模块, 类, 角色 和 Grammar 声明</h4>
<p>有几种类型的包，每种类型都使用关键字，名称，一些可选特征以及子例程，方法或规则体声明。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">package</span> <span class="nn">P</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">module</span> <span class="nn">M</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">R</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">G</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></div><p>可以在单个文件中声明多个包。但是，您可以在文件的开头声明一个单元包（仅在注释或 <code>use</code> 语句之前），并且该文件的其余部分将被视为包的主体。在这种情况下，不需要花括号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">unit</span> <span class="k">module</span> <span class="nn">M</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ... stuff goes here instead of in {}&#39;s </span>
</span></span></code></pre></div><h4 id="多重分派的声明">多重分派的声明</h4>
<p>另请参见多重分派。</p>
<p>可以使用多个签名声明同名子例程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello </span><span class="nv">$name</span><span class="s2">!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span></code></pre></div><p>在类里面, 你还可以声明多重分派方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">method</span> <span class="nf">greet</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">method</span> <span class="nf">greet</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$name</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></div><h3 id="子例程调用">子例程调用</h3>
<p>子程序使用关键字 <code>sub</code> 创建，后跟可选名称，可选签名和代码块。子例程是词法作用域的，因此如果在声明时指定了名称，则可以在词法作用域中使用相同的名称来调用子例程。子例程是 <code>Sub</code> 类型的实例，可以赋值给任何容器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">foo</span><span class="p">;</span>   <span class="c1"># Invoke the function foo with no arguments </span>
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">();</span> <span class="c1"># Invoke the function foo with no arguments </span>
</span></span><span class="line"><span class="cl"><span class="nv">&amp;f</span><span class="p">();</span>  <span class="c1"># Invoke &amp;f, which contains a function </span>
</span></span><span class="line"><span class="cl"><span class="nv">&amp;f</span><span class="o">.</span><span class="p">();</span> <span class="c1"># Same as above, needed to make the following work </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@functions</span> <span class="o">=</span> <span class="p">({</span><span class="nb">say</span> <span class="mi">1</span><span class="p">}</span><span class="o">,</span> <span class="p">{</span><span class="nb">say</span> <span class="mi">2</span><span class="p">}</span><span class="o">,</span> <span class="p">{</span><span class="nb">say</span> <span class="mi">3</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nv">@functions</span><span class="o">&gt;&gt;.</span><span class="p">();</span> <span class="c1"># hyper method call operator </span>
</span></span></code></pre></div><p>当在类中声明时，子例程被命名为“方法”：方法是针对对象（即，类实例）调用的子例程。在方法中，特殊变量 <code>self</code> 包含对象实例（请参阅方法）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Method invocation. Object (instance) is $person, method is set-name-age </span>
</span></span><span class="line"><span class="cl"><span class="nv">$person</span><span class="o">.</span><span class="nf">set-name-age</span><span class="p">(&#39;</span><span class="s1">jane</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">98</span><span class="p">);</span>   <span class="c1"># Most common way </span>
</span></span><span class="line"><span class="cl"><span class="nv">$person</span><span class="o">.</span><span class="nf">set-name-age</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">jane</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">98</span><span class="p">;</span>   <span class="c1"># Precedence drop </span>
</span></span><span class="line"><span class="cl"><span class="nf">set-name-age</span><span class="p">(</span><span class="nv">$person:</span> <span class="p">&#39;</span><span class="s1">jane</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">98</span><span class="p">);</span>  <span class="c1"># Invocant marker </span>
</span></span><span class="line"><span class="cl"><span class="nf">set-name-age</span> <span class="nv">$person:</span> <span class="p">&#39;</span><span class="s1">jane</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">98</span><span class="p">;</span>   <span class="c1"># Indirect invocation </span>
</span></span></code></pre></div><p>有关更多信息，请参阅函数。</p>
<h4 id="优先级下降">优先级下降</h4>
<p>在方法调用的情况下（即，在针对类实例调用子例程时），可以应用由冒号标识的优先级下降：在方法名称之后和参数列表之前。参数列表优先于方法调用，另一方面“降低”其优先级。为了更好地理解，请考虑以下简单示例（仅添加额外空格以对齐方法调用）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$band</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Foo Fighters</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$band</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">.</span><span class="nb">substr</span><span class="p">(</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span> <span class="p">);</span> <span class="c1"># F </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$band</span><span class="o">.</span><span class="nb">substr</span><span class="o">:</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span>   <span class="o">.</span><span class="nb">substr</span><span class="p">(</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span> <span class="p">);</span> <span class="c1"># Foo </span>
</span></span></code></pre></div><p>在第二种方法调用中，最右边的 <code>substr</code> 应用于“3”，而不是最左边的 substr 的结果，另一方面，它产生优先级最右边的 substr。</p>
<h3 id="运算符">运算符</h3>
<p>有关详细信息，请参阅运算符。</p>
<p>运算符是具有更多符号重和可组合语法的函数。与其他函数一样，运算符可以进行多重分派以允许特定于上下文的使用。</p>
<p>运算符有五种类型（排列），每种类型都有一个或两个参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">++</span><span class="nv">$x</span>           <span class="c1"># prefix, operator comes before single input </span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="o">+</span> <span class="mi">3</span>          <span class="c1"># infix, operator is between two inputs </span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span><span class="o">++</span>           <span class="c1"># postfix, operator is after single input </span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">the blue sky</span><span class="p">&gt;</span> <span class="c1"># circumfix, operator surrounds single input </span>
</span></span><span class="line"><span class="cl"><span class="nv">%foo</span><span class="p">&lt;</span><span class="s">bar</span><span class="p">&gt;</span>      <span class="c1"># postcircumfix, operator comes after first input and surrounds second </span>
</span></span></code></pre></div><h4 id="元运算符">元运算符</h4>
<p>运算符可以组合。一个常见的例子是将中缀（二元）运算符与赋值相结合。您可以将赋值与任何二元运算符组合。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$x</span> <span class="o">+=</span> <span class="mi">5</span>     <span class="c1"># Adds 5 to $x, same as $x = $x + 5 </span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span> <span class="nb">min</span><span class="o">=</span> <span class="mi">3</span>   <span class="c1"># Sets $x to the smaller of $x and 3, same as $x = $x min 3 </span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span> <span class="o">.=</span> <span class="nb">child</span> <span class="c1"># Equivalent to $x = $x.child </span>
</span></span></code></pre></div><p>在 <code>[ ]</code> 中包装中缀运算符以创建一个新的化简运算符，该运算符在单个输入列表上工作，从而产生单个值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[+]</span> <span class="o">&lt;</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">;</span>    <span class="c1"># OUTPUT: «15␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">(((</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span> <span class="c1"># equivalent expanded version </span>
</span></span></code></pre></div><p>用 <code>« »</code>（或等效的 ASCII）包装一个中缀运算符，以创建一个在两个列表上成对工作的新超运算符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">1 2 3</span><span class="p">&gt;</span> <span class="p">«</span><span class="s2">+</span><span class="p">»</span> <span class="p">&lt;</span><span class="s">4 5 6</span><span class="p">&gt;</span> <span class="c1"># OUTPUT: «(5 7 9)␤» </span>
</span></span></code></pre></div><p>箭头的方向表示当列表的大小不同时该怎么做。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">@a</span> <span class="o">«+«</span> <span class="nv">@b</span> <span class="c1"># Result is the size of @b, elements from @a will be re-used </span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span> <span class="o">»+»</span> <span class="nv">@b</span> <span class="c1"># Result is the size of @a, elements from @b will be re-used </span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span> <span class="o">«+»</span> <span class="nv">@b</span> <span class="c1"># Result is the size of the biggest input, the smaller one is re-used </span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span> <span class="o">»+«</span> <span class="nv">@b</span> <span class="c1"># Exception if @a and @b are different sizes </span>
</span></span></code></pre></div><p>您还可以使用超运算符包装一元运算符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">-</span><span class="p">«</span><span class="s2"> &lt;1 2 3&gt; # OUTPUT: «(-1 -2 -3)␤</span><span class="p">»</span> 
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[下标]]></title>
            <link href="http://localhost:1313/rakulang/64.subscripts/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/adding-up-even-fibonacci-numbers-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 8/25. 在 Raku 中加总偶数斐波纳契数" />
                <link href="http://localhost:1313/notes/metacpan-mojolicious-and-openapi/?utm_source=atom_feed" rel="related" type="text/html" title="第七天 - MetaCPAN, Mojolicious 和 OpenAPI" />
                <link href="http://localhost:1313/rakulang/63.sets-bags-and-mixes/?utm_source=atom_feed" rel="related" type="text/html" title="集合、包和混合" />
                <link href="http://localhost:1313/notes/the-joy-of-unicode-in-perl6/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 7/25. Raku 中 Unicode 的乐趣" />
                <link href="http://localhost:1313/notes/making-a-list-with-yancy/?utm_source=atom_feed" rel="related" type="text/html" title="第六天 - 用 Yancy 制作一个列表" />
            
                <id>http://localhost:1313/rakulang/64.subscripts/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-08T21:13:31+08:00</published>
            <updated>2018-12-08T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="subscriptshttpsdocsrakuorglanguagesubscripts"><a href="https://docs.raku.org/language/subscripts">Subscripts</a></h1>
<p>通过索引或键访问数据结构中的元素。</p>
<p>通常，人们需要引用集合或数据结构中的一个特定的元素（或特定的元素切片）。从数学标记法中偷学到的，向量 <code>v</code> 的组成部分用 <em>v₁, v₂, v₃</em> 来引用，在 Raku 中这个概念叫做 “下标” （或“索引”）。</p>
<h1 id="basics">Basics</h1>
<p>Raku 提供了两个通用的下标接口：</p>
<pre tabindex="0"><code>	   elements are identified by     interface name    supported by
[ ]	 zero-based indices	              Positional        Array, List, Buf, Match, ...
{ }	 string or object keys            Associative       Hash, Bag, Mix, Match, ...
</code></pre><ul>
<li><strong>Positional</strong> 下标 (通过 <a href="http://doc.raku.org/language/operators#postcircumfix_%5B_%5D">postcircumfix [ ]</a> 通过元素在有序集合中的位置来寻址元素。)索引 0 引用第一个元素， 索引 1 引用第二个元素， 以此类推：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">  <span class="k">my</span> <span class="nv">@chores</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">buy groceries</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">feed dog</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">wash car</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">say</span> <span class="nv">@chores</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>  <span class="c1">#-&gt; buy groceries</span>
</span></span><span class="line"><span class="cl">  <span class="nb">say</span> <span class="nv">@chores</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>  <span class="c1">#-&gt; feed dog</span>
</span></span><span class="line"><span class="cl">  <span class="nb">say</span> <span class="nv">@chores</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>  <span class="c1">#-&gt; wash car</span>
</span></span></code></pre></div><ul>
<li><strong>Associative</strong> 下标 (通过 <a href="http://doc.raku.org/language/operators#postcircumfix_%7B_%7D">postcircumfix { }</a>), 不要求集合以任何特定的顺序保存元素 - 相反，它使用一个唯一的键来寻址每个值。键的种类取决于使用的集合： 举个例子， 一个标准的<a href="http://doc.raku.org/type/Hash">散列</a> 使用字符串作为键， 而一个 <a href="http://doc.raku.org/type/Mix">Mix</a> 能使用任意的对象作为键， 等等:</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">  <span class="k">my</span> <span class="nv">%grade</span> <span class="o">=</span> <span class="s">Zoe</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">C</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">Ben</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">B+</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">say</span> <span class="nv">%grade</span><span class="p">{&#34;</span><span class="s2">Zoe</span><span class="p">&#34;};</span>  <span class="c1">#-&gt; C</span>
</span></span><span class="line"><span class="cl">  <span class="nb">say</span> <span class="nv">%grade</span><span class="p">{&#34;</span><span class="s2">Ben</span><span class="p">&#34;};</span>  <span class="c1">#-&gt; B+</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">my</span> <span class="nv">$stats</span> <span class="o">=</span> <span class="p">(</span> <span class="kt">Date</span><span class="o">.</span><span class="s">today</span> <span class="o">=&gt;</span> <span class="mf">4.18</span><span class="o">,</span> <span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">2015</span><span class="o">,</span>  <span class="mi">4</span><span class="o">,</span>  <span class="mi">5</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="mf">17.253</span> <span class="p">)</span><span class="o">.</span><span class="kt">Mix</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">say</span> <span class="nv">$stats</span><span class="p">{</span> <span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">2015</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="p">)</span> <span class="p">};</span>  <span class="c1">#-&gt; 17.253</span>
</span></span></code></pre></div><p>相对于传递单个-单词字符串键给 <code>{ }</code> , 你也可以使用<a href="http://doc.raku.org/language/quoting#Word_quoting:_qw">以尖括号引起单词的结构</a> ，就像它们是后缀操作符一样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">  <span class="nb">say</span> <span class="nv">%grade</span><span class="p">&lt;</span><span class="s">Zoe</span><span class="p">&gt;;</span>    <span class="c1">#-&gt; C</span>
</span></span><span class="line"><span class="cl">  <span class="nb">say</span> <span class="nv">%grade</span><span class="p">&lt;</span><span class="s">Ben</span><span class="p">&gt;;</span>    <span class="c1">#-&gt; B+</span>
</span></span></code></pre></div><p>这实际上仅仅是在编译时被转换为对应 <code>{ }</code> 形式的语法糖：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">  <span class="nv">%hash</span><span class="p">&lt;</span><span class="s">foo bar</span><span class="p">&gt;;</span>     <span class="c1"># same as %hash{ &lt;foo bar&gt; }</span>
</span></span><span class="line"><span class="cl">  <span class="nv">%hash</span><span class="p">«</span><span class="s2">foo </span><span class="nv">$var</span><span class="p">»;</span>    <span class="c1"># same as %hash{ «foo $var» }</span>
</span></span><span class="line"><span class="cl">  <span class="nv">%hash</span><span class="p">&lt;&lt;</span><span class="s2">foo </span><span class="nv">$var</span><span class="p">&gt;&gt;;</span>  <span class="c1"># same as %hash{ &lt;&lt;foo $var&gt;&gt; }</span>
</span></span></code></pre></div><p>下标能应用到能返回可下标化对象的任何表达式上， 而不仅仅应用到变量上：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">__Hello__</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">match</span><span class="p">(/</span><span class="sr">__</span><span class="p">(</span><span class="ni">.</span><span class="o">*</span><span class="p">)</span><span class="sr">__</span><span class="p">/)</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>   <span class="c1">#-&gt; ｢Hello｣</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">__Hello__</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">match</span><span class="p">(/</span><span class="sr">__</span><span class="p">(</span><span class="ni">.</span><span class="o">*</span><span class="p">)</span><span class="sr">__</span><span class="p">/)</span><span class="o">.[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># same, in method notation</span>
</span></span></code></pre></div><p>Positional 和 associative  下标并不互相排斥 - 举个例子， <code>Match</code> 对象两个都支持（每个访问不同的数据集）。还有， 为了让列表处理更方便， 类 <code>Any</code> 为<code>位置下标</code>提供了备用的实现，这会把调用者看作含有<code>一个</code>元素的列表。(但是对于关系下标，没有这样的备用实现， 所以会抛出一个异常，当下标被应用到没有实现支持的对象上时。)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">42</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>    <span class="c1">#-&gt; 42</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">42</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1"># ERROR: postcircumfix { } not defined for type Int</span>
</span></span></code></pre></div><h1 id="nonexistent-elements">Nonexistent elements</h1>
<p>当通过下标寻址一个不存在的元素所发生的事情取决于正在使用的集合类型。标准的 Array 和 Hash 集合返回它们的<a href="http://doc.raku.org/routine/of">value type constraint</a>  的类型对象（这默认是 <code>Any</code>）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@array1</span><span class="p">;</span>     <span class="nb">say</span> <span class="nv">@array1</span><span class="o">[</span><span class="mi">10</span><span class="o">]</span><span class="p">;</span>  <span class="c1">#-&gt; (Any)</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">@array2</span><span class="p">;</span> <span class="nb">say</span> <span class="nv">@array2</span><span class="o">[</span><span class="mi">10</span><span class="o">]</span><span class="p">;</span>  <span class="c1">#-&gt; (Int)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%hash1</span><span class="p">;</span>      <span class="nb">say</span> <span class="nv">%hash1</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">#-&gt; (Any)</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">%hash2</span><span class="p">;</span>  <span class="nb">say</span> <span class="nv">%hash2</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">#-&gt; (Int)</span>
</span></span></code></pre></div><p>然而， 其它类型的集合可能在寻址不存在的元素的下标时反应也不用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="p">)</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">;</span>       <span class="c1">#-&gt; Nil</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a b b b</span><span class="p">&gt;)&lt;</span><span class="s">c</span><span class="p">&gt;;</span>  <span class="c1">#-&gt; 0</span>
</span></span></code></pre></div><p>为了在下标操作中默默地跳过不存在的元素， 查看 <a href="http://doc.raku.org/language/subscripts#Truncating_slices">#Truncating slices</a>  和 <a href="http://doc.raku.org/language/subscripts#%3Av"><code>#:v</code></a> 副词。</p>
<h1 id="from-the-end">From the end</h1>
<p>Positional  索引是从集合的开头计数的， 但是也有一种标记法用于，通过相对于末尾的位置来寻址元素：<code>*-1</code> 引用最后一个元素， <code>*-2</code> 引用倒数第二个元素， 以此类推。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@alphabet</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">A</span><span class="p">&#39;</span> <span class="o">..</span> <span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>  <span class="c1">#-&gt; Z</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[*-</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>  <span class="c1">#-&gt; Y</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[*-</span><span class="mi">3</span><span class="o">]</span><span class="p">;</span>  <span class="c1">#-&gt; X</span>
</span></span></code></pre></div><p>注意：星号很重要。在 Raku中，如果像在很多其它编程语言中那样传递一个裸的负整数（例如 <code>@alphabet[-1]</code>）， 会抛出错误。</p>
<p>这里实际发生的是， <code>*-1</code> 那样的表达式通过 <a href="http://doc.raku.org/type/Whatever">Whatever</a> 柯里化声明了一个代码对象 - <code>[ ]</code>会把代码对象作为索引， 通过集合的长度作为参数来调用它并使用结果值作为实际的索引。 换句话说，<code>@alphabet[*-1]</code> 变成了 <code>@alphabet[@alphabet.elems - 1]</code>。</p>
<p>这意味着你可以使用任何依赖于集合尺寸的表达式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@array</span><span class="o">[*</span> <span class="ow">div</span> <span class="mi">2</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># 选择最中间的那个元素</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@array</span><span class="o">[</span><span class="nv">$i</span> <span class="nv">%</span> <span class="o">*]</span><span class="p">;</span>   <span class="c1"># wrap around a given index (&#34;模运算&#34;)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@array</span><span class="o">[</span> <span class="k">-&gt;</span> <span class="nv">$size</span> <span class="p">{</span> <span class="nv">$i</span> <span class="nv">%</span> <span class="nv">$size</span> <span class="p">}</span> <span class="o">]</span><span class="p">;</span>  <span class="c1"># same as previous</span>
</span></span></code></pre></div><h1 id="slices">Slices</h1>
<p>当需要访问集合中的多个元素时，有一个快捷方式用于处理多个单独的下标操作：仅仅在下标中指定一个<code>索引/键</code>的列表，来取回一个元素的列表 - 也被叫做”切片” - 以相同的顺序。</p>
<p>对于 positional  切片， 你可以混合普通切片和  <a href="http://doc.raku.org/language/subscripts#From_the_end">from-the-end</a> 切片：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@alphabet</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">..</span> <span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">15</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="o">*-</span><span class="mi">9</span><span class="o">,</span> <span class="mi">11</span><span class="o">]</span><span class="p">;</span>  <span class="c1">#-&gt; (&#34;p&#34;, &#34;e&#34;, &#34;r&#34;, &#34;l&#34;)</span>
</span></span></code></pre></div><p>对于 associative  切片，尖括号形式的切片通常会很方便：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%color</span> <span class="o">=</span> <span class="s">kiwi</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">banana</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">yellow</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">cherry</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">red</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">cherry</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">kiwi</span><span class="p">&#34;};</span>  <span class="c1">#-&gt; (&#34;red&#34;, &#34;green&#34;)</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%color</span><span class="p">&lt;</span><span class="s">cherry kiwi</span><span class="p">&gt;;</span>       <span class="c1">#-&gt; (&#34;red&#34;, &#34;green&#34;)</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%color</span><span class="p">{</span><span class="o">*</span><span class="p">};</span>                 <span class="c1">#-&gt; (&#34;green&#34;, &#34;red&#34;, &#34;yellow&#34;)</span>
</span></span></code></pre></div><p>要知道切片是由传入 (<a href="http://doc.raku.org/language/subscripts#Multiple_dimensions">one dimension of</a>)下标的类型控制的，而非它的长度：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">subscript</span>	                               <span class="nb">result</span>
</span></span><span class="line"><span class="cl"><span class="nb">any</span> <span class="kt">Positional</span> <span class="n">object</span> <span class="nb">not</span> <span class="n">covered</span> <span class="n">below</span>	   <span class="n">normal</span> <span class="n">slice</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="kt">Range</span> <span class="ow">or</span> <span class="nb">infinite</span> <span class="n">sequence</span>	           <span class="n">truncating</span> <span class="n">slice</span> <span class="p">(</span><span class="n">only</span> <span class="k">for</span> <span class="nb">positional</span> <span class="n">subscripts</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span> <span class="p">(</span><span class="n">Whatever-star</span><span class="p">)</span>	                       <span class="nb">full</span> <span class="n">slice</span> <span class="p">(</span><span class="n">as</span> <span class="k">if</span> <span class="nb">all</span> <span class="nb">keys</span><span class="o">/</span><span class="nb">indices</span> <span class="n">were</span> <span class="n">specified</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">any</span> <span class="n">other</span> <span class="n">object</span>	                       <span class="n">single-element</span> <span class="n">access</span> <span class="n">rather</span> <span class="n">than</span> <span class="n">a</span> <span class="n">slice</span>
</span></span><span class="line"><span class="cl"><span class="n">empty</span>	                                   <span class="n">Zen</span> <span class="n">slice</span>
</span></span></code></pre></div><p>所以，即使一个单个元素的列表也会返回一个切片， 而一个裸的标量值不会：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">2</span><span class="o">,]</span><span class="p">;</span>  <span class="c1">#-&gt; (&#34;c&#34;,)</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>   <span class="c1">#-&gt; &#34;c&#34;</span>
</span></span></code></pre></div><p>(尖括号形式的 associative 下标也没有问题，因为 <a href="http://doc.raku.org/language/quoting#Word_quoting:_qw">word quoting</a>  在单个单词的情况下很方便的返回一个 Str, 但是在多个单词的情况下返回一个 <a href="http://doc.raku.org/type/Parcel">Parcel</a>)。</p>
<p>对于普通的切片，下标的内容 (<a href="http://doc.raku.org/language/subscripts#Multiple_dimensions">the current dimension of</a>) 在它的元素被解释为 <code>索引/键</code> 之前会被展平(flattened)：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="o">,</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="p">)))</span><span class="err">];  #-&gt; (&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;)
</span></span></span></code></pre></div><h2 id="truncating-slices">Truncating slices</h2>
<p>通常, 在切片下标中引用不存在的元素会让输出列表包含未定义的值。然而， 如果传递给位置下标的对象是一个 Range 或使用序列操作符构建的无限序列， 它会被自动截断到集合的实际尺寸：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@letters</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e f</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@letters</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">]</span><span class="p">;</span>  <span class="c1">#-&gt; (&#34;d&#34;, &#34;e&#34;, &#34;f&#34;, Any, Any)</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@letters</span><span class="o">[</span><span class="mi">3</span> <span class="o">..</span> <span class="mi">7</span><span class="o">]</span><span class="p">;</span>         <span class="c1">#-&gt; (&#34;d&#34;, &#34;e&#34;, &#34;f&#34;)</span>
</span></span></code></pre></div><p><a href="http://doc.raku.org/language/subscripts#From_the_end">From-the-end</a>  索引被允许作为范围的端点，代表无限的范围和序列：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@array</span><span class="o">[*-</span><span class="mi">3</span> <span class="o">..</span> <span class="o">*]</span><span class="p">;</span>       <span class="c1"># select the last three elements</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@array</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="o">*]</span><span class="p">;</span>  <span class="c1"># select all elements with even indices</span>
</span></span></code></pre></div><p>如果你不想把你的切片指定为 <code>range/sequence</code> 但仍旧想默默地跳过不存在的元素， 你可以使用 <a href="http://doc.raku.org/language/subscripts#%3Av">#:v</a> 副词。</p>
<h2 id="zen-slices">Zen slices</h2>
<p>如果你写的下标没有指定任何 <code>索引/键</code> ，那它就会返回被脚注的对象自身。因为它是空的但是返回了全部东西， 这就是所谓的 &ldquo;Zen slice&rdquo;。</p>
<p>这和传递一个  Whatever-star （这，像普通的切片， 总是返回一个元素的 Parcel，不管原对象的类型）还有传递一个空的列表都不同（它返回一个空的切片）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%bag</span> <span class="o">:=</span> <span class="p">(&#34;</span><span class="s2">orange</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">apple</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Bag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%bag</span><span class="o">&lt;&gt;</span><span class="p">;</span>    <span class="c1">#-&gt; (&#34;orange&#34;=&gt;1,&#34;apple&#34;=&gt;3).Bag</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%bag</span><span class="p">{};</span>    <span class="c1">#-&gt; (&#34;orange&#34;=&gt;1,&#34;apple&#34;=&gt;3).Bag</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%bag</span><span class="p">{</span><span class="o">*</span><span class="p">};</span>   <span class="c1">#-&gt; (1, 3)</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%bag</span><span class="p">{()};</span>  <span class="c1">#-&gt; ()</span>
</span></span></code></pre></div><p>这通常被用于把整个 <code>数组/散列</code> 插值到字符串中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@words</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">cruel</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">world</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, </span><span class="nv">@words</span><span class="s2">[]!</span><span class="p">&#34;</span>  <span class="c1">#-&gt; Hello, cruel world!</span>
</span></span></code></pre></div><h1 id="multiple-dimensions">Multiple dimensions</h1>
<p>尚未实现！等到 9 月份？</p>
<h1 id="modifying-elements">Modifying elements</h1>
<h1 id="autovivification">Autovivification</h1>
<p>下标参与 &ldquo;autovivification”（自动复活），i.e. 这是一种数组和散列在需要时会自动存在的处理， 以至于你没有必要在每一层级预声明集合的类型来构建嵌套的数据结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$beatles</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$beatles</span><span class="p">{&#34;</span><span class="s2">White Album</span><span class="p">&#34;}</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Back in the U.S.S.R.</span><span class="p">&#34;;</span>  <span class="c1"># autovivification!</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$beatles</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>  <span class="c1">#-&gt; {&#34;White Album&#34; =&gt; [&#34;Back in the U.S.S.R.&#34;]}</span>
</span></span></code></pre></div><p><code>$beatles</code>  从未定义开始， 但是它变成了一个 Hash 对象， 因为它在赋值时用 <code>{ }</code> 标注了。 类似地，  <code>$beatles{&quot;White Album”}</code> 变成一个 Array 对象， 因为它在赋值时用 <code>[ ]</code> 标注了。</p>
<p>注意下标本身不会引起 autovivification（自动复活）：它只发生在下标链的结果被赋值时（或变化时）。</p>
<h1 id="binding">Binding</h1>
<p>下标表达式也可以用在绑定语句的左侧。如果被标注的集合的类型支持， 这会使用指定的容器替换集合里的插槽的值：（给跪了！）</p>
<p>内置的 Array 和 Hash 类型支持这种绑定， 为了允许构建复杂的联动的数据结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">13</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">:=</span> <span class="nv">$x</span><span class="p">;</span>  <span class="c1"># binding! (@a[2] and $x refer to the same container now.)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$x</span><span class="o">++</span><span class="p">;</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">2</span><span class="o">]++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@a</span><span class="p">;</span>  <span class="c1">#-&gt; [10, 11, 3, 13]&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">$x</span><span class="p">;</span>  <span class="c1">#-&gt; 3</span>
</span></span></code></pre></div><p>查看 <a href="http://doc.raku.org/language/subscripts#method_BIND-POS">#method BIND-POS</a> 和 <a href="http://doc.raku.org/language/subscripts#method_BIND-KEY">#method BIND-KEY</a> 了解底层机制.</p>
<h1 id="adverbs">Adverbs</h1>
<p>下标操作的返回值和可能存在的副作用能够使用副词来控制。</p>
<p>要知道副词操作符的优先级相对宽松，这可能需要你在合成表达式中添加括号：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$foo</span> <span class="o">||</span> <span class="nv">%hash</span><span class="p">&lt;</span><span class="s">key</span><span class="p">&gt;:</span><span class="s">exists</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>    <span class="c1"># WRONG, tries to adverb the || op</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$foo</span> <span class="o">||</span> <span class="p">(</span><span class="nv">%hash</span><span class="p">&lt;</span><span class="s">key</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>  <span class="c1"># correct</span>
</span></span></code></pre></div><p>支持的副词有:</p>
<h2 id="exists">:exists</h2>
<p>返回请求的元素是否存在，而不是返回元素实际的值。这能够用于区别未定义值的元素和一点儿也不属于集合部分的元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="kt">Any</span><span class="o">,</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@foo</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">defined</span><span class="p">;</span>    <span class="c1">#-&gt; False</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@foo</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">:</span><span class="s">exists</span><span class="p">;</span>     <span class="c1">#-&gt; True</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@foo</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">exists</span><span class="p">;</span>     <span class="c1">#-&gt; False</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@foo</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">exists</span><span class="p">;</span>  <span class="c1">#-&gt; (True, False)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%fruit</span> <span class="o">=</span> <span class="s">apple</span> <span class="o">=&gt;</span> <span class="kt">Any</span><span class="o">,</span> <span class="s">orange</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>       <span class="c1">#-&gt; False</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span>        <span class="c1">#-&gt; True</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">banana</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span>       <span class="c1">#-&gt; False</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple banana</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span> <span class="c1">#-&gt; (True, False)</span>
</span></span></code></pre></div><p>也可以对副词取反来测试不存在：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple banana</span><span class="p">&gt;:</span><span class="o">!</span><span class="s">exists</span><span class="p">;</span> <span class="c1">#-&gt; (False, True)</span>
</span></span></code></pre></div><p>要检查切片的所有元素是否存在， 使用 <a href="http://doc.raku.org/routine/all">all</a> junction:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">all</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple orange banana</span><span class="p">&gt;:</span><span class="s">exists</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span></code></pre></div><p><code>:exists</code>  可以和  <a href="http://doc.raku.org/language/subscripts#%3Adelete">:delete</a> 还有 <code>:p/:kv</code> 副词组合 - 这时表达式的行为就由那些副词决定，除了使用表明元素存在的对应 Bool 值替换返回的元素值之外。</p>
<p>查看 <a href="http://doc.raku.org/language/subscripts#method_EXISTS-POS">method EXISTS-POS</a>  和 <a href="http://doc.raku.org/language/subscripts#method_EXISTS-KEY">method EXISTS-KEY</a> 了解底层机制.</p>
<h2 id="delete">:delete</h2>
<p>从集合中删除元素， 除了返回它们的值以外。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@tens</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">:</span><span class="s">delete</span><span class="p">;</span>     <span class="c1">#-&gt; 30</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@tens</span><span class="p">;</span>               <span class="c1">#-&gt; [0, 10, 20]&lt;&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%fruit</span> <span class="o">=</span> <span class="s">apple</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="o">,</span> <span class="s">orange</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="o">,</span> <span class="s">banana</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="s">peach</span> <span class="o">=&gt;</span> <span class="mi">17</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple</span><span class="p">&gt;:</span><span class="s">delete</span><span class="p">;</span>         <span class="c1">#-&gt; 5</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">peach orange</span><span class="p">&gt;:</span><span class="s">delete</span><span class="p">;</span>  <span class="c1">#-&gt; (17, 10)</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%fruit</span><span class="p">;</span>                       <span class="c1">#-&gt; {banana =&gt; 4}&lt;&gt;</span>
</span></span></code></pre></div><p>使用否定形式的副词，元素实际上不会被删除。这意味着你可以传递一个标记，让它变成有条件的删除：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple</span><span class="p">&gt;</span> <span class="p">:</span><span class="s">delete</span><span class="p">(</span><span class="nv">$flag</span><span class="p">);</span>  <span class="c1"># deletes the element only if $flag is</span>
</span></span><span class="line"><span class="cl">                                  <span class="c1"># true, but always returns the value.</span>
</span></span></code></pre></div><p>能和 <code>:exists</code> 还有 <code>:p/:kv/:k/:v</code> 副词组合 - 这时返回值由那些副词决定， 但是同时元素也会被删除。</p>
<p>查看 <a href="http://doc.raku.org/language/subscripts#method_DELETE-POS">method DELETE-POS</a> and <a href="http://doc.raku.org/language/subscripts#method_DELETE-KEY">method DELETE-KEY</a> 了解底层机制.</p>
<h2 id="p">:p</h2>
<p>以 Pair 的形式，返回元素的<code>索引/键</code> 和元素值， 并默默跳过不存在的元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@tens</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">:</span><span class="s">p</span><span class="p">;</span>        <span class="c1">#-&gt; 1 =&gt; 10</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">p</span><span class="p">;</span>  <span class="c1">#-&gt; (0 =&gt; 0, 2 =&gt; 20)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%month</span> <span class="o">=</span> <span class="s">Jan</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">Feb</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="s">Mar</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Feb</span><span class="p">&gt;:</span><span class="s">p</span><span class="p">;</span>          <span class="c1">#-&gt; &#34;Feb&#34; =&gt; 2</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="s">p</span><span class="p">;</span>  <span class="c1">#-&gt; (&#34;Jan&#34; =&gt; 1, &#34;Mar&#34; =&gt; 3)</span>
</span></span></code></pre></div><p>如果你不想跳过不存在的元素， 使用否定形式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="o">!</span><span class="s">p</span><span class="p">;</span>  <span class="c1">#-&gt; (&#34;Jan&#34; =&gt; 1, &#34;Foo&#34; =&gt; Any, &#34;Mar&#34; =&gt; 3)</span>
</span></span></code></pre></div><p>能和 <code>:exists</code> 还有 <code>:delete</code> 组合。</p>
<p>也可以查看  <a href="http://doc.raku.org/routine/pairs">pairs</a> 子例程.</p>
<h2 id="kv">:kv</h2>
<p>以列表的形式返回元素的<code>索引/键</code>和<code>值</code> , 并默默地跳过不存在的元素。 当作用在切片上时，返回值是一个展平的键和值交叉着的单个列表：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@tens</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">:</span><span class="s">kv</span><span class="p">;</span>        <span class="c1">#-&gt; (1, 10)</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">kv</span><span class="p">;</span>  <span class="c1">#-&gt; (0, 0, 2, 20)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%month</span> <span class="o">=</span> <span class="s">Jan</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">Feb</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="s">Mar</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Feb</span><span class="p">&gt;:</span><span class="s">kv</span><span class="p">;</span>          <span class="c1">#-&gt; (&#34;Feb&#34;, 2)</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="s">kv</span><span class="p">;</span>  <span class="c1">#-&gt; (&#34;Jan&#34;, 1, &#34;Mar&#34;, 3)</span>
</span></span></code></pre></div><p>如果你不想跳过不存在的元素， 使用否定形式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="o">!</span><span class="s">kv</span><span class="p">;</span>  <span class="c1">#-&gt; (&#34;Jan&#34;, 1, &#34;Foo&#34;, Any, &#34;Mar&#34;, 3)</span>
</span></span></code></pre></div><p>这个副词一般用于遍历切片：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Feb Mar</span><span class="p">&gt;:</span><span class="s">kv</span> <span class="k">-&gt;</span> <span class="nv">$month</span><span class="o">,</span> <span class="nv">$i</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$month</span><span class="s2"> had </span><span class="p">{</span><span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">2015</span><span class="o">,</span> <span class="nv">$i</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nb">days-in-month</span><span class="p">}</span><span class="s2"> days in 2015</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>能和 <code>:exists</code> 还有 <code>:delete</code> 组合。</p>
<p>也可以查看  <a href="http://doc.raku.org/routine/kv">kv</a> 子例程.</p>
<h2 id="k">:k</h2>
<p>只返回元素的<code>索引/键</code> , 而不是它们的值, 并默默地跳过不存在的元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@tens</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">:</span><span class="s">k</span><span class="p">;</span>        <span class="c1">#-&gt; 1</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">k</span><span class="p">;</span>  <span class="c1">#-&gt; (0, 2)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%month</span> <span class="o">=</span> <span class="s">Jan</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">Feb</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="s">Mar</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Feb</span><span class="p">&gt;:</span><span class="s">k</span><span class="p">;</span>          <span class="c1">#-&gt; &#34;Feb&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="s">k</span><span class="p">;</span>  <span class="c1">#-&gt; (&#34;Jan&#34;, &#34;Mar&#34;)</span>
</span></span></code></pre></div><p>如果你不想跳过不存在的元素， 使用否定形式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="o">!</span><span class="s">k</span><span class="p">;</span>  <span class="c1">#-&gt; (&#34;Jan&#34;, &#34;Foo&#34;, &#34;Mar&#34;)</span>
</span></span></code></pre></div><p>还可以查看  <a href="http://doc.raku.org/routine/keys">keys</a> 子例程.</p>
<h2 id="v">:v</h2>
<p>返回元素的裸值（不是有可能返回一个可变值容器），并默默跳过不存在的元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@tens</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">:</span><span class="s">v</span><span class="p">;</span>        <span class="c1">#-&gt; 10</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">v</span><span class="p">;</span>  <span class="c1">#-&gt; (0, 20)</span>
</span></span><span class="line"><span class="cl"><span class="nv">@tens</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>        <span class="c1"># OK</span>
</span></span><span class="line"><span class="cl"><span class="nv">@tens</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">:</span><span class="s">v</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>      <span class="c1"># ERROR, cannot assign to immutable integer value</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%month</span> <span class="o">=</span> <span class="s">Jan</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">Feb</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="s">Mar</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Feb</span><span class="p">&gt;:</span><span class="s">v</span><span class="p">;</span>          <span class="c1">#-&gt; 2</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="s">v</span><span class="p">;</span>  <span class="c1">#-&gt; (1, 3)</span>
</span></span></code></pre></div><p>如果你不想跳过不存在的元素， 使用否定形式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="o">!</span><span class="s">v</span><span class="p">;</span>  <span class="c1">#-&gt; (1, Any, 3)</span>
</span></span></code></pre></div><p>还可以查看  <a href="http://doc.raku.org/routine/values">values</a> 子例程.</p>
<h1 id="custom-types">Custom types</h1>
<p>这页描述的下标接口并不意味着和 Raku 的内置集合类型相排斥 - 你可以（并且应该）为任何想通过索引或键提供数据访问的自定义类型重用它们。</p>
<p>你不必手动重载  <a href="http://doc.raku.org/routine/%5B%20%5D#postcircumfix_%5B_%5D">postcircumfix [ ]</a> 和  <a href="http://doc.raku.org/">postcircumfix { }</a>  操作符并重新实现它们所有的戏法， 为了实现它， 相反，你可以依赖这个事实， 在幕后，它们的标准实现分派给了一个定义良好的底层方法集。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nf">当你这样写:</span>	         <span class="n">这会在幕后调用如下底层方法:</span>
</span></span><span class="line"><span class="cl"><span class="nv">%foo</span><span class="o">&lt;</span><span class="n">aa</span><span class="o">&gt;</span>	        <span class="nv">%foo</span><span class="o">.</span><span class="nb">AT-KEY</span><span class="p">(&#34;</span><span class="s2">aa</span><span class="p">&#34;)</span>
</span></span><span class="line"><span class="cl"><span class="nv">%foo</span><span class="p">&lt;</span><span class="s">aa</span><span class="p">&gt;:</span><span class="s">delete</span>	    <span class="nv">%foo</span><span class="o">.</span><span class="nb">DELETE-KEY</span><span class="p">(&#34;</span><span class="s2">aa</span><span class="p">&#34;)</span>
</span></span><span class="line"><span class="cl"><span class="nv">@foo</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>	        <span class="nv">@foo</span><span class="o">.</span><span class="nb">AT-POS</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">,</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">AT-POS</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">,</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">AT-POS</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nv">@foo</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span>	        <span class="nv">@foo</span><span class="o">.</span><span class="nb">AT-POS</span><span class="p">(</span><span class="nv">@foo</span><span class="o">.</span><span class="nb">elems</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span></code></pre></div><p>所以， 为了让你的下标工作， 你只需要为你的自定义类型实现或委托那些底层方法（<a href="http://doc.raku.org/language/subscripts#Methods_to_implement_for_positional_subscripting">下面描述详情</a>）。</p>
<p>如果你这样做了， 你还应该让你的类型各自遵守 <a href="http://doc.raku.org/type/Positional">Positional</a> 或 <a href="http://doc.raku.org/type/Associative">Associative</a> role</p>
<h2 id="custom-type-example">Custom type example</h2>
<p>设想一下 HTTP::Header 类型，尽管它作为一个有特定行为的自定义类，却能像散列那样索引：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$request</span> <span class="o">=</span> <span class="n">HTTP::Request</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">GET</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">raku.org</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>  <span class="c1">#-&gt; (HTTP::Header)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="p">&lt;</span><span class="s">Accept</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">text/plain</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="p">{&#39;</span><span class="s1">Accept-</span><span class="p">&#39;</span> <span class="ow">X</span><span class="o">~</span> <span class="p">&lt;</span><span class="s">Charset Encoding Language</span><span class="p">&gt;}</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">utf-8 gzip en</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="o">.</span><span class="nb">push</span><span class="p">(&#39;</span><span class="s1">Accept-Language</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">fr</span><span class="p">&#34;);</span>  <span class="c1"># like .push on a Hash</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="p">&lt;</span><span class="s">Accept-Language</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>  <span class="c1">#-&gt; [&#34;en&#34;, &#34;fr&#34;]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rawheader</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="o">.</span><span class="kt">Str</span><span class="p">;</span>  <span class="c1"># stringify according to HTTP spec</span>
</span></span></code></pre></div><p>实现这个类的最简单的方法是，给它一个 Hash 类型的属性，并把所有的下标和迭代相关功能性委托给那个属性。（使用一个自定义类型约束来确保使用者不会在里面插入任何不合法的值）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">HTTP::Header</span> <span class="k">does</span> <span class="kt">Associative</span> <span class="k">is</span> <span class="kt">Iterable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">subset</span> <span class="nc">StrOrArrayOfStr</span> <span class="k">where</span> <span class="kt">Str</span> <span class="o">|</span> <span class="p">(</span> <span class="kt">Array</span> <span class="o">&amp;</span> <span class="p">{</span><span class="o">.</span><span class="nb">all</span> <span class="o">~~</span> <span class="kt">Str</span><span class="p">}</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">%!fields</span> <span class="k">of</span> <span class="nc">StrOrArrayOfStr</span>
</span></span><span class="line"><span class="cl">                 <span class="nb">handles</span> <span class="p">&lt;</span><span class="s">AT-KEY EXISTS-KEY DELETE-KEY push
</span></span></span><span class="line"><span class="cl"><span class="s">                          iterator list kv keys values</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="kt">Str</span> <span class="p">{</span> <span class="cm">#`[not shown, for brevity]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>然而， HTTP header 字段名被认为是大小写无关的（更偏好驼峰法）。我们可以通过把 <code>*-key</code> 和 <code>push</code> 方法拿到 <code>handles</code> 列表的外面来容纳它， 并像这样各自实现它们：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">method</span> <span class="nb">AT-KEY</span>     <span class="p">(</span><span class="nv">$key</span><span class="p">)</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">}</span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">method</span> <span class="nb">EXISTS-KEY</span> <span class="p">(</span><span class="nv">$key</span><span class="p">)</span>       <span class="p">{</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">}:</span><span class="s">exists</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">method</span> <span class="nb">DELETE-KEY</span> <span class="p">(</span><span class="nv">$key</span><span class="p">)</span>       <span class="p">{</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">}:</span><span class="s">delete</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">method</span> <span class="nb">push</span> <span class="p">(</span><span class="o">*</span><span class="nv">@_</span><span class="p">)</span> <span class="p">{</span> <span class="cm">#`[not shown, for brevity]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">normalize-key</span> <span class="p">(</span><span class="nv">$key</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$key</span><span class="o">.</span><span class="nb">subst</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/</span><span class="o">,</span> <span class="o">*.</span><span class="nb">tc</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span> <span class="p">}</span>
</span></span></code></pre></div><p>注意下标  <code>%!fields</code> 返回一个适当的 rw 容器， 而我们的 <code>AT-KEY</code> 能够简单地传递。</p>
<p>然而， 我们可能倾向于少一点对用户输入的限制， 相反我们自己关心字段值的消毒。那种情况下，我们可以移除 <code>%!fields</code> 上的 <code>StrOrArrayOfStr</code>  类型约束， 并在赋值时使用返回自定义的关心消毒值的 Proxy 容器来替换我们的 <code>AT-KEY</code> 实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">method</span> <span class="nb">AT-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$element</span> <span class="o">:=</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">Proxy</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="s">FETCH</span> <span class="o">=&gt;</span> <span class="k">method</span> <span class="p">()</span> <span class="p">{</span> <span class="nv">$element</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="s">STORE</span> <span class="o">=&gt;</span> <span class="k">method</span> <span class="p">(</span><span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$element</span> <span class="o">=</span> <span class="nb">do</span> <span class="k">given</span> <span class="nv">$value</span><span class="o">».</span><span class="nb">split</span><span class="p">(/&#39;</span><span class="s1">,</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">flat</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">when</span> <span class="mi">1</span>  <span class="p">{</span> <span class="o">.[</span><span class="mi">0</span><span class="o">]</span> <span class="p">}</span>    <span class="c1"># a single value is stored as a string</span>
</span></span><span class="line"><span class="cl">                <span class="k">default</span> <span class="p">{</span> <span class="o">.</span><span class="kt">Array</span> <span class="p">}</span>  <span class="c1"># multiple values are stored as an array</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意把方法声明为 <code>multi</code> 并把它限制为 <code>:D</code> (defined invocants) 确保未定义情况被传递给由 Any（这在自动复活中被调用） 提供的默认实现。（我去，翻译不来哦！）</p>
<h2 id="methods-to-implement-for-positional-subscripting">Methods to implement for positional subscripting</h2>
<p>为了通过  <a href="http://doc.raku.org/routine/%5B%20%5D#postcircumfix_%5B_%5D">postcircumfix [ ]</a>  让基于索引的下标在你的自定义类型中工作，你应该至少实现下面的  <code>elems</code>, <code>AT-POS</code> 和 <code>EXISTS-POS-</code> 还有其它可选项。</p>
<h3 id="elems-方法">elems 方法</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">method</span> <span class="nb">elems</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span><span class="p">)</span>
</span></span></code></pre></div><p>预期返回一个数字，用于表明对象中有多少个可标注的元素。 可能被用户直接调用， 并且当从末尾索引元素的时候， 还会被  <code>postcircumfix [ ]</code> 调用， 就像 <code>@foo[*-1]</code> 中那样。</p>
<p>如果没有实现这个方法， 你的类型会从 Any 继承默认的实现， 对定义过的调用者这总是返回 1 - 这最不可能是你想要的。 所以， 如果不能从你的位置类型知晓元素的个数， 那就添加一个 fails 或 dies 实现， 以避免沉默地做了错事。</p>
<h3 id="at-pos-方法">AT-POS 方法</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">method</span> <span class="nb">AT-POS</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$index</span><span class="p">)</span>
</span></span></code></pre></div><p>期望返回 <code>$index</code> 位置处的元素。这就是 <code>postcircumfix [ ]</code> 通常调用的方法。
如果你想让元素可变(像它们用于 Array 类型那样), 你就必须确保以 item 容器的形式返回它, 并在被赋值时更新它。(记得使用 <code>return-rw</code> 或 <code>rw</code> 子例程 trait 以使它工作; 查看例子。)</p>
<h3 id="exists-pos-方法">EXISTS-POS 方法</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">method</span> <span class="nb">EXISTS-POS</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$index</span><span class="p">)</span>
</span></span></code></pre></div><p>返回一个布尔值以表明在 <code>$index</code> 位置处是否有元素。这就是引用 <code>@foo[42]:exists</code> 时, <code>postcircumfix [ ]</code> 所调用的方法。</p>
<p>元素&quot;存在&quot;意味着什么, 取决于你的类型。</p>
<p>如果你没有实现它, 你的类型会从 <code>Any</code> 那儿继承默认的实现, 对于索引 0 它会返回 True, 对于 其它索引它会返回 <code>false</code> &ndash; 这可能不是你想要的。所以如果你的类型不能做元素存在检测, 那就添加一个 fails 或 die 实现, 以避免静默地做错事情。</p>
<h3 id="delete-pos-方法">DELETE-POS 方法</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">method</span> <span class="nb">DELETE-POS</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$index</span><span class="p">)</span>
</span></span></code></pre></div><p>删除 <code>$index</code> 处的元素, 并返回它所删除的这个元素。这就是引用 <code>@foo[42]:delete</code> 时, <code>postcircumfix [ ]</code> 所调用的方法。</p>
<p>&ldquo;删除&quot;元素的意思是什么, 取决于你的类型。</p>
<p>实现这个方法是可选的; 如果你没有实现它, 那么用户尝试从这种类型的对象中删除元素会得到一个合适的错误信息。</p>
<h3 id="assign-pos-方法">ASSIGN-POS 方法</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">method</span> <span class="nb">ASSIGN-POS</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$index</span><span class="o">,</span> <span class="nv">$new</span><span class="p">)</span>
</span></span></code></pre></div><p>把 <code>$index</code> 位置处的元素设置为 <code>$new</code> 值。实现这个方法完全是可选的; 如果你没有实现这个方法, 那么会使用 <code>self.AT-POS($index) = $new</code>  代替, 如果你确实实现了该方法, 那么确保它拥有相同的效果。</p>
<p>这意味着 opt-in 性能优化, 以至于简单的诸如 <code>@numbers[5] = &quot;five&quot;</code> 的赋值能在不调用 <code>AT-POS</code>(这必须创建并返回一个潜在的昂贵的容器对象) 方法时操作。</p>
<p>注意, 实现 <code>ASSIGN-POS</code> 不能解除让 <code>AT-POS</code> 变成一个 <code>rw</code> 方法, 因为诸如 <code>@numbers[5]++</code> 的不太重要的赋值/修改 仍旧会使用 <code>AT-POS</code>。</p>
<h3 id="bind-pos-方法">BIND-POS 方法</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">method</span> <span class="nb">BIND-POS</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$index</span><span class="o">,</span> \<span class="nb">new</span><span class="p">)</span>
</span></span></code></pre></div><p>把值或容器 <code>new</code> 绑定给位置 <code>$index</code> 处的插槽上, 替换那儿能找到的任何容器。这是当你这样写的时候所调用的东西:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@numbers</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="o">:=</span> <span class="nv">$x</span><span class="p">;</span>
</span></span></code></pre></div><p>一般的数组类支持这以允许创建复杂的链接数据结构,  但是对于更特定领域类型它可能没有意义, 所以不强求去实现它。如果你没有实现该方法, 用户会获得一个合适的错误信息, 当它们尝试绑定到这种类型的对象的一个位置插槽上时。</p>
<h2 id="methods-to-implement-for-associative-subscripting">Methods to implement for associative subscripting</h2>
<p>为了通过 <code>postcircumfix { }</code> 让基于键的下标能够工作于你的自定义类型中, 你应该至少实现 <code>AT-KEY</code> 和 <code>EXISTS-KEY</code> &ndash; 还有可选地实现下面的方法。</p>
<h3 id="at-key-方法">AT-KEY 方法</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">method</span> <span class="nb">AT-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span>
</span></span></code></pre></div><p>返回和 <code>$key</code> 相关联的元素。这正是 <code>postcircumfix { }</code> 通常所调用的方法。</p>
<p>如果你想让元素可变(就像它们是为了内置的 Hash 类型), 你必须确保以 item 容器的形式返回它, 并在被赋值时更新它。(记得使用 <code>return-rw</code> 或 <code>is rw</code> 子例程 trait 以使其有效; 查看例子。)</p>
<p>另一方面, 如果你想让你的集合只读, 请直接返回非容器值。</p>
<h3 id="exists-key-方法">EXISTS-KEY 方法</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">method</span> <span class="nb">EXISTS-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span>
</span></span></code></pre></div><p>返回一个布尔值以表明和 <code>$key</code> 相关联的元素是否存在。这就是引用 <code>%foo&lt;aa&gt;:exists</code> 时, <code>postcircumfix { }</code> 所调用的方法。</p>
<p>元素&quot;存在&quot;意味着什么, 取决于你的类型。</p>
<p>如果你没有实现它, 你的类型会从 <code>Any</code> 那儿继承默认的实现, 这通常返回 False &ndash; 这可能不是你想要的。所以如果你的类型不能做元素存在检测, 那就添加一个 fails 或 die 实现, 以避免静默地做错事情</p>
<h3 id="delete-key-方法">DELETE-KEY 方法</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">method</span> <span class="nb">DELETE-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span>
</span></span></code></pre></div><p>删除和 <code>$key</code> 相关联的元素, 并返回它所删除的这个元素。这就是引用 <code>%foo&lt;aa&gt;:delete</code> 时, <code>postcircumfix { }</code> 所调用的方法。</p>
<p>&ldquo;删除&quot;元素的意思是什么, 取决于你的类型 &ndash; 尽管它通常让 <code>EXISTS-KEY</code> 因为那个键变为 <code>False</code>。</p>
<p>实现这个方法是可选的; 如果你没有实现它, 那么用户尝试从这种类型的对象中删除元素会得到一个合适的错误信息。</p>
<h3 id="assign-key-方法">ASSIGN-KEY 方法</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">method</span> <span class="nb">ASSIGN-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="o">,</span> <span class="nv">$new</span><span class="p">)</span>
</span></span></code></pre></div><p>把和 <code>$key</code>  相关联的元素设置为 <code>$new</code> 值。实现这个方法完全是可选的; 如果你没有实现这个方法, 那么会使用 <code>self.AT-KEY($key) = $new</code> 代替, 如果你确实实现了该方法, 那么确保它拥有相同的效果。</p>
<p>这意味着 opt-in 性能优化, 以至于简单的诸如 <code>%age&lt;Claire&gt; = 29</code> 的赋值能在不调用 <code>AT-KEY</code>(这必须创建并返回一个潜在的昂贵的容器对象) 方法时操作。</p>
<p>注意, 实现 <code>ASSIGN-KEY</code> 不能解除让 <code>AT-KEY</code> 变成一个 <code>rw</code> 方法, 因为诸如 <code>%age&lt;Claire&gt;++</code> 的不太重要的赋值/修改 仍旧会使用 <code>AT-KEY</code>。</p>
<h3 id="bind-key-方法">BIND-KEY 方法</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">method</span> <span class="nb">BIND-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="o">,</span> \<span class="nb">new</span><span class="p">)</span>
</span></span></code></pre></div><p>把值或容器 <code>new</code> 绑定给跟 <code>$key</code> 相关联的插槽上, 替换那儿能找到的任何容器。这是当你这样写的时候所调用的东西:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">%age</span><span class="p">&lt;</span><span class="s">Claire</span><span class="p">&gt;</span> <span class="o">:=</span> <span class="nv">$x</span><span class="p">;</span>
</span></span></code></pre></div><p>一般的散列类支持这以允许创建复杂的链接数据结构,  但是对于更特定领域类型它可能没有意义, 所以不强求去实现它。如果你没有实现该方法, 用户会获得一个合适的错误信息, 当它们尝试绑定到这种类型的对象的一个位置插槽上时。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[集合、包和混合]]></title>
            <link href="http://localhost:1313/rakulang/63.sets-bags-and-mixes/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/the-joy-of-unicode-in-perl6/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 7/25. Raku 中 Unicode 的乐趣" />
                <link href="http://localhost:1313/notes/making-a-list-with-yancy/?utm_source=atom_feed" rel="related" type="text/html" title="第六天 - 用 Yancy 制作一个列表" />
                <link href="http://localhost:1313/rakulang/62.routines/?utm_source=atom_feed" rel="related" type="text/html" title="例程" />
                <link href="http://localhost:1313/notes/testing-palindromic-numbers-inperl6/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 6/25. 在 Raku 中测试回文数字" />
                <link href="http://localhost:1313/notes/compound-selectors-are-easier-than-regexes/?utm_source=atom_feed" rel="related" type="text/html" title="第五天 - 复合选择器比正则表达式更容易" />
            
                <id>http://localhost:1313/rakulang/63.sets-bags-and-mixes/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-07T21:13:31+08:00</published>
            <updated>2018-12-07T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>简而言之，这些类通常包含无序的对象集合。Set 仅考虑这些对象是否存在，bags 可以容纳多个相同类型的对象，mixes 也允许分数（和负）权重。常规版本是不可变的，<em>Hash</em> 版本是可变的。</p>
<p>让我们详细说明一下。如果要收集容器中的对象但不关心这些对象的顺序，Raku 提供<em>无序</em>集合类型 <a href="https://docs.raku.org/type/Set">Set</a>, <a href="https://docs.raku.org/type/SetHash">SetHash</a>, <a href="https://docs.raku.org/type/Bag">Bag</a>, <a href="https://docs.raku.org/type/BagHash">BagHash</a>, <a href="https://docs.raku.org/type/Mix">Mix</a>, 和 <a href="https://docs.raku.org/type/MixHash">MixHash</a>. 由于无序，这些容器可以比 <a href="https://docs.raku.org/type/List">Lists</a> 更有效地查找元素或处理重复的项目。</p>
<p>另一方面，如果你想获得包含的对象（元素）<strong>而没有重复</strong>并且你只关心元素<em>是否</em>在集合中，你可以使用  <a href="https://docs.raku.org/type/Set">Set</a> 或 <a href="https://docs.raku.org/type/SetHash">SetHash</a>。如果你想消除重复但仍保留顺序，请查看 <a href="https://docs.raku.org/type/List">List</a> 的  <a href="https://docs.raku.org/routine/unique">unique</a> 例程。</p>
<p>如果你想跟踪<strong>每个对象出现的次数</strong>，你可以使用 <a href="https://docs.raku.org/type/Bag">Bag</a> 或 <a href="https://docs.raku.org/type/BagHash">BagHash</a>。在这些Baggy 容器中，每个元素都有一个权重（无符号整数），表示同一个对象已包含在集合中的次数。</p>
<p>类型 <a href="https://docs.raku.org/type/Mix">Mix</a> 和  <a href="https://docs.raku.org/type/MixHash">MixHash</a> 类似于 <a href="https://docs.raku.org/type/Bag">Bag</a> 和 <a href="https://docs.raku.org/type/BagHash">BagHash</a>，但它们也允许<strong>分数和负权重</strong>。</p>
<p><a href="https://docs.raku.org/type/Set">Set</a>，<a href="https://docs.raku.org/type/Bag">Bag</a> 和 <a href="https://docs.raku.org/type/Mix">Mix</a>  是 <em>immutable</em> 类型。如果要在构造容器后添加或删除元素，请使用可变变体 <a href="https://docs.raku.org/type/SetHash">SetHash</a>, <a href="https://docs.raku.org/type/BagHash">BagHash</a>, 和 <a href="https://docs.raku.org/type/MixHash">MixHash</a> 。</p>
<p>六个集合类 <code>Set</code>，<code>SetHash</code>，<code>Bag</code>，<code>BagHash</code>，<code>Mix</code>，<code>MixHash</code>，都有相似的语义。</p>
<p>首先，就它们而言，相同的对象引用相同的元素 - 其中使用 <a href="https://docs.raku.org/routine/WHICH">WHICH</a> 方法确定身份（即以相同的方式<a href="https://docs.raku.org/routine/===">===</a> 运算符检查身份）。对于像 <code>Str</code> 这样的值类型，这意味着具有相同的值; 对于像“Array”这样的引用类型，它意味着引用相同的对象实例。</p>
<p>其次，它们提供了类似 Hash 的接口，其中集合的实际元素（可以是任何类型的对象）是“键”，关联的权重是“值”：</p>
<table>
<thead>
<tr>
<th style="text-align:left">type of $a</th>
<th style="text-align:left">value of $a{$b} if $b is an element</th>
<th style="text-align:left">value of $a{$b} if $b is not an element</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Set / SetHash</td>
<td style="text-align:left">True</td>
<td style="text-align:left">False</td>
</tr>
<tr>
<td style="text-align:left">Bag / BagHash</td>
<td style="text-align:left">a positive integer</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">Mix / MixHash</td>
<td style="text-align:left">a non-zero real number</td>
<td style="text-align:left">0</td>
</tr>
</tbody>
</table>
<h1 id="setbag-operatorshttpsdocsrakuorglanguagesetbagmix___top"><a href="https://docs.raku.org/language/setbagmix#___top">Set/Bag operators</a></h1>
<p>有几个中缀运算符致力于在 <a href="https://docs.raku.org/type/Set">Set</a> 上执行常见操作，例如并集和差集。其他操作包括布尔检查，例如对象是否是 <code>Set</code> 中的元素，或者一个 <code>Set</code> 是否是另一个 <code>Set</code> 的子集。</p>
<p>这些中缀可以使用代表函数的 UTF-8 字符编写（如 <a href="https://docs.raku.org/routine/%E2%88%88">∈</a> 或 <a href="https://docs.raku.org/routine/%E2%88%AA">∪</a>），或与 <a href="https://docs.raku.org/routine/(elem)">(elem)</a> 或 <a href="https://docs.raku.org/routine/%E2%8A%96">(^)</a>。</p>
<p>大多数情况下，显式地使用带有这些中缀的 <code>Set</code> 对象是不必要的。所有中缀运算符都将处理 <a href="https://docs.raku.org/type/Any">Any</a> 类型的任何对象的参数（例如， <a href="https://docs.raku.org/type/List">List</a>），<a href="https://docs.raku.org/type/Array">Array</a>，<a href="https://docs.raku.org/type/Mix">Mix</a> 等）并强制他们到在需要的地方设置。</p>
<p>在某些情况下，如果参数的类型是 <a href="https://docs.raku.org/type/Bag">Bag</a>，则中缀运算符将以与其行为方式不同但类似的方式运行 <code>Set</code> 参数。</p>
<h2 id="operators-that-return-boolhttpsdocsrakuorglanguagesetbagmix___top"><a href="https://docs.raku.org/language/setbagmix#___top">Operators that return <code>Bool</code></a></h2>
<p>下面的运算符都是 “Chaining infix” 的优先级。</p>
<h3 id="infix-elemhttpsdocsrakuorglanguagesetbagmix___top"><a href="https://docs.raku.org/language/setbagmix#___top">infix (elem)</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">(elem)</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="kt">Any</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">(elem)</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="kt">Set</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>成员运算符。</p>
<p>返回i <code>True</code> 如果 <code>$a</code> 是 <code>$b</code> 中的一个<strong>元素</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">2</span> <span class="ow">(elem)</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>              <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">4</span> <span class="ow">(elem)</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>              <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top"><a href="https://docs.raku.org/language/setbagmix#___top">infix ∈</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">∈</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>另一个成员运算符。</p>
<p>等价于 <a href="https://docs.raku.org/routine/(elem)">(elem)</a>, 在代码点 U+2208 (ELEMENT OF).</p>
<h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-1"><a href="https://docs.raku.org/language/setbagmix#___top">infix ∉</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">∉</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>非成员运算符。</p>
<p>等价于 <code>!(elem)</code>, 例如, 返回 <code>True</code> 如果 <code>$a</code> 不是 <code>$b</code> 中的元素, 在代码点 U+2209 (NOT AN ELEMENT OF).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">2</span> <span class="o">!</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>             <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">4</span> <span class="o">!</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>             <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><h3 id="infix-conthttpsdocsrakuorglanguagesetbagmix___top"><a href="https://docs.raku.org/language/setbagmix#___top">infix (cont)</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">(cont)</span><span class="p">&gt;(</span><span class="kt">Any</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">(cont)</span><span class="p">&gt;(</span><span class="kt">Set</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>包含运算符。</p>
<p>返回 <code>True</code> 如果 <code>$a</code> <strong>contains</strong> <code>$b</code> 作为一个元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="ow">(cont)</span> <span class="mi">2</span><span class="p">;</span>              <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="ow">(cont)</span> <span class="mi">4</span><span class="p">;</span>              <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-2"><a href="https://docs.raku.org/language/setbagmix#___top">infix ∋</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">∋</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>另一个包含运算符。</p>
<p>等价于 <a href="https://docs.raku.org/routine/(cont)">(cont)</a>, 在代码点 U+220B (CONTAINS AS MEMBER).</p>
<h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-3"><a href="https://docs.raku.org/language/setbagmix#___top">infix ∌</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">∌</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>不包含运算符。</p>
<p>等价于 <code>!(cont)</code>, 例如, 返回 <code>True</code> 如果 <code>$a</code> 不包含 <code>$b</code>, 在代码点 U+220C (DOES NOT CONTAIN AS MEMBER).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="o">!</span><span class="p">(</span><span class="n">cont</span><span class="p">)</span> <span class="mi">2</span><span class="p">;</span>             <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="o">!</span><span class="p">(</span><span class="n">cont</span><span class="p">)</span> <span class="mi">4</span><span class="p">;</span>             <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-4"><a href="https://docs.raku.org/language/setbagmix#___top">infix (&lt;=)</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2">(&lt;=)</span><span class="p">&gt;&gt;(</span><span class="kt">Any</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Any</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2">(&lt;=)</span><span class="p">&gt;&gt;(</span><span class="kt">Setty</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Setty</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>子集或相等运算符。</p>
<p>返回 <code>True</code> 如果 <code>$a</code> 是  <code>$b</code>  的一个<strong>子集</strong>(subset) 或  <code>$a</code> 和 <code>$b</code> 相等, 例如, 如果 <code>$a</code> 中所有的元素都是 <code>$b</code> 中的元素, 且 <code>$a</code> 的大小小于或等于 <code>$b</code> 的大小。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="ow">(&lt;=)</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>    <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="ow">(&lt;=)</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>          <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="no">∅</span> <span class="ow">(&lt;=)</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>                <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-5"><a href="https://docs.raku.org/language/setbagmix#___top">infix ⊆</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">⊆</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>另一个子集或相等运算符。</p>
<p>等价于 <a href="https://docs.raku.org/routine/(%3C=)">(&lt;=)</a>, 在代码点 U+2286 (SUBSET OF OR EQUAL TO).</p>
<h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-6"><a href="https://docs.raku.org/language/setbagmix#___top">infix ⊈</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">⊈</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>既不是子集运算符也不是相等运算符。</p>
<p>等价于 <code>!(&lt;=)</code>, 在代码点 U+2288 (NEITHER A SUBSET OF NOR EQUAL TO).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="o">!</span><span class="p">(</span><span class="o">&lt;=</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>   <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="o">⊈</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>             <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-7"><a href="https://docs.raku.org/language/setbagmix#___top">infix (&lt;)</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2">(&lt;)</span><span class="p">&gt;&gt;(</span><span class="kt">Any</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Any</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2">(&lt;)</span><span class="p">&gt;&gt;(</span><span class="kt">Setty</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Setty</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>子集运算符。</p>
<p>返回 <code>True</code> 如果 <code>$a</code> 是 <code>$b</code> 的一个<strong>真子集</strong>(strict subset), 例如, <code>$a</code> 中的所有元素都是 <code>$b</code> 中的元素, 但是 <code>$a</code> 的大小比 <code>$b</code> 的大小要小。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="ow">(&lt;)</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>     <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="ow">(&lt;)</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>        <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="no">∅</span> <span class="ow">(&lt;)</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>                 <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-8"><a href="https://docs.raku.org/language/setbagmix#___top">infix ⊂</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">⊂</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>另一个子集运算符。</p>
<p>等价于 <a href="https://docs.raku.org/routine/(%3C)">(&lt;)</a>, 在代码点 U+2282 (SUBSET OF).</p>
<h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-9"><a href="https://docs.raku.org/language/setbagmix#___top">infix ⊄</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">⊄</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>非子集运算符。</p>
<p>等价于 <code>!(&lt;)</code>, 在代码点 U+2284 (NOT A SUBSET OF).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="o">!</span><span class="p">(</span><span class="o">&lt;</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>    <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="o">⊄</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>          <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-10"><a href="https://docs.raku.org/language/setbagmix#___top">infix (&gt;=)</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2">(&gt;=)</span><span class="p">&gt;&gt;(</span><span class="kt">Any</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Any</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2">(&gt;=)</span><span class="p">&gt;&gt;(</span><span class="kt">Setty</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Setty</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>超集或相等运算符。</p>
<p>像 <a href="https://docs.raku.org/routine/(%3C=)">(&lt;=)</a> 但是翻转参数。 返回 <code>True</code> 如果 <code>$a</code> 是 <code>$b</code> 的<strong>超集</strong>(superset) 或与 <code>$b</code> 相等。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="ow">(&gt;=)</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>    <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="ow">(&gt;=)</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>       <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="no">∅</span> <span class="ow">(&gt;=)</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>                <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-11"><a href="https://docs.raku.org/language/setbagmix#___top">infix ⊇</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">⊇</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>另一个超集或集合相等运算符。</p>
<p>等价于 <a href="https://docs.raku.org/routine/(%3E=)">(&gt;=)</a>, 在代码点 U+2287 (SUPERSET OF OR EQUAL TO).</p>
<h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-12"><a href="https://docs.raku.org/language/setbagmix#___top">infix ⊉</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">⊉</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>既不是超集运算符, 也非集合相等运算符。</p>
<p>等价于 <code>!(&gt;=)</code>, 在代码点 U+2289 (NEITHER A SUPERSET OF NOR EQUAL TO).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="o">!</span><span class="p">(</span><span class="o">&gt;=</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>   <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="o">⊉</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>          <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-13"><a href="https://docs.raku.org/language/setbagmix#___top">infix (&gt;)</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2">(&gt;)</span><span class="p">&gt;&gt;(</span><span class="kt">Any</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Any</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2">(&gt;)</span><span class="p">&gt;&gt;(</span><span class="kt">Setty</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Setty</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>超集运算符。</p>
<p>像 <a href="https://docs.raku.org/routine/(%3C)">(&lt;)</a> 但是反转参数。返回 <code>True</code> 如果 <code>$a</code> 是 <code>$b</code> 的一个<strong>严格超集</strong>(strict superset)。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="ow">(&gt;)</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>  <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="ow">(&gt;)</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>        <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="no">∅</span> <span class="ow">(&gt;)</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>                 <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-14"><a href="https://docs.raku.org/language/setbagmix#___top">infix ⊃</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">⊃</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>另一个超集运算符。</p>
<p>等价于 <a href="https://docs.raku.org/routine/(%3E)">(&gt;)</a>, 在代码点 U+2283 (SUPERSET OF).</p>
<h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-15"><a href="https://docs.raku.org/language/setbagmix#___top">infix ⊅</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">⊅</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</span></span></code></pre></div><p>非超集运算符。</p>
<p>等价于<code>!(&gt;)</code>, 在代码点 U+2285 (NOT A SUPERSET OF).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="o">!</span><span class="p">(</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span> <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="o">⊅</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>          <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><h2 id="operators-that-return-set-or-baghttpsdocsrakuorglanguagesetbagmix___top"><a href="https://docs.raku.org/language/setbagmix#___top">Operators that return <code>Set</code> or <code>Bag</code></a></h2>
<h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-16"><a href="https://docs.raku.org/language/setbagmix#___top">infix (|)</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">(|)</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@p</span><span class="p">)</span>
</span></span></code></pre></div><p>并集运算符。 它的优先级是 &ldquo;Junctive Or&rdquo;.</p>
<p>返回它所有参数的<strong>并集</strong>。通常, 这创建一个新的包含参数的所有元素的集合:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">a a b c d</span><span class="p">&gt;</span> <span class="ow">(|)</span> <span class="o">&lt;</span><span class="n">h</span> <span class="n">g</span> <span class="nb">f</span> <span class="nb">e</span> <span class="nb">d</span> <span class="n">c</span><span class="o">&gt;</span> <span class="ow">(|)</span> <span class="o">&lt;</span><span class="no">i</span> <span class="n">j</span><span class="o">&gt;</span> <span class="o">===</span> <span class="nb">set</span> <span class="p">&lt;</span><span class="s">a b c d e f g h i j</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>如果它的任何参数是 “Baggy”，它会创建一个新的 “Bag”，其中包含参数的所有元素，每个元素都按照该元素出现的最高权重进行加权。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a b c a</span><span class="p">&gt;)</span> <span class="ow">(|)</span> <span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a b c c</span><span class="p">&gt;)</span> <span class="o">===</span> <span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a a b c c</span><span class="p">&gt;)</span>
</span></span></code></pre></div><h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-17"><a href="https://docs.raku.org/language/setbagmix#___top">infix ∪</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">∪</span><span class="p">&gt;(</span><span class="o">|</span><span class="n">p</span><span class="p">)</span>
</span></span></code></pre></div><p>另一个并集运算符。它的优先级是 &ldquo;Junctive or&rdquo;.</p>
<p>等价于 <a href="https://docs.raku.org/routine/(%7C)">(|)</a>, 在代码点 U+222A (UNION).</p>
<h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-18"><a href="https://docs.raku.org/language/setbagmix#___top">infix (&amp;)</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">(&amp;)</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@p</span><span class="p">)</span>
</span></span></code></pre></div><p>交集运算符。它的优先级是 &ldquo;Junctive and&rdquo;.</p>
<p>返回它所有参数的<strong>交集</strong>。通常, 这创建一个包含所有参数都共有的元素的新的集合。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="ow">(&amp;)</span> <span class="o">&lt;</span><span class="n">b</span> <span class="n">c</span> <span class="nb">d</span><span class="o">&gt;</span> <span class="o">===</span> <span class="nb">set</span> <span class="p">&lt;</span><span class="s">b c</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">a b c d</span><span class="p">&gt;</span> <span class="ow">(&amp;)</span> <span class="o">&lt;</span><span class="n">b</span> <span class="n">c</span> <span class="nb">d</span> <span class="nb">e</span><span class="o">&gt;</span> <span class="ow">(&amp;)</span> <span class="o">&lt;</span><span class="n">c</span> <span class="nb">d</span> <span class="nb">e</span> <span class="nb">f</span><span class="o">&gt;</span> <span class="o">===</span> <span class="nb">set</span> <span class="p">&lt;</span><span class="s">c d</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>如果任何参数是 “Baggy”，则结果是一个包含公共元素的新 “Bag”，每个元素都由最大<em>共同</em>权重（这是所有参数中该元素的权重的最小值）加权。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a b c a</span><span class="p">&gt;)</span> <span class="ow">(&amp;)</span> <span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a b c c</span><span class="p">&gt;)</span> <span class="o">===</span> <span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a b c</span><span class="p">&gt;)</span>
</span></span></code></pre></div><h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-19"><a href="https://docs.raku.org/language/setbagmix#___top">infix ∩</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">∩</span><span class="p">&gt;(</span><span class="o">|</span><span class="n">p</span><span class="p">)</span>
</span></span></code></pre></div><p>另一个交集运算符。它的优先级是 &ldquo;Junctive and&rdquo;.</p>
<p>等价于 <a href="https://docs.raku.org/routine/(&amp;)">(&amp;)</a>, 在代码点 U+2229 (INTERSECTION).</p>
<h3 id="infix--httpsdocsrakuorglanguagesetbagmix___top"><a href="https://docs.raku.org/language/setbagmix#___top">infix (-)</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">(-)</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@p</span><span class="p">)</span>
</span></span></code></pre></div><p>差集运算符。它优先于“Junctive or”。</p>
<p>返回其所有参数的<strong>差集</strong>。通常，这将返回由第一个参数具有的所有元素组成的 “Set”，但不包括其余元素，即第一个参数的所有元素，减去其他参数中的元素。</p>
<p>如果第一个参数是 “Baggy”，则返回一个 “Bag”，其中包含第一个参数的每个元素，其权重减去每个其他参数中该元素的权重。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a b c a d</span><span class="p">&gt;)</span> <span class="ow">(-)</span> <span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a b c c</span><span class="p">&gt;)</span> <span class="o">===</span> <span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a d</span><span class="p">&gt;)</span>
</span></span><span class="line"><span class="cl"><span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a a a c d d d</span><span class="p">&gt;)</span> <span class="ow">(-)</span> <span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a b d a</span><span class="p">&gt;)</span> <span class="ow">(-)</span> <span class="nb">bag</span><span class="p">(&lt;</span><span class="s">d c</span><span class="p">&gt;)</span> <span class="o">===</span> <span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a d</span><span class="p">&gt;)</span>
</span></span></code></pre></div><h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-20"><a href="https://docs.raku.org/language/setbagmix#___top">infix ∖</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2">&#34;</span><span class="se">\x</span><span class="mh">2216</span><span class="s2">&#34;</span><span class="p">&gt;&gt;(</span><span class="o">|</span><span class="n">p</span><span class="p">)</span>
</span></span></code></pre></div><p>另一个差集运算符. 它的优先级是 &ldquo;Junctive or&rdquo;.</p>
<p>等价于 <a href="https://docs.raku.org/routine/(-)">(-)</a>.</p>
<h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-21"><a href="https://docs.raku.org/language/setbagmix#___top">infix (^)</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">(^)</span><span class="p">&gt;(</span><span class="kt">Any</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Any</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Setty</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">(^)</span><span class="p">&gt;(</span><span class="kt">Set</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Set</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Setty</span><span class="p">)</span>
</span></span></code></pre></div><p>对称差集运算符。 它的优先级是 “Junctive or“。</p>
<p>返回所有参数的<strong>对称差集</strong>，即 <code>Set</code> 由 <code>$a</code> 所有的元素组成，但 <code>$b</code> 没有，所有元素 <code>$b</code> 都有但是 <code>$a</code> 没有。 相当于  <code>($a ∖ $b) ∪ ($b ∖ $a)</code>。</p>
<h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-22"><a href="https://docs.raku.org/language/setbagmix#___top">infix ⊖</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">⊖</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Setty</span><span class="p">)</span>
</span></span></code></pre></div><p>另一个对称差集运算符。它的优先级是 &ldquo;Junctive or&rdquo;.</p>
<p>等价于 <a href="https://docs.raku.org/routine/($CIRCUMFLEX_ACCENT)">(^)</a>, 在代码点 U+2296 (CIRCLED MINUS).</p>
<h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-23"><a href="https://docs.raku.org/language/setbagmix#___top">infix (.)</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">(.)</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@p</span><span class="p">)</span>
</span></span></code></pre></div><p>Baggy 乘法运算符。它的优先级是 “Junctive and”。</p>
<p>返回其参数的 Baggy <strong>倍数</strong>，即 <code>Bag</code> 包含参数的每个元素，其中参数的元素权重相乘以获得新的权重。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="ow">(.)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="nb">d</span><span class="o">&gt;</span> <span class="o">===</span> <span class="nb">bag</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="c1"># Since 1 * 0 == 0, in the case of &#39;d&#39; </span>
</span></span><span class="line"><span class="cl"><span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a b c a d</span><span class="p">&gt;)</span> <span class="ow">(.)</span> <span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a b c c</span><span class="p">&gt;)</span> <span class="o">===</span> <span class="p">(&#34;</span><span class="s2">a</span><span class="p">&#34;</span><span class="o">=&gt;</span><span class="mi">6</span><span class="o">,</span><span class="p">&#34;</span><span class="s2">c</span><span class="p">&#34;</span><span class="o">=&gt;</span><span class="mi">2</span><span class="o">,</span><span class="p">&#34;</span><span class="s2">b</span><span class="p">&#34;</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Bag</span>
</span></span></code></pre></div><h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-24"><a href="https://docs.raku.org/language/setbagmix#___top">infix ⊍</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">⊍</span><span class="p">&gt;(</span><span class="o">|</span><span class="n">p</span><span class="p">)</span>
</span></span></code></pre></div><p>另一个 baggy 乘法运算符。 它的优先级是 &ldquo;Junctive and&rdquo;.</p>
<p>等价于<a href="https://docs.raku.org/routine/(.)">infix (.)</a>, 在代码点 U+228D (MULTISET MULTIPLICATION).</p>
<h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-25"><a href="https://docs.raku.org/language/setbagmix#___top">infix (+)</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">(+)</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@p</span><span class="p">)</span>
</span></span></code></pre></div><p>Baggy 加法运算符。它的优先级是 “Junctive or”。</p>
<p>返回其参数的 Baggy <strong>加法</strong>，即包含参数的每个元素，其中参数的权重加在一起以获得新的权重。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a b c a d</span><span class="p">&gt;)</span> <span class="ow">(+)</span> <span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a b c c</span><span class="p">&gt;)</span> <span class="o">===</span> <span class="p">(&#34;</span><span class="s2">a</span><span class="p">&#34;</span><span class="o">=&gt;</span><span class="mi">5</span><span class="o">,</span><span class="p">&#34;</span><span class="s2">c</span><span class="p">&#34;</span><span class="o">=&gt;</span><span class="mi">3</span><span class="o">,</span><span class="p">&#34;</span><span class="s2">b</span><span class="p">&#34;</span><span class="o">=&gt;</span><span class="mi">2</span><span class="o">,</span><span class="p">&#34;</span><span class="s2">d</span><span class="p">&#34;</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Bag</span>
</span></span></code></pre></div><h3 id="infix-httpsdocsrakuorglanguagesetbagmix___top-26"><a href="https://docs.raku.org/language/setbagmix#___top">infix ⊎</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">only</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">⊎</span><span class="p">&gt;(</span><span class="o">|</span><span class="n">p</span><span class="p">)</span>
</span></span></code></pre></div><p>另一个 baggy 加法 operator。 它的优先级是 &ldquo;Junctive or&rdquo;.</p>
<p>等价于 <a href="https://docs.raku.org/routine/(+)">(+)</a>, 在代码点 U+228E (MULTISET UNION).</p>
<h2 id="term-httpsdocsrakuorglanguagesetbagmix___top"><a href="https://docs.raku.org/language/setbagmix#___top">term ∅</a></h2>
<p>等价于 set(), 即空集, 在代码点 U+2205 (EMPTY SET).</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[例程]]></title>
            <link href="http://localhost:1313/rakulang/62.routines/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/testing-palindromic-numbers-inperl6/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 6/25. 在 Raku 中测试回文数字" />
                <link href="http://localhost:1313/notes/compound-selectors-are-easier-than-regexes/?utm_source=atom_feed" rel="related" type="text/html" title="第五天 - 复合选择器比正则表达式更容易" />
                <link href="http://localhost:1313/notes/what-s-the-date-today/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 5/25. 在 Raku 中今天是什么日期?" />
                <link href="http://localhost:1313/rakulang/61.regexes/?utm_source=atom_feed" rel="related" type="text/html" title="正则表达式" />
                <link href="http://localhost:1313/notes/test-hooks-and-helpers/?utm_source=atom_feed" rel="related" type="text/html" title="第四天 - 测试钩子和助手" />
            
                <id>http://localhost:1313/rakulang/62.routines/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-06T21:13:31+08:00</published>
            <updated>2018-12-06T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>关于怎样定义例程和使用例程, 请参阅 <a href="https://docs.raku.org/type/Sub">Sub</a> 。</p>
<h1 id="控制例程httpsdocsrakuorglanguageroutines___top"><a href="https://docs.raku.org/language/routines#___top">控制例程</a></h1>
<p>控制例程是能改变程序流的例程, 它可能会返回一个值。</p>
<h2 id="sub-exithttpsdocsrakuorglanguageroutines___top"><a href="https://docs.raku.org/language/routines#___top">sub exit</a></h2>
<p>定义为:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">exit</span><span class="p">(</span><span class="kt">Int</span><span class="p">()</span> <span class="nv">$status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><p>使用返回码 <code>$status</code> 退出当前进程，如果未指定值，则返回码为 0。退出值 (<code>$status</code>)，当不同于零时，必须从捕获它的进程（例如，shell）进行适当的计算; 它是从<a href="https://docs.raku.org/routine/MAIN">Main</a> 返回不同于零的退出代码的唯一方法。</p>
<p><code>exit</code> 防止 <a href="https://docs.raku.org/language/phasers#LEAVE">LEAVE</a> phaser 被执行, 但是它会在 <a href="https://docs.raku.org/language/variables#index-entry-%2524%2AEXIT"><code>&amp;*EXIT</code></a> 变量中运行。</p>
<p><code>exit</code> 应该作为最后的手段用于向父进程发出关于退出代码不等于零的信号，而不是异常地终止方法或 sub, 使用 <a href="https://docs.raku.org/language/exceptions">exceptions</a> 代替。</p>
<h2 id="done">done</h2>
<p>定义为:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">done</span><span class="p">(</span><span class="k">--&gt;</span> <span class="kt">Nil</span><span class="p">)</span>
</span></span></code></pre></div><p>如果用在任何 supply 或 react 块儿之外, 则抛出异常: <code>done without supply or react</code>。在 <a href="https://docs.raku.org/type/Supply">Supply</a> 块儿里面, 它会指示该 supply 不会再发出任何东西. 还请参阅 <a href="https://docs.raku.org/routine/done">documentation on method <code>done</code></a>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supply</span> <span class="o">=</span> <span class="k">supply</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">3</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">emit</span><span class="p">(</span><span class="nv">$_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nb">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">$supply</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span> <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Second : </span><span class="nv">$v</span><span class="p">&#34;</span> <span class="p">}</span><span class="o">,</span> <span class="s">done</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No more</span><span class="p">&#34;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: OUTPUT: «Second : 1␤Second : 2␤Second : 3␤No More␤» </span>
</span></span></code></pre></div><p>传递给 <code>done</code> 命名参数的块将在 <code>supply</code> 块中调用结束 (<code>done</code>) 时运行。</p>
<h2 id="emit">emit</h2>
<p>定义为:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">emit</span><span class="p">(</span>\<span class="nb">value</span> <span class="k">--&gt;</span> <span class="kt">Nil</span><span class="p">)</span>
</span></span></code></pre></div><p>如果在任何 supply 或 react 块儿外面使用 <code>emit</code>, 则抛出异常 <code>emit without supply or react</code>. 在 <a href="https://docs.raku.org/type/Supply">Supply</a> 块儿里面, 它会添加一条消息给 stream 流。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supply</span> <span class="o">=</span> <span class="k">supply</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nb">emit</span><span class="p">(</span><span class="nv">$_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">$supply</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span> <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">First : </span><span class="nv">$v</span><span class="p">&#34;</span> <span class="p">});</span>
</span></span></code></pre></div><p>还请参阅 <a href="https://docs.raku.org/routine/emit">the page for <code>emit</code> methods</a>.</p>
<h2 id="undefine">undefine</h2>
<p>定义为:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">undefine</span><span class="p">(</span><span class="kt">Mu</span>    \<span class="nb">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">undefine</span><span class="p">(</span><span class="kt">Array</span> \<span class="nb">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">undefine</span><span class="p">(</span><span class="kt">Hash</span>  \<span class="nb">x</span><span class="p">)</span>
</span></span></code></pre></div><p>在 6.d 中被<strong>废弃</strong>, 将在 6.e 中移除。 对于 <a href="https://docs.raku.org/type/Array">Array</a> 和 <a href="https://docs.raku.org/type/Hash">Hash</a>, 它会变得和赋值为 <a href="https://docs.raku.org/type/Slip#index-entry-Empty-Empty">Empty</a> 相等; 对于其它任何东西, 它会和赋值为 <a href="https://docs.raku.org/type/Nil">Nil</a> 相等, 建议使用它。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[正则表达式]]></title>
            <link href="http://localhost:1313/rakulang/61.regexes/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/test-hooks-and-helpers/?utm_source=atom_feed" rel="related" type="text/html" title="第四天 - 测试钩子和助手" />
                <link href="http://localhost:1313/notes/working-with-big-numbers-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 4/25. 在 Raku 中使用大数" />
                <link href="http://localhost:1313/notes/higher-order-promises/?utm_source=atom_feed" rel="related" type="text/html" title="第三天 - 高阶 Promises" />
                <link href="http://localhost:1313/rakulang/59.pragmas/?utm_source=atom_feed" rel="related" type="text/html" title="编译指令" />
                <link href="http://localhost:1313/notes/generating-random-integers-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 3/25. 在 Raku 中生成随机整数" />
            
                <id>http://localhost:1313/rakulang/61.regexes/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-05T21:13:31+08:00</published>
            <updated>2018-12-05T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>正则表达式, 简称 regexes, 是描述文本模式的字符序列。模式匹配就是将这些模式和实际的文本进行匹配的过程。</p>
<h2 id="词法约定">词法约定</h2>
<p>Raku 正则表达式有特殊的写法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">m</span><span class="p">/</span><span class="sr">abc</span><span class="p">/;</span>         <span class="c1"># a regex that is immediately matched against $_ </span>
</span></span><span class="line"><span class="cl"><span class="k">rx</span><span class="p">/</span><span class="sr">abc</span><span class="p">/;</span>        <span class="c1"># a Regex object </span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr">abc</span><span class="p">/;</span>          <span class="c1"># a Regex object </span>
</span></span></code></pre></div><p>对于前两个例子,  分隔符还能用除了斜线之外的其它字符:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">m</span><span class="p">{</span><span class="sr">abc</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">rx</span><span class="p">{</span><span class="sr">abc</span><span class="p">};</span>
</span></span></code></pre></div><p>注意, 冒号和圆括号都不能用作分隔符; 禁止使用冒号作为正则表达式分割符是因为它和副词冲突, 例如 <code>rx:i/abc/</code>(忽略大小写的正则表达式), 而圆括号表明函数调用。</p>
<p>空白符在正则表达式中通常被忽略(带有 <code>:s</code> 或 <code>:sigspace</code> 副词的正则表达式除外)。</p>
<p>通常, 对于 Raku 来说, 正则表达式中的注释以 <code>#</code> 号开头, 直至行尾。</p>
<h2 id="字面值">字面值</h2>
<p>正则表达式最简单的情况是匹配字符串字面值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">properly</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> perl </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">&#39;properly&#39; contains &#39;perl&#39;</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>字母数字和下划线 <code>_</code> 按字面值匹配。所有其它字符要么使用反斜线转义(例如, <code>\:</code> 匹配一个冒号), 要么用引号引起来:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">two words</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">/;</span>     <span class="c1"># matches &#39;two words&#39; including the blank </span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&#34;</span><span class="s2">a:b</span><span class="p">&#34;</span><span class="sr">       </span><span class="p">/;</span>     <span class="c1"># matches &#39;a:b&#39; including the colon </span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">#</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">/;</span>             <span class="c1"># matches a hash character </span>
</span></span></code></pre></div><p>字符串是从左往右搜索的, 所以如果只有部分字符串匹配正则表达式也足够:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abcdef</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> de </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$/</span><span class="p">;</span>            <span class="c1"># OUTPUT: «de␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">prematch</span><span class="p">;</span>    <span class="c1"># OUTPUT: «abc␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">postmatch</span><span class="p">;</span>   <span class="c1"># OUTPUT: «f␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">from</span><span class="p">;</span>        <span class="c1"># OUTPUT: «3␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">to</span><span class="p">;</span>          <span class="c1"># OUTPUT: «5␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>匹配结果存储在 <code>$/</code> 变量中并且也从匹配中返回。如果匹配成功, 那么结果就是 <a href="https://docs.raku.org/type/Match">Match</a> 类型, 否则它就是 <a href="https://docs.raku.org/type/Nil">Nil</a></p>
<h2 id="通配符和字符类">通配符和字符类</h2>
<h3 id="点号匹配任意字符-">点号匹配任意字符: .</h3>
<p>在正则表达式中一个未转义的点 <code>.</code>  匹配任意单个字符。</p>
<p>所以,  这些都匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">perl</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">per</span><span class="ni">.</span><span class="p">/;</span>       <span class="c1"># matches the whole string </span>
</span></span><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">perl</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> per </span><span class="ni">.</span><span class="sr"> </span><span class="p">/;</span>    <span class="c1"># the same; whitespace is ignored </span>
</span></span><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">perl</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> pe</span><span class="ni">.</span><span class="sr">l </span><span class="p">/;</span>     <span class="c1"># the . matches the r </span>
</span></span><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">speller</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> pe</span><span class="ni">.</span><span class="sr">l</span><span class="p">/;</span>   <span class="c1"># the . matches the first l </span>
</span></span></code></pre></div><p>下面这个不匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">perl</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">.</span><span class="sr"> per </span><span class="p">/;</span>
</span></span></code></pre></div><p>因为在目标字符串中 <code>per</code> 前面没有要匹配的字符。</p>
<h3 id="反斜杠-预定义字符类">反斜杠, 预定义字符类</h3>
<h3 id="unicode-properties">Unicode properties</h3>
<p>Raku 有 <code>\w</code> 形式的预定义字符类。大写形式是它的反面, <code>\W</code>。</p>
<ul>
<li>\d 和 \D</li>
</ul>
<p><code>\d</code> 匹配单个数字(Unicode 属性 N) 而 <code>\D</code> 匹配单个不是数字的字符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">ab42</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="se">\d</span><span class="p">/</span> <span class="ow">and</span> <span class="nb">say</span> <span class="o">~</span><span class="nv">$/</span><span class="p">;</span>     <span class="c1"># OUTPUT: «4␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">ab42</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="se">\D</span><span class="p">/</span> <span class="ow">and</span> <span class="nb">say</span> <span class="o">~</span><span class="nv">$/</span><span class="p">;</span>     <span class="c1"># OUTPUT: «a␤» </span>
</span></span></code></pre></div><p>注意, 不仅仅只有阿拉伯数字(通常用于拉丁字母表中)匹配 <code>\d</code>, 还有来自其它下标的数字也匹配 \d。</p>
<pre tabindex="0"><code>U+0035 5 DIGIT FIVE
U+07C2 ߂ NKO DIGIT TWO
U+0E53 ๓ THAI DIGIT THREE
U+1B56 ᭖ BALINESE DIGIT SIX
</code></pre><ul>
<li>\h 和 \H</li>
</ul>
<p><code>\h</code> 匹配单个水平空白符。 <code>\H</code> 匹配单个不是水平空白符的字符。</p>
<p>水平空白符的例子有:</p>
<pre tabindex="0"><code>U+0020 SPACE
U+00A0 NO-BREAK SPACE
U+0009 CHARACTER TABULATION
U+2001 EM QUAD
</code></pre><p>像换行符那样的垂直空白被显式地排除了; 那些可以用 <code>\v</code> 来匹配, 而 <code>\s</code> 匹配任何类型的空白:</p>
<ul>
<li>\n 和 \N</li>
</ul>
<p><code>\n</code> 匹配单个逻辑换行符。<code>\n</code> 也支持匹配 Windows 的 CR LF 代码点对儿;　尽管还不清楚魔法是发生在读取数据时还是在正则表达式匹配时。 <code>\N</code> 匹配单个非逻辑换行符。</p>
<ul>
<li>\s 和 \S</li>
</ul>
<p><code>\s</code> 匹配单个空白符。 <code>\S</code> 匹配单个非空白符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">contains a word starting with &#34;w&#34;</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> w </span><span class="se">\S</span><span class="o">+</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$/</span><span class="p">;</span>        <span class="c1"># OUTPUT: «word␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>\t 和 \T</li>
</ul>
<p><code>\t</code> 匹配单个 tab/制表符, <code>U+0009</code>。(注意这儿不包含诸如 <code>U+000B VERTICAL TABULATION</code> 这样奇异的制表符)。<code>\T</code> 匹配单个非制表符。</p>
<ul>
<li>\v 和 \V</li>
</ul>
<p><code>\v</code> 匹配单个垂直空白符。 <code>\V</code> 匹配单个非垂直空白符。</p>
<p>垂直空白符的例子:</p>
<pre tabindex="0"><code>U+000A LINE FEED
U+000B VERTICAL TABULATION
U+000C FORM FEED
U+000D CARRIAGE RETURN
U+0085 NEXT LINE
U+2028 LINE SEPARATOR
U+2029 PARAGRAPH SEPARATOR
</code></pre><p>使用 <code>\s</code> 去匹配任意空白, 而不仅仅匹配垂直空白。</p>
<ul>
<li>\w 和 \W</li>
</ul>
<p><code>\w</code> 匹配单个单词字符; 例如: 一个字母(Unicode 类别 L), 一个数字或一个下划线。<code>\W</code> 匹配单个非单词字符。</p>
<p>单词字符的例子:</p>
<pre tabindex="0"><code>0041 A LATIN CAPITAL LETTER A
0031 1 DIGIT ONE
03B4 δ GREEK SMALL LETTER DELTA
03F3 ϳ GREEK LETTER YOT
0409 Љ CYRILLIC CAPITAL LETTER LJE
</code></pre><p>预定义的 subrules:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">alnum</span><span class="p">&gt;</span>   \<span class="nb">w</span>       <span class="p">&#39;</span><span class="s1">alpha</span><span class="p">&#39;</span> <span class="nb">plus</span> <span class="p">&#39;</span><span class="s1">digit</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">alpha</span><span class="p">&gt;</span>   <span class="p">&lt;</span><span class="s">:L</span><span class="p">&gt;</span>     <span class="n">Alphabetic</span> <span class="n">characters</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">blank</span><span class="p">&gt;</span>   \<span class="n">h</span>       <span class="n">Horizontal</span> <span class="n">whitespace</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">cntrl</span><span class="p">&gt;</span>            <span class="n">Control</span> <span class="n">characters</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">digit</span><span class="p">&gt;</span>   \<span class="nb">d</span>       <span class="n">Decimal</span> <span class="n">digits</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">graph</span><span class="p">&gt;</span>            <span class="p">&#39;</span><span class="s1">alnum</span><span class="p">&#39;</span> <span class="nb">plus</span> <span class="p">&#39;</span><span class="s1">punct</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">lower</span><span class="p">&gt;</span>   <span class="p">&lt;</span><span class="s">:Ll</span><span class="p">&gt;</span>    <span class="n">Lowercase</span> <span class="n">characters</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">print</span><span class="p">&gt;</span>            <span class="p">&#39;</span><span class="s1">graph</span><span class="p">&#39;</span> <span class="nb">plus</span> <span class="p">&#39;</span><span class="s1">space</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">but</span> <span class="k">no</span> <span class="p">&#39;</span><span class="s1">cntrl</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">punct</span><span class="p">&gt;</span>            <span class="n">Punctuation</span> <span class="ow">and</span> <span class="n">Symbols</span> <span class="p">(</span><span class="n">only</span> <span class="n">Punct</span> <span class="n">beyond</span> <span class="n">ASCII</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">space</span><span class="o">&gt;</span>   \<span class="k">s</span>       <span class="err">Whitespace</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="sr">upper</span><span class="p">&gt;</span>   <span class="p">&lt;</span><span class="s">:Lu</span><span class="p">&gt;</span>    <span class="n">Uppercase</span> <span class="n">characters</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">|wb</span><span class="p">&gt;</span>               <span class="n">Word</span> <span class="n">Boundary</span> <span class="p">(</span><span class="n">zero-width</span> <span class="n">assertion</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">ww</span><span class="o">&gt;</span>               <span class="n">Within</span> <span class="n">Word</span> <span class="p">(</span><span class="n">zero-width</span> <span class="n">assertion</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">xdigit</span><span class="o">&gt;</span>           <span class="n">Hexadecimal</span> <span class="n">digit</span> <span class="o">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="n">A-Fa-f</span><span class="o">]</span>
</span></span></code></pre></div><h3 id="unicode-属性">Unicode 属性</h3>
<p>目前提到的字符类大多是为了方便; 另一种方法是使用 Unicode 字符属性。这些以 <code>&lt;:property&gt;</code> 的形式出现, 其中 <em>property</em> 可以是短的或长的 Unicode 一般类别名。它们使用 pair 语法。</p>
<p>要匹配一个 Unicode 属性:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">uniprop</span><span class="p">(&#39;</span><span class="s1">Script</span><span class="p">&#39;);</span>                 <span class="c1"># OUTPUT: «Latin␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;:</span><span class="na">Script</span><span class="p">&lt;</span><span class="s">Latin</span><span class="p">&gt;&gt;</span><span class="sr"> </span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">uniprop</span><span class="p">(&#39;</span><span class="s1">Block</span><span class="p">&#39;);</span>                  <span class="c1"># OUTPUT: «Basic Latin␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;:</span><span class="na">Block</span><span class="p">(&#39;</span><span class="s1">Basic Latin</span><span class="p">&#39;)&gt;</span><span class="sr"> </span><span class="p">/;</span>
</span></span></code></pre></div><p>下面的 Unicode 通用类别表是从 Perl 5 的 <a href="http://perldoc.perl.org/perlunicode.html">perlunicode</a> 文档偷来的:</p>
<pre tabindex="0"><code>Short	Long
L	Letter
LC	Cased_Letter
Lu	Uppercase_Letter
Ll	Lowercase_Letter
Lt	Titlecase_Letter
Lm	Modifier_Letter
Lo	Other_Letter
M	Mark
Mn	Nonspacing_Mark
Mc	Spacing_Mark
Me	Enclosing_Mark
N	Number
Nd	Decimal_Number (also Digit)
Nl	Letter_Number
No	Other_Number
P	Punctuation (also punct)
Pc	Connector_Punctuation
Pd	Dash_Punctuation
Ps	Open_Punctuation
Pe	Close_Punctuation
Pi	Initial_Punctuation
        (may behave like Ps or Pe depending on usage)
Pf	Final_Punctuation
        (may behave like Ps or Pe depending on usage)
Po	Other_Punctuation
S	Symbol
Sm	Math_Symbol
Sc	Currency_Symbol
Sk	Modifier_Symbol
So	Other_Symbol
Z	Separator
Zs	Space_Separator
Zl	Line_Separator
Zp	Paragraph_Separator
C	Other
Cc	Control (also cntrl)
Cf	Format
Cs	Surrogate
Co	Private_Use
Cn	Unassigned
</code></pre><p>举个例子: <code>&lt;:Lu&gt;</code> 匹配单个大写字母。</p>
<p>它的反面是这个: <code>&lt;:!property&gt;</code>。所以, <code>&lt;:!Lu&gt;</code> 匹配单个非大写字母的字符。</p>
<p>类别可以使用中缀操作符组合在一起:</p>
<pre tabindex="0"><code>Operator	Meaning
+	        set union
|	        set union
&amp;	        set intersection
-	        set difference (first minus second)
^	        symmetric set intersection / XOR
</code></pre><p>要匹配要么一个小写字母,要么一个数字, 可以写 <code>&lt;:Ll+:N&gt;</code> 或 <code>&lt;:Ll+:Number&gt;</code> 或 <code>&lt;+ :Lowercase_Letter + :Number&gt;</code>。</p>
<p>使用圆括号将类别和一组类别分组也是可以的; 例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">raku</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">{</span><span class="se">\w</span><span class="o">+</span><span class="p">(&lt;:</span><span class="na">Ll</span><span class="o">+</span><span class="p">:</span><span class="na">N</span><span class="p">&gt;)}</span>  <span class="c1"># OUTPUT: «0 =&gt; ｢6｣␤» </span>
</span></span></code></pre></div><h3 id="可枚举的字符类和区间">可枚举的字符类和区间</h3>
<p>有时候, 预先存在的通配符和字符类不够用。幸运的是, 定义你自己的字符类相当简单。在 <code>&lt;[]&gt;</code> 中, 你可以放入任何数量的单个字符和字符区间(两个端点之间有两个点号), 带有或不带有空白。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">abacabadabacaba</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr"> a </span><span class="o">..</span><span class="sr"> c </span><span class="mi">1</span><span class="sr"> </span><span class="mi">2</span><span class="sr"> </span><span class="mi">3</span><span class="sr"> </span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Unicode hex codepoint range </span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">ÀÁÂÃÄÅÆ</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr"> </span><span class="se">\x</span><span class="p">[</span><span class="mh">00C0</span><span class="p">]</span><span class="sr"> </span><span class="o">..</span><span class="sr"> </span><span class="se">\x</span><span class="p">[</span><span class="mh">00C6</span><span class="p">]</span><span class="sr"> </span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Unicode named codepoint range </span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">ÀÁÂÃÄÅÆ</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr"> </span><span class="se">\c</span><span class="p">[</span><span class="s">LATIN CAPITAL LETTER A WITH GRAVE</span><span class="p">]</span><span class="sr"> </span><span class="o">..</span><span class="sr"> </span><span class="se">\c</span><span class="p">[</span><span class="s">LATIN CAPITAL LETTER AE</span><span class="p">]</span><span class="sr"> </span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">/;</span>
</span></span></code></pre></div><p>在 <code>&lt;&gt;</code> 中你可以使用 <code>+</code> 或 <code>-</code> 来添加或移除多个区间定义, 甚至混合某些上面的 unicode 属性。你还可以在 <code>[]</code> 之间写上反斜线形式的字符类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&lt;[</span><span class="se">\d</span><span class="p">]</span> <span class="o">-</span> <span class="p">[</span><span class="mi">13579</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># starts with \d and removes odd ASCII digits, but not quite the same as </span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&lt;[</span><span class="mo">0246</span><span class="mi">8</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># because the first one also contains &#34;weird&#34; unicodey digits </span>
</span></span></code></pre></div><p>解析引号分割的字符串的一个常见模式涉及到对字符类取反:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">&#34;in quotes&#34;</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> &#34; </span><span class="p">]&gt;</span><span class="sr"> </span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;/;</span>
</span></span></code></pre></div><p>这先匹配一个引号, 然后匹配任何不是引号的字符, 再然后还是一个引号。 上面例子中的 <code>*</code> 和 <code>+</code> 会在<a href="https://docs.raku.org/language/regexes#Quantifiers">量词</a>一节中解释。</p>
<p>就像你可以使用 <code>-</code> 用于集合差集和取反单个值, 你也可以在前面显式地放上一个 <code>+</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">+</span><span class="p">[</span><span class="mi">123</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">/</span>  <span class="c1"># same as &lt;[123]&gt; </span>
</span></span></code></pre></div><h2 id="量词">量词</h2>
<p>量词使前面的原子匹配可变次数。例如, <code>a+</code> 匹配一个或多个字符 <em>a</em>。</p>
<p>量词比连结绑定的更紧, 所以 <code>ab+</code> 匹配一个 <em>a</em>, 然后跟着一个或多个 <em>b</em>。对于引号来说, 有点不同, 所以 <code>'ab'+</code> 匹配字符串 <em>ab</em>, <em>abab</em>, <em>ababab</em> 等等。</p>
<h3 id="一次-或多次--">一次 或多次 : +</h3>
<p><code>+</code> 量词使它前面的原子匹配一次或多次, 没有次数上限。</p>
<p>例如, 要匹配 <code>form=value</code> 形式的字符串, 你可以这样写正则表达式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">/</span>
</span></span></code></pre></div><h3 id="零次-或-多次-">零次 或 多次: *</h3>
<p><code>*</code> 量词使它前面的原子匹配一次或多次, 没有次数上限。</p>
<p>例如, 要允许 <em>a</em> 和 <em>b</em> 之间出现可选的空白,  你可以这样写:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> a </span><span class="se">\s</span><span class="o">*</span><span class="sr"> b </span><span class="p">/</span>
</span></span></code></pre></div><h3 id="零次-或-一次匹配-">零次 或 一次匹配: ?</h3>
<p><code>?</code> 量词使它前面的原子匹配零次或一次。</p>
<h3 id="常规量词--minmax">常规量词: ** min..max</h3>
<p>要限定原子匹配任意次数,　你可以写出像 <code>a ** 2..5</code> 那样的表达式来匹配字符 <em>a</em> 至少 2 次, 至多 5 次。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">**</span><span class="sr"> </span><span class="mi">2</span><span class="o">..</span><span class="mi">5</span><span class="p">/;</span>        <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span>  <span class="p">&#39;</span><span class="s1">aaa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">**</span><span class="sr"> </span><span class="mi">2</span><span class="o">..</span><span class="mi">5</span><span class="p">/;</span>     <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>如果最小匹配次数和最大匹配次数相同, 那么使用单个整数: <code>a ** 5</code> 精确地匹配 5 次。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">aaaaa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">**</span><span class="sr"> </span><span class="mi">5</span><span class="p">/;</span>       <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>也可以使用 <code>^</code> 脱字符来排除区间的端点:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span>    <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="ni">^</span><span class="o">..</span><span class="ni">^</span><span class="mi">6</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «False␤» -- there are 2 to 5 &#39;a&#39;s in a row </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">aaaa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="ni">^</span><span class="o">..</span><span class="ni">^</span><span class="mi">6</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>下面这个包含从 0 开始的数值区间:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">aaa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">**</span><span class="sr"> </span><span class="ni">^</span><span class="mi">6</span><span class="p">/;</span>        <span class="c1"># OUTPUT: «True␤» -- there are 0 to 5 &#39;a&#39;s in a row </span>
</span></span></code></pre></div><p>或使用一个 Whatever Star <code>*</code> 操作符来表示无限区间:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">aaaa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="ni">^</span><span class="o">..*</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «True␤» -- there are 2 or more &#39;a&#39;s in a row </span>
</span></span></code></pre></div><h3 id="modified-quantifier-">Modified quantifier: %</h3>
<p>为了更容易地匹配逗号分割那样的值, 你可以在以上任何一个量词后面加上一个 <code>%</code> 修饰符以指定某个修饰符必须出现在每一次匹配之间。例如, <code>a+ % ','</code> 会匹配 <em>a</em>, 或 <em>a,a</em> 或 <em>a,a,a</em> 等等, 但是不会匹配 <em>a,</em> 或 <em>a,a,</em> 等。要连这些也要匹配, 那么使用 <code>%%</code> 代替 <code>%</code>。</p>
<h3 id="贪婪量词-vs-非贪婪量词-">贪婪量词 Vs. 非贪婪量词: ?</h3>
<p>默认地, 量词要求进行贪婪匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">abababa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="ni">.</span><span class="o">*</span><span class="sr"> a</span><span class="p">/</span> <span class="o">&amp;&amp;</span> <span class="nb">say</span> <span class="o">~</span><span class="nv">$/</span><span class="p">;</span>   <span class="c1"># OUTPUT: «abababa␤» </span>
</span></span></code></pre></div><p>你可以给量词附加一个 <code>?</code> 修饰符来开启非贪婪匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">abababa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="ni">.</span><span class="o">*?</span><span class="sr"> a</span><span class="p">/</span> <span class="o">&amp;&amp;</span> <span class="nb">say</span> <span class="o">~</span><span class="nv">$/</span><span class="p">;</span>   <span class="c1"># OUTPUT: «aba␤» </span>
</span></span></code></pre></div><p>你还可以使用 <code>!</code> 修饰符显式地要求贪婪匹配。</p>
<h3 id="阻止回溯-">阻止回溯: :</h3>
<p>你可以在正则表达式中通过为量词附加一个 <code>:</code> 修饰符来阻止回溯:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">abababa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="ni">.</span><span class="o">*</span><span class="sr"> aba</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">abababa</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="ni">.</span><span class="o">*:</span><span class="sr"> aba</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><h2 id="alternation-">Alternation: ||</h2>
<p><a href="https://docs.raku.org/language/regexes#Alternation:_%7C%7C">||</a> 在正则表达式中表示备选分支, 在匹配由 <code>||</code> 分割的几个可能的备选分支之一时, <strong>第一个</strong>匹配的备选分支胜出。例如, <em>ini</em> 文件有如下形式:</p>
<pre tabindex="0"><code>[section]
key = value
</code></pre><p>因此, 如果你解析单行 <em>ini</em> 文件, 那么它要么是一个 section, 要么是一个键值对儿。所以正则表达式可以是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">||</span><span class="sr"> </span><span class="se">\S</span><span class="o">+</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="se">\S</span><span class="o">*</span><span class="sr"> </span><span class="p">/</span>
</span></span></code></pre></div><p>即, 它要么是一个由方括号包围起来的单词, 要么是一个键值对。</p>
<h2 id="longest-alternation-">Longest Alternation: |</h2>
<p>如果正则表达式由 <code>|</code> 分割, 则最长的那个匹配胜出。独立于正则表达式中的词法顺序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> a </span><span class="o">|</span><span class="sr"> </span><span class="ni">.</span><span class="sr">b </span><span class="p">/)</span><span class="o">.</span><span class="kt">Str</span><span class="p">;</span>    <span class="c1"># OUTPUT: «ab␤» </span>
</span></span></code></pre></div><h2 id="anchors">Anchors</h2>
<p>正则表达式引擎尝试在字符串中从左至右地搜索来查找匹配。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">properly</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> perl</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="c1">#          ^^^^ </span>
</span></span></code></pre></div><p>有时候这不是你想要的。相反, 你可能只想匹配整个字符串, 或一整行, 或精确地一个或几个完整的单词。锚或断言能帮助我们。</p>
<p>为了整个正则表达式能够匹配, 断言需要被成功地匹配但是断言在匹配时不消耗字符。</p>
<h3 id="--start-of-string-and---end-of-string">^ , Start of String and $ , End of String</h3>
<p><code>^</code> 断言只匹配字符串的开头:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">properly</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">  perl</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">properly</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr"> perl</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">perly</span><span class="p">&#39;</span>    <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr"> perl</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">perl</span><span class="p">&#39;</span>     <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr"> perl</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p><code>$</code> 断言只匹配字符串的结尾:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">use perl</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">  perl  </span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">use perl</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">  perl </span><span class="ni">$</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">perly</span><span class="p">&#39;</span>    <span class="o">~~</span> <span class="p">/</span><span class="sr">  perl </span><span class="ni">$</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><p>你可以把这两个断言组合起来:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">use perl</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr"> perl </span><span class="ni">$</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">perl</span><span class="p">&#39;</span>     <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr"> perl </span><span class="ni">$</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>记住, <code>^</code> 匹配<strong>字符串</strong>的开头, 而非<strong>行</strong>的开头。同样地, <code>$</code> 匹配<strong>字符串</strong>的结尾, 而非<strong>行</strong>的结尾。</p>
<p>下面的是多行字符串:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOS/;</span><span class="s"> 
</span></span></span><span class="line"><span class="cl"><span class="s">   Keep it secret
</span></span></span><span class="line"><span class="cl"><span class="s">   and keep it safe
</span></span></span><span class="line"><span class="cl"><span class="s">   </span><span class="p">EOS</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">safe   </span><span class="ni">$</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤»  -- &#39;safe&#39; is at the end of the string </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">secret </span><span class="ni">$</span><span class="p">/;</span>   <span class="c1"># OUTPUT: «False␤» -- &#39;secret&#39; is at the end of a line -- not the string </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr">Keep   </span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤»  -- &#39;Keep&#39; is at the start of the string </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr">and    </span><span class="p">/;</span>   <span class="c1"># OUTPUT: «False␤» -- &#39;and&#39; is at the start of a line -- not the string </span>
</span></span></code></pre></div><h3 id="--start-of-line-and---end-of-line">^^ , Start of Line and $$ , End of Line</h3>
<p><code>^^</code> 断言匹配逻辑行的开头。即, 要么在字符串的开头, 要么在换行符之后。然而, 它不匹配字符串的结尾, 即使它以一个换行符结尾。</p>
<p><code>$$</code> 只匹配逻辑换行符的结尾, 即, 在换行符之前, 或在字符串的结尾, 当最后一个字符不是换行符时。</p>
<p>(为了理解下面的示例, 最好先了解 <code>q:to/EOS/...EOS</code> 的 &ldquo;heredoc&rdquo; 语法移除了前置的缩进, 使之与 <code>EOS</code> 标记同级, 以至于第一行, 第二行和最后一行没有前置空格而第三行和第四行各有两个前置空格。)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOS/;</span><span class="s"> 
</span></span></span><span class="line"><span class="cl"><span class="s">    There was a young man of Japan
</span></span></span><span class="line"><span class="cl"><span class="s">    Whose limericks never would scan.
</span></span></span><span class="line"><span class="cl"><span class="s">      When asked why this was,
</span></span></span><span class="line"><span class="cl"><span class="s">      He replied &#34;It&#39;s because
</span></span></span><span class="line"><span class="cl"><span class="s">    I always try to fit as many syllables into the last line as ever I possibly can.&#34;
</span></span></span><span class="line"><span class="cl"><span class="s">    </span><span class="p">EOS</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^^</span><span class="sr"> There</span><span class="p">/;</span>        <span class="c1"># OUTPUT: «True␤»  -- start of string </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^^</span><span class="sr"> limericks</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «False␤» -- not at the start of a line </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^^</span><span class="sr"> I</span><span class="p">/;</span>            <span class="c1"># OUTPUT: «True␤»  -- start of the last line </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^^</span><span class="sr"> When</span><span class="p">/;</span>         <span class="c1"># OUTPUT: «False␤» -- there are blanks between </span>
</span></span><span class="line"><span class="cl">                                  <span class="c1">#                       start of line and the &#34;When&#34; </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> Japan </span><span class="ni">$$</span><span class="p">/;</span>       <span class="c1"># OUTPUT: «True␤»  -- end of first line </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> scan </span><span class="ni">$$</span><span class="p">/;</span>        <span class="c1"># OUTPUT: «False␤» -- there&#39;s a . between &#34;scan&#34; </span>
</span></span><span class="line"><span class="cl">                                  <span class="c1">#                      and the end of line </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">.&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="ni">$$</span><span class="p">/;</span>        <span class="c1"># OUTPUT: «True␤»  -- at the last line </span>
</span></span></code></pre></div><h3 id="w-and-w-word-boundary">&lt;|w&gt; and &lt;!|w&gt;, word boundary</h3>
<p>要匹配单词边界, 使用 <code>&lt;|w&gt;</code>。这与其它语言的 <code>\b</code> 类似，要匹配一个非单词边界, 使用 <code>&lt;!|w&gt;</code>, 类似其它语言的 <code>\B</code>。这些都是零宽断言。</p>
<h3 id="-and---left-and-right-word-boundary">&laquo; and &raquo; , left and right word boundary</h3>
<p><code>&lt;&lt;</code> 匹配左单词边界。它匹配左侧(或者字符串的开头)是非单词字符而右侧是一个单词字符的位置。</p>
<p><code>&gt;&gt;</code> 匹配右单词边界。它匹配左侧有一个单词字符而右侧(或者字符串的结尾)是一个非单词字符的位置。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">The quick brown fox</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">br</span><span class="p">/;</span>              <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="o">&lt;&lt;</span><span class="sr"> br</span><span class="p">/;</span>           <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">br </span><span class="o">&gt;&gt;</span><span class="p">/;</span>           <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">own</span><span class="p">/;</span>             <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="o">&lt;&lt;</span><span class="sr"> own</span><span class="p">/;</span>          <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">own </span><span class="o">&gt;&gt;</span><span class="p">/;</span>          <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>你可以使用变体 <strong>«</strong> 和 <strong>»</strong> :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">The quick brown fox</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="o">«</span><span class="sr"> own</span><span class="p">/;</span>          <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">own </span><span class="o">»</span><span class="p">/;</span>          <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><h2 id="分组和捕获">分组和捕获</h2>
<p>在普通的(非正则表达式)Raku 代码中, 你可以使用圆括号把东西组织到一块, 通常用于覆盖操作符优先级:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>   <span class="c1"># 9, parsed as 1 + (4*2)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span> <span class="c1"># 输出: 10</span>
</span></span></code></pre></div><p>在正则表达式中也可以使用同样的分组工具:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> a </span><span class="o">||</span><span class="sr"> b c</span><span class="p">/;</span>   <span class="c1"># 匹配 &#39;a&#39; 或 &#39;bc&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="sr">a </span><span class="o">||</span><span class="sr"> b</span><span class="p">)</span><span class="sr"> c</span><span class="p">/;</span> <span class="c1"># 匹配 &#39;ac&#39; 或 &#39;bc&#39;</span>
</span></span></code></pre></div><p>分组可以应用在量词上:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> a b</span><span class="o">+</span><span class="sr"> </span><span class="p">/;</span>      <span class="c1"># 匹配一个 &#39;a&#39;, 后面再跟着一个或多个 &#39;b&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="sr">a b</span><span class="p">)</span><span class="o">+</span><span class="p">/;</span>     <span class="c1"># 匹配一个或多个 &#39;ab&#39; 序列</span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="sr">a </span><span class="o">||</span><span class="sr"> b</span><span class="p">)</span><span class="o">+</span><span class="sr"> </span><span class="p">/;</span> <span class="c1"># 匹配一个 &#39;a&#39; 序列或者 &#39;b&#39; 序列, 至少一次</span>
</span></span></code></pre></div><p>一个非量词化的捕获产生一个 <a href="https://docs.raku.org/type/Match">Match</a>对象。当捕获被量化(除了使用 ? 量词)之后, 该捕获就变成 <a href="https://docs.raku.org/type/Match">Match</a>对象的列表。</p>
<h3 id="捕获">捕获</h3>
<p>圆括号不仅仅能够分组, 它们也<em>捕获</em>; 也就是说, 它们使分组中匹配到的字符串用作变量，并且还作为生成的 <a href="https://docs.raku.org/type/Match">Match</a> 对象的元素:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">number 42</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="p">/&#39;</span><span class="s1">number</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The number is </span><span class="nv">$0</span><span class="p">&#34;;</span>    <span class="c1"># The number is 42</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># or</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The number is $/[0]</span><span class="p">&#34;;</span> <span class="c1"># The number is 42</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>圆括号对儿是从左到右编号的, 编号从零开始。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/(</span><span class="sr">a</span><span class="p">)</span><span class="sr"> b </span><span class="p">(</span><span class="sr">c</span><span class="p">)/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">0:</span><span class="nv">$0</span><span class="s2">; 1:</span><span class="nv">$1</span><span class="p">&#34;;</span> <span class="c1"># 输出: 0:a; 1:c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>$0</code> 和 <code>$1</code> 等语法是简写的。这些捕获可以从用作列表的匹配对象 <code>$/</code> 中规范地获取到, 所以, <code>$0</code> 实际上是 <code>$/[0]</code> 的语法糖。</p>
<p>将匹配对象强制转换为列表可以方便地以编程方式访问所有元素:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/(</span><span class="sr">a</span><span class="p">)</span><span class="sr"> b </span><span class="p">(</span><span class="sr">c</span><span class="p">)/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">list</span><span class="o">.</span><span class="nb">join</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">,</span><span class="p">&#39;;</span> <span class="c1"># 输出 a,c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="非捕获分组">非捕获分组</h3>
<p>正则表达式中的圆括号扮演了双重角色: 它们将内部的正则表达式元素分组, 并通过内部的子正则表达式捕获所匹配到的内容。</p>
<p>要仅仅获得分组行为, 可以使用方括号 <code>[...]</code> 代替圆括号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">[</span><span class="sr">a</span><span class="o">||</span><span class="sr">b</span><span class="p">]</span><span class="sr"> </span><span class="p">(</span><span class="sr">c</span><span class="p">)</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$0</span><span class="p">;</span>                <span class="c1"># OUTPUT: «c␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果您不需要捕获, 则使用非捕获分组可提供三个好处: 它们更干净地传达正则表达式; 它们使您更容易对您关心的捕获组计数; 并且它匹配比较快。</p>
<h3 id="捕获编号">捕获编号</h3>
<p>上面已经说明，捕获从左到右编号。 原则上是真的，这也是过于简单的。</p>
<p>为了完整起见，列出了以下规则。 当您发现自己经常使用它们时，考虑命名捕获（可能是 subrules）是值得的。</p>
<p>备选分支会重置捕获计数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="sr">x</span><span class="p">)</span><span class="sr"> </span><span class="p">(</span><span class="sr">y</span><span class="p">)</span><span class="sr">  </span><span class="o">||</span><span class="sr"> </span><span class="p">(</span><span class="sr">a</span><span class="p">)</span><span class="sr"> </span><span class="p">(</span><span class="ni">.</span><span class="p">)</span><span class="sr"> </span><span class="p">(</span><span class="ni">.</span><span class="p">)</span><span class="sr"> </span><span class="p">/</span>
</span></span><span class="line"><span class="cl"><span class="c1"># $0  $1      $0  $1  $2 </span>
</span></span></code></pre></div><p>例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/(</span><span class="sr">x</span><span class="p">)(</span><span class="sr">y</span><span class="p">)</span><span class="sr"> </span><span class="o">||</span><span class="sr"> </span><span class="p">(</span><span class="sr">a</span><span class="p">)(</span><span class="ni">.</span><span class="p">)(</span><span class="ni">.</span><span class="p">)/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$1</span><span class="p">;</span>            <span class="c1"># b </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果两个（或多个）备选分支具有不同的捕获编号，则捕获编号最多的决定了下一个捕获的索引：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">abcd</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">/</span> <span class="n">a</span> <span class="o">[</span> <span class="n">b</span> <span class="ow">(.)</span> <span class="o">||</span> <span class="p">(</span><span class="nb">x</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">]</span> <span class="ow">(.)</span> <span class="o">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#      $0     $0  $1    $2 </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$2</span><span class="p">;</span>           <span class="c1"># d </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>捕获可以嵌套，在这种情况下，它们的每一级都会编号:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="sr"> a </span><span class="p">(</span><span class="ni">.</span><span class="p">)</span><span class="sr"> </span><span class="p">(</span><span class="ni">.</span><span class="p">)</span><span class="sr"> </span><span class="p">)</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Outer: </span><span class="nv">$0</span><span class="p">&#34;;</span>                <span class="c1"># Outer: abc </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Inner: </span><span class="nv">$0</span><span class="s2">[0] and </span><span class="nv">$0</span><span class="s2">[1]</span><span class="p">&#34;;</span>   <span class="c1"># Inner: b and c </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="命名捕获">命名捕获</h3>
<p>除了给捕获编号，你也可以给他们起名字。 命名捕获的通用和略微冗长的方式是这样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="nv">$&lt;myname&gt;</span><span class="sr"> </span><span class="o">=</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$&lt;myname&gt;</span>      <span class="c1"># OUTPUT: «abc␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对命名捕获 <em>$<!-- raw HTML omitted --></em> 的访问是将匹配对象作为哈希索引的简写，换句话说：<code>$/{'myname'}</code> 或 <code>$/&lt;myname&gt;</code>。</p>
<p>命名捕获也可以使用常规捕获分组语法进行嵌套:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc-abc-abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="nv">$&lt;string&gt;</span><span class="o">=</span><span class="p">(</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="nv">$&lt;part&gt;</span><span class="o">=</span><span class="p">[</span><span class="sr">abc</span><span class="p">]</span><span class="sr"> </span><span class="p">]</span><span class="o">*</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">)</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$&lt;string&gt;</span><span class="p">;</span>         <span class="c1"># OUTPUT: «abc-abc-abc␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$&lt;string&gt;</span><span class="p">&lt;</span><span class="s">part</span><span class="p">&gt;;</span>   <span class="c1"># OUTPUT: «[abc, abc, abc]␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>将匹配对象强制为散列可让您轻松地以编程方式访问所有命名捕获:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">count=23</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="nv">$&lt;variable&gt;</span><span class="o">=</span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="nv">$&lt;value&gt;</span><span class="o">=</span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">hash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">%h</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">sort</span><span class="o">.</span><span class="nb">join</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">, </span><span class="p">&#39;;</span>        <span class="c1"># OUTPUT: «value, variable␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">%h</span><span class="o">.</span><span class="nb">values</span><span class="o">.</span><span class="nb">sort</span><span class="o">.</span><span class="nb">join</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">, </span><span class="p">&#39;;</span>      <span class="c1"># OUTPUT: «23, count␤» </span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nv">%h</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$k</span><span class="o">,</span> <span class="nv">$v</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Found value &#39;</span><span class="nv">$v&#39;</span><span class="s2"> with key &#39;</span><span class="nv">$k&#39;</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># outputs two lines: </span>
</span></span><span class="line"><span class="cl">        <span class="c1">#   Found value &#39;count&#39; with key &#39;variable&#39; </span>
</span></span><span class="line"><span class="cl">        <span class="c1">#   Found value &#39;23&#39; with key &#39;value&#39; </span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在 Subrules 部分会讨论获取命名捕获的更方便的方法。</p>
<h3 id="capture-markers--">Capture markers: &lt;( )&gt;</h3>
<p><code>&lt;(</code> token 表示匹配的整体捕捉的开始，而相应的 <code>)&gt;</code> token 表示其末端。 <code>&lt;(</code> 类似于其他语言的 <code>\K</code> 丢弃 <code>\K</code> 之前找到的任何匹配项。</p>
<h2 id="替换">替换</h2>
<p>正则表达式也可以用来替换另一个文本。 您可以使用它来解决拼写错误(例如, 用 &ldquo;Pearl Jam&rdquo; 替换 &ldquo;Perl Jam&rdquo;), 从 <code>yyyy-mm-ddThh:mm:ssZ</code> 到 <code>mm-dd-yy h:m {AM,PM}</code> 重新格式化 ISO8601 日期及其它。</p>
<p>就像搜索替换编辑器的对话框一样，<code>s///</code> 操作符有两面，左侧和右侧。 左侧是匹配表达式的位置，右侧是您要替换的表达式。</p>
<h3 id="词汇约定">词汇约定</h3>
<p>替换和匹配的写法类似，但替换运算符既有正则表达式匹配的区域，也有替换的文本区域：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">s</span><span class="p">/</span><span class="sr">replace</span><span class="p">/</span><span class="s2">with</span><span class="p">/;</span>           <span class="c1"># a substitution that is applied to $_ </span>
</span></span><span class="line"><span class="cl"><span class="nv">$str</span> <span class="o">~~</span> <span class="k">s</span><span class="p">/</span><span class="sr">replace</span><span class="p">/</span><span class="s2">with</span><span class="p">/;</span>   <span class="c1"># a substitution applied to a scalar </span>
</span></span></code></pre></div><p>替换操作法允许除了斜线之外的分隔符:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">s</span><span class="p">|</span><span class="sr">replace</span><span class="p">|</span><span class="s2">with</span><span class="p">|;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">!</span><span class="sr">replace</span><span class="p">!</span><span class="s2">with</span><span class="p">!;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">,</span><span class="sr">replace</span><span class="p">,</span><span class="s2">with</span><span class="p">,;</span>
</span></span></code></pre></div><p>注意, 冒号和诸如 <code>{}</code> 或 <code>()</code> 的分隔符不能作为替换分割符。带有副词的冒号斜线诸如 <code>s:i/Foo/Bar</code> 和其它分割符有其它用途。</p>
<p>就像 <code>m//</code> 操作符一样, 通常会忽略空白。在 Raku 中, 注释以 <em>#</em> 号开头直到当前行的结尾。</p>
<h3 id="替换字符串字面值">替换字符串字面值</h3>
<p>要替换的最简单的东西就是字符串字面量。你要替换的字符串在替换运算符的左侧, 而替换它的字符串在替换操作符的右侧; 例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">The Replacements</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">/</span><span class="sr">Replace</span><span class="p">/</span><span class="s2">Entrap</span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                    <span class="c1"># OUTPUT: «The Entrapments␤» </span>
</span></span></code></pre></div><p>字母数字字符和下划线是文字匹配，就像其表哥 <code>m//</code> 操作符一样。 所有其他字符都必须使用反斜杠<code>\</code>转义，或包含在引号中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Space: 1999</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">/</span><span class="sr">Space</span><span class="se">\</span><span class="sr">:</span><span class="p">/</span><span class="s2">Party like it&#39;s</span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span>                        <span class="c1"># OUTPUT: «Party like it&#39;s 1999␤» </span>
</span></span></code></pre></div><p>请注意，匹配约束仅适用于替换表达式的左侧。</p>
<p>默认情况下，替换仅在第一匹配中完成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">There can be twly two</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">/</span><span class="sr">tw</span><span class="p">/</span><span class="s2">on</span><span class="p">/;</span>                     <span class="c1"># replace &#39;tw&#39; with &#39;on&#39; once </span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                         <span class="c1"># OUTPUT: «there can be only two␤» </span>
</span></span></code></pre></div><h3 id="通配符和字符类-1">通配符和字符类</h3>
<p>任何可以进入 <code>m//</code> 操作符的内容都可以进入替换操作符的左侧，包括通配符和字符类。 当您匹配的文本不是静态的时，这很方便，例如尝试匹配字符串中间的数字：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Blake&#39;s 9</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">/</span><span class="se">\d</span><span class="o">+</span><span class="p">/</span><span class="s2">7</span><span class="p">/;</span>         <span class="c1"># replace any sequence of digits with &#39;7&#39; </span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span><span class="p">;</span>             <span class="c1"># OUTPUT: «Blake&#39;s 7␤»</span>
</span></span></code></pre></div><p>当然，你可以使用任何<code>+</code>，<code>*</code>和<code>?</code> 修饰符，它们的行为就像在 <code>m//</code> 操作符的上下文中一样。</p>
<h3 id="捕获组">捕获组</h3>
<p>就像在匹配运算符中一样，捕获组在左侧被允许，匹配的内容填充 <code>$0..$n</code> 变量和 <code>$/</code> 对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">2016-01-23 18:09:00</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="se">\</span><span class="sr">-</span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="se">\</span><span class="sr">-</span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">/</span><span class="s2">today</span><span class="p">/;</span>   <span class="c1"># replace YYYY-MM-DD with &#39;today&#39; </span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                             <span class="c1"># OUTPUT: «today 18:09:00␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="nv">$1-$2-$0</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                   <span class="c1"># OUTPUT: «01-23-2016␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">$/[1]-$/[2]-$/[0]</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>          <span class="c1"># OUTPUT: «01-23-2016␤» </span>
</span></span></code></pre></div><p>任何这些变量 <code>$0</code>，<code>$1</code>，<code>$/</code> 也可以在运算符的右侧使用，所以你可以操纵你刚刚匹配的内容。 这样，您可以将日期的YYYY，MM和DD部分分开，并将其重新格式化为 <code>MM-DD-YYYY</code> 顺序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">2016-01-23 18:09:00</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="se">\</span><span class="sr">-</span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="se">\</span><span class="sr">-</span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">/</span><span class="nv">$1-$2-$0</span><span class="p">/;</span>    <span class="c1"># transform YYYY-MM-DD to MM-DD-YYYY </span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                                 <span class="c1"># OUTPUT: «01-23-2016 18:09:00␤» </span>
</span></span></code></pre></div><p>由于右侧实际上是一个常规的 Raku 内插字符串，因此可以将时间从 <code>HH:MM</code> 重新格式化为 `h:MM {AM,PM} 格式, 如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">18:38</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">s</span><span class="p">/(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="se">\</span><span class="sr">:</span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)/{</span><span class="nv">$0</span> <span class="nv">%</span> <span class="mi">12</span><span class="p">}</span><span class="s2">\:</span><span class="nv">$1</span><span class="s2"> </span><span class="p">{</span><span class="nv">$0</span> <span class="o">&lt;</span> <span class="mi">12</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">AM</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">PM</span><span class="p">&#39;}/;</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                                                    <span class="c1"># OUTPUT: «6:38 PM␤» </span>
</span></span></code></pre></div><p>使用上面的模数 <code>%</code> 运算符将样本代码保留在80个字符以下，否则就是 <code>$0 &lt;12 ?? $0 !! $0 - 12</code>。 结合解析器表达式语法的强大功能，真正使您在这里看到的内容成为可能，您可以使用“正则表达式”来解析任何文本。</p>
<h3 id="common-adverbs">Common adverbs</h3>
<h2 id="tilde-for-nesting-structures">Tilde for nesting structures</h2>
<p><code>~</code> 运算符是一个帮助器，用于匹配具有特定终结符的嵌套子规则作为目标。 它被设计为放置在开口和闭合括号之间，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">~</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">expression</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/</span>
</span></span></code></pre></div><p>然而, 它主要忽略左侧的参数, 并且在接下来的两个原子（可以被量化）上操作。 它对下两个原子的操作是“旋转”它们，使得它们实际上以相反的顺序匹配。 因此，上面的表达式，起初是腮红，只不过是下面的简写:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">expression</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">/</span>
</span></span></code></pre></div><p>但是除此之外，当它重写原子时，它还会插入将设置内部表达式以识别终止符的设备，并且如果内部表达式不在所需的闭合原子上终止，则产生适当的错误消息。 所以它确实也注意了左边的括号，它实际上把我们的例子改写成更像:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$&lt;OPEN&gt;</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">SETGOAL: &#39;)&#39;</span><span class="p">&gt;</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="o">[</span> <span class="nv">$GOAL</span> <span class="o">||</span> <span class="p">&lt;</span><span class="s">FAILGOAL</span><span class="p">&gt;</span> <span class="o">]</span>
</span></span></code></pre></div><p>FAILGOAL 是一种可以由用户定义的特殊方法，它将在解析失败时被调用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">A</span> <span class="p">{</span> <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">~</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">  </span><span class="p">};</span>
</span></span><span class="line"><span class="cl">            <span class="k">method</span> <span class="nf">FAILGOAL</span><span class="p">(</span><span class="nv">$goal</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Cannot find </span><span class="nv">$goal</span><span class="s2"> near position </span><span class="p">{</span><span class="nb">self</span><span class="o">.</span><span class="nb">pos</span><span class="p">}&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="o">.</span><span class="nb">parse</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">[good]</span><span class="p">&#39;;</span>  <span class="c1"># OUTPUT: «｢[good]｣␤» </span>
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="o">.</span><span class="nb">parse</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">[bad</span><span class="p">&#39;;</span>    <span class="c1"># will throw FAILGOAL exception </span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::AdHoc: Cannot find &#39;]&#39;  near position 5␤» </span>
</span></span></code></pre></div><p>请注意，即使没有开头括号，也可以使用此构造来设置闭合结构的期望值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">3)</span><span class="p">&#34;</span>  <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">~</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">/;</span>  <span class="c1"># RESULT: «｢3)｣» </span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">(3)</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">~</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">/;</span>  <span class="c1"># RESULT: «｢3)｣» </span>
</span></span></code></pre></div><p>这里 <code>&lt;?&gt;</code> 在第一个空字符串中返回true。</p>
<p>正则表达式捕获的顺序是原始的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">abc</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a </span><span class="o">~</span><span class="sr"> </span><span class="p">(</span><span class="sr">c</span><span class="p">)</span><span class="sr"> </span><span class="p">(</span><span class="sr">b</span><span class="p">)/;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$0</span><span class="p">;</span> <span class="c1"># OUTPUT: «｢c｣␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$1</span><span class="p">;</span> <span class="c1"># OUTPUT: «｢b｣␤» </span>
</span></span></code></pre></div><h2 id="subrules">Subrules</h2>
<p>就像你可以把代码片段放进子例程中一样, 你同样可以把正则表达式片段放进命名规则中(named rules)。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">line</span> <span class="p">{</span><span class="sr"> </span><span class="se">\N</span><span class="o">*</span><span class="se">\n</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#34;</span><span class="s2">abc</span><span class="se">\n</span><span class="s2">def</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/&lt;</span><span class="nf">line</span><span class="p">&gt;</span><span class="sr"> def</span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">First line:</span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$&lt;line&gt;</span><span class="o">.</span><span class="nb">chomp</span><span class="p">;</span> <span class="c1"># OUTPUT:«First line: abc␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>命名正则可以使用 <code>my regex_name { body here }</code> 来声明, 并使用 <code>&lt;regex_name&gt;</code> 来调用。与此同时, 调用命名正则的时候会安装一个同名的命名捕获。</p>
<p>要给捕获起一个和 regex 不同的名字, 那么使用 <code>&lt;capture_name=regex_name&gt;</code> 语法。如果不想捕获, 那么使用一个前置的点号来抑制捕获: <code>&lt;.regex_name&gt;</code>。</p>
<p>下面是一个更完善的解析 ini 文件的例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">header</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">(</span><span class="se">\w</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">identifier</span>  <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">kvpair</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">section</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">header</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">kvpair</span><span class="p">&gt;</span><span class="o">*</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$contents</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOI/;</span><span class="s"> 
</span></span></span><span class="line"><span class="cl"><span class="s">    [passwords]
</span></span></span><span class="line"><span class="cl"><span class="s">        jack=password1
</span></span></span><span class="line"><span class="cl"><span class="s">        joy=muchmoresecure123
</span></span></span><span class="line"><span class="cl"><span class="s">    [quotas]
</span></span></span><span class="line"><span class="cl"><span class="s">        jack=123
</span></span></span><span class="line"><span class="cl"><span class="s">        joy=42
</span></span></span><span class="line"><span class="cl"><span class="s"></span><span class="p">EOI</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%config</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$contents</span> <span class="o">~~</span> <span class="p">/&lt;</span><span class="nf">section</span><span class="p">&gt;</span><span class="o">*</span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nv">$&lt;section&gt;</span><span class="o">.</span><span class="nb">list</span> <span class="k">-&gt;</span> <span class="nv">$section</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">%section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nv">$section</span><span class="p">&lt;</span><span class="s">kvpair</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">list</span> <span class="k">-&gt;</span> <span class="nv">$p</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="nv">$p</span><span class="p">&lt;</span><span class="s">value</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%section</span><span class="p">{</span> <span class="nv">$p</span><span class="p">&lt;</span><span class="s">key</span><span class="p">&gt;</span> <span class="p">}</span> <span class="o">=</span> <span class="o">~</span><span class="nv">$p</span><span class="p">&lt;</span><span class="s">value</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nv">%config</span><span class="p">{</span> <span class="nv">$section</span><span class="p">&lt;</span><span class="s">header</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="p">}</span> <span class="o">=</span> <span class="nv">%section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%config</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «(&#34;passwords&#34; =&gt; {&#34;jack&#34; =&gt; &#34;password1&#34;, &#34;joy&#34; =&gt; &#34;muchmoresecure123&#34;},␤ </span>
</span></span><span class="line"><span class="cl"><span class="c1">#          &#34;quotas&#34; =&gt; {&#34;jack&#34; =&gt; &#34;123&#34;, &#34;joy&#34; =&gt; &#34;42&#34;}).hash» </span>
</span></span></code></pre></div><p>命名正则可以规整到 <a href="https://docs.raku.org/language/grammars">gramamrs</a> 中。<a href="https://design.raku.org/S05.html#Predefined_Subrules">S05</a>中有一组预定义的 subrules。</p>
<h2 id="副词">副词</h2>
<p>副词修改正则表达式的工作方式, 并为某些类型的循环任务提供方便的快捷方式。</p>
<p>有两种副词: 正则表达式副词适用于定义正则表达式时, 匹配副词适用于正则表达式与字符串匹配时。</p>
<p>这种区别往往是模糊的, 因为匹配和声明通常是文本上关闭的, 但使用方法形式的匹配使得区分清晰一点。</p>
<p><code>'abc' ~~ /../</code> 大致相当于 <code>'abc'.match(/../)</code>, 甚至可以更清楚地单独写成一行:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$regex</span> <span class="o">=</span> <span class="p">/</span><span class="o">..</span><span class="p">/;</span>           <span class="c1"># definition </span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">match</span><span class="p">(</span><span class="nv">$regex</span><span class="p">)</span> <span class="p">{</span>    <span class="c1"># matching </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">&#39;abc&#39; has at least two characters</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>正则表达式副词像 <code>:i</code> 会进入定义行而匹配副词像 <code>:overlap</code> 会附加到匹配调用上:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$regex</span> <span class="o">=</span> <span class="p">/:</span><span class="na">i</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> a</span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">&#39;</span><span class="s1">baA</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">match</span><span class="p">(</span><span class="nv">$regex</span><span class="o">,</span> <span class="p">:</span><span class="s">overlap</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$m</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «ba␤aA␤» </span>
</span></span></code></pre></div><h3 id="regex-adverbs">Regex Adverbs</h3>
<p>在正则表达式声明时出现的副词是实际正则表达式的一部分, 并影响 Raku 编译器如何将正则表达式转换为二进制代码。</p>
<p>例如: <code>:ignorecase (:i)</code> 副词告诉编译器忽略大写, 小写和标题大小写字母之间的区别。</p>
<p>所以 <code>'a'~~ /A/</code> 是假的, 但 `&lsquo;a&rsquo; ~~ /:i A /是一个成功的匹配。</p>
<p>正则表达式副词可以在正则表达式声明之前或之内, 并且仅在词法上影响其后的正则表达式部分。 请注意, 在正则表达式之前出现的正则表达式副词必须出现在将正则表达式引入解析器之后, 如 &lsquo;rx&rsquo; 或 &rsquo;m&rsquo; 或裸的 &lsquo;/&rsquo;。 但是这样是无效的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rx1</span> <span class="o">=</span> <span class="p">:</span><span class="s">i</span><span class="o">/</span><span class="n">a</span><span class="o">/</span><span class="p">;</span>      <span class="c1"># adverb is before the regex is recognized =&gt; exception </span>
</span></span></code></pre></div><p>下面这些是等价的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rx1</span> <span class="o">=</span> <span class="k">rx</span><span class="p">:</span><span class="na">i</span><span class="p">/</span><span class="sr">a</span><span class="p">/;</span>      <span class="c1"># before </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rx2</span> <span class="o">=</span> <span class="k">rx</span><span class="p">/:</span><span class="na">i</span><span class="sr"> a</span><span class="p">/;</span>     <span class="c1"># inside </span>
</span></span></code></pre></div><p>而下面这两种是不等价的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rx3</span> <span class="o">=</span> <span class="k">rx</span><span class="p">/</span><span class="sr">a </span><span class="p">:</span><span class="na">i</span><span class="sr"> b</span><span class="p">/;</span>   <span class="c1"># matches only the b case insensitively </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rx4</span> <span class="o">=</span> <span class="k">rx</span><span class="p">/:</span><span class="na">i</span><span class="sr"> a b</span><span class="p">/;</span>   <span class="c1"># matches completely case insensitively </span>
</span></span></code></pre></div><p>方括号和圆括号约束副词的作用域:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">(:</span><span class="na">i</span><span class="sr"> a b</span><span class="p">)</span><span class="sr"> c </span><span class="p">/;</span>         <span class="c1"># matches &#39;ABc&#39; but not &#39;ABC&#39; </span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">[:</span><span class="na">i</span><span class="sr"> a b</span><span class="p">]</span><span class="sr"> c </span><span class="p">/;</span>         <span class="c1"># matches &#39;ABc&#39; but not &#39;ABC&#39; </span>
</span></span></code></pre></div><h3 id="ratchet">Ratchet</h3>
<p><code>:ratchet</code> 或 <code>:r</code> 副词会导致正则表达式引擎不回溯。</p>
<p>假如没有这个副词, 那么正则表达式的一部分将尝试不同的路径来匹配字符串, 以使正则表达式的其他部分可以匹配。 例如, 在 <code>'abc' ~~ / \w+ ./</code> 中, <code>\w+</code> 首先吃光整个字符串 abc, 然后 <code>.</code> 就失败了。 因此 <code>\w+</code> 放弃一个字符, 只匹配 ab 而 <code>.</code> 可以成功匹配字符串 c。 放弃字符的过程(或在轮试的情况下, 尝试不同的分支)被称为回溯。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> </span><span class="p">/;</span>        <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">:</span><span class="na">r</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> </span><span class="p">/;</span>     <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><p>Ratcheting 是一种优化, 因为回溯是昂贵的。 但更重要的是, 它与人类解析文本的方式密切相关。 如果你有一个正则表达式 <code>my regex identifier { \w+ } </code> 和 <code>my regex keyword { if | else | endif }</code>, 你直观地期望 <code>identifier</code> 吞噬整个单词，而不是放弃结束下一个规则，如果下一个 rule 失败时。</p>
<p>例如，你不想让单词 <code>motif</code> 被解析为标识符 mot 后面跟着关键字 if。 相反, 你想将 <code>motif</code> 解析为标识符; 并且如果解析器期望之后有一个 <code>if</code>, 那么最好让它失败, 而不是以你不期望的方式解析输入。</p>
<p>由于 ratcheting 行为在解析器中通常是需要的, 所以有一个快捷方式来声明一个 ratcheting 正则表达式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">token</span> <span class="nf">thing</span> <span class="p">{</span><span class="sr"> </span><span class="o">....</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># short for </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">thing</span> <span class="p">{</span><span class="sr"> </span><span class="p">:</span><span class="na">r</span><span class="sr"> </span><span class="o">..</span><span class="ni">.</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><h3 id="sigspace">Sigspace</h3>
<p><code>:sigspace</code> 或 <code>:s</code> 副词使空白在正则表达式中有意义。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#34;</span><span class="s2">I used Photoshop®</span><span class="p">&#34;</span>   <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">i</span><span class="p">/</span><span class="sr">   photo shop </span><span class="p">/;</span>      <span class="c1"># OUTPUT: «True␤»</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#34;</span><span class="s2">I used a photo shop</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">i</span><span class="p">:</span><span class="na">s</span><span class="p">/</span><span class="sr"> photo shop </span><span class="p">/;</span>   <span class="c1"># OUTPUT: «True␤»</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#34;</span><span class="s2">I used Photoshop®</span><span class="p">&#34;</span>   <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">i</span><span class="p">:</span><span class="na">s</span><span class="p">/</span><span class="sr"> photo shop </span><span class="p">/;</span>   <span class="c1"># OUTPUT: «False␤»</span>
</span></span></code></pre></div><p><code>m:s/ photo shop /</code> 的作用和 <code>m/ photo &lt;.ws&gt; shop &lt;.ws&gt; /</code> 一样。默认地, <code>&lt;.ws&gt;</code> 确保单词是分开的, 所以 <code>a b</code> 和 <code>^$</code> 会匹配中间的 <code>&lt;.ws&gt;</code>, 但是 <code>ab</code> 不会。</p>
<p>正则表达式中哪里的空白会被转换为 <code>&lt;.ws&gt;</code> 取决于空白前面是什么。在上面的例子中, 正则表达式开头的空白不会被转换为 <code>&lt;.ws&gt;</code>, 但是字符后面的空白会被转换为 <code>&lt;.ws&gt;</code>。通常, 规则就是, 如果某一项可能匹配某个东西, 那么它后面的空白会被转换为 <code>&lt;.ws&gt;</code>。</p>
<p>此外, 如果空白跟在某个 term 之后, 量词(+,* 或 ?)之前, 那么 <code>&lt;.ws&gt;</code> 会在每次 term 匹配后匹配。 所以, <code>foo +</code> 变为 <code>[foo &lt;.ws&gt;]+</code>。另一方面, 量词后面的空白和普通的空白作用一样; 例如: &ldquo;foo+&rdquo; 变为 <code>foo+&lt;.ws&gt;</code></p>
<h3 id="matching-adverbs">Matching adverbs</h3>
<p>和正则表达式副词对比, 其与正则表达式声明有关, 匹配副词只有在将字符串与正则表达式匹配时才有意义。</p>
<p>它们永远不会出现在正则表达式内部, 只能在外部 - 作为 <code>m/.../</code> 匹配的一部分或作为匹配方法的参数。</p>
<h3 id="continue">Continue</h3>
<p><code>:continue</code> 或短的 <code>:c</code> 副词接收一个参数。 这个参数是正则表达式开始搜索的位置。 默认情况下, 它从字符串的开头搜索, 但是 <code>:c</code> 覆盖该位置。 如果没有为 <code>:c</code> 指定位置, 它将默认为 0, 除非设置了 <code>$/</code>, 在这种情况下, 它默认为 <code>$/.to</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">a1xa2</span><span class="p">&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="k">m</span><span class="p">/</span><span class="sr">a</span><span class="ni">.</span><span class="p">/;</span>         <span class="c1"># OUTPUT: «a1␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="k">m</span><span class="p">:</span><span class="na">c</span><span class="p">(</span><span class="mi">2</span><span class="p">)/</span><span class="sr">a</span><span class="ni">.</span><span class="p">/;</span>    <span class="c1"># OUTPUT: «a2␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意: 不同于 <code>:pos</code>, 使用 <code>:continue()</code> 的匹配将尝试在字符串中进一步匹配, 而不是马上失败:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">abcdefg</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">c</span><span class="p">(</span><span class="mi">3</span><span class="p">)/</span><span class="sr">e</span><span class="ni">.</span><span class="o">+</span><span class="p">/;</span> <span class="c1"># OUTPUT: «｢efg｣␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">abcdefg</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">p</span><span class="p">(</span><span class="mi">3</span><span class="p">)/</span><span class="sr">e</span><span class="ni">.</span><span class="o">+</span><span class="p">/;</span> <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><h3 id="exhaustive">Exhaustive</h3>
<p>要找到正则表达式的所有可能的匹配 - 包括重叠的 - 和几个从同一位置开始的匹配, 请使用 <code>:exhaustive</code>(short: <code>ex</code>) 副词。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">abracadabra</span><span class="p">&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="k">m</span><span class="p">:</span><span class="na">exhaustive</span><span class="p">/</span><span class="sr"> a </span><span class="ni">.</span><span class="o">*</span><span class="sr"> a </span><span class="p">/</span> <span class="k">-&gt;</span> <span class="nv">$match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span> <span class="nb">x</span> <span class="nv">$match</span><span class="o">.</span><span class="nb">from</span><span class="o">,</span> <span class="o">~</span><span class="nv">$match</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面的代码产生这样的输出:</p>
<pre tabindex="0"><code>abracadabra
abracada
abraca
abra
   acadabra
   acada
   aca
     adabra
     ada
       abra
</code></pre><h3 id="global">Global</h3>
<p>不是搜索一个匹配并返回一个 <a href="https://docs.raku.org/type/Match">Match 对象</a>, Global 搜索每个不重叠的匹配, 并将其返回到<a href="https://docs.raku.org/type/List">列表</a>中。 为此, 请使用 <code>:global</code> 副词:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">several words here</span><span class="p">&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">@matches</span> <span class="o">=</span> <span class="k">m</span><span class="p">:</span><span class="na">global</span><span class="p">/</span><span class="se">\w</span><span class="o">+</span><span class="p">/;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">@matches</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>         <span class="c1"># OUTPUT: «3␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">@matches</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>           <span class="c1"># OUTPUT: «here␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>:g</code> 是 <code>:global</code> 的简写。</p>
<h3 id="pos">Pos</h3>
<p>在字符串的特定位置锚定匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">abcdef</span><span class="p">&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$match</span> <span class="o">=</span> <span class="k">m</span><span class="p">:</span><span class="na">pos</span><span class="p">(</span><span class="mi">2</span><span class="p">)/</span><span class="ni">.</span><span class="o">*</span><span class="p">/;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$match</span><span class="o">.</span><span class="nb">from</span><span class="p">;</span>        <span class="c1"># OUTPUT: «2␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">~</span><span class="nv">$match</span><span class="p">;</span>            <span class="c1"># OUTPUT: «cdef␤» </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>:p</code> 是 <code>:pos</code> 的简写。</p>
<p>注意: 不同于 <code>:continue</code>, 使用 <code>:pos()</code> 锚定的匹配在不匹配时将立即失败, 而不是尝试进一步匹配字符串:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">abcdefg</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">c</span><span class="p">(</span><span class="mi">3</span><span class="p">)/</span><span class="sr">e</span><span class="ni">.</span><span class="o">+</span><span class="p">/;</span> <span class="c1"># OUTPUT: «｢efg｣␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">abcdefg</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">p</span><span class="p">(</span><span class="mi">3</span><span class="p">)/</span><span class="sr">e</span><span class="ni">.</span><span class="o">+</span><span class="p">/;</span> <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><h3 id="overlap">Overlap</h3>
<p>要获得多个匹配, 包括重叠的匹配, 但每个起始位置只有一个(最长的)匹配, 请指定 <code>:overlap</code> (short <code>:ov</code>) 副词:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">abracadabra</span><span class="p">&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="k">m</span><span class="p">:</span><span class="na">overlap</span><span class="p">/</span><span class="sr"> a </span><span class="ni">.</span><span class="o">*</span><span class="sr"> a </span><span class="p">/</span> <span class="k">-&gt;</span> <span class="nv">$match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span> <span class="nb">x</span> <span class="nv">$match</span><span class="o">.</span><span class="nb">from</span><span class="o">,</span> <span class="o">~</span><span class="nv">$match</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>产生:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">abracadabra</span>
</span></span><span class="line"><span class="cl">   <span class="n">acadabra</span>
</span></span><span class="line"><span class="cl">     <span class="n">adabra</span>
</span></span><span class="line"><span class="cl">       <span class="n">abra</span>
</span></span></code></pre></div><h2 id="look-around-assertions">Look-around assertions</h2>
<h3 id="lookahead-assertions">Lookahead assertions</h3>
<p>要检查一个模式是否出现在另一个模式之前，请通过 <code>before</code> 断言使用 lookahead 断言。形式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">?before pattern</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>因此，要搜索字符串 foo 后面紧跟着字符串 bar, 请使用以下 regexp:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">rx</span><span class="p">{</span><span class="sr"> foo </span><span class="p">&lt;</span><span class="o">?</span><span class="ow">before</span><span class="sr"> bar</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foobar</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="k">rx</span><span class="p">{</span><span class="sr"> foo </span><span class="p">&lt;</span><span class="o">?</span><span class="ow">before</span><span class="sr"> bar</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">};</span>   <span class="c1"># OUTPUT: «foo␤» </span>
</span></span></code></pre></div><p>但是，如果要搜索一个不紧随某个模式的模式, 那么您需要使用反向向前查看断言, 其形式如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">!before pattern</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>因此，所有出现的不在 bar 之前的 foo 都会匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">rx</span><span class="p">{</span><span class="sr"> foo </span><span class="p">&lt;</span><span class="o">!</span><span class="ow">before</span><span class="sr"> bar</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><h3 id="lookbehind-assertions">Lookbehind assertions</h3>
<p>要检查一个模式是否出现在另一个模式之后，请通过 <code>after</code> 断言使用 <code>lookbehind</code> 断言。 其形式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">?after pattern</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>因此, 要搜索字符串 foo 立即跟着的 bar 字符串, 使用如下正则表达式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">rx</span><span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="ow">after</span><span class="sr"> foo</span><span class="p">&gt;</span><span class="sr"> bar </span><span class="p">}</span> <span class="c1"># read as after foo is bar</span>
</span></span></code></pre></div><p>例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foobar</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="k">rx</span><span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="ow">after</span><span class="sr"> foo</span><span class="p">&gt;</span><span class="sr"> bar </span><span class="p">};</span> <span class="c1">#  OUTPUT: «bar␤» </span>
</span></span></code></pre></div><p>但是, 如果要搜索的模式不是紧随其后的模式, 那么您需要使用反向的 lookbehind 断言, 其形式如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">!after pattern</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>因此, bar 前面不是 foo 的所有 bar 将被匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">rx</span><span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="ow">after</span><span class="sr"> foo</span><span class="p">&gt;</span><span class="sr"> bar </span><span class="p">}</span>
</span></span></code></pre></div><h2 id="best-practices-and-gotchas">Best practices and gotchas</h2>
<p>为了帮助强大的正则表达式和 Grammar, 以下是代码布局和可读性的最佳实践，实际匹配的内容，并避免常见的陷阱。</p>
<h3 id="code-layout">Code layout</h3>
<p>没有 <code>:sigspace</code> 副词, 空白在 Raku 正则表达式中就是没有意义的。 在能增加可读性的地方插入空格。 此外, 必要时插入注释。</p>
<p>比较下面这个比较紧凑的正则表达式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">float</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="se">\d</span><span class="o">*</span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="se">\d</span><span class="o">+</span><span class="p">[</span><span class="sr">e</span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="se">\d</span><span class="o">+</span><span class="p">]</span><span class="o">?</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>和可读性更好的版本:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">float</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="sr">        </span><span class="c1"># optional sign 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">     </span><span class="se">\d</span><span class="o">*</span><span class="sr">            </span><span class="c1"># leading digits, optional 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">     </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="se">\d</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">[</span><span class="sr">              </span><span class="c1"># optional exponent 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">        e </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="sr">  </span><span class="se">\d</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">]</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><p>根据经验，在原子周围和分组内部使用空格; 将量词直接置于原子之后; 并垂直对齐开口和闭合方括号和圆括号。</p>
<p>当你在方括号或圆括号中使用一组备选分支时, 请对齐垂直条:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">example</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">preamble</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">[</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">choice_1</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">choice_2</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">choice_3</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">]</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">postamble</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="keep-it-small">Keep it small</h3>
<p>正则表达式通常比常规代码更紧凑。 因为他们短小精悍, 保持正则表达式很短。</p>
<p>当你可以命名正则表达式的一部分时, 通常最好将其放入单独的命名正则表达式中。</p>
<p>例如, 您可以从前面获取 float 正则表达式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">float</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="sr">        </span><span class="c1"># optional sign 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">     </span><span class="se">\d</span><span class="o">*</span><span class="sr">            </span><span class="c1"># leading digits, optional 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">     </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="se">\d</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">[</span><span class="sr">              </span><span class="c1"># optional exponent 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">        e </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="sr">  </span><span class="se">\d</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">]</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><p>并把它分解成几部分:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">token</span> <span class="nf">sign</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">token</span> <span class="nf">decimal</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">token</span> <span class="nf">exponent</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">e</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sign</span><span class="p">&gt;</span><span class="o">?</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">float</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">sign</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">exponent</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><p>这很有用, 特别是当正则表达式变得更加复杂时。 例如, 你可能希望在存在指数的情况下使小数点可选。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">float</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">sign</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">[</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">  </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">exponent</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">exponent</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">]</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="what-to-match">What to match</h3>
<p>通常，输入数据格式没有明确的规范，或规范对编程人员来说是未知的。 那么，在你期望的时候是自由的，只要没有可能的含糊不清就行了。</p>
<p>例如，在 ini 文件中:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">[</span><span class="n">section</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">key</span><span class="o">=</span><span class="nb">value</span>
</span></span></code></pre></div><p>什么可以在 section 标题内? 只允许一个单词可能太限制了。 有人会写 <code>[two words]</code>, 或用破折号等等。 而不是询问内部允许的内容, 可能这样问比较好: 什么是不允许的？</p>
<p>显然, 不允许使用括号，因为 <code>[a] b]</code> 是不明确的。 同样的论据, 应禁止开口方括号。 这让我们有了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">header</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> </span><span class="se">\</span><span class="sr">[</span><span class="se">\</span><span class="sr">] </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>如果你只处理一行就行了。 但是，如果你正在处理整个文件，突然间正则表达式解析到一句</p>
<pre tabindex="0"><code>[with a
newline in between]
</code></pre><p>这可能不是一个好方法。折中的方式是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">header</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> </span><span class="se">\</span><span class="sr">[</span><span class="se">\</span><span class="sr">] </span><span class="se">\n</span><span class="sr"> </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>然后在扫尾处理中, 从 section 标题中移除前导和尾部空格和制表符。</p>
<h3 id="matching-whitespace">Matching Whitespace</h3>
<p><code>:sigspace</code> 副词(或使用 <code>rule</code> 声明符, 而不是 <code>token</code> 或 <code>regex</code>) 非常适用于隐式解析许多地方可能出现的空格。</p>
<p>回到解析 ini 文件的例子, 我们有</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">kvpair</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>这可能不像我们想要的那样自由, 因为用户可能会在等号周围放置空格。 那么我们可以试试这个:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">kvpair</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>但这看起来很笨重, 所以我们尝试其他方式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">rule</span> <span class="nf">kvpair</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>可是等等! <code>value</code> 之后，隐含的空白匹配用光了所有的空白, 包括换行符, 所以 <code>\n+</code> 没有什么可以匹配的(rule 也禁止回溯, 所以运气不佳)。</p>
<p>因此, 重要的是将隐式空白的定义重新定义为输入格式无意义的空白。</p>
<p>这通过重新定义 token <code>ws</code>; 但是，它只适用于 <a href="https://docs.raku.org/language/grammars">Grammars</a>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">IniFormat</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">ws</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="ow">ww</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">header</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">(</span><span class="se">\w</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">identifier</span>  <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">kvpair</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">section</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">&lt;</span><span class="nf">header</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">&lt;</span><span class="nf">kvpair</span><span class="p">&gt;</span><span class="o">*</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">&lt;</span><span class="nf">section</span><span class="p">&gt;</span><span class="o">*</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$contents</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOI/;</span><span class="s"> 
</span></span></span><span class="line"><span class="cl"><span class="s">    [passwords]
</span></span></span><span class="line"><span class="cl"><span class="s">        jack = password1
</span></span></span><span class="line"><span class="cl"><span class="s">        joy = muchmoresecure123
</span></span></span><span class="line"><span class="cl"><span class="s">    [quotas]
</span></span></span><span class="line"><span class="cl"><span class="s">        jack = 123
</span></span></span><span class="line"><span class="cl"><span class="s">        joy = 42
</span></span></span><span class="line"><span class="cl"><span class="s"></span><span class="p">EOI</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="n">IniFormat</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$contents</span><span class="p">);</span>
</span></span></code></pre></div><p>除了把所有的正则表达式都放在一个 Grammar 中并把它们变成了 tokens(因为他们不需要回溯) 之外, 有趣的新花样是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">ws</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="ow">ww</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>这被称为隐式空白解析。 当它不在两个字符之间 (<code>&lt;ww&gt;</code>, 反向的&quot;within word&quot; 断言)时匹配, 以及零个或多个水平空格字符。 对水平空白的限制很重要, 因为换行符(它们是垂直空白)定界记录, 不应该被隐式地匹配。</p>
<p>还有一些与空白有关的麻烦潜伏着。 正则表达式 <code>\n+</code> 将不会匹配 <code>\n \n</code> 这样的字符串, 因为两个换行符之间有空白。 要允许这样的输入字符串, 用 <code>\n\s*</code> 代替 <code>\n+</code>。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[编译指令]]></title>
            <link href="http://localhost:1313/rakulang/59.pragmas/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/generating-random-integers-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 3/25. 在 Raku 中生成随机整数" />
                <link href="http://localhost:1313/notes/automatic-reload-for-rapid-development/?utm_source=atom_feed" rel="related" type="text/html" title="第二天 - 自动重载以实现快速开发" />
                <link href="http://localhost:1313/rakulang/58.phasers/?utm_source=atom_feed" rel="related" type="text/html" title="Phasers" />
                <link href="http://localhost:1313/rakulang/57.perl-6-native-types/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 原生类型" />
                <link href="http://localhost:1313/notes/grepping-dividable-numbers-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 2/25. 在 Raku 中 Grepping 可整除的数字" />
            
                <id>http://localhost:1313/rakulang/59.pragmas/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-03T21:13:31+08:00</published>
            <updated>2018-12-03T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>在 Raku 中，<strong>pragma</strong> 是用于识别要使用的 Raku 的特定版本或以某种方式修改编译器的正常行为的指令。<code>use</code> 关键字开启编译指示（类似于你怎么 <code>use</code> 一个模块）。要禁用 pragma，请使用 <code>no</code> 关键字：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="ni">.c</span><span class="p">;</span>   <span class="c1"># use 6.c language version </span>
</span></span><span class="line"><span class="cl"><span class="k">no</span> <span class="kt">worries</span><span class="p">;</span> <span class="c1"># don&#39;t issue compile time warnings </span>
</span></span></code></pre></div><p>以下是一个编译指令列表，其中包含每个编译指令意图的简短描述或指向其使用的更多详细信息的链接。（注意：标记为“[NYI]”的编译指令尚未实现，标记为“[TBD]”的编号将在稍后定义。）</p>
<h2 id="v6xhttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">v6.x</a></h2>
<p>该编译指令 声明了将要使用的编译器的版本，如果它们是可选的，则开启它的功能。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>   <span class="c1"># Load latest supported version (non-PREVIEW). </span>
</span></span><span class="line"><span class="cl">          <span class="c1"># Also, useful for producing better errors when accidentally </span>
</span></span><span class="line"><span class="cl">          <span class="c1"># executing the program with `perl` instead of `raku` </span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="ni">.c</span><span class="p">;</span>         <span class="c1"># Use the &#34;Christmas&#34; version of Raku </span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="ni">.d</span><span class="p">;</span>         <span class="c1"># Use the &#34;Diwali&#34; version of Raku </span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="ni">.d.PREVIEW</span><span class="p">;</span> <span class="c1"># On 6.d-capable compilers, enables 6.d features, </span>
</span></span><span class="line"><span class="cl">                  <span class="c1"># otherwise enables the available experimental </span>
</span></span><span class="line"><span class="cl">                  <span class="c1"># preview features for 6.d language </span>
</span></span><span class="line"><span class="cl">                  <span class="c1"># This will only work on releases previous to 6.d. </span>
</span></span></code></pre></div><p>由于这些编译指令是在编译器版本上开启的，所以它们应该是文件中的第一个语句（前面的注释和 Pod 都没问题）。</p>
<h2 id="monkey-gutshttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">MONKEY-GUTS</a></h2>
<p>该编译指令目前不是任何 Raku 规范的一部分，但作为 <code>use nqp</code> 的同义词存在于 Rakudo 中（见下文）。</p>
<h2 id="monkey-see-no-evalhttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">MONKEY-SEE-NO-EVAL</a></h2>
<p><a href="https://docs.raku.org/routine/EVAL">EVAL</a></p>
<h2 id="monkey-typinghttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">MONKEY-TYPING</a></h2>
<p><a href="https://docs.raku.org/syntax/augment">augment</a></p>
<h2 id="monkeyhttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">MONKEY</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">MONKEY</span><span class="p">;</span>
</span></span></code></pre></div><p>打开所有可用的 <code>MONKEY</code> 编译指令，目前有上面的三个; 因此，它等同于：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">MONKEY-TYPING</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">MONKEY-SEE-NO-EVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">MONKEY-GUTS</span><span class="p">;</span>
</span></span></code></pre></div><h2 id="experimentalhttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">experimental</a></h2>
<p>允许使用<a href="https://docs.raku.org/language/experimental">实验性功能</a></p>
<h2 id="fatalhttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">fatal</a></h2>
<p>一个词法编译指令，使得<a href="https://docs.raku.org/type/Failure">Failures</a>从例程致命错误中返回。例如，<a href="https://docs.raku.org/type/Str">Str</a>上的 <code>+</code> 前缀将其强制转换为<a href="https://docs.raku.org/type/Numeric">Numeric</a>，但如果字符串包含非数字字符，则返回<a href="https://docs.raku.org/type/Failure">Failure</a>。在变量中保存该<a href="https://docs.raku.org/type/Failure">Failure</a>可以防止它被下沉，因此下面的第一个代码块到达 <code>say $x.^name;</code> 行并在输出中打印 <code>Failure</code>。</p>
<p>在第二个块中，<code>use fatal</code> 编译指定开启了，因此 <code>say</code> 永远不会到达该行，因为从前缀 <code>+</code> 返回的 <a href="https://docs.raku.org/type/Failure">Failure</a> 中包含的 <a href="https://docs.raku.org/type/Exception">Exception</a> 被抛出并且 <code>CATCH</code> 块被运行，打印出 <code>Caught...</code> 行。请注意，这两个块都是相同的程序，<code>use fatal</code> 只会影响它所使用的词法块：<code>Caught...use fatal</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="o">+</span><span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$x</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Caught </span><span class="p">{</span><span class="o">.^</span><span class="nb">name</span><span class="p">}&#34;</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1"># OUTPUT: «Failure» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">use</span> <span class="kt">fatal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="o">+</span><span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$x</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Caught </span><span class="p">{</span><span class="o">.^</span><span class="nb">name</span><span class="p">}&#34;</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1"># OUTPUT: «Caught X::Str::Numeric» </span>
</span></span></code></pre></div><p>在<a href="https://docs.raku.org/language/exceptions#index-entry-try_blocks-try"><code>try</code></a> 块内部，默认开启 <code>fatal</code> 编译指令，您可以使用 <code>no fatal</code> <em>禁用</em>它：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="o">+</span><span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$x</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Caught </span><span class="p">{</span><span class="o">.^</span><span class="nb">name</span><span class="p">}&#34;</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1"># OUTPUT: «Caught X::Str::Numeric» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">no</span> <span class="kt">fatal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="o">+</span><span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$x</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Caught </span><span class="p">{</span><span class="o">.^</span><span class="nb">name</span><span class="p">}&#34;</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1"># OUTPUT: «Failure» </span>
</span></span></code></pre></div><h2 id="internalshttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">internals</a></h2>
<p>[NYI]</p>
<h2 id="invocanthttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">invocant</a></h2>
<p>[NYI]</p>
<h2 id="ismshttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">isms</a></h2>
<pre tabindex="0"><code>[2018.09 and later]
</code></pre><p>允许被认为是正常 Raku 编程中的警告和/或错误的陷阱的一些其他语言结构。目前，<code>Perl5</code> 和 <code>C++</code> 是被允许的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">abs</span><span class="p">()</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">abs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Unsupported use of bare &#34;abs&#34;; in Raku please use .abs if you meant </span>
</span></span><span class="line"><span class="cl"><span class="c1"># to call it as a method on $_, or use an explicit invocant or argument, </span>
</span></span><span class="line"><span class="cl"><span class="c1"># or use &amp;abs to refer to the function as a noun </span>
</span></span></code></pre></div><p>在这种情况下，提供一个不带任何参数的 <code>abs</code> sub，并没有使编译错误消失。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">isms</span> <span class="p">&lt;</span><span class="s">Perl5</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">abs</span><span class="p">()</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">abs</span><span class="p">;</span>   <span class="c1"># foo </span>
</span></span></code></pre></div><p>有了这个，编译器将允许违规的 Perl 5 构造，允许实际执行代码。</p>
<p>如果未指定任何语言，则允许使用所有已知语言结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">isms</span><span class="p">;</span>   <span class="c1"># allow for Perl5 and C++ isms </span>
</span></span></code></pre></div><h2 id="libhttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">lib</a></h2>
<p>该编译指令将子目录添加到库搜索路径，以便解释器可以<a href="https://docs.raku.org/language/modules#Finding_modules">找到模块</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">lib</span> <span class="p">&lt;</span><span class="s">lib /opt/lib /usr/local/lib</span><span class="p">&gt;;</span>
</span></span></code></pre></div><p>这将搜索列表中传递的目录。有关更多示例，请查看<a href="https://docs.raku.org/language/modules#use">模块文档</a>。</p>
<h2 id="newlinehttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">newline</a></h2>
<p>在调用的作用域内设置<a href="https://docs.raku.org/language/variables#Compile-time_variables">$?NL</a>常量的值。可能的值有 <code>:lf</code>（默认值，表示换行），<code>:crlf</code>（表示回车，换行）和 <code>:cr</code>（表示回车）。</p>
<h2 id="nqphttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">nqp</a></h2>
<p>使用风险由您自己承担。</p>
<p>这是一个 Rakudo 特有的编译指令。有了它，Rakudo 可以访问顶级命名空间中的<a href="https://github.com/raku/nqp/blob/master/docs/ops.markdown">nqp操作码</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">nqp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">nqp::say</span><span class="p">(&#34;</span><span class="s2">hello world</span><span class="p">&#34;);</span>
</span></span></code></pre></div><p>这使用底层的 nqp <code>say</code> 操作码而不是 Raku 例程。这个编译指示可能会使您的代码依赖于特定版本的 nqp，并且由于该代码不是 Raku 规范的一部分，因此不能保证它是稳定的。您可能会在 Rakudo 核心中找到大量用法，这些用法用于尽可能快地实现核心功能。Rakudo 代码生成的未来优化可能会废弃这些用法。</p>
<h2 id="parametershttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">parameters</a></h2>
<p>[NYI]</p>
<h2 id="precompilationhttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">precompilation</a></h2>
<p>默认允许预编译源代码，特别是在模块中使用时。如果由于某种原因您不希望预编译（模块的）代码，您可以使用 <code>no precompilation</code>。这将阻止整个编译单元（通常是文件）被预编译。</p>
<h2 id="softhttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">soft</a></h2>
<p><a href="https://docs.raku.org/language/functions#Re-dispatching">Re-dispatching</a>, <a href="https://docs.raku.org/language/functions#index-entry-use_soft_%28pragma%29">inlining</a></p>
<h2 id="stricthttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">strict</a></h2>
<p><code>strict</code> 是默认行为，并要求您在使用变量之前声明变量。你可以用 <code>no</code> 放松这个限制。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">no</span> <span class="kt">strict</span><span class="p">;</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1"># OK </span>
</span></span></code></pre></div><h2 id="tracehttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">trace</a></h2>
<p>当 <code>use trace</code> 被激活时，执行的代码的任何行将被写入 stderr。您可以使用 <code>no trace</code> 关闭该功能，因此这仅适用于某些代码段。</p>
<h2 id="v6httpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">v6</a></h2>
<p><a href="https://docs.raku.org/language/testing#Writing_tests">Writing Tests</a></p>
<h2 id="variableshttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">variables</a></h2>
<p><a href="https://docs.raku.org/language/variables#Default_defined_variables_pragma">Defined Variables Pragma</a></p>
<h2 id="worrieshttpsdocsrakuorglanguagepragmas___top"><a href="https://docs.raku.org/language/pragmas#___top">worries</a></h2>
<p>词法地控制是否显示编译器生成的编译时警告。默认情况下启用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">say :foo&lt;&gt;.Pair</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nf">Potential</span> <span class="n">difficulties:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">Pair</span> <span class="k">with</span> <span class="o">&lt;&gt;</span> <span class="n">really</span> <span class="n">means</span> <span class="n">an</span> <span class="n">empty</span> <span class="nb">list</span><span class="o">,</span> <span class="nb">not</span> <span class="n">null</span> <span class="n">string</span><span class="p">;</span> <span class="k">use</span> <span class="p">:</span><span class="s">foo</span><span class="p">(&#39;&#39;)</span> <span class="nb">to</span> <span class="n">represent</span> <span class="n">the</span> <span class="n">null</span> <span class="n">string</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="ow">or</span> <span class="p">:</span><span class="s">foo</span><span class="p">()</span> <span class="nb">to</span> <span class="n">represent</span> <span class="n">the</span> <span class="n">empty</span> <span class="nb">list</span> <span class="n">more</span> <span class="n">accurately</span>
</span></span><span class="line"><span class="cl">  <span class="nb">at</span> <span class="o">-</span><span class="no">e</span><span class="p">:</span><span class="s">1</span>
</span></span><span class="line"><span class="cl">  <span class="o">------&gt;</span> <span class="nb">say</span> <span class="p">:</span><span class="s">foo</span><span class="p">&lt;&gt;</span>⏏<span class="o">.</span><span class="kt">Pair</span>
</span></span><span class="line"><span class="cl"><span class="s">foo</span> <span class="o">=&gt;</span> <span class="kt">Nil</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nv">$</span> <span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">no worries; say :foo&lt;&gt;.Pair</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="s">foo</span> <span class="o">=&gt;</span> <span class="kt">Nil</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Phasers]]></title>
            <link href="http://localhost:1313/rakulang/58.phasers/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/57.perl-6-native-types/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 原生类型" />
                <link href="http://localhost:1313/notes/grepping-dividable-numbers-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 2/25. 在 Raku 中 Grepping 可整除的数字" />
                <link href="http://localhost:1313/notes/welcome-and-mojo-conf-recap/?utm_source=atom_feed" rel="related" type="text/html" title="第一天 - 欢迎来到 Mojo 会议" />
                <link href="http://localhost:1313/rakulang/56.performance/?utm_source=atom_feed" rel="related" type="text/html" title="性能" />
                <link href="http://localhost:1313/notes/generating-random-passwords-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 1/25. 在 Raku 中生成随机密码" />
            
                <id>http://localhost:1313/rakulang/58.phasers/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-02T21:13:31+08:00</published>
            <updated>2018-12-02T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>程序的生命周期（执行时间表）分为几个阶段。<em>phaser</em>是在特定执行阶段调用的代码块。</p>
<h1 id="phasershttpsdocsrakuorglanguagephasers___top"><a href="https://docs.raku.org/language/phasers#___top">Phasers</a></h1>
<p>phaser 块只是包含它的闭包的 trait，并在适当的时刻自动调用。这些自动调用的块称为 <em>phasers</em>，因为它们通常标记从计算的一个阶段到另一个阶段的转换。例如，在编译编译单元结束时调用 <code>CHECK</code> 块。也可以安装其他类型的 phasers; 它们会在适当的时候自动调用，其中一些 phasers 响应各种控制异常和退出值。例如，如果块的退出成功或失败，则可能会调用某些 phasers，在这种情况下<em>成功</em>退出, 则在这时返回定义的值或列表，而不带任何 <code>Failure</code> 或异常。</p>
<p>以下是摘要：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">  <span class="k">BEGIN</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  * at compile time, as soon as possible, only ever runs once </span>
</span></span><span class="line"><span class="cl">  <span class="k">CHECK</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  * at compile time, as late as possible, only ever runs once </span>
</span></span><span class="line"><span class="cl">   <span class="k">INIT</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  * at runtime, as soon as possible, only ever runs once </span>
</span></span><span class="line"><span class="cl">    <span class="k">END</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at runtime, as late as possible, only ever runs once </span>
</span></span><span class="line"><span class="cl">    <span class="k">DOC</span> <span class="o">[</span><span class="k">BEGIN</span><span class="o">|</span><span class="k">CHECK</span><span class="o">|</span><span class="k">INIT</span><span class="o">]</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1"># only in documentation mode </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="k">ENTER</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  * at every block entry time, repeats on loop blocks. </span>
</span></span><span class="line"><span class="cl">  <span class="k">LEAVE</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at every block exit time (even stack unwinds from exceptions) </span>
</span></span><span class="line"><span class="cl">   <span class="k">KEEP</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at every successful block exit, part of LEAVE queue </span>
</span></span><span class="line"><span class="cl">   <span class="k">UNDO</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at every unsuccessful block exit, part of LEAVE queue </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="k">FIRST</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at loop initialization time, before any ENTER </span>
</span></span><span class="line"><span class="cl">   <span class="k">NEXT</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at loop continuation time, before any LEAVE </span>
</span></span><span class="line"><span class="cl">   <span class="k">LAST</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at loop termination time, after any LEAVE </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">PRE</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  assert precondition at every block entry, before ENTER </span>
</span></span><span class="line"><span class="cl">   <span class="k">POST</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  assert postcondition at every block exit, after LEAVE </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="k">CATCH</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  catch exceptions, before LEAVE </span>
</span></span><span class="line"><span class="cl"><span class="k">CONTROL</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  catch control exceptions, before LEAVE </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">   <span class="k">LAST</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  supply tapped by whenever-block is done, runs very last </span>
</span></span><span class="line"><span class="cl">   <span class="k">QUIT</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  catch async exceptions within a whenever-block, runs very last </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">COMPOSE</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  when a role is composed into a class (Not yet implemented) </span>
</span></span><span class="line"><span class="cl">  <span class="k">CLOSE</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  appears in a supply block, called when the supply is closed </span>
</span></span></code></pre></div><p>标记为 <code>*</code> 号的 phaser 具有运行时值，并且如果早于周围表达式进行求值，则只需保存其结果，以便在以后计算表达式的其余部分时在表达式中使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$compiletime</span> <span class="o">=</span> <span class="k">BEGIN</span> <span class="p">{</span> <span class="nb">now</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">our</span> <span class="nv">$random</span> <span class="o">=</span> <span class="k">ENTER</span> <span class="p">{</span> <span class="nb">rand</span> <span class="p">};</span>
</span></span></code></pre></div><p>与其他语句前缀一样，这些产生值的构造可以放在块或语句的前面：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$compiletime</span> <span class="o">=</span> <span class="k">BEGIN</span> <span class="nb">now</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">our</span> <span class="nv">$random</span> <span class="o">=</span> <span class="k">ENTER</span> <span class="nb">rand</span><span class="p">;</span>
</span></span></code></pre></div><p>这些 phaser 的大多数将接收块或函数引用。语句形式对于将词法作用域的声明暴露给周围的词法作用域而不在块中“捕获”它特别有用。</p>
<p>它们声明了与前面示例相同作用域的相同变量，但在指定时间把语句作为整体运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">BEGIN</span> <span class="k">my</span> <span class="nv">$compiletime</span> <span class="o">=</span> <span class="nb">now</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">ENTER</span> <span class="k">our</span> <span class="nv">$random</span> <span class="o">=</span> <span class="nb">rand</span><span class="p">;</span>
</span></span></code></pre></div><p>（但请注意，在运行时克隆任何周围闭包时，在编译时计算的变量值可能不会持久存在。）</p>
<p>大多数非值生成 phasers 也可能如此使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">END</span> <span class="nb">say</span> <span class="k">my</span> <span class="nv">$accumulator</span><span class="p">;</span>
</span></span></code></pre></div><p>但请注意：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">END</span> <span class="nb">say</span> <span class="k">my</span> <span class="nv">$accumulator</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span></code></pre></div><p>在 <code>END</code> time 时将变量设置为 0 ，因为这是实际执行 “my” 声明的时间。只有无参数的 phasers 可以使用语句形式。这意味着 <code>CATCH</code> 和 <code>CONTROL</code> 始终需要一个块，因为它们接收一个设置 <code>$_</code> 为当前主题的参数，以便内部行为能够表现为 switch 语句。（如果允许使用裸语句，那么 <code>$_</code> 临时绑定会在 <code>CATCH</code>或者<code>CONTROL</code> 结束时泄漏出来，带来不可预测的，甚至可能是可怕的后果。异常处理程序应该减少不确定性，而不是增加它。）</p>
<p>其中一些 phasers 也具有可以在变量上设置的相应 trait; 他们使用 <code>will</code> 后面跟着小写的 phaser 名称。这些优点是将讨论中的变量作为主题传递给闭包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">our</span> <span class="nv">$h</span> <span class="n">will</span> <span class="n">enter</span> <span class="p">{</span> <span class="o">.</span><span class="nf">rememberit</span><span class="p">()</span> <span class="p">}</span> <span class="n">will</span> <span class="n">undo</span> <span class="p">{</span> <span class="o">.</span><span class="nf">forgetit</span><span class="p">()</span> <span class="p">};</span>
</span></span></code></pre></div><p>只有在块内可以多次出现的 phaser 才有资格获得这种每个变量(per-variable)形式; 这不包括 <code>CATCH</code> 和其他例如 <code>CLOSE</code> 或 <code>QUIT</code> phaser 。</p>
<p>phaser 外部的块的主题作为 <code>OUTER::&lt;$_&gt;</code> 仍然可用。返回值是否可修改可能是所讨论的 phaser 的策略。特别地，不应在 <code>POST</code> phaser 内修改返回值，但 <code>LEAVE</code> phaser 可能更自由。</p>
<p>在方法的词法作用域中定义的任何 phaser 都是闭合 <code>self</code> 以及正常词汇。（或者等效地，实现可以简单地将所有这样的 phaser 转换为其引导的调用者是当前对象的子方法。）</p>
<p>当多个 phaser 被安排在同一时刻运行时，一般的打破平局的原则是初始化 phaser 按照声明的顺序执行，而最终 phaser 以相反的顺序执行，因为设置和拆除通常希望以相反的顺序相互发生。</p>
<h2 id="执行顺序httpsdocsrakuorglanguagephasers___top"><a href="https://docs.raku.org/language/phasers#___top">执行顺序</a></h2>
<p>编译开始</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">      <span class="k">BEGIN</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at compile time, As soon as possible, only ever runs once </span>
</span></span><span class="line"><span class="cl">      <span class="k">CHECK</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at compile time, As late as possible, only ever runs once </span>
</span></span><span class="line"><span class="cl">    <span class="n">COMPOSE</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  when a role is composed into a class (Not yet implemented) </span>
</span></span></code></pre></div><p>执行开始</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">       <span class="k">INIT</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at runtime, as soon as possible, only ever runs once </span>
</span></span></code></pre></div><p>在块执行开始之前</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">        <span class="k">PRE</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  assert precondition at every block entry, before ENTER </span>
</span></span></code></pre></div><p>循环执行开始</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">      <span class="k">FIRST</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at loop initialization time, before any ENTER </span>
</span></span></code></pre></div><p>块执行开始</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">      <span class="k">ENTER</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at every block entry time, repeats on loop blocks. </span>
</span></span></code></pre></div><p>可能会发生异常</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">      <span class="k">CATCH</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  catch exceptions, before LEAVE </span>
</span></span><span class="line"><span class="cl">    <span class="k">CONTROL</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  catch control exceptions, before LEAVE </span>
</span></span></code></pre></div><p>循环结束，继续或结束</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">       <span class="k">NEXT</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at loop continuation time, before any LEAVE </span>
</span></span><span class="line"><span class="cl">       <span class="k">LAST</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at loop termination time, after any LEAVE </span>
</span></span></code></pre></div><p>块结束</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">      <span class="k">LEAVE</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at every block exit time (even stack unwinds from exceptions) </span>
</span></span><span class="line"><span class="cl">       <span class="k">KEEP</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at every successful block exit, part of LEAVE queue </span>
</span></span><span class="line"><span class="cl">       <span class="k">UNDO</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at every unsuccessful block exit, part of LEAVE queue </span>
</span></span></code></pre></div><p>块的后置条件</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">       <span class="k">POST</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  assert postcondition at every block exit, after LEAVE </span>
</span></span></code></pre></div><p>异步 whenever-block 结束</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">       <span class="k">LAST</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  if ended normally with done, runs once after block </span>
</span></span><span class="line"><span class="cl">       <span class="k">QUIT</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  catch async exceptions </span>
</span></span></code></pre></div><p>程序终止</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">        <span class="k">END</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1">#  at runtime, ALAP, only ever runs once </span>
</span></span></code></pre></div><h1 id="程序执行-phasershttpsdocsrakuorglanguagephasers___top"><a href="https://docs.raku.org/language/phasers#___top">程序执行 phasers</a></h1>
<h2 id="begin">BEGIN</h2>
<p>编译时运行，一旦 phaser 中的代码编译完毕，就只运行一次。</p>
<p>返回值可在以后的 phaser 中使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">About to print 3 things</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">^</span><span class="mi">3</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">^</span><span class="mi">10</span> <span class="o">.</span><span class="nb">pick</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> <span class="o">~</span> <span class="k">BEGIN</span> <span class="p">{</span> <span class="nb">say</span>  <span class="p">&#34;</span><span class="s2">Generating BEGIN value</span><span class="p">&#34;;</span> <span class="o">^</span><span class="mi">10</span> <span class="o">.</span><span class="nb">pick</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Generating BEGIN value </span>
</span></span><span class="line"><span class="cl"><span class="c1"># About to print 3 things </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 3-3 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 4-3 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 6-3 </span>
</span></span></code></pre></div><p>phaser 中的 <code>^10 .pick</code> 只产生一次，并在运行时期间由循环重用。注意怎么 <code>BEGIN</code> 块中的 <a href="https://docs.raku.org/routine/say">say</a> 是在上述循环执行之前是怎么执行的。</p>
<h2 id="check">CHECK</h2>
<p>在编译时运行，尽可能晚，只运行一次。</p>
<p>可以具有即使在后期 phases 提供的返回值。</p>
<p>在运行时生成的代码仍然可以启动 <code>CHECK</code> 和 <code>INIT</code> phasers，但当然这些 phaser 无法做出需要及时返回的事情。你需要一个虫洞。</p>
<h2 id="init">INIT</h2>
<p>在 main 执行期间编译后运行，尽快运行一次。它可以具有即使在后期 phases 也提供的返回值。</p>
<p>当 phaser 位于不同的模块中时， phaser <code>INIT</code> 和 <code>END</code> phaser 将被视为在使用模块中就像在 <code>use</code> 时声明一样。（如果模块被多次使用，则依赖于此顺序是错误的，因为仅在第一次注意到它们时才安装 phaser 。）</p>
<p>在运行时生成的代码仍然可以启动 <code>CHECK</code> 和 <code>INIT</code> phaser，但当然这些 phaser 无法做出需要及时返回的事情。你需要一个虫洞。</p>
<p>对 <code>INIT</code> 克隆闭包的所有副本只运行一次。</p>
<h2 id="end">END</h2>
<p>在 main 执行期间编译后运行，尽可能晚，只运行一次。</p>
<p>当 phaser 位于不同的模块中时， <code>INIT</code> 和 <code>END</code> phaser 将被视为在正使用的模块中就像在 <code>use</code> 时声明一样。（如果模块被多次使用，则依赖于此顺序是错误的，因为仅在第一次注意到它们时才安装 phaser 。）</p>
<h1 id="block-phasershttpsdocsrakuorglanguagephasers___top"><a href="https://docs.raku.org/language/phasers#___top">Block phasers</a></h1>
<p>块的上下文中的执行具有其自己的 phases。</p>
<p>块离开 phaser 等待直到调用堆栈实际展开才能运行。只有在某个异常处理程序决定以这种方式处理异常之后才会展开。也就是说，仅仅因为异常被抛出堆栈帧并不意味着我们已经正式离开了块，因为异常可能是可恢复的。在任何情况下，异常处理程序都指定在失败代码的动态作用域内运行，无论异常是否可恢复。堆栈已展开，仅在未恢复异常时才调用 phaser 。</p>
<p>这些可以在块内多次出现。所以它们确实不是真正的 trait - 它们将自己添加到存储在实际 trait 中的列表中。如果你检查块的 <code>ENTER</code> trait，你会发现它实际上是一个 phaser 列表而不是一个 phaser 。</p>
<p>所有这些 phaser 块都可以看到任何先前声明的词法变量，即使在调用闭包时尚未详细说明这些变量（在这种情况下，变量会计算为未定义的值。）</p>
<h2 id="enter">ENTER</h2>
<p>在每个块进入时运行，在循环块上重复。</p>
<p>可以具有即使在后期 phases 提供的返回值。</p>
<p>从 <code>ENTER</code> phaser 抛出的异常将中止 <code>ENTER</code> 队列，但是从 <code>LEAVE</code> phaser 抛出的异常将不会。</p>
<h2 id="leave">LEAVE</h2>
<p>在每个块退出时运行（甚至堆栈从异常中展开），除非程序突然退出（例如 <a href="https://docs.raku.org/routine/exit"><code>exit</code></a>）。</p>
<p><code>LEAVE</code> 在任何 <code>CATCH</code> 和 <code>CONTROL</code> phaser 之后必须计算给定块的 phaser 。这包括 <code>LEAVE</code> 变体，<code>KEEP</code> 和 <code>UNDO</code>。<code>POST</code> 在其他一切之后对 phaser 进行计算，以保证偶数 <code>LEAVE</code> phaser 不会违反后置条件。</p>
<p>从 <code>ENTER</code> phaser 抛出的异常将中止 <code>ENTER</code> 队列，但是从 <code>LEAVE</code> phaser 抛出的异常将不会。</p>
<p>如果 <code>POST</code> 失败或任何类型的 <code>LEAVE</code> 块在堆栈展开时抛出异常，则展开继续并收集要处理的异常。展开完成后，将从该点抛出所有新异常。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">answer</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">LEAVE</span> <span class="nb">say</span> „<span class="n">I</span> <span class="nb">say</span> <span class="nb">after</span> <span class="n">the</span> <span class="k">return</span> <span class="nb">value</span><span class="o">.</span>“<span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="mi">42</span> <span class="c1"># this is the return value </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>注意:</strong> 铭记 <code>LEAVE</code> phaser 直接在程序的块，即使用错误的参数尝试调用该例程, 他们也将得到执行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span> <span class="p">(</span><span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">LEAVE</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">oh noes!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="n">foo</span> <span class="nb">rand</span><span class="p">;</span> <span class="c1"># OUTPUT: «oh noes!» </span>
</span></span></code></pre></div><p>虽然子程序的主体没有得到执行，因为 sub 的<a href="https://docs.raku.org/type/Int">Int</a> 和 <a href="https://docs.raku.org/routine/rand"><code>rand</code></a> 期望返回一个 <a href="https://docs.raku.org/type/Num">Num</a>，其块进入和离开时（指令绑定失败），因此 <code>LEAVE</code> phaser <em>正</em>运行。</p>
<h2 id="keep">KEEP</h2>
<p>在每个成功的块出口处运行，作为 LEAVE 队列的一部分（共享相同的执行顺序）。</p>
<h2 id="undo">UNDO</h2>
<p>在每个不成功的块出口处运行，作为 LEAVE 队列的一部分（共享相同的执行顺序）。</p>
<h2 id="pre">PRE</h2>
<p>断言每个块条目的前提条件。在 ENTER phase 之前运行。</p>
<p><code>PRE</code> phaser 在任何 <code>ENTER</code> 或 <code>FIRST</code> 之前启动。</p>
<p>失败的 <code>PRE</code> 和 <code>POST</code> phaser 抛出的异常不能被同一个块中的 <code>CATCH</code> 异常捕获，这意味着如果<code>PRE</code>phaser 失败，则 <code>POST</code> phaser 不会运行。</p>
<h2 id="post">POST</h2>
<p>在每个块条目处断言后置条件。在 LEAVE phase 后运行。</p>
<p>对于如 <code>KEEP</code> 和 <code>POST</code> 的 phaser，在正常情况下退出作用域时运行，返回值（如果有的话）从该作用域可作为 phaser 中的当前主题。</p>
<p><code>POST</code> 块可以以两种方式之一来定义。要么 <code>POST</code> 定义为单独的 phaser ，在这种情况下 <code>PRE</code> 和 <code>POST</code> 不共享词法作用域。或者，任何 <code>PRE</code> phaser 都可以将其对应的 <code>POST</code> 定义为嵌入式 phaser 块，该 phaser 块封闭在 <code>PRE</code> 的词法作用域内。</p>
<p>如果 <code>POST</code> 失败或任何类型的 <code>LEAVE</code> 块在堆栈展开时抛出异常，则展开继续并收集要处理的异常。展开完成后，将从该点抛出所有新异常。</p>
<p><code>PRE</code> 和 <code>POST</code> phaser 抛出的异常不能被同一个块中的  <code>CATCH</code> 异常捕获，这意味着如果 <code>PRE</code> phaser 失败，<code>POST</code> phaser 就不会运行。</p>
<h1 id="loop-phasershttpsdocsrakuorglanguagephasers___top"><a href="https://docs.raku.org/language/phasers#___top">Loop phasers</a></h1>
<p><code>FIRST</code>，<code>NEXT</code> 和 <code>LAST</code> 仅在循环的词法作用域内有意义，并且可能仅在这样的循环块的顶层发生。</p>
<h2 id="first">FIRST</h2>
<p>在 ENTER 之前运行循环初始化。</p>
<h2 id="next">NEXT</h2>
<p>循环继续（通过 <code>next</code> 或因为你到达循环的底部并循环回来）时运行，在LEAVE之前。</p>
<p>仅当正常到达循环块的末尾或 <code>next</code>显式 执行时，才执行 <code>NEXT</code>。 与 <code>LEAVE</code> phaser 不同，<code>NEXT</code> 如果通过除由 <code>next</code> 引发的控制异常之外的任何异常退出循环块，则不执行 <code>NEXT</code> phaser。特别地，<code>last</code> 绕过了 <code>NEXT</code> phaser 的计算。</p>
<h2 id="last">LAST</h2>
<p>在循环结束时运行，在 <code>LEAVE</code> 之后(或者当它使用 <code>last</code> 或 <code>return</code> 退出时; 或者因为你到了循环的底部) 。</p>
<h1 id="exception-handling-phasershttpsdocsrakuorglanguagephasers___top"><a href="https://docs.raku.org/language/phasers#___top">Exception handling phasers</a></h1>
<h2 id="catch">CATCH</h2>
<p>在 LEAVE phase 之前，当前块引发异常时运行。</p>
<h2 id="control">CONTROL</h2>
<p>在 LEAVE phase 之前，当前块引发控制异常时运行。它通过 <code>return</code>，<code>fail</code>，<code>redo</code>，<code>next</code>，<code>last</code>，<code>emit</code>，<code>take</code>，<code>warn</code>，<code>proceed</code> 和 <code>succeed</code> 发生。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">elems</span> <span class="k">gather</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">CONTROL</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="ne">CX::Warn</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">WARNING!!! </span><span class="nv">$_</span><span class="p">&#34;;</span> <span class="o">.</span><span class="nb">resume</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="ne">CX::Take</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Don&#39;t take my stuff</span><span class="p">&#34;;</span> <span class="o">.</span><span class="nb">resume</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nb">warn</span> <span class="p">&#39;</span><span class="s1">people take stuff here</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">take</span> <span class="p">&#39;</span><span class="s1">keys</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># WARNING!!! people take stuff here </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Don&#39;t take my stuff </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 0 </span>
</span></span></code></pre></div><h1 id="object-phasershttpsdocsrakuorglanguagephasers___top"><a href="https://docs.raku.org/language/phasers#___top">Object phasers</a></h1>
<h2 id="compose-not-yet-implemented">COMPOSE (Not yet implemented)</h2>
<p>将角色组合到一个类中时运行。</p>
<h1 id="asynchronous-phasershttpsdocsrakuorglanguagephasers___top"><a href="https://docs.raku.org/language/phasers#___top">Asynchronous phasers</a></h1>
<h2 id="last-1">LAST</h2>
<p>当<a href="https://docs.raku.org/type/Supply">Supply</a> 完成 <code>done</code> 调用或当一个 <code>supply</code> 块正常退出时运行。它在 <code>whenever</code> 块完成后完全运行。</p>
<p>此 phaser 重用该名称 <code>LAST</code>，但与 <code>LAST</code> 循环 phaser 的工作方式不同。此 phaser 类似于用 <code>tap</code> supply 设置例程 <code>done</code>。</p>
<h2 id="quit">QUIT</h2>
<p>当 <a href="https://docs.raku.org/type/Supply">Supply</a> 以异常提前终止时运行。它在放置的  <code>whenever</code> 块完成后运行。</p>
<p>此 phaser 类似于 <code>quit</code> 在 <code>tap</code> supply 时设置例程 <code>quit</code>。</p>
<h2 id="close">CLOSE</h2>
<p>出现在 supply 块中。supply 关闭时调用。</p>
<h1 id="doc-phasershttpsdocsrakuorglanguagephasers___top"><a href="https://docs.raku.org/language/phasers#___top">DOC phasers</a></h1>
<h2 id="doc">DOC</h2>
<p>phaser <code>BEGIN</code>，<code>CHECK</code> 和 <code>INIT</code> 仅在文档模式时，前面带有 <code>DOC</code> 关键字。当使用 <code>--doc</code> 运行时编译器在文档中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">DOC</span> <span class="k">INIT</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">init</span><span class="p">&#39;</span>  <span class="p">}</span>  <span class="c1"># prints &#39;init&#39; at initialization time when in documentation mode. </span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 原生类型]]></title>
            <link href="http://localhost:1313/rakulang/57.perl-6-native-types/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/58.phasers/?utm_source=atom_feed" rel="related" type="text/html" title="Phasers" />
                <link href="http://localhost:1313/notes/grepping-dividable-numbers-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 2/25. 在 Raku 中 Grepping 可整除的数字" />
                <link href="http://localhost:1313/notes/welcome-and-mojo-conf-recap/?utm_source=atom_feed" rel="related" type="text/html" title="第一天 - 欢迎来到 Mojo 会议" />
                <link href="http://localhost:1313/rakulang/56.performance/?utm_source=atom_feed" rel="related" type="text/html" title="性能" />
                <link href="http://localhost:1313/notes/generating-random-passwords-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 1/25. 在 Raku 中生成随机密码" />
            
                <id>http://localhost:1313/rakulang/57.perl-6-native-types/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-02T21:13:31+08:00</published>
            <updated>2018-12-02T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>Raku 提供了一组原生类型，在内存中具有固定且已知的表示。此页面显示了存在哪些原生类型以及如何使用它们。有关它们的更多信息，请查看有关<a href="https://docs.raku.org/language/numerics#Native_numerics">原生数字</a> 的页面。</p>
<h1 id="types-with-native-representationhttpsdocsrakuorglanguagenativetypes___top"><a href="https://docs.raku.org/language/nativetypes#___top">Types with native representation</a></h1>
<p>Raku 中的一些简单类型具有原生表示，表示它们将使用编译器，操作系统和原生提供的 C 语言表示。这些是可用的四种原生类型：</p>
<table>
<thead>
<tr>
<th>int</th>
<th>Equivalent to Int (with limited range)</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint</td>
<td>Equivalent to Int (with limited range) with the unsigned trait</td>
</tr>
<tr>
<td>num</td>
<td>Equivalent to Num</td>
</tr>
<tr>
<td>str</td>
<td>Equivalent to Str</td>
</tr>
</tbody>
</table>
<p>但是，这些类型不一定具有 <a href="https://docs.raku.org/language/nativecall">NativeCall</a> 接口所需的大小（例如，Raku 的 <code>int</code> 可以是 8 个字节，但 C 的 <code>int</code> 只有 4 个字节）; 必须使用以下类型而不是上面列出的 <code>int</code> 或 <code>num</code> 类型。</p>
<p>通常，这些变量的行为与常规标量变量的行为方式相同，称为<a href="https://docs.raku.org/language/numerics#Auto-boxing"><em>自动装箱</em></a>; 然而，存在一些差异，因为您实际宣称的是如何表示它们，而不是它们的实际类型。第一个是它们的类型实际上是它们的等效类型，而不是它们的原生类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">int</span> <span class="nv">$intillo</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$intillo</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># OUTPUT: «Int␤» </span>
</span></span></code></pre></div><p>这显然意味着他们将智能匹配他们的等效（自动装箱）类型，而不是他们的原生类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">str</span> <span class="nv">$strillo</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">tres</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$strillo</span> <span class="o">~~</span> <span class="kt">str</span><span class="p">;</span> <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$strillo</span> <span class="o">~~</span> <span class="kt">Str</span><span class="p">;</span> <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>并且与非原生对应物不同，他们将始终具有默认值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="k">my</span> <span class="kt">Str</span> <span class="nv">$</span><span class="p">);</span> <span class="c1"># OUTPUT: «(Str)␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="k">my</span> <span class="kt">str</span> <span class="nv">$</span><span class="p">);</span> <span class="c1"># OUTPUT: «␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="k">my</span> <span class="n">num</span> <span class="nv">$</span><span class="p">);</span> <span class="c1"># OUTPUT: «0␤» </span>
</span></span></code></pre></div><p><strong>注意</strong>: 在 v6.c 中，<code>num</code> 的默认值是 NaN。</p>
<p>这是因为 Natives 不知道他们的类型，因为他们只是值，没有任何元数据。在<a href="https://docs.raku.org/language/glossary#Multi-Dispatch">多重分派</a> 中，您可以拥有原生候选者，但无法区分相同原生类型的不同大小。也就是说，你可以有一个 <a href="https://docs.raku.org/type/Int">Int</a> 和 <a href="https://docs.raku.org/type/int">int</a> 候选者，但是 <a href="https://docs.raku.org/type/int">int</a>, <a href="https://docs.raku.org/type/atomicint">atomicint</a>, <a href="https://docs.raku.org/type/int64">int64</a> 等候选者之间会有歧义。</p>
<p>它们也不能被绑定。尝试做 <code>my num $numillo := 3.5</code> 会发出异常 <code>Cannot bind to natively typed variable '$variable-name'; use assignment instead</code>。</p>
<p>原生类型也可以是复合的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">int</span> <span class="nv">@intillos</span> <span class="o">=</span> <span class="o">^</span><span class="mi">10_000_000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[+]</span> <span class="nv">@intillos</span><span class="p">;</span> <span class="c1"># OUTPUT: «49999995000000␤» </span>
</span></span></code></pre></div><p>在这种情况下，<em>native</em>ness 扩展到复合类型，它将是 <code>array</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">num</span> <span class="nv">@many-pi</span>  <span class="o">=</span> <span class="o">^</span><span class="mi">8</span> <span class="o">»*»</span> <span class="no">π</span> <span class="p">;</span> <span class="nb">say</span> <span class="nv">@many-pi</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>  <span class="c1"># OUTPUT: «array[num]␤» </span>
</span></span></code></pre></div><p>原生<code>数组</code>是 <a href="https://docs.raku.org/type/Iterable">Iterable</a>，但它们不是 List 的子类。但是，它们的行为类似于 <a href="https://docs.raku.org/type/Array">Array</a>; 例如，它们可以成形</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">str</span> <span class="nv">@letter-pairs</span><span class="o">[</span><span class="mi">10</span><span class="o">]</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">j</span><span class="p">&#39;</span> <span class="ow">Z</span><span class="o">~</span> <span class="p">&#39;</span><span class="s1">A</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">J</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@letter-pairs</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «array[str].new(:shape(10,), [&#34;aA&#34;, &#34;bB&#34;, &#34;cC&#34;, &#34;dD&#34;, &#34;eE&#34;, &#34;fF&#34;, &#34;gG&#34;, &#34;hH&#34;, &#34;iI&#34;, &#34;jJ&#34;])␤» </span>
</span></span></code></pre></div><h1 id="types-with-native-representation-and-sizehttpsdocsrakuorglanguagenativetypes___top"><a href="https://docs.raku.org/language/nativetypes#___top">Types with native representation and size</a></h1>
<p>关于具有原生表示的类型的提及也适用于此;它们将自动装入 Raku 类型，并且不受限制。但是，下表中列出的这些类型具有可在 NativeCall](<a href="https://docs.raku.org/language/nativecall#Passing_and_returning_values">https://docs.raku.org/language/nativecall#Passing_and_returning_values</a>) 函数中使用的特性：</p>
<table>
<thead>
<tr>
<th>int8</th>
<th>(int8_t in C, also used for char)</th>
</tr>
</thead>
<tbody>
<tr>
<td>int16</td>
<td>(int16_t in C, also used for short)</td>
</tr>
<tr>
<td>int32</td>
<td>(int32_t in C, also used for int)</td>
</tr>
<tr>
<td>int64</td>
<td>(int64_t in C)</td>
</tr>
<tr>
<td>byte, uint8</td>
<td>(uint8_t in C, also used for unsigned char)</td>
</tr>
<tr>
<td>uint16</td>
<td>(uint16_t in C, also used for unsigned short)</td>
</tr>
<tr>
<td>uint32</td>
<td>(uint32_t in C, also used for unsigned int)</td>
</tr>
<tr>
<td>uint64</td>
<td>(uint64_t in C)</td>
</tr>
<tr>
<td>num32</td>
<td>(float in C)</td>
</tr>
<tr>
<td>num64</td>
<td>(double in C)</td>
</tr>
</tbody>
</table>
<p>这些类型具有固定大小的表示，它独立于平台，因此可以安全地用于那些原生调用。如果我们愿意，没有什么能阻止我们在任何其他环境中使用它们。与上述类型相同，在为此类型的变量赋值时，必须考虑此大小：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">byte</span> <span class="nv">$intillo</span> <span class="o">=</span> <span class="mi">257</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$intillo</span><span class="p">;</span> <span class="c1"># OUTPUT: «1␤» </span>
</span></span></code></pre></div><p>由于 <code>byte</code> 只能容纳 8 位，因此它将换行并分配模值为 256 的原始值的结果，这就是所示的内容。</p>
<p>声明原生大小的类型与没有声明原生大小的类型之间的主要区别是在声明中使用了 nativesize。例如，<code>int8</code> 以这种方式声明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">native</span> <span class="kt">int8</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">P6int</span><span class="p">&#39;)</span> <span class="k">is</span> <span class="kt">Int</span> <span class="k">is</span> <span class="nc">nativesize</span><span class="p">(</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></div><p>表示除了整数表示（<code>P6int</code>）之外，它还将使用仅 8 位的原生大小。但是，这个特性并不打算在您的程序中使用，因为它不是 Raku 规范的一部分。</p>
<h1 id="void-类型httpsdocsrakuorglanguagenativetypes___top"><a href="https://docs.raku.org/language/nativetypes#___top"><code>void</code> 类型</a></h1>
<p>原生 <code>void</code> 类型对应于 C 的 <code>void</code> 类型。虽然是有效类型，但您可以在表达式中使用它</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">void</span> <span class="nv">$nothing</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$nothing</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span> <span class="c1"># OUTPUT: «NativeCall::Types::void␤» </span>
</span></span></code></pre></div><p>实际上，它是一个很难单独使用的 <code>Uninstantiable</code> 类型，实际上它在 <a href="(https://docs.raku.org/language/nativecall#Passing_and_returning_values)"><code>return</code></a> 类型中被明确禁止。但是，它通常在类型指针中找到，表示等效于 C 中的 <code>void *</code> 指针。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">malloc</span><span class="p">(</span> <span class="kt">int32</span> <span class="nv">$size</span> <span class="k">--&gt;</span> <span class="kt">Pointer</span><span class="o">[</span><span class="n">void</span><span class="o">]</span> <span class="p">)</span> <span class="k">is</span> <span class="k">native</span> <span class="p">{</span> <span class="o">*</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Pointer</span><span class="o">[</span><span class="n">void</span><span class="o">]</span> <span class="nv">$for-malloc</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span> <span class="mi">32</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$for-malloc</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span></code></pre></div><p>如果您需要在使用该类型的原生函数中使用它们，您还可以将 <a href="https://docs.raku.org/type/Blob">Blob</a> <a href="https://docs.raku.org/routine/nativecast">nativecast</a>  到此类指针上。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Pointer</span><span class="o">[</span><span class="n">void</span><span class="o">]</span> <span class="nv">$native</span> <span class="o">=</span> <span class="nb">nativecast</span><span class="p">(</span><span class="kt">Pointer</span><span class="o">[</span><span class="n">void</span><span class="o">],</span> <span class="kt">Blob</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mh">0x22</span><span class="o">,</span> <span class="mh">0x33</span><span class="p">));</span>
</span></span></code></pre></div><p>但是，除此之外，它提供的功能非常有限，因为指向 <code>void</code> 的指针无法解引用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Pointer</span><span class="o">[</span><span class="n">void</span><span class="o">]</span> <span class="nv">$native</span> <span class="o">=</span> <span class="nb">nativecast</span><span class="p">(</span><span class="kt">Pointer</span><span class="o">[</span><span class="n">void</span><span class="o">],</span> <span class="kt">Buf</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mh">0x22</span><span class="o">,</span> <span class="mh">0x33</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$native</span><span class="o">.</span><span class="nf">deref</span><span class="p">;</span> <span class="c1"># ERROR OUTPUT: «Internal error: unhandled target type␤» </span>
</span></span></code></pre></div><h1 id="atomic-typeshttpsdocsrakuorglanguagenativetypes___top"><a href="https://docs.raku.org/language/nativetypes#___top"><em>Atomic</em> types</a></h1>
<p>在这种情况下，<em>atomic</em> 指的是线程下的安全操作。 Raku 提供了一个类型，<a href="https://docs.raku.org/type/atomicint"><code>atomicint</code></a> 和<a href="https://docs.raku.org/type/atomicint#Routines">一些操作</a>，它们共同保证了这一点。有关详细信息，请查看 <a href="(https://docs.raku.org/language/numerics#Atomic_operations)">Numerics</a> 页面上的原子操作部分。</p>
<h1 id="rakudo-specific-native-typeshttpsdocsrakuorglanguagenativetypes___top"><a href="https://docs.raku.org/language/nativetypes#___top">Rakudo specific native types</a></h1>
<p>本节中描述的类型是特定于 Rakudo 的，因此不保证它们在其他实现中或在将来的版本中保持不变。</p>
<table>
<thead>
<tr>
<th>long</th>
<th>(long in C)</th>
</tr>
</thead>
<tbody>
<tr>
<td>longlong</td>
<td>(longlong in C)</td>
</tr>
<tr>
<td>ulong</td>
<td>(long and unsigned in C)</td>
</tr>
<tr>
<td>ulonglong</td>
<td>(longlong and unsigned in C)</td>
</tr>
<tr>
<td>size_t</td>
<td>(size_t and unsigned in C)</td>
</tr>
<tr>
<td>ssize_t</td>
<td>(size_t in C)</td>
</tr>
<tr>
<td>bool</td>
<td>(bool in C)</td>
</tr>
</tbody>
</table>
<p>您可以像在本机 C 中使用它们一样使用它们：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$just-an-array</span> <span class="o">=</span> <span class="kt">CArray</span><span class="o">[</span><span class="kt">int32</span><span class="o">].</span><span class="nb">new</span><span class="p">(</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">loop</span> <span class="p">(</span> <span class="k">my</span> <span class="kt">size_t</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">&lt;</span> <span class="nv">$just-an-array</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span> <span class="nv">$i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$just-an-array</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这将打印数组的五个元素，因为它应该是你期望的。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[性能]]></title>
            <link href="http://localhost:1313/rakulang/56.performance/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/generating-random-passwords-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="🎄 1/25. 在 Raku 中生成随机密码" />
                <link href="http://localhost:1313/notes/regexes-and-guesses/?utm_source=atom_feed" rel="related" type="text/html" title="正则表达式和猜测（名称提取）" />
                <link href="http://localhost:1313/rakulang/55.packages/?utm_source=atom_feed" rel="related" type="text/html" title="包" />
                <link href="http://localhost:1313/notes/working-with-complex-data-formats-with-structured-streaming-in-apache-spark-2-1/?utm_source=atom_feed" rel="related" type="text/html" title="在结构化流中使用复杂数据格式" />
                <link href="http://localhost:1313/notes/cassandra-sink-for-spark-structured-streaming/?utm_source=atom_feed" rel="related" type="text/html" title="用于 Spark 结构化流的 Cassandra 接收器" />
            
                <id>http://localhost:1313/rakulang/56.performance/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-12-01T21:13:31+08:00</published>
            <updated>2018-12-01T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>该页面是关于在 Raku 上下文中 <a href="https://en.wikipedia.org/wiki/Computer_performance">计算机性能</a> 的。</p>
<h1 id="首先剖析你的代码httpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">首先,剖析你的代码</a></h1>
<p><strong>确保你没有在错误的代码上浪费时间</strong>: 通过剖析你的代码的性能以从识别你的 <a href="https://en.wikiquote.org/wiki/Donald_Knuth">&ldquo;临界 3%&rdquo;</a> 开始。本文档的其余部分将向您展示如何执行此操作。</p>
<h2 id="time-with-now---init-nowhttpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">Time with <code>now - INIT now</code></a></h2>
<p>对于 <code>now - INIT now</code> 形式的表达式, 其中 <code>INIT</code> 是一个 <a href="https://docs.raku.org/language/phasers">Raku 程序中运行的 phase</a>, 为计时代码片段提供了一个很好的习惯用法。</p>
<p>使用 <code>m: your code goes here</code> <a href="https://docs.raku.org/language/glossary#camelia">raku 频道 evalbot</a> 来写出这样的行:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">m</span><span class="err">:</span> <span class="err">say</span> <span class="err">now</span> <span class="p">-</span><span class="sr"> INIT now
</span></span></span><span class="line"><span class="cl"><span class="sr">rakudo</span><span class="p">-</span><span class="nf">moar</span> <span class="n">abc1234:</span> <span class="n">OUTPUT</span><span class="p">«</span><span class="s2">0.0018558␤</span><span class="p">»</span>
</span></span></code></pre></div><p><code>INIT</code> 左边的 <code>now</code> 比 <code>INIT</code> 右边的 <code>now</code> <em>晚</em>运行了 0.0018558 秒, 因为后者在<a href="https://docs.raku.org/language/phasers#INIT">INIT phase</a> 期间出现。</p>
<h2 id="本地剖析httpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">本地剖析</a></h2>
<p>当使用 <a href="https://moarvm.org/">MoarVM</a> 后端时, <a href="https://rakudo.org/">Rakudo</a> 编译器的 <code>--profile</code> 命令行选项将剖析数据写到一个 HTML 文件中。</p>
<p>此文件将打开“概述”部分，该部分提供有关程序如何运行的一些总体数据，例如总运行时间，执行垃圾回收所花费的时间。您将获得的一个重要信息是被解释的总调用帧（即，块）的百分比（最慢，红色），拼写（更快，橙色）和 jitted（最快，绿色）。</p>
<p>下一节“常规”可能是您花费最多时间的地方。它有一个可排序和可过滤的例程（或块）名称+文件+行的表，它运行的次数，包含时间（在该例程中花费的时间+从它调用的所有例程中花费的时间），独占时间（仅在该例程中花费的时间），以及它是否被解释，拼写或jitted（与“概述”页面相同的颜色代码）。按专属时间排序是了解从哪里开始优化的好方法。文件名从 <code>SETTING::src/core/</code> 或 <code>gen/moar/</code> 开始的例程来自编译器，从您自己的代码中看到的东西的一个好方法是将您描述的脚本的文件名放在“名称”中“ 搜索框。</p>
<p>“调用图”部分给出了与“例程”部分大致相同信息的火焰图表示。</p>
<p>“分配”部分为您提供有关分配的不同类型的数量以及分配的例程的信息。</p>
<p>“GC”部分为您提供有关所发生的所有垃圾收集的详细信息。</p>
<p>“OSR/Deopt”部分为您提供有关堆栈替换（OSR）的信息，这是在将例程从“已解释”升级为“拼写”或“jitted”时。当拼写或jitted代码必须被“降级”为被解释时，De是相反的。</p>
<p>如果配置文件数据太大，浏览器可能需要很长时间才能打开该文件。在这种情况下，使用 <code>--profile-filename</code> 选项输出到扩展名为 <code>.json</code> 的文件，然后使用 <a href="https://github.com/tadzik/p6profiler-qt">Qt</a> 查看器打开该文件。</p>
<p>要处理更大的配置文件，请输出到扩展名为 <code>.sql</code> 的文件。这将把配置文件数据写成一系列SQL语句，适合在 SQLite 中打开。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># create a profile </span>
</span></span><span class="line"><span class="cl"><span class="nb">raku</span> <span class="o">--</span><span class="n">profile</span> <span class="o">--</span><span class="n">profile-filename</span><span class="o">=</span><span class="n">demo</span><span class="o">.</span><span class="nf">sql</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">say (^20).combinations(3).elems</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># create a SQLite database </span>
</span></span><span class="line"><span class="cl"><span class="n">sqlite3</span> <span class="n">demo</span><span class="o">.</span><span class="nf">sqlite</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># load the profile data </span>
</span></span><span class="line"><span class="cl"><span class="n">sqlite</span><span class="o">&gt;</span> <span class="o">.</span><span class="nb">read</span> <span class="n">demo</span><span class="o">.</span><span class="nf">sql</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># the query below is equivalent to the default view of the &#34;Routines&#34; tab in the HTML profile </span>
</span></span><span class="line"><span class="cl"><span class="n">sqlite</span><span class="o">&gt;</span> <span class="n">select</span>
</span></span><span class="line"><span class="cl">      <span class="n">case</span> <span class="k">when</span> <span class="nb">r</span><span class="o">.</span><span class="nb">name</span> <span class="o">=</span> <span class="p">&#34;&#34;</span> <span class="nb">then</span> <span class="p">&#34;</span><span class="s2">&lt;anon&gt;</span><span class="p">&#34;</span> <span class="k">else</span> <span class="nb">r</span><span class="o">.</span><span class="nb">name</span> <span class="nb">end</span> <span class="n">as</span> <span class="nb">name</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">      <span class="nb">r</span><span class="o">.</span><span class="nb">file</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">      <span class="nb">r</span><span class="o">.</span><span class="nb">line</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">      <span class="nb">sum</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span> <span class="n">as</span> <span class="n">entries</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">      <span class="nb">sum</span><span class="p">(</span><span class="n">case</span> <span class="k">when</span> <span class="n">rec_depth</span> <span class="o">=</span> <span class="mi">0</span> <span class="nb">then</span> <span class="n">inclusive_time</span> <span class="k">else</span> <span class="mi">0</span> <span class="nb">end</span><span class="p">)</span> <span class="n">as</span> <span class="n">inclusive_time</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">      <span class="nb">sum</span><span class="p">(</span><span class="n">exclusive_time</span><span class="p">)</span> <span class="n">as</span> <span class="n">exclusive_time</span>
</span></span><span class="line"><span class="cl">    <span class="nb">from</span>
</span></span><span class="line"><span class="cl">      <span class="n">calls</span> <span class="n">c</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">routines</span> <span class="nb">r</span>
</span></span><span class="line"><span class="cl">    <span class="k">where</span>
</span></span><span class="line"><span class="cl">      <span class="n">c</span><span class="o">.</span><span class="nb">id</span> <span class="o">=</span> <span class="nb">r</span><span class="o">.</span><span class="nb">id</span>
</span></span><span class="line"><span class="cl">    <span class="n">group</span> <span class="n">by</span>
</span></span><span class="line"><span class="cl">      <span class="n">c</span><span class="o">.</span><span class="nb">id</span>
</span></span><span class="line"><span class="cl">    <span class="n">order</span> <span class="n">by</span>
</span></span><span class="line"><span class="cl">      <span class="n">inclusive_time</span> <span class="nb">desc</span>
</span></span><span class="line"><span class="cl">    <span class="n">limit</span> <span class="mi">30</span><span class="p">;</span>
</span></span></code></pre></div><p>要了解如何解释配置文件信息，请使用 evalbot（如上所述）并在 IRC 频道上提问。</p>
<h2 id="profile-编译httpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">Profile 编译</a></h2>
<p>If you want to profile the time and memory it takes to compile your code, use Rakudo&rsquo;s <code>--profile-compile</code> or <code>--profile-stage</code>options.
如果要分析编译代码所需的时间和内存，请使用 Rakudo 的 <code>--profile-compile</code> 或 <code>--profile-stage</code> 选项。</p>
<h2 id="创建或查看基准httpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">创建或查看基准</a></h2>
<p>使用 <a href="https://github.com/japhb/raku-bench">raku-bench</a>。</p>
<p>如果您为多个编译器（通常是 Perl 5，Raku 或 NQP 的版本）运行 raku-bench，则每个编译器的结果将在视觉上覆盖在相同的图形上，以便快速轻松地进行比较。</p>
<h2 id="share-problemshttpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">Share problems</a></h2>
<p>Once you&rsquo;ve used the above techniques to identify the code to improve, you can then begin to address (and share) the problem with others:</p>
<ul>
<li>对于每个问题，将其提取到单行或 gist，并提供性能数字或使片段足够小，以便可以使用 <code>prof-m: your code or gist URL goes here</code> 进行分析。</li>
<li>考虑你需要/想要的最低速度增加（或减少或减少什么），并考虑与实现该目标相关的成本。在人们的时间和精力方面，改进的价值是什么？</li>
<li>让其他人知道您的 Raku 用例是在生产环境中还是仅仅是为了好玩。</li>
</ul>
<h1 id="解决问题httpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">解决问题</a></h1>
<p>这需要重复：<strong>确保你没有浪费时间在错误的代码上</strong>。首先确定代码的“<a href="https://en.wikiquote.org/wiki/Donald_Knuth">关键3％</a>”。</p>
<h2 id="逐行httpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">逐行</a></h2>
<p>尝试逐行改进代码的快速，有趣和高效的方法是使用 raku <a href="https://docs.raku.org/language/glossary#IRC">evalbot</a> <a href="https://docs.raku.org/language/glossary#camelia">camelia</a> 与其他人协作。</p>
<h2 id="逐个例程httpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">逐个例程</a></h2>
<p>使用 multidispatch，您可以在现有的例程“旁边”添加新的例程变体：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># existing code generically matches a two arg foo call: </span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">Any</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Any</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># new variant takes over for a foo(&#34;quux&#34;, 42) call: </span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">foo</span><span class="p">(&#34;</span><span class="s2">quux</span><span class="p">&#34;</span><span class="o">,</span> <span class="kt">Int</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span></code></pre></div><p>拥有多个 <code>foo</code> 定义的调用开销通常是微不足道的（虽然请参见下面的讨论），因此如果您的新定义比以前存在的定义集更有效地处理其特定情况，那么您可能只是使您的代码更有效率对于那种情况。</p>
<h2 id="加速类型检测和调用解析httpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">加速类型检测和调用解析</a></h2>
<p>大多数 <a href="https://docs.raku.org/type/Signature#Type_constraints">where 子句</a>  - 以及大多数<a href="https://design.raku.org/S12.html#Types_and_Subtypes">子集</a>  - 强制动态（运行时）类型检查和调用解析它可能匹配的任何调用。这比编译时更慢，或者至少晚一些。</p>
<p>方法调用通常尽可能晚地解析（在运行时动态），而 sub 调用通常在编译时静态解析。</p>
<h2 id="选择更好的算法httpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">选择更好的算法</a></h2>
<p>无论语言或编译器如何，提高性能的最可靠技术之一是选择更合适的算法。</p>
<p>一个典型的例子是 <a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm">Boyer-Moore</a>。要匹配大字符串中的小字符串，一个明显的方法是比较两个字符串的第一个字符然后，如果它们匹配，则比较第二个字符，或者，如果它们不匹配，则比较第一个字符大字符串中第二个字符的小字符串的字符，依此类推。相反，Boyer-Moore 算法首先将小字符串的 <em>last</em> 字符与大字符串中相应定位的字符进行比较。对于大多数字符串，Boyer-Moore 算法在算法上接近 N 倍，其中 N 是小字符串的长度。</p>
<p>接下来的几节讨论了算法改进的两大类，这些类别在 Raku 中特别容易实现。有关这个一般主题的更多信息，请阅读有关<a href="https://en.wikipedia.org/wiki/Algorithmic_efficiency">算法效率</a>的维基百科页面，尤其是接近结尾的“另请参阅”部分。</p>
<h3 id="将顺序阻塞代码更改为并行非阻塞httpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">将顺序/阻塞代码更改为并行/非阻塞</a></h3>
<p>这是另一个非常重要的算法改进类。</p>
<p>查看幻灯片 <a href="https://jnthn.net/papers/2015-yapcasia-concurrency.pdf#page=17">Raku 中的并行、并发和异步</a> 和 <a href="https://www.youtube.com/watch?v=JpqnNCx7wVY&amp;list=PLRuESFRW2Fa77XObvk7-BYVFwobZHdXdK&amp;index=8">对应的视频</a>。</p>
<h2 id="使用已有的高性能代码httpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">使用已有的高性能代码</a></h2>
<p>您可以在 Raku 中使用大量高性能 C 库，而 <a href="https://docs.raku.org/language/nativecall">NativeCall</a> 可以轻松地为它们创建包装器。还有对 C++ 库的实验性支持。</p>
<p>如果要<a href="https://stackoverflow.com/a/27206428/1077672">在 Raku 中使用 Perl 5 模块</a>，请混合使用 Raku 类型和<a href="https://docs.raku.org/language/mop">元对象协议</a>。</p>
<p>更一般地说，Raku 旨在与其他语言平滑地互操作，并且有许多模块<a href="https://modules.raku.org/#q=inline">旨在促进使用来自其他语言的库</a>。</p>
<h2 id="让-rakudo-编译器生成更快的代码httpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">让 Rakudo 编译器生成更快的代码</a></h2>
<p>到目前为止，编译器的重点是正确性，而不是它生成代码的速度有多快，或者生成的代码运行速度有多快。但是预计会发生变化，最终&hellip;&hellip;你可以在 freenode IRC 频道#raku 和 #moarvm 上与编译器开发人员讨论预期的内容。更好的是，你可以自己贡献代码：</p>
<ul>
<li>Rakudo 主要用 Raku 编写。因此，如果您可以编写 Raku，那么您可以破解编译器，包括优化任何影响代码速度的大量现有高级代码（以及其他所有代码）。</li>
<li>大多数编译器的其余部分都是用一种名为 <a href="https://github.com/raku/nqp">NQP</a> 的小语言编写的，它基本上是 Raku 的一个子集。如果你可以编写 Raku，你也可以很容易地学会使用和改进中级 NQP 代码，至少从一种纯粹的语言观点。要深入了解 NQP 和 Rakudo 的内涵，请从 <a href="https://edumentab.github.io/rakudo-and-nqp-internals-course/">NQP 和内部课程</a>开始。</li>
<li>如果低级别的 C 黑客是你的乐趣，请查看 <a href="https://moarvm.org/">MoarVM</a> 并访问 freenode IRC 频道 #moarvm（<a href="https://colabti.org/irclogger/irclogger_logs/moarvm">日志</a>）。</li>
</ul>
<h2 id="仍然需要更多想法httpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">仍然需要更多想法?</a></h2>
<p>此页面中尚未涵盖的一些已知当前 Rakudo 性能缺陷包括使用 <code>gather/take</code>，<code>junctions</code>，正则表达式和字符串处理。</p>
<p>如果您认为某个主题需要在此页面上进行更多报道，请提交 PR 或告诉某人您的想法。谢谢。 :)</p>
<h1 id="没有得到你需要想要的结果httpsdocsrakuorglanguageperformance___top"><a href="https://docs.raku.org/language/performance#___top">没有得到你需要/想要的结果?</a></h1>
<p>如果您已尝试此页面上的所有内容无效，请考虑使用 #raku 上的编译器开发人员进行讨论，以便我们可以从您的用例中了解到目前为止您已经发现的内容。</p>
<p>一旦开发人员知道您的困境，请留出足够的时间做出明智的回应（几天或几周，具体取决于问题的确切性质和潜在的解决方案）。</p>
<p>如果还没有成功，请考虑在继续之前提交有关您在我们的<a href="https://github.com/raku/user-experience/issues">用户体验</a>仓库中的体验的问题。</p>
<p>谢谢。 :)</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[包]]></title>
            <link href="http://localhost:1313/rakulang/55.packages/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/working-with-complex-data-formats-with-structured-streaming-in-apache-spark-2-1/?utm_source=atom_feed" rel="related" type="text/html" title="在结构化流中使用复杂数据格式" />
                <link href="http://localhost:1313/notes/cassandra-sink-for-spark-structured-streaming/?utm_source=atom_feed" rel="related" type="text/html" title="用于 Spark 结构化流的 Cassandra 接收器" />
                <link href="http://localhost:1313/rakulang/54.operators/?utm_source=atom_feed" rel="related" type="text/html" title="操作符" />
                <link href="http://localhost:1313/rakulang/53.object-orientation/?utm_source=atom_feed" rel="related" type="text/html" title="面向对象" />
                <link href="http://localhost:1313/rakulang/52.numerics/?utm_source=atom_feed" rel="related" type="text/html" title="数值" />
            
                <id>http://localhost:1313/rakulang/55.packages/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-30T21:13:31+08:00</published>
            <updated>2018-11-30T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>
<p>Packages - Organizing and referencing namespaced program elements</p>
</blockquote>
<p>包是指定程序元素的嵌套命名空间。 模块，类，Grammar是包类型。 像目录中的文件一样，通常可以使用其短名称（如果它们是本地的）或使用较长的名称来消除歧义的引用具名元素。</p>
<h2 id="names">Names</h2>
<p>名称是作为变量名称的合法部分的任何东西（不包括sigil符号）。 这包括：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$foo</span>                <span class="c1"># 简单标识符</span>
</span></span><span class="line"><span class="cl"><span class="nv">$Foo::Bar::baz</span>      <span class="c1"># 通过 :: 分割的组合标识符</span>
</span></span><span class="line"><span class="cl"><span class="nv">$Foo::</span><span class="p">(</span><span class="nv">$bar</span><span class="p">)</span><span class="o">:</span><span class="p">:</span><span class="s">baz</span>   <span class="c1"># 执行插值的组合标识符</span>
</span></span><span class="line"><span class="cl"><span class="nv">$42</span>                 <span class="c1"># numeric names</span>
</span></span><span class="line"><span class="cl"><span class="nv">$!</span>                  <span class="c1"># 某些标点符号变量</span>
</span></span></code></pre></div><p><code>::</code> 用于分割嵌套的包名。</p>
<h3 id="包限定名">包限定名</h3>
<p>普通的包限定名像这样:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$Foo::Bar::baz</span>  <span class="c1"># 包 Foo::Bar 中的 $baz 变量</span>
</span></span></code></pre></div><p>有时保持sigil与变量名很清晰，所以来写这个的一个替代方式是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">Foo::Bar::</span><span class="p">&lt;</span><span class="s">$baz</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>这在编译时解决，因为变量名是一个常量。</p>
<p>如果 <code>::</code> 之前的名称部分为 null，则意味着包未指定并且必须搜索。 一般来说，这意味着跟在主sigil后面的初始 <code>::</code> 是对编译时已知的名字的无操作(no-op)，但 <code>::()</code> 也可以用来引入插值。 另外，在没有另一个sigil的情况下，<code>::</code> 可以作为它自己的sigil，表明有意使用一个尚未声明的包名。</p>
<h2 id="伪包">伪包</h2>
<p>在名称前面保留以下伪包名称：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">MY</span>          <span class="c1"># 当前词法作用域中的符号 (aka $?SCOPE)</span>
</span></span><span class="line"><span class="cl"><span class="n">OUR</span>         <span class="c1"># 当前包中的符号 (aka $?PACKAGE)</span>
</span></span><span class="line"><span class="cl"><span class="n">CORE</span>        <span class="c1"># 最外层词法作用域, 定义标准 Perl</span>
</span></span><span class="line"><span class="cl"><span class="n">GLOBAL</span>      <span class="c1"># Interpreter-wide package symbols, really UNIT::GLOBAL</span>
</span></span><span class="line"><span class="cl"><span class="n">PROCESS</span>     <span class="c1"># 进程相关的全局变量 (superglobals)</span>
</span></span><span class="line"><span class="cl"><span class="n">COMPILING</span>   <span class="c1"># 正在编译的作用域中的词法符号</span>
</span></span></code></pre></div><p>以下相对名称也保留，但可以在名称中的任何位置使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">CALLER</span>      <span class="c1"># Contextual symbols in the immediate caller&#39;s lexical scope</span>
</span></span><span class="line"><span class="cl"><span class="n">CALLERS</span>     <span class="c1"># Contextual symbols in any caller&#39;s lexical scope</span>
</span></span><span class="line"><span class="cl"><span class="n">DYNAMIC</span>     <span class="c1"># Contextual symbols in my or any caller&#39;s lexical scope</span>
</span></span><span class="line"><span class="cl"><span class="n">OUTER</span>       <span class="c1"># Symbols in the next outer lexical scope</span>
</span></span><span class="line"><span class="cl"><span class="n">OUTERS</span>      <span class="c1"># Symbols in any outer lexical scope</span>
</span></span><span class="line"><span class="cl"><span class="n">LEXICAL</span>     <span class="c1"># Contextual symbols in my or any outer&#39;s lexical scope</span>
</span></span><span class="line"><span class="cl"><span class="n">UNIT</span>        <span class="c1"># Symbols in the outermost lexical scope of compilation unit</span>
</span></span><span class="line"><span class="cl"><span class="n">SETTING</span>     <span class="c1"># Lexical symbols in the unit&#39;s DSL (usually CORE)</span>
</span></span><span class="line"><span class="cl"><span class="n">PARENT</span>      <span class="c1"># Symbols in this package&#39;s parent package (or lexical scope)</span>
</span></span><span class="line"><span class="cl"><span class="n">CLIENT</span>      <span class="c1"># The nearest CALLER that comes from a different package</span>
</span></span></code></pre></div><p>文件的作用域称为 <code>UNIT</code>，但在对应于语言设置的外面有一个或多个词法作用域（其他文化中通常称为序幕）。 因此，<code>SETTING</code> 作用域等价于 <code>UNIT::OUTERS</code>。 对于标准的Perl程序，<code>SETTING</code> 与 <code>CORE</code> 相同，但是各种启动选项（如 <code>-n</code> 或 <code>-p</code>）可以使您进入特定领域语言，在这种情况下，<code>CORE</code> 仍然是标准语言的作用域，而 <code>SETTING</code> 表示定义用作当前文件的设置的DSL的作用域。 当作为名称中间的搜索项使用时，SETTING包括其所有外部作用域，直到 <code>CORE</code>。 要仅获取设置的最外层作用域，请改用 <code>UNIT::OUTER</code>。</p>
<h2 id="查找名字">查找名字</h2>
<h3 id="插值到名字中">插值到名字中</h3>
<p>您可以使用 <code>::($expr)</code> 将字符串插入到包或变量名中，<code>$expr</code> 表达式中通常放置包或变量名。 该字符串允许包含额外的 <code>::</code> 实例，这将被解释为包嵌套。 您只能内插整个名称，因为结构以 <code>::</code> 开头，并且立即结束或用括号之外的另一个 <code>::</code> 继续。 大多数符号引用使用这种记法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$foo</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Bar</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$foobar</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Foo::Bar</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$::</span><span class="p">(</span><span class="nv">$foo</span><span class="p">)</span>           <span class="c1"># lexically-scoped $Bar</span>
</span></span><span class="line"><span class="cl"><span class="nv">$::</span><span class="p">(&#34;</span><span class="s2">MY::</span><span class="nv">$foo</span><span class="p">&#34;)</span>     <span class="c1"># lexically-scoped $Bar</span>
</span></span><span class="line"><span class="cl"><span class="nv">$::</span><span class="p">(&#34;</span><span class="s2">OUR::</span><span class="nv">$foo</span><span class="p">&#34;)</span>    <span class="c1"># package-scoped $Bar</span>
</span></span><span class="line"><span class="cl"><span class="nv">$::</span><span class="p">(&#34;</span><span class="s2">GLOBAL::</span><span class="nv">$foo</span><span class="p">&#34;)</span> <span class="c1"># global $Bar</span>
</span></span><span class="line"><span class="cl"><span class="nv">$::</span><span class="p">(&#34;</span><span class="s2">PROCESS::</span><span class="nv">$foo</span><span class="p">&#34;)</span><span class="c1"># process $Bar</span>
</span></span><span class="line"><span class="cl"><span class="nv">$::</span><span class="p">(&#34;</span><span class="s2">PARENT::</span><span class="nv">$foo</span><span class="p">&#34;)</span> <span class="c1"># current package&#39;s parent&#39;s $Bar</span>
</span></span><span class="line"><span class="cl"><span class="nv">$::</span><span class="p">(</span><span class="nv">$foobar</span><span class="p">)</span>        <span class="c1"># $Foo::Bar</span>
</span></span><span class="line"><span class="cl"><span class="nv">$::</span><span class="p">(</span><span class="nv">$foobar</span><span class="p">)</span><span class="o">:</span><span class="p">:</span><span class="s">baz</span>   <span class="c1"># $Foo::Bar::baz</span>
</span></span><span class="line"><span class="cl"><span class="nv">$::</span><span class="p">(</span><span class="nv">$foo</span><span class="p">)</span><span class="o">:</span><span class="p">:</span><span class="s">Bar</span><span class="o">:</span><span class="p">:</span><span class="s">baz</span> <span class="c1"># $Bar::Bar::baz</span>
</span></span><span class="line"><span class="cl"><span class="nv">$::</span><span class="p">(</span><span class="nv">$foobar</span><span class="p">)</span><span class="n">baz</span>     <span class="c1"># ILLEGAL at compile time (no operator baz)</span>
</span></span></code></pre></div><p>初始 <code>::</code> 不表明全局。 这里作为插值语法的一部分，它甚至不暗示包。 <code>::()</code> 组件插值之后，间接名称被查找，就像它在原始源代码中一样，优先级首先指定为前导伪包名称，然后指向词法作用域中的名称（搜索 向外扩展，以<code>CORE</code>结束）。 最后搜索当前包。</p>
<p>使用 <code>MY</code> 伪包将查找限制为当前词法作用域，<code>OUR</code> 将作用域限制为当前包作用域。</p>
<h3 id="直接查找">直接查找</h3>
<p>要在包的符号表中直接查找而不进行扫描，请将包名视为哈希：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">Foo::Bar::</span><span class="p">{&#39;</span><span class="s1">&amp;baz</span><span class="p">&#39;}</span>  <span class="c1"># same as &amp;Foo::Bar::baz</span>
</span></span><span class="line"><span class="cl"><span class="n">PROCESS::</span><span class="p">&lt;</span><span class="s">$IN</span><span class="p">&gt;</span>      <span class="c1"># Same as $*IN</span>
</span></span><span class="line"><span class="cl"><span class="n">Foo::</span><span class="p">&lt;</span><span class="s">::Bar</span><span class="p">&gt;&lt;</span><span class="s">::Baz</span><span class="p">&gt;</span> <span class="c1"># same as Foo::Bar::Baz</span>
</span></span></code></pre></div><p>不像 <code>::()</code> 符号引用，这不解析<code>::</code>的参数，也不从该初始点启动命名空间扫描。 此外，对于常量下标，保证在编译时解析符号。</p>
<p>空伪包是与普通名称搜索有相同的搜索列表。 也就是说，以下各项在意义上是相同的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$foo</span>
</span></span><span class="line"><span class="cl"><span class="nv">$::</span><span class="p">{&#39;</span><span class="s1">foo</span><span class="p">&#39;}</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="p">{&#39;</span><span class="s1">$foo</span><span class="p">&#39;}</span>
</span></span><span class="line"><span class="cl"><span class="nv">$::</span><span class="p">&lt;</span><span class="s">foo</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="p">&lt;</span><span class="s">$foo</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>它们中的每一个都向外扫描词法作用域，然后扫描当前的包作用域（虽然当“strict”有效时包作用域被禁止，）。</p>
<p>作为这些规则的结果，您可以把变量名写的很随意：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$::</span><span class="p">{&#39;</span><span class="s1">!@#$#@</span><span class="p">&#39;}</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="p">{&#39;</span><span class="s1">$!@#$#@</span><span class="p">&#39;}</span>
</span></span></code></pre></div><p>只要名字中没有空格, 您也可以使用 <code>::&lt;&gt;</code> 形式。</p>
<h3 id="包查找">包查找</h3>
<p>将包对象本身下标为哈希对象，其键是变量名，包括任何sigil。 包对象可以通过使用 <code>::</code> 后缀从类型名中派生：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">MyType::</span><span class="p">&lt;</span><span class="s">$foo</span><span class="p">&gt;</span>
</span></span></code></pre></div><h2 id="全局">全局</h2>
<p>解释器全局变量存在于 <code>GLOBAL</code> 包中。 用户程序在 <code>GLOBAL</code> 包中启动，因此默认情况下，主线代码中的“our”声明会进入该包。 进程范围的变量存在于 <code>PROCESS</code>包中。 大多数预定义的全局变量，例如 <code>$*UID</code> 和 <code>$*PID</code> 实际上是进程全局变量。</p>
<h2 id="版本">版本</h2>
<p>任何包都可以有一个 <a href="https://docs.raku.org/type/Version">Version</a> 对象。 这个对象可以通过 <code>$PACKAGE.^ver</code> 或从包 <code>Fully::Qualified::Name.^ver</code> 外部访问。</p>
<p><a href="https://docs.raku.org/language/packages">Packages</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[操作符]]></title>
            <link href="http://localhost:1313/rakulang/54.operators/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/53.object-orientation/?utm_source=atom_feed" rel="related" type="text/html" title="面向对象" />
                <link href="http://localhost:1313/rakulang/52.numerics/?utm_source=atom_feed" rel="related" type="text/html" title="数值" />
                <link href="http://localhost:1313/notes/a-tour-of-spark-structured-streaming/?utm_source=atom_feed" rel="related" type="text/html" title="Spark 结构化流之旅" />
                <link href="http://localhost:1313/notes/write-parquet-to-kafka/?utm_source=atom_feed" rel="related" type="text/html" title="读取 Parquet 并写回 Kafka" />
                <link href="http://localhost:1313/rakulang/51.newline-handling-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的换行处理" />
            
                <id>http://localhost:1313/rakulang/54.operators/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-29T21:13:31+08:00</published>
            <updated>2018-11-29T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h2 id="操作符httpsdocsrakuorglanguageoperators"><a href="https://docs.raku.org/language/operators">操作符</a></h2>
<h3 id="操作符优先级">操作符优先级</h3>
<p>在像 <code>1 + 2 * 3</code> 这样的表达式中， <code>2 * 3</code> 被首先计算， 因为中缀操作符  <code>*</code> 的优先级比 <code>+</code> 的优先级高。下面的表中总结了 Perl  6 中  的优先级级别， 从最牢固到最松散：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">A</span>	<span class="n">Level</span>	           <span class="n">Examples</span>
</span></span><span class="line"><span class="cl"><span class="n">N</span>	<span class="n">Terms</span>	           <span class="mi">42</span> <span class="mf">3.14</span> <span class="p">&#34;</span><span class="s2">eek</span><span class="p">&#34;</span> <span class="k">qq</span><span class="p">[</span><span class="s2">&#34;foo&#34;</span><span class="p">]</span> <span class="nv">$x</span> <span class="p">:</span><span class="o">!</span><span class="s">verbose</span> <span class="nv">@$array</span>
</span></span><span class="line"><span class="cl"><span class="n">L</span>	<span class="n">方法后缀</span>	        <span class="o">.</span><span class="nf">meth</span> <span class="o">.+</span> <span class="o">.?</span> <span class="o">.*</span> <span class="o">.</span><span class="p">()</span> <span class="o">.[]</span> <span class="o">.</span><span class="p">{}</span> <span class="o">.&lt;&gt;</span> <span class="o">.</span><span class="p">«»</span> <span class="o">.::</span> <span class="o">.=</span> <span class="o">.^</span> <span class="o">.:</span>
</span></span><span class="line"><span class="cl"><span class="n">N</span>	<span class="n">自增</span>	              <span class="o">++</span> <span class="o">--</span>
</span></span><span class="line"><span class="cl"><span class="ow">R</span>	<span class="n">求幂</span>	              <span class="o">**</span>
</span></span><span class="line"><span class="cl"><span class="n">L</span>	<span class="n">Symbolic</span> <span class="n">unary</span>	   <span class="o">!</span> <span class="o">+</span> <span class="o">-</span> <span class="o">~</span> <span class="o">?</span> <span class="o">|</span> <span class="o">||</span> <span class="o">+^</span> <span class="o">~^</span> <span class="o">?^</span> <span class="o">^</span>
</span></span><span class="line"><span class="cl"><span class="n">L</span>	<span class="n">乘法</span>	              <span class="o">*</span> <span class="o">/</span> <span class="nv">%</span> <span class="nv">%%</span> <span class="o">+&amp;</span> <span class="o">+&lt;</span> <span class="o">+&gt;</span> <span class="o">~&amp;</span> <span class="o">~&lt;</span> <span class="o">~&gt;</span> <span class="o">?&amp;</span> <span class="ow">div</span> <span class="ow">mod</span> <span class="ow">gcd</span> <span class="ow">lcm</span>
</span></span><span class="line"><span class="cl"><span class="n">L</span>	<span class="n">加法</span>	              <span class="o">+</span> <span class="o">-</span> <span class="o">+|</span> <span class="o">+^</span> <span class="o">~|</span> <span class="o">~^</span> <span class="o">?|</span> <span class="o">?^</span>
</span></span><span class="line"><span class="cl"><span class="n">L</span>	<span class="n">重复</span>	              <span class="nb">x</span> <span class="ow">xx</span>
</span></span><span class="line"><span class="cl"><span class="ow">X</span>	<span class="n">连结</span>                <span class="o">~</span>
</span></span><span class="line"><span class="cl"><span class="ow">X</span>	<span class="n">Junctive</span> <span class="ow">and</span>	   <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="ow">X</span>	<span class="n">Junctive</span> <span class="ow">or</span>	       <span class="o">|</span> <span class="o">^</span>
</span></span><span class="line"><span class="cl"><span class="n">L</span>	<span class="n">Named</span> <span class="n">unary</span>	       <span class="k">temp</span> <span class="k">let</span>
</span></span><span class="line"><span class="cl"><span class="n">N</span>	<span class="n">Structural</span> <span class="nb">infix</span>   <span class="k">but</span> <span class="k">does</span> <span class="o">&lt;=&gt;</span> <span class="ow">leg</span> <span class="ow">cmp</span> <span class="o">..</span> <span class="o">..^</span> <span class="o">^..</span> <span class="o">^..^</span>
</span></span><span class="line"><span class="cl"><span class="n">C</span>	<span class="n">Chaining</span> <span class="nb">infix</span>	   <span class="o">!=</span> <span class="o">==</span> <span class="o">&lt;</span> <span class="p">&lt;</span><span class="s">= </span><span class="p">&gt;</span> <span class="o">&gt;=</span> <span class="ow">eq</span> <span class="ow">ne</span> <span class="ow">lt</span> <span class="ow">le</span> <span class="ow">gt</span> <span class="ow">ge</span> <span class="o">~~</span> <span class="o">===</span> <span class="ow">eqv</span> <span class="o">!</span><span class="ow">eqv</span>
</span></span><span class="line"><span class="cl"><span class="ow">X</span>	<span class="n">Tight</span> <span class="ow">and</span>	       <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl"><span class="ow">X</span>	<span class="n">Tight</span> <span class="ow">or</span>	       <span class="o">||</span> <span class="o">^^</span> <span class="o">//</span> <span class="nb">min</span> <span class="nb">max</span>
</span></span><span class="line"><span class="cl"><span class="ow">R</span>	<span class="n">Conditional</span>	       <span class="o">??</span> <span class="o">!!</span> <span class="ow">ff</span> <span class="ow">fff</span>
</span></span><span class="line"><span class="cl"><span class="ow">R</span>	<span class="n">Item</span> <span class="n">assignment</span>	   <span class="o">=</span> <span class="o">=&gt;</span> <span class="o">+=</span> <span class="o">-=</span> <span class="o">**=</span> <span class="ow">xx</span><span class="o">=</span> <span class="o">.=</span>
</span></span><span class="line"><span class="cl"><span class="n">L</span>	<span class="n">Loose</span> <span class="n">unary</span>	       <span class="nb">so</span> <span class="nb">not</span>
</span></span><span class="line"><span class="cl"><span class="ow">X</span>	<span class="n">Comma</span> <span class="n">operator</span>	   <span class="o">,</span> <span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="ow">X</span>	<span class="kt">List</span> <span class="nb">infix</span>	       <span class="ow">Z</span> <span class="nb">minmax</span> <span class="ow">X</span> <span class="ow">X</span><span class="o">~</span> <span class="ow">X</span><span class="o">*</span> <span class="n">Xeqv</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="ow">R</span>	<span class="kt">List</span> <span class="nb">prefix</span>	       <span class="nb">print</span> <span class="nb">push</span> <span class="nb">say</span> <span class="nb">die</span> <span class="nb">map</span> <span class="nb">substr</span> <span class="o">...</span> <span class="o">[+]</span> <span class="o">[*]</span> <span class="nb">any</span> <span class="ow">Z</span><span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="ow">X</span>	<span class="n">Loose</span> <span class="ow">and</span>	       <span class="ow">and</span> <span class="ow">andthen</span>
</span></span><span class="line"><span class="cl"><span class="ow">X</span>	<span class="n">Loose</span> <span class="ow">or</span>	       <span class="ow">or</span> <span class="ow">xor</span> <span class="ow">orelse</span>
</span></span><span class="line"><span class="cl"><span class="ow">X</span>	<span class="n">Sequencer</span>	       <span class="p">&lt;</span><span class="s">==, ==</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&lt;&lt;</span><span class="s2">==, ==</span><span class="p">&gt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">N</span>	<span class="n">Terminator</span>	       <span class="p">;</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="o">,</span> <span class="k">unless</span><span class="o">,</span> <span class="ow">extra</span> <span class="p">)</span><span class="err">, ], }
</span></span></span></code></pre></div><p>下面使用的两处 <code>!</code> 符号一般代表任何一对儿拥有相同优先级的操作符， 上表指定的二元操作符的结合性解释如下(其中 A 代表结合性， associativities )：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">A</span>	<span class="n">Assoc</span>	<span class="n">Meaning</span> <span class="k">of</span> <span class="nv">$a</span> <span class="o">!</span> <span class="nv">$b</span> <span class="o">!</span> <span class="nv">$c</span>
</span></span><span class="line"><span class="cl"><span class="n">L</span>	<span class="n">left</span>	<span class="p">(</span><span class="nv">$a</span> <span class="o">!</span> <span class="nv">$b</span><span class="p">)</span> <span class="o">!</span> <span class="nv">$c</span>
</span></span><span class="line"><span class="cl"><span class="ow">R</span>	<span class="nb">right</span>	<span class="nv">$a</span> <span class="o">!</span> <span class="p">(</span><span class="nv">$b</span> <span class="o">!</span> <span class="nv">$c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">N</span>	<span class="n">non</span>	    <span class="n">ILLEGAL</span>
</span></span><span class="line"><span class="cl"><span class="n">C</span>	<span class="n">chain</span>	<span class="p">(</span><span class="nv">$a</span> <span class="o">!</span> <span class="nv">$b</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nv">$b</span> <span class="o">!</span> <span class="nv">$c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="ow">X</span>	<span class="nb">list</span>	<span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="p">;</span> <span class="nv">$b</span><span class="p">;</span> <span class="nv">$</span><span class="p">)</span>
</span></span></code></pre></div><p>对于一元操作符， 这解释为:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">A</span>	<span class="n">Assoc</span>	<span class="n">Meaning</span> <span class="k">of</span> <span class="o">!</span><span class="nv">$a</span><span class="o">!</span>
</span></span><span class="line"><span class="cl"><span class="n">L</span>	<span class="n">left</span>	<span class="p">(</span><span class="o">!</span><span class="nv">$a</span><span class="p">)</span><span class="o">!</span>
</span></span><span class="line"><span class="cl"><span class="ow">R</span>	<span class="nb">right</span>	<span class="o">!</span><span class="p">(</span><span class="nv">$a</span><span class="o">!</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">N</span>	<span class="n">non</span>	    <span class="n">ILLEGAL</span>
</span></span></code></pre></div><p>下面描述的操作符， 默认假定为 left 结合性。</p>
<h3 id="操作符种类">操作符种类</h3>
<p>操作符能出现在相对于 term 的几个位置处：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">+</span><span class="nb">term</span>	        <span class="nb">prefix</span>         <span class="p">(</span><span class="n">后缀</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">term1</span> <span class="o">+</span> <span class="n">term2</span>	<span class="nb">infix</span>          <span class="p">(</span><span class="n">中缀</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">term</span><span class="o">++</span>	        <span class="nb">postfix</span>        <span class="p">(</span><span class="n">后缀</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">term</span><span class="p">)</span>	        <span class="n">circumfix</span>      <span class="p">(</span><span class="n">环缀</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">term1</span><span class="o">[</span><span class="n">term2</span><span class="o">]</span>	<span class="n">postcircumfix</span>  <span class="p">(</span><span class="n">后环缀</span><span class="p">)</span>
</span></span></code></pre></div><p>每个操作符也可以用作子例程。 这样的子例程的名字由操作符的种类， 然后后跟一个冒号，再加上一组引号结构， 引号结构中是组成操作符的符号(s):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span>                           <span class="c1"># same as 1 + 2</span>
</span></span><span class="line"><span class="cl"><span class="n">circumfix:</span><span class="p">«</span><span class="s2">( )</span><span class="p">»(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;)</span>            <span class="c1"># same as (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), 目前编译错误。</span>
</span></span><span class="line"><span class="cl"><span class="n">circumfix:</span><span class="p">&lt;</span><span class="s">[ ]</span><span class="p">&gt;(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">perl</span><span class="o">.</span><span class="nb">say</span>   <span class="c1"># [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]</span>
</span></span></code></pre></div><p>作为一种特殊情况， listop(列表操作符)既能作为 term 又能作为前缀。子例程调用是最常见的列表操作符。其它情况包括元运算中缀操作符 <code>[+]| 1, 2, 3</code> 和 <code>prefix</code> 等 stub 操作符。</p>
<p>定义自定义操作符在 <a href="http://doc.raku.org/language/functions#Defining_Operators"> /language/functions#Defining_Operators.</a>  中有涉及。</p>
<h3 id="term-优先级">Term 优先级</h3>
<p>Term 怎么翻译才合适？ 我觉得翻译成 <code>项</code> 更合适， 表明这是一个名词。</p>
<h4 id="环缀--">环缀 &lt; &gt;</h4>
<p>引起单词的结构。以空白隔开内容， 并返回一个单词的 <code>Parcel</code>。 如果单词看起来像数字字面量或 <code>Pair</code> 字面量， 那么它会被转为合适的数字。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>  <span class="c1"># b</span>
</span></span></code></pre></div><p>(Rakudo 当前总是返回一块儿字符串)。</p>
<h3 id="环缀---1">环缀 ( )</h3>
<p>分组操作符。</p>
<p>空的分组 <code>()</code> 创建一个空的 <code>Pracel</code>。 非空表达式周围的圆括号只是构建了表达式， 而没有额外的语义。</p>
<p>在参数列表中，在参数周围放上圆括号防止了参数被解释为具名参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">p</span><span class="p">(</span><span class="o">:</span><span class="nv">$a</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">named</span><span class="p">&#39;</span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">p</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span>   <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">positional</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">;</span>       <span class="c1"># named</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span> <span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">);</span>     <span class="c1"># positional</span>
</span></span></code></pre></div><h3 id="环缀---2">环缀 { }</h3>
<p>Block 或 散列构造器。</p>
<p>如果<code>{}</code> 里面的内容看起来像一组 pairs 并且没有 <code>$_</code> 或其它占位符参数，就返回一个散列， 这个散列由逐项逐项的 pair 组成。</p>
<p>否则就返回一个 Block。</p>
<p>注意，这个结构没有重新解析内容； 而里面的内容总是被解析为一组句子（例如，像一个 block）， 并且如果后面的分析表明它需要被解析成一个散列， 那么 block 就会被执行并强转为散列。</p>
<h3 id="环缀---3">环缀 [ ]</h3>
<p>数组构造器。在列表上下文中返回一个不会展平的 item 化的数组。</p>
<h2 id="方法后缀优先级">方法后缀优先级</h2>
<h3 id="后环缀--">后环缀 [ ]</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">postcircumfix:</span><span class="p">&lt;</span><span class="s">[ ]</span><span class="p">&gt;(</span><span class="nv">@container</span><span class="o">,</span> <span class="o">**</span><span class="nv">@index</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                        <span class="o">:</span><span class="nv">$k</span><span class="o">,</span> <span class="o">:</span><span class="nv">$v</span><span class="o">,</span> <span class="o">:</span><span class="nv">$kv</span><span class="o">,</span> <span class="o">:</span><span class="nv">$p</span><span class="o">,</span> <span class="o">:</span><span class="nv">$exists</span><span class="o">,</span> <span class="o">:</span><span class="nv">$delete</span><span class="p">)</span>
</span></span></code></pre></div><p><code>:$k</code> 会创建一个 pair， 它是散列中的一个条目。 键是 <code>k</code>， 键值为 <code>$kv</code>。 所以， <code>$k</code> 等价于 <code>k</code> =&gt; <code>$k</code></p>
<p>访问 <code>@container</code>  中的一个或多个元素，即数组索引操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@alphabet</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">..</span> <span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>                   <span class="c1">#-&gt; a</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>                   <span class="c1">#-&gt; b</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>                 <span class="c1">#-&gt; z</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">100</span><span class="o">]</span><span class="p">:</span><span class="s">exists</span><span class="p">;</span>          <span class="c1">#-&gt; False</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">15</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">17</span><span class="o">,</span> <span class="mi">11</span><span class="o">].</span><span class="nb">join</span><span class="p">;</span>  <span class="c1">#-&gt; perl</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">23</span> <span class="o">..</span> <span class="o">*].</span><span class="nb">perl</span><span class="p">;</span>        <span class="c1">#-&gt; (&#34;x&#34;, &#34;y&#34;, &#34;z&#34;)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">@alphabet</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">B</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">C</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">3</span><span class="o">].</span><span class="nb">perl</span>            <span class="c1">#-&gt; (&#34;a&#34;, &#34;B&#34;, &#34;C&#34;, &#34;d&#34;)</span>
</span></span></code></pre></div><p>查看 <a href="http://doc.raku.org/language/subscripts">Subscripts</a> 获取关于该操作符行为的更详细的解释， 还有怎么在自定义类型中实现对它的支持。</p>
<h3 id="后环缀---1">后环缀 { }</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">postcircumfix:</span><span class="p">&lt;</span><span class="s">{ }</span><span class="p">&gt;(</span><span class="nv">%container</span><span class="o">,</span> <span class="o">**</span><span class="nv">@key</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                        <span class="o">:</span><span class="nv">$k</span><span class="o">,</span> <span class="o">:</span><span class="nv">$v</span><span class="o">,</span> <span class="o">:</span><span class="nv">$kv</span><span class="o">,</span> <span class="o">:</span><span class="nv">$p</span><span class="o">,</span> <span class="o">:</span><span class="nv">$exists</span><span class="o">,</span> <span class="o">:</span><span class="nv">$delete</span><span class="p">)</span>
</span></span></code></pre></div><p>访问 <code>%container</code> 的一个或多个元素， 即散列索引操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span>  <span class="nv">%color</span> <span class="o">=</span> <span class="s">kiwi</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">banana</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">yellow</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">cherry</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">red</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">banana</span><span class="p">&#34;};</span>               <span class="c1">#-&gt; yellow</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">cherry</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">kiwi</span><span class="p">&#34;}</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>  <span class="c1">#-&gt; (&#34;red&#34;, &#34;green&#34;)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">strawberry</span><span class="p">&#34;}:</span><span class="s">exists</span><span class="p">;</span>    <span class="c1">#-&gt; False</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">banana</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">lime</span><span class="p">&#34;}</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">yellowish</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">cherry</span><span class="p">&#34;}:</span><span class="s">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%color</span><span class="p">;</span>  <span class="c1">#-&gt; banana =&gt; yellowish, kiwi =&gt; green, lime =&gt; green</span>
</span></span></code></pre></div><p>查看 <code>后环缀 &lt; &gt;</code> 和 <code>后环缀 « »</code> 作为便捷形式， 查看 <code>Subscripts</code> 获取这个操作符行为的更详细解释， 还有怎么在自定义类型中实现对它的支持。</p>
<h3 id="后环缀---2">后环缀 &lt; &gt;</h3>
<p><code>后环缀 { }</code> 的简写形式， 它会引起它的参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%color</span> <span class="o">=</span> <span class="s">kiwi</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">banana</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">yellow</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">cherry</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">red</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%color</span><span class="p">&lt;</span><span class="s">banana</span><span class="p">&gt;;</span>             <span class="c1">#-&gt; yellow</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%color</span><span class="p">&lt;</span><span class="s">cherry kiwi</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>   <span class="c1">#-&gt; (&#34;red&#34;, &#34;green&#34;)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%color</span><span class="p">&lt;</span><span class="s">strawberry</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span>  <span class="c1">#-&gt; False</span>
</span></span></code></pre></div><p>这不是一个真正的操作符， 它仅仅是一个在编译时把 <code>&lt; &gt;</code> 变成 <code>{}</code> 后环缀操作符的语法糖。</p>
<h3 id="后环缀---3">后环缀 « »</h3>
<p><code>后环缀 { }</code> 的简写形式。它会引起它的参数，并且 « » 中能进行变量插值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%color</span> <span class="o">=</span> <span class="s">kiwi</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">banana</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">yellow</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">cherry</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">red</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fruit</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">kiwi</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%color</span><span class="p">«</span><span class="s2">cherry </span><span class="nv">$fruit</span><span class="p">»</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>   <span class="c1">#-&gt; (&#34;red&#34;, &#34;green&#34;)</span>
</span></span></code></pre></div><p>这不是一个真正的操作符， 它仅仅是一个在编译时把 « » 变成 <code>{}</code> 后环缀操作符的语法糖。</p>
<h3 id="后环缀---4">后环缀 ( )</h3>
<p>调用操作符。把调用者当作 <code>Callable</code> 并引用它，它使用圆括号之间的表达式作为参数。</p>
<p>注意，标识符后面直接跟着一对儿圆括号总是被解析为子例程调用。</p>
<p>如果你想要你的对象响应该调用操作符， 你需要实现 <code>CALL-ME</code> 方法。</p>
<h3 id="postfix-">postfix .</h3>
<p>该操作符用于调用一个方法， <code>$invocant.method</code>。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--1">postfix .=</h3>
<p>可变的方法调用。 <code>$invocant.=method</code> ， 脱去语法糖后就是 <code>$invocant = $invocant.method</code> , 这与 <a href="http://doc.raku.org/routine/op%3D">op=.</a> 类似。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--2">postfix .^</h3>
<p>元方法调用。 <code> $invocant.^method</code> 在  <code>$invocant</code> 的元类身上调用方法。脱去语法糖后， 它就是 <code>$invocant.HOW.method($invocant, ...)</code> 。 查看 <a href="http://doc.raku.org/type/HOW">HOW</a> 获取更多信息。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--3">postfix .?</h3>
<p><code>有可能被调用</code>的方法调用。如果有名为 <code>method</code> 的方法，  <code>$invocant.?method</code> 就在 <code>$invocant</code> 上调用 <code>method</code> 方法。否则它就返回 <code>Nil</code>。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--4">postfix .+</h3>
<p><code>$invocant.+method </code> 从 <code>$invocant</code> 身上调用所有叫做 	<code>method</code> 的方法， 并返回一个 Parcel 作为结果。 如果没有找到这个名字的方法， 就会死掉。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--5">postfix .*</h3>
<p><code>$invocant.*method</code> <code>从</code>$invocant<code>身上调用所有叫做</code>method` 的方法， 并返回一个 Parcel 作为结果。 如果没有找到这个名字的方法，则返回一个空的 Parcel。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-postfix">postfix .postfix</h3>
<p>大多数情况下， 可以在后缀或后环缀前面放上一个点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">.[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="p">;</span> <span class="c1"># Same</span>
</span></span></code></pre></div><p>这对于视觉清晰或简洁很有帮助。例如，如果对象的属性是一个函数，在属性名后面放置一对儿圆括号会变成方法调用的一部分。 所以要么使用两对儿圆括号， 要么在圆括号前面放上一个点来阻止方法调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Operation</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.symbol</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">&amp;.function</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$addition</span> <span class="o">=</span> <span class="n">Operation</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">symbol</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">function</span><span class="p">{</span> <span class="nv">$^a</span> <span class="o">+</span> <span class="nv">$^b</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$addition</span><span class="o">.</span><span class="nf">function</span><span class="p">()(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1"># 3</span>
</span></span></code></pre></div><p>或者</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$addition</span><span class="o">.</span><span class="nf">function</span><span class="o">.</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1"># 3</span>
</span></span></code></pre></div><p>然而，如果后缀是一个标识符， 那么它会被解释为一个普通的方法调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">1</span><span class="o">.</span><span class="nf">i</span> <span class="c1"># No such method &#39;i&#39; for invocant of type &#39;Int&#39;</span>
</span></span></code></pre></div><p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-prefix">postfix .:<!-- raw HTML omitted --></h3>
<p>前缀能够像方法那样， 使用冒号对儿标记法来调用。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">++</span><span class="nv">$a</span><span class="p">;</span>     <span class="c1"># 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="o">.:</span><span class="p">&lt;</span><span class="s">++</span><span class="p">&gt;;</span> <span class="c1"># 3</span>
</span></span></code></pre></div><p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--6">postfix .::</h3>
<p>一个类限定的方法调用， 用于调用一个定义在父类或 role 中的方法， 甚至在子类中重新定义了之后。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Bar</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">baz</span> <span class="p">{</span> <span class="mi">42</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Foo</span> <span class="k">is</span> <span class="nc">Bar</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">baz</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">nope</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Foo</span><span class="o">.</span><span class="nf">Bar::baz</span><span class="p">;</span> <span class="c1"># 42</span>
</span></span></code></pre></div><h2 id="自增优先级">自增优先级</h2>
<h3 id="prefix-">prefix ++</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">++</span><span class="p">&gt;(</span><span class="nv">$x</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>把它的参数增加 1， 并返回增加后的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">++</span><span class="nv">$x</span><span class="p">;</span>    <span class="c1"># 4</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>      <span class="c1"># 4</span>
</span></span></code></pre></div><p>它的工作原理是在它的参数身上调用 <code>succ</code> 方法， 这可以让自定义类型自由地实现它们自己的增量语义。</p>
<h3 id="prefix---">prefix &ndash;</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">--</span><span class="p">&gt;(</span><span class="nv">$x</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>把它的参数减少 1， 并返回减少后的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">--</span><span class="nv">$x</span><span class="p">;</span>       <span class="c1"># 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># 2</span>
</span></span></code></pre></div><p>它的工作原理是在它的参数身上调用 <code>pred</code> 方法， 这可以让自定义类型自由地实现它们自己的减量语义。</p>
<h3 id="postfix--7">postfix ++</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">++</span><span class="p">&gt;(</span><span class="nv">$x</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>把它的参数增加 1， 并返回<code>unincremented</code>的那个值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>       <span class="c1"># 3</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># 4</span>
</span></span></code></pre></div><p>它的工作原理是在它的参数身上调用 <code>succ</code> 方法， 这可以让自定义类型自由地实现它们自己的增量语义。</p>
<p>注意这并不一定返回它的参数。 例如，对于未定义的值， 它返回 0:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>       <span class="c1"># 0</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># 1</span>
</span></span></code></pre></div><h3 id="postfix---">postfix &ndash;</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">--</span><span class="p">&gt;(</span><span class="nv">$x</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>把它的参数减少 1， 并返回<code>undecremented</code>的那个值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x--</span><span class="p">;</span>       <span class="c1"># 3</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># 2</span>
</span></span></code></pre></div><p>它的工作原理是在它的参数身上调用 <code>pred</code> 方法， 这可以让自定义类型自由地实现它们自己的减量语义。</p>
<p>注意这并不一定返回它的参数。 例如，对于未定义的值， 它返回 0:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x--</span><span class="p">;</span>       <span class="c1"># 0</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># -1</span>
</span></span></code></pre></div><h2 id="求幂优先级">求幂优先级</h2>
<h3 id="infix-">infix **</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">**</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Numeric:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">right</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>求幂操作符把它的两个参数都强制转为 <code>Numeric</code> , 然后计算，右侧为幂。</p>
<p>如果 <code>**</code> 右边是一个非负整数，并且左侧是任意精度类型(Int, FatRat)，那么计算不会损失精度。</p>
<h2 id="象形一元操作符的优先级">象形一元操作符的优先级</h2>
<h3 id="prefix--1">prefix ?</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">?</span><span class="p">&gt;(</span><span class="kt">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span>
</span></span></code></pre></div><p>布尔上下文操作符。</p>
<p>通过在参数身上调用 <code>Bool</code> 方法强制它的参数为 Bool。注意， 这会使 Junctions 失效。</p>
<h3 id="prefix--2">prefix !</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!</span><span class="p">&gt;(</span><span class="kt">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span>
</span></span></code></pre></div><p>否定的布尔上下文操作符。</p>
<p>通过在参数身上调用 <code>Bool</code> 方法强制它的参数为 Bool， 并返回结果的否定值。注意， 这会使 Junctions 失效。</p>
<h3 id="prefix--3">prefix +</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Numeric:D</span>
</span></span></code></pre></div><p>Numeric 上下文操作符。</p>
<p>通过在参数身上调用 Numeric 方法强制将参数转为 Numeric 类型。</p>
<h3 id="prefix--">prefix -</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">-</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Numeric:D</span>
</span></span></code></pre></div><p>否定的 Numeric 上下文操作符。</p>
<p>通过在参数身上调用 Numeric 方法强制将参数转为 Numeric 类型， 并返回结果的否定值。</p>
<h3 id="prefix--4">prefix ~</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">-</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Str:D</span>
</span></span></code></pre></div><p>字符串上下文操作符。</p>
<p>通过在参数身上调用 <code>Str</code> 方法强制把参数转为 <code>Str</code> 类型。</p>
<h3 id="prefix--5">prefix |</h3>
<p>将  Capture, Enum, Pair, List, Parcel, EnumMap 和 Hash 展平到参数列表中。</p>
<p>（在 Rakudo 中，这不是作为一个合适的操作符来实现的，而是编译器中的一种特殊情况， 这意味着它只对参数列表有效，而非在任意代码中都有效。）</p>
<h3 id="prefix--6">prefix +^</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+^</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Int:D</span>
</span></span></code></pre></div><p>Integer bitwise negation</p>
<p>整数按位取反。</p>
<p>将参数强转为 Int 类型并对结果按位取反， 假设两者互补。</p>
<h3 id="prefix--7">prefix ?^</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">?^</span><span class="p">&gt;(</span><span class="kt">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span>
</span></span></code></pre></div><p>布尔按位取反。</p>
<p>将参数强转为 Bool， 然后按位反转，这使它和 prefix:&lt;!&gt;  一样。</p>
<h3 id="prefix--8">prefix ^</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Range:D</span>
</span></span></code></pre></div><p>upto 操作符.</p>
<p>强制把它的参数转为 Numeric， 生成一个从 0 直到（但是排除） 参数为止的范围。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">^</span><span class="mi">5</span><span class="p">;</span>         <span class="c1"># 0..^5</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">^</span><span class="mi">5</span> <span class="p">{</span> <span class="p">}</span>      <span class="c1"># 5 iterations</span>
</span></span></code></pre></div><h2 id="乘法优先级">乘法优先级</h2>
<h3 id="infix--1">infix *</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">*</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Numeric:D</span>
</span></span></code></pre></div><p>把两边的参数都强转为 Numeric 并把它们相乘。 结果是一个更宽的类型。 查看 Numeric 获取更详细信息。</p>
<h3 id="infix--2">infix /</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">/</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Numeric:D</span>
</span></span></code></pre></div><p>把两边的参数都强制为 Numeric， 并用左边除以右边的数。整数相除返回 Rat， 否则返回&quot;更宽类型” 的结果。</p>
<h3 id="infix-div">infix div</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">div</span><span class="p">&gt;(</span><span class="kt">Int:D</span><span class="o">,</span> <span class="kt">Int:D</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Int:D</span>
</span></span></code></pre></div><p>整除。向下取整。</p>
<h3 id="infix--3">infix %</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">%</span><span class="p">&gt;(</span><span class="nv">$x</span><span class="o">,</span> <span class="nv">$y</span><span class="p">)</span> <span class="k">return</span> <span class="kt">Numeric:D</span>
</span></span></code></pre></div><p>模操作符。首先强制为 Numeric。</p>
<p>通常，下面的等式是成立的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$x</span> <span class="nv">%</span> <span class="nv">$y</span> <span class="o">==</span> <span class="nv">$x</span> <span class="o">-</span> <span class="nb">floor</span><span class="p">(</span><span class="nv">$x</span> <span class="o">/</span> <span class="nv">$y</span><span class="p">)</span> <span class="o">*</span> <span class="nv">$y</span>
</span></span></code></pre></div><h3 id="infix--4">infix %%</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">%%</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span>
</span></span></code></pre></div><p>整除操作符， 如果 <code> $a % $b == 0</code> 则返回 True.</p>
<h3 id="infix-mod">infix mod</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">mod</span><span class="p">&gt;(</span><span class="kt">Int:D</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Int:D</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Int:D</span>
</span></span></code></pre></div><p>整数取模操作符。 返回整数取模操作的剩余部分。</p>
<h3 id="infix--5">infix +&amp;</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+&amp;</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Int:D</span>
</span></span></code></pre></div><p>Numeric 按位 <code>AND</code>。 把两个参数都强转为 Int 并执行按位 AND 操作，假定两者是互补的。</p>
<h3 id="infix--6">infix +&lt;</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2"> +&lt; </span><span class="p">&gt;&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Int:D</span>
</span></span></code></pre></div><p>向左移动整数个位。</p>
<h3 id="infix--7">infix +&gt;</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2"> +&gt; </span><span class="p">&gt;&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Int:D</span>
</span></span></code></pre></div><p>向右移动整数个位。</p>
<h3 id="infix-gcd">infix gcd</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">gcd</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Int:D</span>
</span></span></code></pre></div><p>强制两个参数都为 Int 并返回最大公分母（greatest common denominator）。</p>
<h3 id="infix-lcm">infix lcm</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">lcm</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Int:D</span>
</span></span></code></pre></div><p>强制两个参数为 Int 并返回最小公倍数(least common multiple)</p>
<h2 id="加法优先级">加法优先级</h2>
<h3 id="infix--8">infix +</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Numeric:D</span>
</span></span></code></pre></div><p>强制两个参数为 Numeric 并把它们相加。</p>
<h3 id="infix--">infix -</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">-</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Numeric:D</span>
</span></span></code></pre></div><p>强制两个参数为 Numeric 并用第一个参数减去第二个参数。</p>
<h3 id="infix--9">infix +|</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+|</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Int:D</span>
</span></span></code></pre></div><p>强制两个参数为 Int 并执行按位 OR（包括 OR）</p>
<h3 id="infix--10">infix +^</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+^</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Int:D</span>
</span></span></code></pre></div><p>强制两个参数为 Int 并执行按位 XOR（不包括 OR）</p>
<h3 id="infix--11">infix ?|</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">?|</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span>
</span></span></code></pre></div><p>强制两个参数为 Bool 并执行逻辑 OR（不包括 OR）</p>
<h2 id="重复操作符优先级">重复操作符优先级</h2>
<h3 id="infix-x">infix x</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">x</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Str:D</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">x</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">x</span><span class="p">&gt;(</span><span class="kt">Str:D</span><span class="o">,</span> <span class="kt">Int:D</span><span class="p">)</span>
</span></span></code></pre></div><p>把 <code>$a</code> 强转为 Str ， 把 <code>$b</code> 强转为 Int， 并重复字符串 <code>$b</code> 次。 如果 <code>$b &lt;= 0</code> 则返回空字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">ab</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">3</span><span class="p">;</span>       <span class="c1"># ababab</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">42</span> <span class="nb">x</span> <span class="mi">3</span><span class="p">;</span>         <span class="c1"># 424242</span>
</span></span></code></pre></div><h3 id="infix-xx">infix xx</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">xx</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">List:D</span>
</span></span></code></pre></div><p>返回一组重复的 <code>$a</code> 并计算 <code>$b</code> 次（<code>$b</code> 被强转为 Int）。 如果 <code>$b &lt;= 0</code> ,则返回一个空列表。</p>
<p>每次重复都会计算左侧的值， 所以</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span> <span class="ow">xx</span> <span class="mi">5</span>
</span></span></code></pre></div><p>返回 5 个不同的数组（但是每次都是相同的内容）并且</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">rand</span> <span class="ow">xx</span> <span class="mi">3</span>
</span></span></code></pre></div><p>返回 3 个独立的伪随机数。右侧可以是 <code>*</code>, 这时会返回一个惰性的，无限的列表。</p>
<h2 id="连结">连结</h2>
<h3 id="infix--12">infix ~</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">~</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Str:D</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">~</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span>   <span class="kt">Any</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">~</span><span class="p">&gt;(</span><span class="kt">Str:D</span><span class="o">,</span> <span class="kt">Str:D</span><span class="p">)</span>
</span></span></code></pre></div><p>强制两个参数为 Str 并连结它们。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">ab</span><span class="p">&#39;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;;</span>     <span class="c1"># abc</span>
</span></span></code></pre></div><h2 id="junctive-and-all-优先级">Junctive AND (all) 优先级</h2>
<h3 id="infix--13">infix &amp;</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">&amp;</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Junction:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>用它的参数创建一个 <code>all</code> Junction。查看 Junctions 获取更多详情。</p>
<h2 id="junctive-or-any-precedence">Junctive OR (any) Precedence</h2>
<h3 id="infix--14">infix |</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">|</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Junction:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>用它的参数创建一个 <code>any</code> Junction。查看 Junctions 获取更多详情。</p>
<h3 id="infix--15">infix ^</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Junction:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>用它的参数创建一个 <code>one</code> Junction。查看 Junctions 获取更多详情。</p>
<h2 id="named-unary-precedence">Named Unary Precedence</h2>
<h3 id="prefix-temp">prefix temp</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">temp</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$a</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span>
</span></span></code></pre></div><p>temporizes 传入的变量作为参数， 这意味着退出作用域后它被重置为旧值。（这和 Perl 5 中的 local 操作符类似， 除了 temp 不重置值之外。）</p>
<h3 id="prefix-let">prefix let</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">let</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$a</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span>
</span></span></code></pre></div><p>假定重置：如果通过异常或 fail()退出当前作用域, 旧值就会被恢复。</p>
<h2 id="nonchaining-binary-precedence">Nonchaining Binary Precedence</h2>
<h3 id="infix-does">infix does</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">does</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$obj</span><span class="o">,</span> <span class="kt">Mu</span> <span class="nv">$role</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>在运行时把 <code>$role</code> 混合进 <code>$obj</code> 中。 要求 <code>$obj</code> 是可变的。</p>
<p>参数 <code>$role</code> 不一定要求是一个 role， 它可以表现的像是一个 role， 例如枚举值。</p>
<h3 id="infix-but">infix but</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">but</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$obj</span><span class="o">,</span> <span class="kt">Mu</span> <span class="nv">$role</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>把 <code>$role</code> 混合进 <code>$obj</code> 并创建一个 <code>$obj</code> 的副本。因为 <code>$obj</code> 是不能修改的，但是能使用 mixins 用于创建不可变值。</p>
<p>参数 <code>$role</code> 不一定要求是一个 role， 它可以表现的像是一个 role， 例如枚举值。</p>
<h3 id="infix-cmp">infix cmp</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Order:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span>       <span class="kt">Any</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="kt">Real:D</span><span class="o">,</span>    <span class="kt">Real:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="kt">Str:D</span><span class="o">,</span>     <span class="kt">Str:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="n">Enum:D</span><span class="o">,</span>    <span class="n">Enum:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="kt">Version:D</span><span class="o">,</span> <span class="kt">Version:D</span><span class="p">)</span>
</span></span></code></pre></div><p>一般的， “智能的” 三路比较器。</p>
<p>比较字符串时使用字符串语义， 比较数字时使用数字语义， 比较 Pair 对象时， 先比较键， 再比较值，等等。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$a</span> <span class="ow">eqv</span> <span class="nv">$b</span><span class="o">,</span> <span class="nb">then</span> <span class="nv">$a</span> <span class="ow">cmp</span> <span class="nv">$b</span> <span class="n">always</span> <span class="k">returns</span> <span class="n">Order::Same</span><span class="o">.</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">cmp</span> <span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">);</span>      <span class="c1"># Less</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">4</span>        <span class="ow">cmp</span> <span class="mf">4.0</span><span class="p">;</span>           <span class="c1"># Same</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span>      <span class="ow">cmp</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>           <span class="c1"># More</span>
</span></span></code></pre></div><h3 id="infix-leg">infix leg</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">leg</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Order:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">leg</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span>   <span class="kt">Any</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">leg</span><span class="p">&gt;(</span><span class="kt">Str:D</span><span class="o">,</span> <span class="kt">Str:D</span><span class="p">)</span>
</span></span></code></pre></div><p>字符串三路比较器。 leg 是  less, equal 还有 greater 的简写形式？</p>
<p>把两个参数都强转为 <code>Str</code> , 然后按照字母次序比较。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="ow">leg</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;;</span>        <span class="kt">Less</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="ow">leg</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>        <span class="kt">Same</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span> <span class="ow">leg</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>        <span class="kt">More</span>
</span></span></code></pre></div><h3 id="infix--16">infix &lt;=&gt;</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=&gt;</span><span class="p">»(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Order:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>Numeric 三路比较器。</p>
<p>把两个参数强转为 Real， 并执行数值比较。</p>
<h3 id="infix--17">infix ..</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">..</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Range:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>由参数创建一个  Range。</p>
<h3 id="infix--18">infix ..^</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">..^</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Range:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>由参数创建一个 Range， 不包含末端。</p>
<h3 id="infix--19">infix ^..</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^..</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Range:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>由参数创建一个 Range， 不包含开始端点。</p>
<h3 id="infix--20">infix ^..^</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^..^</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Range:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>由参数创建一个 Range， 不包含开端和末端。</p>
<h2 id="chaining-binary-precedence">Chaining Binary Precedence</h2>
<h3 id="infix--21">infix ==</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nv">$</span><span class="o">,</span> <span class="nv">$</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc:</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="kt">Int:D</span><span class="o">,</span> <span class="kt">Int:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="kt">Num:D</span><span class="o">,</span> <span class="kt">Num:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="kt">Rational:D</span><span class="o">,</span> <span class="kt">Rational:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="kt">Real:D</span><span class="o">,</span> <span class="kt">Real:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="kt">Complex:D</span><span class="o">,</span> <span class="kt">Complex:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="kt">Numeric:D</span><span class="o">,</span> <span class="kt">Numeric:D</span><span class="p">)</span>
</span></span></code></pre></div><p>强转两个参数为 Numeric（如果必要）， 并返回 True 如果它们相等。</p>
<h3 id="infix--22">infix !=</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!=</span><span class="p">&gt;(</span><span class="kt">Mu</span><span class="o">,</span> <span class="kt">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>强转两个参数为 Numeric（如果必要）， 并返回 True 如果它们不相等。</p>
<h3 id="infix--23">infix &lt;</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;</span><span class="p">»(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;</span><span class="p">»(</span><span class="kt">Int:D</span><span class="o">,</span> <span class="kt">Int:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;</span><span class="p">»(</span><span class="kt">Num:D</span><span class="o">,</span> <span class="kt">Num:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;</span><span class="p">»(</span><span class="kt">Real:D</span><span class="o">,</span> <span class="kt">Real:D</span><span class="p">)</span>
</span></span></code></pre></div><p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数小于第二个参数。</p>
<h3 id="infix--24">infix &lt;=</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=</span><span class="p">»(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=</span><span class="p">»(</span><span class="kt">Int:D</span><span class="o">,</span> <span class="kt">Int:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=</span><span class="p">»(</span><span class="kt">Num:D</span><span class="o">,</span> <span class="kt">Num:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=</span><span class="p">»(</span><span class="kt">Real:D</span><span class="o">,</span> <span class="kt">Real:D</span><span class="p">)</span>
</span></span></code></pre></div><p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数小于第二个参数。</p>
<h3 id="infix--25">infix &gt;</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;</span><span class="p">»(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;</span><span class="p">»(</span><span class="kt">Int:D</span><span class="o">,</span> <span class="kt">Int:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;</span><span class="p">»(</span><span class="kt">Num:D</span><span class="o">,</span> <span class="kt">Num:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;</span><span class="p">»(</span><span class="kt">Real:D</span><span class="o">,</span> <span class="kt">Real:D</span><span class="p">)</span>
</span></span></code></pre></div><p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数大于第二个参数。</p>
<h3 id="infix--26">infix &gt;=</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;=</span><span class="p">»(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;=</span><span class="p">»(</span><span class="kt">Int:D</span><span class="o">,</span> <span class="kt">Int:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;=</span><span class="p">»(</span><span class="kt">Num:D</span><span class="o">,</span> <span class="kt">Num:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;=</span><span class="p">»(</span><span class="kt">Real:D</span><span class="o">,</span> <span class="kt">Real:D</span><span class="p">)</span>
</span></span></code></pre></div><p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数大于或等于第二个参数。</p>
<h3 id="infix-eq">infix eq</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eq</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eq</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span>   <span class="kt">Any</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eq</span><span class="p">&gt;(</span><span class="kt">Str:D</span><span class="o">,</span> <span class="kt">Str:D</span><span class="p">)</span>
</span></span></code></pre></div><p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数等于第二个参数。</p>
<p>助记法: equal</p>
<h3 id="infix-ne">infix ne</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ne</span><span class="p">&gt;(</span><span class="kt">Mu</span><span class="o">,</span> <span class="kt">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ne</span><span class="p">&gt;(</span><span class="kt">Mu</span><span class="o">,</span>    <span class="kt">Mu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ne</span><span class="p">&gt;(</span><span class="kt">Str:D</span><span class="o">,</span> <span class="kt">Str:D</span><span class="p">)</span>
</span></span></code></pre></div><p>强转两个参数为 Str（如果必要）， 并返回 False 如果第一个参数等于第二个参数。</p>
<p>助记法: not equal</p>
<h3 id="infix-gt">infix gt</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">gt</span><span class="p">&gt;(</span><span class="kt">Mu</span><span class="o">,</span> <span class="kt">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">gt</span><span class="p">&gt;(</span><span class="kt">Mu</span><span class="o">,</span>    <span class="kt">Mu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">gt</span><span class="p">&gt;(</span><span class="kt">Str:D</span><span class="o">,</span> <span class="kt">Str:D</span><span class="p">)</span>
</span></span></code></pre></div><p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数大于第二个参数。</p>
<p>助记法: greater than</p>
<h3 id="infix-ge">infix ge</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ge</span><span class="p">&gt;(</span><span class="kt">Mu</span><span class="o">,</span> <span class="kt">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ge</span><span class="p">&gt;(</span><span class="kt">Mu</span><span class="o">,</span>    <span class="kt">Mu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ge</span><span class="p">&gt;(</span><span class="kt">Str:D</span><span class="o">,</span> <span class="kt">Str:D</span><span class="p">)</span>
</span></span></code></pre></div><p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数大于第二个参数。</p>
<p>助记法: greater or equal</p>
<h3 id="infix-lt">infix lt</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">lt</span><span class="p">&gt;(</span><span class="kt">Mu</span><span class="o">,</span> <span class="kt">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">lt</span><span class="p">&gt;(</span><span class="kt">Mu</span><span class="o">,</span>    <span class="kt">Mu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">lt</span><span class="p">&gt;(</span><span class="kt">Str:D</span><span class="o">,</span> <span class="kt">Str:D</span><span class="p">)</span>
</span></span></code></pre></div><p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数小于第二个参数。</p>
<p>助记法: less than</p>
<h3 id="infix-le">infix le</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">le</span><span class="p">&gt;(</span><span class="kt">Mu</span><span class="o">,</span> <span class="kt">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">le</span><span class="p">&gt;(</span><span class="kt">Mu</span><span class="o">,</span>    <span class="kt">Mu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">le</span><span class="p">&gt;(</span><span class="kt">Str:D</span><span class="o">,</span> <span class="kt">Str:D</span><span class="p">)</span>
</span></span></code></pre></div><p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数小于或等于第二个参数。</p>
<p>助记法: less or equal</p>
<h3 id="infix-before">infix before</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span>       <span class="kt">Any</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="kt">Real:D</span><span class="o">,</span>    <span class="kt">Real:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="kt">Str:D</span><span class="o">,</span>     <span class="kt">Str:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="n">Enum:D</span><span class="o">,</span>    <span class="n">Enum:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="kt">Version:D</span><span class="o">,</span> <span class="kt">Version:D</span><span class="p">)</span>
</span></span></code></pre></div><p>一般的排序， 使用和 cmp 相同的语义。 如果第一个参数小于第二个参数则返回 True。</p>
<h3 id="infix-after">infix after</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span>       <span class="kt">Any</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="kt">Real:D</span><span class="o">,</span>    <span class="kt">Real:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="kt">Str:D</span><span class="o">,</span>     <span class="kt">Str:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="n">Enum:D</span><span class="o">,</span>    <span class="n">Enum:D</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="kt">Version:D</span><span class="o">,</span> <span class="kt">Version:D</span><span class="p">)</span>
</span></span></code></pre></div><p>一般的排序， 使用和 cmp 相同的语义。 如果第一个参数大于第二个参数则返回 True。</p>
<h3 id="infix-eqv">infix eqv</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eqv</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eqv</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span>
</span></span></code></pre></div><p>等值操作符。如果两个参数在结构上相同就返回 True。例如， 相同类型（并且递归）包含相同的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="ow">eqv</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="p">;</span>        <span class="c1"># True</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="kt">Any</span> <span class="ow">eqv</span> <span class="kt">Any</span><span class="p">;</span>                    <span class="c1"># True</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span> <span class="ow">eqv</span> <span class="mi">2</span><span class="p">;</span>                        <span class="c1"># False</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span> <span class="ow">eqv</span> <span class="mf">1.0</span><span class="p">;</span>                      <span class="c1"># False</span>
</span></span></code></pre></div><p>对于任意对象使用默认的 eqv 操作是不可能的。例如， eqv 不认为同一对象的两个实例在结构上是相等的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="ow">eqv</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">);</span>  <span class="c1">#=&gt; False</span>
</span></span></code></pre></div><p>要得到这个类的对象相等（eqv）语义， 需要实现一个合适的中缀 eqv 操作符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eqv</span><span class="p">&gt;(</span><span class="n">A</span> <span class="nv">$l</span><span class="o">,</span> <span class="n">A</span> <span class="nv">$r</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$l</span><span class="o">.</span><span class="nf">a</span> <span class="ow">eqv</span> <span class="nv">$r</span><span class="o">.</span><span class="nf">a</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="ow">eqv</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">);</span>  <span class="c1">#=&gt; True</span>
</span></span></code></pre></div><h3 id="infix--27">infix ===</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">===</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">===</span><span class="p">&gt;(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">Any</span><span class="p">)</span>
</span></span></code></pre></div><p>值相等。如果两个参数都是同一个对象则返回 True。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span> <span class="o">===</span> <span class="nv">$a</span><span class="p">;</span>              <span class="c1"># True</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span> <span class="o">===</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>        <span class="c1"># False</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">A</span> <span class="o">===</span> <span class="n">A</span><span class="p">;</span>                <span class="c1"># True</span>
</span></span></code></pre></div><p>对于值的类型，  <code>===</code> 表现的和 eqv 一样:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">===</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>            <span class="c1"># True</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">===</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;;</span>            <span class="c1"># False</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># different types</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span> <span class="o">===</span> <span class="mf">1.0</span><span class="p">;</span>              <span class="c1"># False</span>
</span></span></code></pre></div><p><code>===</code> 使用 <code>WHICH</code> 方法来获取对象相等， 所以所有的值类型必须重写方法 <code>WHICH</code>。</p>
<h3 id="infix--28">infix =:=</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">=:=</span><span class="p">&gt;(</span><span class="kt">Mu</span> \<span class="n">a</span><span class="o">,</span> <span class="kt">Mu</span> \<span class="n">b</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">=:=</span><span class="p">&gt;(</span><span class="kt">Mu</span> \<span class="n">a</span><span class="o">,</span> <span class="kt">Mu</span> \<span class="n">b</span><span class="p">)</span>
</span></span></code></pre></div><p>容器相等。返回 True 如果两个参数都绑定到同一个容器上。 如果它返回 True， 那通常意味着修改一个参数也会同时修改另外一个。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span> <span class="o">=:=</span> <span class="nv">$b</span><span class="p">;</span>      <span class="c1"># False</span>
</span></span><span class="line"><span class="cl"><span class="nv">$b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="p">;</span>             <span class="c1"># 1</span>
</span></span><span class="line"><span class="cl"><span class="nv">$b</span> <span class="o">:=</span> <span class="nv">$a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span> <span class="o">=:=</span> <span class="nv">$b</span><span class="p">;</span>      <span class="c1"># True</span>
</span></span><span class="line"><span class="cl"><span class="nv">$a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$b</span><span class="p">;</span>             <span class="c1"># 5</span>
</span></span></code></pre></div><h3 id="infix--29">infix ~~</h3>
<p>智能匹配操作符。把左侧参数起别名为 <code>$_</code> , 然后计算右侧的值， 并在它身上调用 <code>.ACCEPTS($_)</code> 。 匹配的语义由右侧操作数的类型决定。</p>
<p>这儿有一个内建智能匹配函数的摘要：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">右侧</span>      <span class="n">比较语义</span>
</span></span><span class="line"><span class="cl"><span class="kt">Mu:U</span>	  <span class="n">类型检查</span>
</span></span><span class="line"><span class="cl"><span class="kt">Str</span>	      <span class="n">字符串相等</span>
</span></span><span class="line"><span class="cl"><span class="kt">Numeric</span>	  <span class="n">数值相等</span>
</span></span><span class="line"><span class="cl"><span class="kt">Regex</span>	  <span class="n">正则匹配</span>
</span></span><span class="line"><span class="cl"><span class="kt">Callable</span>  <span class="n">调用的布尔结果</span>
</span></span><span class="line"><span class="cl"><span class="kt">Any:D</span>	  <span class="n">对象相等</span>
</span></span></code></pre></div><h2 id="tight-and-precedence">Tight AND Precedence</h2>
<h3 id="infix--30">infix &amp;&amp;</h3>
<p>在布尔上下文中返回第一个求值为 False 的参数， 否则返回最后一个参数。</p>
<p>注意这是短路操作符，如果其中的一个参数计算为 false 值， 那么该参数右侧的值绝不会被计算。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">a</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">b</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">c</span> <span class="p">{</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">never called</span><span class="p">&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">a</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">b</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">c</span><span class="p">();</span>      <span class="c1"># 0</span>
</span></span></code></pre></div><h2 id="tight-or-precedence">Tight OR Precedence</h2>
<h3 id="infix--31">infix ||</h3>
<p>在布尔上下文中返回第一个求值为 True 的参数， 否则返回最后一个参数。</p>
<p>注意这是短路操作符，如果其中的一个参数计算为 true 值， 那么该参数右侧的值绝不会被计算。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">a</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">b</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">c</span> <span class="p">{</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">never called</span><span class="p">&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">a</span><span class="p">()</span> <span class="o">||</span> <span class="nf">b</span><span class="p">()</span> <span class="o">||</span> <span class="nf">c</span><span class="p">();</span>      <span class="c1"># 1</span>
</span></span></code></pre></div><h3 id="infix--32">infix ^^</h3>
<p>返回第一个值为 true 的参数如果只有一个的话， 否则返回 Nil。只要找到两个值为 true 的参数就发生短路。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">0</span> <span class="o">^^</span> <span class="mi">42</span><span class="p">;</span>                <span class="c1"># 42</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">0</span> <span class="o">^^</span> <span class="mi">42</span> <span class="o">^^</span> <span class="mi">1</span> <span class="o">^^</span> <span class="nb">die</span> <span class="mi">8</span><span class="p">;</span>  <span class="c1"># (empty line)</span>
</span></span></code></pre></div><p>注意， 这个操作符的语义可能不是你假想的那样： infix ^^ 翻到它找到的第一个 true 值， 找到第二个 true 值后永远地反转为 Nil 值， 不管还有多少 true 值。（换句话说，它的语义是”找到一个真值”， 而不是布尔起奇偶校验语义）</p>
<h3 id="infix--33">infix //</h3>
<p>Defined-or  操作符。返回第一个定义了的操作数， 否则返回最后一个操作数。短路操作符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="kt">Any</span> <span class="o">//</span> <span class="mi">0</span> <span class="o">//</span> <span class="mi">42</span><span class="p">;</span>         <span class="c1"># 0</span>
</span></span></code></pre></div><h3 id="infix-min">infix min</h3>
<p>返回参数的最小值。语义由 cmp 语义决定。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$foo</span> <span class="nb">min</span><span class="o">=</span> <span class="mi">0</span>  <span class="c1"># read as: $foo decreases to 0</span>
</span></span></code></pre></div><h3 id="infix-max">infix max</h3>
<p>返回参数的最大值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$foo</span> <span class="nb">max</span><span class="o">=</span> <span class="mi">0</span>  <span class="c1"># read as: $foo increases to 0</span>
</span></span></code></pre></div><h2 id="conditional-operator-precedence">Conditional Operator Precedence</h2>
<h3 id="infix---1">infix ?? !!</h3>
<p>三目操作符， 条件操作符。</p>
<p><code>$condition ?? $true !! $false</code> 计算并返回 <code>$true</code> 表达式，如果 <code>$condition</code> 为真的话。 否则计算并返回 <code>$false</code> 分支。</p>
<h3 id="infix-ff">infix ff</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ff</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</span></span></code></pre></div><p>Flipflop operator. 触发器操作符。</p>
<p>把两个参数都跟 <code>$_</code> 进行比较（即，<code>$_ ~~ $a</code> 和 <code>$_ ~~ $b</code>）。求值为 False 直到左侧的智能匹配为真， 这时，它求值为真， 直到右侧的智能匹配为真。</p>
<p>实际上，左边的参数是&quot;开始”条件， 右侧的参数是”停止” 条件。 这种结构一般用于收集只在特定区域的行。 例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$excerpt</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/END/;</span><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">Here&#39;s some unimportant text.
</span></span></span><span class="line"><span class="cl"><span class="s">=begin code
</span></span></span><span class="line"><span class="cl"><span class="s">    This code block is what we&#39;re after.
</span></span></span><span class="line"><span class="cl"><span class="s">    We&#39;ll use &#39;ff&#39; to get it.
</span></span></span><span class="line"><span class="cl"><span class="s">=end code
</span></span></span><span class="line"><span class="cl"><span class="s">More unimportant text.
</span></span></span><span class="line"><span class="cl"><span class="s"></span><span class="p">END</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@codelines</span> <span class="o">=</span> <span class="k">gather</span> <span class="k">for</span> <span class="nv">$excerpt</span><span class="o">.</span><span class="nb">lines</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">take</span> <span class="nv">$_</span> <span class="k">if</span> <span class="p">&#34;</span><span class="s2">=begin code</span><span class="p">&#34;</span> <span class="ow">ff</span> <span class="p">&#34;</span><span class="s2">=end code</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># this will print four lines,</span>
</span></span><span class="line"><span class="cl"><span class="c1"># starting with &#34;=begin code&#34; and ending with &#34;=end code&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@codelines</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="se">\n</span><span class="p">&#34;);</span>
</span></span></code></pre></div><p>匹配开始条件之后，操作符会继续将停止条件与 <code>$_</code> 进行匹配， 如果成功就做相应地表现。在这个例子中， 只有第一个元素被打印了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">&lt;</span><span class="s">AB C D B E F</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">ff</span> <span class="o">/</span><span class="n">B</span><span class="o">/</span><span class="p">;</span>  <span class="c1"># prints only &#34;AB&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果你想测试开始条件， 并且没有结束条件， <code>*</code> 能用作 “停止” 条件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">&lt;</span><span class="s">A B C D E</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="ow">ff</span> <span class="o">*</span><span class="p">;</span> <span class="c1"># prints C, D, and E</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对于 sed-like 版本， 在开始条件匹配成功之后，它不会使用停止条件与 <code>$_</code> 进行匹配。</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-ff-1">infix ^ff</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^ff</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</span></span></code></pre></div><p>像 ff 那样工作，除了它不会在条目匹配开始条件时返回真。（包括匹配停止条件的条目）</p>
<p>一个比较:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">ff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">^ff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints B and C</span>
</span></span></code></pre></div><p>sed-like 版本 可以在 ^fff 中找到.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-ff-2">infix ff^</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ff^</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</span></span></code></pre></div><p>像 ff 那样工作，除了它不会在条目匹配停止条件时返回真。（包括第一次匹配开始条件的条目）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">ff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">ff^</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints A and B</span>
</span></span></code></pre></div><p>sed-like 版本 可以在 fff^ 中找到.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-ff-3">infix ^ff^</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^ff^</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</span></span></code></pre></div><p>像 ff 那样工作，除了它不会在条目匹配停止条件时返回真, 也不会在条目匹配开始时返回真。（或者两者）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">ff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">^ff</span><span class="o">^</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints B</span>
</span></span></code></pre></div><p>sed-like 版本 可以在 ^fff^ 中找到.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff">infix fff</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">fff</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</span></span></code></pre></div><p>执行 sed-like 那样的 flipflop 操作，在其中，它返回 False 直到左侧的参数与 <code>$_</code> 智能匹配， 并且在那之后返回 True 直到右侧的参数和 <code>$_</code>  智能匹配。</p>
<p>像 ff 那样工作， 除了它每次调用只尝试一个参数之外。即， 如果 <code>$_</code> 和左侧的参数智能匹配， fff 随后不会尝试将同一个 <code>$_</code> 和右侧的参数进行匹配。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">&lt;</span><span class="s">AB C D B E F</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">fff</span> <span class="o">/</span><span class="n">B</span><span class="o">/</span><span class="p">;</span>  <span class="c1"># Prints &#34;AB&#34;, &#34;C&#34;, &#34;D&#34;, and &#34;B&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对于 non-sed-like 版本， 查看 <code>ff</code>.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff-1">infix ^fff</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^fff</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</span></span></code></pre></div><p>像 fff那样， 除了它对于左侧的匹配不返回真之外。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">fff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">^fff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints B and C</span>
</span></span></code></pre></div><p>对于 non-sed 版本， 查看 <code>^ff</code>.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff-2">infix fff^</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">fff^</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</span></span></code></pre></div><p>像 fff 那样， 除了它对于右侧的匹配不返回真之外。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">fff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">fff^</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints A and B</span>
</span></span></code></pre></div><p>对于 non-sed 版本， 查看 <code>ff^</code>.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff-3">infix ^fff^</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^fff^</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</span></span></code></pre></div><p>像 fff 那样， 除了它对于左侧和右侧的匹配都不返回真之外。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">fff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">^fff</span><span class="o">^</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints B</span>
</span></span></code></pre></div><p>对于 non-sed 版本， 查看 <code>^ff^</code>.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h2 id="item-assignment-precedence">Item Assignment Precedence</h2>
<h3 id="infix--34">infix =</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$a</span> <span class="k">is</span> <span class="k">rw</span><span class="o">,</span> <span class="kt">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</span></span></code></pre></div><p>Item 赋值.</p>
<p>把 = 号右侧的值放入左侧的容器中。 它真正的语义是由左侧的容器类型决定的。</p>
<p>（注意 item 赋值和列表赋值的优先级级别不同， 并且等号左侧的语法决定了等号是被解析为 item 赋值还是列表赋值操作符）。</p>
<h3 id="infix--35">infix =&gt;</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">=&gt;</span><span class="p">»(</span><span class="nv">$key</span><span class="o">,</span> <span class="kt">Mu</span> <span class="nv">$value</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Pair:D</span>
</span></span></code></pre></div><p>Pair 构造器.</p>
<p>使用左侧值作为键， 右侧值作为值，构造一个 Pair 对象。</p>
<p>注意 <code>=&gt;</code> 操作符是语法上的特例，在这个结构中， 它允许左侧是一个未被引起的标识符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$p</span> <span class="o">=</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$p</span><span class="o">.</span><span class="nb">key</span><span class="p">;</span>         <span class="c1"># a</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$p</span><span class="o">.</span><span class="nb">value</span><span class="p">;</span>       <span class="c1"># 1</span>
</span></span></code></pre></div><p>在参数列表中，在 <code>=&gt;</code> 左侧使用未被引起的标识符构建的 Pair 会被解释为一个具名参数。</p>
<p>查看 Terms 语言文档了解更多创建 Pair 对象的方式。</p>
<h2 id="loose-unary-precedence">Loose Unary Precedence</h2>
<h3 id="prefix-not">prefix not</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">not</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$x</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span>
</span></span></code></pre></div><p>在布尔上下文中计算它的参数（因此使 Junctions 失效）， 并返回否定的结果。</p>
<h3 id="prefix-so">prefix so</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">so</span><span class="p">&gt;(</span><span class="kt">Mu</span> <span class="nv">$x</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">Bool:D</span>
</span></span></code></pre></div><p>在布尔上下文中计算它的参数（因此使 Junctions 失效）， 并返回结果。</p>
<h2 id="逗号操作符优先级">逗号操作符优先级</h2>
<h3 id="infix--36">infix ,</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">,</span><span class="p">&gt;(</span><span class="o">*</span><span class="nv">@a</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span> <span class="k">returns</span> <span class="n">Parcel:D</span>
</span></span></code></pre></div><p>从它的参数宏构建一个 Parcel。也在语法构成上用作函数用的参数的分隔符。</p>
<h3 id="infix--37">infix :</h3>
<p>就像中缀操作符  <code>,</code> 那样， <code>:</code> 用作参数分隔符， 并把它左侧的参数标记为调用者。</p>
<p>那会把函数调用转为方法调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">substr</span><span class="p">(&#39;</span><span class="s1">abc</span><span class="p">&#39;</span><span class="o">:</span> <span class="mi">1</span><span class="p">);</span>       <span class="c1"># same as &#39;abc&#39;.substr(1)</span>
</span></span></code></pre></div><p><code>Infix :</code> 只允许出现在非方法调用的第一个参数后面。 在其它位置它会是语法错误。</p>
<h2 id="list-infix-precedence">List Infix Precedence</h2>
<h3 id="infix-z">infix Z</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">Z</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@lists</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">List:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>Zip operator.</p>
<p>Z 像一个拉链那样把列表插入进来， 只要第一个输入列表耗尽就停止：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span> <span class="ow">Z</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="ow">Z</span> <span class="p">&lt;</span><span class="s">+ -</span><span class="p">&gt;)</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>  <span class="c1"># ((1, &#34;a&#34;, &#34;+&#34;), (2, &#34;b&#34;, &#34;-&#34;)).list</span>
</span></span></code></pre></div><p><code>Z</code> 操作符也作为元操作符存在， 此时内部的 parcels 被应用了元操作符的列表替换：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">100</span><span class="o">,</span> <span class="mi">200</span> <span class="ow">Z</span><span class="o">+</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">23</span><span class="p">;</span>             <span class="c1"># 142, 223</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span> <span class="ow">Z</span><span class="o">~</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="ow">Z</span><span class="o">~</span> <span class="p">&#39;</span><span class="s1">x</span><span class="p">&#39;</span> <span class="ow">xx</span> <span class="mi">3</span><span class="p">;</span>    <span class="c1"># 1ax 2bx 3cx</span>
</span></span></code></pre></div><h3 id="infix-x-1">infix X</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">X</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@lists</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">List:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>从所有列表创建一个外积。最右边的元素变化得最迅速。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">1</span><span class="o">..</span><span class="mi">3</span> <span class="ow">X</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="ow">X</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># produces   (1, &#39;a&#39;, 9), (1, &#39;b&#39;, 9), (1, &#39;c&#39;, 9),</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">9</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">9</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">9</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">9</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">9</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">9</span><span class="p">)</span>
</span></span></code></pre></div><p>X 操作符也可以作为元操作符， 此时内部的 parcels 被应用了元操作符的列表的值替换：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">1</span><span class="o">..</span><span class="mi">3</span> <span class="ow">X</span><span class="o">~</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="ow">X</span><span class="o">~</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># produces   &#39;1a9&#39;, &#39;1b9&#39;, &#39;1c9&#39;,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">         <span class="p">&#39;</span><span class="s1">2a9</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">2b9</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">2c9</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">         <span class="p">&#39;</span><span class="s1">3a9</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">3b9</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">3c9</span><span class="p">&#39;</span>
</span></span></code></pre></div><h3 id="infix--38">infix &hellip;</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">...</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">...^</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>序列操作符是一个用于产生惰性列表的普通操作符。</p>
<p>它可以有一个初始元素和一个生成器在 <code>…</code> 的左侧， 在右侧是一个端点。</p>
<p>序列操作符会使用尽可能多的参数来调用生成器。参数会从初始元素和已生成元素中获取。</p>
<p>默认的生成器是 <code>*.succ</code> 或 <code>*.pred</code> ， 取决于末端怎么比较：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span> <span class="o">...</span> <span class="mi">4</span><span class="p">;</span>        <span class="c1"># 1 2 3 4</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">4</span> <span class="o">...</span> <span class="mi">1</span><span class="p">;</span>        <span class="c1"># 4 3 2 1</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">...</span> <span class="p">&#39;</span><span class="s1">e</span><span class="p">&#39;;</span>    <span class="c1"># a b c d e</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">e</span><span class="p">&#39;</span> <span class="o">...</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>    <span class="c1"># e d c b a</span>
</span></span></code></pre></div><p><code>*</code>  (Whatever) 末端生成一个无限序列，使用的是默认的生成器 <code>*.succ</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span> <span class="o">...</span> <span class="o">*</span><span class="p">)</span><span class="o">[^</span><span class="mi">5</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># 1 2 3 4 5</span>
</span></span></code></pre></div><p>自定义生成器是在 <code>…</code> 操作符之前的最后一个参数。下面这个自定义生成器接收两个参数， 生成了斐波纳契数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span> <span class="p">}</span> <span class="o">...</span> <span class="o">*</span><span class="p">)</span><span class="o">[^</span><span class="mi">8</span><span class="o">]</span><span class="p">;</span>    <span class="c1"># 1 1 2 3 5 8 13 21</span>
</span></span><span class="line"><span class="cl"><span class="c1"># same but shorter</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*+*</span> <span class="o">...</span> <span class="o">*</span><span class="p">)</span><span class="o">[^</span><span class="mi">8</span><span class="o">]</span><span class="p">;</span>                      <span class="c1"># 1 1 2 3 5 8 13 21</span>
</span></span></code></pre></div><p>当然自定义生成器也能只接收一个参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">5</span><span class="o">,</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">}</span> <span class="o">...</span> <span class="mi">40</span><span class="p">;</span>                       <span class="c1"># 5 10 20 40</span>
</span></span></code></pre></div><p>生成器的参数个数至少要和初始元素的个数一样多。</p>
<p>如果没有生成器，并且有不止一个初始元素，所有的初始元素都是数值，那么序列操作符会尝试推导出生成器。它知道数学和几何序列。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span> <span class="o">...</span> <span class="mi">12</span><span class="p">;</span>     <span class="c1"># 2 4 6 8 10 12</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="mi">32</span><span class="p">;</span>     <span class="c1"># 1 2 4 8 16 32</span>
</span></span></code></pre></div><p>如果末端不是 <code>*</code>， 它会和每个生成的元素进行智能匹配，当智能匹配成功的时候序列就被终止。对于 <code>...</code>  操作符， 会包含最后一个元素， 对于 <code>...^</code> 操作符，会排除最后的那个元素。</p>
<p>这允许你这样写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*+*</span> <span class="o">...^</span> <span class="o">*&gt;=</span> <span class="mi">100</span><span class="p">;</span>
</span></span></code></pre></div><p>来生成所有直到 100 但不包括 100 的斐波纳契数。</p>
<p><code>...</code> 操作符还会把初始值看作”已生成的元素”，所以它们也会对末端进行检查：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$end</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">16</span> <span class="o">...</span> <span class="nv">$end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># outputs 1 2 4</span>
</span></span></code></pre></div><h2 id="list-prefix-precedence">List Prefix Precedence</h2>
<h3 id="infix--39">infix =</h3>
<p>列表赋值。  它真正的语义是由左侧的容器类型决定的。查看 Array 和 Hash 获取普通案例。</p>
<p>item 赋值和列表赋值的优先级级别不同， 并且等号左侧的语法决定了等号是被解析为 item 赋值还是列表赋值操作符。</p>
<h3 id="infix--40">infix :=</h3>
<p>绑定。 而 <code>$x = $y</code> 是把 <code>$y</code> 中的值放到 <code>$x</code> 里面， <code>$x := $y</code> 会让 <code>$x</code> 和 <code>$y</code> 引用同一个值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$b</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="p">;</span>
</span></span></code></pre></div><p>这会输出 42， 因为 $a 和 $b 都包含了数字 42， 但是容器是不同的。</p>
<pre tabindex="0"><code>my $a = 42;
my $b := $a;
$b++;
say $a;
</code></pre><p>这会打印 43， 因为 <code>$b</code> 和 <code>$a</code> 都代表着<code>同一个对象</code>。</p>
<h3 id="infix--41">infix ::=</h3>
<p>只读绑定. 查看  infix :=.</p>
<h3 id="listop-">listop &hellip;</h3>
<p>这是yada, yada, yada 操作符 或 stub 操作符。如果它在子例程或类型中是唯一的语句，它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
<p>如果 <code>...</code> 语句被执行了， 它会调用 <code>&amp;fail</code> , 伴随着默认的消息 stub 代码的执行。</p>
<h3 id="listop--1">listop !!!</h3>
<p>如果它在子例程或类型中是唯一的语句，它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
<p>如果 <code>!!!</code> 语句被执行了， 它会调用 <code>&amp;die</code> , 伴随着默认的消息 stub 代码的执行。</p>
<h3 id="listop--2">listop ???</h3>
<p>如果它在子例程或类型中是唯一的语句，它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
<p>如果 <code>???</code> 语句被执行了， 它会调用 <code>&amp;warn</code> , 伴随着默认的消息 stub 代码的执行。</p>
<h2 id="loose-and-precedence">Loose AND precedence</h2>
<h3 id="infix-and">infix and</h3>
<p>和中缀操作符 <code>&amp;&amp;</code> 一样，除了优先级更宽松。</p>
<p>在布尔上下文中返回第一个求值为 False 的操作数， 否则返回最后一个操作数。短路操作符。</p>
<h3 id="infix-andthen">infix andthen</h3>
<p>返回第一个未定义的参数，否则返回最后一个参数。短路操作符。左侧的结果被绑定到 <code>$_</code> 身上， 在右侧中使用， 或者作为参数被传递，如果右侧是一个 block 或 pointy block.</p>
<h2 id="loose-or-precedence">Loose OR Precedence</h2>
<h3 id="infix-or">infix or</h3>
<p>和中缀操作符 <code>||</code> 一样，除了优先级更宽松。</p>
<p>在布尔上下文中返回第一个求值为 True 的参数， 否则返回最后一个参数。短路操作符。</p>
<h3 id="infix-orelse">infix orelse</h3>
<p>和中缀操作符 <code>//</code> 一样，除了优先级更宽松之外。</p>
<p>返回第一个定义过的参数， 否则返回最后一个参数。短路操作符。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[面向对象]]></title>
            <link href="http://localhost:1313/rakulang/53.object-orientation/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/52.numerics/?utm_source=atom_feed" rel="related" type="text/html" title="数值" />
                <link href="http://localhost:1313/notes/a-tour-of-spark-structured-streaming/?utm_source=atom_feed" rel="related" type="text/html" title="Spark 结构化流之旅" />
                <link href="http://localhost:1313/notes/write-parquet-to-kafka/?utm_source=atom_feed" rel="related" type="text/html" title="读取 Parquet 并写回 Kafka" />
                <link href="http://localhost:1313/rakulang/51.newline-handling-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的换行处理" />
                <link href="http://localhost:1313/notes/nim/?utm_source=atom_feed" rel="related" type="text/html" title="Nim" />
            
                <id>http://localhost:1313/rakulang/53.object-orientation/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-28T21:13:31+08:00</published>
            <updated>2018-11-28T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p><a href="https://docs.raku.org/language/objects">Object Orientation in Raku</a></p>
<p>Raku 有很多预先定义好的类型，这些类型可以归为 2 类：<code>普通类型</code>和<code>原生类型</code>。原生类型用于<code>底层类型</code>（例如 uint 64）。原生类型没有和对象同样的功能，尽管你可以在它们身上调用方法， 它们还是被包装成普通的对象。所有你能存储到变量中的东西要么是一个原生的 value， 要么是一个对象。这包括字面值、类型（类型对象）、code 和容器。</p>
<h2 id="使用对象">使用对象</h2>
<p>方法可以有参数， 但是方法名和参数列表之间不可以有空格：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">abc</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">uc</span><span class="p">;</span>                   
</span></span><span class="line"><span class="cl"><span class="c1">#        ^^^ 不带参数的方法调用</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@words</span> <span class="o">=</span> <span class="nv">$string</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/);</span>
</span></span><span class="line"><span class="cl"><span class="c1">#                  ^^^^^^^^^^^^ 带一个参数的方法调用</span>
</span></span></code></pre></div><p>另外一种方法调用的语法将方法名和参数列表用一个冒号分开(冒号紧跟方法名, 中间不能有空格):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="vg">@*INC</span><span class="o">.</span><span class="nb">join</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;;</span>
</span></span></code></pre></div><p>方法能返回一个可变容器, 这种情况下 你可以赋值给方法调用的返回值.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="vg">$*IN</span><span class="o">.</span><span class="nf">input-line-separator</span> <span class="o">=</span> <span class="p">&#34;</span><span class="se">\r\n</span><span class="p">&#34;;</span>
</span></span></code></pre></div><h2 id="类型对象">类型对象</h2>
<p>Types本身就是对象 ，你可以使用类型的名字获取 type object :</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$int-type-obj</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">;</span>
</span></span></code></pre></div><p>你可以通过调用 WHAT 方法查看任何对象的 type object(它实际上是一个方法形式的macro):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$int-type-obj</span> <span class="o">=</span> <span class="mi">1</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>
</span></span></code></pre></div><p>使用 === 操作符可以比较 类型对象的相等性：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$x</span><span class="o">.</span><span class="nb">WHAT</span> <span class="o">===</span> <span class="kt">Int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">you passed an Int</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">you passed a subtype of Int</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>子类型可以使用 smart-matching来检查：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$type</span> <span class="o">~~</span> <span class="kt">Real</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">$type contains Real or a subtype thereof</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="类">类</h2>
<p>使用 class 关键字进行类的定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Journey</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>声明一个词法作用域的类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">class</span> <span class="nc">Journey</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这在嵌套类中很有用。</p>
<h2 id="属性">属性</h2>
<p>属性存在于每个类的实例中。属性中存储着对象的状态。在 Raku 中, 一切属性都是<code>私有的</code>.  它们一般使用 <code>has</code> 关键字和 <code>!</code> twigil 进行声明.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Journey</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!origin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!destination</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">@!travellers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!notes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>然而, 没有像这样的公共(甚至保护属性)属性, 不过有一种方式能<code>自动生成访问方法</code>: 使用 <code>. </code>代替 <code>!</code> twigil 。(那个 <code>.</code> 应该让你想起了<strong>方法调用</strong>).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Journey</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.origin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.destination</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">@!travellers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.notes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这默认提供了一种<strong>只读</strong>的取值方法, 为了允许更改属性, 要添加 <code>is rw</code> 特性:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Journey</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.origin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.destination</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">@!travellers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.notes</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>因为类默认继承于构造器 <code>Mu</code>, 我们也要求类为我们生成一些<strong>存取方法</strong>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># 创建一个新的类的实例.</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$vacation</span> <span class="o">=</span> <span class="n">Journey</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">origin</span>      <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Sweden</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">destination</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Switzerland</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">notes</span>       <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Pack hiking gear!</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用存取器; 这打印出 Sweden.</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$vacation</span><span class="o">.</span><span class="nf">origin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 rw 存取器来更改属性的值.</span>
</span></span><span class="line"><span class="cl"><span class="nv">$vacation</span><span class="o">.</span><span class="nf">notes</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Pack hiking gear and sunglasses!</span><span class="p">&#39;;</span>
</span></span></code></pre></div><p>注意, 默认的构造器只会设置含有存取器方法的属性.</p>
<h2 id="方法">方法</h2>
<p>使用 <code>method</code> 关键字定义类中的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Journey</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.origin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.destination</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">@!travellers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.notes</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">add_traveller</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nv">$name</span> <span class="ow">ne</span> <span class="nb">any</span><span class="p">(</span><span class="nv">@!travellers</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">push</span> <span class="nv">@!travellers</span><span class="o">,</span> <span class="nv">$name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">warn</span> <span class="p">&#34;</span><span class="nv">$name</span><span class="s2"> is already going on the journey!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">describe</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#34;</span><span class="s2">From </span><span class="nv">$!origin</span><span class="s2"> to </span><span class="nv">$!destination</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>方法可以有签名, 就像子例程一样。 方法中能访问对象的属性,  并且总是能使用 <code>!</code> twigil, 即使属性是用 <code>.</code> twigil 声明的. 这是因为, . twigil 是在那个位置上使用 ! twigil 声明了属性, 然后额外又添加了一个取值器方法.</p>
<p>即 <code>has $.attribute</code> 等价于:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!attribute</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">attribute</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>    
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.attr</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>等价于:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>    
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!attr</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">attr</span><span class="p">()</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!attr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在 describe 方法中使用 $!origin 和 $.origin ,这之间有一个微小但很重要的差别.  $!origin 只是属性的简单查看. 它是廉价的, 并且你知道它是类中声明的属性. $.origin 真正的是一个方法调用, 因此能在子类中被覆写. 如果你真的显式地要覆写它才使用 $.origin 吧.</p>
<h2 id="self">self</h2>
<p>在方法内部, self 是可用的, 它被绑定到调用者, 例如方法调用的对象. self 能用于在调用者上调用深层的方法, 例如:</p>
<h3 id="私有方法">私有方法</h3>
<p>在方法的名字前面引入一个感叹号, 这个方法就变为类的私有方法, 这个方法只在内的内部使用, 不能在其它任何地方调用.</p>
<p>私有方法的调用要使用感叹号而非点号:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">method</span> <span class="nf">!do-something-private</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">method</span> <span class="nf">public</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">self</span><span class="o">.</span><span class="nf">precondition</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">self</span><span class="o">!</span><span class="nf">do-something--private</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nv">$x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>私有方法不能被子类继承.</p>
<h3 id="子方法">子方法</h3>
<p>submethod  是不会被子类继承的公开方法。从词干名来看它们在语义上与子例程类似。</p>
<p>Submethods 对于对象构建和解构任务很有用。</p>
<h2 id="继承">继承</h2>
<p>类可以有父类:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Child</span> <span class="k">is</span> <span class="nc">Parent1</span> <span class="k">is</span> <span class="nc">Parent2</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></div><p>如果在子类中调用一个方法, 但是子类没有提供那个方法, 就会调用父类中同名的方法, 如果父类中存在那个方法的话. 父类被询问的顺序就叫做方法解析顺序(MRO). Raku 使用 C3 方法解析顺序. 你可以通过调用一个类型的元类型方法得知这个类型的 MRO.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Parcel</span><span class="o">.^</span><span class="nb">mro</span><span class="p">;</span>    <span class="c1"># Parcel() Cool() Any() Mu()</span>
</span></span></code></pre></div><p>如果一个类没有指定它的父类, 就假定默认为 <code>Any</code>. 所有的类都直接或间接的派生于 Mu-类型层级的根.</p>
<h2 id="对象构造">对象构造</h2>
<p>对象通常通过方法调用创建, 或者通过类型对象或者通过同类型的其它对象创建. 类 Mu 提供了一个叫做 new 的构造器方法, 这个方法接收命名参数然后使用它们来初始化公共属性.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nv">$!x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$p</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">y</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">#             ^^^ 继承自类 Mu</span>
</span></span></code></pre></div><p><code>Mu.new</code> 在调用者身上调用 <code>bless</code> 方法, 传递所有的具名参数. bless 创建新的对象, 然后调用该对象的 <code>BUILDALL</code> 方法.  <strong>BUILDALL</strong> 以<code>相反的</code>方法解析顺序(继承层级树自上而下)遍历所有子类(例如, 从 Mu 到 派生类), 并且在每个类中检查名为 <code>BUILD</code> 的方法是否存在。 如果存在就调用它, 再把传递给 new 方法的所有具名参数传递给这个 <code>BUILD</code> 方法。 如果没有, 这个类的公开属性就会用<code>同名的</code>具名参数进行初始化.  这两种情况下, 如果 <strong>BULID</strong> 方法和 <strong>默认构造函数</strong> 都没有对属性进行初始化, 就会应用默认值 (上面例子中的 <code>2 * $!x</code>)。</p>
<p>这种构造模式对于自定义构造器有几处暗示. 首先, 自定义 BUILD 方法应该总是子方法(submethod), 否则它们会中断子类中的属性初始化. 第二, BUILD 子方法能用于在对象构造时执行自定义代码. 它们也能用于为属性初始化<strong>创建别名</strong>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">EncodedBuffer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.enc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(:</span><span class="s">encoding</span><span class="p">(</span><span class="o">:</span><span class="nv">$enc</span><span class="p">)</span><span class="o">,</span> <span class="o">:</span><span class="nv">$data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!enc</span>  <span class="o">:=</span> <span class="nv">$enc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!data</span> <span class="o">:=</span> <span class="nv">$data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$b1</span> <span class="o">=</span> <span class="n">EncodedBuffer</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">encoding</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">UTF-8</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">data</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">64</span><span class="o">,</span> <span class="mi">65</span><span class="o">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$b2</span> <span class="o">=</span> <span class="n">EncodedBuffer</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">enc</span>      <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">UTF-8</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">data</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">64</span><span class="o">,</span> <span class="mi">65</span><span class="o">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  现在 enc 和 encoding 都被允许</span>
</span></span></code></pre></div><p>因为传递实参给子例程把实参绑定给了形参, 如果把属性用作形参,单独绑定那一步就不需要了. 所以上面的例子可以写为:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(:</span><span class="s">encoding</span><span class="p">(</span><span class="o">:</span><span class="nv">$!enc</span><span class="p">)</span><span class="o">,</span> <span class="o">:</span><span class="nv">$!data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># nothing to do here anymore, the signature binding</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># does all the work for us.</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>第三个暗示是如果你想要一个接收位置参数的构造函数, 你必须自己写 new 方法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span><span class="nv">$x</span><span class="o">,</span> <span class="nv">$y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span><span class="o">*,</span> <span class="o">:</span><span class="nv">$x</span><span class="o">,</span> <span class="o">:</span><span class="nv">$y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>然而, 这不是最佳实践, 因为这让来自子类的对象的初始化正确更难了.</p>
<h2 id="roles">Roles</h2>
<p>Roles 在某种程度上和类相似, 它们都是属性和方法的集合. 不同之处在于,  roles 是用来描述对象行为的某<strong>一部分</strong>的, 和 roles 怎样应用于类中. 或怎样解析。 类用于管理对象实例, 而 roles 用于<strong>管理行为</strong>和<strong>代码复用</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">Serializable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">serialize</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">self</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span> <span class="c1"># 很粗超的序列化</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">deserialization-code</span><span class="p">(</span><span class="nv">$buf</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">EVAL</span> <span class="nv">$buf</span><span class="p">;</span> <span class="c1">#  反转 .perl 操作</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span> <span class="k">does</span> <span class="nc">Serializable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$p</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">y</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$serialized</span> <span class="o">=</span> <span class="nv">$p</span><span class="o">.</span><span class="nf">serialize</span><span class="p">;</span>      <span class="c1"># 由 role 提供的方法</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$clone-of-p</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="nf">deserialization-code</span><span class="p">(</span><span class="nv">$serialized</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$clone-of-p</span><span class="o">.</span><span class="nb">x</span><span class="p">;</span>      <span class="c1"># 1</span>
</span></span></code></pre></div><p>编译器一解析到 role 声明的闭合花括号, roles 就不可变了。</p>
<h2 id="role-application">Role Application</h2>
<p>Role 应用和类继承有重大不同。 当 role 应用到类中时, 那个 role 的方法被复制到类中。如果多个 roles 被应用到同一个类中, 冲突( 例如同名的非 multi 方法(s) )会导致编译时错误, 这可以通过在类中提供一个同名的方法来解决冲突。
这比多重继承更安全, 在冲突从来不会被编译器检测到的地方, 但是代替的是借助于在 MRO 中出现更早的父类, 这可能是也可能不是程序员想要的。</p>
<p>当一个 role 被应用到第二个 role上, 实际的程序被延迟直到第二个 role 被应用到类, 这时两个 roles 才都被应用到那个类中。 因此：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">R1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># methods here</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">R2</span> <span class="k">does</span> <span class="nc">R1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># methods here</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="k">does</span> <span class="nc">R2</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></div><p>等价于：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">role</span> <span class="n">R1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># methods here</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">role</span> <span class="n">R2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># methods here</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">class</span> <span class="n">C</span> <span class="n">does</span> <span class="n">R2</span> <span class="n">does</span> <span class="n">R1</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></div><h2 id="stubs">Stubs</h2>
<p>当 role 中包含了一个 stubbed 方法, 在这个 role 被应用到类中时, 必须提供一个同名的非 stubbed 版本的方法。这允许你创建如抽象接口那样的 roles。这有点像 Swift 中的 Protocol 协议。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">AbstractSerializable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">serialize</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>  <span class="c1"># 字面的三个点 ... 把方法标记为 stub</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#  下面是一个编译时错误, 例如</span>
</span></span><span class="line"><span class="cl"><span class="c1">#        Method &#39;serialize&#39; must be implemented by APoint because</span>
</span></span><span class="line"><span class="cl"><span class="c1">#        it is required by a role</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">APoint</span> <span class="k">does</span> <span class="nc">AbstractSerializable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 这个有效:</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SPoint</span> <span class="k">does</span> <span class="nc">AbstractSerializable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">serialize</span><span class="p">()</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">p(</span><span class="nv">$.x</span><span class="s2">, </span><span class="nv">$.y</span><span class="s2">)</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>那个 stubbed 方法的实现也可能由另外一个 role 提供。</p>
<p>TODO: 参数化的 roles</p>
<h2 id="元对象编程和自省">元对象编程和自省</h2>
<p>Raku 有一个元对象系统, 这意味着对象,类,roles,grammars,enums 它们自身的行为都被其它对象控制; 那些对象叫做元对象(想想元操作符, 它操作的对象是普通操作符). 元对象, 像普通对象一样,  是类的实例, 这时我们称它们为元类.</p>
<p>对每个对象或类, 你能通过调用 <code>.HOW</code>方法获取元对象. 注意, 尽管这看起来像是一个方法调用, 然而它实际上是编译器中的特殊案列, 所以它更像一个 macro.</p>
<p>所以, 你能用元对象干些什么呢? 你可以通过比较元类的相等性来检查两个对象是否具有同样的元类:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">.</span><span class="nb">HOW</span> <span class="o">===</span>   <span class="mi">2</span><span class="o">.</span><span class="nb">HOW</span><span class="p">;</span>      <span class="c1"># True</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">.</span><span class="nb">HOW</span> <span class="o">===</span> <span class="kt">Int</span><span class="o">.</span><span class="nb">HOW</span><span class="p">;</span>      <span class="c1"># True</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">.</span><span class="nb">HOW</span> <span class="o">===</span> <span class="kt">Num</span><span class="o">.</span><span class="nb">HOW</span><span class="p">;</span>      <span class="c1"># False</span>
</span></span></code></pre></div><p>Raku 使用单词 <code>HOW</code>, Higher Order Workings, 来引用元对象系统. 因此, 在 Rakudo 中不必对此吃惊, 控制类行为的元类的类名叫做 <code>Raku::Metamodel::ClassHow</code>. 每个类都有一个 <code>Raku::Metamodel::ClassHOW</code>的实例.</p>
<p>但是,理所当然的, 元模型为你做了很多. 例如它允许你内省对象和类.  元对象方法调用的约定是, 在元对象上调用方法, 并且传递感兴趣的对象作为对象的第一参数. 所以, 要获取对象的类名, 你可以这样写:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$object</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$metaobject</span> <span class="o">=</span> <span class="mi">1</span><span class="o">.</span><span class="nb">HOW</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$metaobject</span><span class="o">.</span><span class="nb">name</span><span class="p">(</span><span class="nv">$object</span><span class="p">);</span>      <span class="c1"># Int</span>
</span></span><span class="line"><span class="cl"><span class="c1"># or shorter:</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nb">name</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>                  <span class="c1"># Int</span>
</span></span></code></pre></div><p>为了避免使用同一个对象两次, 有一个便捷写法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>                        <span class="c1"># Int</span>
</span></span><span class="line"><span class="cl"><span class="c1"># same as</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nb">name</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>                  <span class="c1"># Int</span>
</span></span></code></pre></div><h2 id="内省">内省</h2>
<p>内省就是在运行时获取对象或类的信息的过程. 在 Raku 中,  所有的内省都会搜查原对象. 标准的基于类对象的 ClassHow 提供了这些工具:</p>
<h3 id="can">can</h3>
<p>给定一个方法名, 它返回一个Parcel, 这个 Parcel 里面是可用的方法名</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span>      <span class="p">{</span> <span class="k">method</span> <span class="nb">x</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="p">{}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="k">is</span> <span class="nc">A</span> <span class="p">{</span> <span class="k">method</span> <span class="nb">x</span><span class="p">()</span>   <span class="p">{}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">B</span><span class="o">.^</span><span class="nb">can</span><span class="p">(&#39;</span><span class="s1">x</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>              <span class="c1"># 2</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">B</span><span class="o">.^</span><span class="nb">can</span><span class="p">(&#39;</span><span class="s1">x</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">.</span><span class="nb">arity</span><span class="p">;</span>                     <span class="c1"># 1, 2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这个例子中, 类 B 中有两个名为 x 的方法可能可用(尽管一个正常的方法调用仅仅会直接调用安置在 B 中那个方法). B 中的那个方法有一个参数(例如, 它期望一个参数, 一个调用者(self)), 而 A 中的 x 方法期望 2 个参数( self 和 $a).</p>
<h3 id="methods">methods</h3>
<p>返回类中可用公共方法的列表( 这包括父类和 roles 中的方法). 默认它会停在类 Cool, Any 或 Mu 那儿; 若真要获取所有的方法, 使用副词 <code>:all</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">x</span><span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">A</span><span class="o">.^</span><span class="nb">methods</span><span class="p">();</span>                   <span class="c1"># x</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">A</span><span class="o">.^</span><span class="nb">methods</span><span class="p">(:</span><span class="s">all</span><span class="p">);</span>               <span class="c1"># x infinite defined ...</span>
</span></span></code></pre></div><h3 id="mro">mro</h3>
<p>按方法解析顺序返回类自身的列表和它们的父类.  当方法被调用时, 类和它的父类按那个顺序被访问.(仅仅是概念上; 实际上方法列表在类构建是就创建了).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">.^</span><span class="nb">mro</span><span class="p">;</span>                         <span class="c1"># (Int) (Cool) (Any) (Mu)</span>
</span></span></code></pre></div><h3 id="name">name</h3>
<p>返回类的名字:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a string</span><span class="p">&#39;</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>               <span class="c1"># Str</span>
</span></span></code></pre></div><h3 id="parents">parents</h3>
<p>返回一个父类的列表. 默认它会停在 Cool, Any 或者 Mu 那儿, 但你可以提供一个副词 <code>:all</code>来压制它. 使用副词 <code>:tree</code> 会返回一个嵌套列表.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">D</span>             <span class="p">{</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C1</span> <span class="k">is</span> <span class="nc">D</span>       <span class="p">{</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C2</span> <span class="k">is</span> <span class="nc">D</span>       <span class="p">{</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="k">is</span> <span class="nc">C1</span> <span class="k">is</span> <span class="nc">C2</span> <span class="p">{</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="k">is</span> <span class="nc">B</span>        <span class="p">{</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">A</span><span class="o">.^</span><span class="nb">parents</span><span class="p">(:</span><span class="s">all</span><span class="p">)</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>          <span class="c1"># (B, C1, C2, D, Any, Mu)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">A</span><span class="o">.^</span><span class="nb">parents</span><span class="p">(:</span><span class="s">all</span><span class="o">,</span> <span class="p">:</span><span class="s">tree</span><span class="p">)</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ([B, [C1, [D, [Any, [Mu]]]], [C2, [D, [Any, [Mu]]]]],)</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[数值]]></title>
            <link href="http://localhost:1313/rakulang/52.numerics/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/a-tour-of-spark-structured-streaming/?utm_source=atom_feed" rel="related" type="text/html" title="Spark 结构化流之旅" />
                <link href="http://localhost:1313/notes/write-parquet-to-kafka/?utm_source=atom_feed" rel="related" type="text/html" title="读取 Parquet 并写回 Kafka" />
                <link href="http://localhost:1313/rakulang/51.newline-handling-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的换行处理" />
                <link href="http://localhost:1313/notes/nim/?utm_source=atom_feed" rel="related" type="text/html" title="Nim" />
                <link href="http://localhost:1313/rakulang/50.native-calling-interface/?utm_source=atom_feed" rel="related" type="text/html" title="原生调用接口" />
            
                <id>http://localhost:1313/rakulang/52.numerics/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-27T21:13:31+08:00</published>
            <updated>2018-11-27T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="int">Int</h1>
<p><code>Int</code> 类型提供任意大小的整数。它们可以像计算机内存允许的那样大，虽然有些实现在被要求生成真正惊人大小的整数时会选择抛出数字溢出错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">10</span><span class="o">**</span><span class="mi">600</span><span class="o">**</span><span class="mi">600</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Numeric overflow» </span>
</span></span></code></pre></div><p>与某些语言不同，当两个操作数都是 <a href="https://docs.raku.org/type/Int">Int</a> 类型时，使用<a href="https://docs.raku.org/routine/$SOLIDUS"><code>/</code>运算符</a>执行除法将生成小数，而不执行任何舍入。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">4</span><span class="o">/</span><span class="mi">5</span><span class="p">;</span> <span class="c1"># OUTPUT: «0.8» </span>
</span></span></code></pre></div><p>这种除法产生的类型是 <a href="https://docs.raku.org/type/Rat">Rat</a> 或 <a href="https://docs.raku.org/type/Num">Num</a> 类型。换算后，如果分数的分母是小于64位，则产生 <a href="https://docs.raku.org/type/Rat">Rat</a>, 否则产生 <a href="https://docs.raku.org/type/Num">Num</a> 类型。</p>
<p>如果你想落得 <a href="https://docs.raku.org/type/Int">Int</a> 的结果，那么 <a href="https://docs.raku.org/routine/div">div</a> 和 <a href="https://docs.raku.org/routine/narrow">narrow</a> 例程可能会有帮助，只要有可能。<a href="https://docs.raku.org/routine/div">div</a>运算符执行整除，丢弃余数，而<a href="https://docs.raku.org/routine/narrow">narrow</a> 会把数拟合到它适合的最窄类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">5</span> <span class="ow">div</span> <span class="mi">2</span><span class="p">;</span> <span class="c1"># OUTPUT: «2» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Result `2` is narrow enough to be an Int: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">4</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">narrow</span><span class="p">;</span> <span class="c1"># OUTPUT: «2» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">4</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">narrow</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># OUTPUT: «Int» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># But 2.5 has fractional part, so it ends up being a Rat type: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">narrow</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># OUTPUT: «Rat» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">narrow</span><span class="p">;</span>       <span class="c1"># OUTPUT: «2.5» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Denominator is too big for a Rat, so a Num is produced: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">10</span>⁹⁹<span class="p">;</span> <span class="c1"># OUTPUT: «1e-99» </span>
</span></span></code></pre></div><p>Raku 具有 <a href="https://docs.raku.org/type/FatRat">FatRat</a> 类型，可提供任意精度的分数。为什么在上一个例子中生成了有限精度的 <a href="https://docs.raku.org/type/Num">Num</a> 而不是 <a href="https://docs.raku.org/type/FatRat">FatRat</a> 类型？原因是：性能。大多数操作都很好，精度损失很少，因此不需要使用更昂贵的 <a href="https://docs.raku.org/type/FatRat">FatRat</a> 类型。如果您希望获得额外的精度，则需要自己实例化一个。</p>
<h1 id="numhttpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top"><code>Num</code></a></h1>
<p><a href="https://docs.raku.org/type/Num">Num</a> 类型提供 <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">双精度浮点</a>十进制数，在其他语言中有时被称为“doubles”。</p>
<p><a href="https://docs.raku.org/type/Num">Num</a> 字面量的写法是使用字母 <code>e</code> 与指数分割开。请记住，即使指数为零，字母<code>e</code> <strong>也是必需的</strong>，否则您将得到一个<a href="https://docs.raku.org/type/Rat">Rat</a> 有理数字面量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mf">42e0</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># OUTPUT: «Num» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mf">42.0</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># OUTPUT: «Rat» </span>
</span></span></code></pre></div><p>区分大小写的单词 <a href="https://docs.raku.org/type/Num#Inf">Inf</a> 和 <a href="https://docs.raku.org/type/Num#NaN">NaN</a> 分别表示特殊值 infinity 和 not-a-number。可以使用 U+221E INFINITY（<code>∞</code>）字符代替 <a href="https://docs.raku.org/type/Num#Inf">Inf</a>：</p>
<p>Raku  尽可能遵循<a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754-2008浮点运算标准，</a>计划在以后的语言版本中实现更多的一致性。该语言保证为任何给定的 <a href="https://docs.raku.org/type/Num">Num</a> 字面量选择最接近的可表示数字，并且确实支持负零和<a href="https://en.wikipedia.org/wiki/Denormal_number">非正规</a>（也称为“次正规”）。</p>
<p>请记住，像 <a href="https://docs.raku.org/routine/say">say</a> 或 <a href="https://docs.raku.org/routine/put">put</a> 这样的输出例程不会非常难以区分输出<a href="https://docs.raku.org/type/Numeric">数字</a>类型的方式，并且可能选择将<a href="https://docs.raku.org/type/Num">Num</a>显示为<a href="https://docs.raku.org/type/Int">Int</a>或<a href="https://docs.raku.org/type/Rat">Rat</a>数字。要获得更明确的输出字符串，请使用<a href="https://docs.raku.org/routine/perl">perl</a>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span>  <span class="mf">1e0</span><span class="p">;</span>      <span class="c1"># OUTPUT: «1» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mf">.5e0</span><span class="p">;</span>      <span class="c1"># OUTPUT: «0.5» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span>  <span class="mf">1e0</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span> <span class="c1"># OUTPUT: «1e0» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mf">.5e0</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span> <span class="c1"># OUTPUT: «0.5e0» </span>
</span></span></code></pre></div><h1 id="complexhttpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top"><code>Complex</code></a></h1>
<p><a href="https://en.wikipedia.org/wiki/Complex_plane">复平面</a>的<a href="https://docs.raku.org/type/Complex">复数</a>型数值。<a href="https://docs.raku.org/type/Complex">复数</a>对象包括两个 <a href="https://docs.raku.org/type/Num">Num</a> 对象以表示复数的<a href="https://docs.raku.org/routine/re">实部</a>和<a href="https://docs.raku.org/routine/im">虚部</a>。</p>
<p>要创建<a href="https://docs.raku.org/type/Complex">复数</a>，可以在任何其他非复数上使用<a href="https://docs.raku.org/routine/i">后缀<code>i</code>运算符</a>，可选择使用加法设置实部。要使用<code>i</code>运算符作用在 <code>NaN</code> 或 <code>Inf</code> 字面量上，请使用反斜杠将其与它们分开。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">42</span><span class="no">i</span><span class="p">;</span>      <span class="c1"># OUTPUT: «0+42i» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">73</span><span class="o">+</span><span class="mi">42</span><span class="no">i</span><span class="p">;</span>   <span class="c1"># OUTPUT: «73+42i» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">73</span><span class="o">+</span><span class="no">Inf</span>\<span class="no">i</span><span class="p">;</span> <span class="c1"># OUTPUT: «73+Inf\i» </span>
</span></span></code></pre></div><p>请记住，上面的语法只是一个附加表达式和优先级规则适用。它也不能用于禁止表达式的地方，例如常规参数中的字面量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Precedence of `*` is higher than that of `+` </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">73</span><span class="o">+</span><span class="mi">10</span><span class="no">i</span><span class="p">;</span> <span class="c1"># OUTPUT: «146+10i» </span>
</span></span></code></pre></div><p>为了避免这些问题，您可以选择使用<a href="https://docs.raku.org/type/Complex">复数</a>字面量语法，其中包括使用尖括号包围实部和虚部，<em>而不包含任何空格</em>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">&lt;</span><span class="s">73+10i</span><span class="p">&gt;;</span> <span class="c1"># OUTPUT: «146+20i» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">how-is-it</span> <span class="p">(&lt;</span><span class="s">2+4i</span><span class="p">&gt;)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">that&#39;s my favorite number!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">how-is-it</span> <span class="ow">(|)</span>      <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">meh</span><span class="p">&#34;</span>                        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">how-is-it</span> <span class="mi">2</span><span class="o">+</span><span class="mi">4</span><span class="no">i</span><span class="p">;</span>  <span class="c1"># OUTPUT: «that&#39;s my favorite number!» </span>
</span></span><span class="line"><span class="cl"><span class="n">how-is-it</span> <span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="no">i</span><span class="p">;</span>  <span class="c1"># OUTPUT: «meh» </span>
</span></span></code></pre></div><h1 id="rationalhttpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top"><code>Rational</code></a></h1>
<p>执行 <a href="https://docs.raku.org/type/Rational">Rational</a> 角色的类型提供高精度和任意精度的十进制数。由于精度越高，性能损失越大，<a href="https://docs.raku.org/type/Rational">Rational</a> 类型有两种形式：<a href="https://docs.raku.org/type/Rat">Rat</a> 和 <a href="https://docs.raku.org/type/FatRat">FatRat</a>。<a href="https://docs.raku.org/type/Rat">Rat</a> 是最常用的变体, 其在大多数情况下降级成 <a href="https://docs.raku.org/type/Num">Num</a>，当它不再能容纳所有的要求精度时。<a href="https://docs.raku.org/type/FatRat">FatRat</a> 是保持增长提供所有所需的精度任意精度的变体。</p>
<h2 id="rathttpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top"><code>Rat</code></a></h2>
<p>最常见的 <a href="https://docs.raku.org/type/Rational">Rational</a> 类型。它支持有 64 位分母的有理数（在将分数换算到最小分母之后）。<code>Rat</code> 可以直接创建具有较大分母的对象，但是，当具有这样的分母的 <code>Rat</code> 是数学运算的结果时，它们会降级为 <a href="https://docs.raku.org/type/Num">Num</a> 对象。</p>
<p>在许多其他语言中 <a href="https://docs.raku.org/type/Rat">Rat</a> 字面量使用和 <a href="https://docs.raku.org/type/Num">Num</a> 字面量类似的语法，使用点来表示数字是十进制：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mf">.1</span> <span class="o">+</span> <span class="mf">.2</span> <span class="o">==</span> <span class="mf">.3</span><span class="p">;</span> <span class="c1"># OUTPUT: «True» </span>
</span></span></code></pre></div><p>如果你在许多常用语言中执行与上述类似的语句, 由于浮点数学的精度，您将得到 <code>False</code> 作为答案。要在 Raku 中获得相同的结果，你必须使用 <a href="https://docs.raku.org/type/Num">Num</a> 字面量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mf">.1e0</span> <span class="o">+</span> <span class="mf">.2e0</span> <span class="o">==</span> <span class="mf">.3e0</span><span class="p">;</span> <span class="c1"># OUTPUT: «False» </span>
</span></span></code></pre></div><p>You can also use <a href="https://docs.raku.org/routine/$SOLIDUS"><code>/</code> division operator</a> with <a href="https://docs.raku.org/type/Int">Int</a> or <a href="https://docs.raku.org/type/Rat">Rat</a> objects to produce a <a href="https://docs.raku.org/type/Rat">Rat</a>:</p>
<p>您还可以使用具有 <a href="https://docs.raku.org/type/Int">Int</a> 或 <a href="https://docs.raku.org/type/Rat">Rat</a> 对象的<a href="https://docs.raku.org/routine/$SOLIDUS"><code>/</code>除法运算符</a>来生成 <a href="https://docs.raku.org/type/Rat">Rat</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>     <span class="c1"># OUTPUT: «0.75» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">3</span><span class="o">/</span><span class="mf">4.2</span><span class="p">;</span>   <span class="c1"># OUTPUT: «0.714286» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mf">1.1</span><span class="o">/</span><span class="mf">4.2</span><span class="p">;</span> <span class="c1"># OUTPUT: «0.261905» </span>
</span></span></code></pre></div><p>Keep in mind the above syntax is just a division expression and precedence rules apply. It also cannot be used in places that forbid expressions, such as literals in routine parameters.</p>
<p>请记住，上面的语法只是一个应用了优先级规则的除法表达式。它也不能用于禁止表达式的地方，例如例程参数中的字面量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Precedence of power operators is higher than division </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span>²<span class="p">;</span> <span class="c1"># OUTPUT: «0.75» </span>
</span></span></code></pre></div><p>为了避免这些问题，您可以选择使用 <a href="https://docs.raku.org/type/Rational">Rational</a> 字面量语法，它用尖括号括起分子和分母，<em>不带任何空格</em>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">3/2</span><span class="p">&gt;</span>²<span class="p">;</span> <span class="c1"># OUTPUT: «2.25» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">how-is-it</span> <span class="p">(&lt;</span><span class="s">3/2</span><span class="p">&gt;)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">that&#39;s my favorite number!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">how-is-it</span> <span class="ow">(|)</span>     <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">meh</span><span class="p">&#34;</span>                        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">how-is-it</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>  <span class="c1"># OUTPUT: «that&#39;s my favorite number!» </span>
</span></span><span class="line"><span class="cl"><span class="n">how-is-it</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">;</span>  <span class="c1"># OUTPUT: «meh» </span>
</span></span></code></pre></div><p>最后，任何具有 <code>No</code> 属性的表示小数的 Unicode 字符都可以用作<a href="https://docs.raku.org/type/Rat">Rat</a> 字面量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> ½ <span class="o">+</span> ⅓ <span class="o">+</span> ⅝ <span class="o">+</span> ⅙<span class="p">;</span> <span class="c1"># OUTPUT: «1.625» </span>
</span></span></code></pre></div><h3 id="分解为-numhttpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">分解为 <code>Num</code></a></h3>
<p>If a <em>mathematical operation</em> that produces a <a href="https://docs.raku.org/type/Rat">Rat</a> answer would produce a <a href="https://docs.raku.org/type/Rat">Rat</a> with denominator larger than 64 bits, that operation would instead return a <a href="https://docs.raku.org/type/Num">Num</a> object. When <em>constructing</em> a <a href="https://docs.raku.org/type/Rat">Rat</a> (i.e. when it is not a result of some mathematical expression), however, a larger denominator can be used:</p>
<p>如果产生 <a href="https://docs.raku.org/type/Rat">Rat</a> 答案的<em>数学运算</em>会产生分母大于64位的 <a href="https://docs.raku.org/type/Rat">Rat</a>，则该操作将返回 <a href="https://docs.raku.org/type/Num">Num</a> 对象。当<em>构建</em>一个<a href="https://docs.raku.org/type/Rat">Rat</a>（即，当它不是一些数学表达式的结果）时，但是，更大的分母可以使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span>⁶⁴ <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="p">;</span>                   <span class="c1"># OUTPUT: «0.000000000000000000054» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>             <span class="c1"># OUTPUT: «Rat» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="o">.</span><span class="nb">nude</span><span class="p">;</span>              <span class="c1"># OUTPUT: «(1 18446744073709551615)» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span>⁶⁴<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$b</span><span class="p">;</span>                   <span class="c1"># OUTPUT: «5.421010862427522e-20» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$b</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>             <span class="c1"># OUTPUT: «Num» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="kt">Rat</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span>⁶⁴<span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$c</span><span class="p">;</span>                   <span class="c1"># OUTPUT: «0.000000000000000000054» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$c</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>             <span class="c1"># OUTPUT: «Rat» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$c</span><span class="o">.</span><span class="nb">nude</span><span class="p">;</span>              <span class="c1"># OUTPUT: «(1 18446744073709551616)» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$c</span><span class="o">.</span><span class="kt">Num</span><span class="p">;</span>               <span class="c1"># OUTPUT: «5.421010862427522e-20» </span>
</span></span></code></pre></div><h2 id="fatrathttpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top"><code>FatRat</code></a></h2>
<p>最后一个 <a href="https://docs.raku.org/type/Rational">Rational</a> 类型 - <a href="https://docs.raku.org/type/FatRat">FatRat</a> - 保留你所要求的所有精度，将分子和分母存储为两个 <a href="https://docs.raku.org/type/Int">Int</a> 对象。<a href="https://docs.raku.org/type/FatRat">FatRat</a> 比 <a href="https://docs.raku.org/type/Rat">Rat</a> 更具传染性，有这么多的 <a href="https://docs.raku.org/type/FatRat">FatRat</a> 数学运算会产生另一个 <a href="https://docs.raku.org/type/FatRat">FatRat</a>，保留所有可用的精度。当 <a href="https://docs.raku.org/type/Rat">Rat</a> 退化为 <a href="https://docs.raku.org/type/Num">Num</a> 时，使用 <a href="https://docs.raku.org/type/FatRat">FatRat </a> 的数学运算会持续不断：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">((</span><span class="mi">42</span> <span class="o">+</span> <span class="kt">Rat</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="mi">999999999999999999</span><span class="p">)</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>         <span class="c1"># OUTPUT: «Rat» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">((</span><span class="mi">42</span> <span class="o">+</span> <span class="kt">Rat</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="mi">9999999999999999999</span><span class="p">)</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>        <span class="c1"># OUTPUT: «Num» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">((</span><span class="mi">42</span> <span class="o">+</span> <span class="kt">FatRat</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="mi">999999999999999999</span><span class="p">)</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>      <span class="c1"># OUTPUT: «FatRat» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">((</span><span class="mi">42</span> <span class="o">+</span> <span class="kt">FatRat</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="mi">99999999999999999999999</span><span class="p">)</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># OUTPUT: «FatRat» </span>
</span></span></code></pre></div><p>没有特殊的运算符或语法可用于构造 <a href="https://docs.raku.org/type/FatRat">FatRat</a> 对象。只需使用 <a href="https://docs.raku.org/type/FatRat#%28Rational%29_method_new"><code>FatRat.new</code></a> 方法，将分子作为第一个位置参数，将分母作为第二个位置参数。</p>
<p>如果您的程序需要大量的 <a href="https://docs.raku.org/type/FatRat">FatRat</a> 创建，您可以创建自己的自定义运算符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">🙼</span><span class="p">&gt;</span> <span class="p">{</span> <span class="kt">FatRat</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="nv">$^a</span><span class="o">,</span> <span class="nv">$^b</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span>🙼<span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span> <span class="c1"># OUTPUT: «FatRat.new(1, 3)» </span>
</span></span></code></pre></div><h2 id="打印-rationalshttpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">打印 rationals</a></h2>
<p>请记住，像 <a href="https://docs.raku.org/routine/say">say</a> 或 <a href="https://docs.raku.org/routine/put">put</a> 这样的输出例程不会力图区分<a href="https://docs.raku.org/type/Numeric">数字</a>类型如何输出，并且可能选择将 <a href="https://docs.raku.org/type/Num">Num</a> 显示为 <a href="https://docs.raku.org/type/Int">Int</a> 或 <a href="https://docs.raku.org/type/Rat">Rat</a> 数字。要获得更明确的输出字符串，请使用 <a href="https://docs.raku.org/routine/perl">perl</a> 方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mf">1.0</span><span class="p">;</span>        <span class="c1"># OUTPUT: «1» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> ⅓<span class="p">;</span>          <span class="c1"># OUTPUT: «0.333333» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mf">1.0</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>   <span class="c1"># OUTPUT: «1.0» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> ⅓<span class="o">.</span><span class="nb">perl</span><span class="p">;</span>     <span class="c1"># OUTPUT: «&lt;1/3&gt;» </span>
</span></span></code></pre></div><p>有关更多信息，您可以选择在 <a href="https://docs.raku.org/routine/nude">nude</a> 中查看 <a href="https://docs.raku.org/type/Rational">Rational</a> 对象，显示其分子和分母：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> ⅓<span class="p">;</span>          <span class="c1"># OUTPUT: «0.333333» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">4</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>        <span class="c1"># OUTPUT: «2» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> ⅓<span class="o">.</span><span class="nb">perl</span><span class="p">;</span>     <span class="c1"># OUTPUT: «&lt;1/3&gt;» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">4/2</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">nude</span><span class="p">;</span> <span class="c1"># OUTPUT: «(2 1)» </span>
</span></span></code></pre></div><h1 id="division-by-zerohttpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">Division by zero</a></h1>
<p>在许多语言中，除以零立马会抛出一个异常。在 Raku 中，会发生什么取决于你要除的东西以及你如何使用结果。</p>
<p>Raku 遵循 <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754-2008浮点运算标准</a>，但由于历史原因，6.c 和 6.d 语言版本不完全符合。<a href="https://docs.raku.org/type/Num">Num</a>被零除产生 <a href="https://docs.raku.org/type/Failure">Failure</a>，而<a href="https://docs.raku.org/type/Complex">复数</a>被零除产生 <code>NaN</code> 部件, 无论分子是什么。</p>
<p>从 6.e 语言开始，<a href="https://docs.raku.org/type/Num">Num</a> 和 <a href="https://docs.raku.org/type/Complex">Complex</a> 除以零将产生<a href="https://docs.raku.org/type/Num#Inf">-Inf</a>，<code>+Inf</code> 或 <a href="https://docs.raku.org/type/Num#NaN">NaN</a>, 这取决于分子分别是负数，正数还是零（对于<a href="https://docs.raku.org/type/Complex">复数</a>，实部和虚部是 <a href="https://docs.raku.org/type/Num">Num</a> 并且被分别考虑）。</p>
<p><a href="https://docs.raku.org/type/Int">Int</a> 数字的除法产生一个 <a href="https://docs.raku.org/type/Rat">Rat</a> 对象（或 <a href="https://docs.raku.org/type/Num">Num</a>，如果在换算之后分母大于64位，当你除以零时就不是这种情况）。这意味着这种除法永远不会产生<a href="https://docs.raku.org/type/Exception">异常</a>或<a href="https://docs.raku.org/type/Failure">失败</a>。结果是零分母有理数，这可能是爆炸性的。</p>
<h2 id="zero-denominator-rationalshttpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">Zero-denominator rationals</a></h2>
<p><a href="https://docs.raku.org/type/FatRat">零分母</a> 有理数是一个扮演 <a href="https://docs.raku.org/type/Rational">Rational</a> 角色的数字，它在核心数字中将是 <a href="https://docs.raku.org/type/Rat">Rat</a> 和 <a href="https://docs.raku.org/type/FatRat">FatRat</a> 对象，其分母为零。这样根据原始分子是否为负，分别为零或正数, 有理数的分子被归一化到<code>-1</code>，<code>0</code>或<code>1</code>。</p>
<p>可以在不需要实际除法的情况下执行的操作是非爆炸性的。例如，您可以单独检查 <a href="https://docs.raku.org/routine/nude">nude</a> 中的<a href="https://docs.raku.org/routine/numerator">分子</a>和<a href="https://docs.raku.org/routine/denominator">分母</a>，或执行数学运算，而不会出现任何异常或失败。</p>
<p>转换零分母有理数到 <a href="https://docs.raku.org/type/Num">Num</a> 遵循 <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE</a> 公约，结果是<code>-Inf</code>，<code>Inf</code>，或 <code>NaN</code>，这取决于分子是否分别是负，正，或零。从另一个方面来看也是如此：转换<code>±Inf</code>/ <code>NaN</code>到其中一个 <a href="https://docs.raku.org/type/Rational">Rational</a> 类型将产生具有适当分子的零分母有理数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span>  <span class="p">&lt;</span><span class="s">1/0</span><span class="p">&gt;</span><span class="o">.</span><span class="kt">Num</span><span class="p">;</span>   <span class="c1"># OUTPUT: «Inf» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">-1/0</span><span class="p">&gt;</span><span class="o">.</span><span class="kt">Num</span><span class="p">;</span>   <span class="c1"># OUTPUT: «-Inf» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span>  <span class="p">&lt;</span><span class="s">0/0</span><span class="p">&gt;</span><span class="o">.</span><span class="kt">Num</span><span class="p">;</span>   <span class="c1"># OUTPUT: «NaN» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="no">Inf</span><span class="o">.</span><span class="kt">Rat</span><span class="o">.</span><span class="nb">nude</span><span class="p">;</span> <span class="c1"># OUTPUT: «(1 0)» </span>
</span></span></code></pre></div><p>要求非 <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE</a> 除法的分子和分母的所有其他操作将导致抛出异常 <code>X::Numeric::DivideByZero</code>。最常见的此类操作可能是尝试打印或字符串化零分母有理数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">0</span><span class="o">/</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Attempt to divide by zero using div </span>
</span></span><span class="line"><span class="cl"><span class="c1">#  in block &lt;unit&gt; at -e line 1 </span>
</span></span></code></pre></div><h1 id="同质异形httpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">同质异形</a></h1>
<p><a href="https://docs.raku.org/language/glossary#index-entry-Allomorph">Allomorphs</a> 是两种类型的子类，可以表现为它们中的任何一种。例如，同质异形 <a href="https://docs.raku.org/type/IntStr">IntStr</a> 是 <a href="https://docs.raku.org/type/Int">Int</a> 和 <a href="https://docs.raku.org/type/Str">Str</a> 类型的子类，并且将被需要 <a href="https://docs.raku.org/type/Int">Int</a> 或 <a href="https://docs.raku.org/type/Str">Str</a> 对象的任何类型约束所接受。</p>
<p>同质异形可以使用<a href="https://docs.raku.org/language/quoting#Word_quoting%3A_%3C_%3E">尖括号</a>创建，可以单独使用或作为散列键查找的一部分使用; 直接使用方法<code>.new</code>，也由一些结构提供，如 <a href="https://docs.raku.org/language/functions#sub_MAIN"><code>sub MAIN</code></a> 的参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">42</span><span class="p">&gt;</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>                 <span class="c1"># OUTPUT: «IntStr» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">42e0</span><span class="p">&gt;</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>               <span class="c1"># OUTPUT: «NumStr» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s"> 42+42i</span><span class="p">&gt;</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>            <span class="c1"># OUTPUT: «ComplexStr» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s"> 1/2</span><span class="p">&gt;</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>               <span class="c1"># OUTPUT: «RatStr» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">0.5</span><span class="p">&gt;</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>                <span class="c1"># OUTPUT: «RatStr» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="vg">@*ARGS</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">42</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$x</span><span class="o">.^</span><span class="nb">name</span> <span class="p">}</span>   <span class="c1"># OUTPUT: «IntStr» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="kt">IntStr</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">42</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">42</span><span class="p">&#34;)</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># OUTPUT: «IntStr» </span>
</span></span></code></pre></div><p>上面的几个结构在打开角括号之后有一个空格。那个空格不是故意的。通常使用运算符编写的数字，例如<code>1/2</code>（<a href="https://docs.raku.org/type/Rat">Rat</a>，除法运算符）和<code>1+2i</code>（<a href="https://docs.raku.org/type/Complex">复数</a>，加法）可以写成不涉及使用运算符的字面值：在尖括号和尖括号里面的字符之间<em>没有</em>任何空格。通过在尖括号中添加空格，我们告诉编译器我们不仅需要 <a href="https://docs.raku.org/type/Rat">Rat</a> 或 <a href="https://docs.raku.org/type/Complex">Complex</a> 字面量，而且我们还希望它是一个allomorph：在这种情况下是 <a href="https://docs.raku.org/type/RatStr">RatStr</a> 或 <a href="https://docs.raku.org/type/ComplexStr">ComplexStr</a>。</p>
<p>如果数字字面量不使用任何运算符，则将其写入尖括号内，即使不包含任何空格，也会产生同形异形体。（逻辑：如果你不想要同质异形，你就不会使用尖括号。对于使用运算符的数字也是如此，因为某些结构，例如签名字面量，不允许你使用运算符，所以你不能只为这些数字字面量省略尖括号）。</p>
<h2 id="可用的同质异形httpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">可用的同质异形</a></h2>
<p>核心语言提供以下同质异形：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Allomorph of</th>
<th style="text-align:left">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">IntStr</td>
<td style="text-align:left">Int and Str</td>
<td style="text-align:left">&lt;42&gt;</td>
</tr>
<tr>
<td style="text-align:left">NumStr</td>
<td style="text-align:left">Num and Str</td>
<td style="text-align:left">&lt;42e0&gt;</td>
</tr>
<tr>
<td style="text-align:left">ComplexStr</td>
<td style="text-align:left">Complex and Str</td>
<td style="text-align:left">&lt; 1+2i&gt;</td>
</tr>
<tr>
<td style="text-align:left">RatStr</td>
<td style="text-align:left">Rat and Str</td>
<td style="text-align:left">&lt;1.5&gt;</td>
</tr>
</tbody>
</table>
<p>注意：没有<code>FatRatStr</code>类型。</p>
<h2 id="coercion-of-allomorphshttpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">Coercion of allomorphs</a></h2>
<p>请记住，同质异形只是它们所代表的两种（或三种）类型的子类。正如变量或参数类型约束为<code>Foo</code>可以接受任何 <code>Foo</code> 子类一样，所以变量或参数类型约束为 <a href="https://docs.raku.org/type/Int">Int</a> 的将接受 <a href="https://docs.raku.org/type/IntStr">IntStr</a> 同质异形：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$x</span><span class="o">.^</span><span class="nb">name</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">foo</span> <span class="p">&lt;</span><span class="s">42</span><span class="p">&gt;;</span>                          <span class="c1"># OUTPUT: «IntStr» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Num</span> <span class="nv">$y</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">42e0</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$y</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>                      <span class="c1"># OUTPUT: «NumStr» </span>
</span></span></code></pre></div><p>当然，这也适用于参数<a href="https://docs.raku.org/type/Signature#Coercion_type">coercers</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">Int</span><span class="p">(</span><span class="kt">Cool</span><span class="p">)</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$x</span><span class="o">.^</span><span class="nb">name</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">foo</span> <span class="p">&lt;</span><span class="s">42</span><span class="p">&gt;;</span>  <span class="c1"># OUTPUT: «IntStr» </span>
</span></span></code></pre></div><p>给定的同质异形<em>已经</em>是 <a href="https://docs.raku.org/type/Int">Int</a> 类型的对象，因此在这种情况下它不会转换为“普通的”  <a href="https://docs.raku.org/type/Int">Int</a>。</p>
<p>当然，如果没有办法将它们“折叠”到其中一个组件，那么同质异形体的力量将会严重减弱。因此，如果你使用所要强制到的类型的名字显式调用方法，那么您将获得该组件。这同样适用于任何代理方法，例如调用方法<a href="https://docs.raku.org/routine/Numeric"><code>.Numeric</code></a>而不是<a href="https://docs.raku.org/routine/Int"><code>.Int</code></a>或使用<a href="https://docs.raku.org/routine/~"><code>prefix:&lt;~&gt; </code></a>运算符而不是<a href="https://docs.raku.org/routine/Str"><code>.Str</code></a>方法调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$al</span> <span class="o">:=</span> <span class="kt">IntStr</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">forty two</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$al</span><span class="o">.</span><span class="kt">Str</span><span class="p">;</span>  <span class="c1"># OUTPUT: «forty two» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">+</span><span class="nv">$al</span><span class="p">;</span>     <span class="c1"># OUTPUT: «42» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">1/99999999999999999999</span><span class="p">&gt;</span><span class="o">.</span><span class="kt">Rat</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>    <span class="c1"># OUTPUT: «Rat» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">1/99999999999999999999</span><span class="p">&gt;</span><span class="o">.</span><span class="kt">FatRat</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># OUTPUT: «FatRat» </span>
</span></span></code></pre></div><p>强制整个同质异形体列表的一种方便方法是将 <a href="https://docs.raku.org/language/operators#Hyper_operators">hyper</a> 运算符应用于适当的前缀：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">map</span> <span class="o">*.^</span><span class="nb">name</span><span class="o">,</span>   <span class="p">&lt;</span><span class="s">42 50e0 100</span><span class="p">&gt;;</span>  <span class="c1"># OUTPUT: «(IntStr NumStr IntStr)» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">map</span> <span class="o">*.^</span><span class="nb">name</span><span class="o">,</span> <span class="o">+</span><span class="p">«</span><span class="s2">&lt;42 50e0 100&gt;;  # OUTPUT: «(Int Num Int)</span><span class="p">»</span> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">map</span> <span class="o">*.^</span><span class="nb">name</span><span class="o">,</span> <span class="o">~</span><span class="p">«</span><span class="s2">&lt;42 50e0 100&gt;;  # OUTPUT: «(Str Str Str)</span><span class="p">»</span> 
</span></span></code></pre></div><h2 id="object-identityhttpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">Object identity</a></h2>
<p>当我们考虑对象一致性时，上面关于强制同形异形的讨论变得更加重要。一些构造利用它来确定两个对象是否“相同”。而对于人类而言，同质异形<code>42</code>和常规的<code>42</code>可能看起来“相同”，对于那些构造，它们是完全不同的对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># &#34;42&#34; shows up twice in the result: 42 and &lt;42&gt; are different objects: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">unique</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&lt;</span><span class="s">42</span><span class="p">&gt;;</span> <span class="c1"># OUTPUT: «(1 42 42)» </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Use a different operator to `unique` with: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">unique</span> <span class="p">:</span><span class="s">with</span><span class="p">(</span><span class="o">&amp;[==]</span><span class="p">)</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&lt;</span><span class="s">42</span><span class="p">&gt;;</span> <span class="c1"># OUTPUT: «(1 42)» </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Or coerce the input instead (faster than using a different `unique` operator): </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">unique</span> <span class="p">:</span><span class="s">as</span><span class="p">(</span><span class="o">*.</span><span class="kt">Int</span><span class="p">)</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&lt;</span><span class="s">42</span><span class="p">&gt;;</span> <span class="c1"># OUTPUT: «(1 42)» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">unique</span> <span class="o">+</span><span class="p">«</span><span class="s2">(1, 1, 1, 42, &lt;42&gt;);         # OUTPUT: «(1 42)</span><span class="p">»</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Parameterized Hash with `Any` keys does not stringify them; our key is of type `Int`: </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span><span class="p">{</span><span class="kt">Any</span><span class="p">}</span> <span class="o">=</span> <span class="mi">42</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># But we use the allomorphic key of type `IntStr`, which is not in the Hash: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">42</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span>           <span class="c1"># OUTPUT: «False» </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Must use curly braces to avoid the allomorph: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="p">{</span><span class="mi">42</span><span class="p">}:</span><span class="s">exists</span><span class="p">;</span>           <span class="c1"># OUTPUT: «True» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># We are using a set operator to look up an `Int` object in a list of `IntStr` objects: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">42</span> <span class="o">∈</span> <span class="p">&lt;</span><span class="s">42 100 200</span><span class="p">&gt;;</span> <span class="c1"># OUTPUT: «False» </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Convert it to an allomorph: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">42</span><span class="p">&gt;</span> <span class="o">∈</span> <span class="p">&lt;</span><span class="s">42 100 200</span><span class="p">&gt;;</span> <span class="c1"># OUTPUT: «True» </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Or convert the items in the list to plain `Int` objects: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">42</span> <span class="o">∈</span> <span class="o">+</span><span class="p">«</span><span class="s2">&lt;42 100 200&gt;; # OUTPUT: «True</span><span class="p">»</span> 
</span></span></code></pre></div><p>注意这些对象一致性的差异，并根据需要强制你的同形异形体。</p>
<h1 id="原生数字httpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">原生数字</a></h1>
<p>顾名思义，原生数字可以访问原生数字 - 即由硬件直接提供的数字。这反过来又提供两个功能：溢出/下溢和更好的性能。</p>
<p>**注意：**在撰写本文时（2018.05），某些实现（例如 Rakudo）提供了有关原生类型的一些细节，例如  <code>int64</code> 是否可用且在32位计算机上具有64位大小，以及如何检测何时你的程序正在这样的硬件上运行。</p>
<h2 id="可用的原生数字httpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">可用的原生数字</a></h2>
<table>
<thead>
<tr>
<th style="text-align:left">Native type</th>
<th style="text-align:left">Base numeric</th>
<th style="text-align:left">Size</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">atomicint</td>
<td style="text-align:left">integer</td>
<td style="text-align:left">sized to offer CPU-provided atomic operations. (typically 64 bits on 64-bit platforms and 32 bits on 32-bit ones)</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">integer</td>
<td style="text-align:left">64-bits</td>
</tr>
<tr>
<td style="text-align:left">int16</td>
<td style="text-align:left">integer</td>
<td style="text-align:left">16-bits</td>
</tr>
<tr>
<td style="text-align:left">int32</td>
<td style="text-align:left">integer</td>
<td style="text-align:left">32-bits</td>
</tr>
<tr>
<td style="text-align:left">int64</td>
<td style="text-align:left">integer</td>
<td style="text-align:left">64-bits</td>
</tr>
<tr>
<td style="text-align:left">int8</td>
<td style="text-align:left">integer</td>
<td style="text-align:left">8-bits</td>
</tr>
<tr>
<td style="text-align:left">num</td>
<td style="text-align:left">floating point</td>
<td style="text-align:left">64-bits</td>
</tr>
<tr>
<td style="text-align:left">num32</td>
<td style="text-align:left">floating point</td>
<td style="text-align:left">32-bits</td>
</tr>
<tr>
<td style="text-align:left">num64</td>
<td style="text-align:left">floating point</td>
<td style="text-align:left">64-bits</td>
</tr>
<tr>
<td style="text-align:left">uint</td>
<td style="text-align:left">unsigned integer</td>
<td style="text-align:left">64-bits</td>
</tr>
<tr>
<td style="text-align:left">uint16</td>
<td style="text-align:left">unsigned integer</td>
<td style="text-align:left">16-bits</td>
</tr>
<tr>
<td style="text-align:left">uint32</td>
<td style="text-align:left">unsigned integer</td>
<td style="text-align:left">32-bits</td>
</tr>
<tr>
<td style="text-align:left">uint64</td>
<td style="text-align:left">unsigned integer</td>
<td style="text-align:left">64-bits</td>
</tr>
<tr>
<td style="text-align:left">uint8</td>
<td style="text-align:left">unsigned integer</td>
<td style="text-align:left">8-bits</td>
</tr>
</tbody>
</table>
<h2 id="创建原生数字httpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">创建原生数字</a></h2>
<p>要创建原生类型的变量或参数，只需使用其中一个可用数字的名称作为类型约束：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">int32</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="n">num</span> <span class="nv">$y</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="p">{</span> <span class="k">has</span> <span class="kt">int8</span> <span class="nv">$.z</span> <span class="p">}</span>
</span></span></code></pre></div><p>有时，您可能希望在不创建任何可用变量的情况下将某些值强制转换为原生类型。没有<code>.int</code>或类似的强制方法（方法调用是后期的，所以它们不适合这个目的）。相反，只需使用匿名变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">some-native-taking-sub</span> <span class="p">(</span><span class="k">my</span> <span class="kt">int</span> <span class="nv">$</span> <span class="o">=</span> <span class="nv">$y</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="k">my</span> <span class="kt">int32</span> <span class="nv">$</span> <span class="o">=</span> <span class="nv">$z</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="溢出下溢httpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">溢出/下溢</a></h2>
<p>尝试<strong>分配</strong>不适合特定原生类型的值会产生异常。这包括尝试为原生参数提供过大的参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">int</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">2</span>¹⁰⁰<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Cannot unbox 101 bit wide bigint into native integer </span>
</span></span><span class="line"><span class="cl"><span class="c1">#  in block &lt;unit&gt; at -e line 1 </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="kt">int</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="p">};</span> <span class="nb">say</span> <span class="nb">f</span> <span class="mi">2</span>⁶⁴
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Cannot unbox 65 bit wide bigint into native integer </span>
</span></span><span class="line"><span class="cl"><span class="c1">#   in sub f at -e line 1 </span>
</span></span><span class="line"><span class="cl"><span class="c1">#   in block &lt;unit&gt; at -e line 1 </span>
</span></span></code></pre></div><p>但是，以这样一种太大/太小的方式修改已存在的值会产生溢出/下溢行为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">int</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">2</span>⁶³<span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>             <span class="c1"># OUTPUT: «9223372036854775807» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">++</span><span class="nv">$x</span><span class="p">;</span>           <span class="c1"># OUTPUT: «-9223372036854775808» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">uint8</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>             <span class="c1"># OUTPUT: «0» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span> <span class="o">-=</span> <span class="mi">100</span><span class="p">;</span>      <span class="c1"># OUTPUT: «156» </span>
</span></span></code></pre></div><p>创建使用原生类型的对象不涉及程序员的直接分配; 这就是为什么这些构造提供溢出/下溢行为而不是抛出异常。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="kt">Buf</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">1000</span><span class="o">,</span> <span class="mi">2000</span><span class="o">,</span> <span class="mi">3000</span><span class="p">)</span><span class="o">.</span><span class="kt">List</span><span class="p">;</span> <span class="c1"># OUTPUT: «(232 208 184)» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="k">my</span> <span class="kt">uint8</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">,</span> <span class="mi">2000</span><span class="o">,</span> <span class="mi">3000</span><span class="p">;</span> <span class="c1"># OUTPUT: «232 208 184» </span>
</span></span></code></pre></div><h2 id="auto-boxinghttpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">Auto-boxing</a></h2>
<p>虽然它们可以被称为“<em>原生类型</em> ”，但原生数字实际上并不是具有任何可用方法的类。但是，您<em>可以</em>调用这些数字的非原生版本上可用的任何方法。这是怎么回事？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">int8</span> <span class="nv">$x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="o">.</span><span class="nb">abs</span><span class="p">;</span> <span class="c1"># OUTPUT: «42» </span>
</span></span></code></pre></div><p>此行为称为“自动装箱”。编译器使用所有方法自动将原生类型“装箱”为功能齐全的高级类型。换句话说，<code>int8</code>上面的内容自动转换为<a href="https://docs.raku.org/type/Int">Int，</a>然后它是<a href="https://docs.raku.org/type/Int">Int</a>类，然后提供被调用的<a href="https://docs.raku.org/routine/abs">abs</a>方法。</p>
<p>当您使用原生类型获得性能提升时，此详细信息非常重要。如果您正在使用的代码导致执行大量自动装箱，那么使用原生类型的性能可能会比使用非原生类型时<em>更差</em>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">int</span> <span class="nv">$a-native</span> <span class="o">=</span> <span class="o">-</span><span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">for</span> <span class="o">^</span><span class="mi">1000_000</span> <span class="p">{</span> <span class="nv">$a</span><span class="o">.</span><span class="nb">abs</span>        <span class="p">};</span> <span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">ENTER</span> <span class="nb">now</span> <span class="p">}</span> <span class="c1"># OUTPUT: «0.38180862» </span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">for</span> <span class="o">^</span><span class="mi">1000_000</span> <span class="p">{</span> <span class="nv">$a-native</span><span class="o">.</span><span class="nb">abs</span> <span class="p">};</span> <span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">ENTER</span> <span class="nb">now</span> <span class="p">}</span> <span class="c1"># OUTPUT: «0.938720» </span>
</span></span></code></pre></div><p>如您所见，原生变体的速度慢了两倍多。原因是方法调用需要将原生类型装箱，而非原生变体不需要这样的东西，因此性能损失。</p>
<p>在这种特殊情况下，我们可以简单地切换到<a href="https://docs.raku.org/routine/abs">abs</a>的子程序形式，它可以使用原生类型而无需装箱。在其他情况下，您可能需要寻找其他解决方案以避免过多的自动装箱，包括切换到部分代码的非原生类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">int</span> <span class="nv">$a-native</span> <span class="o">=</span> <span class="o">-</span><span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">for</span> <span class="o">^</span><span class="mi">1000_000</span> <span class="p">{</span> <span class="nb">abs</span> <span class="nv">$a</span>        <span class="p">};</span> <span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">ENTER</span> <span class="nb">now</span> <span class="p">}</span> <span class="c1"># OUTPUT: «0.38229177» </span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="k">for</span> <span class="o">^</span><span class="mi">1000_000</span> <span class="p">{</span> <span class="nb">abs</span> <span class="nv">$a-native</span> <span class="p">};</span> <span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">ENTER</span> <span class="nb">now</span> <span class="p">}</span> <span class="c1"># OUTPUT: «0.3088305» </span>
</span></span></code></pre></div><h2 id="默认值httpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">默认值</a></h2>
<p>由于原生类型后面没有类，因此通常没有使用尚未初始化的变量获得的类型对象。因此，原生类型自动初始化为零。在6.c语言，原生的浮点类型（<code>num</code>，<code>num32</code>，和<code>num64</code>）被初始化为值 <code>NaN</code>; 在 6.d 语言中默认为 <code>0e0</code>。</p>
<h2 id="原生分派httpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">原生分派</a></h2>
<p>例如，当大小可预测时，可以使原生候选者与非原生候选者一起提供具有原生候选者的更快算法，但是否则回退到较慢的非原生候选者。以下是涉及原生候选人的多重分派的规则。</p>
<p>首先，原生类型的大小在分派中不起作用，并且<code>int8</code>被认为与<code>int16</code>或<code>int</code> 例如，当大小可预测时，可以使本地候选者与非本地候选者一起提供具有本地候选者的更快算法，但是否则回退到较慢的非本地候选者。以下是涉及本地候选人的多次派遣的规则。</p>
<p>首先，原生类型的大小在调度中不起作用，并且<code>int8</code>被认为与<code>int16</code>或<code>int</code> 相同：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span>   <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">int</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int32</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">int32</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">foo</span> <span class="k">my</span> <span class="kt">int</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Ambiguous call to &#39;foo(Int)&#39;; these signatures all match: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># :(int $x) </span>
</span></span><span class="line"><span class="cl"><span class="c1"># :(int32 $x) </span>
</span></span></code></pre></div><p>其次，如果例程是一个 <code>only</code>-ie，它不是一个<a href="https://docs.raku.org/language/functions#Multi-dispatch"><code>multi</code></a>非原生类型，而是在调用期间给出一个原生类型，反之亦然，那么参数将被自动装箱或自动取消装箱以使可以被调用。如果给定的参数太大而无法放入native参数，则会抛出异常：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">-&gt;</span> <span class="kt">int</span> <span class="p">{}(</span> <span class="mi">42</span> <span class="p">);</span>            <span class="c1"># OK; auto-unboxing </span>
</span></span><span class="line"><span class="cl"><span class="k">-&gt;</span> <span class="kt">int</span> <span class="p">{}(</span> <span class="mi">2</span>¹⁰⁰ <span class="p">);</span>          <span class="c1"># Too large; exception </span>
</span></span><span class="line"><span class="cl"><span class="k">-&gt;</span> <span class="kt">Int</span> <span class="p">{}(</span> <span class="mi">2</span>¹⁰⁰ <span class="p">);</span>          <span class="c1"># OK; non-native parameter </span>
</span></span><span class="line"><span class="cl"><span class="k">-&gt;</span> <span class="kt">Int</span> <span class="p">{}(</span> <span class="k">my</span> <span class="kt">int</span> <span class="nv">$</span> <span class="o">=</span> <span class="mi">42</span> <span class="p">);</span> <span class="c1"># OK; auto-boxing </span>
</span></span></code></pre></div><p>当涉及到<a href="https://docs.raku.org/language/functions#Multi-dispatch"><code>multi</code></a>例程时，如果没有可用的原生候选者，则原生参数将始终自动装箱：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">foo</span> <span class="p">(</span><span class="kt">Int</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">foo</span> <span class="k">my</span> <span class="kt">int</span> <span class="nv">$</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1"># OUTPUT: «42» </span>
</span></span></code></pre></div><p>另一种方式是不能提供相同的 luxury。如果只有原生候选者可用，则非原生参数将<em>不会</em>被自动取消装箱，而是指示不会抛出匹配的候选者的异常（这种不对称的原因是原生类型总是可以装箱，但是非原生的可能太大而无法融入原生）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">f</span><span class="p">(</span><span class="kt">int</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">f</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Cannot resolve caller f(Int); none of these signatures match: </span>
</span></span><span class="line"><span class="cl"><span class="c1">#     (int $x) </span>
</span></span><span class="line"><span class="cl"><span class="c1">#   in block &lt;unit&gt; at -e line 1 </span>
</span></span></code></pre></div><p>但是，如果正在进行调用，其中一个参数是原生类型而另一个是<a href="https://docs.raku.org/language/syntax#Number_literals">数字字面量</a>，则放弃此规则：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">f</span><span class="p">(</span><span class="kt">int</span><span class="o">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span> <span class="mi">42</span><span class="o">,</span> <span class="k">my</span> <span class="kt">int</span> <span class="nv">$x</span><span class="p">;</span> <span class="c1"># Successful call </span>
</span></span></code></pre></div><p>这样，您就不必不断将诸如 <code>$n +&gt; 2</code> 写为 <code>$n +&gt; (my int $ = 2)</code> 了。编译器知道字面量小到足以适合原生类型并将其转换为原生类型。</p>
<h2 id="原子操作httpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">原子操作</a></h2>
<p>该语言提供了一些保证以原子方式执行的<a href="https://docs.raku.org/type/atomicint">操作</a>，即安全地由多个线程执行而无需锁定而没有数据争用的风险。</p>
<p>对于此类操作，需要<a href="https://docs.raku.org/type/atomicint">atomicint</a>原生类型。此类型与普通原生<a href="https://docs.raku.org/type/int">int</a>类似，不同之处在于它的大小使得可以对其执行CPU提供的原子操作。在32位CPU上，它通常是32位大小，而在64位CPU上，它通常是64位大小。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># !!WRONG!! Might be non-atomic on some systems </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">int</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">await</span> <span class="o">^</span><span class="mi">100</span> <span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span> <span class="k">start</span> <span class="nv">$x</span>⚛<span class="o">++</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span> <span class="c1"># OUTPUT: «98» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># RIGHT! The use of `atomicint` type guarantees operation is atomic </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">atomicint</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">await</span> <span class="o">^</span><span class="mi">100</span> <span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span> <span class="k">start</span> <span class="nv">$x</span>⚛<span class="o">++</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span> <span class="c1"># OUTPUT: «100» </span>
</span></span></code></pre></div><p>相似性<code>int</code>也存在于多重分派中： <code>atomicint</code>，普通的 <code>int</code>和固定大小的<code>int</code>变量都是相同的，并且不能通过多重分派来区分。</p>
<h1 id="numeric-infectiousnesshttpsdocsrakuorglanguagenumerics___top"><a href="https://docs.raku.org/language/numerics#___top">Numeric infectiousness</a></h1>
<p>当一些数学运算中涉及两个不同类型的数字时，数字“传递性”决定了结果类型。如果结果是该类型而不是其他操作数的类型，则认为类型比其他类型更具传递性。例如，<a href="https://docs.raku.org/type/Num">Num</a>类型比<a href="https://docs.raku.org/type/Int">Int</a>更具传递性，因此我们可以期望<code>42e0 + 42</code>产生<a href="https://docs.raku.org/type/Num">Num</a>作为结果。</p>
<p>传递性如下，首先列出最具传递性的类型</p>
<ul>
<li>Complex</li>
<li>Num</li>
<li>FatRat</li>
<li>Rat</li>
<li>Int</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">2e0</span><span class="p">)</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># Int + Num =&gt; OUTPUT: «Num» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span>½ <span class="o">+</span> ½<span class="p">)</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># Rat + Rat =&gt; OUTPUT: «Rat» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="kt">FatRat</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> ½<span class="p">)</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># FatRat + Rat =&gt; OUTPUT: «FatRat» </span>
</span></span></code></pre></div><p>同质异形体具有与其数字成分相同的传递性。原生类型获得自动装箱，并具有与其盒装变体相同的传递性。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的换行处理]]></title>
            <link href="http://localhost:1313/rakulang/51.newline-handling-in-perl-6/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/nim/?utm_source=atom_feed" rel="related" type="text/html" title="Nim" />
                <link href="http://localhost:1313/rakulang/50.native-calling-interface/?utm_source=atom_feed" rel="related" type="text/html" title="原生调用接口" />
                <link href="http://localhost:1313/notes/codewars/?utm_source=atom_feed" rel="related" type="text/html" title="codewars" />
                <link href="http://localhost:1313/notes/roundrobin/?utm_source=atom_feed" rel="related" type="text/html" title="roundrobin" />
                <link href="http://localhost:1313/rakulang/49.meta-object-protocol-mop/?utm_source=atom_feed" rel="related" type="text/html" title="元对象协议" />
            
                <id>http://localhost:1313/rakulang/51.newline-handling-in-perl-6/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-26T21:13:31+08:00</published>
            <updated>2018-11-26T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>不同的操作系统使用不同的字符或字符的组合来表示换行符。每种语言都有自己的一套规则来处理这个问题。 Raku 有以下几个规则：</p>
<ul>
<li>字符串字面量中的 <code>\n</code> 表示 Unicode 代码点 10。</li>
<li>由 <code>say</code> 附加到字符串的默认 <a href="https://docs.raku.org/routine/nl-out">nl-out</a> 也是 <code>\n</code>。</li>
<li>在输出时，当在 Windows 上时，编码器默认将 <code>\n</code> 转换为 <code>\r\n</code>，当它转到文件，进程或终端时（但它不会在套接字上执行此操作）。</li>
<li>在输入时，在任何平台上，解码器默认将 <code>\r\n</code> 标准化为 <code>\n</code>，以便从文件，进程或终端（同样不是套接字）输入。</li>
<li>以上两点一起意味着你可以 - 把套接字编程放在一边 - 期望永远不会在你的程序中看到 <code>\r\n</code>（这也是许多其他语言的工作原理）。</li>
<li><a href="https://docs.raku.org/type/Encoding#method_decoder">:$translate-nl</a> 命名参数存在于控制此转换的各个位置，例如，在 <a href="https://docs.raku.org/type/Proc::Async#method_new">Proc::Async.new</a> 和 <a href="https://docs.raku.org/type/Proc::Async#method_Supply">Proc::Async.Supply</a> 中。</li>
<li>正则表达式语言中的 <code>\n</code> 是合乎逻辑的，并且匹配 <code>\r\n</code>。</li>
</ul>
<p>您可以通过在创建该句柄时设置 <code>:nl-out</code> 属性来更改特定句柄的默认行为。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$crlf-out</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="kt">IO::Special</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">&lt;STDOUT&gt;</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">nl-out</span><span class="p">(&#34;</span><span class="s2">\\</span><span class="se">\n\r</span><span class="p">&#34;));</span>
</span></span><span class="line"><span class="cl"><span class="vg">$*OUT</span><span class="o">.</span><span class="nb">say</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>     <span class="c1">#OUTPUT: «1␤» </span>
</span></span><span class="line"><span class="cl"><span class="nv">$crlf-out</span><span class="o">.</span><span class="nb">say</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">#OUTPUT: «1\␤␍» </span>
</span></span></code></pre></div><p>在这个例子中，我们通过使用 <a href="https://docs.raku.org/type/IO::Special">IO::Special</a> 将标准输出复制到新句柄，我们在字符串的末尾附加一个 <code>\</code>，然后是换行符 <code>␤</code> 和回车符 <code>␍</code>; 我们打印到该句柄的所有内容都会在行尾添加这些字符，如图所示。</p>
<p>在正则表达式中，<a href="https://docs.raku.org/language/regexes#index-entry-regex_%5Cn-regex_%5CN-%5Cn_and_%5CN">\n</a> 是根据<a href="https://unicode.org/reports/tr18/#Line_Boundaries">逻辑换行符的Unicode定义</a>定义的。它会匹配 <code>.</code>, 还有 <code>\v</code>，以及包含空格的任何类。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[原生调用接口]]></title>
            <link href="http://localhost:1313/rakulang/50.native-calling-interface/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/codewars/?utm_source=atom_feed" rel="related" type="text/html" title="codewars" />
                <link href="http://localhost:1313/notes/roundrobin/?utm_source=atom_feed" rel="related" type="text/html" title="roundrobin" />
                <link href="http://localhost:1313/rakulang/49.meta-object-protocol-mop/?utm_source=atom_feed" rel="related" type="text/html" title="元对象协议" />
                <link href="http://localhost:1313/notes/bettercap/?utm_source=atom_feed" rel="related" type="text/html" title="bettercap" />
                <link href="http://localhost:1313/rakulang/48.lists-sequences-and-arrays/?utm_source=atom_feed" rel="related" type="text/html" title="列表、序列和数组" />
            
                <id>http://localhost:1313/rakulang/50.native-calling-interface/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-25T21:13:31+08:00</published>
            <updated>2018-11-25T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="原生调用接口">原生调用接口</h1>
<h2 id="入门指南">入门指南</h2>
<p>能想象出的最简单的 <code>NativeCall</code> 用法应该类似于这样的东西：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">some_argless_function</span><span class="p">()</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#39;</span><span class="s1">something</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">some_argless_function</span><span class="p">();</span>
</span></span></code></pre></div><p>第一行导入了各种 <code>traits</code> 和类型，接下来的一行看起来很像相对普通的 Raku 子例程声明 - 稍微有点变化。我们使用<strong>native</strong>这个 <code>trait </code> 是为了指定这个 sub 子例程实际上被定义在<strong>原生库</strong>中。Raku 会给你添加特定平台的扩展名（比如 <code>.so</code> 或者 <code>.dll</code>）还有任何惯常的前缀(例如: &rsquo;lib&rsquo;)。</p>
<p>当你第一次调用 “some_argless_function” 时，“<strong>lib</strong>something” 将会被加载，然后会在 libsomething 库中定位到 “some_argless_function” 函数，接下来将会进行一次调用。之后的调用将会更快，因为符号句柄会被保留。</p>
<p>当然，大部分的函数都会接受参数或者返回值 - 但是你可以做的其他事情只是增加了这个声明Raku sub的简单模式</p>
<p>但是一切你需要做的就是增加这个简单的模式，通过声明一个 Raku 的过程、在符号后面指出你想要调用的名字，并且使用 “native” trait。</p>
<h2 id="改变名字">改变名字</h2>
<p>有时你想要 Raku 子例程的名字和加载库中使用的名字不同，可能这个名字很长, 或者有不同的大小写或者在你想要创建的模块的上下文中, 这个名字很繁琐。</p>
<p>NativeCall 为你提供了一个 <code>symbol</code> trait 以指定库中<strong>原生子例程</strong>的名字, 这个名字和你的 Raku 子例程名字不同。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">module</span> <span class="nn">Foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">our</span> <span class="k">sub</span> <span class="nf">init</span><span class="p">()</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;)</span> <span class="k">is</span> <span class="k">symbol</span><span class="p">(&#39;</span><span class="s1">FOO_INIT</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span></code></pre></div><p>在 <code>libfoo</code> 库里面有一个子例程叫 <code>FOO_INIT</code>，因为我们创建了一个模块叫做 Foo，我们更愿意使用 <code>Foo::init</code> 调用子例程，我们使用 <code>symbol</code> trait 来指定在 <code>libfoo</code> 库名字符号的名字，然后以任何我们想要的方式调用这个子例程（这里是 “init”）。</p>
<h2 id="传递值和返回值">传递值和返回值</h2>
<p>普通的 Raku 签名和 <code>returns</code> trait 的使用是为了传送原生函数期望的参数类型以及返回的东西，下面有个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">add</span><span class="p">(</span><span class="kt">int32</span><span class="o">,</span> <span class="kt">int32</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">int32</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#39;</span><span class="s1">calculator</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span></code></pre></div><p>在这里，我们声明该函数接受两个32位整数，返回一个32位整数。你可以在<a href="https://docs.raku.org/language/nativetypes">原生类型</a>页面中找到可以传递的其他类型。 请注意，缺少 <code>returns</code> trait 用于指示 <code>void</code> 返回类型。 除指针参数化外，不要在任何地方使用 <code>void</code> 类型。</p>
<p>对于字符串，还有一个额外的 <code>encoded</code> trait，可以提供一些关于如何进行编组的额外提示。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">message_box</span><span class="p">(</span><span class="kt">Str</span> <span class="k">is</span> <span class="nc">encoded</span><span class="p">(&#39;</span><span class="s1">utf8</span><span class="p">&#39;))</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#39;</span><span class="s1">gui</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span></code></pre></div><p>为了指定如何对返回类型进行编组，只需在子例程自身应用这个 trait 即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">input_box</span><span class="p">()</span> <span class="k">returns</span> <span class="kt">Str</span> <span class="k">is</span> <span class="nc">encoded</span><span class="p">(&#39;</span><span class="s1">utf8</span><span class="p">&#39;)</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#39;</span><span class="s1">gui</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span></code></pre></div><p>注意, 可以通过传递 Str 类型对象来传递 NULL 字符串指针; NULL 返回也将由类型对象表示。</p>
<p>如果 C 函数要求字符串的生命周期超过函数调用，则必须手动编码该参数并将其作为 <code>CArray[uint8]</code> 传递：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># C prototype is void set_foo(const char *) </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">set_foo</span><span class="p">(</span><span class="kt">CArray</span><span class="o">[</span><span class="kt">uint8</span><span class="o">]</span><span class="p">)</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># C prototype is void use_foo(void) </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">use_foo</span><span class="p">()</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span> <span class="c1"># will use pointer stored by set_foo() </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$string</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">FOO</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># The lifetime of this variable must be equal to the required lifetime of </span>
</span></span><span class="line"><span class="cl"><span class="c1"># the data passed to the C function. </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$array</span> <span class="o">=</span> <span class="kt">CArray</span><span class="o">[</span><span class="kt">uint8</span><span class="o">].</span><span class="nb">new</span><span class="p">(</span><span class="nv">$string</span><span class="o">.</span><span class="nb">encode</span><span class="o">.</span><span class="nb">list</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nf">set_foo</span><span class="p">(</span><span class="nv">$array</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ... </span>
</span></span><span class="line"><span class="cl"><span class="nf">use_foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1"># It&#39;s fine if $array goes out of scope starting from here. </span>
</span></span></code></pre></div><h2 id="指定原生表示">指定原生表示</h2>
<p>使用原生函数时，有时需要指定要使用的原生数据结构类型。 <code>is repr</code> 是用于此的术语。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">timespec</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">CStruct</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">uint32</span> <span class="nv">$.tv_sec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">long</span> <span class="nv">$.tv_nanosecs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">clock_gettime</span><span class="p">(</span><span class="kt">uint32</span> <span class="nv">$clock-id</span><span class="o">,</span> <span class="n">timespec</span> <span class="nv">$tspec</span> <span class="k">--&gt;</span> <span class="kt">uint32</span><span class="p">)</span> <span class="k">is</span> <span class="k">native</span> <span class="p">{</span> <span class="o">*</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">timespec</span> <span class="nv">$this-time</span> <span class="o">.=</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$result</span> <span class="o">=</span> <span class="nf">clock_gettime</span><span class="p">(</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">$this-time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$result</span><span class="s2">, </span><span class="nv">$this-time</span><span class="p">&#34;;</span> <span class="c1"># OUTPUT: «0, timespec&lt;65385480&gt;␤» </span>
</span></span></code></pre></div><p><a href="https://linux.die.net/man/3/clock_gettime">我们调用的原始函数</a>, <a href="https://docs.raku.org/routine/clock_gettime">clock_gettime</a> 使用指向 <code>timespec</code> 结构的指针作为第二个参数。 我们在这里将它声明为一个<a href="https://docs.raku.org/routine/class">类</a>，但是将其表示指定为 <code>repr('CStruct')</code>, 以指示它对应于 C 数据结构。 当我们创建该类的对象时，我们正在创建 <code>clock_gettime</code> 所期望的指针类型。 这样，数据可以无缝地传输到原生接口和从原生接口传输。</p>
<h2 id="指针的基本使用">指针的基本使用</h2>
<p>当你的原生函数签名需要一个指向某些原生类型（<code>int32</code>、<code>uint32</code>等等）的指针时，所有你需要做的就是将参数声明为 <code>is rw</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># C prototype is void my_version(int *major, int *minor) </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">my_version</span><span class="p">(</span><span class="kt">int32</span> <span class="k">is</span> <span class="k">rw</span><span class="o">,</span> <span class="kt">int32</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">my_version</span><span class="p">(</span><span class="k">my</span> <span class="kt">int32</span> <span class="nv">$major</span><span class="o">,</span> <span class="k">my</span> <span class="kt">int32</span> <span class="nv">$minor</span><span class="p">);</span> <span class="c1"># Pass a pointer to </span>
</span></span></code></pre></div><p>有的时候你需要获取一个从 C 库返回的指针（比如一个库句柄），你不关心它指向什么 - 你只需要保存它就可以了，<code>Pointer</code> 类型就是为此而生的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">Foo_init</span><span class="p">()</span> <span class="k">returns</span> <span class="kt">Pointer</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#34;</span><span class="s2">foo</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">Foo_free</span><span class="p">(</span><span class="kt">Pointer</span><span class="p">)</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#34;</span><span class="s2">foo</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span></code></pre></div><p>这个可以正常工作，但是你可能想要使用比 <code>Pointer</code> 更好的类型，事实证明，任何具有表示“CPointer”的类都可以担任此角色，这意味着你可以通过编写如下类来暴露工作在句柄上的库：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">FooHandle</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">CPointer</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Here are the actual NativeCall functions. </span>
</span></span><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nf">Foo_init</span><span class="p">()</span> <span class="k">returns</span> <span class="n">FooHandle</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#34;</span><span class="s2">foo</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nf">Foo_free</span><span class="p">(</span><span class="n">FooHandle</span><span class="p">)</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#34;</span><span class="s2">foo</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nf">Foo_query</span><span class="p">(</span><span class="n">FooHandle</span><span class="o">,</span> <span class="kt">Str</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">int8</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#34;</span><span class="s2">foo</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nf">Foo_close</span><span class="p">(</span><span class="n">FooHandle</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">int8</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#34;</span><span class="s2">foo</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="c1"># Here are the methods we use to expose it to the outside world. </span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">new</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Foo_init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">query</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$stmt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Foo_query</span><span class="p">(</span><span class="nb">self</span><span class="o">,</span> <span class="nv">$stmt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">close</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Foo_close</span><span class="p">(</span><span class="nb">self</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="c1"># Free data when the object is garbage collected. </span>
</span></span><span class="line"><span class="cl">    <span class="k">submethod</span> <span class="nb">DESTROY</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Foo_free</span><span class="p">(</span><span class="nb">self</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>请注意，CPointer 表示只能保存 C 指针。 这意味着你的类不能有额外的属性。 但是，对于简单的库，这可能是向其暴露面向对象的接口的一种巧妙方式。</p>
<p>当然，你总是可以有一个空类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DoorHandle</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">CPointer</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></div><p>只需像使用 <code>Pointer</code> 一样使用类，但有可能提高类型安全性和更易读的代码。</p>
<p>同样，类型对象用于表示 NULL 指针。</p>
<h2 id="函数指针">函数指针</h2>
<p>C 库可以将指向 C 函数的指针暴露为函数的返回值和结构体的成员，例如 structs 和 unions。</p>
<p>使用定义所需函数参数和返回值的签名调用函数“f”返回的函数指针“$fptr”的示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">()</span> <span class="k">returns</span> <span class="kt">Pointer</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#39;</span><span class="s1">mylib</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fptr</span>    <span class="o">=</span> <span class="nb">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$nfptr</span>   <span class="o">=</span> <span class="nb">nativecast</span><span class="p">(</span><span class="o">:</span><span class="p">(</span><span class="kt">Str</span><span class="o">,</span> <span class="kt">size_t</span> <span class="k">--&gt;</span> <span class="kt">int32</span><span class="p">)</span><span class="o">,</span> <span class="nv">$fptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$nfptr</span><span class="p">(&#34;</span><span class="s2">test</span><span class="p">&#34;</span><span class="o">,</span> <span class="mi">4</span><span class="p">);</span>
</span></span></code></pre></div><h2 id="数组">数组</h2>
<p>NativeCall 对数组有一些支持。 它受限于使用机器大小的整数，双精度和字符串，定型的数字类型，指针数组，结构体数组和数组的数组。</p>
<p>Raku 数组支持懒惰，在内存中以与 C 数组完全不同的方式布局。 因此，NativeCall 库提供了更原始的 CArray 类型，如果使用 C 数组，则必须使用该类型。</p>
<p>这是传递 C 数组的示例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">RenderBarChart</span><span class="p">(</span><span class="kt">Str</span><span class="o">,</span> <span class="kt">int32</span><span class="o">,</span> <span class="kt">CArray</span><span class="o">[</span><span class="kt">Str</span><span class="o">],</span> <span class="kt">CArray</span><span class="o">[</span><span class="kt">num64</span><span class="o">]</span><span class="p">)</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#34;</span><span class="s2">chart</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@titles</span> <span class="o">:=</span> <span class="kt">CArray</span><span class="o">[</span><span class="kt">Str</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@titles</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>  <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Me</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@titles</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>  <span class="o">=</span> <span class="p">&#39;</span><span class="s1">You</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@titles</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>  <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Hagrid</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@values</span> <span class="o">:=</span> <span class="kt">CArray</span><span class="o">[</span><span class="kt">num64</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@values</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>  <span class="o">=</span> <span class="mf">59.5e0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@values</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>  <span class="o">=</span> <span class="mf">61.2e0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@values</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>  <span class="o">=</span> <span class="mf">180.7e0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">RenderBarChart</span><span class="p">(&#39;</span><span class="s1">Weights (kg)</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="nv">@titles</span><span class="o">,</span> <span class="nv">@values</span><span class="p">);</span>
</span></span></code></pre></div><p>注意我们对 <code>@titles</code> 使用了绑定，而不是赋值，如果你使用赋值，则会把值放进 Raku 数组，然后它就不会工作了。如果这令你抓狂，忘记你所知道的关于 <code>@</code> 符号的事情，使用 NativeCall 的时候直接使用 <code>$</code> 吧。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$titles</span> <span class="o">=</span> <span class="kt">CArray</span><span class="o">[</span><span class="kt">Str</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$titles</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Me</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$titles</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">You</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$titles</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Hagrid</span><span class="p">&#39;;</span>
</span></span></code></pre></div><p>获取数组的返回值也是一样的。</p>
<p>某些库 API 可能会将数组作为缓冲区，将由 C 函数填充，例如，返回填充的实际项数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">get_n_ints</span><span class="p">(</span><span class="kt">CArray</span><span class="o">[</span><span class="kt">int32</span><span class="o">],</span> <span class="kt">int32</span><span class="p">)</span> <span class="k">returns</span> <span class="kt">int32</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#39;</span><span class="s1">ints</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span></code></pre></div><p>在这些情况下，重要的是 CArray 在将其传递给原生子例程之前至少具有要填充的元素的数量，否则 C 函数可能会遍历 Perl 的内存，从而可能导致不可预测的行为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$number_of_ints</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$ints</span> <span class="o">=</span> <span class="kt">CArray</span><span class="o">[</span><span class="kt">int32</span><span class="o">].</span><span class="nb">allocate</span><span class="p">(</span><span class="nv">$number_of_ints</span><span class="p">);</span> <span class="c1"># instantiates an array with 10 elements </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="nf">get_n_ints</span><span class="p">(</span><span class="nv">$ints</span><span class="o">,</span> <span class="nv">$number_of_ints</span><span class="p">);</span>
</span></span></code></pre></div><blockquote>
<p>注意：<code>allocate</code> 是在 Rakudo 2018.05 中引入的。 在此之前，你必须使用此机制将数组扩展为许多元素：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$ints</span> <span class="o">=</span> <span class="kt">CArray</span><span class="o">[</span><span class="kt">int32</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$number_of_ints</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$ints</span><span class="o">[</span><span class="nv">$number_of_ints</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1"># extend the array to 10 items </span>
</span></span></code></pre></div><p>数组的内存管理很重要。 当你自己创建一个数组时，可以根据需要为其添加元素，并根据需要为你进行扩展。 但是，这可能会导致元素在内存中移动（但是，对现有元素的赋值永远不会导致这种情况）。 这意味着如果在将数组传递给 C 库之后将数组旋转，你最好知道自己在做什么。</p>
<p>相比之下，当 C 库向你返回一个数组时，内存不能由 NativeCall 管理，并且它不知道数组的结束位置。 据推测，库 API 中的某些东西告诉你这一点（例如，你知道当你看到一个 null 元素时，你应该不再读取）。 请注意，NativeCall 在这里无法为您提供任何保护 - 一旦做错了，你将遇到 segfault 错误或导致内存损坏。 这不是 NativeCall 的缺点，它是原生世界的工作方式。害怕吗？ 还在这里，拥抱一下。 祝好运！</p>
<h2 id="carray-方法">CArray 方法</h2>
<p>除了每个 Raku 实例上可用的常用方法之外，CArray 还提供了以下方法，可以从 Raku 的角度与它进行交互：</p>
<ul>
<li>
<p><code>elems</code> 提供数组中的元素数量;</p>
</li>
<li>
<p><code>AT-POS</code> 在给定位置提供特定元素（从零开始）;</p>
</li>
<li>
<p><code>list</code> 提供了从原生数组迭代器构建它的数组中的元素<a href="https://docs.raku.org/type/List">列表</a>。</p>
</li>
</ul>
<p>例如，请考虑以下简单的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$native-array</span> <span class="o">=</span> <span class="kt">CArray</span><span class="o">[</span><span class="kt">int32</span><span class="o">].</span><span class="nb">new</span><span class="p">(</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Number of elements: </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$native-array</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># walk the array </span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">$native-array</span><span class="o">.</span><span class="nb">list</span> <span class="k">-&gt;</span> <span class="nv">$elem</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Current element is: </span><span class="nv">$elem</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># get every element by its index-based position </span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="nv">$native-array</span><span class="o">.</span><span class="nb">elems</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">-&gt;</span> <span class="nv">$position</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Element at position </span><span class="nv">$position</span><span class="s2"> is </span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">          <span class="o">~</span> <span class="nv">$native-array</span><span class="o">.</span><span class="nb">AT-POS</span><span class="p">(</span> <span class="nv">$position</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>产生以下输出：</p>
<pre tabindex="0"><code>Number of elements: 5
Current element is: 1
Current element is: 2
Current element is: 3
Current element is: 4
Current element is: 5
Element at position 0 is 1
Element at position 1 is 2
Element at position 2 is 3
Element at position 3 is 4
Element at position 4 is 5
</code></pre><h2 id="结构体">结构体</h2>
<p>由于表示多态性，可以声明一个看起来很正常的 Raku 类，实际上，C 编译器将它们放置在类似的结构体定义中以相同的方式存储其属性。 所需要的只是快速使用“repr” trait：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">CStruct</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">num64</span> <span class="nv">$.x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">num64</span> <span class="nv">$.y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>声明的属性只能是 NativeCall 已知的可以转换成结构体字段的类型，目前，结构体中可以包含机器大小的整数，doubles，strings 以及其它 NativeCall 对象（CArrays，还有 CPointer 以及 CStruct reprs）。除此之外，你可以做一些跟类一样的常用的设置，你甚至可以让某些属性来自于角色或者从其它的类继承。当然，方法也完全没有问题，疯狂!</p>
<p>CStruct 对象以引用的形式传递到原生函数，并且原生函数必须返回 CStruct 对象的引用，对于这些引用的内存管理规则跟数组的内存管理规则很像，尽管更简单，因为结构体的大小是不变的。当你创建一个结构体，内存也一并为你分配好，当指向 CStruct 实例的变量的生命期结束，GC 会负责释放内存。当基于 CStruct 的类型作为原生函数的返回类型时，GC 并不帮你管理它的内存。</p>
<p>NativeCall 目前并不把对象成员放到容器里面，所以不能对对象进行赋（使用 =）新值。 相反，你必须将新值绑定到私有成员上：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyStruct</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">CStruct</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">CArray</span><span class="o">[</span><span class="kt">num64</span><span class="o">]</span> <span class="nv">$!arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Str</span> <span class="nv">$!str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="n">Point</span> <span class="nv">$!point</span><span class="p">;</span> <span class="c1"># Point is a user-defined class </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">submethod</span> <span class="nb">TWEAK</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$arr</span> <span class="o">:=</span> <span class="kt">CArray</span><span class="o">[</span><span class="kt">num64</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.9e0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.2e0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!arr</span> <span class="o">:=</span> <span class="nv">$arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!str</span> <span class="o">:=</span> <span class="p">&#39;</span><span class="s1">Raku is fun</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!point</span> <span class="o">:=</span> <span class="n">Point</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>正如你预测的那样，空指针由结构体类型的类型对象表示的。</p>
<h2 id="cunions">CUnions</h2>
<p>同样地，我们可以声明一个 Raku 类，它的属性拥有和 C 编译器中联合体（<code>union</code>）的相同的内存布局，这可以使用 <code>CUnion</code> 表示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyUnion</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">CUnion</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">int32</span> <span class="nv">$.flags32</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">int64</span> <span class="nv">$.flags64</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">nativesizeof</span><span class="p">(</span><span class="n">MyUnion</span><span class="o">.</span><span class="nb">new</span><span class="p">);</span>  <span class="c1"># 8, ie. max(sizeof(MyUnion.flags32), sizeof(MyUnion.flags64)) </span>
</span></span></code></pre></div><h2 id="嵌套的-cstructs-和-cunions">嵌套的 CStructs 和 CUnions</h2>
<p>反过来, CStructs 和 CUnions 可以被周围的 CStruct 和 CUnion 引用，或者嵌入到其他的 CStructs 和 CUnions 里面，如果是引用我们则像往常一样使用 <code>has</code> 来声明，如果是嵌入则使用 <code>HAS</code> 代替：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyStruct</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">CStruct</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="n">Point</span> <span class="nv">$.point</span><span class="p">;</span>  <span class="c1"># referenced </span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">int32</span> <span class="nv">$.flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">nativesizeof</span><span class="p">(</span><span class="n">MyStruct</span><span class="o">.</span><span class="nb">new</span><span class="p">);</span>  <span class="c1"># 16, ie. sizeof(struct Point *) + sizeof(int32_t) </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyStruct2</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">CStruct</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">HAS</span> <span class="n">Point</span> <span class="nv">$.point</span><span class="p">;</span>  <span class="c1"># embedded </span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">int32</span> <span class="nv">$.flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">nativesizeof</span><span class="p">(</span><span class="n">MyStruct2</span><span class="o">.</span><span class="nb">new</span><span class="p">);</span>  <span class="c1"># 24, ie. sizeof(struct Point) + sizeof(int32_t) </span>
</span></span></code></pre></div><h3 id="注意内存管理">注意内存管理</h3>
<p>分配结构体以用作结构体时，请确保在 C 函数中分配自己的内存。 如果要将结构体传递给需要提前分配的 <code>Str/char*</code> 的C函数，请确保在将结构体传递给函数之前为 <code>Str</code> 类型的变量分配容器。</p>
<h4 id="在你的-raku-代码中">在你的 Raku 代码中&hellip;</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">AStringAndAnInt</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#34;</span><span class="s2">CStruct</span><span class="p">&#34;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">has</span> <span class="kt">Str</span> <span class="nv">$.a_string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">has</span> <span class="kt">int32</span> <span class="nv">$.an_int32</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="k">sub</span> <span class="nf">init_struct</span><span class="p">(</span><span class="n">AStringAndAnInt</span> <span class="k">is</span> <span class="k">rw</span><span class="o">,</span> <span class="kt">Str</span><span class="o">,</span> <span class="kt">int32</span><span class="p">)</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#39;</span><span class="s1">simple-struct</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(</span><span class="o">:</span><span class="nv">$a_string</span><span class="o">,</span> <span class="o">:</span><span class="nv">$an_int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">init_struct</span><span class="p">(</span><span class="nb">self</span><span class="o">,</span> <span class="nv">$a_string</span><span class="o">,</span> <span class="nv">$an_int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在此代码中，我们首先设置我们的成员 <code>$.a_string</code> 和 <code>$.an_int32</code>。 之后，我们声明 <code>init_struct()</code> 函数以使 <code>init()</code> 方法包装; 然后从 <code>BUILD</code> 调用此函数以在返回创建的对象之前有效地分配值。</p>
<h4 id="在你的-c-代码中-">在你的 C 代码中 &hellip;</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">typedef</span> <span class="n">struct</span> <span class="n">a_string_and_an_int32_t_</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">char</span> <span class="o">*</span><span class="n">a_string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">int32_t</span> <span class="n">an_int32</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">a_string_and_an_int32_t</span><span class="p">;</span>
</span></span></code></pre></div><p>这是结构体。 注意我们在那里有怎么得到一个 <code>char *</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init_struct</span><span class="p">(</span><span class="kt">a_string_and_an_int32_t</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">int32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">target</span><span class="o">-&gt;</span><span class="n">an_int32</span> <span class="o">=</span> <span class="n">int32</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">target</span><span class="o">-&gt;</span><span class="n">a_string</span> <span class="o">=</span> <span class="nf">strdup</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这个函数中，我们通过按值分配整数并通过引用传递字符串来初始化 C 结构体。 该函数在复制字符串时将 <code>&lt;point * a_string&gt;</code> 指向的内存分配到结构中。 （注意，你还必须管理内存的释放以避免内存泄漏。）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># A long time ago in a galaxy far, far away... </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="n">AStringAndAnInt</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">a_string</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">str</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">an_int</span> <span class="o">=&gt;</span> <span class="mi">123</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foo is </span><span class="p">{</span><span class="nv">$foo</span><span class="o">.</span><span class="nf">a_string</span><span class="p">}</span><span class="s2"> and </span><span class="p">{</span><span class="nv">$foo</span><span class="o">.</span><span class="nf">an_int32</span><span class="p">}&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «foo is str and 123␤» </span>
</span></span></code></pre></div><h2 id="类型指针">类型指针</h2>
<p>将 <code>Pointer</code> 作为参数传递时可以类型化你的 <code>Pointer</code>。这不但对原生类型可用，同样适用于 <code>CArray</code> 以及 <code>CStruct</code> 定义类型，NativeCall 将不会显式为他们分配内存，即使在它们身上调用 <code>new</code> 方法也不会。这适用于那种 C 函数返回指针或者 <code>CStruct</code> 中嵌入的指针情况。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">strdup</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$s</span> <span class="k">--&gt;</span> <span class="kt">Pointer</span><span class="o">[</span><span class="kt">Str</span><span class="o">]</span><span class="p">)</span> <span class="k">is</span> <span class="k">native</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Pointer</span><span class="o">[</span><span class="kt">Str</span><span class="o">]</span> <span class="nv">$p</span> <span class="o">=</span> <span class="nf">strdup</span><span class="p">(&#34;</span><span class="s2">Success!</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$p</span><span class="o">.</span><span class="nf">deref</span><span class="p">;</span>
</span></span></code></pre></div><p>原生函数返回指向元素的数组的指针是很常见的。 可以将类型化指针解引用为数组以获取单个元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># returns a pointer to an array of length $n </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Pointer</span><span class="o">[</span><span class="n">Point</span><span class="o">]</span> <span class="nv">$plot</span> <span class="o">=</span> <span class="nf">some_other_c_routine</span><span class="p">(</span><span class="nv">$n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># display the 5 elements in the array </span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="nv">$n</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="nv">$plot</span><span class="o">[</span><span class="nv">$i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">].</span><span class="nb">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$y</span> <span class="o">=</span> <span class="nv">$plot</span><span class="o">[</span><span class="nv">$i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">].</span><span class="nf">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$i:</span><span class="s2"> (</span><span class="nv">$x</span><span class="s2">, </span><span class="nv">$y</span><span class="s2">)</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>指针也可以更新以引用数组中的连续元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Pointer</span><span class="o">[</span><span class="n">Point</span><span class="o">]</span> <span class="nv">$elem</span> <span class="o">=</span> <span class="nv">$plot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># show differences between successive points </span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span> <span class="o">..^</span> <span class="nv">$n</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="n">Point</span> <span class="nv">$lo</span> <span class="o">=</span> <span class="nv">$elem</span><span class="o">.</span><span class="nf">deref</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="nv">$elem</span><span class="p">;</span> <span class="c1"># equivalent to $elem = $elem.add(1); </span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="n">Point</span> <span class="nv">$hi</span> <span class="o">=</span> <span class="p">(</span><span class="o">++</span><span class="nv">$elem</span><span class="p">)</span><span class="o">.</span><span class="nf">deref</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$dx</span> <span class="o">=</span> <span class="nv">$hi</span><span class="o">.</span><span class="nb">x</span> <span class="o">=</span> <span class="nv">$lo</span><span class="o">.</span><span class="nb">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$dy</span> <span class="o">=</span> <span class="nv">$hi</span><span class="o">.</span><span class="nf">y</span> <span class="o">=</span> <span class="nv">$lo</span><span class="o">.</span><span class="nf">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$_:</span><span class="s2"> delta (</span><span class="nv">$dx</span><span class="s2">, </span><span class="nv">$dy</span><span class="s2">)</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>通过声明 <code>Pointer[void]</code> 也可以使用 Void 指针。 有关该主题的更多信息，请参阅<a href="https://docs.raku.org/language/nativetypes#The_void_type">原生类型文档</a>。</p>
<h2 id="字符串">字符串</h2>
<h3 id="显式内存管理">显式内存管理</h3>
<h3 id="buffers-and-blobs">Buffers and Blobs</h3>
<h2 id="函数参数">函数参数</h2>
<p>NativeCall 也支持把函数作为原生函数的参数，一个常用的情况就是事件驱动模型中，使用函数指针作为回调。当通过 NativeCall 绑定了这些函数，只需要提供对等的 signature 作为函数参数的约束。</p>
<h1 id="void-setcallbackint-callbackchar-const-">void SetCallBack(int (*callback)(char const *))</h1>
<p>my sub SetCallBack(&amp;callback(Str &ndash;&gt; int32)) is native(&lsquo;mylib&rsquo;) { * }
注意：原生代码负责传递给 Raku 回调的值的内存管理，换句话说，NativeCall 将不会释放传递给回调的字符串占用的内存。</p>
<h2 id="库路径以及名字">库路径以及名字</h2>
<p>native trait 接受库的名字或者全路径：</p>
<p>constant LIBMYSQL = &lsquo;mysqlclient&rsquo;;
constant LIBFOO = &lsquo;/usr/lib/libfoo.so.1&rsquo;;</p>
<p>sub mysql_affectied_rows( .. ) returns int32 is native(LIBMYSQL);
sub bar is native(LIBFOO);
你也可以使用相对路径比如&rsquo;./foo&rsquo;，NativeCall 将会自动根据不同的平台添加对应的扩展名。
注意：native trait 和 constant 都是在编译期求值的，constant类型的变量不要依赖动态变量，比如：</p>
<p>constant LIBMYSQL = %*ENV&lt;P6LIB_MYSQLCLIENT&gt; || &lsquo;mysqlclient&rsquo;;
这将在编译期保持给定的值，在一个模块预编译时，LIBMYSQL将会始终保持那个值。</p>
<h3 id="abiapi版本">ABI/API版本</h3>
<p>假设你写的原生库为native(&lsquo;foo&rsquo;)， 在类Unix系统下，NativeCall 将会搜索&rsquo;libfoo.so&rsquo;（对于OS X是libfoo.dynlib，win32是foo.dll）。在大多数的现代系统上，将会需要你或者模块的使用者安装开发环境包，因为它们总是建议支持动态库的API/ABI的版本控制，所以&rsquo;libfoo.so&rsquo;大多数是一个符号链接，并且只被开发包提供。</p>
<p>sub foo is native(&lsquo;foo&rsquo;, v1);         # 将会查找并加载 libfoo.so.1
sub foo is native(&lsquo;foo&rsquo;, v1.2.3);    # 将会查找并加载 libfoo.so.1.2.3</p>
<p>my List $lib = (&lsquo;foo&rsquo;, &lsquo;v1&rsquo;);
sub foo is native($lib);</p>
<h3 id="例程">例程</h3>
<p>native trait 也可以接受一个Callable作为参数，允许你使用自己的方式指定将会被加载的库文件：</p>
<p>sub foo is native(sub { &rsquo;libfoo.so.42&rsquo; } );
这个函数只会在第一个调用者访问的时候调用。</p>
<h3 id="调用标准库">调用标准库</h3>
<p>如果你想调用一个已经被加载的，或者是标准库或者来自你自己的程序的 C 函数，你可以将 Str 类型对象作为参数传递给is native，这将会是is native(Str)。
比如说，在类UNIX操作系统下，你可以使用下面的代码打印当前用户的home目录：</p>
<p>use NativeCall;
my class PwStruct is repr(&lsquo;CStruct&rsquo;) {
has Str $.pw_name;
has Str $.pw_passwd;
has uint32 $.pw_uid;
has uint32 $.pw_gid;
has Str $.pw_gecos;
has Str $.pw_dir;
has Str $.pw_shell;
}</p>
<p>sub getuid()                returns uint32         is native(Str) { * }
sub getpwuid(uint32 $uid)    returns PwStruct     is native(Str) { * }</p>
<p>say getpwuid(getuid());
不过，使用$*HOME更方便一些 :-)</p>
<h2 id="导出的变量">导出的变量</h2>
<p>一个库导出的变量 &ndash; 也被叫做“全局（global）”或者 “外部（extern）”变量 &ndash; 可以使用cglobal访问。比如：</p>
<p>my $var := cglobal(&rsquo;libc.so.6&rsquo;, &rsquo;error&rsquo;, int32);
这将会为$var绑定一个新的Proxy对象，并且将对它的访问重定向到被“libc.so.6”导出的叫做errno的整数变量。</p>
<h2 id="对c的支持">对C++的支持</h2>
<p>NativeCall 也支持使用来自 c++ 的类以及方法，就像这个例子展示的那样（还有相关的 c++ 文件），注意现阶段还不像 C 一样支持测试和开发。</p>
<h2 id="helper-函数">Helper 函数</h2>
<h3 id="sub-nativecast">sub nativecast</h3>
<h3 id="sub-cglobal">sub cglobal</h3>
<h3 id="sub-nativesizeof">sub nativesizeof</h3>
<h3 id="sub-explicitly-manage">sub explicitly-manage</h3>
<h2 id="例子">例子</h2>
<p>一些具体示例，以及在特定平台上使用上述示例的说明。</p>
<h3 id="postgresql">PostgreSQL</h3>
<p><a href="https://github.com/raku/DBIish/blob/master/examples/pg.p6">DBIish</a> 中的 PostgreSQL 示例使用 NativeCall 库，并且<code>原生使用</code> Windows 中的原生 <code>_putenv</code> 函数调用。</p>
<h3 id="mysql">MySQL</h3>
<p>注意：请记住，自 Stretch 版本以来，Debian 已经将 MySQL 替换为 MariaDB，因此如果要安装 MySQL，请使用 <a href="https://dev.mysql.com/downloads/repo/apt/">MySQL APT 存储库</a>而不是默认存储库。</p>
<p>要在 <a href="https://github.com/raku/DBIish/blob/master/examples/mysql.p6">DBIish</a> 中使用 MySQL 示例，您需要在本地安装 MySQL 服务器; 在Debian-esque 系统上，它可以安装如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">wget https://dev.mysql.com/get/mysql-apt-config_0.8.10-1_all.deb
</span></span><span class="line"><span class="cl">sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb <span class="c1"># Don&#39;t forget to select 5.6.x </span>
</span></span><span class="line"><span class="cl">sudo apt-get update
</span></span><span class="line"><span class="cl">sudo apt-get install mysql-community-server -y
</span></span><span class="line"><span class="cl">sudo apt-get install libmysqlclient18 -y
</span></span></code></pre></div><p>在尝试示例之前，请按照这些方法准备系统：</p>
<pre tabindex="0"><code>$ mysql -u root -p
SET PASSWORD = PASSWORD(&#39;sa&#39;);
DROP DATABASE test;
CREATE DATABASE test;
</code></pre><h3 id="microsoft-windows">Microsoft Windows</h3>
<p>这是一个 Windows API 调用的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">MessageBoxA</span><span class="p">(</span><span class="kt">int32</span><span class="o">,</span> <span class="kt">Str</span><span class="o">,</span> <span class="kt">Str</span><span class="o">,</span> <span class="kt">int32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">returns</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="k">is</span> <span class="k">native</span><span class="p">(&#39;</span><span class="s1">user32</span><span class="p">&#39;)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nf">MessageBoxA</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">We have NativeCall</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">ohai</span><span class="p">&#34;</span><span class="o">,</span> <span class="mi">64</span><span class="p">);</span>
</span></span></code></pre></div><h3 id="关于调用-c-函数的简明指南">关于调用 C 函数的简明指南</h3>
<p>这是一个调用标准函数并在 Raku 程序中使用返回信息的示例。</p>
<p><code>getaddrinfo</code> 是 POSIX 标准函数，用于获取有关网络节点的网络信息，例如 <code>google.com</code>。 这是一个有趣的功能，因为它说明了 NativeCall 的许多元素。</p>
<p>Linux 手册提供了有关 C 可调用函数的以下信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">getaddrinfo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">service</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">       <span class="k">const</span> <span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">hints</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">       <span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">**</span><span class="n">res</span><span class="p">);</span>
</span></span></code></pre></div><p>该函数返回响应码 0 = 错误，1 = 成功。 数据是从 <code>addrinfo</code> 元素的链表中提取的，第一个元素由 <code>res</code> 指向。</p>
<p>从 NativeCall 类型表我们知道 <code>int</code> 是 <code>int32</code>。 我们也知道 <code>char *</code> 是 C <code>Str</code> 的形式 C 之一，它简单地映射到 Str。 但是 <code>addrinfo</code> 是一个结构体，这意味着我们需要编写自己的 Type 类。 但是，函数声明很简单：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">getaddrinfo</span><span class="p">(</span> <span class="kt">Str</span> <span class="nv">$node</span><span class="o">,</span> <span class="kt">Str</span> <span class="nv">$service</span><span class="o">,</span> <span class="n">Addrinfo</span> <span class="nv">$hints</span><span class="o">,</span> <span class="kt">Pointer</span> <span class="nv">$res</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">returns</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="k">is</span> <span class="k">native</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
</span></span></code></pre></div><p>请注意，<code>$res</code> 将由函数写入，因此必须将其标记为 <code>rw</code>。 由于库是标准 POSIX，因此库名称可以是 Type 定义或 null。</p>
<p>我们现在必须处理结构体 <code>Addrinfo</code>。 Linux 手册提供了以下信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">addrinfo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="kt">int</span>              <span class="n">ai_flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">               <span class="kt">int</span>              <span class="n">ai_family</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">               <span class="kt">int</span>              <span class="n">ai_socktype</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">               <span class="kt">int</span>              <span class="n">ai_protocol</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">               <span class="kt">socklen_t</span>        <span class="n">ai_addrlen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">               <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">ai_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">               <span class="kt">char</span>            <span class="o">*</span><span class="n">ai_canonname</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">               <span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">ai_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">           <span class="p">};</span>
</span></span></code></pre></div><p><code>int</code>，<code>char *</code> 部分很简单。 一些研究表明 <code>socklen_t</code> 可以依赖于架构，但是是一个至少32位的无符号整数。 所以 <code>socklen_t</code> 可以映射到 <code>uint32</code> 类型。</p>
<p>复杂的是 <code>sockaddr</code>，它取决于 <code>ai_socktype</code> 是否是未定义的，INET 还是 INET6（标准的v4 IP 地址或 v6 地址）。</p>
<p>所以我们创建一个 Raku 类来映射到 C <code>struct addrinfo</code>; 当我们在它的时候，我们还为 <code>SockAddr</code> 创建了另一个类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SockAddr</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">CStruct</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">int32</span>    <span class="nv">$.sa_family</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Str</span>      <span class="nv">$.sa_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Addrinfo</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">CStruct</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">int32</span>     <span class="nv">$.ai_flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">int32</span>     <span class="nv">$.ai_family</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">int32</span>     <span class="nv">$.ai_socktype</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">int32</span>     <span class="nv">$.ai_protocol</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">int32</span>     <span class="nv">$.ai_addrlen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="n">SockAddr</span>  <span class="nv">$.ai_addr</span>       <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Str</span>       <span class="nv">$.ai_cannonname</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="n">Addrinfo</span>  <span class="nv">$.ai_next</span>       <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>最后三个属性的 <code>is rw</code> 反映了这些在 C 中被定义为指针。</p>
<p>映射到 C <code>Struct</code> 的重要一点是类的状态部分的结构，即属性。 但是，类可以有方法，而 <code>NativeCall</code> 不会“触摸”它们以映射到C.这意味着我们可以向类添加额外的方法以更易读的方式解包属性，例如，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">method</span> <span class="nf">flags</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">do</span> <span class="k">for</span> <span class="n">AddrInfo-Flags</span><span class="o">.</span><span class="nb">enums</span> <span class="p">{</span> <span class="o">.</span><span class="nb">key</span> <span class="k">if</span> <span class="nv">$!ai_flags</span> <span class="o">+&amp;</span> <span class="o">.</span><span class="nb">value</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>通过定义适当的 <code>enum</code>，<code>flags</code> 将返回一串键而不是一个打包的整数。</p>
<p><code>sockaddr</code> 结构中最有用的信息是节点的地址，它取决于 Socket 的族。 因此，我们可以将方法地址添加到 Raku 类中，该类根据族来解释地址。</p>
<p>为了获得人类可读的 IP 地址，有一个 C 函数 <code>inet_ntop</code>，它给出一个带有 <code>addrinfo</code> 的缓冲区的 <code>char *</code>。</p>
<p>将所有这些组合在一起会产生以下程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env raku </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">NativeCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">constant</span> <span class="nv">\INET_ADDRSTRLEN</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">constant</span> <span class="nv">\INET6_ADDRSTRLEN</span> <span class="o">=</span> <span class="mi">46</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">AddrInfo-Family</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">AF_UNSPEC</span>                   <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">AF_INET</span>                     <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">AF_INET6</span>                    <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">AddrInfo-Socktype</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">SOCK_STREAM</span>                 <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">SOCK_DGRAM</span>                  <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">SOCK_RAW</span>                    <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">SOCK_RDM</span>                    <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">SOCK_SEQPACKET</span>              <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">SOCK_DCCP</span>                   <span class="o">=&gt;</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">SOCK_PACKET</span>                 <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">AddrInfo-Flags</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">AI_PASSIVE</span>                  <span class="o">=&gt;</span> <span class="mh">0x0001</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">AI_CANONNAME</span>                <span class="o">=&gt;</span> <span class="mh">0x0002</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">AI_NUMERICHOST</span>              <span class="o">=&gt;</span> <span class="mh">0x0004</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">AI_V4MAPPED</span>                 <span class="o">=&gt;</span> <span class="mh">0x0008</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">AI_ALL</span>                      <span class="o">=&gt;</span> <span class="mh">0x0010</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">AI_ADDRCONFIG</span>               <span class="o">=&gt;</span> <span class="mh">0x0020</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">AI_IDN</span>                      <span class="o">=&gt;</span> <span class="mh">0x0040</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">AI_CANONIDN</span>                 <span class="o">=&gt;</span> <span class="mh">0x0080</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">AI_IDN_ALLOW_UNASSIGNED</span>     <span class="o">=&gt;</span> <span class="mh">0x0100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">AI_IDN_USE_STD3_ASCII_RULES</span> <span class="o">=&gt;</span> <span class="mh">0x0200</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="s">AI_NUMERICSERV</span>              <span class="o">=&gt;</span> <span class="mh">0x0400</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">inet_ntop</span><span class="p">(</span><span class="kt">int32</span><span class="o">,</span> <span class="kt">Pointer</span><span class="o">,</span> <span class="kt">Blob</span><span class="o">,</span> <span class="kt">int32</span> <span class="k">--&gt;</span> <span class="kt">Str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">is</span> <span class="k">native</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SockAddr</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">CStruct</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">uint16</span> <span class="nv">$.sa_family</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SockAddr-in</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">CStruct</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">int16</span> <span class="nv">$.sin_family</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">uint16</span> <span class="nv">$.sin_port</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">uint32</span> <span class="nv">$.sin_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">address</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$buf</span> <span class="o">=</span> <span class="n">buf8</span><span class="o">.</span><span class="nb">allocate</span><span class="p">(</span><span class="n">INET_ADDRSTRLEN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">inet_ntop</span><span class="p">(</span><span class="n">AF_INET</span><span class="o">,</span> <span class="kt">Pointer</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nb">nativecast</span><span class="p">(</span><span class="kt">Pointer</span><span class="o">,</span><span class="nb">self</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$buf</span><span class="o">,</span> <span class="n">INET_ADDRSTRLEN</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SockAddr-in6</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">CStruct</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">uint16</span> <span class="nv">$.sin6_family</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">uint16</span> <span class="nv">$.sin6_port</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">uint32</span> <span class="nv">$.sin6_flowinfo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">uint64</span> <span class="nv">$.sin6_addr0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">uint64</span> <span class="nv">$.sin6_addr1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">uint32</span> <span class="nv">$.sin6_scope_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">address</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$buf</span> <span class="o">=</span> <span class="n">buf8</span><span class="o">.</span><span class="nb">allocate</span><span class="p">(</span><span class="n">INET6_ADDRSTRLEN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">inet_ntop</span><span class="p">(</span><span class="n">AF_INET6</span><span class="o">,</span> <span class="kt">Pointer</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nb">nativecast</span><span class="p">(</span><span class="kt">Pointer</span><span class="o">,</span><span class="nb">self</span><span class="p">)</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$buf</span><span class="o">,</span> <span class="n">INET6_ADDRSTRLEN</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Addrinfo</span> <span class="k">is</span> <span class="k">repr</span><span class="p">(&#39;</span><span class="s1">CStruct</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">int32</span> <span class="nv">$.ai_flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">int32</span> <span class="nv">$.ai_family</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">int32</span> <span class="nv">$.ai_socktype</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">int32</span> <span class="nv">$.ai_protocol</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">uint32</span> <span class="nv">$.ai_addrNativeCalllen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="n">SockAddr</span> <span class="nv">$.ai_addr</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Str</span> <span class="nv">$.ai_cannonname</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="n">Addrinfo</span> <span class="nv">$.ai_next</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">flags</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">do</span> <span class="k">for</span> <span class="n">AddrInfo-Flags</span><span class="o">.</span><span class="nb">enums</span> <span class="p">{</span> <span class="o">.</span><span class="nb">key</span> <span class="k">if</span> <span class="nv">$!ai_flags</span> <span class="o">+&amp;</span> <span class="o">.</span><span class="nb">value</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">family</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">AddrInfo-Family</span><span class="p">(</span><span class="nv">$!ai_family</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">socktype</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">AddrInfo-Socktype</span><span class="p">(</span><span class="nv">$!ai_socktype</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">address</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">given</span> <span class="nv">$.family</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">when</span> <span class="n">AF_INET</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nb">nativecast</span><span class="p">(</span><span class="n">SockAddr-in</span><span class="o">,</span> <span class="nv">$!ai_addr</span><span class="p">)</span><span class="o">.</span><span class="nf">address</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">when</span> <span class="n">AF_INET6</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nb">nativecast</span><span class="p">(</span><span class="n">SockAddr-in6</span><span class="o">,</span> <span class="nv">$!ai_addr</span><span class="p">)</span><span class="o">.</span><span class="nf">address</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">getaddrinfo</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$node</span><span class="o">,</span> <span class="kt">Str</span> <span class="nv">$service</span><span class="o">,</span> <span class="n">Addrinfo</span> <span class="nv">$hints</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="kt">Pointer</span> <span class="nv">$res</span> <span class="k">is</span> <span class="k">rw</span> <span class="k">--&gt;</span> <span class="kt">int32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">is</span> <span class="k">native</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">freeaddrinfo</span><span class="p">(</span><span class="kt">Pointer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">is</span> <span class="k">native</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="n">Addrinfo</span> <span class="nv">$hint</span> <span class="o">.=</span> <span class="nb">new</span><span class="p">(:</span><span class="s">ai_flags</span><span class="p">(</span><span class="n">AI_CANONNAME</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="kt">Pointer</span> <span class="nv">$res</span> <span class="o">.=</span> <span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$rv</span> <span class="o">=</span> <span class="nf">getaddrinfo</span><span class="p">(&#34;</span><span class="s2">google.com</span><span class="p">&#34;</span><span class="o">,</span> <span class="kt">Str</span><span class="o">,</span> <span class="nv">$hint</span><span class="o">,</span> <span class="nv">$res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">return val: </span><span class="nv">$rv</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="nv">$rv</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$addr</span> <span class="o">=</span> <span class="nb">nativecast</span><span class="p">(</span><span class="n">Addrinfo</span><span class="o">,</span> <span class="nv">$res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="nv">$addr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">with</span> <span class="nv">$addr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Name: </span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$_</span> <span class="k">with</span> <span class="o">.</span><span class="nf">ai_cannonname</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="nb">say</span> <span class="o">.</span><span class="nf">family</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="nf">socktype</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="nb">say</span> <span class="o">.</span><span class="nf">address</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="nv">$addr</span> <span class="o">=</span> <span class="o">.</span><span class="nf">ai_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">freeaddrinfo</span><span class="p">(</span><span class="nv">$res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这产生如下输出:</p>
<pre tabindex="0"><code>return val: 0
Name: google.com
AF_INET SOCK_STREAM
216.58.219.206
AF_INET SOCK_DGRAM
216.58.219.206
AF_INET SOCK_RAW
216.58.219.206
AF_INET6 SOCK_STREAM
2607:f8b0:4006:800::200e
AF_INET6 SOCK_DGRAM
2607:f8b0:4006:800::200e
AF_INET6 SOCK_RAW
2607:f8b0:4006:800::200e
</code></pre>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[元对象协议]]></title>
            <link href="http://localhost:1313/rakulang/49.meta-object-protocol-mop/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/bettercap/?utm_source=atom_feed" rel="related" type="text/html" title="bettercap" />
                <link href="http://localhost:1313/rakulang/48.lists-sequences-and-arrays/?utm_source=atom_feed" rel="related" type="text/html" title="列表、序列和数组" />
                <link href="http://localhost:1313/notes/subtrip/?utm_source=atom_feed" rel="related" type="text/html" title="sub trip" />
                <link href="http://localhost:1313/rakulang/47.input-and-output-the-definitive-guide/?utm_source=atom_feed" rel="related" type="text/html" title="输入和输出专家指南" />
                <link href="http://localhost:1313/rakulang/46.hashes-and-maps/?utm_source=atom_feed" rel="related" type="text/html" title="散列和映射" />
            
                <id>http://localhost:1313/rakulang/49.meta-object-protocol-mop/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-24T21:13:31+08:00</published>
            <updated>2018-11-24T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="自省和-raku-的对象系统">自省和 Raku 的对象系统</h1>
<p>Raku 是构建在元对象层上面的。那意味着有些对象(元对象)控制着各种面向对象结构(例如类、roles、方法、属性、枚举,…)怎样去表现。</p>
<p>要感受类的元对象, 这儿有一个同样的例子出现2次: 一次一种 Raku中的普通声明, 一次通过元模型来表达:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">x</span><span class="p">()</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">42</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="o">.</span><span class="nb">x</span><span class="p">();</span> <span class="c1"># 42</span>
</span></span></code></pre></div><p>对应于:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">constant</span> <span class="no">A</span> <span class="o">:=</span> <span class="kt">Metamodel::ClassHOW</span><span class="o">.</span><span class="nb">new_type</span><span class="p">(</span> <span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">A</span><span class="p">&#39;</span> <span class="p">);</span>  <span class="c1"># class A {</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(&#39;</span><span class="s1">x</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">my</span> <span class="k">method</span> <span class="nb">x</span><span class="p">(</span><span class="n">A:</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">42</span> <span class="p">});</span>             <span class="c1"># method x() .. .</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="o">.^</span><span class="nb">compose</span><span class="p">;</span>                                                 <span class="c1"># }</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="o">.</span><span class="nb">x</span><span class="p">();</span> <span class="c1"># 42</span>
</span></span></code></pre></div><p>(除了声明形式的运行在编译时, 后面这种形式不是)</p>
<p>对象后面的元对象能使用 <code>$obj.HOW</code>获取, 这儿的 HOW 代表着 <strong>Higher Order Workings</strong>(或者 HOW the *%@$ does this work?)。</p>
<p>这儿, 带有 <code>.^</code>的调用是元对象的调用, 所以 <code>A.^compose</code>是 <code>A.HOW.compose(A)</code>的简写。调用者也被传递到参数列表中, 以使它能够支持原型类型风格的类型系统, 那儿只有一个元对象。</p>
<p>就像上面的例子展示的那样, 所有的面向对象特性对使用者都是可获得的, 而不仅仅是编译器。实际上编译器就是使用元对象的这样的调用的。</p>
<h2 id="元对象metaobjects">元对象(MetaObjects)</h2>
<p>这些是内省的宏, 类似于方法调用。</p>
<p>元对象通常以 ALLCAPS(全大写)命名, 并且避免使用你自己的带有全大写名字的方法被认为是一个好的风格。这会避免和可能出现在未来版本中的任何元对象发生冲突。注意, 如果你必须使用带有全大写名字的方法的话, 把你的这个方法名字用引号引起来来间接安全地调用:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">THIS IS A CLASS FOR SHOUTING THINGS
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">class</span> <span class="nc">MY-CLASSES-ARE-ALL-CAPS</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">WHY</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">I DON&#39;T KNOW</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="n">MY-CLASSES-ARE-ALL-CAPS</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$c</span><span class="o">.</span><span class="nb">WHY</span>      <span class="c1"># &#34;THIS IS A CLASS FOR SHOUTING THINGS&#34;? 显示这？你在逗我!</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$c</span><span class="o">.</span><span class="p">&#34;</span><span class="s2">WHY</span><span class="p">&#34;()</span>  <span class="c1"># &#34;I DON&#39;T KNOW&#34;</span>
</span></span></code></pre></div><h2 id="what">WHAT</h2>
<p>类型的类型对象。例如 <code>42.WHAT</code> 返回 <code>Int</code>类型对象。</p>
<h2 id="which">WHICH</h2>
<p>对象的同一值。这能用于哈希和同一比较, 并且这是 <code>===</code>中缀操作符的实现方式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">WHICH</span>
</span></span><span class="line"><span class="cl"><span class="kt">Str</span><span class="o">|</span><span class="n">a</span>
</span></span></code></pre></div><h2 id="who">WHO</h2>
<p>支持对象的包</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">WHO</span>
</span></span><span class="line"><span class="cl"><span class="kt">Str</span>
</span></span></code></pre></div><h2 id="where">WHERE</h2>
<p>对象的内存地址。注意这在移动的/紧凑的垃圾回收实现中是不稳定的。 在稳定的同一指示器中使用 <code>WHERE</code>。</p>
<h2 id="how">HOW</h2>
<p>元类对象(the metaclass object)：“Higher Order Workings”。</p>
<h2 id="why">WHY</h2>
<p>附加的 Pod 值。</p>
<h2 id="definite">DEFINITE</h2>
<p>对象有一个有效的强制表现。</p>
<p>对于实例返回 <code>True</code>, 对于类型对象返回 <code>False</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="mi">42</span><span class="o">.</span><span class="nb">DEFINITE</span>
</span></span><span class="line"><span class="cl"><span class="kt">True</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="kt">Int</span><span class="o">.</span><span class="nb">DEFINITE</span>
</span></span><span class="line"><span class="cl"><span class="kt">False</span>
</span></span></code></pre></div><h2 id="var">VAR</h2>
<p>返回底层的 Scalar 对象, 如果有的话。</p>
<h2 id="元对象系统的结构">元对象系统的结构</h2>
<p>对于每个类型声明符关键字, 例如 <code>class</code>、<code>role</code> 、<code>enum</code>、<code>module</code>、<code>package</code>、<code>grammar</code> 或<code>subset</code>, 就有一个独立的元类在 <code>Matamodel::</code>命名空间中。(Rakudo 在 <code>Raku::Metamodel::</code>命名空间中实现了它们, 然后把 <code>Raku::Metamodel</code>映射到 <code>Metamodel</code>)。</p>
<p>这些元类(meta classes)中的很多都共享公共的功能。例如 roles、grammars和 classes(类)都能包括方法和属性, 还能遵守 roles。这个共享的功能是在 roles 中实现的, 它被组合进合适的元类中。例如 <a href="http://doc.raku.org/type/Metamodel::RoleContainer">role Metamodel::RoleContainer</a>实现了类型能处理 roles 和 <code>Metamodel::ClassHOW</code>的功能, 它是在 <code>class</code>关键字后面的元类, 遵守了这个 role。</p>
<h2 id="bootstrapping-concernshttpdocrakuorglanguagemop___top"><a href="http://doc.raku.org/language/mop#___top">Bootstrapping concerns</a></h2>
<p>你可能想知道为什么 <code>Metamodel::ClassHOW</code>可以是一个类, 当按照<code>Metamodel::ClassHOW</code>作为一个类被定义时, 或者 roles 负责 role 处理的怎么能是 roles。答案是通过魔法。</p>
<p>开玩笑啦。自举是特别实现的。Rakudo 使用语言的对象系统来实现自举, 它恰好(几乎)就是 Raku 的一个子集: NQP, Not Quite Perl。 NQP 有原始的, class-like 叫做 <code>konwhow</code> 的性质, 它用于自举它自己的类和 roles 实现。<code>konwhow</code>建立在NQP 提供的虚拟机的原始基础上。</p>
<p>因为元对象是根据低级(low-level)类型引导的, 自省有时能返回低级(low-level)类型而非你期望的那个类型, 例如返回一个 NQP-level 的子例程而非普通的 <code>Routine</code>对象, 或返回一个引导的属性而非<a href="http://doc.raku.org/type/Attribute">Attribute</a>。</p>
<h2 id="组合和静态推理">组合和静态推理</h2>
<p>在 Raku中, 类型是在解析时被构造的, 所以在开始, 它必须是可变的。然而, 如果所有类型一直是可变的, 那么关于类型的所有推断会在任何类型的修改时变得无效。例如父类的列表因此类型检测的结果能在那个时候改变。</p>
<p>所以为了获得这两个世界中最好的东西, 当类型从可变转为不可变时是好时机。这就叫做组合, 并且对于从句法构成上声明的类型, 它发生在类型声明被完全解析时(所以总是在闭合花括号被解析时)。</p>
<p>如果你通过元对象系统直接创建类型, 你必须要在它们身上调用 <code>.^compose</code>, 在它们变得完全起作用之前。</p>
<p>很多元类也使用组合时来计算一些诸如方法解析顺序这样的属性, 发布一个方法缓存, 和其它清扫任务。在它们被组合之后干预类型有时是可能的, 但通常是造成灾难的因素。 不要那样做。</p>
<h2 id="能力和责任">能力和责任</h2>
<p>元对象协议提供了很多常规 Raku 代码故意限制了的能力, 例如调用类中不信任你的私有方法, 窥探私有属性, 和其它通常不能完成的东西。</p>
<p>常规的 Raku 代码有很多就地的安全检测; 元模型中不是这样，它靠近底层的虚拟机, 违反和虚拟机的约定可以导致所有奇怪的行为, 而在正常代码中, 显而易见的会是 bugs。</p>
<p>所以, 在写元类型的时候要格外小心和思考。</p>
<h2 id="能力便利和陷阱">能力、便利和陷阱</h2>
<p>元对象协议被设计的强大到实现 Raku 的对象系统。这种能力间或花费了便利的代价。</p>
<p>例如, 当你写了 <code>my $x = 42</code>并在 <code>$x</code>上调用方法时, 大部分方法会在整数 42 上起作用, 而不是在存储 42 的标量容器上。这是 Raku中设立的一块便利。元对象协议中的大部分不能提供自动忽略标量容器的便利性, 因为它们也用于实现那些标量容器。 所以, 如果你写了 <code>my $t = MyType; ... $t.^compose</code>, 那么你正组合那个<code>$</code>变量表明的标量, 而不是 <code>MyType</code>。</p>
<p>结果就是你需要很详尽的理解 Raku 的底层以避免陷阱, 当使用 MOP 时, 并且不能期望得到和普通 Raku 代码提供的 &ldquo;do what I mean&rdquo; 的便利。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[列表、序列和数组]]></title>
            <link href="http://localhost:1313/rakulang/48.lists-sequences-and-arrays/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/subtrip/?utm_source=atom_feed" rel="related" type="text/html" title="sub trip" />
                <link href="http://localhost:1313/rakulang/47.input-and-output-the-definitive-guide/?utm_source=atom_feed" rel="related" type="text/html" title="输入和输出专家指南" />
                <link href="http://localhost:1313/rakulang/46.hashes-and-maps/?utm_source=atom_feed" rel="related" type="text/html" title="散列和映射" />
                <link href="http://localhost:1313/notes/sink-to-hbase-using-structured-streaming/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Spark Structured Streaming 落数据到 HBase 中" />
                <link href="http://localhost:1313/rakulang/45.grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Grammars" />
            
                <id>http://localhost:1313/rakulang/48.lists-sequences-and-arrays/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-23T21:13:31+08:00</published>
            <updated>2018-11-23T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>列表一直是计算机的核心部分，因为之前有计算机，在这段时间里，许多恶魔占据了他们的细节。 它们实际上是 Raku 设计中最难的部分之一，但是通过坚持和耐心，Raku 已经使用了一个优雅的系统来处理它们。</p>
<h2 id="literal-lists">Literal Lists</h2>
<p>字面上的<a href="https://docs.raku.org/type/List">列表</a>用逗号和分号不是用圆括号创建，因此：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span>        <span class="c1"># This is two-element list</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span>      <span class="c1"># This is also a List, in parentheses</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">)</span>      <span class="c1"># same List</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="p">)</span>         <span class="c1"># This is not a List, just a 1 in parentheses</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="p">)</span>        <span class="c1"># This is a one-element List</span>
</span></span></code></pre></div><p>括号可用于标记<code>列表</code>的开头和结尾，因此：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># This is a list of two lists.</span>
</span></span></code></pre></div><p>多维字面上的<code>列表</code>是通过逗号和分号组合而成的。 它们可以在常规参数列表和下标中使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="p">)</span> <span class="ow">eqv</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«True␤»</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;;);</span> <span class="c1"># a list with one element and the empty list</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«(foo)()␤»</span>
</span></span></code></pre></div><p>单个元素可以使用下标从列表中拉出。 列表的第一个元素的索引号为零：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>   <span class="c1"># says 1</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>   <span class="c1"># says 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>   <span class="c1"># says Nil</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">[-</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># Error</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span> <span class="c1"># 2</span>
</span></span></code></pre></div><h2 id="the--sigil">The @ sigil</h2>
<p>Raku 中名称为 @ 符号的变量应该包含某种类似列表的对象。 当然，其他变量也可能包含这些对象，但是 <code>@-sigiled</code> 变量总是这样，并且期望它们作用于该部分。</p>
<p>默认情况下，当您将<code>列表</code>分配给 <code>@-sigiled</code> 变量时，您将创建一个<code>数组</code>。 这些在下面描述。 如果你想把一个真实的的 <code>List</code> 放到一个 @ -sigiled 变量中，你可以用 <code>:=</code> 绑定代替。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
</span></span></code></pre></div><p>将列表的列表赋值给 @-sigiled 变量不提供相同的快捷方式。 在这种情况下，外部 List 成为数组的第一个元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">flat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«((1 2) (3 4))␤»</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span> <span class="o">:=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">flat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«((1 2 3 4)␤»</span>
</span></span></code></pre></div><p>@_sigiled 变量像列表一样的方式之一是总是支持<a href="https://docs.raku.org/language/subscripts">位置下标</a>。 任何绑定到 @-sigiled 值的东西都必须支持 <a href="https://docs.raku.org/type/Positional">Positional</a> 角色，这保证了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1"># Type check failed in binding; expected Positional but got Int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 但是</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span><span class="p">;</span> <span class="c1"># (1)</span>
</span></span></code></pre></div><h2 id="reset-a-list-container">Reset a List Container</h2>
<p>要从 Positional 容器中删除所有元素，请将 <a href="https://docs.raku.org/type/Slip#Empty">Empty</a>，空列表 <code>()</code> 或空列表的 <code>Slip</code> 赋值给容器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span> <span class="o">=</span> <span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span> <span class="o">=</span> <span class="kt">Empty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span> <span class="o">=</span> <span class="o">|</span><span class="p">();</span>
</span></span></code></pre></div><h2 id="iteration">Iteration</h2>
<p>所有的列表都可以被迭代，这意味着从列表中按顺序拿出每个元素并在最后一个元素之后停止：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span> <span class="c1"># says 1, then says 2, then says 3</span>
</span></span></code></pre></div><h2 id="testing-for-elements">Testing for Elements</h2>
<p>要测试元素将 <code>List</code> 或 <code>Array</code> 转换为 <a href="https://docs.raku.org/type/Set">Set</a> 或使用 Set <a href="https://docs.raku.org/language/setbagmix">运算符</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">foo bar buzz</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">.</span><span class="kt">Set</span><span class="p">&lt;</span><span class="s">bar buzz</span><span class="p">&gt;;</span> <span class="c1"># (True True)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#39;</span><span class="s1">bar</span><span class="p">&#39;</span> <span class="o">∈</span> <span class="nv">@a</span><span class="p">;</span>   <span class="c1"># True</span>
</span></span></code></pre></div><h3 id="sequences">Sequences</h3>
<p>不是所有的列表生来都充满元素。 有些只创建他们被要求的尽可能多的元素。 这些称为序列，其类型为 <code>Seq</code>。 因为这样发生，循环返回 <code>Seqs</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="k">loop</span> <span class="p">{</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span> <span class="p">})</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="c1"># says 42 three times</span>
</span></span></code></pre></div><p>所以，在 Raku 中有无限列表是很好的，只要你从不问他们所有的元素。 在某些情况下，你可能希望避免询问它们有多长 - 如果 Raku 知道一个序列是无限的，它将尝试返回 <code>Inf</code>，但它不能总是知道。</p>
<p>虽然 <code>Seq</code> 类确实提供了一些位置下标，但它不提供 Positional 的完整接口，因此 @-sigiled 变量可能不会绑定到 <code>Seq</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@s</span> <span class="o">:=</span> <span class="p">(</span><span class="k">loop</span> <span class="p">{</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span> <span class="p">});</span> <span class="c1"># Error expected Positional but got Seq</span>
</span></span></code></pre></div><p>这是因为 <code>Seq</code> 在使用它们之后不会保留值。 这是有用的行为，如果你有一个很长的序列，因为你可能想在使用它们之后丢弃值，以便你的程序不会填满内存。 例如，当处理一个百万行的文件时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">&#39;</span><span class="s1">filename</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">do-something-with</span><span class="p">(</span><span class="nv">$line</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>你可以确信文件的整个内容不会留在内存中，除非你明确地存储某个地方的行。</p>
<p>另一方面，在某些情况下，您可能希望保留旧值。 可以在<code>列表</code>中隐藏一个 <code>Seq</code>，它仍然是惰性的，但会记住旧的值。 这是通过调用 <code>.list</code> 方法完成的。 由于此<code>列表</code>完全支持 <code>Positional</code>，因此可以将其直接绑定到 @-sigiled 变量上。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@s</span> <span class="o">:=</span> <span class="p">(</span><span class="k">loop</span> <span class="p">{</span> <span class="mi">42</span> <span class="p">})</span><span class="o">.</span><span class="nb">list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@s</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span> <span class="c1"># Says 42 three times</span>
</span></span><span class="line"><span class="cl"><span class="nv">@s</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span> <span class="c1"># does not say anything</span>
</span></span><span class="line"><span class="cl"><span class="nv">@s</span><span class="o">[</span><span class="mi">4</span><span class="o">]</span><span class="p">;</span> <span class="c1"># Says 42 two more times</span>
</span></span></code></pre></div><p>您还可以使用 <code>.cache</code> 方法代替 <code>.list</code>，这取决于您希望处理引用的方式。 有关详细信息，请参阅 <a href="https://docs.raku.org/type/Seq">Seq</a> 上的页面。</p>
<h3 id="slips">Slips</h3>
<p>有时候你想把一个列表的元素插入到另一个列表中。 这可以通过一个称为 <a href="https://docs.raku.org/type/Slip">Slip</a> 的特殊类型的列表来完成。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">,</span> <span class="mi">4</span><span class="p">)</span> <span class="ow">eqv</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">);</span>         <span class="c1"># says False</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="kt">Slip</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">,</span> <span class="mi">4</span><span class="p">)</span> <span class="ow">eqv</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1"># says True</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="nb">slip</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">,</span> <span class="mi">4</span><span class="p">)</span> <span class="ow">eqv</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">);</span>     <span class="c1"># also says True</span>
</span></span></code></pre></div><p>另一种方法是使用 <code>|</code> 前缀运算符。 注意，这有一个比逗号更严格的优先级，所以它只影响一个单一的值，但不像上面的选项，它会打碎<a href="https://docs.raku.org/type/Scalar">标量</a>。而 <code>slip</code> 不会。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">|</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">,</span> <span class="mi">4</span><span class="p">)</span> <span class="ow">eqv</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">);</span>        <span class="c1"># says True</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">|</span><span class="nv">$</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">,</span> <span class="mi">4</span><span class="p">)</span> <span class="ow">eqv</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">);</span>       <span class="c1"># also says True</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="nb">slip</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">,</span> <span class="mi">4</span><span class="p">)</span> <span class="ow">eqv</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1"># says False</span>
</span></span></code></pre></div><h2 id="lazy-lists">Lazy Lists</h2>
<p>列表可以是惰性的，这意味着它们的值是根据需要计算的，并且存储供以后使用。 要创建惰性列表，请使用 <a href="https://docs.raku.org/language/control#gather%2Ftake">gather/take</a> 或<a href="https://docs.raku.org/language/operators#infix_...">序列运算符</a>。 您还可以编写一个实现 <a href="https://docs.raku.org/type/Iterable">Iterable</a> 角色的类，并在调用 <a href="https://docs.raku.org/routine/lazy">lazy</a> 时返回 <code>True</code>。 请注意，某些方法（如 <code>elems</code>）可能会导致整个列表计算失败，如果列表也是无限的。无限列表没办法知道它的元素个数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@l</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">8</span><span class="o">...</span><span class="no">Inf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@l</span><span class="o">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">16</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«(1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536)␤»</span>
</span></span></code></pre></div><h2 id="immutability">Immutability</h2>
<p>到目前为止我们谈论的列表（<code>List</code>，<code>Seq</code> 和 <code>Slip</code>）都是不可变的。 这意味着您不能从中删除元素，或重新绑定现有元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">:</span><span class="s">delete</span><span class="p">;</span> <span class="c1"># Error Can not remove elements from a List</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1"># Error Cannot use bind operator with this left-hand side</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1"># Error Cannot modify an immutable Int</span>
</span></span></code></pre></div><p>但是，如果任何元素包裹在<a href="https://docs.raku.org/type/Scalar">标量</a>中，您仍然可以更改 <code>Scalar</code> 指向的值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="nv">$a</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$a</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>            <span class="c1"># says 42</span>
</span></span></code></pre></div><p>&hellip;就是说，它只是列表结构本身 - 有多少个元素和每个元素的标识 - 是不可变的。 不变性不是通过元素的身份传染。</p>
<h2 id="list-contexts">List Contexts</h2>
<p>到目前为止，我们主要是在中立语境下处理列表。 实际上列表在语法层面上上下文非常敏感。</p>
<h3 id="list-assignment-context">List Assignment Context</h3>
<p>当一个列表出现在赋值给 @-sigiled 变量的右边时，它被“热切地”计算。 这意味着 <code>Seq</code> 将被迭代，直到它不能产生更多的元素。 这是你不想放置无限列表的地方之一，免得你的程序挂起，最终耗尽内存：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">(</span><span class="k">loop</span> <span class="p">{</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="nb">last</span> <span class="k">unless</span> <span class="o">--</span><span class="nv">$i</span> <span class="p">});</span> <span class="c1"># Says 3 2 1</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">take off!</span><span class="p">&#34;;</span>
</span></span></code></pre></div><h3 id="flattening-context">Flattening &ldquo;Context&rdquo;</h3>
<p>当您的列表包含子列表，但您只想要一个平面列表时，可以展平该列表以生成一系列值，就像所有的括号被删除了一样。 无论括号中有多少层次嵌套，这都可以工作。</p>
<p>请注意，列表周围的标量将使其免于扁平化：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="nv">$</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="nb">flat</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span> <span class="c1"># says 1, then 2, then (3 4), then 5</span>
</span></span></code></pre></div><p>&hellip;但是一个 @-sigiled 变量将溢出它的元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@l</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="nv">@l</span><span class="o">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="nb">flat</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">};</span>      <span class="c1"># says 1, then 2, then 3, then 4, then 5</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">);</span>                 <span class="c1"># Arrays are special, see below</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="nv">@a</span><span class="o">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="nb">flat</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">};</span>      <span class="c1"># says 1, then 2, then (3 4), then 5</span>
</span></span></code></pre></div><h3 id="argument-list-capture-context">Argument List (Capture) Context</h3>
<p>当列表作为函数或方法调用的参数出现时，会使用特殊的语法规则：该列表立即转换为 <code>Capture</code>。 <code>Capture</code> 本身有一个 List（<code>.list</code>）和一个 Hash（<code>.hash</code>）。 任何键没有引号的 <code>Pair</code>，或者没有括号的 <code>Pair</code> 字面量，永远不会变成 <code>.list</code>。 相反，它们被认为是命名参数，并且压缩为 <code>.hash</code>。 有关此处理的详细信息，请参阅 <a href="https://docs.raku.org/type/Capture">Capture</a> 上的页面。</p>
<p>考虑从<code>列表</code>中创建新<code>数组</code>的以下方法。 这些方法将 <code>List</code> 放在参数列表上下文中，因此，<code>Array</code> 只包含 1 和 2，但不包含 <code>Pair :c(3)</code>，它被忽略。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="kt">Array</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="p">:</span><span class="s">c</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="kt">Array</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="p">:</span><span class="s">c</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">new</span> <span class="nb">Array</span><span class="o">:</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="p">:</span><span class="s">c</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span></code></pre></div><p>相反，这些方法不会将  <code>List</code> 放置在参数列表上下文中，所以所有元素，甚至 <code>Pair :c(3)</code>，都放置在<code>数组</code>中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="kt">Array</span><span class="o">.</span><span class="nb">new</span><span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="p">:</span><span class="s">c</span><span class="p">(</span><span class="mi">3</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="p">:</span><span class="s">c</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="kt">Array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="p">:</span><span class="s">c</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="kt">Array</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">@a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="p">:</span><span class="s">c</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="kt">Array</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="nv">@a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="p">:</span><span class="s">c</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="nb">new</span> <span class="nb">Array</span><span class="o">:</span> <span class="nv">@a</span><span class="p">;</span>
</span></span></code></pre></div><p>在参数列表上下文中，应用于 <code>Positional</code> 上的 <code>|</code> 前缀运算符总是将列表元素slip为Capture的位置参数，而应用到 <code>Associative</code> 上的 <code>|</code> 前缀运算符会把 pairs 作为具名参数 slip 进来：</p>
<p>`raku
my @a := 2, &ldquo;c&rdquo; =&gt; 3;
Array.new(1, |@a, 4);    # Array contains 1, 2, :c(3), 4
my %a = &ldquo;c&rdquo; =&gt; 3;
Array.new(1, |%a, 4);    # Array contains 1, 4</p>
<pre tabindex="0"><code>
### Slice Indexing Context

从[切片下标](https://docs.raku.org/language/subscripts#Slices) 中的 `List` 角度来看，只有一个显着的地方在于它是不可见的：因为一个切片的副词附在 `]` 后面，切片的内部**不是**参数列表，并且没有对 pair 形式的特殊处理 。

大多数 `Positional` 类型将对切片索引的每个元素强制执行整数强制，因此那儿出现的 pairs 将生成错误，无论如何：

```raku
(1, 2, 3)[1, 2, :c(3)] # Method &#39;Int&#39; not found for invocant of class &#39;Pair&#39;
</code></pre><p>&hellip;但是这完全取决于类型 - 如果它定义了pairs的顺序，它可以考虑 <code>:c(3)</code> 是有效的索引。</p>
<p>切片内的索引通常不会自动展平，但是子列表通常不会强制为 <code>Int</code>。 相反，列表结构保持不变，从而导致在结果中重复结构的嵌套 slice 操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(&#34;</span><span class="s2">a</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">b</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">c</span><span class="p">&#34;)</span><span class="o">[</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">]</span> <span class="ow">eqv</span> <span class="p">((&#34;</span><span class="s2">b</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">c</span><span class="p">&#34;)</span><span class="o">,</span> <span class="p">(&#34;</span><span class="s2">a</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">b</span><span class="p">&#34;))</span> <span class="c1"># says True</span>
</span></span></code></pre></div><h3 id="range-as-slice">Range as Slice</h3>
<p><a href="https://docs.raku.org/type/Range">Range</a> 是用于下边界和上边界的容器。 生成具有 <code>Range</code> 的切片将包括这些边界之间的任何索引，包括边界。 对于无限上限，我们同意数学家 <code>Inf</code> 等于 <code>Inf-1</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>     <span class="c1"># (1 2 3)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">..^</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>    <span class="c1"># (1 2)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">..*]</span><span class="p">;</span>     <span class="c1"># (1 2 3 4 5)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">..^*]</span><span class="p">;</span>    <span class="c1"># (1 2 3 4 5)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">..</span><span class="no">Inf</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span> <span class="c1"># (1 2 3 4 5)</span>
</span></span></code></pre></div><h3 id="array-constructor-context">Array Constructor Context</h3>
<p>在数组字面量中，初始化值的列表不在捕获上下文中，只是一个正常的列表。 然而，正如在赋值中一样，急切地对它求值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">[</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="p">:</span><span class="s">c</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">]</span> <span class="ow">eqv</span> <span class="kt">Array</span><span class="o">.</span><span class="nb">new</span><span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="p">:</span><span class="s">c</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span> <span class="c1"># says True</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="k">while</span> <span class="nv">$</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">{</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="mi">43</span> <span class="p">}</span><span class="o">].</span><span class="nb">map</span><span class="o">:</span> <span class="o">*.</span><span class="nb">say</span><span class="p">;</span>   <span class="c1"># says 42 twice then 43 twice</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="k">while</span> <span class="nv">$</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">{</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="mi">43</span> <span class="p">})</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="o">*.</span><span class="nb">say</span><span class="p">;</span>   <span class="c1"># says &#34;42&#34; then &#34;43&#34;</span>
</span></span><span class="line"><span class="cl">                                             <span class="c1"># then &#34;42&#34; then &#34;43&#34;</span>
</span></span></code></pre></div><p>它把我们带到数组这儿来。</p>
<h2 id="arrays">Arrays</h2>
<p>数组与列表在三个主要方面不同：它们的元素可以被类型化，它们自动列出它们的元素，并且它们是可变的。 否则，它们是列表，并且在列表所在的位置被接受。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="kt">Array</span> <span class="o">~~</span> <span class="kt">List</span>     <span class="c1"># says True</span>
</span></span></code></pre></div><p>第四种更微妙的方式是，当使用数组时，有时可能更难以维持惰性或使用无限序列。</p>
<h3 id="typing">Typing</h3>
<p>数组可以被类型化，使得它们的槽在被赋值时执行类型检查。 只允许分配 <code>Int</code> 值的数组是 <code>Array[Int]</code> 类型，可以使用 <code>Array[Int].new</code> 创建一个数组。 如果你打算仅仅为了这个目的使用 @-sigiled 变量，你可以在声明它时通过指定元素的类型来改变它的类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>              <span class="c1"># An Array that contains only Ints</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@b</span> <span class="o">:=</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">].</span><span class="nb">new</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1"># Same thing, but the variable is not typed</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@b</span> <span class="ow">eqv</span> <span class="nv">@a</span><span class="p">;</span>                    <span class="c1"># says True.</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>                  <span class="c1"># An Array that can contain anything</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@b</span> <span class="ow">eqv</span> <span class="nv">@c</span><span class="p">;</span>                    <span class="c1"># says False because types do not match</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@c</span> <span class="ow">eqv</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>             <span class="c1"># says False because one is a List</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@b</span> <span class="ow">eq</span> <span class="nv">@c</span><span class="p">;</span>                     <span class="c1"># says True, because eq only checks values</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@b</span> <span class="ow">eq</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>              <span class="c1"># says True, because eq only checks values</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>                       <span class="c1"># fine</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;;</span>                    <span class="c1"># error: Type check failed in assignment</span>
</span></span></code></pre></div><p>在上面的例子中，我们将一个类型化的 Array 对象绑定到一个没有指定类型的 @-sigil 变量上。 另一种方法不工作 - 你不能绑定一个类型错误的数组到一个类型化的 @-sigiled 变量上：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">:=</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">].</span><span class="nb">new</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>     <span class="c1"># fine</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span> <span class="o">:=</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Str</span><span class="o">].</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">a</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">b</span><span class="p">&#34;);</span>       <span class="c1"># fine, can be re-bound</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">@b</span> <span class="o">:=</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">].</span><span class="nb">new</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1"># fine</span>
</span></span><span class="line"><span class="cl"><span class="nv">@b</span> <span class="o">:=</span> <span class="kt">Array</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>             <span class="c1"># error: Type check failed in binding</span>
</span></span></code></pre></div><p>当使用类型化数组时，重要的是要记住它们是名义类型的。 这意味着数组的声明类型是重要的。 给定以下子声明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">mean</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">@a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">@a</span><span class="o">.</span><span class="nb">sum</span> <span class="o">/</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">elems</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>传递 <code>Array[Int]</code> 的调用将成功：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">@b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">mean</span><span class="p">(</span><span class="nv">@b</span><span class="p">);</span>                       <span class="c1"># @b is Array[Int]</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">mean</span><span class="p">(</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">].</span><span class="nb">new</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="p">));</span>  <span class="c1"># Anonymous Array[Int]</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">mean</span><span class="p">(</span><span class="k">my</span> <span class="kt">Int</span> <span class="nv">@</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="p">);</span>       <span class="c1"># Another anonymous Array[Int]</span>
</span></span></code></pre></div><p>但是，由于传递一个无类型的数组，下面的调用将全部失败，即使该数组在传递时恰好包含 Int 值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">mean</span><span class="p">(</span><span class="nv">@c</span><span class="p">);</span>                       <span class="c1"># Fails, passing untyped Array</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">mean</span><span class="p">(</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span><span class="p">);</span>                <span class="c1"># Same</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">mean</span><span class="p">(</span><span class="kt">Array</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="p">));</span>       <span class="c1"># Same again</span>
</span></span></code></pre></div><p>请注意，在任何给定的编译器中，可能有一些奇怪的，底层的方法来绕过数组上的类型检查，因此在处理不受信任的输入时，执行额外的类型检查是一个很好的做法，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@a</span> <span class="k">-&gt;</span> <span class="kt">Int</span> <span class="nv">$i</span> <span class="p">{</span> <span class="nv">$_</span><span class="o">++.</span><span class="nb">say</span> <span class="p">};</span>
</span></span></code></pre></div><p>然而，只要你坚持在一个信任的代码区域内的正常赋值操作，这不会是一个问题，并且typecheck错误将在分配到数组时发生，如果他们不能在编译时捕获。 在Raku中提供的用于操作列表的核心功能不应该产生一个类型化的数组。</p>
<p>不存在的元素（当索引时）或已分配Nil的元素将采用默认值。 可以使用 <code>is default</code> 特征在逐个变量的基础上调整此默认值。 请注意，无类型的@ -sigiled变量的元素类型为 <code>Mu</code>，但其默认值为未定义的 <code>Any</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">.</span><span class="k">of</span><span class="o">.</span><span class="nb">perl</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                 <span class="c1"># says &#34;Mu&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nb">perl</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>            <span class="c1"># says &#34;Any&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">say</span><span class="p">;</span>                      <span class="c1"># says &#34;(Any)&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Numeric</span> <span class="nv">@n</span> <span class="k">is</span> <span class="k">default</span><span class="p">(</span><span class="kt">Real</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">@n</span><span class="o">.</span><span class="k">of</span><span class="o">.</span><span class="nb">perl</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                 <span class="c1"># says &#34;Numeric&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@n</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nb">perl</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>            <span class="c1"># says &#34;Real&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@n</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">say</span><span class="p">;</span>                      <span class="c1"># says &#34;(Real)&#34;</span>
</span></span></code></pre></div><h3 id="fixed-size-arrays">Fixed Size Arrays</h3>
<p>要限制<code>阵列</code>的尺寸，请提供由 <code>,</code> 或 <code>;</code> 在数组容器的名称后面的括号中。 这样一个<code>数组</code>的值将默认为 <code>Any</code>。 形状可以在运行时通过 <code>shape</code> 方法访问。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«Array.new(:shape(2, 2), [Any, Any], [Any, Any])␤»</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">shape</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«(2 2)␤»</span>
</span></span></code></pre></div><p>赋值到固定大小的数组将把一个列表的列表提升为数组的数组。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">2</span><span class="p">;</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">@a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«Array.new(:shape(2, 2), [1, 2], [3, 42])␤»</span>
</span></span></code></pre></div><h3 id="itemization">Itemization</h3>
<p>对于大多数用途，数组由多个槽组成，每个槽包含正确类型的<code>标量</code>。 每个这样的<code>标量</code>，反过来，包含该类型的值。 当数组被初始化，赋值或构造时，Raku 将自动进行类型检查值并创建标量来包含它们。</p>
<p>这实际上是 Raku 列表处理中最棘手的部分之一，以获得牢固的理解。</p>
<p>首先，请注意，因为假设数组中的项目化，它本质上意味着 <code>$(...)</code> 被放置在您分配给数组的所有内容，如果你不把它们放在那里。 另一方面，<code>Array.perl</code> 不会将$显式地显示标量，与 <code>List.perl</code> 不同：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">,</span> <span class="nv">$</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="nb">perl</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># says &#34;((1, 2), $(3, 4))&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">,</span> <span class="nv">$</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">].</span><span class="nb">perl</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># says &#34;[(1, 2), (3, 4)]&#34;</span>
</span></span><span class="line"><span class="cl">                            <span class="c1"># ...but actually means: &#34;[$(1, 2), $(3, 4)]&#34;</span>
</span></span></code></pre></div><p>它决定所有这些额外的美元符号和括号更多的眼睛疼痛比对用户的好处。 基本上，当你看到一个方括号，记住隐形美元符号。</p>
<p>第二，记住这些看不见的美元符号也防止扁平化，所以你不能真正地扁平化一个数组内的元素与正常调用 <code>flat</code> 或 <code>.flat</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">,</span> <span class="nv">$</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="nb">flat</span><span class="o">.</span><span class="nb">perl</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># (1, 2, $(3, 4)).Seq</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">,</span> <span class="nv">$</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">].</span><span class="nb">flat</span><span class="o">.</span><span class="nb">perl</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># ($(1, 2), $(3, 4)).Seq</span>
</span></span></code></pre></div><p>由于方括号本身不会防止展平，因此您仍然可以使用平面将数组中的元素溢出到周围的列表中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">[</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">,</span> <span class="nv">$</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">],</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="nb">flat</span><span class="o">.</span><span class="nb">perl</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># (0, $(1, 2), $(3, 4), 5).Seq</span>
</span></span></code></pre></div><p>&hellip;元素本身，但是，留在一块。</p>
<p>这可以阻止用户提供的数据，如果你有深嵌套的数组他们想要平面数据。 目前，他们必须手动地深度地映射结构以撤消嵌套：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="k">gather</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="o">[</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">,</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]],</span> <span class="nv">$</span><span class="p">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">].</span><span class="nb">deepmap</span><span class="o">:</span> <span class="o">*.</span><span class="nb">take</span><span class="p">;</span> <span class="c1"># (1 2 3 4 5 6)</span>
</span></span></code></pre></div><p>&hellip;未来版本的 Raku 可能会找到一种使这更容易的方法。 但是，当 non-itemized 列表足够时，不从函数返回数组或  itemized 列表，这是一个应该考虑作为好意给他们的用户：</p>
<ul>
<li>当您总是想要与周围列表合并时使用 Slips</li>
<li>使用  non-itemized 列表，当你想让用户容易展平时</li>
<li>使用 itemized 列表来保护用户可能不想展平的东西</li>
<li>使用数组作为  non-itemized  列表的  non-itemized  列表，如果合适</li>
<li>如果用户想要改变结果而不首先复制结果，请使用数组。</li>
</ul>
<p>事实上，数组的所有元素（在<code>Scalar</code>容器中）是一个绅士的协议，而不是一个普遍强制的规则，并且在类型数组中的类型检查不太好。 请参阅下面有关绑定到阵列插槽的部分。</p>
<h3 id="literal-arrays">Literal Arrays</h3>
<p>字面数组是用方括号内的 List 构造的。 列表被热切地迭代（如果可能，在编译时），并且列表中的值每个都进行类型检查和itemized。 在展平时, 方括号本身会将元素放入周围的列表中，但是元素本身不会因为 itemization 化而溢出。</p>
<h3 id="mutability">Mutability</h3>
<p>与列表不同，数组是可变的。 元素可以删除，添加或更改。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">b</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">c</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                  <span class="c1"># [a b c]</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">.</span><span class="nb">pop</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>              <span class="c1"># says &#34;c&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                  <span class="c1"># says &#34;[a b]&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">.</span><span class="nb">push</span><span class="p">(&#34;</span><span class="s2">d</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                  <span class="c1"># says &#34;[a b d]&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">c</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">c</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                  <span class="c1"># says &#34;[a c d c]&#34;</span>
</span></span></code></pre></div><h3 id="assigning">Assigning</h3>
<p>列表到数组的分配是急切的。 该列表将被完全求值，并且数组不应该是无限的否则程序可能挂起。 类似地，对阵列的分片的分配是急切的，但是仅仅达到所请求数量的元素，其可以是有限的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">loop</span> <span class="p">{</span> <span class="mi">42</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                     <span class="c1"># says &#34;[42 42 42]&#34;</span>
</span></span></code></pre></div><p>在赋值期间，每个值都将进行类型检查，以确保它是 <code>Array</code> 允许的类型。 任何<code>标量</code>将从每个值中剥离，一个新的<code>标量</code>将被包裹。</p>
<h3 id="binding">Binding</h3>
<p>单个数组槽可以以相同的方式绑定 $-sigiled 变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">:=</span> <span class="nv">$b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>          <span class="c1"># says &#39;[1 2 &#34;foo&#34;]&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$b</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">bar</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>          <span class="c1"># says &#39;[1 2 &#34;bar&#34;]&#39;</span>
</span></span></code></pre></div><p>&hellip;但强烈不建议将 Array 槽直接绑定到值。 如果你这样做，预期内置函数的惊喜。 只有当需要知道值和Scalar-Wrapped值之间的差异的可变容器时，或者对于不能使用本地类型数组的非常大的Arrays，才需要执行此操作。 这样的生物永远不应该被传递回不知情的用户。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[输入和输出专家指南]]></title>
            <link href="http://localhost:1313/rakulang/47.input-and-output-the-definitive-guide/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/46.hashes-and-maps/?utm_source=atom_feed" rel="related" type="text/html" title="散列和映射" />
                <link href="http://localhost:1313/notes/sink-to-hbase-using-structured-streaming/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Spark Structured Streaming 落数据到 HBase 中" />
                <link href="http://localhost:1313/rakulang/45.grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Grammars" />
                <link href="http://localhost:1313/rakulang/44.functions/?utm_source=atom_feed" rel="related" type="text/html" title="函数" />
                <link href="http://localhost:1313/notes/the-modules-that-will-be-rewrite-in-perl6/?utm_source=atom_feed" rel="related" type="text/html" title="The modules that will be rewrite in Raku" />
            
                <id>http://localhost:1313/rakulang/47.input-and-output-the-definitive-guide/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-22T21:13:31+08:00</published>
            <updated>2018-11-22T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="基础知识httpsdocsrakuorglanguageio-guide___top"><a href="https://docs.raku.org/language/io-guide#___top">基础知识</a></h1>
<p>绝大多数常见的 IO 工作都是由<a href="https://docs.raku.org/type/IO::Path">IO::Path</a>类型完成的。如果您想以某种形式或形状读取或写入文件，这就是您想要的类。它抽象出文件句柄（或“文件描述符”）的细节，因此你甚至不必考虑它们。</p>
<p>在幕后，<a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 与 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 一起使用 ; 一个你可以直接使用的类，如果你需要比 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 提供的更多控制。当与其他进程，例如通过 <a href="https://docs.raku.org/type/Proc">Proc</a> 或 <a href="https://docs.raku.org/type/Proc::Async">Proc::Async</a>类型，您还可以处理<a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 的<em>子类</em>：在<a href="https://docs.raku.org/type/IO::Pipe">IO::Pipe</a>。</p>
<p>最后，你有 <a href="https://docs.raku.org/type/IO::CatHandle">IO::CatHandle</a>，以及 <a href="https://docs.raku.org/type/IO::Spec">IO::Spec</a> 及其子类，你很少直接使用它们。这些类为您提供了高级功能，例如将多个文件作为一个句柄进行操作，或者进行低级路径操作。</p>
<p>除了所有这些类之外，Raku 还提供了几个子程序，可以让您间接使用这些类。如果您喜欢函数式编程风格或 Raku  单行程序，这些就派上用场了。</p>
<p>虽然 <a href="https://docs.raku.org/type/IO::Socket">IO::Socket</a> 及其子类也与输入和输出有关，但本指南并未涵盖它们。</p>
<h1 id="导航路径httpsdocsrakuorglanguageio-guide___top"><a href="https://docs.raku.org/language/io-guide#___top">导航路径</a></h1>
<h2 id="whats-an-iopath-anywayhttpsdocsrakuorglanguageio-guide___top"><a href="https://docs.raku.org/language/io-guide#___top">What&rsquo;s an IO::Path anyway?</a></h2>
<p>要将路径表示为文件或目录，请使用 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 类型。获取该类型对象的最简单方法是通过在它身上调用 <a href="https://docs.raku.org/routine/IO"><code>.IO</code></a> 方法强制将 <a href="https://docs.raku.org/type/Str">Str</a> 类型转为路径类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">my-file.txt</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="p">;</span> <span class="c1"># OUTPUT: «&#34;my-file.txt&#34;.IO␤» </span>
</span></span></code></pre></div><p>看起来这里似乎缺少某些东西 - 没有卷或绝对路径 - 但该信息实际上存在于对象中。你可以通过使用 <a href="https://docs.raku.org/routine/perl"><code>.perl</code></a> 方法看到它：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">my-file.txt</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «IO::Path.new(&#34;my-file.txt&#34;, :SPEC(IO::Spec::Unix), :CWD(&#34;/home/camelia&#34;))␤» </span>
</span></span></code></pre></div><p>这两个额外的属性 - <code>SPEC</code> 和 - <code>CWD</code> 指定路径应该使用的操作系统语义类型以及路径的“当前工作目录”，即如果它是相对路径，则它相对于该目录。</p>
<p>这意味着无论你如何制作一个路径，<a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 对象在技术上总是指一个绝对路径。这就是它的 <a href="https://docs.raku.org/routine/absolute"><code>.absolute</code></a> 和 <a href="https://docs.raku.org/routine/relative"><code>.relative</code></a> 方法返回 <a href="https://docs.raku.org/type/Str">Str</a> 对象的原因，它们是字符串化路径的正确方法。</p>
<p>但是，不要急于将任何东西字符串化起来。将路径作为 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 对象传递。在路径上运行的所有例程都可以处理它们，因此不需要转换它们。</p>
<h2 id="working-with-fileshttpsdocsrakuorglanguageio-guide___top"><a href="https://docs.raku.org/language/io-guide#___top">Working with files</a></h2>
<h3 id="writing-into-fileshttpsdocsrakuorglanguageio-guide___top"><a href="https://docs.raku.org/language/io-guide#___top">Writing into files</a></h3>
<h4 id="writing-new-contenthttpsdocsrakuorglanguageio-guide___top"><a href="https://docs.raku.org/language/io-guide#___top">Writing new content</a></h4>
<p>让我们制作一些文件并从中写入和读取数据！<a href="https://docs.raku.org/routine/spurt"><code>spurt</code></a> 和 <a href="https://docs.raku.org/routine/slurp"><code>slurp</code></a> 程序写和读取一块儿数据。除非您正在处理难以完全存储在内存中的非常大的文件，否则这两个例程都适合您。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">my-file.txt</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">spurt</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">I ♥ Perl!</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>上面的代码在当前目录中创建了一个名为 <code>my-file.txt</code> 的文件，然后将文本 <code>I ♥ Perl!</code> 写入其中。如果 Raku 是您的第一语言，请庆祝您任务完成了！尝试打开您使用其他程序创建的文件，以验证您使用程序编写的内容。如果您已经了解其他语言，您可能想知道本指南是否遗漏了处理编码或错误条件等问题。</p>
<p>但是，这就是您需要的所有代码。默认情况下，字符串将按 <code>utf-8</code> 编码进行编码，并通过 <a href="https://docs.raku.org/type/Failure">Failure</a> 机制处理错误：这些是您可以使用常规条件处理的异常。在这种情况下，我们会让所有潜在的 <a href="https://docs.raku.org/type/Failure">Failures</a> 在调用之后陷入沉没，因此它们包含的任何<a href="https://docs.raku.org/type/Exception">异常</a>都将被抛出。</p>
<h4 id="追加内容httpsdocsrakuorglanguageio-guide___top"><a href="https://docs.raku.org/language/io-guide#___top">追加内容</a></h4>
<p>如果您想在我们在上一节中创建的文件中添加更多内容，您可以注意 <a href="https://docs.raku.org/routine/spurt"><code>spurt</code></a> 文档中提到的 <code>:append</code> 参数。但是，为了更好地控制，让我们自己使用 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 来处理：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">my-file.txt</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">open</span><span class="o">:</span> <span class="p">:</span><span class="s">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">I count: </span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span><span class="o">:</span> <span class="p">&#34;</span><span class="nv">$_</span><span class="s2"> </span><span class="p">&#34;</span> <span class="k">for</span> <span class="o">^</span><span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span></code></pre></div><p><a href="https://docs.raku.org/routine/open"><code>.open</code></a> 方法调用打开我们的 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a>，并返回一个 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a>。我们把 <code>:a</code> 作为参数传递，表示我们想要以追加模式打开文件。</p>
<p>在接下来的两行代码中，我们使用 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 上的 <a href="https://docs.raku.org/routine/print"><code>.print</code></a> 常用方法打印包含 11 个文本（<code>'I count: '</code> 字符串和 10 个数字）的文本行。请注意，<a href="https://docs.raku.org/type/Failure">Failure</a> 机制再一次负责我们的所有错误检查。如果 <a href="https://docs.raku.org/routine/open"><code>.open</code></a> 失败，它将返回一个 <a href="https://docs.raku.org/type/Failure">Failure</a>，当我们尝试在其上调用 <a href="https://docs.raku.org/routine/print"><code>.print</code></a> 方法时将抛出异常。</p>
<p>最后，我们通过调用它上面的 <a href="https://docs.raku.org/routine/close"><code>.close</code></a> 方法来关闭 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a>。这样<em>做很重要</em>，特别是在大型程序或处理大量文件的程序中，因为许多系统对程序可以同时打开的文件数量有限制。如果您没有关闭句柄，最终您将达到该限制并且 <a href="https://docs.raku.org/routine/open"><code>.open</code></a> 调用将失败。请注意，与其他一些语言不同，Raku 不使用引用计数，因此当离开所定义的作用域时，文件句柄<strong>不会关闭</strong>。只有当它们被垃圾收集并且未能关闭句柄时，它们才会被关闭，这可能会导致程序在打开的句柄有机会在垃圾回收<em>之前</em>达到文件限制。</p>
<h3 id="从文件中读取httpsdocsrakuorglanguageio-guide___top"><a href="https://docs.raku.org/language/io-guide#___top">从文件中读取</a></h3>
<h4 id="使用-iopathhttpsdocsrakuorglanguageio-guide___top"><a href="https://docs.raku.org/language/io-guide#___top">使用 IO::Path</a></h4>
<p>我们在前面的章节中已经看到，在文件中写东西是 Raku 中的单行代码。从它们中读取，同样容易：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">my-file.txt</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>        <span class="c1"># OUTPUT: «I ♥ Perl!␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">my-file.txt</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">slurp</span><span class="o">:</span> <span class="p">:</span><span class="s">bin</span><span class="p">;</span>  <span class="c1"># OUTPUT: «Buf[uint8]:0x&lt;49 20 e2 99 a5 20 50 65 72 6c 21&gt;␤» </span>
</span></span></code></pre></div><p><a href="https://docs.raku.org/routine/slurp"><code>.slurp</code></a> 方法读取文件的全部内容并将其作为单个 <a href="https://docs.raku.org/type/Str">Str</a> 对象返回，如果请求二进制模式，则通过指定 <code>:bin</code> 命名参数将其作为 <a href="https://docs.raku.org/type/Buf">Buf</a> 对象返回。</p>
<p>由于 <a href="https://docs.raku.org/routine/slurp">slurping</a> 将整个文件加载到内存中，因此它不适合处理大文件。</p>
<p><a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 类型提供了另外两种方便的方法：<a href="https://docs.raku.org/type/IO::Path#method_words"><code>.words</code></a> 与 <a href="https://docs.raku.org/type/IO::Path#method_lines"><code>.lines</code></a>，这俩方法惰性地读取小块文件并返回（默认）不保留已消耗值的<a href="https://docs.raku.org/type/Seq">Seq</a> 对象。</p>
<p>这是一个示例，它在文本文件中查找提及 Perl 的行并将其打印出来。尽管文件本身太大而无法容纳到可用的<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a> 中，但程序运行时不会出现任何问题，因为内容是以小块的形式处理的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="p">&#39;</span><span class="s1">500-PetaByte-File.txt</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">lines</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="o">*.</span><span class="nb">contains</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">Perl</span><span class="p">&#39;;</span>
</span></span></code></pre></div><p>这是另一个打印文件中前 100 个单词的示例，没有完全加载它：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="p">&#39;</span><span class="s1">500-PetaByte-File.txt</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">words</span><span class="o">:</span> <span class="mi">100</span>
</span></span></code></pre></div><p>请注意，我们通过传递 limit 参数给 <a href="https://docs.raku.org/type/IO::Path#method_words"><code>.words</code></a>而不是使用<a href="https://docs.raku.org/language/operators#index-entry-array_indexing_operator-array_subscript_operator-array_indexing_operator">列表索引操作</a> 来完成此操作。原因是在于底层仍然使用文件句柄，并且在完全使用返回的 <a href="https://docs.raku.org/type/Seq">Seq</a> 之前，句柄将保持打开状态。如果没有引用 <a href="https://docs.raku.org/type/Seq">Seq</a>，最终句柄将在垃圾收集运行期间关闭，但在大型程序中使用大量文件时，最好确保所有句柄立即关闭。所以，你应该始终确保 <a href="https://docs.raku.org/type/Seq">Seq</a> 从<a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 的 <a href="https://docs.raku.org/type/IO::Path#method_words"><code>.words</code></a> 和 <a href="https://docs.raku.org/type/IO::Path#method_lines"><code>.lines</code></a> 方法是<a href="https://docs.raku.org/language/glossary#index-entry-Reify">完全具体化</a> ; 而 limit 参数可以帮助你。</p>
<h4 id="using-iohandlehttpsdocsrakuorglanguageio-guide___top"><a href="https://docs.raku.org/language/io-guide#___top">Using IO::Handle</a></h4>
<p>当然，您可以使用 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 类型从文件中读取，这样可以更好地控制您正在执行的操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">some-file.txt</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">open</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">.</span><span class="nb">readchars</span><span class="o">:</span> <span class="mi">8</span><span class="p">;</span>  <span class="c1"># OUTPUT: «I ♥ Perl␤» </span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="nb">seek</span><span class="o">:</span> <span class="mi">1</span><span class="o">,</span> <span class="n">SeekFromCurrent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="o">.</span><span class="nb">readchars</span><span class="o">:</span> <span class="mi">15</span><span class="p">;</span>  <span class="c1"># OUTPUT: «I ♥ Programming␤» </span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="nb">close</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 给你 <a href="https://docs.raku.org/type/IO::Handle#method_read">.read</a>，<a href="https://docs.raku.org/type/IO::Handle#method_readchars">.readchars</a>，<a href="https://docs.raku.org/type/IO::Handle#routine_get">.get</a>，<a href="https://docs.raku.org/type/IO::Handle#method_getc">.getc</a>，<a href="https://docs.raku.org/type/IO::Handle#routine_words">.words</a>，<a href="https://docs.raku.org/type/IO::Handle#routine_lines">.lines</a>，<a href="https://docs.raku.org/type/IO::Handle#routine_slurp">.slurp</a>，<a href="https://docs.raku.org/type/IO::Handle#method_comb">.comb</a>，<a href="https://docs.raku.org/type/IO::Handle#method_split">.split</a> 和 <a href="https://docs.raku.org/type/IO::Handle#method_Supply">.Supply</a> 方法从中读取数据。有很多选择; 当你读取完时，需要关闭句柄。</p>
<p>与某些语言不同，当离开定义的作用域时，句柄不会自动关闭。相反，它将保持打开，直到被垃圾回收为止。为了使关闭更容易，一些方法允许您指定 <code>:close</code> 参数，您还可以使用 <a href="https://docs.raku.org/language/phasers#index-entry-will_trait"><code>will leave</code></a> trait 或 <a href="https://modules.raku.org/dist/Trait::IO"><code>Trait::IO</code></a> 模块提供的 <code>does auto-close</code> trait。</p>
<h1 id="错误的做事方法httpsdocsrakuorglanguageio-guide___top"><a href="https://docs.raku.org/language/io-guide#___top">错误的做事方法</a></h1>
<p>本节介绍如何不执行 Raku IO。</p>
<h2 id="别去管-spechttpsdocsrakuorglanguageio-guide___top"><a href="https://docs.raku.org/language/io-guide#___top">别去管 $*SPEC</a></h2>
<p>您可能听说过 <a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*SPEC</code></a> 并看到过一些代码或书籍显示其用于拆分和连接路径片段的用法。它提供的一些例程名称甚至可能看起来与您在其他语言中使用的名称相似。</p>
<p>但是，除非您正在编写自己的 IO 框架，否则几乎不需要直接使用 <a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*SPEC</code></a>。<a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*SPEC</code></a> 提供低级别的东西，它的使用不仅会使你的代码难以阅读，你可能会引入安全问题（例如空字符）！</p>
<p><a href="https://docs.raku.org/type/IO::Path"><code>IO::Path</code></a> 类型是 Raku 世界的主力。它满足所有路径操作需求，并提供快捷例程，让您避免处理文件句柄。用它而不是 <a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*SPEC</code></a> 这样的东西。</p>
<p>提示：您可以使用 <code>/</code> 连接路径部分并将其提供给 <a href="https://docs.raku.org/type/IO::Path"><code>IO::Path</code></a> 例程; 无论操作系统如何，他们仍然可以做正确的事情。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># WRONG!! TOO MUCH WORK! </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="vg">$*SPEC</span><span class="o">.</span><span class="nb">catpath</span><span class="o">:</span> <span class="p">&#39;&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">foo/bar</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$file</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$data</span> <span class="o">=</span> <span class="nv">$fh</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># RIGHT! Use IO::Path to do all the dirty work </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$data</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">foo/bar</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">add</span><span class="p">(</span><span class="nv">$file</span><span class="p">)</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>
</span></span></code></pre></div><p>但是，将它用于 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 无法提供的东西是很好的。例如，<a href="https://docs.raku.org/routine/devnull"><code>.devnull</code></a> 方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">temp</span> <span class="vg">$*OUT</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">:</span><span class="s">w</span><span class="o">,</span> <span class="vg">$*SPEC</span><span class="o">.</span><span class="nb">devnull</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">In space no one can hear you scream!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;;</span>
</span></span></code></pre></div><h2 id="字符串化-iopathhttpsdocsrakuorglanguageio-guide___top"><a href="https://docs.raku.org/language/io-guide#___top">字符串化 IO::Path</a></h2>
<p>不要使用 <code>.Str</code> 方法对 <a href="https://docs.raku.org/type/IO::Path"><code>IO::Path</code></a> 对象进行字符串化，除非您只是想将它们显示在某个地方以供参考或使用。<code>.Str</code> 方法返回 <a href="https://docs.raku.org/type/IO::Path"><code>IO::Path</code></a> 实例化的任何基本路径字符串。它不考虑 <a href="https://docs.raku.org/type/IO::Path#attribute_CWD"><code>$.CWD</code></a> 属性的值。例如，此代码已损坏：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$path</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">chdir</span> <span class="p">&#39;</span><span class="s1">bar</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># WRONG!! .Str DOES NOT USE $.CWD! </span>
</span></span><span class="line"><span class="cl"><span class="nb">run</span> <span class="p">&lt;</span><span class="s">tar -cvvf archive.tar</span><span class="p">&gt;</span><span class="o">,</span> <span class="nv">$path</span><span class="o">.</span><span class="kt">Str</span><span class="p">;</span>
</span></span></code></pre></div><p><a href="https://docs.raku.org/routine/chdir"><code>chdir</code></a> 调用更改了当前目录的值，但我们创建的  <code>$path</code> 是相对于该更改之前的目录。</p>
<p>但是，<a href="https://docs.raku.org/type/IO::Path"><code>IO::Path</code></a> 对象<em>确实</em>知道它相对于哪个目录。我们只需要使用 <a href="https://docs.raku.org/routine/absolute"><code>.absolute</code></a> 或 <a href="https://docs.raku.org/routine/relative"><code>.relative</code></a> 来字符串化对象。两个例程都返回一个 <a href="https://docs.raku.org/type/Str"><code>Str</code></a> 对象; 它们不同之处在于结果是绝对路径还是相对路径。所以，我们可以像这样修复我们的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$path</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">chdir</span> <span class="p">&#39;</span><span class="s1">bar</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># RIGHT!! .absolute does consider the value of $.CWD! </span>
</span></span><span class="line"><span class="cl"><span class="nb">run</span> <span class="p">&lt;</span><span class="s">tar -cvvf archive.tar</span><span class="p">&gt;</span><span class="o">,</span> <span class="nv">$path</span><span class="o">.</span><span class="nb">absolute</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Also good: </span>
</span></span><span class="line"><span class="cl"><span class="nb">run</span> <span class="p">&lt;</span><span class="s">tar -cvvf archive.tar</span><span class="p">&gt;</span><span class="o">,</span> <span class="nv">$path</span><span class="o">.</span><span class="nb">relative</span><span class="p">;</span>
</span></span></code></pre></div><h2 id="注意-cwdhttpsdocsrakuorglanguageio-guide___top"><a href="https://docs.raku.org/language/io-guide#___top">注意 $*CWD</a></h2>
<p>虽然通常不在视线范围内，但默认情况下，每个 <a href="https://docs.raku.org/type/IO::Path"><code>IO::Path</code></a> 对象都使用 <a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*CWD</code></a> 的当前值来设置其 <a href="https://docs.raku.org/type/IO::Path#attribute_CWD"><code>$.CWD</code>属性</a>。这意味着有两件事需要注意。</p>
<h3 id="temp-the-cwdhttpsdocsrakuorglanguageio-guide___top"><a href="https://docs.raku.org/language/io-guide#___top">temp the $*CWD</a></h3>
<p>这段代码是错误的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># WRONG!! </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="vg">$*CWD</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="p">;</span>
</span></span></code></pre></div><p><code>my $*CWD</code> 让 <a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*CWD</code></a> 变为未定义的。然后 <a href="https://docs.raku.org/routine/IO"><code>.IO</code></a> coercer 继续并将其正创建的路径的<a href="https://docs.raku.org/type/IO::Path#attribute_CWD"><code>$.CWD</code></a> 属性设置为 undefined 的 <code>$*CWD</code> 字符串化版本 ; 一个空字符串。</p>
<p>执行此操作的正确方法是使用 <a href="https://docs.raku.org/routine/temp"><code>temp</code></a> 而不是 <code>my</code>。它会将 <a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*CWD</code></a> 的更改效果本地化，就像 <code>my</code> 那样，但它不会使其未定义，因此 <a href="https://docs.raku.org/routine/IO"><code>.IO</code></a> coercer 仍将获得正确的旧值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">temp</span> <span class="vg">$*CWD</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="p">;</span>
</span></span></code></pre></div><p>更好的是，如果要在本地化的 <a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*CWD</code></a> 中执行某些代码，请使用该<a href="https://docs.raku.org/routine/indir"><code>indir</code></a> 例程。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[散列和映射]]></title>
            <link href="http://localhost:1313/rakulang/46.hashes-and-maps/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/sink-to-hbase-using-structured-streaming/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Spark Structured Streaming 落数据到 HBase 中" />
                <link href="http://localhost:1313/rakulang/45.grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Grammars" />
                <link href="http://localhost:1313/rakulang/44.functions/?utm_source=atom_feed" rel="related" type="text/html" title="函数" />
                <link href="http://localhost:1313/notes/the-modules-that-will-be-rewrite-in-perl6/?utm_source=atom_feed" rel="related" type="text/html" title="The modules that will be rewrite in Raku" />
                <link href="http://localhost:1313/notes/send-data-to-socket/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 发送数据到 Socket" />
            
                <id>http://localhost:1313/rakulang/46.hashes-and-maps/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-21T21:13:31+08:00</published>
            <updated>2018-11-21T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h2 id="关联角色和关联类">关联角色和关联类</h2>
<p><a href="https://docs.raku.org/type/Associative">关联</a>角色是 Hash 和 Map 以及 <a href="https://docs.raku.org/type/MixHash">MixHash</a> 等其他类的基础。它定义了将在关联类中使用的两种类型; 默认情况下，您可以使用任何内容（字面意思，因为任何 <a href="https://docs.raku.org/type/Any">Any</a> 子类的类都可以使用）<a href="https://docs.raku.org/language/hashmap#Non-string_keys_%28object_hash%29%2C_although_it_will_be_coerced_to_a_string%2C_and_any_object_as_value._You_can_access_these_types_using_the_C%3Cof">作为键</a>和 <code>keyof</code> 方法。</p>
<p>默认情况下，使用 <code>%</code> sigil 声明的任何对象都将获得 Associative 角色，默认情况下将表现为散列，但此角色仅提供上述两种方法，以及默认的 Hash 行为。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="nv">%</span><span class="p">)</span><span class="o">.^</span><span class="nb">name</span> <span class="p">;</span> <span class="c1"># 输出 Hash</span>
</span></span></code></pre></div><p>相反，如果未混入 <code>Associative</code> 角色，则不能使用 <code>%</code> sigil，但由于此角色没有任何关联属性，因此你必须重新定义<a href="https://docs.raku.org/language/operators#postcircumfix_%7B_%7D">散列下标操作符</a>的行为。为此，你必须重写几个函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Logger</span> <span class="k">does</span> <span class="kt">Associative</span><span class="o">[</span><span class="kt">Cool</span><span class="o">,</span><span class="kt">DateTime</span><span class="o">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">%.store</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">log</span><span class="p">(</span> <span class="kt">Cool</span> <span class="nv">$event</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">%.store</span><span class="p">{</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="nb">now</span> <span class="p">)</span> <span class="p">}</span> <span class="o">=</span> <span class="nv">$event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nb">AT-KEY</span> <span class="p">(</span> <span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">@keys</span> <span class="o">=</span> <span class="nv">%.store</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span> <span class="p">/</span><span class="nv">$key</span><span class="p">/</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nv">%.store</span><span class="p">{</span> <span class="nv">@keys</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nb">EXISTS-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">%.store</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span> <span class="p">/</span><span class="nv">$key</span><span class="p">/</span> <span class="p">)</span><span class="o">??</span><span class="kt">True</span><span class="o">!!</span><span class="kt">False</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nb">DELETE-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="ne">X::Assignment::RO</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nb">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nb">ASSIGN-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="o">,</span> <span class="nv">$new</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="ne">X::Assignment::RO</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nb">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nb">BIND-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="o">,</span> \<span class="nb">new</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="ne">X::Assignment::RO</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nb">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Logger</span><span class="o">.</span><span class="k">of</span><span class="p">;</span>                   <span class="c1"># OUTPUT: «(Cool)» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%logger</span> <span class="o">:=</span> <span class="n">Logger</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%logger</span><span class="o">.</span><span class="k">of</span><span class="p">;</span>                  <span class="c1"># OUTPUT: «(Cool)» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nv">%logger</span><span class="o">.</span><span class="nb">log</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">Stuff</span><span class="p">&#34;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">%logger</span><span class="o">.</span><span class="nb">log</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">More stuff</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%logger</span><span class="p">&lt;</span><span class="s">2018-05-26</span><span class="p">&gt;;</span>         <span class="c1"># OUTPUT: «(More stuff Stuff)» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%logger</span><span class="p">&lt;</span><span class="s">2018-04-22</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span>  <span class="c1"># OUTPUT: «False» </span>
</span></span></code></pre></div><p>在这里，我们定义了一个具有关联语义的 logger，它可以使用日期（或其中一部分）作为键。由于我们将参数化 <code>Associative</code> 为那些特定类，<code>of</code> 将返回我们使用的值类型，在这里为 <code>Cool</code>（我们只能记录列表或字符串）。混合 <code>Associative</code> 角色赋予其使用 <code>%</code> sigil 的权利; 因为 <code>%</code>-sigilled 变量默认获得 <code>Hash</code> 类型，所以在定义中需要绑定。</p>
<p>此 log 将仅附加，这就是为什么我们转义关联数组隐喻以使用 <code>log</code> 方法向日志添加新事件。但是，一旦添加它们，我们就可以按日期检索它们或检查它们是否存在。对于第一个，我们必须重写 <code>AT-KEY</code> multi 方法，对于后者 <code>EXIST-KEY</code>。在最后两个语句中，我们展示了下标操作如何调用 <code>AT-KEY</code>，而 <code>:exists</code> 副词调用 <code>EXISTS-KEY</code>。</p>
<p>我们重写 <code>DELETE-KEY</code>，<code>ASSIGN-KEY</code> 和 <code>BIND-KEY</code>，但只抛出异常。尝试赋值，删除或绑定值到键上将导致 <code>Cannot modify an immutable Str (value)</code> 异常抛出。</p>
<p>使类关联提供了一种使用哈希来使用和使用它们的非常方便的方法; 在 <a href="http://cro.services/docs/reference/cro-http-client#Setting_the_request_body">Cro</a> 中可以看到一个例子，它广泛使用它来方便使用哈希定义结构化请求并表达其响应。</p>
<h2 id="可变哈希和不可变映射">可变哈希和不可变映射</h2>
<p>Hash 是从键到值的可变映射（在其他编程语言中称为字典，哈希表或映射）。这些值都是标量容器，这意味着你可以给它们赋值。另一方面，<a href="https://docs.raku.org/type/Map">Map</a>s是不可变的。键与值配对后，此配对无法更改。</p>
<p>Maps 和 hashes 通常存储在百分号 <code>%</code> 变量中，用于表示它们是关联的(Associative)。</p>
<p>通过 <code>{}</code> postcircumfix 运算符使用键访问 Hash 和 map 元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="vg">%*ENV</span><span class="p">{&#39;</span><span class="s1">HOME</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">PATH</span><span class="p">&#39;}</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «(&#34;/home/camelia&#34;, &#34;/usr/bin:/sbin:/bin&#34;)␤» </span>
</span></span></code></pre></div><p>一般的<a href="https://docs.raku.org/language/subscripts">下标</a>规则适用于提供字符串字面量列表的快捷方式，包括插值和不插值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="s">oranges</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">round</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">bananas</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">bendy</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">oranges bananas</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «(round bendy)␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fruit</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">bananas</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="p">«</span><span class="s2">oranges &#34;</span><span class="nv">$fruit</span><span class="s2">&#34;</span><span class="p">»;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «(round bendy)␤» </span>
</span></span></code></pre></div><p>您只需分配一个未使用的键即可添加新对：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">%h</span><span class="p">{&#39;</span><span class="s1">new key</span><span class="p">&#39;}</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">new value</span><span class="p">&#39;;</span>
</span></span></code></pre></div><h2 id="hash-赋值">Hash 赋值</h2>
<p>将一个元素列表赋值给一个哈希变量首先清空该变量，然后迭代右侧的元素。如果元素是 <a href="https://docs.raku.org/type/Pair">Pair</a>，则将其键作为新的哈希键，并将其值作为该键的新哈希值。否则，该值被强制转换为 <a href="https://docs.raku.org/type/Str">Str</a> 并用作散列键，而列表的下一个元素则被视为相应的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">c</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">d</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">e</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">f</span><span class="p">&#39;;</span>
</span></span></code></pre></div><p>等价于</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">c</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">d</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">e</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">f</span><span class="p">&#39;;</span>
</span></span></code></pre></div><p>或者</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e f</span><span class="p">&gt;;</span>
</span></span></code></pre></div><p>甚至</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="nv">%</span><span class="p">(</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">c</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">d</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">e</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">f</span><span class="p">&#39;)</span>
</span></span></code></pre></div><p>或者</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$h</span> <span class="o">=</span> <span class="p">{</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">c</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">d</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">e</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">f</span><span class="p">&#39;};</span>
</span></span></code></pre></div><p>请注意，花括号仅在我们未将其分配给 %-sigilled 变量的情况下使用;如果我们将它用于 %-sigilled 变量，我们将遇到 <code>Potential difficulties:␤ Useless use of hash composer on right side of hash assignment; did you mean := instead?</code> 的错误。但是，正如此错误所示，只要我们使用绑定，我们就可以使用花括号：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span> <span class="o">:=</span> <span class="p">{</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">c</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">d</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">e</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">f</span><span class="p">&#39;};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="p">;</span> <span class="c1"># OUTPUT: «{a =&gt; b, c =&gt; d, e =&gt; f}␤» </span>
</span></span></code></pre></div><p>嵌套哈希也可以使用相同的语法定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span>  <span class="s">e</span> <span class="o">=&gt;</span> <span class="s">f</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">g</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">e</span><span class="p">&gt;&lt;</span><span class="s">f</span><span class="p">&gt;;</span> <span class="c1"># OUTPUT: «g␤» </span>
</span></span></code></pre></div><p>但是，你在这里定义的是一个指向 <a href="https://docs.raku.org/type/Pair">Pair</a> 的键，如果你想要的话，这很好，如果你的嵌套哈希有一个键。但是 <code>%h &lt;e&gt;</code> 将指向 <code>Pair</code> 会产生这些后果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span>  <span class="s">e</span> <span class="o">=&gt;</span> <span class="s">f</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">g</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">%h</span><span class="p">&lt;</span><span class="s">e</span><span class="p">&gt;&lt;</span><span class="s">q</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">k</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «(exit code 1) Pair␤Cannot modify an immutable Str (Nil)␤  in block &lt;unit&gt;»</span>
</span></span></code></pre></div><p>但是，这将有效地定义嵌套哈希：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span>  <span class="s">e</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="s">f</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">g</span><span class="p">&#39;};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">e</span><span class="p">&gt;</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>  <span class="c1"># OUTPUT: «Hash␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">e</span><span class="p">&gt;&lt;</span><span class="s">f</span><span class="p">&gt;;</span>     <span class="c1"># OUTPUT: «g␤» </span>
</span></span></code></pre></div><p>如果遇到期望值的 <a href="https://docs.raku.org/type/Pair">Pair</a>，则将其用作哈希值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">a</span><span class="p">&gt;</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>            <span class="c1"># OUTPUT: «Pair␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">a</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">key</span><span class="p">;</span>              <span class="c1"># OUTPUT: «b␤» </span>
</span></span></code></pre></div><p>如果同一个键出现多次，则与其最后一次出现的值存储在哈希中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">a</span><span class="p">&gt;;</span>                  <span class="c1"># OUTPUT: «2␤» </span>
</span></span></code></pre></div><p>要将哈希值分配给不具有％sigil的变量，可以使用％（）哈希构造函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$h</span> <span class="o">=</span> <span class="nv">%</span><span class="p">(</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">b</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$h</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>               <span class="c1"># OUTPUT: «Hash␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$h</span><span class="p">&lt;</span><span class="s">a</span><span class="p">&gt;;</span>                  <span class="c1"># OUTPUT: «1␤» </span>
</span></span></code></pre></div><p>如果一个或多个值引用主题变量$ _，则赋值的右侧将被解释为<a href="https://docs.raku.org/type/Block">块</a>，而不是哈希：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@people</span> <span class="o">=</span> <span class="o">[</span>
</span></span><span class="line"><span class="cl">    <span class="nv">%</span><span class="p">(</span> <span class="s">id</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">1A</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">firstName</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Andy</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">lastName</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Adams</span><span class="p">&#34;</span> <span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="nv">%</span><span class="p">(</span> <span class="s">id</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">2B</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">firstName</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Beth</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">lastName</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Burke</span><span class="p">&#34;</span> <span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ... </span>
</span></span><span class="line"><span class="cl"><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">lookup-user</span> <span class="p">(</span><span class="kt">Hash</span> <span class="nv">$h</span><span class="p">)</span> <span class="p">{</span> <span class="cm">#`(Do something...)</span> <span class="nv">$h</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="nb">map</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># While this creates a hash: </span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span>  <span class="nv">$query</span> <span class="o">=</span> <span class="p">{</span> <span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="nv">$person</span><span class="s2">&lt;firstName&gt; </span><span class="nv">$person</span><span class="s2">&lt;lastName&gt;</span><span class="p">&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$query</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>      <span class="c1"># OUTPUT: «Hash␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="c1"># Doing this will create a Block. Oh no! </span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span>  <span class="nv">$query2</span> <span class="o">=</span> <span class="p">{</span> <span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="nv">$_</span><span class="s2">&lt;firstName&gt; </span><span class="nv">$_</span><span class="s2">&lt;lastName&gt;</span><span class="p">&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$query2</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>       <span class="c1"># OUTPUT: «Block␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$query2</span><span class="o">&lt;</span><span class="nb">name</span><span class="o">&gt;</span><span class="p">;</span>       <span class="c1"># fails </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># OUTPUT: «X::AdHoc: Type Block does not support associative indexing.␤» </span>
</span></span><span class="line"><span class="cl">    <span class="nf">lookup-user</span><span class="p">(</span><span class="nv">$query</span><span class="p">);</span>   <span class="c1"># Type check failed in binding $h; expected Hash but got Block </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="o">,</span> <span class="nv">@people</span><span class="p">;</span>
</span></span></code></pre></div><p>如果您使用了％（）哈希构造函数，则可以避免这种情况。仅使用花括号来创建块。</p>
<h2 id="hash-切片">Hash 切片</h2>
<p>您可以使用切片同时分配多个键。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span><span class="p">;</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="o">=</span> <span class="mi">2</span> <span class="ow">xx</span> <span class="o">*</span><span class="p">;</span> <span class="nv">%h</span><span class="o">.</span><span class="nb">perl</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>  <span class="c1"># OUTPUT: «{:a(2), :b(2), :c(2)}␤» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span><span class="p">;</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="o">=</span> <span class="o">^</span><span class="mi">3</span><span class="p">;</span>     <span class="nv">%h</span><span class="o">.</span><span class="nb">perl</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>  <span class="c1"># OUTPUT: «{:a(0), :b(1), :c(2)}␤» </span>
</span></span></code></pre></div><h2 id="非字符串键对象哈希">非字符串键（对象哈希）</h2>
<p>默认情况下，{} 中的键被强制为字符串。要使用非字符串键组合散列，请使用冒号前缀：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$when</span> <span class="o">=</span> <span class="o">:</span><span class="p">{</span> <span class="p">(</span><span class="nb">now</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Instant</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">(</span><span class="kt">DateTime</span><span class="o">.</span><span class="nb">now</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">DateTime</span><span class="p">&#34;</span> <span class="p">};</span>
</span></span></code></pre></div><p>请注意，将对象作为键，您通常无法使用&lt;&hellip;&gt;构造进行键查找，因为它只创建字符串和同形异义。请改用{&hellip;}：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">:</span><span class="p">{</span>  <span class="mi">0</span>  <span class="o">=&gt;</span> <span class="mi">42</span> <span class="p">}&lt;</span><span class="s">0</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>   <span class="c1"># Int    as key, IntStr in lookup; OUTPUT: «(Any)␤» </span>
</span></span><span class="line"><span class="cl"><span class="o">:</span><span class="p">{</span>  <span class="mi">0</span>  <span class="o">=&gt;</span> <span class="mi">42</span> <span class="p">}{</span><span class="mi">0</span><span class="p">}</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>   <span class="c1"># Int    as key, Int    in lookup; OUTPUT: «42␤» </span>
</span></span><span class="line"><span class="cl"><span class="o">:</span><span class="p">{</span> <span class="p">&#39;</span><span class="s1">0</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">42</span> <span class="p">}&lt;</span><span class="s">0</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>   <span class="c1"># Str    as key, IntStr in lookup; OUTPUT: «(Any)␤» </span>
</span></span><span class="line"><span class="cl"><span class="o">:</span><span class="p">{</span> <span class="p">&#39;</span><span class="s1">0</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">42</span> <span class="p">}{&#39;</span><span class="s1">0</span><span class="p">&#39;}</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># Str    as key, Str    in lookup; OUTPUT: «42␤» </span>
</span></span><span class="line"><span class="cl"><span class="o">:</span><span class="p">{</span> <span class="p">&lt;</span><span class="s">0</span><span class="p">&gt;</span> <span class="o">=&gt;</span> <span class="mi">42</span> <span class="p">}&lt;</span><span class="s">0</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>   <span class="c1"># IntStr as key, IntStr in lookup; OUTPUT: «42␤» </span>
</span></span></code></pre></div><p>注意：Rakudo实现目前错误地对{}应用与{}相同的规则，并且可以在某些情况下构造块。为避免这种情况，您可以直接实例化参数化哈希。还支持％-sigiled变量的参数化：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Num</span> <span class="nv">%foo1</span>      <span class="o">=</span> <span class="p">&#34;</span><span class="s2">0</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="mf">0e0</span><span class="p">;</span> <span class="c1"># Str keys and Num values </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span>     <span class="nv">%foo2</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span> <span class="o">=</span>  <span class="mi">0</span>  <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">x</span><span class="p">&#34;;</span> <span class="c1"># Int keys and Any values </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Num</span> <span class="nv">%foo3</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span> <span class="o">=</span>  <span class="mi">0</span>  <span class="o">=&gt;</span> <span class="mf">0e0</span><span class="p">;</span> <span class="c1"># Int keys and Num values </span>
</span></span><span class="line"><span class="cl"><span class="kt">Hash</span><span class="o">[</span><span class="kt">Num</span><span class="o">,</span><span class="kt">Int</span><span class="o">].</span><span class="nb">new</span><span class="o">:</span> <span class="mi">0</span><span class="o">,</span> <span class="mf">0e0</span><span class="p">;</span>      <span class="c1"># Int keys and Num values </span>
</span></span></code></pre></div><p>现在，如果您要定义一个哈希来保存您正在使用的对象作为您提供给哈希用作键的确切对象的键，那么对象哈希就是您要查找的内容。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%intervals</span><span class="p">{</span><span class="kt">Instant</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$first-instant</span> <span class="o">=</span> <span class="nb">now</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">%intervals</span><span class="p">{</span> <span class="nv">$first-instant</span> <span class="p">}</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Our first milestone.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">sleep</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$second-instant</span> <span class="o">=</span> <span class="nb">now</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">%intervals</span><span class="p">{</span> <span class="nv">$second-instant</span> <span class="p">}</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Logging this Instant for spurious raisins.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">%intervals</span><span class="o">.</span><span class="nb">sort</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="o">:</span><span class="nv">$key</span><span class="o">,</span> <span class="o">:</span><span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">state</span> <span class="nv">$last-instant</span> <span class="o">//=</span> <span class="nv">$key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">We noted &#39;</span><span class="nv">$value&#39;</span><span class="s2"> at </span><span class="nv">$key</span><span class="s2">, with an interval of </span><span class="p">{</span><span class="nv">$key</span> <span class="o">-</span> <span class="nv">$last-instant</span><span class="p">}&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$last-instant</span> <span class="o">=</span> <span class="nv">$key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>此示例使用仅接受Instant类型的键的对象哈希来实现基本但类型安全的日志记录机制。我们利用一个命名的状态变量来跟踪前一个Instant，以便我们可以提供一个间隔。</p>
<p>对象哈希的整个要点是将密钥保持为对象本身。当前对象散列利用对象的WHICH方法，该方法返回每个可变对象的唯一标识符。这是对象标识运算符（===）所依赖的基石。顺序和容器在这里真的很重要，因为.keys的顺序是未定义的，一个匿名列表永远不会===到另一个。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%intervals</span><span class="p">{</span><span class="kt">Instant</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$first-instant</span> <span class="o">=</span> <span class="nb">now</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">%intervals</span><span class="p">{</span> <span class="nv">$first-instant</span> <span class="p">}</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Our first milestone.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">sleep</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$second-instant</span> <span class="o">=</span> <span class="nb">now</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">%intervals</span><span class="p">{</span> <span class="nv">$second-instant</span> <span class="p">}</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Logging this Instant for spurious raisins.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="nv">$first-instant</span><span class="o">,</span> <span class="nv">$second-instant</span><span class="p">)</span> <span class="o">~~</span> <span class="nv">%intervals</span><span class="o">.</span><span class="nb">keys</span><span class="p">;</span>       <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="nv">$first-instant</span><span class="o">,</span> <span class="nv">$second-instant</span><span class="p">)</span> <span class="o">~~</span> <span class="nv">%intervals</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">sort</span><span class="p">;</span>  <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="nv">$first-instant</span><span class="o">,</span> <span class="nv">$second-instant</span><span class="p">)</span> <span class="o">===</span> <span class="nv">%intervals</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">sort</span><span class="p">;</span> <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$first-instant</span> <span class="o">===</span> <span class="nv">%intervals</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">sort</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>                 <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>由于Instant定义了自己的比较方法，因此在我们的示例中，根据cmp的排序将始终提供最早的即时对象作为它返回的List中的第一个元素。</p>
<p>如果您想接受哈希中的任何对象，可以使用Any！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span><span class="p">{</span><span class="kt">Any</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nv">%h</span><span class="p">{(</span><span class="nb">now</span><span class="p">)}</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">This is an Instant</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">%h</span><span class="p">{(</span><span class="kt">DateTime</span><span class="o">.</span><span class="nb">now</span><span class="p">)}</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">This is a DateTime, which is not an Instant</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nv">%h</span><span class="p">{&#34;</span><span class="s2">completely different</span><span class="p">&#34;}</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Monty Python references are neither DateTimes nor Instants</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>有一种更简洁的语法，它使用绑定。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span> <span class="o">:=</span> <span class="o">:</span><span class="p">{</span> <span class="p">(</span><span class="nb">now</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Instant</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">(</span><span class="kt">DateTime</span><span class="o">.</span><span class="nb">now</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">DateTime</span><span class="p">&#34;</span> <span class="p">};</span>
</span></span></code></pre></div><p>绑定是必要的，因为对象哈希是关于非常可靠的特定对象，这是绑定在跟踪哪些任务并不关心哪些很好的事情。</p>
<h2 id="约束值类型">约束值类型</h2>
<p>在声明符和名称之间放置一个类型对象，以约束哈希值的所有值的类型。使用具有where子句的约束的子集。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">subset</span> <span class="nc">Powerful</span> <span class="k">of</span> <span class="kt">Int</span> <span class="k">where</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">9000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">Powerful</span> <span class="nv">%h</span><span class="p">{</span><span class="kt">Str</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">put</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">Goku</span><span class="p">&gt;</span>   <span class="o">=</span> <span class="mi">9001</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">%h</span><span class="p">&lt;</span><span class="s">Vegeta</span><span class="p">&gt;</span> <span class="o">=</span> <span class="mi">900</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">CATCH</span> <span class="p">{</span> <span class="k">when</span> <span class="ne">X::TypeCheck::Binding</span> <span class="p">{</span> <span class="o">.</span><span class="nb">message</span><span class="o">.</span><span class="nb">put</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 9001 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Type check failed in binding assignval; expected Powerful but got Int (900) </span>
</span></span></code></pre></div><h2 id="循环哈希键和值">循环哈希键和值</h2>
<p>处理散列中元素的常用习惯是循环键和值，例如，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%vowels</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">e</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">i</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">o</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">u</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">%vowels</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$vowel</span><span class="o">,</span> <span class="nv">$index</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">&#34;</span><span class="nv">$vowel:</span><span class="s2"> </span><span class="nv">$index</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>给出与此类似的输出：</p>
<pre tabindex="0"><code>a: 1
e: 2
o: 4
u: 5
i: 3
</code></pre><p>我们使用kv方法从散列中提取键及其各自的值，以便我们可以将这些值传递给循环。</p>
<p>请注意，不能依赖打印的键和值的顺序;对于同一程序的不同运行，散列的元素并不总是以相同的方式存储在内存中。事实上，从版本2018.05开始，订单在每次调用时都保证不同。有时人们希望处理排序的元素，例如哈希的键。如果有人希望按字母顺序打印元音列表，那么就会写一个</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%vowels</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">e</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">i</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">o</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">u</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">%vowels</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">*.</span><span class="nb">key</span><span class="p">)</span><span class="o">&gt;&gt;.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nv">$vowel</span><span class="o">,</span> <span class="nv">$index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">&#34;</span><span class="nv">$vowel:</span><span class="s2"> </span><span class="nv">$index</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>打印</p>
<pre tabindex="0"><code>a: 1
e: 2
i: 3
o: 4
u: 5
</code></pre><p>按字母顺序排列。为了达到这个结果，我们按键（％vowels.sort（* .key））对元音的哈希值进行排序，然后通过将.kv方法应用于每个元素，通过一元&raquo; superroperator生成元数据和值。键/值列表的列表。为了提取键/值，变量因此需要包含在括号中。</p>
<p>另一种解决方案是展平结果列表。然后可以使用与.kv相同的方式访问键/值对：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%vowels</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">e</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">i</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">o</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">u</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">%vowels</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">*.</span><span class="nb">key</span><span class="p">)</span><span class="o">&gt;&gt;.</span><span class="nb">kv</span><span class="o">.</span><span class="nb">flat</span> <span class="k">-&gt;</span> <span class="nv">$vowel</span><span class="o">,</span> <span class="nv">$index</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">&#34;</span><span class="nv">$vowel:</span><span class="s2"> </span><span class="nv">$index</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>您还可以使用解构来循环哈希。</p>
<h2 id="在位编辑值">在位编辑值</h2>
<p>有时您可能希望在迭代时修改哈希值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%answers</span> <span class="o">=</span> <span class="s">illuminatus</span> <span class="o">=&gt;</span> <span class="mi">23</span><span class="o">,</span> <span class="s">hitchhikers</span> <span class="o">=&gt;</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «hitchhikers =&gt; 42, illuminatus =&gt; 23» </span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">%answers</span><span class="o">.</span><span class="nb">values</span> <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nv">$v</span> <span class="o">+=</span> <span class="mi">10</span> <span class="p">};</span> <span class="c1"># Fails </span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::AdHoc: Cannot assign to a readonly variable or a value␤» </span>
</span></span></code></pre></div><p>传统上，这是通过发送密钥和值来完成的，如下所示。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%answers</span> <span class="o">=</span> <span class="s">illuminatus</span> <span class="o">=&gt;</span> <span class="mi">23</span><span class="o">,</span> <span class="s">hitchhikers</span> <span class="o">=&gt;</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">%answers</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$k</span><span class="o">,</span><span class="nv">$v</span> <span class="p">{</span> <span class="nv">%answers</span><span class="p">{</span><span class="nv">$k</span><span class="p">}</span> <span class="o">=</span> <span class="nv">$v</span> <span class="o">+</span> <span class="mi">10</span> <span class="p">};</span>
</span></span></code></pre></div><p>但是，可以利用块的签名来指定您希望对值进行读写访问。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%answers</span> <span class="o">=</span> <span class="s">illuminatus</span> <span class="o">=&gt;</span> <span class="mi">23</span><span class="o">,</span> <span class="s">hitchhikers</span> <span class="o">=&gt;</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">%answers</span><span class="o">.</span><span class="nb">values</span> <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span> <span class="nv">$v</span> <span class="o">+=</span> <span class="mi">10</span> <span class="p">};</span>
</span></span></code></pre></div><p>但是，即使在对象哈希的情况下，也不可能进行哈希键的就地编辑。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Grammars]]></title>
            <link href="http://localhost:1313/rakulang/45.grammars/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/44.functions/?utm_source=atom_feed" rel="related" type="text/html" title="函数" />
                <link href="http://localhost:1313/notes/the-modules-that-will-be-rewrite-in-perl6/?utm_source=atom_feed" rel="related" type="text/html" title="The modules that will be rewrite in Raku" />
                <link href="http://localhost:1313/notes/send-data-to-socket/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 发送数据到 Socket" />
                <link href="http://localhost:1313/rakulang/43.exceptions/?utm_source=atom_feed" rel="related" type="text/html" title="异常" />
                <link href="http://localhost:1313/rakulang/42.enumeration/?utm_source=atom_feed" rel="related" type="text/html" title="枚举" />
            
                <id>http://localhost:1313/rakulang/45.grammars/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-20T21:13:31+08:00</published>
            <updated>2018-11-20T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="grammarshttpdocrakuorglanguagegrammars"><a href="http://doc.raku.org/language/grammars">Grammars</a></h1>
<p>Grammars - 一组具名 regexes 组成正式的 grammar</p>
<p>Grammars 是一个很强大的工具用于析构文本并通常返回数据结构。</p>
<p>例如, Raku 是使用 Raku 风格 grammar 解析并执行的。</p>
<p>对普通 Raku 使用者更实用的一个例子是 <a href="https://github.com/moritz/json">JSON::Tiny</a>模块, 它能反序列化任何合法的 JSON 文件, 而反序列代码只有不到 100 行, 还能扩展。</p>
<p>Grammars 允许你把 regexes 组织到一块儿, 就像类(class) 中组织方法那样。</p>
<h2 id="具名正则-named-regexes">具名正则 (Named Regexes)</h2>
<p>　
grammars 的主要组成部分是 <a href="http://doc.raku.org/language/regexes">regexes</a>。 而 Raku 的 <a href="http://doc.raku.org/language/regexes">regexes</a>语法不在该文档的讨论范围, 具名正则(named regexes) 有它自己的特殊语法, 这跟子例程(subroutine) 的定义很像:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">number</span> <span class="p">{</span> <span class="o">\</span><span class="n">d</span><span class="o">+</span> <span class="p">[</span> <span class="o">\.</span> <span class="o">\</span><span class="n">d</span><span class="o">+</span> <span class="p">]?</span>   <span class="p">}</span>   <span class="c1"># 普通 regex 中空格被忽略, [] 是非捕获组</span>
</span></span></code></pre></div><p>上面的代码使用 <code>my</code> 关键字指定了本地作用域的 regex, 因为具名正则(named regexes) 通常用在 grammars 里面。</p>
<p>正则有名字了就方便我们在任何地方重用那个正则了:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;32.51&#34;</span> <span class="o">~~</span> <span class="o">&amp;</span><span class="n">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;15 + 4.5&#34;</span> <span class="o">~~</span> <span class="sr">/  \s* &#39;+&#39; \s*  /</span>
</span></span><span class="line"><span class="cl"><span class="o">&amp;</span><span class="n">number</span>           <span class="c1"># my regex number { \d+ [ \. \d+ ]?   }  </span>
</span></span></code></pre></div><p>为什么用 <code>&amp;number</code>, 对比具名子例程你就知道了:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="k">sub</span> <span class="nf">number</span> <span class="p">{</span> <span class="n">say</span> <span class="s">&#34;i am a subroutine&#34;</span> <span class="p">}</span>  <span class="c1"># 具名子例程</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">number</span>                                 <span class="c1"># sub number () { #`(Sub|140651249646256) ... }</span>
</span></span></code></pre></div><p><code>&amp;number</code> 就是直接引用了具名的 regex 或 子例程。而在<code>/ /</code> 或 grammars 里面, 引用一个具名正则的语法也很特殊, 就是给名字包裹上 <code>&lt; &gt;</code>。<code>&lt;&gt;</code> 就像引号那样, 当用它引起某个具名正则后, 引用这个 `` 就会把该具名正则插入(带入)到整个正则之中, 就像字符串插值那样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">v6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 具名正则的声明</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">number</span> <span class="p">{</span> <span class="o">\</span><span class="n">d</span><span class="o">+</span> <span class="p">[</span> <span class="o">\.</span> <span class="o">\</span><span class="n">d</span><span class="o">+</span><span class="p">]?</span> <span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">token</span> <span class="n">ident</span>  <span class="p">{</span> <span class="o">\</span><span class="n">w</span><span class="o">+</span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">rule</span>  <span class="n">alpha</span>  <span class="p">{</span> <span class="sr">&lt;[A..Za..z]&gt;</span>   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 1.0 通过 &amp; 来引用</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="s">&#34;12.34&#34;</span> <span class="o">~~</span> <span class="o">&amp;</span><span class="n">number</span><span class="p">;</span> <span class="c1"># true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 2.0 在正则构造 // 里使用</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="s">&#34;12.88 + 0.12&#34;</span> <span class="o">~~</span> <span class="sr">/  \s* &#39;+&#39; \s*  /</span><span class="p">;</span> <span class="c1"># true</span>
</span></span><span class="line"><span class="cl"><span class="c1"># say so &#34;12.88 + 0.12&#34; ~~ /  \s* &#39;+&#39; \s*  /;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># wrong, method &#39;number&#39; not found for invocant of class &#39;Cursor&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 3.0 在 grammar 里面使用</span>
</span></span><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">EquationParse</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 这里也不能给 number 起别名, 除非 number 是在 grammar 内部声明的</span>
</span></span><span class="line"><span class="cl">     <span class="n">token</span> <span class="n">TOP</span> <span class="p">{</span>  <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="s">&#39;+&#39;</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span>  <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="s">&#39;=&#39;</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 等式解析</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$expr</span> <span class="o">=</span> <span class="n">EquationParse</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#34;12.88 + 0.12 = 13.00&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="nv">$expr</span><span class="p">;</span>
</span></span></code></pre></div><p>声明具名正则不是只有一个 <code>regex</code> 声明符, 实际上 , regex 声明符用的最少, 大多数时候, 都是使用 <code>token</code> 或 <code>rule</code> 声明符。token 和 rule 这两个都是 <code>ratcheing</code> (棘轮)的, 这意味着如果匹配失败, 那么匹配引擎就不会回并尝试匹配了。这通常会是你想要的, 但不适用于所有情况:</p>
<blockquote>
<p>棘轮用于单向驱动, 防止逆转。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">works</span><span class="o">-</span><span class="n">but</span><span class="o">-</span><span class="n">slow</span> <span class="p">{</span> <span class="o">.+</span> <span class="sx">q } </span><span class="c1"># 可能会回溯</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">token</span> <span class="n">fails</span><span class="o">-</span><span class="n">but</span><span class="o">-</span><span class="n">fast</span> <span class="p">{</span> <span class="o">.+</span> <span class="sx">q } </span><span class="c1"># 不回溯</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="s">&#39;Tokens and rules won\&#39;t backtrack, which makes them fail quicker!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="nv">$s</span> <span class="o">~~</span> <span class="o">&amp;</span><span class="n">works</span><span class="o">-</span><span class="n">but</span><span class="o">-</span><span class="n">slow</span><span class="p">;</span> <span class="c1"># True</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="nv">$s</span> <span class="o">~~</span> <span class="o">&amp;</span><span class="n">fails</span><span class="o">-</span><span class="n">but</span><span class="o">-</span><span class="n">fast</span><span class="p">;</span> <span class="c1"># False, .+ 得到了整个字符串但不回溯</span>
</span></span></code></pre></div><p><code>token</code> 和 <code>rule</code> 的唯一区别就是 <code>rule</code> 声明符会让正则中的 <code>:sigspace</code> 修饰符起效:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">token</span> <span class="n">non</span><span class="o">-</span><span class="n">space</span><span class="o">-</span><span class="n">y</span> <span class="p">{</span> <span class="s">&#39;once&#39;</span> <span class="s">&#39;upon&#39;</span> <span class="s">&#39;a&#39;</span> <span class="s">&#39;time&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">rule</span> <span class="n">space</span><span class="o">-</span><span class="n">y</span> <span class="p">{</span> <span class="s">&#39;once&#39;</span> <span class="s">&#39;upon&#39;</span> <span class="s">&#39;a&#39;</span> <span class="s">&#39;time&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#39;onceuponatime&#39;</span>    <span class="o">~~</span> <span class="o">&amp;</span><span class="n">non</span><span class="o">-</span><span class="n">space</span><span class="o">-</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#39;once upon a time&#39;</span> <span class="o">~~</span> <span class="o">&amp;</span><span class="n">space</span><span class="o">-</span><span class="n">y</span><span class="p">;</span>
</span></span></code></pre></div><h2 id="创建-grammar">创建 Grammar</h2>
<p>　
当使用 grammar 关键字而非 class 关键字声明来声明一个类时, 会自动得到以 <a href="https://docs.raku.org/type/Grammar">Grammar</a> 的父类。Grammars 应该只用于解析文本; 如果你想提取复杂的数据, 推荐 <a href="http://doc.raku.org/language/grammars#Action_Objects">action object</a>和 grammar 一块使用。</p>
<h3 id="proto-regexes">Proto regexes</h3>
<p><a href="https://docs.raku.org/type/Grammar">Grammars</a> 由 rules，token 和 regexes 组成; 他们实际上是方法，因为 grammars 是类。这些方法可以共享一个共同的名称和功能，因此可以使用 <a href="https://docs.raku.org/syntax/proto">proto</a>。</p>
<p>如果你有很多备选分支(alternations), 那么生成可读性好的代码或子类化(subclass)你的 grammar 可能会变得很困难。在下面的 <code>Actions</code> 类中, <code>TOP</code> 方法中的三元操作符并不理想, 并且当我们添加的操作越多, 它就变得越糟糕:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">Calculator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">add</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sub</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span>  <span class="nf">add</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span>  <span class="nf">sub</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">num</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Calculations</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">TOP</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;add&gt;</span> <span class="o">??</span> <span class="nv">$&lt;add&gt;</span><span class="o">.</span><span class="k">made</span> <span class="o">!!</span> <span class="nv">$&lt;sub&gt;</span><span class="o">.</span><span class="k">made</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">add</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">[+]</span> <span class="nv">$&lt;num&gt;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="k">sub</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">[-]</span> <span class="nv">$&lt;num&gt;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Calculator</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">2 + 3</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">Calculations</span><span class="p">)</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 5</span>
</span></span></code></pre></div><p>为了让事情变得更好, 我们可以在 tokens 身上使用看起来像 <code>:sym&lt;...&gt;</code> 那样的副词来使用正则表达式原型(protoregexes):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">Calculator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">calc-op</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">proto</span> <span class="k">rule</span> <span class="nf">calc-op</span>          <span class="p">{</span><span class="o">*</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="k">rule</span> <span class="nf">calc-op</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">add</span><span class="p">&gt;</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="k">rule</span> <span class="nf">calc-op</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">sub</span><span class="p">&gt;</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">num</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Calculations</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">TOP</span>              <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;calc-op&gt;</span><span class="o">.</span><span class="k">made</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">calc-op</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">add</span><span class="p">&gt;</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">[+]</span> <span class="nv">$&lt;num&gt;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">calc-op</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">sub</span><span class="p">&gt;</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">[-]</span> <span class="nv">$&lt;num&gt;</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Calculator</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">2 + 3</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">Calculations</span><span class="p">)</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 5</span>
</span></span></code></pre></div><p>在这个 grammar 中, 备选分支(alternation)已经被 <code>&lt;calc-op&gt;</code> 替换掉了, 它实质上是我们将要创建的一组值的名字。我们通过使用 <code>proto rule calc-op</code> 定义了一个 rule 原型类型(prototype) 来达成。我们之前的每一个备选分支已经被新的 rule <code>calc-op</code> 替换掉了并且备选分支的名字被附加上了 <code>:sym&lt;&gt;</code> 副词。</p>
<p>在 actions 类中, 我们现在摆脱了三目操作符, 仅仅只在 <code>$&lt;calc-op&gt;</code> 匹配对象上接收 <code>.made</code> 值。并且单独备选分支的 actions 现在和 grammar 遵守相同的命名模式:  <code>method calc-op:sym&lt;add&gt;</code> 和 <code>method calc-op:sym&lt;sub&gt;</code>。</p>
<p>当你子类化(subclass)那个 grammar 和 actions 类的时候才能看到这个方法的真正魅力。假设我们想为 calculator 增加一个乘法功能:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">BetterCalculator</span> <span class="k">is</span> <span class="nc">Calculator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">calc-op</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">mult</span><span class="p">&gt;</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">*</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BetterCalculations</span> <span class="k">is</span> <span class="nc">Calculations</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">calc-op</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">mult</span><span class="p">&gt;</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">[*]</span> <span class="nv">$&lt;num&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">BetterCalculator</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">2 * 3</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">BetterCalculations</span><span class="p">)</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 6</span>
</span></span></code></pre></div><p>所有我们需要添加的就是为 <code>calc-op</code> 组添加额外的 rule 和 action, 感谢正则表达式原型(protoregexes), 所有的东西都能正常工作。</p>
<h2 id="特殊的-tokens">特殊的 Tokens</h2>
<h3 id="top">TOP</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The TOP token is the default first token attempted to match when parsing with a grammar—the root of the tree. Note that if you&rsquo;re parsing with .parse method, token TOP is automatically anchored to the start and end of the string (see also: .subparse).</p>
<p><code>TOP</code> token 是默认的第一个尝试去匹配的 token , 当解析一个 grammar 的时候 - 那颗树的根。注意如果你正使用 <code>.parse</code> 方法进行解析, 那么 token TOP 被自动地锚定到字符串的开头和结尾(再看看 <code>.subparse</code>)。</p>
<p>使用 <code>rule TOP</code> 或 <code>regex TOP</code> 也是可以接受的。</p>
<p>在 <code>.parse</code>、<code>.subparse</code> 或 <code>.parsefile</code> Grammar 方法中使用 <code>:rule</code> 命名参数可以选择一个不同的 token 来进行首次匹配。</p>
<h3 id="ws">ws</h3>
<p>当使用 <code>rule</code> 而非 <code>token</code> 时, 原子(atom)后面的任何空白(whitespace)被转换为一个对 <code>ws</code> 的非捕获调用。即:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">rule</span> <span class="nf">entry</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">key</span><span class="p">&gt;</span><span class="sr"> ’</span><span class="o">=</span><span class="sr">’ </span><span class="p">&lt;</span><span class="nf">value</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>等价于:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">entry</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">key</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr"> ’</span><span class="o">=</span><span class="sr">’ </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">value</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span> <span class="c1"># . = non-capturing</span>
</span></span></code></pre></div><p>默认的 <code>ws</code> 匹配&quot;空白&quot;(whitespace), 例如空格序列(不管什么类型)、换行符、unspaces、或 heredocs。</p>
<p>提供你自己的 <code>ws</code> token 是极好的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="sr"> </span><span class="se">\d</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="o">.</span><span class="nb">parse</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">4   </span><span class="se">\n\n</span><span class="s2"> 5</span><span class="p">&#34;;</span> <span class="c1"># Succeeds</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">Bar</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="sr"> </span><span class="se">\d</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">ws</span> <span class="p">{</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr">   </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="o">.</span><span class="nb">parse</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">4   </span><span class="se">\n\n</span><span class="s2"> 5</span><span class="p">&#34;;</span> <span class="c1"># Fails</span>
</span></span></code></pre></div><p>上面的例子中, 在 Bar Gramamr 中重写了自己的 <code>ws</code>, 只匹配水平空白符, 所以 <code>\n\n</code> 匹配失败。</p>
<h3 id="sym">sym</h3>
<p><code>&lt;sym&gt;</code> token 可以在原型正则表达式(proto regex) 中使用，以匹配那个特定正则表达式的 <code>:sym</code> 副词的字符串值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">letter</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">proto</span> <span class="k">token</span> <span class="nf">letter</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">letter</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">P</span><span class="p">&gt;</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">letter</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">e</span><span class="p">&gt;</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">letter</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">r</span><span class="p">&gt;</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">letter</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">l</span><span class="p">&gt;</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">letter</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">*</span><span class="p">&gt;</span> <span class="p">{</span><span class="sr">   </span><span class="ni">.</span><span class="sr">   </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#34;</span><span class="s2">I ♥ Perl</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="k">class</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;letter&gt;</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*.</span><span class="p">&lt;</span><span class="s">sym</span><span class="p">&gt;)</span><span class="o">.</span><span class="nb">join</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span><span class="o">.</span><span class="k">made</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># OUTPUT: «Perl␤» </span>
</span></span></code></pre></div><p>当你已经将原型正则表达式与要匹配的字符串区分开来时，这很方便，因为使用 <code>&lt;sym&gt;</code> token 可防止重复这些字符串。</p>
<h3 id="总是成功断言">总是成功断言</h3>
<p><code>&lt;?&gt;</code> is the always succeed assertion(总是匹配成功). 当它用作 grammar 中的 token 时, 它可以被用于触发一个 Action 类方法。在下面的 grammar 中, 我们查找阿拉伯数字并且使用 <code>always succeed assertion</code> 定义一个 succ token。</p>
<p>在 action 类中, 我们使用对 succ 方法的调用来设置(在这个例子中, 我们在 @!numbers 中准备了一个新元素)。在 <code>digit</code> 方法中, 我们把阿拉伯数字转换为梵文数字并且把它添加到 @!numbers 数组的最后一个元素中。多亏了 <code>succ</code>, 最后一个元素总是当前正被解析的 <code>digit</code> 数字的数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">Digifier</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">succ</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">digit</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">succ</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">digit</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Devanagari</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">@!numbers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">digit</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@!numbers</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span> <span class="o">~=</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">ord</span><span class="o">.&amp;[+]</span><span class="p">(</span><span class="mi">2358</span><span class="p">)</span><span class="o">.</span><span class="nb">chr</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">succ</span>  <span class="p">(</span><span class="nv">$</span><span class="p">)</span>  <span class="p">{</span> <span class="nv">@!numbers</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="p">&#39;&#39;</span>     <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">TOP</span>   <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">@!numbers</span><span class="o">[^</span><span class="p">(</span><span class="o">*-</span><span class="mi">1</span><span class="p">)</span><span class="o">]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Digifier</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">255 435 777</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">Devanagari</span><span class="o">.</span><span class="nb">new</span><span class="p">)</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># (२५५ ४३५ ७७७)</span>
</span></span></code></pre></div><h2 id="grammar-中的方法">Grammar 中的方法</h2>
<p>在 grammar 中使用 <code>method</code> 代替 <code>rule</code> 或 <code>token</code> 也是可以的, 只要它们返回一个 <a href="https://docs.raku.org/type/Cursor">Cursor</a> 类型:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">DigitMatcher</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">TOP</span> <span class="p">(</span><span class="o">:</span><span class="nv">$full-unicode</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$full-unicode</span> <span class="o">??</span> <span class="nb">self</span><span class="o">.</span><span class="nf">num-full</span> <span class="o">!!</span> <span class="nb">self</span><span class="o">.</span><span class="nf">num-basic</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">num-full</span>  <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">num-basic</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面的 grammar 会根据 parse 方法提供的参数尝试不同的匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">+</span><span class="n">DigitMatcher</span><span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">12७१७९०९</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">args</span> <span class="o">=&gt;</span> \<span class="p">(:</span><span class="s">full-unicode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 12717909</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">+</span><span class="n">DigitMatcher</span><span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">12७१७९०९</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">args</span> <span class="o">=&gt;</span> \<span class="p">(:</span><span class="o">!</span><span class="s">full-unicode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 12</span>
</span></span></code></pre></div><h2 id="action-object">Action Object</h2>
<p>　
一个成功的 grammar 匹配会给你一棵匹配对象(Match objects)的解析树, 匹配树(match tree)到达的越深, 则 grammar 中的分支越多, 那么在匹配树中航行以获取你真正感兴趣的东西就变的越来越困难。</p>
<p>为了避免你在匹配树(match tree)中迷失, 你可以提供一个 action object。grammar 中每次解析成功一个具名规则(named rule)之后, 它就会尝试调用一个和该 grammar rule 同名的方法, 并传递给这个方法一个<code>Match</code> 对象作为位置参数。如果不存在这样的同名方法, 就跳过。</p>
<p>这儿有一个例子来说明 grammar 和 action：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">v6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">TestGrammar</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">TOP</span> <span class="p">{</span> <span class="o">^</span> <span class="o">\</span><span class="n">d</span><span class="o">+</span> <span class="nv">$</span> <span class="err">}</span>
</span></span><span class="line"><span class="cl"><span class="err">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">class</span> <span class="n">TestActions</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">TOP</span><span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="vg">$/</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="vg">$/</span><span class="p">);</span>  <span class="c1"># 等价于 $/.make: 2 + $/</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$actions</span> <span class="o">=</span> <span class="n">TestActions</span><span class="o">.</span><span class="k">new</span><span class="p">;</span> <span class="c1"># 创建 Action 实例</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$match</span>   <span class="o">=</span> <span class="n">TestGrammar</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#39;40&#39;</span><span class="p">,</span> <span class="p">:</span><span class="nv">$actions</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="nv">$match</span><span class="p">;</span>       <span class="c1"># ｢40｣</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="nv">$match</span><span class="o">.</span><span class="n">made</span><span class="p">;</span>  <span class="c1"># 42</span>
</span></span></code></pre></div><p><code>TestActions</code> 的一个实例变量作为具名参数 <code>actions</code> 被传递给 <code>parse</code> 调用, 然后当 token <code>TOP</code> 匹配成功之后, 就会自动调用方法 <code>TOP</code>, 并传递匹配对象(match object) 作为方法的参数。</p>
<p>为了让参数是匹配对象更清楚, 上面的例子使用 <code>$/</code> 作为 action 方法的参数名, 尽管那仅仅是一个方便的约定, 跟内在无关。 <code>$match</code> 也可以。(尽管使用 <code>$/</code>可以提供把 <code>$</code>作为<code>$/</code>的缩写的优势。)</p>
<p>下面是一个更有说服力的例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">v6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">KeyValuePairs</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">TOP</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span><span class="sr">&lt;pair&gt;</span> <span class="o">\</span><span class="n">n</span><span class="o">+</span><span class="p">]</span><span class="o">*</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">ws</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">\</span><span class="n">h</span><span class="o">*</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">pair</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="sr">&lt;key=.identifier&gt;</span> <span class="s">&#39;=&#39;</span> <span class="sr">&lt;value=.identifier&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">identifier</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">\</span><span class="n">w</span><span class="o">+</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">class</span> <span class="n">KeyValuePairsActions</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">pair</span>      <span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="vg">$/</span><span class="o">.</span><span class="n">make:</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">key</span><span class="o">&gt;.</span><span class="n">made</span> <span class="o">=&gt;</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">value</span><span class="o">&gt;.</span><span class="n">made</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">identifier</span><span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 子例程 `make` 和在 $/ 上调用 .make 相同</span>
</span></span><span class="line"><span class="cl">        <span class="n">make</span> <span class="o">~</span><span class="vg">$/</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">TOP</span> <span class="p">(</span><span class="nv">$match</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># TOP 方法的参数可以使用任意变量名, 而不仅仅是 $/ </span>
</span></span><span class="line"><span class="cl">        <span class="nv">$match</span><span class="o">.</span><span class="n">make:</span> <span class="nv">$match</span><span class="sr">&lt;pair&gt;</span><span class="err">»</span><span class="o">.</span><span class="n">made</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$res</span> <span class="o">=</span> <span class="n">KeyValuePairs</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="sx">q:to/EOI/, :</span><span class="n">actions</span><span class="p">(</span><span class="n">KeyValuePairsActions</span><span class="p">))</span><span class="o">.</span><span class="n">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">second</span><span class="o">=</span><span class="n">b</span>
</span></span><span class="line"><span class="cl">    <span class="n">hits</span><span class="o">=</span><span class="mi">42</span>
</span></span><span class="line"><span class="cl">    <span class="n">perl</span><span class="o">=</span><span class="mi">6</span>
</span></span><span class="line"><span class="cl">    <span class="n">EOI</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@$res</span> <span class="o">-&gt;</span> <span class="nv">$p</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#34;Key: $p.key()\tValue: $p.value()&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这会输出:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">Key:</span> <span class="n">second</span>     <span class="n">Value:</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="n">Key:</span> <span class="n">hits</span>       <span class="n">Value:</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="n">Key:</span> <span class="n">perl</span>       <span class="n">Value:</span> <span class="mi">6</span>
</span></span></code></pre></div><p><code>pair</code> 这个 rule, 解析一对由等号分割的 pair, 并且给 <code>identifier</code> 这个 token 各自起了别名。对应的 action 方法构建了一个 <code>Pair</code> 对象, 并使用子匹配对象(sub match objects)的 <code>.made</code> 属性。这也暴露了一个事实: submatches 的 action 方法在那些调用正则/外部正则之前就被调用。所以 action 方法是按后续调用的。</p>
<p>名为 <code>TOP</code> 的 action 方法仅仅把由 <code>pair</code> 这个 rule 的多重匹配组成的所有对象收集到一块, 然后以一个列表的方式返回。</p>
<p>注意 <code>KeyValuePairsActions</code> 是作为一个类型对象(type object)传递给方法 <code>parse</code>的, 这是因为 action 方法中没有一个使用属性(属性只能通过实例来访问)。</p>
<p>其它情况下, action 方法可能会在属性中保存状态。 那么这当然需要你传递一个实例给 <code>parse</code> 方法。</p>
<p>注意, <code>token ws</code> 有点特殊: 当 <code>:sigspace</code> 开启的时候(就是我们使用 <code>rule</code>的时候), 我们覆写的 <code>ws</code> 会替换某些空白序列。这就是为什么 <code>rule pair</code> 中等号两边的空格解析没有问题并且闭合 <code>}</code> 之前的空白不会狼吞虎咽地吃下换行符, 因为换行符在 <code>TOP</code> token 已经占位置了, 并且 token 不会回溯。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># ws 的内置定义</span>
</span></span><span class="line"><span class="cl"><span class="sr">/ &lt;.ws&gt; /</span>                <span class="c1"># match &#34;whitespace&#34;:</span>
</span></span><span class="line"><span class="cl">                         <span class="c1">#   \s+ if it&#39;s between two \w characters,</span>
</span></span><span class="line"><span class="cl">                         <span class="c1">#   \s* otherwise</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="k">my</span> <span class="n">token</span> <span class="n">ws</span> <span class="p">{</span> <span class="o">\</span><span class="n">h</span><span class="o">*</span> <span class="p">}</span> <span class="c1"># 重写 ws 这个内置的 token</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="n">say</span> <span class="n">so</span> <span class="s">&#34;\n&#34;</span> <span class="o">~~</span> <span class="o">&amp;</span><span class="n">ws</span> <span class="c1"># True</span>
</span></span></code></pre></div><p>所以 <code>&lt;.ws&gt;</code> 内置的定义是：如果空白在两个 <code>\w</code> 单词字符之间, 则意思为 <code>\s+</code>, 否则为 <code>\s*</code>。 我们可以重写 <code>ws</code> 关于空白的定义, 重新定义我们需要的空白。比如把 <code>ws</code> 定义为 <code>{ \h* }</code> 就是所有水平空白符, 甚至可以将<code>ws</code> 定义为非空白字符。例如: <code>token ws { 'x' }</code></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[函数]]></title>
            <link href="http://localhost:1313/rakulang/44.functions/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/the-modules-that-will-be-rewrite-in-perl6/?utm_source=atom_feed" rel="related" type="text/html" title="The modules that will be rewrite in Raku" />
                <link href="http://localhost:1313/notes/send-data-to-socket/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 发送数据到 Socket" />
                <link href="http://localhost:1313/rakulang/43.exceptions/?utm_source=atom_feed" rel="related" type="text/html" title="异常" />
                <link href="http://localhost:1313/rakulang/42.enumeration/?utm_source=atom_feed" rel="related" type="text/html" title="枚举" />
                <link href="http://localhost:1313/rakulang/41.date-and-time-functions/?utm_source=atom_feed" rel="related" type="text/html" title="日期和时间函数" />
            
                <id>http://localhost:1313/rakulang/44.functions/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-19T21:13:31+08:00</published>
            <updated>2018-11-19T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="raku-中的函数httpsdocsrakuorglanguagefunctions"><a href="https://docs.raku.org/language/functions">Raku 中的函数</a></h1>
<p>例程（Routines）是 Raku 中代码重用的最小手段。它们有几种形式，最明显的是属于类和角色并与对象相关联的方法，还有函数, 也叫做子例程或短子程序，它们独立于对象而存在。</p>
<p>子例程默认是词法（<code>my</code>）作用域的，对它们的调用通常在编译时解析。</p>
<p>子例程可以具有<a href="https://docs.raku.org/type/Signature">签名</a>，也称为<em>参数列表</em>，其指定签名期望的参数（如果有的话）。 它可以指定（或保持打开）参数的数量和类型，以及返回值。</p>
<p>子例程的内省通过<a href="https://docs.raku.org/type/Routine">例程</a>提供。</p>
<h2 id="定义创建使用-函数">定义/创建/使用 函数</h2>
<h3 id="子例程">子例程</h3>
<p>创建子例程的基本方法是使用 <code>sub</code> 声明符，后跟可选<a href="https://docs.raku.org/language/syntax#Identifiers">标识符</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">my-func</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Look ma, no args!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">my-func</span><span class="p">;</span>
</span></span></code></pre></div><p>sub 声明符返回可以存储在任何容器中的 <a href="https://docs.raku.org/type/Sub">Sub</a> 类型的值:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">&amp;c</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Look ma, no name!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="p">;</span>     <span class="c1"># OUTPUT: «Look ma, no name!␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Any:D</span> <span class="nv">$f</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Still nameless...</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">$f</span><span class="p">();</span>  <span class="c1"># OUTPUT: «Still nameless...␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Code</span> \<span class="n">a</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> ‚<span class="k">raw</span> <span class="n">containers</span> <span class="n">don&#39;t</span> <span class="nf">implement</span> <span class="n">postcircumfix:</span><span class="p">&lt;</span><span class="s">( )</span><span class="p">&gt;</span>‘ <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="o">.</span><span class="p">();</span>  <span class="c1"># OUTPUT: «raw containers don&#39;t implement postcircumfix:&lt;( )&gt;␤» </span>
</span></span></code></pre></div><p><code>sub</code> 声明符将在编译时在当前作用域内声明一个新名称。因此，任何间接性都必须在编译时解析：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">constant</span> <span class="no">aname</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">::</span><span class="p">(</span><span class="n">aname</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">oi‽</span><span class="p">&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">foo</span><span class="p">;</span>
</span></span></code></pre></div><p>一旦将宏添加到 Raku 中，这将变得更有用。</p>
<p>为了使子程序接受参数，<a href="https://docs.raku.org/type/Signature">签名</a>被放置在子例程名称和它的函数主体之间，在括号中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">exclaim</span> <span class="p">(</span><span class="nv">$phrase</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$phrase</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">!!!!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">exclaim</span> <span class="p">&#34;</span><span class="s2">Howdy, World</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>默认地, 子例程是<a href="https://docs.raku.org/syntax/my">词法作用域</a>的。即 <code>sub foo {...}</code> 和 <code>my sub foo {...}</code> 是相同的并且只被定义在当前作用域中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">escape</span><span class="p">(</span><span class="nv">$str</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Puts a slash before non-alphanumeric characters</span>
</span></span><span class="line"><span class="cl">    <span class="k">S</span><span class="p">:</span><span class="na">g</span><span class="p">[&lt;</span><span class="s">-alpha -digit</span><span class="p">&gt;]</span> <span class="p">=</span><span class="sr"> </span><span class="p">&#34;</span><span class="s2">\\$/</span><span class="p">&#34;</span><span class="sr"> given </span><span class="nv">$str</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">}
</span></span></span><span class="line"><span class="cl"><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">say escape </span><span class="p">&#39;</span><span class="s1">foo#bar?</span><span class="p">&#39;</span><span class="sr">; </span><span class="c1"># foo\#bar\?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nf">escape</span><span class="p">(</span><span class="nv">$str</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Writes each non-alphanumeric character in its hexadecimal escape</span>
</span></span><span class="line"><span class="cl">        <span class="k">S</span><span class="p">:</span><span class="na">g</span><span class="p">[&lt;</span><span class="s">-alpha -digit</span><span class="p">&gt;]</span> <span class="p">=</span><span class="sr"> </span><span class="p">&#34;</span><span class="s2">\\x[</span><span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">ord</span><span class="o">.</span><span class="nb">base</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="p">}</span><span class="s2">]</span><span class="p">&#34;</span><span class="sr"> given </span><span class="nv">$str</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="n">escape</span> <span class="p">&#39;</span><span class="s1">foo#bar?</span><span class="p">&#39;</span> <span class="c1"># foo\x[23]bar\x[3F]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Back to original escape function</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">escape</span> <span class="p">&#39;</span><span class="s1">foo#bar?</span><span class="p">&#39;;</span> <span class="c1"># foo\#bar\?</span>
</span></span></code></pre></div><p>子例程不必命名; 这种情况下, 它们被叫做匿名的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="k">sub</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="nv">$b</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">}(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1"># 25</span>
</span></span></code></pre></div><p>但在这种情况下，通常希望使用更简洁的块语法。可以就地调用子例程和块，如上例所示。</p>
<h3 id="blocks-和-lambdas">Blocks 和 Lambdas</h3>
<p>每当你看到像</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span> <span class="nv">$_</span> <span class="o">+</span> <span class="mi">42</span> <span class="p">}</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">**</span> <span class="nv">$b</span> <span class="p">}</span>
</span></span></code></pre></div><p>或</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span> <span class="nv">$^text</span><span class="o">.</span><span class="nb">indent</span><span class="p">(</span><span class="nv">$:spaces</span><span class="p">)</span> <span class="p">}</span>
</span></span></code></pre></div><p>那么这是<a href="https://docs.raku.org/type/Block">块</a>语法。 它在每个 <code>if</code>，<code>for</code>，<code>while</code> 等关键字之后使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$a</span> <span class="o">~</span> <span class="nv">$b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «12␤34␤» </span>
</span></span></code></pre></div><p>它们也可以作为匿名代码块自己使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">{</span> <span class="nv">$^a</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="nv">$^b</span> <span class="o">**</span> <span class="mi">2</span><span class="p">}(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">)</span> <span class="c1"># 25</span>
</span></span></code></pre></div><p>有关块语法的详细信息，请参阅<a href="https://docs.raku.org/type/Block">块</a>类型的文档。</p>
<h3 id="签名">签名</h3>
<p>函数接受的参数在其签名中有描述。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">format</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$s</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span></code></pre></div><p>有关签名的语法和使用的详细信息，请参阅 <a href="https://docs.raku.org/type/Signature">Signature</a> 类的文档。</p>
<h3 id="自动签名">自动签名</h3>
<p>如果没有提供签名，但在函数体中使用了两个自动变量 <code>@_</code> 或 <code>%_</code> 中的任何一个，则将生成带有 <code>*@_</code> 或 <code>*%_</code> 的签名。 两个自动变量可以同时使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="k">s</span> <span class="p">{</span><span class="sr"> say </span><span class="nv">@_</span><span class="sr">, </span><span class="nv">%_</span><span class="sr"> </span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">&amp;s</span><span class="o">.</span><span class="nb">signature</span> <span class="c1"># OUTPUT«:(*@_, *%_)␤»</span>
</span></span></code></pre></div><h3 id="参数">参数</h3>
<p>参数以逗号分隔列表的形式提供。 要消除嵌套调用的歧义, 可以使用圆括号或副词形式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nv">&amp;c</span><span class="p">){</span> <span class="nf">c</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">};</span> <span class="c1"># call the function reference c with empty parameter list</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">g</span><span class="p">(</span><span class="nv">$p</span><span class="p">){</span> <span class="nv">$p</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span><span class="p">(</span><span class="nf">g</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1"># nest call to g in call to say</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span><span class="o">:</span> <span class="p">{</span> <span class="nb">say</span> <span class="nf">g</span><span class="p">(</span><span class="mi">666</span><span class="p">)</span> <span class="p">};</span> <span class="c1"># call f with a block</span>
</span></span></code></pre></div><p>当调用函数时，位置参数应该以与函数签名相同的顺序提供。 命名参数可以以任何顺序提供，但是最好将命名参数放在位置参数之后。 在函数调用的参数列表中，支持一些特殊的语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">){};</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span> <span class="p">:</span><span class="s">named</span><span class="p">(</span><span class="mi">35</span><span class="p">);</span>     <span class="c1"># 具名参数(in &#34;adverb&#34; form.)</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span> <span class="s">named</span> <span class="o">=&gt;</span> <span class="mi">35</span><span class="p">;</span>    <span class="c1"># 也是具名参数.</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span> <span class="p">:</span><span class="mi">35</span><span class="s">named</span><span class="p">;</span>       <span class="c1"># 使用缩写的副词形式的具名参数</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span> <span class="p">&#39;</span><span class="s1">named</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">35</span><span class="p">;</span>  <span class="c1"># 不是具名参数, 而是一个 Pair 位置参数</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\c</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="kt">Capture</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span> <span class="o">|</span><span class="n">c</span><span class="p">;</span>             <span class="c1"># Merge the contents of Capture $c as if they were supplied</span>
</span></span></code></pre></div><p>传递给函数的参数在概念上首先被收集在 Capture 容器中。 关于这些容器的语法和使用的细节可以在 <a href="https://docs.raku.org/type/Capture">Capture</a> 类的文档中找到。</p>
<p>当使用命名参数时，请注意，正常的 List &ldquo;pair-chaining&rdquo; 允许在命名参数之间跳过逗号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">){};</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span> <span class="p">:</span><span class="s">dest</span><span class="p">&lt;</span><span class="s">/tmp/foo</span><span class="p">&gt;</span> <span class="p">:</span><span class="s">src</span><span class="p">&lt;</span><span class="s">/tmp/bar</span><span class="p">&gt;</span> <span class="p">:</span><span class="s">lines</span><span class="p">(</span><span class="mi">512</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span> <span class="p">:</span><span class="mi">32</span><span class="s">x</span> <span class="p">:</span><span class="mi">50</span><span class="s">y</span> <span class="p">:</span><span class="mi">110</span><span class="s">z</span><span class="p">;</span>   <span class="c1"># This flavor of &#34;adverb&#34; works, too</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span> <span class="p">:</span><span class="s">a</span><span class="p">:</span><span class="s">b</span><span class="p">:</span><span class="s">c</span><span class="p">;</span>            <span class="c1"># The spaces are also optional.</span>
</span></span></code></pre></div><h3 id="返回值">返回值</h3>
<p>任何块或例程将把它的最后一个表达式作为返回值提供给调用者。如果 <a href="https://docs.raku.org/language/control#return">return</a> 或 <a href="https://docs.raku.org/language/control#return-rw">return-rw</a> 被调用，它们的参数（如果有的话）将成为返回值。 默认返回值为 <a href="https://docs.raku.org/type/Nil">Nil</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">a</span> <span class="p">{</span> <span class="mi">42</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">b</span> <span class="p">{</span> <span class="nb">say</span> <span class="n">a</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«42␤»</span>
</span></span></code></pre></div><p>多个返回值作为列表或通过创建<a href="https://docs.raku.org/type/Capture">捕获</a>返回。 解构可以用于解开多个返回值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">a</span> <span class="p">{</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">answer</span><span class="p">&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">put</span> <span class="n">a</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«(42, &#34;answer&#34;)␤»</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">$n</span><span class="o">,</span> <span class="nv">$s</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">put</span> <span class="o">[</span><span class="nv">$s</span><span class="o">,</span> <span class="nv">$n</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«answer 42␤»</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">b</span> <span class="p">{</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="kt">Capture</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">put</span> <span class="n">b</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«\(&#34;a&#34;, &#34;b&#34;, &#34;c&#34;)␤»</span>
</span></span></code></pre></div><h3 id="返回类型约束">返回类型约束</h3>
<p>Raku 有很多方式来指定函数的返回类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="k">--&gt;</span> <span class="kt">Int</span><span class="p">)</span>      <span class="p">{};</span> <span class="nb">say</span> <span class="nv">&amp;foo</span><span class="o">.</span><span class="k">returns</span><span class="p">;</span> <span class="c1"># (Int)</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">returns</span> <span class="kt">Int</span> <span class="p">{};</span> <span class="nb">say</span> <span class="nv">&amp;foo</span><span class="o">.</span><span class="k">returns</span><span class="p">;</span> <span class="c1"># (Int)</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">of</span> <span class="kt">Int</span>      <span class="p">{};</span> <span class="nb">say</span> <span class="nv">&amp;foo</span><span class="o">.</span><span class="k">returns</span><span class="p">;</span> <span class="c1"># (Int)</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="k">sub</span> <span class="nf">foo</span><span class="p">()</span>      <span class="p">{};</span> <span class="nb">say</span> <span class="nv">&amp;foo</span><span class="o">.</span><span class="k">returns</span><span class="p">;</span> <span class="c1"># (Int)</span>
</span></span></code></pre></div><p>尝试返回另外一种类型的值会引起编译错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">returns</span> <span class="kt">Int</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;;</span> <span class="p">};</span> <span class="n">foo</span><span class="p">;</span> <span class="c1"># Type check fails</span>
</span></span></code></pre></div><p>注意，<code>Nil</code> 和 <code>Failure</code> 是免于返回类型约束，并且可以从任何子例程返回，而不管其约束：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">returns</span> <span class="kt">Int</span> <span class="p">{</span> <span class="nb">fail</span>   <span class="p">};</span> <span class="n">foo</span><span class="p">;</span> <span class="c1"># Failure returned</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">bar</span><span class="p">()</span> <span class="k">returns</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="p">};</span> <span class="n">bar</span><span class="p">;</span> <span class="c1"># Nil returned</span>
</span></span></code></pre></div><h3 id="多重分派">多重分派</h3>
<p>Raku 允许你使用同一个名字但是不同签名写出几个子例程。当子例程按名字被调用时, 运行时环境决定哪一个子例程是最佳匹配, 然后调用那个候选者。你使用 <code>multi</code> 声明符来声明每个候选者。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">congratulate</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">祝你生日快乐, </span><span class="nv">$name</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">congratulate</span><span class="p">(</span><span class="nv">$name</span><span class="o">,</span> <span class="nv">$age</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">祝 </span><span class="nv">$age</span><span class="s2"> 岁生日快乐, </span><span class="nv">$name</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">congratulate</span> <span class="p">&#39;</span><span class="s1">Camelia</span><span class="p">&#39;;</span> <span class="c1"># 祝你生日快乐, Camelia</span>
</span></span><span class="line"><span class="cl"><span class="n">congratulate</span> <span class="p">&#39;</span><span class="s1">Rakudo</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">15</span><span class="p">;</span> <span class="c1"># 祝你 15 岁生日快乐, Rakudo</span>
</span></span></code></pre></div><p>分发/分派(dispatch) 可以发生在参数的数量(元数)上, 但是也能发生在类型上:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">as-json</span><span class="p">(</span><span class="kt">Bool</span> <span class="nv">$d</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$d</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">true</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">false</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">as-json</span><span class="p">(</span><span class="kt">Real</span> <span class="nv">$d</span><span class="p">)</span> <span class="p">{</span> <span class="o">~</span><span class="nv">$d</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">as-json</span><span class="p">(</span><span class="nv">@d</span><span class="p">)</span>      <span class="p">{</span> <span class="nb">sprintf</span> <span class="p">&#39;</span><span class="s1">[%s]</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">@d</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="nv">&amp;as-json</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">, </span><span class="p">&#39;)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">as-json</span><span class="p">(</span><span class="o">[</span><span class="kt">True</span><span class="o">,</span> <span class="mi">42</span><span class="o">]</span><span class="p">);</span> <span class="c1"># [true, 42]</span>
</span></span></code></pre></div><p>不带任何指定例程类型的 <code>multi</code> 总是默认为 <code>sub</code>, 但是你也可以把 <code>multi</code> 用在方法(methods)上。那些候选者全都是对象的 <code>multi</code> 方法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Congrats</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nf">congratulate</span><span class="p">(</span><span class="nv">$reason</span><span class="o">,</span> <span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hooray for your </span><span class="nv">$reason</span><span class="s2">, </span><span class="nv">$name</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">BirthdayCongrats</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nf">congratulate</span><span class="p">(&#39;</span><span class="s1">birthday</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Happy birthday, </span><span class="nv">$name</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nf">congratulate</span><span class="p">(&#39;</span><span class="s1">birthday</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$name</span><span class="o">,</span> <span class="nv">$age</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Happy </span><span class="p">{</span><span class="nv">$age</span><span class="p">}</span><span class="s2">th birthday, </span><span class="nv">$name</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$congrats</span> <span class="o">=</span> <span class="n">Congrats</span><span class="o">.</span><span class="nb">new</span> <span class="k">does</span> <span class="nc">BirthdayCongrats</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$congrats</span><span class="o">.</span><span class="nf">congratulate</span><span class="p">(&#39;</span><span class="s1">升职</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Cindy</span><span class="p">&#39;);</span>   <span class="c1">#-&gt; 恭喜你升职,Cindy</span>
</span></span><span class="line"><span class="cl"><span class="nv">$congrats</span><span class="o">.</span><span class="nf">congratulate</span><span class="p">(&#39;</span><span class="s1">birthday</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Bob</span><span class="p">&#39;);</span> <span class="c1">#-&gt; Happy birthday, Bob</span>
</span></span></code></pre></div><h3 id="proto">proto</h3>
<p><a href="https://docs.raku.org/syntax/proto">proto</a> 从形式上声明了 <code>multi</code> 候选者之间的<code>共性</code>。 proto 充当作能检查但不会修改参数的包装器。看看这个基本的例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="nf">congratulate</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$reason</span><span class="o">,</span> <span class="kt">Str</span> <span class="nv">$name</span><span class="o">,</span> <span class="o">|</span><span class="p">)</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">congratulate</span><span class="p">(</span><span class="nv">$reason</span><span class="o">,</span> <span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hooray for your </span><span class="nv">$reason</span><span class="s2">, </span><span class="nv">$name</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">congratulate</span><span class="p">(</span><span class="nv">$reason</span><span class="o">,</span> <span class="nv">$name</span><span class="o">,</span> <span class="kt">Int</span> <span class="nv">$rank</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hooray for your </span><span class="nv">$reason</span><span class="s2">, </span><span class="nv">$name</span><span class="s2"> -- you got rank </span><span class="nv">$rank</span><span class="s2">!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">congratulate</span><span class="p">(&#39;</span><span class="s1">being a cool number</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Fred</span><span class="p">&#39;);</span>     <span class="c1"># OK</span>
</span></span><span class="line"><span class="cl"><span class="nf">congratulate</span><span class="p">(&#39;</span><span class="s1">being a cool number</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Fred</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">42</span><span class="p">);</span> <span class="c1"># OK</span>
</span></span><span class="line"><span class="cl"><span class="nf">congratulate</span><span class="p">(&#39;</span><span class="s1">being a cool number</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">42</span><span class="p">);</span>         <span class="c1"># Proto match error</span>
</span></span></code></pre></div><p>所有的 <code>multi congratulate</code> 都会遵守基本的签名, 这个签名中有两个字符串参数, 后面跟着可选的更多的参数。 <code>|</code> 是一个未命名的 <code>Capture</code> 形参, 它允许 <code>multi</code> 接收额外的参数。第三个 congratulate 调用在编译时失败, 因为第一行的 proto 的签名变成了所有三个 multi congratulate 的共同签名, 而 42 不匹配 <code>Str</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">&amp;congratulate</span><span class="o">.</span><span class="nb">signature</span> <span class="c1">#-&gt; (Str $reason, Str $name, | is raw)</span>
</span></span></code></pre></div><p>你可以给 <code>proto</code> 一个函数体, 并且在你想执行 dispatch 的地方放上一个 <code>{*}</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># attempts to notify someone -- returns False if unsuccessful</span>
</span></span><span class="line"><span class="cl"><span class="k">proto</span> <span class="nf">notify</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$user</span><span class="o">,</span><span class="kt">Str</span> <span class="nv">$msg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">my</span> <span class="nv">\hour</span> <span class="o">=</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">now</span><span class="o">.</span><span class="nb">hour</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nb">hour</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="ow">or</span> <span class="nb">hour</span> <span class="o">&lt;</span> <span class="mi">22</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">{</span><span class="o">*</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1"># we can&#39;t notify someone when they might be sleeping</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="kt">False</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>{*}</code> 总是分派给带有参数的候选者。默认参数和类型强制转换会起作用单不会传递。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="nf">mistake-proto</span><span class="p">(</span><span class="kt">Str</span><span class="p">()</span> <span class="nv">$str</span><span class="o">,</span> <span class="kt">Int</span> <span class="nv">$number</span> <span class="o">=</span> <span class="mi">42</span><span class="p">)</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">mistake-proto</span><span class="p">(</span><span class="nv">$str</span><span class="o">,</span><span class="nv">$number</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$str</span><span class="o">.</span><span class="nb">WHAT</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">mistake-proto</span><span class="p">(</span><span class="mi">7</span><span class="o">,</span><span class="mi">42</span><span class="p">);</span>   <span class="c1">#-&gt; (Int) -- coercions not passed on</span>
</span></span><span class="line"><span class="cl"><span class="nf">mistake-proto</span><span class="p">(&#39;</span><span class="s1">test</span><span class="p">&#39;);</span> <span class="c1">#!&gt; fails -- defaults not passed on</span>
</span></span></code></pre></div><h2 id="约定和惯用法">约定和惯用法</h2>
<p>虽然上面描述的调度系统提供了很多灵活性，但是存在一些大多数内部函数以及许多模块中的函数将遵循的约定。 这些将产生一致的外观和感觉。</p>
<h3 id="吞噬约定">吞噬约定</h3>
<p>也许最重要的是处理 slurpy 列表参数的方式。 大多数时候，函数不会自动展平吞噬(slurpy)列表。 罕见的例外是在列表的列表上没有合理行为的那些函数（例如chrs），或者与已建立的习语有冲突的函数，例如 <a href="https://docs.raku.org/routine/pop">pop</a> 是 <a href="https://docs.raku.org/routine/push">push</a> 的逆操作。</p>
<p>如果你想匹配这个外观和感觉，任何可迭代(Iterable)参数必须使用 <code>**@slurpy</code> 逐个元素地打开，有两个细微差别：</p>
<ul>
<li><a href="https://docs.raku.org/language/containers#Scalar_containers">Scalar 容器</a>内的 Iterable 不计数。</li>
<li>在顶层使用 <code>,</code> 创建的列表只能计数为一个 Iterable。</li>
</ul>
<p>这可以通过使用带有 <code>+</code> 或 <code>+@</code> 而不是 <code>**</code>的 slurpy 来实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">grab</span><span class="p">(</span><span class="o">+</span><span class="nv">@a</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">grab </span><span class="nv">$_</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@a</span> <span class="p">}</span>
</span></span></code></pre></div><p>这非常接近于:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">grab</span><span class="p">(</span><span class="o">**</span><span class="nv">@a</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">grab </span><span class="nv">$_</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@a</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">grab</span><span class="p">(</span>\<span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">~~</span> <span class="kt">Iterable</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="nb">VAR</span> <span class="o">!~~</span> <span class="kt">Scalar</span> <span class="o">??</span> <span class="nb">nextwith</span><span class="p">(</span><span class="o">|</span><span class="n">a</span><span class="p">)</span> <span class="o">!!</span> <span class="nb">nextwith</span><span class="p">(</span><span class="n">a</span><span class="o">,</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这导致以下行为，称为「单参数规则」，并且理解什么时间调用 slurpy 函数很重要：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">grab</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span>      <span class="c1"># grab 1 grab 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">grab</span><span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">));</span>    <span class="c1"># grab 1 grab 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">grab</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">));</span>   <span class="c1"># grab 1 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">grab</span><span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1"># grab 1 2 grab 3</span>
</span></span></code></pre></div><p>这也使得用户请求的展平感觉一致，无论有没有子列表，或很多</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">grab</span><span class="p">(</span><span class="nb">flat</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">));</span>   <span class="c1"># grab 1 grab 2 grab 3 grab 4</span>
</span></span><span class="line"><span class="cl"><span class="nb">grab</span><span class="p">(</span><span class="nb">flat</span> <span class="nv">$</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">,</span> <span class="nv">$</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">));</span> <span class="c1"># grab 1 2 grab 3 4</span>
</span></span><span class="line"><span class="cl"><span class="nb">grab</span><span class="p">(</span><span class="nb">flat</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">));</span>           <span class="c1"># grab 1 grab 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">grab</span><span class="p">(</span><span class="nb">flat</span> <span class="nv">$</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">));</span>          <span class="c1"># grab 1 2</span>
</span></span></code></pre></div><p>值得注意的是，在这些情况下将绑定和无符号变量混合在一起需要一点技巧，因为在绑定期间没有使用 Scalar 中间人。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1"># Normal assignment, equivalent to $(1, 2)</span>
</span></span><span class="line"><span class="cl"><span class="nb">grab</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span>       <span class="c1"># grab 1 2</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$b</span> <span class="o">:=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1"># Binding, $b links directly to a bare (1, 2)</span>
</span></span><span class="line"><span class="cl"><span class="nb">grab</span><span class="p">(</span><span class="nv">$b</span><span class="p">);</span>       <span class="c1"># grab 1 grab 2</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\c</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1"># Sigilless variables always bind, even with &#39;=&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">grab</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>        <span class="c1"># grab 1 grab 2</span>
</span></span></code></pre></div><h2 id="函数是一等对象">函数是一等对象</h2>
<p>函数和其他代码对象可以作为值传递，就像任何其他对象一样。</p>
<p>有几种方法来获取代码对象。 您可以在声明点将其赋值给变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$square</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">(</span><span class="kt">Numeric</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># and then use it:</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$square</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>    <span class="c1"># 36</span>
</span></span></code></pre></div><p>或者，您可以通过使用它前面的 <code>&amp;</code> 来引用现有的具名函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">square</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># get hold of a reference to the function:</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$func</span> <span class="o">=</span> <span class="nv">&amp;square</span>
</span></span></code></pre></div><p>这对于高阶函数非常有用，即，将其他函数作为输入的函数。 一个简单高阶函数的是 <a href="https://docs.raku.org/type/List#routine_map">map</a>，它对每个输入元素应用一个函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">square</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@squared</span> <span class="o">=</span> <span class="nb">map</span> <span class="nv">&amp;square</span><span class="o">,</span>  <span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">join</span> <span class="p">&#39;</span><span class="s1">, </span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">@squared</span><span class="p">;</span>        <span class="c1"># 1, 4, 9, 16, 25</span>
</span></span></code></pre></div><h3 id="中缀形式">中缀形式</h3>
<p>要像中缀运算符那样调用具有2个参数的子例程，请使用由 <code>[</code> 和 <code>]</code> 包围的子例程引用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">plus</span> <span class="p">{</span> <span class="nv">$^a</span> <span class="o">+</span> <span class="nv">$^b</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">21</span> <span class="o">[</span><span class="nv">&amp;plus</span><span class="o">]</span> <span class="mi">21</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«42␤»</span>
</span></span></code></pre></div><h3 id="闭包">闭包</h3>
<p>Raku 中的所有代码对象都是闭包，这意味着它们可以从外部作用域引用词法变量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">generate-sub</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$y</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#      ^^^^^^^^^^^^^^  inner sub, uses $y</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$generated</span> <span class="o">=</span> <span class="nf">generate-sub</span><span class="p">(</span><span class="mi">21</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$generated</span><span class="p">();</span> <span class="c1"># 42</span>
</span></span></code></pre></div><p>这里 <code>$y</code> 是 <code>generate-sub</code> 中的词法变量，并且返回的内部子例程使用了 <code>$y</code>。 到内部 sub 被调用时，<code>generate-sub</code> 已经退出。 然而内部 sub 仍然可以使用 <code>$y</code>，因为它关闭了变量。</p>
<p>一个不太明显但有用的闭包示例是使用 <a href="https://docs.raku.org/type/List#routine_map">map</a> 乘以数字列表：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$multiply-by</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">join</span> <span class="p">&#39;</span><span class="s1">, </span><span class="p">&#39;</span><span class="o">,</span> <span class="nb">map</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">*</span> <span class="nv">$multiply-by</span> <span class="p">}</span><span class="o">,</span> <span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">;</span>     <span class="c1"># 5, 10, 15, 20, 25</span>
</span></span></code></pre></div><p>这里传递给 <code>map</code> 的块从外部作用域引用变量 <code>$multiply-by</code>，使块成为闭包。</p>
<p>没有闭包的语言不能轻易地提供高阶函数，它们像 map 一样易于使用和强大。</p>
<h3 id="routines">Routines</h3>
<p>例程是遵守 <a href="https://docs.raku.org/type/Routine">Routine</a> 类型的代码对象，最明显的是 <a href="https://docs.raku.org/type/Sub">Sub</a>，<a href="https://docs.raku.org/type/Method">方法</a>，<a href="https://docs.raku.org/type/Regex">正则表达式</a>和<a href="https://docs.raku.org/type/Submethod">Submethod</a>。</p>
<p>他们携带除了<a href="https://docs.raku.org/type/Block">块</a>提供的额外的功能：他们可以作为 <a href="https://docs.raku.org/language/functions#Multi-dispatch">multis</a>，你可以<a href="https://docs.raku.org/type/Routine#method_wrap">包装</a>它们，并使用 <code>return</code> 提前退出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$keywords</span> <span class="o">=</span> <span class="nb">set</span> <span class="p">&lt;</span><span class="s">if for unless while</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">has-keyword</span><span class="p">(</span><span class="o">*</span><span class="nv">@words</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nv">@words</span> <span class="k">-&gt;</span> <span class="nv">$word</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kt">True</span> <span class="k">if</span> <span class="nv">$word</span> <span class="ow">(elem)</span> <span class="nv">$keywords</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">False</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">has-keyword</span> <span class="p">&#39;</span><span class="s1">not</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">one</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">here</span><span class="p">&#39;;</span>       <span class="c1"># False</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">has-keyword</span> <span class="p">&#39;</span><span class="s1">but</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">here</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">for</span><span class="p">&#39;;</span>       <span class="c1"># True</span>
</span></span></code></pre></div><p>这里 <code>return</code> 不仅仅是将离开它所调用的块的内部，而是离开整个程序。 一般来说，块对于 <code>return</code> 是透明的，它们附加到外部程序。</p>
<p>例程(Routines)可以是内联的，并且因此为包装设置了障碍。 使用指令 <code>use soft;</code> 以防止内联在运行时允许包装。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">testee</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$i</span><span class="o">,</span> <span class="kt">Str</span> <span class="nv">$s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nb">rand</span><span class="o">.</span><span class="kt">Rat</span> <span class="o">*</span> <span class="nv">$i</span> <span class="o">~</span> <span class="nv">$s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">wrap-to-debug</span><span class="p">(</span><span class="nv">&amp;c</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">wrapping </span><span class="p">{</span><span class="nv">&amp;c</span><span class="o">.</span><span class="nb">name</span><span class="p">}</span><span class="s2"> with arguments </span><span class="p">{</span><span class="nv">&amp;c</span><span class="o">.</span><span class="nb">signature</span><span class="o">.</span><span class="nb">perl</span><span class="p">}&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">&amp;c</span><span class="o">.</span><span class="nb">wrap</span><span class="o">:</span> <span class="k">sub</span> <span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nb">note</span> <span class="p">&#34;</span><span class="s2">calling </span><span class="p">{</span><span class="nv">&amp;c</span><span class="o">.</span><span class="nb">name</span><span class="p">}</span><span class="s2"> with </span><span class="p">{</span><span class="nb">args</span><span class="o">.</span><span class="nb">gist</span><span class="p">}&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">\ret-val</span> <span class="o">:=</span> <span class="nb">callwith</span><span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nb">note</span> <span class="p">&#34;</span><span class="s2">returned from </span><span class="p">{</span><span class="nv">&amp;c</span><span class="o">.</span><span class="nb">name</span><span class="p">}</span><span class="s2"> with return value </span><span class="p">{</span><span class="n">ret-val</span><span class="o">.</span><span class="nb">perl</span><span class="p">}&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret-val</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$testee-handler</span> <span class="o">=</span> <span class="nf">wrap-to-debug</span><span class="p">(</span><span class="nv">&amp;testee</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«wrapping testee with arguments :(Int $i, Str $s)»</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">testee</span><span class="p">(</span><span class="mi">10</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">ten</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«calling testee with \(10, &#34;ten&#34;)␤returned from testee with return value &#34;6.151190ten&#34;␤6.151190ten»</span>
</span></span><span class="line"><span class="cl"><span class="nv">&amp;testee</span><span class="o">.</span><span class="nb">unwrap</span><span class="p">(</span><span class="nv">$testee-handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">testee</span><span class="p">(</span><span class="mi">10</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">ten</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«6.151190ten␤»</span>
</span></span></code></pre></div><h3 id="定义操作符">定义操作符</h3>
<p>操作符只是有趣名字的子例程。 有趣的名称由类别名称（中缀，前缀，后缀，环缀，后环缀）组成，后面跟着冒号，以及一个或多个操作符名称的列表（在环缀和后环缀的情况下为两个组件）。</p>
<p>这既适用于向现有运算符添加多个候选项，也适用于定义新的运算符。 在后一种情况下，新子例程的定义自动将新运算符安装到 语法(grammar)中，但仅在当前词法作用域中。 通过 <code>use</code> 或 <code>import</code> 导入操作符也使其可用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># adding a multi candidate to an existing operator:</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;(</span><span class="kt">Int</span> <span class="nv">$x</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">same</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="mi">2</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">21</span> <span class="o">+</span> <span class="p">&#34;</span><span class="s2">same</span><span class="p">&#34;;</span>            <span class="c1"># 42</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 定义一个新的操作符</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!</span><span class="p">&gt;(</span><span class="kt">Int</span> <span class="nv">$x</span> <span class="k">where</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">})</span> <span class="p">{</span> <span class="o">[*]</span> <span class="mi">1</span><span class="o">..</span><span class="nv">$x</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">6</span><span class="o">!</span><span class="p">;</span>                     <span class="c1"># 720</span>
</span></span></code></pre></div><p>运算符声明变得尽快可用，因此您甚至可以递归到刚才定义的运算符中，如果您真的想要：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!</span><span class="p">&gt;(</span><span class="kt">Int</span> <span class="nv">$x</span> <span class="k">where</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">??</span> <span class="mi">1</span> <span class="o">!!</span> <span class="nv">$x</span> <span class="o">*</span> <span class="p">(</span><span class="nv">$x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">!</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">6</span><span class="o">!</span><span class="p">;</span>                     <span class="c1"># 720</span>
</span></span></code></pre></div><p>环缀和后环缀操作符由两个分隔符组成，一个开口和一个闭合。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">circumfix:</span><span class="p">&lt;</span><span class="s">START END</span><span class="p">&gt;(</span><span class="o">*</span><span class="nv">@elems</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">&#34;</span><span class="s2">start</span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">@elems</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">end</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">START</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;</span> <span class="k">END</span><span class="p">;</span>        <span class="c1"># start a b c end</span>
</span></span></code></pre></div><p>后环缀也接收这个术语，在它们被作为参数解析之后：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">postcircumfix:</span><span class="p">&lt;</span><span class="s">!! !!</span><span class="p">&gt;(</span><span class="nv">$left</span><span class="o">,</span> <span class="nv">$inside</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">&#34;</span><span class="nv">$left</span><span class="s2"> -&gt; ( </span><span class="nv">$inside</span><span class="s2"> )</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">42</span><span class="o">!!</span> <span class="mi">1</span> <span class="o">!!</span><span class="p">;</span>      <span class="c1"># 42 -&gt; ( 1 )</span>
</span></span></code></pre></div><p>块可以直接赋值给操作符名。 使用变量声明符，并在操作符名前加上一个 <code>&amp;</code> 符号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">&amp;infix:</span><span class="p">&lt;</span><span class="s">ieq</span><span class="p">&gt;</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">l</span> <span class="p">{</span> <span class="o">[</span><span class="ow">eq</span><span class="o">]</span> <span class="nb">l</span><span class="o">&gt;&gt;.</span><span class="nb">fc</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">abc</span><span class="p">&#34;</span> <span class="n">ieq</span> <span class="p">&#34;</span><span class="s2">Abc</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«True␤»</span>
</span></span></code></pre></div><h3 id="优先级">优先级</h3>
<p>Raku 中的运算符优先级相对于现有运算符指定。 <code>is tighter</code>、<code>is equiv</code> 和 <code>is looser</code> 特性能使用一个运算符提供，新的运算符优先级与之相关。 可以应用更多的特征。</p>
<p>例如，<code>infix:&lt;*&gt;</code> 的优先级高于 <code>infix:&lt;+&gt;</code>，并且在中间挤压一个像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!!</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">is</span> <span class="nc">tighter</span><span class="p">(</span><span class="nv">&amp;infix:</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">!!</span> <span class="mi">4</span><span class="p">;</span>     <span class="c1"># 21</span>
</span></span></code></pre></div><p>这里 <code>1 + 2 * 3 !! 4</code> 被解析为 <code>1 + ((2 * 3) !! 4)</code>，因为新的 <code>!!</code> 运算符的优先级在 <code>+</code> 和 <code>*</code> 之间。</p>
<p>可以使用下面的代码实现相同的效果:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!!</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span><span class="nv">$b</span><span class="p">)</span> <span class="k">is</span> <span class="nc">looser</span><span class="p">(</span><span class="nv">&amp;infix:</span><span class="p">&lt;</span><span class="s">x</span><span class="p">&gt;)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span></code></pre></div><p>要将新运算符置于与现有运算符相同的优先级别上，请使用 <code>is equiv(&amp;other-operator)</code>。</p>
<h3 id="结合性">结合性</h3>
<p>当同一个操作符在一行中连续出现多次时，有多种可能的解释。 例如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
</span></span></code></pre></div><p>能被解析为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="c1"># 左结合性</span>
</span></span></code></pre></div><p>或者解析为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># 右结合性</span>
</span></span></code></pre></div><p>对于实数的加法，区别有点模糊，因为 <code>+</code> 是<a href="https://en.wikipedia.org/wiki/Associative_property">数学上相关的</a>。</p>
<p>但对其他运算符来说它很重要。 例如对于指数/幂运算符，<code>infix:&lt;**&gt;</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">3</span><span class="p">);</span>      <span class="c1"># 256</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span><span class="p">;</span>      <span class="c1"># 64</span>
</span></span></code></pre></div><p>Raku 拥有以下可能的结合性配置：</p>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">Assoc</th>
<th style="text-align:left">Meaning of $a ! $b ! $c</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">L</td>
<td style="text-align:center">left</td>
<td style="text-align:left">($a ! $b) ! $c</td>
</tr>
<tr>
<td style="text-align:center">R</td>
<td style="text-align:center">right</td>
<td style="text-align:left">$a ! ($b ! $c)</td>
</tr>
<tr>
<td style="text-align:center">N</td>
<td style="text-align:center">non</td>
<td style="text-align:left">ILLEGAL</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">chain</td>
<td style="text-align:left">($a ! $b) and ($b ! $c)</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">list</td>
<td style="text-align:left">infix:&lt;!&gt;($a; $b; $c)</td>
</tr>
</tbody>
</table>
<p>您可以使用 <code>is assoc</code> trait 指定运算符的结合性，其中 <code>left</code> 是默认的结合性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">§</span><span class="p">&gt;(</span><span class="o">*</span><span class="nv">@a</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;)</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span> § <span class="mi">2</span> § <span class="mi">3</span><span class="p">;</span>      <span class="c1"># (1|2|3)</span>
</span></span></code></pre></div><h3 id="traits">Traits</h3>
<p>特性（<em>traits</em>）是在编译时运行以修改类型，变量，例程，属性或其他语言对象的行为的子例程。</p>
<p>traits 的例子有：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ChildClass</span> <span class="k">is</span> <span class="nc">ParentClass</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">#                ^^ trait, with argument ParentClass</span>
</span></span><span class="line"><span class="cl"><span class="k">has</span> <span class="nv">$.attrib</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#            ^^^^^  trait with name &#39;rw&#39;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SomeClass</span> <span class="k">does</span> <span class="nc">AnotherRole</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">#               ^^^^ trait</span>
</span></span><span class="line"><span class="cl"><span class="k">has</span> <span class="nv">$!another-attribute</span> <span class="nb">handles</span> <span class="p">&lt;</span><span class="s">close</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#                       ^^^^^^^ trait</span>
</span></span></code></pre></div><p>还有之前章节中的 <code>is tighter</code>、<code>is looser</code>、<code>is equiv</code>、<code>is assoc</code> 等。</p>
<p>Traits 是 <code>trait_mod&lt;VERB&gt;</code> 形式的 subs, 其中  <code>VERB</code> 代表像 <code>is</code>、<code>does</code>、<code>handles</code> 那样的名字。它接受修改后的东西作为参数, 还有名字作为具名参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">trait_mod</span><span class="o">:</span><span class="p">&lt;</span><span class="s">is</span><span class="p">&gt;(</span><span class="kt">Routine</span> <span class="nv">$r</span><span class="o">,</span> <span class="o">:</span><span class="nv">$doubles</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$r</span><span class="o">.</span><span class="nb">wrap</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">        <span class="mi">2</span> <span class="o">*</span> <span class="nb">callsame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">square</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="k">is</span> <span class="nc">doubles</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$x</span> <span class="o">*</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">square</span> <span class="mi">3</span><span class="p">;</span>       <span class="c1"># 18</span>
</span></span></code></pre></div><p>请参阅内置常规性状文档的<a href="https://docs.raku.org/type/Routine">类型例程</a>。</p>
<h3 id="重新分派">重新分派</h3>
<p>在某些情况下，例程可能想从链中调用下一个方法。 这个链可以是类层次结构中的父类的列表，或者它可以是来自多分派的较不具体的 multi 候选者，或者它可以是来自<code>wrap</code>的内部例程。</p>
<p>在所有这些情况下，您可以使用 <code>callwith</code> 通过您自己选择的参数调用链中的下一个例程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">a</span><span class="p">(</span><span class="kt">Any</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Any </span><span class="nv">$x</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">a</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Int </span><span class="nv">$x</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$res</span> <span class="o">=</span> <span class="nb">callwith</span><span class="p">(</span><span class="nv">$x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Back in Int with </span><span class="nv">$res</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Int 1</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Any 2</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Back in Int with 5</span>
</span></span></code></pre></div><p>这里，<code>a 1</code> 首先调用最具体的 <code>Int</code> 候选者，并且 <code>callwith</code> 重新调度到较不具体的 <code>Any</code> 候选者。</p>
<p>通常，重新分派传递和调用者接收到的相同的参数，因此有一个特殊的例程：<code>callsame</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">a</span><span class="p">(</span><span class="kt">Any</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Any </span><span class="nv">$x</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">a</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Int </span><span class="nv">$x</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$res</span> <span class="o">=</span> <span class="nb">callsame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Back in Int with </span><span class="nv">$res</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="mi">1</span><span class="p">;</span>        <span class="c1"># Int 1\n Any 1\n Back in Int with 5</span>
</span></span></code></pre></div><p>另一个常见的用例是重新分派到链中的下一个例程，之后不执行任何其他操作。 这就是为什么我们有 <code>nextwith</code> 和 <code>nextsame</code>，它使用任意的参数调用下一个例程（<code>nextwith</code>）或与调用者接收（<code>nextsame</code>）相同的参数，但不会返回给调用者。 或者对其进行不同的措辞，<code>nextsame</code> 和 <code>nextwith</code> 变体用下一个候选项替换当前的调用帧(callframe)。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">a</span><span class="p">(</span><span class="kt">Any</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Any </span><span class="nv">$x</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">a</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Int </span><span class="nv">$x</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">nextsame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">back in a</span><span class="p">&#34;;</span>    <span class="c1"># never executed, because &#39;nextsame&#39; doesn&#39;t return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="mi">1</span><span class="p">;</span>        <span class="c1"># Int 1\n Any 1</span>
</span></span></code></pre></div><p>如前所述，multi sub 不是唯一能在 call，call me，nextwith 和 next 中有帮助的情况。 下面是是调度到包装的例程：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># enable wrapping:</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">soft</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># function to be wrapped:</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">square-root</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span><span class="o">.</span><span class="nb">sqrt</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">&amp;square-root</span><span class="o">.</span><span class="nb">wrap</span><span class="p">(</span><span class="k">sub</span> <span class="p">(</span><span class="nv">$num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nb">nextsame</span> <span class="k">if</span> <span class="nv">$num</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="mi">1</span><span class="no">i</span> <span class="o">*</span> <span class="nb">callwith</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="nv">$num</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">square-root</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>     <span class="c1"># 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">square-root</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span>    <span class="c1"># 0+2i</span>
</span></span></code></pre></div><p>最后一个用例是从父类中重分派给方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LoggedVersion</span> <span class="k">is</span> <span class="kt">Version</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">note</span> <span class="p">&#34;</span><span class="s2">New version object created with arguments </span><span class="p">&#34;</span> <span class="o">~</span> <span class="n">c</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">nextsame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">LoggedVersion</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">1.0.2</span><span class="p">&#39;);</span>
</span></span></code></pre></div><p>如果你需要对被包装的代码进行多次调用或获得一个引用，例如内省它，你可以使用 <code>nextcallee</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">power-it</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">run-it-again-and-again</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">&amp;again</span> <span class="o">=</span> <span class="nb">nextcallee</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">again</span> <span class="n">again</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">&amp;power-it</span><span class="o">.</span><span class="nb">wrap</span><span class="p">(</span><span class="nv">&amp;run-it-again-and-again</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">power-it</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>    <span class="c1"># 625</span>
</span></span></code></pre></div><h3 id="强制类型">强制类型</h3>
<p>强制类型可以帮助您在例程中拥有特定类型，但接受更宽的输入。 当调用例程时，参数将自动转换为较窄的类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">double</span><span class="p">(</span><span class="kt">Int</span><span class="p">(</span><span class="kt">Cool</span><span class="p">)</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="mi">2</span> <span class="o">*</span> <span class="nv">$x</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">double</span> <span class="p">&#39;</span><span class="s1">21</span><span class="p">&#39;;</span> <span class="c1"># 42</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">double</span> <span class="kt">Any</span><span class="p">;</span>  <span class="c1"># Type check failed in binding $x; expected &#39;Cool&#39; but got &#39;Any&#39;</span>
</span></span></code></pre></div><p>这里的 <code>Int</code> 是参数将被强制的目标类型，而 <code>Cool</code> 是例程接受的作为输入的类型。</p>
<p>如果接受的输入类型为 <code>Any</code>，则可以将 <code>Int(Any)</code> 缩写为 <code>Int()</code>。</p>
<p>强制只需查找与目标类型具有相同名称的方法即可。 所以你可以为你自己的类型定义强制，像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Bar</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">has</span> <span class="nv">$.msg</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">I&#39;m a foo!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">method</span> <span class="nf">Bar</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">Bar</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">msg</span><span class="p">(</span><span class="nv">$.msg</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> But I am now Bar.</span><span class="p">&#39;));</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Bar</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">has</span> <span class="nv">$.msg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">print-bar</span><span class="p">(</span><span class="nf">Bar</span><span class="p">()</span> <span class="nv">$bar</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nb">say</span> <span class="nv">$bar</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span> <span class="c1"># (Bar)</span>
</span></span><span class="line"><span class="cl">   <span class="nb">say</span> <span class="nv">$bar</span><span class="o">.</span><span class="nf">msg</span><span class="p">;</span>  <span class="c1"># I&#39;m a foo! But I am now Bar.</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">print-bar</span> <span class="n">Foo</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span></code></pre></div><p>强制类型应该在类型工作的任何地方工作，但 Rakudo 当前（2015.02）仅针对子例程参数实现了它们。</p>
<h2 id="sub-main">sub MAIN</h2>
<p>具有特殊名称 MAIN 的 sub 在所有相关 parsers 之后执行，并且其签名是可以解析命令行参数的装置。 支持 multi 方法，如果未提供命令行参数，则会自动生成并显示使用方法。 所有命令行参数在 <a href="https://docs.raku.org/language/variables#Dynamic_variables">@*ARGS</a> 中也可用，它可以在被 MAIN 处理之前进行变换。</p>
<p><code>MAIN</code> 的返回值被忽略。 要提供除 0 以外的退出代码，请调用 <a href="https://docs.raku.org/routine/exit">exit</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span> <span class="kt">Int</span> <span class="o">:</span><span class="nv">$length</span> <span class="o">=</span> <span class="mi">24</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">           <span class="p">:</span><span class="s">file</span><span class="p">(</span><span class="nv">$data</span><span class="p">)</span> <span class="k">where</span> <span class="p">{</span> <span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">f</span> <span class="o">//</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">file not found in </span><span class="nv">$*CWD</span><span class="p">&#34;</span> <span class="p">}</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">file.dat</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">           <span class="kt">Bool</span> <span class="o">:</span><span class="nv">$verbose</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$length</span> <span class="k">if</span> <span class="nv">$length</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$data</span>   <span class="k">if</span> <span class="nv">$data</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Verbosity </span><span class="p">&#39;</span><span class="o">,</span> <span class="p">(</span><span class="nv">$verbose</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">on</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">off</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">exit</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="sub-usage">sub USAGE</h2>
<p>如果对于给定的命令行参数没有找到 <code>MAIN</code> 的多个候选者，则调用 sub <code>USAGE</code>。 如果没有找到此类方法，则输出生成的使用消息。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$i</span><span class="p">){</span> <span class="nb">say</span> <span class="nv">$i</span> <span class="o">==</span> <span class="mi">42</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">answer</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">dunno</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">USAGE</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="k">Q</span><span class="sa">:c:to</span><span class="p">/EOH/;</span><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">Usage: </span><span class="p">{</span><span class="vg">$*PROGRAM-NAME</span><span class="p">}</span><span class="s"> [number]
</span></span></span><span class="line"><span class="cl"><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">Prints the answer or &#39;dunno&#39;.
</span></span></span><span class="line"><span class="cl"><span class="s"></span><span class="p">EOH</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[异常]]></title>
            <link href="http://localhost:1313/rakulang/43.exceptions/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/42.enumeration/?utm_source=atom_feed" rel="related" type="text/html" title="枚举" />
                <link href="http://localhost:1313/rakulang/41.date-and-time-functions/?utm_source=atom_feed" rel="related" type="text/html" title="日期和时间函数" />
                <link href="http://localhost:1313/rakulang/40.data-structures/?utm_source=atom_feed" rel="related" type="text/html" title="数据流" />
                <link href="http://localhost:1313/rakulang/39.control-flow/?utm_source=atom_feed" rel="related" type="text/html" title="控制流" />
                <link href="http://localhost:1313/rakulang/38.contexts-and-contextualizers/?utm_source=atom_feed" rel="related" type="text/html" title="上下文和上下文器" />
            
                <id>http://localhost:1313/rakulang/43.exceptions/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-18T21:13:31+08:00</published>
            <updated>2018-11-18T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>Raku 中的异常是保存有关错误信息的对象。例如，错误可能是意外接收数据或网络连接不再可用，或者丢失文件。异常对象存储的信息是关于错误条件的人类可读消息，错误引发的回溯等等。</p>
<p>所有内置异常都继承自 <a href="https://docs.raku.org/type/Exception">Exception</a>，它提供了一些基本行为，包括回溯的存储和回溯打印机的接口。</p>
<h2 id="热异常">热异常</h2>
<p>通过调用带有描述错误的 <a href="https://docs.raku.org/routine/die">die</a> 函数来使用热异常：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">die</span> <span class="p">&#34;</span><span class="s2">oops, something went wrong</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># RESULT: «oops, something went wrong in block &lt;unit&gt; at my-script.p6:1␤» </span>
</span></span></code></pre></div><p>值得注意的是，<code>die</code> 会将错误消息打印到标准错误 <code>$*ERR</code>。</p>
<h2 id="类型化的异常">类型化的异常</h2>
<p>类型化异常提供有关异常对象中存储的错误的更多信息。</p>
<p>例如，如果在对象上执行 <code>.zombie copy</code> 时，所需的路径 <code>foo/bar</code> 变得不可用，则可以引发 <a href="https://docs.raku.org/type/X::IO::DoesNotExist">X::IO::DoesNotExist</a>异常：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">die</span> <span class="ne">X::IO::DoesNotExist</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">path</span><span class="p">(&#34;</span><span class="s2">foo/bar</span><span class="p">&#34;)</span><span class="o">,</span> <span class="p">:</span><span class="s">trying</span><span class="p">(&#34;</span><span class="s2">zombie copy</span><span class="p">&#34;))</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># RESULT: «Failed to find &#39;foo/bar&#39; while trying to do &#39;.zombie copy&#39; </span>
</span></span><span class="line"><span class="cl"><span class="c1">#          in block &lt;unit&gt; at my-script.p6:1» </span>
</span></span></code></pre></div><p>请注意对象如何为回溯提供有关出错的信息。代码的用户现在可以更轻松地找到并纠正问题。</p>
<h2 id="捕获异常">捕获异常</h2>
<p>通过提供 <code>CATCH</code> 块可以处理异常情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">die</span> <span class="ne">X::IO::DoesNotExist</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">path</span><span class="p">(&#34;</span><span class="s2">foo/bar</span><span class="p">&#34;)</span><span class="o">,</span> <span class="p">:</span><span class="s">trying</span><span class="p">(&#34;</span><span class="s2">zombie copy</span><span class="p">&#34;));</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="ne">X::IO</span> <span class="p">{</span> <span class="vg">$*ERR</span><span class="o">.</span><span class="nb">say</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">some kind of IO exception was caught!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «some kind of IO exception was caught!» </span>
</span></span></code></pre></div><p>在这里，我们说如果发生 <code>X::IO</code> 类型的任何异常，那么消息 <code>some kind of IO exception was caught!</code> 会被发送到 <em>stderr</em>，这是 <code>$*ERR.say</code> 所做的事情，在那一刻构成标准错误设备的任何内容上显示，默认情况下可能是控制台。</p>
<p><code>CATCH</code> 块使用类似于 <code>given/when</code> 对选项进行智能匹配的智能匹配，因此可以捕获和处理 <code>when</code> 块内的各种类别的异常。</p>
<p>要处理所有异常，请使用 <code>default</code> 语句。此示例打印出与普通回溯打印机几乎相同的信息。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="vg">$*ERR</span><span class="o">.</span><span class="nb">say</span><span class="o">:</span> <span class="o">.</span><span class="nb">message</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">         <span class="k">for</span> <span class="o">.</span><span class="nb">backtrace</span><span class="o">.</span><span class="nb">reverse</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">             <span class="nb">next</span> <span class="k">if</span> <span class="o">.</span><span class="nb">file</span><span class="o">.</span><span class="nb">starts-with</span><span class="p">(&#39;</span><span class="s1">SETTING::</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">             <span class="nb">next</span> <span class="k">unless</span> <span class="o">.</span><span class="nb">subname</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">             <span class="vg">$*ERR</span><span class="o">.</span><span class="nb">say</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">  in block </span><span class="p">{</span><span class="o">.</span><span class="nb">subname</span><span class="p">}</span><span class="s2"> at </span><span class="p">{</span><span class="o">.</span><span class="nb">file</span><span class="p">}</span><span class="s2"> line </span><span class="p">{</span><span class="o">.</span><span class="nb">line</span><span class="p">}&#34;;</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>请注意，匹配目标是一个角色。要允许用户定义的异常以相同的方式匹配，它们必须实现给定的角色。仅存在于同一名称空间中看起来相似但在 <code>CATCH</code> 块中不匹配。</p>
<h2 id="异常处理程序和闭合块">异常处理程序和闭合块</h2>
<p>在 <code>CATCH</code> 处理异常之后，退出包围 <code>CATCH</code> 块的块。</p>
<p>换句话说，即使成功处理异常，封闭块中的其余代码也永远不会被执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">die</span> <span class="p">&#34;</span><span class="s2">something went wrong ...</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># will definitely catch all the exception </span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span> <span class="p">{</span> <span class="o">.</span><span class="kt">Str</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">This won&#39;t be said.</span><span class="p">&#34;;</span>   <span class="c1"># but this line will be never reached since </span>
</span></span><span class="line"><span class="cl">                             <span class="c1"># the enclosing block will be exited immediately </span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «something went wrong ...␤» </span>
</span></span></code></pre></div><p>和这个作对比：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="k">CATCH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">default</span> <span class="p">{</span> <span class="o">.</span><span class="kt">Str</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">something went wrong ...</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hi! I am at the outer block!</span><span class="p">&#34;;</span> <span class="c1"># OUTPUT: «Hi! I am at the outer block!␤» </span>
</span></span></code></pre></div><p>有关如何将控制权返回到发生异常的位置，请参阅<a href="https://docs.raku.org/language/exceptions#Resuming_of_exceptions">恢复异常</a>。</p>
<h2 id="try-块">try 块</h2>
<p><code>try</code> 块是一个普通块，它隐式打开 <a href="https://docs.raku.org/language/pragmas#index-entry-fatal-fatal">use fatal pragma</a> 编译指示，并包含一个隐式 <code>CATCH</code> 块，它会删除异常，这意味着您可以使用它来包含它们。 捕获的异常存储在$中！ 变量，它包含 <code>Exception</code> 类型的值。</p>
<p>像这样的普通块将会失败：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="o">+</span><span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$x</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1"># OUTPUT: «Failure␤» </span>
</span></span></code></pre></div><p>但是，<code>try</code> 块将包含异常并将其放入 <code>$!</code> 变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="o">+</span><span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$x</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$!</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Something failed!</span><span class="p">&#34;</span> <span class="p">}</span> <span class="c1"># OUTPUT: «Something failed!␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$!</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>                     <span class="c1"># OUTPUT: «X::Str::Numeric␤» </span>
</span></span></code></pre></div><p>在这样的块中抛出的任何异常都将被 <code>CATCH</code> 块捕获，无论是隐式的还是由用户提供的。在后一种情况下，任何未处理的异常都将被重新抛出。如果您选择不处理异常，则它们将被块包含。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Tough luck</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Not gonna happen</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">fail</span> <span class="p">&#34;</span><span class="s2">FUBAR</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在上面的两个 <code>try</code> 块中，异常将包含在块中，但不会运行 <code>say</code> 语句。但我们可以处理它们：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">E</span> <span class="k">is</span> <span class="kt">Exception</span> <span class="p">{</span> <span class="k">method</span> <span class="nb">message</span><span class="p">()</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Just stop already!</span><span class="p">&#34;</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">E</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nb">throw</span><span class="p">;</span> <span class="c1"># this will be local </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">This won&#39;t be said.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I&#39;m alive!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">CATCH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="ne">X::AdHoc</span> <span class="p">{</span> <span class="o">.</span><span class="kt">Str</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="o">.</span><span class="nb">resume</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">No, I expect you to DIE Mr. Bond!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I&#39;m immortal.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="n">E</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nb">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No, you don&#39;t!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这会输出：</p>
<pre tabindex="0"><code>I&#39;m alive!
No, I expect you to DIE Mr. Bond!
I&#39;m immortal.
Just stop already!
  in block &lt;unit&gt; at exception.p6 line 21
</code></pre><p>由于 <code>CATCH</code> 块只处理 <code>die</code> 语句抛出的 <code>X::AdHoc</code> 异常，而不处理 <code>E</code> 异常。 如果没有 <code>CATCH</code> 块，所有异常都将被包含和删除，如上所示。 恢复将在异常抛出后立即恢复执行; 在这种情况下，在 <code>die</code> 语句中。 有关详细信息，请参阅有关<a href="https://docs.raku.org/language/exceptions#Resuming_of_exceptions">恢复异常</a>的部分。</p>
<p><code>try-block</code> 是一个普通的块，因此将其最后一个语句视为自身的返回值。 因此，我们可以将其用作右手边。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="k">try</span> <span class="p">{</span> <span class="o">+</span><span class="p">&#34;</span><span class="s2">99999</span><span class="p">&#34;</span> <span class="p">}</span> <span class="o">//</span> <span class="p">&#34;</span><span class="s2">oh no</span><span class="p">&#34;;</span> <span class="c1"># OUTPUT: «99999␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="k">try</span> <span class="p">{</span> <span class="o">+</span><span class="p">&#34;</span><span class="s2">hello</span><span class="p">&#34;</span> <span class="p">}</span> <span class="o">//</span> <span class="p">&#34;</span><span class="s2">oh no</span><span class="p">&#34;;</span> <span class="c1"># OUTPUT: «oh no␤» </span>
</span></span></code></pre></div><p>通过返回表达式的返回值来间接尝试块支持 <code>else</code> 块，如果抛出异常，则返回 <a href="https://docs.raku.org/type/Nil">Nil</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">with</span> <span class="k">try</span> <span class="o">+</span><span class="p">&#34;</span><span class="s2">♥</span><span class="p">&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">this is my number: </span><span class="nv">$_</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">not my number!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «not my number!␤» </span>
</span></span></code></pre></div><p><code>try</code> 也可以和语句一块用而非块：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="k">try</span> <span class="p">&#34;</span><span class="s2">some-filename.txt</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">slurp</span> <span class="o">//</span> <span class="p">&#34;</span><span class="s2">sane default</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «sane default␤» </span>
</span></span></code></pre></div><p><code>try</code> 实际导致的是，通过 <code>use fatal pragma</code>，立即抛出在其范围内发生的异常，但通过这样做，从抛出异常的点调用 <code>CATCH</code> 块，定义其范围。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$error-code</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">333</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">bad-sub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Something bad happened</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$error-code</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">111</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="n">bad-sub</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">CATCH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Error </span><span class="nv">$error-code</span><span class="s2"> </span><span class="p">&#34;</span><span class="o">,</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,.</span><span class="kt">Str</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Error 111 X::AdHoc: Something bad happened␤» </span>
</span></span></code></pre></div><h2 id="抛出异常">抛出异常</h2>
<p>可以使用Exception对象的 <code>.throw</code> 方法显式抛出异常。</p>
<p>此示例抛出 AdHoc 异常，捕获它并允许代码通过调用 <code>.resume</code> 方法从异常点继续。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="ne">X::AdHoc</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">payload</span><span class="p">&lt;</span><span class="s">foo</span><span class="p">&gt;)</span><span class="o">.</span><span class="nb">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&#34;</span><span class="s2">OHAI</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">CATCH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="ne">X::AdHoc</span> <span class="p">{</span> <span class="o">.</span><span class="nb">resume</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">OBAI</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «OHAI␤OBAI␤» </span>
</span></span></code></pre></div><p>如果 CATCH 块与抛出的异常不匹配，则将异常的有效负载传递给回溯打印机制。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="ne">X::AdHoc</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">payload</span><span class="p">&lt;</span><span class="s">foo</span><span class="p">&gt;)</span><span class="o">.</span><span class="nb">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&#34;</span><span class="s2">OHAI</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">CATCH</span> <span class="p">{</span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">OBAI</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># RESULT: «foo </span>
</span></span><span class="line"><span class="cl"><span class="c1">#          in block &lt;unit&gt; at my-script.p6:1» </span>
</span></span></code></pre></div><p>下一个示例不会从异常点恢复。相反，它会在封闭块之后继续，因为捕获了异常，然后在 CATC H块之后控制继续。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="ne">X::AdHoc</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">payload</span><span class="p">&lt;</span><span class="s">foo</span><span class="p">&gt;)</span><span class="o">.</span><span class="nb">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&#34;</span><span class="s2">OHAI</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">CATCH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="ne">X::AdHoc</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">OBAI</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «OBAI␤» </span>
</span></span></code></pre></div><p>throw 可以被视为 die 的方法形式，只是在这种特殊情况下，例程的 sub 和 method 形式有不同的名称。</p>
<h2 id="异常恢复">异常恢复</h2>
<p>异常会中断控制流并将其从抛出语句后的语句中转移出去。可以恢复用户处理的任何异常，并且控制流将继续使用抛出异常的语句之后的语句。为此，请在异常对象上调用方法 <code>.resume</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">when</span> <span class="ne">X::AdHoc</span> <span class="p">{</span> <span class="o">.</span><span class="nb">resume</span> <span class="p">}</span> <span class="p">}</span>         <span class="c1"># this is step 2 </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">die</span> <span class="p">&#34;</span><span class="s2">We leave control after this.</span><span class="p">&#34;;</span>         <span class="c1"># this is step 1 </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">We have continued with control flow.</span><span class="p">&#34;;</span> <span class="c1"># this is step 3 </span>
</span></span></code></pre></div><p>恢复将在导致异常的语句之后和最里面的调用帧中发生</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">bad-sub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Something bad happened</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">&#34;</span><span class="s2">not returning</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$return</span> <span class="o">=</span> <span class="n">bad-sub</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Returned </span><span class="nv">$return</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">CATCH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Error </span><span class="p">&#34;</span><span class="o">,</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,.</span><span class="kt">Str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$return</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">0</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="nb">resume</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Error X::AdHoc: Something bad happened </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Returned not returning </span>
</span></span></code></pre></div><p>在这种情况下，<code>.resume</code> 将转到在 <code>die</code> 语句之后发生的 <code>return</code> 语句。请注意，<code>$return</code> 的赋值不起作用，因为 CATCH 语句发生在对 <code>bad-sub</code> 的调用中，<code>bad-sub</code> 通过 <code>return</code> 语句为其分配不返回的值。</p>
<h2 id="未捕获的异常">未捕获的异常</h2>
<p>如果抛出异常但未捕获异常，则会导致程序以非零状态代码退出，并且通常会将消息输出到程序的标准错误流。通过在异常对象上调用 <code>gist</code> 方法获得此消息。您可以使用它来抑制打印回溯的默认行为以及消息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="ne">X::WithoutLineNumber</span> <span class="k">is</span> <span class="ne">X::AdHoc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nb">gist</span><span class="p">(</span><span class="ne">X::WithoutLineNumber:D:</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$.payload</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">die</span> <span class="ne">X::WithoutLineNumber</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">payload</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">message</span><span class="p">&#34;)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># prints &#34;message\n&#34; to $*ERR and exits, no backtrace </span>
</span></span></code></pre></div><h2 id="控制异常">控制异常</h2>
<p>某些关键字会引发控制异常，并自动或由相应的 phaser 处理。任何未处理的控制异常都将转换为正常异常。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="vg">$*ERR</span><span class="o">.</span><span class="nb">say</span><span class="o">:</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::ControlFlow::Return: Attempt to return outside of any Routine␤» </span>
</span></span><span class="line"><span class="cl"><span class="c1"># was CX::Return </span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[枚举]]></title>
            <link href="http://localhost:1313/rakulang/42.enumeration/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/41.date-and-time-functions/?utm_source=atom_feed" rel="related" type="text/html" title="日期和时间函数" />
                <link href="http://localhost:1313/rakulang/40.data-structures/?utm_source=atom_feed" rel="related" type="text/html" title="数据流" />
                <link href="http://localhost:1313/rakulang/39.control-flow/?utm_source=atom_feed" rel="related" type="text/html" title="控制流" />
                <link href="http://localhost:1313/rakulang/38.contexts-and-contextualizers/?utm_source=atom_feed" rel="related" type="text/html" title="上下文和上下文器" />
                <link href="http://localhost:1313/rakulang/37.containers/?utm_source=atom_feed" rel="related" type="text/html" title="容器" />
            
                <id>http://localhost:1313/rakulang/42.enumeration/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-17T21:13:31+08:00</published>
            <updated>2018-11-17T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>在 Raku 中，枚举(<code>enum</code>)类型比其他语言复杂得多，详细信息可在<a href="https://docs.raku.org/language/typesystem#enum">此处</a>的类型描述中找到。</p>
<p>这个简短的文档将给出一个简单的使用示例，就像在 C 语言中一样。</p>
<p>假设我们有一个需要写入各种目录的程序; 我们想要一个函数，给定一个目录名，测试它（1）是否存在（2）它是否可以被该程序的用户写入; 这意味着从用户的角度来看有三种可能的状态：要么你可以写（<code>CanWrite</code>），要么没有目录（<code>NoDir</code>）或者目录存在，但你不能写（<code>NoWrite</code>）。 测试结果将决定程序接下来要采取的操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">DirStat</span> <span class="p">&lt;</span><span class="s">CanWrite NoDir NoWrite</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">check-dir-status</span><span class="p">(</span><span class="nv">$dir</span> <span class="k">--&gt;</span> <span class="n">DirStat</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$dir</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">d</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># dir exists, can the program user write to it? </span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$f</span> <span class="o">=</span> <span class="p">&#34;</span><span class="nv">$dir</span><span class="s2">/.tmp</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">spurt</span> <span class="nv">$f</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">some text</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="k">CATCH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># unable to write for some reason </span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">NoWrite</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># if we get here we must have successfully written to the dir </span>
</span></span><span class="line"><span class="cl">        <span class="nb">unlink</span> <span class="nv">$f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">CanWrite</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># if we get here the dir must not exist </span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">NoDir</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># test each of three directories by a non-root user </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$dirs</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="p">&#39;</span><span class="s1">/tmp</span><span class="p">&#39;</span><span class="o">,</span>  <span class="c1"># normally writable by any user </span>
</span></span><span class="line"><span class="cl">    <span class="p">&#39;</span><span class="s1">/</span><span class="p">&#39;</span><span class="o">,</span>     <span class="c1"># writable only by root </span>
</span></span><span class="line"><span class="cl">    <span class="p">&#39;</span><span class="s1">~/tmp</span><span class="p">&#39;;</span> <span class="c1"># a non-existent dir in the user&#39;s home dir </span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">$dirs</span> <span class="k">-&gt;</span> <span class="nv">$dir</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$stat</span> <span class="o">=</span> <span class="n">check-dir-status</span> <span class="nv">$dir</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">status of dir &#39;</span><span class="nv">$dir&#39;:</span><span class="s2"> </span><span class="nv">$stat</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$stat</span> <span class="o">~~</span> <span class="n">CanWrite</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">  user can write to dir: </span><span class="nv">$dir</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># output </span>
</span></span><span class="line"><span class="cl"><span class="c1">#   status of dir &#39;/tmp&#39;: CanWrite </span>
</span></span><span class="line"><span class="cl"><span class="c1">#     user can write to dir: /tmp </span>
</span></span><span class="line"><span class="cl"><span class="c1">#   status of dir &#39;/&#39;: NoWrite </span>
</span></span><span class="line"><span class="cl"><span class="c1">#   status of dir &#39;~/tmp&#39;: NoDir </span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[日期和时间函数]]></title>
            <link href="http://localhost:1313/rakulang/41.date-and-time-functions/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/40.data-structures/?utm_source=atom_feed" rel="related" type="text/html" title="数据流" />
                <link href="http://localhost:1313/rakulang/39.control-flow/?utm_source=atom_feed" rel="related" type="text/html" title="控制流" />
                <link href="http://localhost:1313/rakulang/38.contexts-and-contextualizers/?utm_source=atom_feed" rel="related" type="text/html" title="上下文和上下文器" />
                <link href="http://localhost:1313/rakulang/37.containers/?utm_source=atom_feed" rel="related" type="text/html" title="容器" />
                <link href="http://localhost:1313/rakulang/36.traps-to-avoid/?utm_source=atom_feed" rel="related" type="text/html" title="要避免的陷阱" />
            
                <id>http://localhost:1313/rakulang/41.date-and-time-functions/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-16T21:13:31+08:00</published>
            <updated>2018-11-16T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>Raku 包括几个处理时态信息的类：<a href="https://docs.raku.org/type/Date">Date</a>，<a href="https://docs.raku.org/type/DateTime">DateTime</a>，<a href="https://docs.raku.org/type/Instant">Instant</a> 和 <a href="https://docs.raku.org/type/Duration">Duration</a>。前三个是 dateish，所以它们混合了 <a href="https://docs.raku.org/type/Dateish">Dateish</a> 角色，它定义了处理日期的类应该采用的所有方法和属性。它还包括以 <a href="https://docs.raku.org/type/X::Temporal">X::Temporal</a> 为根的异常的类层次结构。</p>
<p>我们将尝试在下一个（稍微扩展）的示例中说明这些类，这个示例可用于处理目录中的所有文件（默认情况下）。在目录中使用特定扩展名（默认为 <code>.p6</code>），根据他们的年龄对其进行排序，并计算每月创建的文件数量，以及在几个月的范围内表示的特定时期内修改的文件数量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span> <span class="nv">$path</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">.</span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$extension</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">p6</span><span class="p">&#34;</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="kt">DateTime</span> <span class="nv">$right</span> <span class="o">=</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">now</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">%metadata</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">%files-month</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">%files-period</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nb">dir</span><span class="p">(</span><span class="nv">$path</span><span class="p">)</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span> <span class="p">/</span><span class="sr"> </span><span class="se">\</span><span class="sr">.</span><span class="nv">$extension</span><span class="sr"> </span><span class="ni">$</span><span class="p">/</span> <span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$file</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">CATCH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">when</span> <span class="ne">X::Temporal</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Date-related problem</span><span class="p">&#34;</span><span class="o">,</span> <span class="o">.</span><span class="nb">payload</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">when</span> <span class="ne">X::IO</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">File-related problem</span><span class="p">&#34;</span><span class="o">,</span> <span class="o">.</span><span class="nb">payload</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">default</span> <span class="p">{</span> <span class="o">.</span><span class="nb">payload</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="kt">Instant</span> <span class="nv">$modified</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">modified</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="kt">Instant</span> <span class="nv">$accessed</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">accessed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="kt">Duration</span> <span class="nv">$duration</span> <span class="o">=</span> <span class="nv">$accessed</span> <span class="o">-</span> <span class="nv">$modified</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$age</span> <span class="o">=</span> <span class="nv">$right</span> <span class="o">-</span> <span class="kt">DateTime</span><span class="p">(</span><span class="nv">$accessed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$time-of-day</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">changed</span><span class="o">.</span><span class="kt">DateTime</span><span class="o">.</span><span class="nb">hh-mm-ss</span> <span class="k">but</span> <span class="kt">Dateish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$file-changed-date</span> <span class="o">=</span>  <span class="nv">$file</span><span class="o">.</span><span class="nb">changed</span><span class="o">.</span><span class="kt">Date</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">%metadata</span><span class="p">{</span><span class="nv">$file</span><span class="p">}</span> <span class="o">=</span> <span class="nv">%</span><span class="p">(</span> <span class="s">modified</span> <span class="o">=&gt;</span> <span class="nv">$modified</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                              <span class="s">accessed</span> <span class="o">=&gt;</span> <span class="nv">$accessed</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                              <span class="s">age</span> <span class="o">=&gt;</span> <span class="nv">$age</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                              <span class="s">difference</span> <span class="o">=&gt;</span> <span class="nv">$duration</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                              <span class="s">changed-tod</span> <span class="o">=&gt;</span> <span class="nv">$time-of-day</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                              <span class="s">changed-date</span> <span class="o">=&gt;</span> <span class="nv">$file-changed-date</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nv">%files-month</span><span class="p">{</span><span class="nv">$file-changed-date</span><span class="o">.</span><span class="nb">month</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">given</span> <span class="nv">$file-changed-date</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">when</span> <span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">2018-01-01</span><span class="p">&#34;)</span><span class="o">..^</span><span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">2018-04-01</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="nv">%files-period</span><span class="p">&lt;</span><span class="s">pre-grant</span><span class="p">&gt;</span><span class="o">++</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">when</span> <span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">2018-04-01</span><span class="p">&#34;)</span><span class="o">..</span><span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">2018-05-31</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="nv">%files-period</span><span class="p">&lt;</span><span class="s">grant</span><span class="p">&gt;</span><span class="o">++</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">default</span> <span class="p">{</span> <span class="nv">%files-period</span><span class="p">&lt;</span><span class="s">post-grant</span><span class="p">&gt;</span><span class="o">++</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="nv">%metadata</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span> <span class="p">{</span> <span class="nv">$^a</span><span class="o">.</span><span class="nb">value</span><span class="p">&lt;</span><span class="s">age</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;</span> <span class="nv">$^b</span><span class="o">.</span><span class="nb">value</span><span class="p">&lt;</span><span class="s">age</span><span class="p">&gt;</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$^x</span><span class="o">.</span><span class="nb">key</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">, </span><span class="p">&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$^x</span><span class="o">.</span><span class="nb">value</span><span class="p">&lt;</span><span class="s">accessed modified age difference changed-tod changed-date</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">, </span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="nv">%files-month</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">sort</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Month </span><span class="nv">$^x</span><span class="s2"> → </span><span class="nv">%files-month</span><span class="p">{</span><span class="nv">$^x</span><span class="p">}&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="nv">%files-period</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Period </span><span class="nv">$^x</span><span class="s2"> → </span><span class="nv">%files-period</span><span class="p">{</span><span class="nv">$^x</span><span class="p">}&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>第 6 行使用 <code>DateTime</code> 来包含现在返回的当前日期和时间。</p>
<p>CATCH phaser 在第 11 到 15 行中声明。其主要任务是区分与 <code>DateTime</code> 相关的异常和其他类型。这种异常可能来自<a href="https://docs.raku.org/type/X::Temporal::InvalidFormat">无效格式</a>或<a href="https://docs.raku.org/type/X::DateTime::TimezoneClash">时区冲突</a>。除非文件属性有些损坏，否则两者都是不可能的，但无论如何它们都应该被捕获并与其他类型的异常分开。</p>
<p>我们使用第 16-17 行中的 <a href="https://docs.raku.org/type/Instant">Instants</a> 来表示访问和修改文件的时刻。 Instant 是以原子秒为单位测量的，是对时间事件的非常低级别的描述;但是，第 18 行中声明的持续时间代表两个不同实例之间转换的时间，我们将使用它来表示年龄。</p>
<p>对于某些变量，我们可能有兴趣用一些日期特征来处理它们。 <code>$time-of-day</code> 包含文件更改日期的时间; <code>changed</code> 将返回一个 Instant，但它将转换为日期（<code>Instant</code> 而不是 <code>Dateish</code>），然后从中提取时间。 <code>$time-of-day</code> 将有 <code>«Str+{Dateish}␤»</code> 类型。</p>
<p>我们将使用此变量中的日期来查找文件更改的时间段。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">2018-01-01</span><span class="p">&#34;)</span><span class="o">..^</span><span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">2018-04-01</span><span class="p">&#34;)</span>
</span></span></code></pre></div><p>创建一个日期<a href="https://docs.raku.org/type/Range">范围</a>，<code>$file-changed-date</code> 与它进行智能匹配。日期可以这样使用;在这种情况下，它会创建一个排除其最后一个元素的 <code>Range</code>。</p>
<p>这个变量也用于计算修改文件的一年中的月份。<a href="https://docs.raku.org/type/Date">日期</a> 显然是 Dateish，然后有月份方法从中提取该属性。</p>
<p>可以比较持续时间对象。这用于</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">     <span class="nv">%metadata</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">         <span class="nv">$^a</span><span class="o">.</span><span class="nb">value</span><span class="p">&lt;</span><span class="s">age</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;</span> <span class="nv">$^b</span><span class="o">.</span><span class="nb">value</span><span class="p">&lt;</span><span class="s">age</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">     <span class="p">});</span>
</span></span></code></pre></div><p>按年龄对文件进行排序。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[数据流]]></title>
            <link href="http://localhost:1313/rakulang/40.data-structures/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/39.control-flow/?utm_source=atom_feed" rel="related" type="text/html" title="控制流" />
                <link href="http://localhost:1313/rakulang/38.contexts-and-contextualizers/?utm_source=atom_feed" rel="related" type="text/html" title="上下文和上下文器" />
                <link href="http://localhost:1313/rakulang/37.containers/?utm_source=atom_feed" rel="related" type="text/html" title="容器" />
                <link href="http://localhost:1313/rakulang/36.traps-to-avoid/?utm_source=atom_feed" rel="related" type="text/html" title="要避免的陷阱" />
                <link href="http://localhost:1313/rakulang/35.testing/?utm_source=atom_feed" rel="related" type="text/html" title="测试" />
            
                <id>http://localhost:1313/rakulang/40.data-structures/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-15T21:13:31+08:00</published>
            <updated>2018-11-15T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="标量结构">标量结构</h1>
<p>某些类没有任何<em>内部</em>结构, 访问它们的一部分必须使用特定的方法。数字，字符串和其他一些整体类包含在该类中。他们使用 <code>$</code> sigil，虽然复杂的数据结构也可以使用它。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$just-a-number</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$just-a-string</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">8</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>有一个 <a href="https://docs.raku.org/type/Scalar">Scalar</a> 类，它在内部用于为使用 <code>$</code> sigil 声明的变量赋值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$just-a-number</span> <span class="o">=</span> <span class="mi">333</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$just-a-number</span><span class="o">.</span><span class="nb">VAR</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># OUTPUT: «Scalar␤» </span>
</span></span></code></pre></div><p>任何复杂数据结构都可以通过使用 <a href="https://docs.raku.org/type/Any#index-entry-%2524_%28item_contextualizer%29"><code>$</code></a> 在项上下文中<em>标量化</em>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="nv">$</span><span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">[</span><span class="mi">3</span><span class="o">].</span><span class="nb">VAR</span><span class="o">.^</span><span class="nb">name</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># OUTPUT: «Scalar␤» </span>
</span></span></code></pre></div><p>但是，这意味着它将在它们的上下文中被视为标量。你仍然可以访问其内部结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="nv">$</span><span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">[</span><span class="mi">3</span><span class="o">][</span><span class="mi">0</span><span class="o">].</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># OUTPUT: «4␤» </span>
</span></span></code></pre></div><p>有一个有趣的副作用，或者可能是故意的特性，是标量化保留了复杂结构的同一性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="o">^</span><span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="nb">say</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">WHICH</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1"># OUTPUT: «Array|93947995146096␤Array|93947995700032␤» </span>
</span></span></code></pre></div><p>每次 <code>(1, 1)</code> 被分配时，创建的变量在 <code>===</code> 上的意义上是不同的; 如它所示，打印了内部指针所表示的不同值。然而</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="o">^</span><span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">my</span> <span class="nv">$list</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nb">say</span> <span class="nv">$list</span><span class="o">.</span><span class="nb">WHICH</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1"># OUTPUT: «List|94674814008432␤List|94674814008432␤» </span>
</span></span></code></pre></div><p>在这种情况下，<code>$list</code> 使用的是 Scalar sigil，因此将是一个 <code>Scalar</code>。任何具有相同值的标量都将完全相同，如打印指针时所显示的那样。</p>
<h1 id="复杂数据结构httpsdocsrakuorglanguagestructures___top"><a href="https://docs.raku.org/language/structures#___top">复杂数据结构</a></h1>
<p>根据你如何访问其第一级元素, 复杂的数据结构分为两大类: <a href="https://docs.raku.org/type/Positional">Positional</a>, 或类列表结构 <a href="https://docs.raku.org/type/Associative">Associative</a>, 或类键值对儿结构。 通常, 复杂数据结构, 包括对象, 会是两者的组合, 使对象属性变为键值对儿。而所有的对象都是 <a href="https://docs.raku.org/type/Mu">Mu</a> 的子类, 通常复杂对象是 <a href="https://docs.raku.org/type/Any">Any</a> 子类的实例。 虽然理论上可以在不这样做的情况下混合使用 “Positional” 或 “Associative”，但是大多数适用于复杂数据结构的方法都是在 “Any” 中实现的。</p>
<p>操纵这些复杂的数据结构是一项挑战，但 Raku 提供了一些可用于它们身上的函数：<a href="https://docs.raku.org/routine/deepmap"><code>deepmap</code></a> 和 <a href="https://docs.raku.org/routine/duckmap"><code>duckmap</code></a>。而前者会按顺序切换每个元素，无论块传递的是什么。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]],[[</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">]]]].</span><span class="nb">deepmap</span><span class="p">(</span> <span class="o">*.</span><span class="nb">elems</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «[[1 1 [1 1]] [1 1 [1 1]]]␤» </span>
</span></span></code></pre></div><p>这返回 <code>1</code> 因为它进入更深层次并将 <code>elems</code> 应用于元素，<code>deepmap</code> 可以执行更复杂的操作:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]],</span> <span class="o">[[</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">]]]].</span><span class="nb">duckmap</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="k">-&gt;</span> <span class="nv">$array</span> <span class="k">where</span> <span class="o">.</span><span class="nb">elems</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span> <span class="nv">$array</span><span class="o">.</span><span class="nb">elems</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «[[1 2 2] [5 6 2]]␤» </span>
</span></span></code></pre></div><p>在这种情况下，它深入到结构中，但如果它不满足块  (<code>1, 2</code>) 中的条件则返回元素本身，如果它满足则返回数组的元素数(每个子数组末尾的两个 <code>2</code> )。</p>
<p>由于 <code>deepmap</code> 和 <code>duckmap</code> 是 <code>Any</code> 方法，它们也适用于关联数组：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%</span><span class="p">(</span> <span class="s">first</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">],</span> <span class="s">second</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="p">)</span><span class="o">.</span><span class="nb">deepmap</span><span class="p">(</span> <span class="o">*.</span><span class="nb">elems</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «{first =&gt; [1 1], second =&gt; [1 1]}␤» </span>
</span></span></code></pre></div><p>仅在这种情况下，它们将应用于作为值的每个列表或数组，而仅保留键。</p>
<p><code>Positional</code> 和 <code>Associative</code> 可以相互转换。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%</span><span class="p">(</span> <span class="s">first</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">],</span> <span class="s">second</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="p">)</span><span class="o">.</span><span class="nb">list</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «second =&gt; [3 4]␤» </span>
</span></span></code></pre></div><p>但是，在这种情况下，对于 Rakudo &gt;= 2018.05，它每次运行时都会返回不同的值。哈希将被转换为键值对的列表，但保证它是无序的。你也可以从相反的方向进行操作，只要该列表具有偶数个元素(奇数将导致错误)：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d</span><span class="p">&gt;</span><span class="o">.</span><span class="kt">Hash</span> <span class="c1"># OUTPUT: «{a =&gt; b, c =&gt; d}␤» </span>
</span></span></code></pre></div><p>但是</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d</span><span class="p">&gt;</span><span class="o">.</span><span class="kt">Hash</span><span class="o">.</span><span class="nb">kv</span> <span class="c1"># OUTPUT: «(c d a b)␤» </span>
</span></span></code></pre></div><p>每次运行时都会获得不同的值; <a href="https://docs.raku.org/type/Pair#method_kv"><code>kv</code></a> 把每个 <code>Pair</code> 转换成列表。</p>
<p>复杂数据结构通常还是 <a href="https://docs.raku.org/type/Iterable">Iterable</a> 的。 从中生成 <a href="https://docs.raku.org/routine/iterator">iterator</a> 将允许程序逐个访问结构的第一级：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="p">&#39;</span><span class="s1">א</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">ס</span><span class="p">&#39;;</span> <span class="c1"># OUTPUT: «א␤ב␤ג␤ד␤ה␤ו␤ז␤ח␤ט␤י␤ך␤כ␤ל␤ם␤מ␤ן␤נ␤ס␤» </span>
</span></span></code></pre></div><p><code>'א'..'ס'</code> 是一个 <a href="https://docs.raku.org/type/Range">Range</a>, 一个复杂数据结构,  把 <code>for</code> 放在它前面会迭代直到列表元素耗尽。你可以通过重写 <a href="https://docs.raku.org/routine/iterator">iterator</a> 方法(来自角色 <code>Iterable</code>)以在你的复杂数据结构上使用 <code>for</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">SortedArray</span> <span class="k">is</span> <span class="kt">Array</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">method</span> <span class="nb">iterator</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">self</span><span class="o">.</span><span class="nb">sort</span><span class="o">.</span><span class="nb">iterator</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@thing</span> <span class="o">:=</span> <span class="n">SortedArray</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@thing</span><span class="p">;</span> <span class="c1"># OUTPUT: «1␤2␤3␤4␤» </span>
</span></span></code></pre></div><p><code>for</code> 直接调用 <code>@thing</code> 上的 <code>iterator</code> 方法, 使其按顺序返回数组元素。更多信息请参阅 <a href="https://docs.raku.org/language/iterating">专门讨论迭代的页面</a>.</p>
<h1 id="函数式结构httpsdocsrakuorglanguagestructures___top"><a href="https://docs.raku.org/language/structures#___top">函数式结构</a></h1>
<p>Raku 是一种函数式语言，因此，函数是一等<em>数据</em>结构。函数遵循 <a href="https://docs.raku.org/type/Callable">Callable</a> 角色，这是基础角色四重奏中的第 4 个元素。  <a href="https://docs.raku.org/type/Callable">Callable</a>  与 <code>&amp;</code> sigil 一起使用，尽管在大多数情况下，为了简单起见，它被省略了; 在 <code>Callables</code> 的情况下，总是允许消除这种 sigil。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">&amp;a-func</span><span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="nv">$^þ</span><span class="p">))</span><span class="o">.</span><span class="kt">Seq</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">a-func</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">,</span> <span class="nf">a-func</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span> <span class="c1"># OUTPUT: «(0 1 2)(0 1 2 3 4 5 6)␤» </span>
</span></span></code></pre></div><p><a href="https://docs.raku.org/type/Block">Block</a> 是最简单的可调用结构，因为 <code>Callable</code> 无法实例化。在这种情况下，我们实现了一个记录事件的块并可以检索它们:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$logger</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="nv">$event</span><span class="o">,</span> <span class="nv">$key</span> <span class="o">=</span> <span class="kt">Nil</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">state</span> <span class="nv">%store</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span> <span class="nv">$event</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">%store</span><span class="p">{</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="nb">now</span> <span class="p">)</span> <span class="p">}</span> <span class="o">=</span> <span class="nv">$event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">%store</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span> <span class="p">/</span><span class="nv">$key</span><span class="p">/</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">$logger</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">Stuff</span><span class="p">&#34;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$logger</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">More stuff</span><span class="p">&#34;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$logger</span><span class="p">(</span> <span class="kt">Nil</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">2018-05-28</span><span class="p">&#34;</span> <span class="p">);</span> <span class="c1"># OUTPUT: «(Stuff More stuff)␤» </span>
</span></span></code></pre></div><p><code>Block</code> 有一个 <a href="https://docs.raku.org/type/Signature">Signature</a>，在这种情况下有两个参数，第一个是要记录的事件，第二个是要检索的事件的键。它们将以独立的方式使用，但其目的是展示<a href="https://docs.raku.org/syntax/state">状态变量</a> 的使用，该状态变量从每次调用到下一次调用时都会被保留。此状态变量封装在块中，除非使用块提供的简单 API，否则无法从外部访问：使用第二个参数调用块。前两个调用记录两个事件，示例底部的第三个调用使用第二种类型的调用来检索存储的值。 <code>Block</code> 可以被克隆：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$clogger</span> <span class="o">=</span> <span class="nv">$logger</span><span class="o">.</span><span class="nb">clone</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$clogger</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">Clone stuff</span><span class="p">&#34;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$clogger</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">More clone stuff</span><span class="p">&#34;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$clogger</span><span class="p">(</span> <span class="kt">Nil</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">2018-05-28</span><span class="p">&#34;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «(Clone stuff More clone stuff)␤» </span>
</span></span></code></pre></div><p>克隆将重置状态变量; 代替克隆，我们可以创建改变 API 的 <em>façades</em>。例如，无需使用 <code>Nil</code> 作为第一个参数来检索特定日期的日志：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$gets-logs</span> <span class="o">=</span> <span class="nv">$logger</span><span class="o">.</span><span class="nb">assuming</span><span class="p">(</span> <span class="kt">Nil</span><span class="o">,</span> <span class="o">*</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$logger</span><span class="p">(</span> <span class="nv">%</span><span class="p">(</span><span class="s">changing</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Logs</span><span class="p">&#34;)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$gets-logs</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">2018-05-28</span><span class="p">&#34;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «({changing =&gt; Logs} Stuff More stuff)␤» </span>
</span></span></code></pre></div><p><a href="https://docs.raku.org/type/Block#%28Code%29_method_assuming"><code>assuming</code></a> 包裹着一个块调用，给我们需要的参数赋值（在本例中为<code>Nil</code>）， 将参数传递给我们使用 <code>*</code> 表示的其他参数。 实际上，这对应于自然语言语句 “我们正在调用<code>$logger</code> <em>假设</em>第一个参数是 <code>Nil</code>”。 我们可以稍微改变这两个块的外观，以澄清它们实际上是在同一个块上运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$Logger</span> <span class="o">=</span> <span class="nv">$logger</span><span class="o">.</span><span class="nb">clone</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$Logger::logs</span> <span class="o">=</span> <span class="nv">$Logger</span><span class="o">.</span><span class="nb">assuming</span><span class="p">(</span> <span class="o">*,</span> <span class="kt">Nil</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$Logger::get</span> <span class="o">=</span> <span class="nv">$Logger</span><span class="o">.</span><span class="nb">assuming</span><span class="p">(</span> <span class="kt">Nil</span><span class="o">,</span> <span class="o">*</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$Logger::logs</span><span class="p">(</span> <span class="p">&lt;</span><span class="s">an array</span><span class="p">&gt;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$Logger::logs</span><span class="p">(</span> <span class="nv">%</span><span class="p">(</span><span class="s">key</span> <span class="o">=&gt;</span> <span class="mi">42</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$Logger::get</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">2018-05-28</span><span class="p">&#34;</span> <span class="p">);</span>
</span></span></code></pre></div><p>尽管 <code>::</code> 通常用于调用类方法，但它实际上是变量名称的有效部分。在这种情况下，我们通常使用它们来简单地指示 <code>$Logger::logs</code> 和 <code>$Logger::get</code> 实际上是在调用 <code>$Logger</code>，我们已经大写使用了类似于类的外观。本教程的重点是，使用函数作为一等公民，以及使用状态变量，允许使用某些有趣的设计模式，例如这个。</p>
<p>作为这样的一等数据结构，可以在其他类型的数据可以使用的任何地方使用 callable。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@regex-check</span> <span class="o">=</span> <span class="p">(</span> <span class="p">/&lt;</span><span class="nf">alnum</span><span class="p">&gt;/</span><span class="o">,</span> <span class="p">/&lt;</span><span class="nf">alpha</span><span class="p">&gt;/</span><span class="o">,</span> <span class="p">/&lt;</span><span class="nf">punct</span><span class="p">&gt;/</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@regex-check</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">33af</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="o">*</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «(｢3｣␤ alnum =&gt; ｢3｣ ｢a｣␤ alpha =&gt; ｢a｣ Nil)␤» </span>
</span></span></code></pre></div><p>正则表达式实际上是一种 callable 类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">/</span><span class="k">regex</span><span class="o">/.</span><span class="k">does</span><span class="p">(</span> <span class="kt">Callable</span> <span class="p">);</span> <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>在上面的例子中，我们调用存储在数组中的正则表达式，并将它们应用于字符串字面值。</p>
<p>使用<a href="https://docs.raku.org/language/operators#infix_%25E2%2588%2598">函数组合运算符∘</a>组成 Callables：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$typer</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="nv">$thing</span> <span class="p">{</span> <span class="nv">$thing</span><span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> → </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$thing</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$Logger::withtype</span> <span class="o">=</span> <span class="nv">$Logger::logs</span> <span class="o">∘</span> <span class="nv">$typer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$Logger::withtype</span><span class="p">(</span> <span class="kt">Pair</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">left</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">right</span><span class="p">&#39;</span> <span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$Logger::withtype</span><span class="p">(</span> ¾ <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$Logger::get</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">2018-05-28</span><span class="p">&#34;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «(Pair → left right Rat → 0.75)␤» </span>
</span></span></code></pre></div><p>我们使用上面定义的函数组合 <code>$Logger::logs</code> 和 <code>$typer</code>，获得一个记录其类型前面的对象的函数，例如，这对于过滤非常有用。 <code>$Logger::withtype</code> 实际上是一个复杂的数据结构，由两个以串行方式应用的函数组成，但每一个组合的 callables 都可以保持状态，从而创建复杂的变换 callables，其设计模式是：类似于面向对象领域中的对象组合。在每种特定情况下，你都必须选择最适合你的问题的编程风格。</p>
<h1 id="defining-and-constraining-data-structureshttpsdocsrakuorglanguagestructures___top"><a href="https://docs.raku.org/language/structures#___top">Defining and constraining data structures</a></h1>
<p>Raku 有不同的方法来定义数据结构，但也有许多方法来约束它们，以便你为每个问题域创建最合适的数据结构。例如，<a href="https://docs.raku.org/routine/but"><code>but</code></a> 将角色或值混合到值或变量中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%not-scalar</span> <span class="o">:=</span> <span class="nv">%</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="k">but</span> <span class="kt">Associative</span><span class="o">[</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%not-scalar</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># OUTPUT: «Hash+{Associative[Int, Int]}␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%not-scalar</span><span class="o">.</span><span class="k">of</span><span class="p">;</span>    <span class="c1"># OUTPUT: «Associative[Int, Int]␤» </span>
</span></span><span class="line"><span class="cl"><span class="nv">%not-scalar</span><span class="p">{</span><span class="mi">3</span><span class="p">}</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">%not-scalar</span><span class="p">&lt;</span><span class="s">thing</span><span class="p">&gt;</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%not-scalar</span><span class="p">;</span>       <span class="c1"># OUTPUT: «{2 =&gt; 3, 3 =&gt; 4, thing =&gt; 3}␤» </span>
</span></span></code></pre></div><p>在这种情况下，<code>but</code> 混合在 <code>Associative [Int，Int]</code> 角色中; 请注意我们正在使用绑定，以便变量的类型是所定义的，而不是 <code>%</code> sigil 强加的类型; 这个混合角色显示在用花括号包围的 <code>name</code> 中。 它的真实意义是什么？ 该角色包括两个方法，<code>of</code> 和 <code>keyof</code>; 通过混合角色，将调用新的 <code>of</code>（旧的 <code>of</code> 将返回 <code>Mu</code>，这是 Hashes 的默认值类型）。 然而，就是这样。 它并没有真正改变变量的类型，因为你可以看到，因为我们在接下来的几个语句中使用了任何类型的键和值。</p>
<p>但是，我们可以使用这种类型的 mixin 为变量提供新功能：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">Lastable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">method</span> <span class="nb">last</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">self</span><span class="o">.</span><span class="nb">sort</span><span class="o">.</span><span class="nb">reverse</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%hash-plus</span> <span class="o">:=</span> <span class="nv">%</span><span class="p">(</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="mi">33</span><span class="o">,</span> <span class="mi">4</span> <span class="o">=&gt;</span> <span class="mi">44</span><span class="p">)</span> <span class="k">but</span> <span class="nc">Lastable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%hash-plus</span><span class="o">.</span><span class="nb">sort</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span> <span class="c1"># OUTPUT: «3 =&gt; 33␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%hash-plus</span><span class="o">.</span><span class="nb">last</span><span class="p">;</span>    <span class="c1"># OUTPUT: «4 =&gt; 44␤» </span>
</span></span></code></pre></div><p>在 <code>Lastable</code> 中，我们使用通用的 <code>self</code> 变量来指代这个特定角色混合的任何对象; 在这种情况下，它将包含与其混合的哈希; 在其他情况下，它将包含其他内容（并可能以其他方式工作）。这个角色将为它混合的任何变量提供 <code>last</code> 方法，为 <em>常规</em>变量提供新的，可附加的功能。甚至可以<a href="https://docs.raku.org/language/objects#Mixins_of_roles">使用 <code>does</code> 关键字将角色添加到现有变量</a>。</p>
<p><a href="https://docs.raku.org/language/typesystem#subset">Subsets</a> 也可用于约束变量可能包含的值; 他们是 Raku 尝试<a href="https://en.wikipedia.org/wiki/Gradual_typing">渐进类型</a>; 它不是一个完整的尝试，因为子集在严格意义上不是真正的类型，但它们允许运行时类型检查。它为常规类型添加了类型检查功能，因此它有助于创建更丰富的类型系统，允许类似以下代码中显示的内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">subset</span> <span class="nc">OneOver</span> <span class="k">where</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nv">$_</span><span class="p">)</span><span class="o">.</span><span class="kt">Int</span> <span class="o">==</span> <span class="mi">1</span><span class="o">/</span><span class="nv">$_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">OneOver</span> <span class="nv">$one-fraction</span> <span class="o">=</span> ⅓<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$one-fraction</span><span class="p">;</span> <span class="c1"># OUTPUT: «0.333333␤» </span>
</span></span></code></pre></div><p>另一方面，<code>my OneOver $ = ⅔;</code> 会导致类型检查错误。子集可以使用 <code>Whatever</code>，即 <code>*</code> 来引用参数; 但是每次将它用于不同的参数时都会实例化，所以如果我们在定义中使用它两次，我们就会得到一个错误。在这种情况下，我们使用主题单变量 <code>$_</code> 来检查实例化。子签名可以在<a href="https://docs.raku.org/language/typesystem#subset">签名</a> 中直接完成，无需声明。</p>
<h1 id="无限结构和惰性httpsdocsrakuorglanguagestructures___top"><a href="https://docs.raku.org/language/structures#___top">无限结构和惰性</a></h1>
<p>可以假设数据结构中包含的所有数据实际上都是<em>那里</em>。情况不一定如此：在许多情况下，出于效率原因或仅仅因为不可能，数据结构中包含的元素只有在实际需要时才会跳存。这种按需对项的计算称为 <a href="https://docs.raku.org/language/glossary#Reify">reification</a>.。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># A list containing infinite number of un-reified Fibonacci numbers: </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@fibonacci</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*</span> <span class="o">+</span> <span class="o">*</span> <span class="o">…</span> <span class="no">∞</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># We reify 10 of them, looking up the first 10 of them with array index: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@fibonacci</span><span class="o">[^</span><span class="mi">10</span><span class="o">]</span><span class="p">;</span> <span class="c1"># OUTPUT: «(1 1 2 3 5 8 13 21 34 55)␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># We reify 5 more: 10 we already reified on previous line, and we need to </span>
</span></span><span class="line"><span class="cl"><span class="c1"># reify 5 more to get the 15th element at index 14. Even though we need only </span>
</span></span><span class="line"><span class="cl"><span class="c1"># the 15th element, the original Seq still has to reify all previous elements: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@fibonacci</span><span class="o">[</span><span class="mi">14</span><span class="o">]</span><span class="p">;</span> <span class="c1"># OUTPUT: «987␤» </span>
</span></span></code></pre></div><p>上面我们具体化了用<a href="https://docs.raku.org/language/operators#index-entry-%25E2%2580%25A6_operators">序列运算符</a>创建了的 <a href="https://docs.raku.org/type/Seq">Seq</a>，但其他数据结构也使用这个概念。例如，未具体化的 <a href="https://docs.raku.org/type/Range">Range</a> 只是两个终点。在某些语言中，计算大范围的总和是一个漫长而耗费内存的过程，但 Raku 会立即计算出来:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">sum</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">9_999_999_999_999</span><span class="p">;</span> <span class="c1"># OUTPUT: «49999999999995000000000000␤» </span>
</span></span></code></pre></div><p>为什么？ 因为<em>不用</em>具体化范围总就可以计算总和; 也就是说，不用弄清楚它包含的所有元素。这就是此功能存在的原因。你甚至可以使用 <a href="https://docs.raku.org/syntax/gather%20take"><code>gather</code> and <code>take</code></a> 按需具体化：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$seq</span> <span class="o">=</span> <span class="k">gather</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">About to make 1st element</span><span class="p">&#34;;</span> <span class="nb">take</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">About to make 2nd element</span><span class="p">&#34;;</span> <span class="nb">take</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Let&#39;s reify an element!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$seq</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Let&#39;s reify more!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$seq</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Both are reified now!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$seq</span><span class="o">[^</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Let&#39;s reify an element! </span>
</span></span><span class="line"><span class="cl"><span class="c1"># About to make 1st element </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Let&#39;s reify more! </span>
</span></span><span class="line"><span class="cl"><span class="c1"># About to make 2nd element </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Both are reified now! </span>
</span></span><span class="line"><span class="cl"><span class="c1"># (1 2) </span>
</span></span></code></pre></div><p>在上面的输出之后，你可以看到 <code>gather</code> 里面的 <code>print</code> 语句只有当我们在查找元素时确定各个元素时才会执行。另请注意，这些元素只被修改了一次。当我们在示例的最后一行再次打印相同的元素时，就不再打印 <code>gather</code> 内的消息。这是因为该构造使用了来自 <a href="https://docs.raku.org/type/Seq">Seq</a> 缓存的已经确定的元素。</p>
<p>请注意，上面我们将 <code>gather</code> 赋值给 <a href="https://docs.raku.org/type/Scalar">Scalar</a> 容器( <code>$</code> sigil)，而不是 <a href="https://docs.raku.org/type/Positional">Positional</a> (<code>@</code> sigil)。原因是 <code>@</code>-sigiled 变量<em>主要是eager</em>。这意味着他们<em>大部分时间</em>立即<em>明确分配给他们的东西</em>。他们唯一没有这样做的时候知道这些项是 <a href="https://docs.raku.org/routine/is-lazy"><code>is-lazy</code></a>，就像我们用无穷大生成序列作为终点一样。如果我们将 <code>gather</code> 赋值给 <code>@</code>-variable，那里面的 <code>say</code> 语句就会被立即打印出来。</p>
<p>完全具体化列表的另一种方法是在其上调用 <a href="https://docs.raku.org/routine/elems"><code>.elems</code></a>。这就是为什么检查列表是否包含任何项最好使用 <code>.Bool</code> 方法的原因(或者只使用 <code>if @array { … }</code>)，因为你不需要明确<em>所有</em>元素以找出它们中的任何一个。</p>
<p>有些时候你<em>确实</em>需要在做某事之前完全具体化列表。例如，<a href="https://docs.raku.org/type/IO::Handle#method_lines"><code>IO::Handle.lines</code></a> 返回 <a href="https://docs.raku.org/type/Seq">Seq</a>。以下代码包含错误; 记住具体化，试着发现它：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">/tmp/bar</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">open</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$lines</span> <span class="o">=</span> <span class="nv">$fh</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">close</span> <span class="nv">$fh</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$lines</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
</span></span></code></pre></div><p>我们打开 <a href="https://docs.raku.org/type/IO::Handle">filehandle</a>，然后分配 <a href="https://docs.raku.org/type/IO::Handle#method_lines"><code>.lines</code></a>  给  <a href="https://docs.raku.org/type/Scalar">Scalar</a> 变量，因此返回的 <a href="https://docs.raku.org/type/Seq">Seq</a> 不会立刻被具体化。 然后我们 <a href="https://docs.raku.org/routine/close"><code>close</code></a> 文件句柄，并尝试从 <code>$lines</code> 打印一个元素。</p>
<p>代码中的错误是在我们在最后一行具体化 <code>$lines</code> <a href="https://docs.raku.org/type/Seq">Seq</a>  时，我们<em>已经关闭</em>文件句柄。 当 <code>Seq</code> 的 iterator 试图生成我们请求的项时，会导致尝试从关闭的句柄中读取的错误。 因此，要修复错误，我们可以在关闭句柄之前分配给 <code>@</code>-sigiled 变量或在 <code>$lines</code> 上调用 <a href="https://docs.raku.org/routine/elems"><code>.elems</code></a>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">/tmp/bar</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">open</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@lines</span> <span class="o">=</span> <span class="nv">$fh</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">close</span> <span class="nv">$fh</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@lines</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span> <span class="c1"># no problem! </span>
</span></span></code></pre></div><p>我们也可以使用带有具体化副作用的任何函数，如上面提到的 <code>.elems</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">/tmp/bar</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">open</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$lines</span> <span class="o">=</span> <span class="nv">$fh</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Read </span><span class="nv">$lines</span><span class="o">.</span><span class="nf">elems</span><span class="p">()</span><span class="s2"> lines</span><span class="p">&#34;;</span> <span class="c1"># reifying before closing handle </span>
</span></span><span class="line"><span class="cl"><span class="nb">close</span> <span class="nv">$fh</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$lines</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span> <span class="c1"># no problem! </span>
</span></span></code></pre></div><p>使用 <a href="https://docs.raku.org/routine/eager">eager</a> 也将具体化整个序列：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">/tmp/bar</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">open</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$lines</span> <span class="o">=</span> <span class="nb">eager</span> <span class="nv">$fh</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span> <span class="c1"># Uses eager for reification. </span>
</span></span><span class="line"><span class="cl"><span class="nb">close</span> <span class="nv">$fh</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$lines</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
</span></span></code></pre></div><h1 id="内省httpsdocsrakuorglanguagestructures___top"><a href="https://docs.raku.org/language/structures#___top">内省</a></h1>
<p>允许 <a href="https://en.wikipedia.org/wiki/Type_introspection">内省</a>(如Raku)的语言具有附加到类型系统的功能，允许开发人员访问容器和值元数据。该元数据可以在程序中使用，以根据它们的值执行不同的动作。从名称中可以明显看出，元数据是通过元类从值或容器中提取的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$any-object</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">random object</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$metadata</span> <span class="o">=</span> <span class="nv">$any-object</span><span class="o">.</span><span class="nb">HOW</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$metadata</span><span class="o">.^</span><span class="nb">mro</span><span class="p">;</span>                   <span class="c1"># OUTPUT: «((ClassHOW) (Any) (Mu))␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$metadata</span><span class="o">.</span><span class="nb">can</span><span class="p">(</span> <span class="nv">$metadata</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">uc</span><span class="p">&#34;</span> <span class="p">);</span> <span class="c1"># OUTPUT: «(uc uc)␤» </span>
</span></span></code></pre></div><p>使用第一个 <code>say</code>，我们展示了元模型类的类层次结构，在本例中是 <a href="https://docs.raku.org/type/Metamodel::ClassHOW">Metamodel::ClassHOW</a>。它直接继承自 <code>Any</code>，这意味着可以使用任何方法; 它还混合了几个角色，可以为您提供有关类结构和功能的信息。但是那个特定类的方法之一是 <a href="https://docs.raku.org/type/Metamodel::ClassHOW#method_can"><code>can</code></a>，我们可以用它来查找对象是否可以使用 <code>uc</code>(大写)方法，它显然可以。但是，在某些其他情况下，当角色直接被混合到变量中时，它可能不那么明显。例如，在上面定义的的 <a href="https://docs.raku.org/language/structures#Defining_and_constraining_data_structures"><code>%hash-plus</code></a> 情况下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%hash-plus</span><span class="o">.^</span><span class="nb">can</span><span class="p">(&#34;</span><span class="s2">last</span><span class="p">&#34;);</span> <span class="c1"># OUTPUT: «(last)␤» </span>
</span></span></code></pre></div><p>在这种情况下，我们使用 <code>HOW.method</code> 的<em>语法塘</em> <code>^method</code> 来检查你的数据结构是否响应该方法; 输出显示匹配方法的名称，证明我们可以使用它。</p>
<p>另请参见<a href="https://rakuadvent.wordpress.com/2015/12/19/day-19-introspection/">关于类内省的文章</a>，了解如何访问类属性和方法，并使用它来为该类生成测试数据;这篇<a href="https://rakuadvent.wordpress.com/2010/12/22/day-22-the-meta-object-protocol/">Advent Calendar 文章详细描述了元对象协议</a> 。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[控制流]]></title>
            <link href="http://localhost:1313/rakulang/39.control-flow/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/38.contexts-and-contextualizers/?utm_source=atom_feed" rel="related" type="text/html" title="上下文和上下文器" />
                <link href="http://localhost:1313/rakulang/37.containers/?utm_source=atom_feed" rel="related" type="text/html" title="容器" />
                <link href="http://localhost:1313/rakulang/36.traps-to-avoid/?utm_source=atom_feed" rel="related" type="text/html" title="要避免的陷阱" />
                <link href="http://localhost:1313/rakulang/35.testing/?utm_source=atom_feed" rel="related" type="text/html" title="测试" />
                <link href="http://localhost:1313/rakulang/34.terms/?utm_source=atom_feed" rel="related" type="text/html" title="项" />
            
                <id>http://localhost:1313/rakulang/39.control-flow/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-14T21:13:31+08:00</published>
            <updated>2018-11-14T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="语句">语句</h1>
<p>Raku 程序由一个或多个语句组成。简单语句由分号分隔。以下程序将打印 “Hello”，然后在下一行打印“World”。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">World</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>在语句中出现空白的大多数地方，且在分号之前，语句可能会分成许多行。此外，多个语句可能出现在同一行。这会很尴尬，但上面的内容也可以写成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;;</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">World</span><span class="p">&#34;;</span>
</span></span></code></pre></div><h1 id="块儿httpsdocsrakuorglanguagecontrol___top"><a href="https://docs.raku.org/language/control#___top">块儿</a></h1>
<p>与许多语言一样，Raku 使用 <code>{</code> 和 <code>}</code> 将 <code>blocks</code>括起来以将多个语句转换为单个语句。可以省略块中最后一个语句和闭合 <code>}</code>之间的分号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello</span><span class="p">&#34;;</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">World</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span></code></pre></div><p>When a block stands alone as a statement, it will be entered immediately after the previous statement finishes, and the statements inside it will be executed.</p>
<p>当块单独作为一个语句存在时，它将在前一个语句完成后立即进入，并且其中的语句将被执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="p">;</span>                    <span class="c1"># OUTPUT: «1» </span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="nb">say</span> <span class="mi">2</span><span class="p">;</span> <span class="nb">say</span> <span class="mi">3</span> <span class="p">};</span>         <span class="c1"># OUTPUT: «23» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">4</span><span class="p">;</span>                    <span class="c1"># OUTPUT: «4» </span>
</span></span></code></pre></div><p>除非它作为一个语句单独存在，否则一个块只会创建一个闭包。内部的语句不会立即执行。闭包是另一个主题，如何使用它们在<a href="https://docs.raku.org/language/functions#Blocks_and_lambdas">别处</a>有解释。现在，了解块何时运行以及何时不运行是非常重要的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">We get here</span><span class="p">&#34;;</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">then here.</span><span class="p">&#34;</span> <span class="p">};</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">not here</span><span class="p">&#34;;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="ow">or</span> <span class="nb">die</span><span class="p">;</span>
</span></span></code></pre></div><p>在上面的示例中，在运行第一个语句之后，第一个块独立作为第二个语句，因此我们运行里面的语句。第二个块不是单独作为一个语句，所以相反，它创建了一个 <code>Block</code> 类型的对象，但不运行它。对象实例通常被认为是 true，因此代码不会死掉，即使该块被计算为 0，它是否被执行。该示例没有说明如何处理<code>Block</code>对象，因此它会被丢弃。</p>
<p>下面介绍的大多数流控制结构只是告诉 Raku 何时，如何以及多少次进入像第二个块那样的块。</p>
<p>在我们深入这些之前，关于语法的一个重要的注意事项：如果在通常放置分号的结束大括号之后的行上没有任何内容（或者只有注释），则不需要分号：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># All three of these lines can appear as a group, as is, in a program </span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>                <span class="c1"># OUTPUT: «42» </span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="mi">43</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>                <span class="c1"># OUTPUT: «43» </span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span> <span class="p">};</span> <span class="p">{</span> <span class="mi">43</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>    <span class="c1"># OUTPUT: «42 43» </span>
</span></span></code></pre></div><p>&hellip;但是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>  <span class="p">{</span> <span class="mi">43</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>    <span class="c1"># Syntax error </span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="p">}</span> <span class="p">{</span> <span class="mi">43</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>    <span class="c1"># Also a syntax error, of course </span>
</span></span></code></pre></div><p>因此，在换行编辑器中退格时要小心：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span> <span class="p">&#34;</span><span class="s2">Without semicolons line-wrapping can be a bit treacherous.</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span> \
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="mi">43</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span> <span class="c1"># Syntax error </span>
</span></span></code></pre></div><p>无论如何，在大多数语言中你必须注意这一点，以防止代码意外被注释掉。为清楚起见，下面的许多示例可能包含不必要的分号。</p>
<p>对于任何顶级表达式，类主体的行为类似于简单的块;  这同样适用于角色和其他包，如语法（实际上是类）或模块。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I live</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">I will never live!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>                              │
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: Fails and writes «I live␤II will never live!␤I</span>
</span></span></code></pre></div><p>该块首先运行第一个语句，然后<code>die</code>打印第二个语句。<code>$c</code> 永远不会得到值。</p>
<h1 id="phasers">Phasers</h1>
<p>块可能有<em>phasers</em>：即将他们的执行分解成特别阶段运行阶段的特殊标记块。有关详细信息，请参阅页面<a href="https://docs.raku.org/language/phasers">phasers</a>。</p>
<h1 id="do">do</h1>
<p>块不能是独立的语句, 运行这样一个块的最简单方法是在它前面写上一个 <code>do</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># This dies half of the time </span>
</span></span><span class="line"><span class="cl"><span class="nb">do</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Heads I win, tails I die.</span><span class="p">&#34;;</span> <span class="kt">Bool</span><span class="o">.</span><span class="nb">pick</span> <span class="p">}</span> <span class="ow">or</span> <span class="nb">die</span><span class="p">;</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I win.</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>请注意，您需要在 <code>do</code> 和块之间留一个空格。</p>
<p>整个 <code>do {...}</code> 计算为块儿的最终值。当需要该值时，将运行该块以计算表达式的剩余部分。所以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="kt">False</span> <span class="ow">and</span> <span class="nb">do</span> <span class="p">{</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span> <span class="p">};</span>
</span></span></code></pre></div><p>&hellip;不会打印 42。但是，每次计算包含它的表达式时，只会计算一次：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># This says &#34;(..1 ..2 ..3)&#34; not &#34;(..1 ...2 ....3)&#34; </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$f</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">.</span><span class="p">&#34;;</span> <span class="nb">say</span> <span class="nb">do</span> <span class="p">{</span> <span class="nv">$f</span> <span class="o">~=</span> <span class="p">&#34;</span><span class="s2">.</span><span class="p">&#34;</span> <span class="p">}</span> <span class="ow">X</span><span class="o">~</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
</span></span></code></pre></div><p>换句话说，它遵循与其他所有东西相同的具体规则。</p>
<p>从技术上讲，<code>do</code> 是一个只运行一次迭代的循环。</p>
<p><code>do</code> 也可以用在一个裸语句上（没有花括号）但这主要是为了避免需要用圆括号扩住语句的语法，如果它是表达式中的最后一个：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">3</span><span class="o">,</span> <span class="nb">do</span> <span class="k">if</span> <span class="mi">1</span> <span class="p">{</span> <span class="mi">2</span> <span class="p">}</span>  <span class="p">;</span> <span class="c1"># OUTPUT: «(3, 2)» </span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span><span class="o">,</span>   <span class="p">(</span><span class="k">if</span> <span class="mi">1</span> <span class="p">{</span> <span class="mi">2</span> <span class="p">})</span> <span class="p">;</span> <span class="c1"># OUTPUT: «(3, 2)» </span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span><span class="o">,</span>    <span class="k">if</span> <span class="mi">1</span> <span class="p">{</span> <span class="mi">2</span> <span class="p">}</span>  <span class="p">;</span> <span class="c1"># Syntax error </span>
</span></span></code></pre></div><h1 id="start">start</h1>
<p><strong>异步</strong>运行块的最简单方法是在它之前写上一个 <code>start</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">start</span> <span class="p">{</span> <span class="nb">sleep</span> <span class="mi">1</span><span class="p">;</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">done</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">working</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># working, done </span>
</span></span></code></pre></div><p>请注意，您需要在 <code>start</code> 和块儿之间留一个空格。在上面的示例中，<code>start</code> 块处于 sink 上下文中，因为它未赋值给变量。从版本 6.d 开始，这种块儿附加了一个异常处理程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">start</span> <span class="p">{</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">We&#39;re dead</span><span class="p">&#34;;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">working</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">sleep</span> <span class="mi">10</span><span class="p">;</span>
</span></span></code></pre></div><p>此代码将在版本 6.d 中打印 <code>Unhandled exception in code scheduled on thread 4 We're dead</code>，而在版本 6.c 中等待 10 秒后它将立即退出。</p>
<p>如果你对块儿的结果不感兴趣, <code>start {...}</code> 会立即返回一个可被安全忽略的 <code>Promise</code>。如果你对块儿的最终值<strong>感</strong>兴趣，你可以调用返回的 promise 上的 <code>.result</code> 方法。所以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$promise</span> <span class="o">=</span> <span class="k">start</span> <span class="p">{</span> <span class="nb">sleep</span> <span class="mi">10</span><span class="p">;</span> <span class="mi">42</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ... do other stuff </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The result is </span><span class="nv">$promise</span><span class="o">.</span><span class="nf">result</span><span class="p">()&#34;;</span>
</span></span></code></pre></div><p>如果块内的代码尚未完成，则 <code>.result</code> 调用将等待直到完成。</p>
<p><code>start</code> 也可用于裸语句（不带花括号）。这主要用于, 当在对象上调用子例程/方法是异步执行的唯一事情时。</p>
<h1 id="if">if</h1>
<p>要有条件地运行代码块，请使用 <code>if</code> 后跟条件。条件，表达式，将在 <code>if</code> 完成之前的语句之后立即进行计算。只有在条件被强转为 <code>Bool</code> 为真时, 才会计算附加到条件的块。与某些语言不同，条件不必用圆括号括起来，而块周围的 <code>{</code> 和 <code>}</code> 是必需的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">1</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">1 is true</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>  <span class="p">;</span> <span class="c1"># says &#34;1 is true&#34; </span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">1</span>   <span class="p">&#34;</span><span class="s2">1 is true</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span>    <span class="p">;</span> <span class="c1"># syntax error, missing block </span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">0 is true</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>  <span class="p">;</span> <span class="c1"># does not say anything, because 0 is false </span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span> <span class="ow">and</span> <span class="mi">0</span> <span class="p">{</span> <span class="mi">43</span><span class="o">.</span><span class="nb">say</span> <span class="p">};</span> <span class="c1"># says &#34;42&#34; but does not say &#34;43&#34; </span>
</span></span></code></pre></div><p>还有一种“语句修饰符”的形式的 <code>if</code>。在这种情况下，if 和 then 条件在您想要有条件地运行的代码之后。请注意，仍然始终首先计算条件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">43</span><span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span> <span class="ow">and</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1"># says &#34;42&#34; but does not say &#34;43&#34; </span>
</span></span><span class="line"><span class="cl"><span class="mi">43</span><span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span> <span class="ow">and</span> <span class="mi">1</span><span class="p">;</span>     <span class="c1"># says &#34;42&#34; and then says &#34;43&#34; </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">It is easier to read code when &#39;if&#39;s are kept on left of screen</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="kt">True</span><span class="p">;</span>                <span class="c1"># says the above, because it is true </span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="mi">43</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span> <span class="k">if</span> <span class="kt">True</span><span class="p">;</span>         <span class="c1"># says &#34;43&#34; as well </span>
</span></span></code></pre></div><p>语句修饰符形式最好谨慎使用。</p>
<p><code>if</code> 语句本身要么 <a href="https://docs.raku.org/type/Slip">slip</a>我们一个空列表，如果它不运行块，否则就会返回该块产生的值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="p">(</span><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nv">$d</span> <span class="o">+=</span> <span class="mi">42</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="p">})</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="nv">$d</span><span class="p">);</span> <span class="c1"># says &#34;(1 3 0)&#34; </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="p">(</span><span class="k">if</span> <span class="mi">1</span> <span class="p">{</span> <span class="nv">$c</span> <span class="o">+=</span> <span class="mi">42</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="p">})</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="nv">$c</span><span class="p">);</span> <span class="c1"># says &#34;(1 2 3 42)&#34; </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="p">(</span><span class="k">if</span> <span class="mi">1</span> <span class="p">{</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span> <span class="p">})</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>         <span class="c1"># does not slip, says &#34;(1 (2 2) 3)&#34; </span>
</span></span></code></pre></div><p>对于语句修饰符，是一样的，除非你有语句的值而不是块：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="p">(</span><span class="mi">42</span> <span class="k">if</span> <span class="kt">True</span><span class="p">)</span> <span class="o">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1"># says &#34;(1 42 2)&#34; </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="p">(</span><span class="mi">42</span> <span class="k">if</span> <span class="kt">False</span><span class="p">)</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1"># says &#34;(1 2)&#34; </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span>  <span class="mi">42</span> <span class="k">if</span> <span class="kt">False</span> <span class="o">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1"># says &#34;(1 42)&#34; because &#34;if False, 2&#34; is true </span>
</span></span></code></pre></div><p><code>if</code> 默认不改变主题变量（<code>$_</code>）。为了访问条件表达式生成的值，您必须更强烈地要求它：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">if</span> <span class="mi">42</span> <span class="p">{</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>                <span class="p">;</span> <span class="c1"># says &#34;1&#34; </span>
</span></span><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">if</span> <span class="mi">42</span> <span class="k">-&gt;</span> <span class="nv">$_</span> <span class="p">{</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>          <span class="p">;</span> <span class="c1"># says &#34;42&#34; </span>
</span></span><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">if</span> <span class="mi">42</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>  <span class="nv">$a</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span> <span class="p">;</span> <span class="c1"># says &#34;1&#34; then says &#34;42&#34; </span>
</span></span><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">if</span> <span class="mi">42</span>       <span class="p">{</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="nv">$^a</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span> <span class="p">;</span> <span class="c1"># says &#34;1&#34; then says &#34;42&#34; </span>
</span></span></code></pre></div><h2 id="elseelsif">else/elsif</h2>
<p>组合条件可以通过用 <code>else</code> 跟在 <code>if</code> 条件后面来产生, 以提供一个备选块，当条件表达式为假来运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">no</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">yes</span><span class="p">&#34;</span> <span class="p">}</span>   <span class="p">;</span> <span class="c1"># says &#34;yes&#34; </span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">no</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">else</span><span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">yes</span><span class="p">&#34;</span> <span class="p">}</span>    <span class="p">;</span> <span class="c1"># says &#34;yes&#34;, space is not required </span>
</span></span></code></pre></div><p><code>else</code> 不能用分号将条件语句分开，但作为一个特例，换行符是可行的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">no</span><span class="p">&#34;</span> <span class="p">};</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">yes</span><span class="p">&#34;</span> <span class="p">}</span>  <span class="p">;</span> <span class="c1"># syntax error </span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">no</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">yes</span><span class="p">&#34;</span> <span class="p">}</span>                     <span class="p">;</span> <span class="c1"># says &#34;yes&#34; </span>
</span></span></code></pre></div><p>使用 <code>elsif</code>, 额外的条件可以被夹在 <code>if</code> 和 <code>else</code> 之间。只有在前面的所有条件都为假的情况下才会计算额外条件，并且只运行第一个真实条件旁边的块。如果你愿意，你可以以一个 <code>elsif</code> 而不是一个 <code>else</code> 结束。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">no</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">elsif</span> <span class="kt">False</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">NO</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">yes</span><span class="p">&#34;</span> <span class="p">}</span> <span class="c1"># says &#34;yes&#34; </span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">no</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">elsif</span> <span class="kt">True</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">YES</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">yes</span><span class="p">&#34;</span> <span class="p">}</span> <span class="c1"># says &#34;YES&#34; </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">no</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">elsif</span> <span class="kt">False</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">NO</span><span class="p">&#34;</span> <span class="p">}</span> <span class="c1"># does not say anything </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">right</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Right!</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="kt">True</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">wrong</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Wrong!</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="kt">False</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nf">wrong</span><span class="p">()</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">no</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">elsif</span> <span class="nb">right</span><span class="p">()</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">yes</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">maybe</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># The above says &#34;Wrong!&#34; then says &#34;Right!&#34; then says &#34;yes&#34; </span>
</span></span></code></pre></div><p>您不能将语句修饰符形式用于 <code>else</code> 或 <code>elsif</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">42</span><span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">43</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>            <span class="c1"># syntax error </span>
</span></span></code></pre></div><p>对于分号和换行, 所有相同的规则都适用，始终如一。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">0</span> <span class="p">};</span> <span class="k">elsif</span> <span class="mi">1</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">1</span> <span class="p">}</span>  <span class="k">else</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">how?</span><span class="p">&#34;</span> <span class="p">}</span> <span class="p">;</span> <span class="c1"># syntax error </span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">0</span> <span class="p">}</span>  <span class="k">elsif</span> <span class="mi">1</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">1</span> <span class="p">};</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">how?</span><span class="p">&#34;</span> <span class="p">}</span> <span class="p">;</span> <span class="c1"># syntax error </span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">0</span> <span class="p">}</span>  <span class="k">elsif</span> <span class="mi">1</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">1</span> <span class="p">}</span>  <span class="k">else</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">how?</span><span class="p">&#34;</span> <span class="p">}</span> <span class="p">;</span> <span class="c1"># says &#34;1&#34; </span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">0</span> <span class="p">}</span> <span class="k">elsif</span> <span class="mi">1</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">1</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">how?</span><span class="p">&#34;</span> <span class="p">}</span>                                    <span class="p">;</span> <span class="c1"># says &#34;1&#34; </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">0</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">elsif</span> <span class="mi">1</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">1</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">how?</span><span class="p">&#34;</span> <span class="p">}</span>                  <span class="p">;</span> <span class="c1"># says &#34;1&#34; </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">if</span>        <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">no</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">elsif</span> <span class="kt">False</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">NO</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>        <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">yes</span><span class="p">&#34;</span> <span class="p">}</span>                              <span class="p">;</span> <span class="c1"># says &#34;yes&#34; </span>
</span></span></code></pre></div><p>整个东西要么<a href="https://docs.raku.org/type/Slip">slips</a>我们一个空列表（如果没有运行块）或者返回由运行的块产生的值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nv">$d</span> <span class="o">+=</span> <span class="mi">42</span><span class="p">;</span> <span class="p">&#34;</span><span class="s2">two</span><span class="p">&#34;;</span> <span class="p">}</span> <span class="k">elsif</span> <span class="kt">False</span> <span class="p">{</span> <span class="nv">$d</span> <span class="o">+=</span> <span class="mi">43</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="p">})</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="mi">3</span><span class="o">,</span> <span class="nv">$d</span><span class="p">);</span> <span class="c1"># says &#34;(1 3 0)&#34; </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nv">$c</span> <span class="o">+=</span> <span class="mi">42</span><span class="p">;</span> <span class="p">&#34;</span><span class="s2">two</span><span class="p">&#34;;</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nv">$c</span> <span class="o">+=</span> <span class="mi">43</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="p">})</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="mi">3</span><span class="o">,</span> <span class="nv">$c</span><span class="p">);</span> <span class="c1"># says &#34;(1 2 3 43)&#34; </span>
</span></span></code></pre></div><p>可以在 <code>else</code> 中获取前一个表达式的值，它可以来自 <code>if</code> 或者最后一个 <code>elsif</code>,  如果存在的话：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">if</span> <span class="mi">0</span>     <span class="p">{</span> <span class="p">}</span> <span class="k">else</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="p">&#34;</span><span class="nv">$_</span><span class="s2"> </span><span class="nv">$a</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span> <span class="p">;</span> <span class="c1"># says &#34;1 0&#34; </span>
</span></span><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">if</span> <span class="kt">False</span> <span class="p">{</span> <span class="p">}</span> <span class="k">else</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="p">&#34;</span><span class="nv">$_</span><span class="s2"> </span><span class="nv">$a</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span> <span class="p">;</span> <span class="c1"># says &#34;1 False&#34; </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="kt">False</span> <span class="p">{</span> <span class="p">}</span> <span class="k">elsif</span> <span class="mi">0</span> <span class="p">{</span> <span class="p">}</span> <span class="k">else</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="nv">$a</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>  <span class="p">;</span> <span class="c1"># says &#34;0&#34; </span>
</span></span></code></pre></div><h2 id="unless">unless</h2>
<p>当你厌倦了输入 “if not (X)” 时，你可能会用 <code>unless</code> 来反转条件语句的意义。你不能使用把 <code>else</code> 或 <code>elsif</code> 与 <code>unless</code> 用在一起。因为那最终会让人感到困惑。除了这两个不同,  <code>unless</code> 的工作方式和 <a href="https://docs.raku.org/language/control#if">if</a> 相同：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">unless</span> <span class="mi">1</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">1 is false</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>  <span class="p">;</span> <span class="c1"># does not say anything, since 1 is true </span>
</span></span><span class="line"><span class="cl"><span class="k">unless</span> <span class="mi">1</span>   <span class="p">&#34;</span><span class="s2">1 is false</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span>    <span class="p">;</span> <span class="c1"># syntax error, missing block </span>
</span></span><span class="line"><span class="cl"><span class="k">unless</span> <span class="mi">0</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">0 is false</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>  <span class="p">;</span> <span class="c1"># says &#34;0 is false&#34; </span>
</span></span><span class="line"><span class="cl"><span class="k">unless</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span> <span class="ow">and</span> <span class="mi">1</span> <span class="p">{</span> <span class="mi">43</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span> <span class="p">;</span> <span class="c1"># says &#34;42&#34; but does not say &#34;43&#34; </span>
</span></span><span class="line"><span class="cl"><span class="mi">43</span><span class="o">.</span><span class="nb">say</span> <span class="k">unless</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span> <span class="ow">and</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1"># says &#34;42&#34; and then says &#34;43&#34; </span>
</span></span><span class="line"><span class="cl"><span class="mi">43</span><span class="o">.</span><span class="nb">say</span> <span class="k">unless</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span> <span class="ow">and</span> <span class="mi">1</span><span class="p">;</span>      <span class="c1"># says &#34;42&#34; but does not say &#34;43&#34; </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">unless</span> <span class="mi">0</span> <span class="p">{</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>           <span class="p">;</span> <span class="c1"># says &#34;1&#34; </span>
</span></span><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">unless</span> <span class="mi">0</span> <span class="k">-&gt;</span> <span class="nv">$_</span> <span class="p">{</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>     <span class="p">;</span> <span class="c1"># says &#34;0&#34; </span>
</span></span><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">unless</span> <span class="kt">False</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="nv">$a</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span> <span class="p">;</span> <span class="c1"># says &#34;False&#34; </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="p">(</span><span class="k">unless</span> <span class="mi">0</span> <span class="p">{</span> <span class="nv">$c</span> <span class="o">+=</span> <span class="mi">42</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="p">})</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="nv">$c</span><span class="p">);</span> <span class="c1"># says &#34;(1 2 3 42)&#34; </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="p">(</span><span class="k">unless</span> <span class="mi">1</span> <span class="p">{</span> <span class="nv">$d</span> <span class="o">+=</span> <span class="mi">42</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="p">})</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="nv">$d</span><span class="p">);</span> <span class="c1"># says &#34;(1 3 0)&#34; </span>
</span></span></code></pre></div><h2 id="with-orwith-withouthttpsdocsrakuorglanguagecontrol___top"><a href="https://docs.raku.org/language/control#___top"><code>with</code>, <code>orwith</code>, <code>without</code></a></h2>
<p><code>with</code> 语句像 <code>if</code> 一样，但它测试 definedness 而不是真假。此外，它在条件上主题化，很像 <code>given</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">with</span> <span class="p">&#34;</span><span class="s2">abc</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">index</span><span class="p">(&#34;</span><span class="s2">a</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span>      <span class="c1"># prints 0 </span>
</span></span></code></pre></div><p>代替 <code>elsif</code>，<code>orwith</code> 可用于链定义性测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># The below code says &#34;Found a at 0&#34; </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">abc</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">with</span>   <span class="nv">$s</span><span class="o">.</span><span class="nb">index</span><span class="p">(&#34;</span><span class="s2">a</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Found a at </span><span class="nv">$_</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">orwith</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">index</span><span class="p">(&#34;</span><span class="s2">b</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Found b at </span><span class="nv">$_</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">orwith</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">index</span><span class="p">(&#34;</span><span class="s2">c</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Found c at </span><span class="nv">$_</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>                 <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Didn&#39;t find a, b or c</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span></code></pre></div><p>您可以混合基于 <code>if</code> 和基于 <code>with</code> 的子句。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># This says &#34;Yes&#34; </span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">orwith</span> <span class="kt">Nil</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">orwith</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Yes</span><span class="p">&#34;</span> <span class="p">};</span>
</span></span></code></pre></div><p>与 <code>unless</code> 一样，您可以使用 <code>without</code> 检查 undefinedness，但是您可能不会添加一个 <code>else</code> 子句：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$answer</span> <span class="o">=</span> <span class="kt">Any</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">without</span> <span class="nv">$answer</span> <span class="p">{</span> <span class="nb">warn</span> <span class="p">&#34;</span><span class="s2">Got: </span><span class="p">{</span><span class="nv">$_</span><span class="o">.</span><span class="nb">perl</span><span class="p">}&#34;</span> <span class="p">}</span>
</span></span></code></pre></div><p>也有 <code>with</code> 和 <code>without</code> 语句修饰符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$answer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">True</span><span class="p">)</span><span class="o">.</span><span class="nb">roll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">42</span> <span class="k">with</span> <span class="nv">$answer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">warn</span> <span class="p">&#34;</span><span class="s2">undefined answer</span><span class="p">&#34;</span> <span class="k">without</span> <span class="nv">$answer</span><span class="p">;</span>
</span></span></code></pre></div><h1 id="when">when</h1>
<p><code>when</code> 块类似于 <code>if</code> 块，它们中的一个或两个都可以用在外部块中; 他们也都有一个“语句修饰符”形式。但是如何处理外部块中的相同代码是有区别的：当 <code>when</code> 块执行时，控制被传递到封闭块并忽略后面的语句; 但是当 <code>if</code> 块执行时，后面的语句会被执行。[<a href="https://docs.raku.org/language/control#fn-1">1]</a>以下例子应说明 <code>if</code> 或 <code>when</code> 块的默认行为，假设没有特殊出口或其他副作用的语句被包括在 <code>if</code> 或 <code>when</code> 块中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="ow">X</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1"># if X is true in boolean context, block is executed </span>
</span></span><span class="line"><span class="cl">    <span class="c1"># following statements are executed regardless </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="ow">X</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1"># if X is true in boolean context, block is executed </span>
</span></span><span class="line"><span class="cl">                 <span class="c1"># and control passes to the outer block </span>
</span></span><span class="line"><span class="cl">    <span class="c1"># following statements are NOT executed </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果以上 <code>if</code> 和 <code>when</code> 块出现在文件作用域内，则在每种情况下都会执行后面的语句。</p>
<p>还有另外一个功能，<code>when</code> 有而 <code>if</code> 没有的：<code>when</code> 的布尔上下文测试默认为 <code>$_ ~~</code>，而 <code>if</code> 的不是。这会影响如何在没有 <code>$_</code> (在这种情况下是 <code>Any</code>。 并且 <code>Any</code> 智能匹配<code>True</code>：<code>Any ~~ True</code> 产生 <code>True</code>)值的 <code>when</code> 块儿中使用X。请看以下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="kt">True</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="nv">$a</span>    <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="p">};</span> <span class="c1"># no output </span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="nb">so</span> <span class="nv">$a</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="p">}</span>  <span class="c1"># a (in &#34;so $a&#34; &#39;so&#39; coerces $a to Boolean context True </span>
</span></span><span class="line"><span class="cl">                            <span class="c1"># which matches with Any) </span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="nv">$b</span>    <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span> <span class="p">};</span> <span class="c1"># no output (this statement won&#39;t be run) </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>最后，<code>when</code> 语句修饰符形式不影响在另一个块内部或外部执行以下语句：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span> <span class="k">when</span> <span class="ow">X</span><span class="err">;</span> <span class="c1"># if X is true statement is executed </span>
</span></span><span class="line"><span class="cl">                  <span class="c1"># following statements are not affected </span>
</span></span></code></pre></div><p>由于成功匹配将退出块，这段代码的行为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="kt">True</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$a</span> <span class="o">=</span> <span class="nb">do</span> <span class="k">when</span> <span class="o">.</span><span class="nb">so</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1"># OUTPUT: «(Any)» </span>
</span></span></code></pre></div><p>解释了，因为在存储或处理任何值之前放弃了 <code>do</code> 块。但是，在这种情况下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$_</span> <span class="o">=</span> <span class="kt">False</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$a</span> <span class="o">=</span> <span class="nb">do</span> <span class="k">when</span> <span class="o">.</span><span class="nb">so</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1"># OUTPUT: «False» </span>
</span></span></code></pre></div><p>因为比较是假的，所以不会放弃该块，因此 <code>$a</code> 实际上会得到一个值。</p>
<h1 id="for">for</h1>
<p><code>for</code> 循环迭代一个列表，每次迭代, 运行<a href="https://docs.raku.org/type/Block">块</a>中的语句一次，。如果块接受参数，则列表元素作为参数提供。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@foo</span> <span class="p">{</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">print</span> <span class="p">}</span> <span class="c1"># prints each value contained in @foo </span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@foo</span> <span class="p">{</span> <span class="o">.</span><span class="nb">print</span> <span class="p">}</span>   <span class="c1"># same thing, because .print implies a $_ argument </span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@foo</span> <span class="p">{</span> <span class="mi">42</span><span class="o">.</span><span class="nb">print</span> <span class="p">}</span> <span class="c1"># prints 42 as many times as @foo has elements </span>
</span></span></code></pre></div><p>当然，尖括号语法或<a href="https://docs.raku.org/language/variables#The_%5E_twigil">占位符</a>可用于命名参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@foo</span> <span class="k">-&gt;</span> <span class="nv">$item</span> <span class="p">{</span> <span class="nb">print</span> <span class="nv">$item</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@foo</span> <span class="p">{</span> <span class="nb">print</span> <span class="nv">$^item</span> <span class="p">}</span>            <span class="c1"># same thing </span>
</span></span></code></pre></div><p>可以声明多个参数，在这种情况下，迭代器在运行块之前根据需要从列表中获取尽可能多的元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$idx</span><span class="o">,</span> <span class="nv">$val</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$idx:</span><span class="s2"> </span><span class="nv">$val</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%hash</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="ow">Z</span><span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">%hash</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$key</span><span class="o">,</span> <span class="nv">$val</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$key</span><span class="s2"> =&gt; </span><span class="nv">$val</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mf">1.1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mf">2.1</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$^x</span><span class="s2"> &lt; </span><span class="nv">$^y</span><span class="p">&#34;</span> <span class="p">}</span>  <span class="c1"># says &#34;1 &lt; 1.1&#34; then says &#34;2 &lt; 2.1&#34; </span>
</span></span></code></pre></div><p>尖块的参数可以具有默认值，允许处理缺少元素的列表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@list</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">N/A</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$c</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">N/A</span><span class="p">&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$a</span><span class="s2"> </span><span class="nv">$b</span><span class="s2"> </span><span class="nv">$c</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «1 2 3</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="n">N</span><span class="o">/</span><span class="n">A</span> <span class="n">N</span><span class="o">/</span><span class="n">A</span><span class="o">»</span> 
</span></span></code></pre></div><p>If the postfix form of <code>for</code> is used a block is not required and the topic is set for the statement list.</p>
<p>如果使用 <code>for</code> 的后缀形式，则不需要块，并且为语句列表设置主题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> „<span class="n">I</span> <span class="nv">$_</span> <span class="n">butterflies</span><span class="o">!</span>“ <span class="k">for</span> <span class="p">&lt;</span><span class="s">♥ ♥ ♥</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT«I ♥ butterflies!</span>
</span></span><span class="line"><span class="cl"><span class="n">I</span> ♥ <span class="n">butterflies</span><span class="o">!</span>
</span></span><span class="line"><span class="cl"><span class="n">I</span> ♥ <span class="n">butterflies</span><span class="o">!»</span> 
</span></span></code></pre></div><p><code>for</code> 可以在惰性列表上使用 - 只在需要时从列表中取元素，因此要逐行读取文件，您可以使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="vg">$*IN</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span>
</span></span></code></pre></div><p>迭代变量总是有词法的，因此您无需使用 <code>my</code> 来为它们提供适当的作用域。此外，它们是只读别名。如果您需要它们进行读写，请使用 <code>&lt;-&gt;</code> 而不是 <code>-&gt;</code>。如果需要 <code>$_</code> 在 for 循环中进行读写，请明确执行此操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@foo</span> <span class="o">&lt;-&gt;</span> <span class="nv">$_</span> <span class="p">{</span> <span class="nv">$_</span><span class="o">++</span> <span class="p">}</span>
</span></span></code></pre></div><p>for 循环可以生成每个附加块运行产生的值的 <code>List</code>。要捕获这些值，请将 for 循环放在括号中或将它们赋值给数组：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">})</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>              <span class="c1"># OUTPUT «(2 4 6)» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="nb">do</span> <span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">};</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># OUTPUT «[2 4 6]» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@b</span> <span class="o">=</span> <span class="p">(</span><span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">});</span> <span class="nv">@b</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>  <span class="c1"># OUTPUT: «[2 4 6]» </span>
</span></span></code></pre></div><h1 id="gathertake">gather/take</h1>
<p><code>gather</code> 是一个返回值的<a href="https://docs.raku.org/type/Seq">序列</a>的语句或块前缀。该值来自在 <code>gather</code> 块的动态作用域的<a href="https://docs.raku.org/type/Mu#routine_take">take</a>调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="k">gather</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">take</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">take</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">take</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">join</span> <span class="p">&#39;</span><span class="s1">, </span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">@a</span><span class="p">;</span>          <span class="c1"># OUTPUT: «1, 5, 42» </span>
</span></span></code></pre></div><p><code>gather/take</code> 可以懒惰地生成值，具体取决于上下文。如果要强制延迟计算 ，请使用<a href="https://docs.raku.org/type/Iterable#method_lazy">lazy</a>子例程或方法。绑定到标量或无符号的容器也会导致懒惰。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@vals</span> <span class="o">=</span> <span class="nb">lazy</span> <span class="k">gather</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">take</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Produced a value</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">take</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@vals</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">between consumption of two values</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@vals</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># between consumption of two values </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Produced a value </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2 </span>
</span></span></code></pre></div><p><code>gather/take</code> 是动态作用域的，因此您可以从 <code>gather</code> 里面的 subs 或方法内部调用 <code>take</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">weird</span><span class="p">(</span><span class="nv">@elems</span><span class="o">,</span> <span class="o">:</span><span class="nv">$direction</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">forward</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">%direction</span> <span class="o">=</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="s">forward</span>  <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">take</span> <span class="nv">$_</span> <span class="k">for</span> <span class="nv">@elems</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="s">backward</span> <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">take</span> <span class="nv">$_</span> <span class="k">for</span> <span class="nv">@elems</span><span class="o">.</span><span class="nb">reverse</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="s">random</span>   <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">take</span> <span class="nv">$_</span> <span class="k">for</span> <span class="nv">@elems</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">gather</span> <span class="nv">%direction</span><span class="p">{</span><span class="nv">$direction</span><span class="p">}();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">weird</span><span class="p">(&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">direction</span><span class="p">&lt;</span><span class="s">backward</span><span class="p">&gt;</span> <span class="p">);</span>          <span class="c1"># OUTPUT: «(c b a)» </span>
</span></span></code></pre></div><p>如果值需要在调用方可变，请使用<a href="https://docs.raku.org/type/Mu#routine_take-rw">take-rw</a>。</p>
<p>请注意，<code>gather/take</code> 也适用于哈希。返回值仍然是一个 <code>Seq</code> 但在以下示例中对散列的赋值使其成为散列。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="k">gather</span> <span class="p">{</span> <span class="nb">take</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nb">take</span> <span class="p">&#34;</span><span class="s2">bar</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="p">;</span>                                             <span class="c1"># OUTPUT: «{bar =&gt; 2, foo =&gt; 1}» </span>
</span></span></code></pre></div><h1 id="supplyemit">supply/emit</h1>
<p>将调用者发射到闭合的 <a href="https://docs.raku.org/language/concurrency#index-entry-supply_%28on-demand%29">supply</a> 中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supply</span> <span class="o">=</span> <span class="k">supply</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">emit</span> <span class="nv">$_</span> <span class="k">for</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mf">.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">$supply</span><span class="o">.</span><span class="nb">tap</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">received </span><span class="p">{</span><span class="o">.^</span><span class="nb">name</span><span class="p">}</span><span class="s2"> (</span><span class="nv">$_</span><span class="s2">)</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># received Str (foo) </span>
</span></span><span class="line"><span class="cl"><span class="c1"># received Int (42) </span>
</span></span><span class="line"><span class="cl"><span class="c1"># received Rat (0.5) </span>
</span></span></code></pre></div><h1 id="given">given</h1>
<p><code>given</code> 语句是 Raku 中的 topicalizing 关键字, 类似于 C 语言中的 <code>switch</code>。换句话说，<code>given</code> 设置后面跟着的块里面的 <code>$_</code>。单独用例的关键词是 <code>when</code> 和 <code>default</code>。通常的惯用法看起来像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$var</span> <span class="o">=</span> <span class="p">(</span><span class="kt">Any</span><span class="o">,</span> <span class="mi">21</span><span class="o">,</span> <span class="nb">any</span> <span class="p">&lt;</span><span class="s">answer lie</span><span class="p">&gt;)</span><span class="o">.</span><span class="nb">pick</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">given</span> <span class="nv">$var</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="mi">21</span>    <span class="p">{</span> <span class="nb">say</span> <span class="nv">$_</span> <span class="o">*</span> <span class="mi">2</span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="p">&#39;</span><span class="s1">lie</span><span class="p">&#39;</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span>          <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span>    <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">default</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>given</code> 语句通常单独使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="mi">42</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="o">.</span><span class="kt">Numeric</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></div><p>这比下面的写法更容易理解：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span> <span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="o">.</span><span class="kt">Numeric</span><span class="p">;</span> <span class="p">}(</span><span class="mi">42</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="default-和-when">default 和 when</h2>
<p>当 <code>default</code> 语句后面的 sub-block 离开时, 包含 <code>default</code> 语句的块立马离开。好像跳过了块中的其余语句。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="mi">42</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">&#34;</span><span class="s2">This says</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$_</span> <span class="o">==</span> <span class="mi">42</span> <span class="ow">and</span> <span class="p">(</span> <span class="k">default</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">This says, too</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="mi">43</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">&#34;</span><span class="s2">This never says</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># The above block evaluates to 43 </span>
</span></span></code></pre></div><p><code>when</code> 语句也将这样做（但 <code>when</code> 语句修饰符将<em>不会</em>。）</p>
<p>此外，<code>when</code> 语句针对提供的表达式和 <code>topic</code>（<code>$_</code>）进行 智能匹配，以便在指定匹配时可以检查值，正则表达式和类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">43</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span><span class="o">,</span> <span class="mi">44</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">bar</span><span class="p">&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="kt">Int</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="o">/</span><span class="p">:</span><span class="s">i</span> <span class="o">^</span><span class="n">Bar</span><span class="o">/</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span>  <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Not an Int or a Bar</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «42</span>
</span></span><span class="line"><span class="cl"><span class="mi">43</span>
</span></span><span class="line"><span class="cl"><span class="n">Not</span> <span class="n">an</span> <span class="kt">Int</span> <span class="ow">or</span> <span class="n">a</span> <span class="n">Bar</span>
</span></span><span class="line"><span class="cl"><span class="mi">44</span>
</span></span><span class="line"><span class="cl"><span class="n">Bar</span><span class="o">»</span> 
</span></span></code></pre></div><p>在这种形式中，<code>given</code>/<code>when</code> 结构的行为很像一组 <code>if</code>/<code>elsif</code>/<code>else</code> 语句。注意 <code>when</code> 语句的顺序。下面的代码打印 <code>&quot;Int&quot;</code> 而不是 <code>42</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="mi">42</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="kt">Int</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Int</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="mi">42</span>  <span class="p">{</span> <span class="nb">say</span> <span class="mi">42</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span>  <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">huh?</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Int» </span>
</span></span></code></pre></div><p>当 <code>when</code> 语句或 <code>default</code> 语句导致外部块返回时，嵌套 <code>when</code> 或 <code>default</code> 块不计为外部块，因此只要不打开新块，就可以嵌套这些语句并仍然在同一个“开关”(switch)中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="mi">42</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="kt">Int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">when</span> <span class="mi">42</span>  <span class="p">{</span> <span class="nb">say</span> <span class="mi">42</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Int</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span>  <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">huh?</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «42» </span>
</span></span></code></pre></div><p><code>when</code> 语句可以智能匹配<a href="https://docs.raku.org/language/syntax#Signature_literals">签名</a>。</p>
<h2 id="proceed">proceed</h2>
<h2 id="succeed">succeed</h2>
<p><code>proceed</code> 和 <code>succeed</code> 意在仅用于 <code>when</code> 或 <code>default</code> 块的内部。</p>
<p><code>proceed</code> 语句将立即离开 <code>when</code> 或 <code>default</code> 块, 跳过其余的语句，并在块后重新开始。这可以防止 <code>when</code> 或 <code>default</code> 退出外部块。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="o">*</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">proceed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#34;</span><span class="s2">This never says</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">This says</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span></code></pre></div><p>这通常用于进入多个 <code>when</code> 块。<code>proceed</code> 在成功匹配后将恢复匹配，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="mi">42</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="kt">Int</span>   <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Int</span><span class="p">&#34;;</span> <span class="k">proceed</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="mi">42</span>    <span class="p">{</span> <span class="nb">say</span> <span class="mi">42</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="mi">40</span><span class="o">..*</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">greater than 40</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span>    <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">huh?</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Int» </span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «42» </span>
</span></span></code></pre></div><p>请注意，<code>when 40..*</code> 匹配未发生。为了匹配这样的情况，人们需要在 <code>when 42</code> 块中添加 <code>proceed</code>。</p>
<p>这不像 <code>C</code> 的 <code>switch</code> 语句，因为 <code>proceed</code> 不仅仅是进入直接跟随的块，它还会再次尝试匹配 <code>given</code> 值，请看以下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="mi">42</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="kt">Int</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Int</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="k">proceed</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="mi">43</span>  <span class="p">{</span> <span class="mi">43</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="mi">42</span>  <span class="p">{</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span>  <span class="p">{</span> <span class="p">&#34;</span><span class="s2">got change for an existential answer?</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Int» </span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «42» </span>
</span></span></code></pre></div><p>&hellip;匹配 <code>Int</code>，跳过 <code>43</code>， 因为值不匹配，匹配 <code>42</code>，因为这是下一个真实的匹配，但不进入 <code>default</code> 块，因为该 <code>when 42</code> 块不包含 <code>proceed</code>。</p>
<p>相反，<code>succeed</code> 关键字短路执行并在此时退出整个 <code>given</code> 块。它也可能需要参数来指定块的最终值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="mi">42</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="kt">Int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Int</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="k">succeed</span> <span class="p">&#34;</span><span class="s2">Found</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">never this!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="mi">42</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">42</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">dunno?</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Int» </span>
</span></span></code></pre></div><p>如果您不在 <code>when</code> 或 <code>default</code> 块中，则尝试使用 <code>proceed</code> 或 <code>succeed</code> 是错误的。还要记住，<code>when</code> 语句修饰符形式不会导致任何块被丢弃，并且这样的语句中的任何 <code>succeed</code> 或 <code>proceed</code> 都应用于周围的子句，如果有的话：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="mi">42</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">This says</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">when</span> <span class="kt">Int</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&#34;</span><span class="s2">This says too</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">41</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="p">{</span> <span class="p">&#34;</span><span class="s2">And this says</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="k">proceed</span> <span class="p">}</span> <span class="k">when</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">41</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="p">&#34;</span><span class="s2">This never says</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">&#34;</span><span class="s2">This also says</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="given-作为语句">given 作为语句</h2>
<p><code>given</code> 可以跟在语句后面, 以在给它所跟的语句中设置主题(topic)。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span> <span class="k">given</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «foo» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">printf</span> <span class="p">&#34;</span><span class="nv">%s</span><span class="s2"> </span><span class="nv">%02i</span><span class="s2">.</span><span class="nv">%02i</span><span class="s2">.</span><span class="nv">%i</span><span class="p">&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">&lt;</span><span class="s">Mo Tu We Th Fr Sa Su</span><span class="p">&gt;</span><span class="o">[.</span><span class="nb">day-of-week</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="nb">day</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="nb">month</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="nb">year</span>
</span></span><span class="line"><span class="cl">    <span class="k">given</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">now</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Sa 03.06.2016» </span>
</span></span></code></pre></div><h1 id="loop">loop</h1>
<p><code>loop</code> 语句接收 3 个参数, 分别是初始化, 条件和增量, 它们在元括号中用 <code>;</code> 分隔。初始化执行一次，任何变量声明都将溢出到周围的块中。每次迭代执行一次条件并将其强转为 <code>Bool</code>，如果为 <code>False</code> 则循环停止。每次迭代执行一次增量器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">loop</span> <span class="p">(</span><span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nv">$i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>无限循环不需要圆括号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">loop</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">forever</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span></code></pre></div><p><code>loop</code> 如果出现在列表中，则该语句可用于从附加块的每次运行结果中生成值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="k">loop</span> <span class="p">(</span> <span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;)</span> <span class="p">{</span> <span class="nv">$i</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">})</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>               <span class="c1"># OUTPUT: «(2 4 6)» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">(</span><span class="k">loop</span> <span class="p">(</span> <span class="k">my</span> <span class="nv">$j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$j</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;)</span> <span class="p">{</span> <span class="nv">$j</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">});</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>   <span class="c1"># OUTPUT: «[2 4 6]» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@b</span> <span class="o">=</span> <span class="nb">do</span> <span class="k">loop</span> <span class="p">(</span> <span class="k">my</span> <span class="nv">$k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$k</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;)</span> <span class="p">{</span> <span class="nv">$k</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">};</span> <span class="nv">@b</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>  <span class="c1"># same thing </span>
</span></span></code></pre></div><p>与 <code>for</code> 循环不同，不应该依赖于返回的值是否是惰性生成的。最好使用 <code>eager</code> 来保证循环的返回值真实运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">heads-in-a-row</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nb">eager</span> <span class="k">loop</span> <span class="p">(;</span> <span class="mi">2</span><span class="o">.</span><span class="nb">rand</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">;)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">heads</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="while-until">while, until</h1>
<p>只要条件为真，<code>while</code> 语句就会执行该块。所以</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="nv">$x</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="p">&#34;</span><span class="se">\n</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «123» </span>
</span></span></code></pre></div><p>类似地，只要表达式为 false ，<code>until</code> 语句就会执行该块。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">until</span> <span class="nv">$x</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="p">&#34;</span><span class="se">\n</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «123» </span>
</span></span></code></pre></div><p><code>while</code> 或 <code>until</code> 的条件可以用括号括起来，但关键字和条件的左括号之间必须有空格。</p>
<p><code>while</code> 和 <code>until</code> 两者可作为语句修饰符。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x--</span> <span class="k">while</span> <span class="nv">$x</span> <span class="o">&gt;</span> <span class="mi">12</span>
</span></span></code></pre></div><p>另见 <code>repeat/while</code> 和下面的 <code>repeat/until</code>。</p>
<p>所有这些形式都可以以和 <code>loop</code> 相同的方式产生返回值。</p>
<h1 id="repeatwhile-repeatuntil">repeat/while, repeat/until</h1>
<p><em>至少</em>执行<em>一次</em>该块，如果条件允许，则重复执行该块。这与 <code>while</code>/<code>until</code> 的不同之处在于，即使条件出现在前面，也会在循环结束时计算条件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">repeat</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">while</span> <span class="nv">$x</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># OUTPUT: «5» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">repeat</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">while</span> <span class="nv">$x</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># OUTPUT: «6» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">repeat</span> <span class="k">while</span> <span class="nv">$x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># OUTPUT: «10» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">repeat</span> <span class="k">while</span> <span class="nv">$x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># OUTPUT: «11» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">repeat</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">until</span> <span class="nv">$x</span> <span class="o">&gt;=</span> <span class="mi">15</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># OUTPUT: «15» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">repeat</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">until</span> <span class="nv">$x</span> <span class="o">&gt;=</span> <span class="mi">15</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># OUTPUT: «16» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">repeat</span> <span class="k">until</span> <span class="nv">$x</span> <span class="o">&gt;=</span> <span class="mi">20</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># OUTPUT: «20» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">repeat</span> <span class="k">until</span> <span class="nv">$x</span> <span class="o">&gt;=</span> <span class="mi">20</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># OUTPUT: «21» </span>
</span></span></code></pre></div><p>所有这些形式都可以以和 <code>loop</code> 相同的方式产生返回值。</p>
<h1 id="return">return</h1>
<p>sub <code>return</code> 将停止子程序或方法的执行，运行所有相关的<a href="https://docs.raku.org/language/phasers#Block_phasers">phasers</a>，并提供给定的返回值给调用者。默认返回值是 <code>Nil</code>。如果提供了返回值<a href="https://docs.raku.org/type/Signature#Constraining_return_types">类型约束</a>，则将检查它，除非返回值为 <code>Nil</code>。如果类型检查失败，则抛出异常 <a href="https://docs.raku.org/type/X::TypeCheck::Return">X::TypeCheck::Return</a>。如果它通过了, 则发生控制异常，可以通过 <a href="https://docs.raku.org/language/phasers#CONTROL">CONTROL</a> 捕获。</p>
<p>无论嵌套有多深，块中的任何 <code>return</code> 都与该块外部词法作用域中的第一个 <code>Routine</code> 绑定。请注意，包的根目录中的 <code>return</code> 将在运行时失败。块中被惰性计算（例如在 <code>map</code> 里面）的<code>return</code> 可能发现外部词法例程在块执行时消失了。几乎在任何情况下 <code>last</code> 都是更好的选择。有关如何处理和生成返回值的更多信息，请查看<a href="https://docs.raku.org/language/functions#Return_values">函数文档</a>。</p>
<h1 id="return-rw">return-rw</h1>
<p>sub <code>return</code> 将返回值，而不是容器。这些是不可变的，并且在尝试可变(mutated)时会导致运行时错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="k">s</span><span class="p">(){</span> <span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">41</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$a</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">++</span><span class="k">s</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::Multi::NoMatch.new(dispatcher … </span>
</span></span></code></pre></div><p>要返回可变容器，请使用 <code>return-rw</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="k">s</span><span class="p">(){</span> <span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">41</span><span class="p">;</span> <span class="k">return-rw</span> <span class="nv">$a</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">++</span><span class="k">s</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «42» </span>
</span></span></code></pre></div><p><code>return</code> 适用于关于 phasers 和控制异常的规则。</p>
<h1 id="fail">fail</h1>
<p>在执行所有相关的 <a href="https://docs.raku.org/language/phasers#Block_phasers">phasers</a>之后，离开例程并返回提供的 <a href="https://docs.raku.org/type/Exception">Exception</a> 或包含在 <a href="https://docs.raku.org/type/Failure">Failure</a> 里面的 <code>Str</code> 。如果调用者通过编译指令 <code>use fatal;</code> 激活致命异常，则抛出异常而不是作为 <code>Failure</code> 返回。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span> <span class="p">{</span> <span class="nb">fail</span> <span class="p">&#34;</span><span class="s2">WELP!</span><span class="p">&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::AdHoc: WELP!» </span>
</span></span></code></pre></div><h1 id="once">once</h1>
<p>带有前缀 <code>once</code> 的块即使放在循环或递归例程中，也只执行一次。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$guard</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">loop</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">last</span> <span class="k">if</span> <span class="nv">$guard--</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">once</span> <span class="p">{</span> <span class="nb">put</span> <span class="p">&#39;</span><span class="s1">once</span><span class="p">&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="p">&#39;</span><span class="s1">many</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="c1"># OUTPUT: «once</span>
</span></span><span class="line"><span class="cl"><span class="n">manymanymany</span><span class="o">»</span> 
</span></span></code></pre></div><p>这适用于包含代码对象的每个“克隆”，因此：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">({</span> <span class="n">once</span> <span class="mi">42</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span> <span class="ow">xx</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span><span class="nv">$_</span><span class="p">()</span><span class="o">,</span> <span class="nv">$_</span><span class="p">()};</span> <span class="c1"># says 42 thrice </span>
</span></span></code></pre></div><p>请注意，当多个线程运行同一个块儿的同一克隆时，这<strong>不是</strong>线程安全的构造。还要记住，方法每个类只有一个克隆，而不是每个对象。</p>
<h1 id="quietly">quietly</h1>
<p><code>quietly</code> 块将抑制其生成的所有警告。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">quietly</span> <span class="p">{</span> <span class="nb">warn</span> <span class="p">&#39;</span><span class="s1">kaput!</span><span class="p">&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">warn</span> <span class="p">&#39;</span><span class="s1">still kaput!</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «still kaput! [...]» </span>
</span></span></code></pre></div><p>从块内调用的任何例程生成的任何警告也将被抑制：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">told-you</span> <span class="p">{</span> <span class="nb">warn</span> <span class="p">&#39;</span><span class="s1">hey...</span><span class="p">&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">quietly</span> <span class="p">{</span> <span class="n">told-you</span><span class="p">;</span> <span class="nb">warn</span> <span class="p">&#39;</span><span class="s1">kaput!</span><span class="p">&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">warn</span> <span class="p">&#39;</span><span class="s1">Only telling you now!</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Only telling you now!</span>
</span></span><span class="line"><span class="cl"> <span class="o">[...]</span> <span class="o">»</span> 
</span></span></code></pre></div><h1 id="labelshttpsdocsrakuorglanguagecontrol___top"><a href="https://docs.raku.org/language/control#___top">LABELs</a></h1>
<p><code>while</code>，<code>until</code>，<code>loop</code> 和 <code>for</code> 循环都可以带一个标签，它可以用来标识 <code>next</code>，<code>last</code> 和 <code>redo</code> 。支持嵌套循环，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nl">OUTAHERE</span><span class="o">:</span> <span class="k">while</span> <span class="kt">True</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">last</span> <span class="n">OUTAHERE</span> <span class="k">if</span> <span class="nv">$n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>标签也可以在嵌套循环中用于命名每个循环，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nl">OUTAHERE</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="k">loop</span> <span class="p">(</span> <span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="kt">True</span><span class="p">;</span> <span class="nv">$i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nl">OUTFOR</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1"># exits the for loop before its natural end </span>
</span></span><span class="line"><span class="cl">      <span class="nb">last</span> <span class="n">OUTFOR</span> <span class="k">if</span> <span class="nv">$n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="c1"># exits the infinite loop </span>
</span></span><span class="line"><span class="cl">  <span class="nb">last</span> <span class="n">OUTAHERE</span> <span class="k">if</span> <span class="nv">$i</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="next">next</h1>
<p><code>next</code>  命令启动循环的下一次迭代。所以代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@x</span> <span class="k">-&gt;</span> <span class="nv">$x</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">next</span> <span class="k">if</span> <span class="nv">$x</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>打印 “1245”。</p>
<p>如果存在<a href="https://docs.raku.org/language/phasers#NEXT"><code>NEXT</code> phaser</a>，它将在下一次迭代之前运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="nv">$i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nv">$i</span> <span class="nv">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$i</span><span class="s2"> is odd.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="k">NEXT</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «1 is odd.</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="k">is</span> <span class="nc">odd</span><span class="o">.</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="k">is</span> <span class="nc">odd</span><span class="o">.</span>
</span></span><span class="line"><span class="cl"><span class="mi">7</span> <span class="k">is</span> <span class="nc">odd</span><span class="o">.</span>
</span></span><span class="line"><span class="cl"><span class="mi">9</span> <span class="k">is</span> <span class="nc">odd</span><span class="o">.»</span> 
</span></span></code></pre></div><p><em>从版本 6.d 开始，对于它们运行的迭代，循环中收集其最后一个语句值的 <code>next</code> 命令将返回 <code>Empty</code></em></p>
<h1 id="last">last</h1>
<p><code>last</code> 命令立即退出当前循环。</p>
<pre tabindex="0"><code>my @x = 1, 2, 3, 4, 5;
for @x -&gt; $x {
    last if $x == 3;
    print $x;
}
</code></pre><p>打印 “12”。</p>
<p>如果存在<a href="https://docs.raku.org/language/phasers#LAST"><code>LAST</code> phaser</a>，则在退出循环之前运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="nv">$i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nv">$i</span> <span class="nv">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">  <span class="k">LAST</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The last number was </span><span class="nv">$i</span><span class="s2">.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">NEXT</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «The last number was 5.» </span>
</span></span></code></pre></div><p><em>从版本 6.d 开始，对于它们运行的迭代，循环中收集其最后一个语句值的 <code>last</code> 命令将返回 <code>Empty</code></em></p>
<h1 id="redo">redo</h1>
<p><code>redo</code> 命令重新启动循环块，而不再计算条件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">loop</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="nb">prompt</span><span class="p">(&#34;</span><span class="s2">Enter a number</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl">    <span class="nb">redo</span> <span class="k">unless</span> <span class="nv">$x</span> <span class="o">~~</span> <span class="p">/</span><span class="se">\d</span><span class="o">+</span><span class="p">/;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[上下文和上下文器]]></title>
            <link href="http://localhost:1313/rakulang/38.contexts-and-contextualizers/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/37.containers/?utm_source=atom_feed" rel="related" type="text/html" title="容器" />
                <link href="http://localhost:1313/rakulang/36.traps-to-avoid/?utm_source=atom_feed" rel="related" type="text/html" title="要避免的陷阱" />
                <link href="http://localhost:1313/rakulang/35.testing/?utm_source=atom_feed" rel="related" type="text/html" title="测试" />
                <link href="http://localhost:1313/rakulang/34.terms/?utm_source=atom_feed" rel="related" type="text/html" title="项" />
                <link href="http://localhost:1313/rakulang/33.pod-6-tables/?utm_source=atom_feed" rel="related" type="text/html" title="Pod 6 表" />
            
                <id>http://localhost:1313/rakulang/38.contexts-and-contextualizers/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-13T21:13:31+08:00</published>
            <updated>2018-11-13T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>在许多情况下，需要上下文来解释容器的值。在 Raku 中，我们将使用 context 将容器的值强制转换为某种类型或类，或者决定如何处理它，就像接收器(sink)上下文的情况一样。</p>
<h1 id="sink-上下文httpsdocsrakuorglanguagecontexts___top"><a href="https://docs.raku.org/language/contexts#___top">Sink 上下文</a></h1>
<p><em>Sink</em> 相当于 <code>void</code> 上下文，也就是说，我们抛出（在接收器下面）操作的结果或块的返回值的上下文。通常，当语句不知道如何处理该值时，将在警告和错误中调用此上下文。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$sub</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="k">return</span> <span class="nv">$a</span>² <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nv">$sub</span><span class="p">;</span> <span class="c1"># OUTPUT: «WARNINGS:</span>
</span></span><span class="line"><span class="cl"><span class="n">Useless</span> <span class="k">use</span> <span class="k">of</span> <span class="nv">$sub</span> <span class="nb">in</span> <span class="nb">sink</span> <span class="n">context</span> <span class="p">(</span><span class="nb">line</span> <span class="mi">1</span><span class="p">)</span><span class="o">»</span> 
</span></span></code></pre></div><p>您可以使用 <a href="https://docs.raku.org/routine/sink-all"><code>sink-all</code></a> 方法在 <a href="https://docs.raku.org/type/Iterator">Iterator</a> 上强制使用该接收器上下文。<a href="https://docs.raku.org/type/Proc">Proc</a>也可以通过 <a href="https://docs.raku.org/type/Proc#method_sink"><code>sink</code></a> 方法沉没，迫使它们引发异常而不返回任何东西。</p>
<p>通常，如果在 sink 上下文中进行计算，则块将发出警告; 但是，在 sink 上下文中 <a href="https://docs.raku.org/language/control#Flow%2529_gather_take">gather/take</a> 块是显式计算的，并使用 <code>take</code> 显式返回值。</p>
<p>在 sink 上下文中，对象将调用其 <code>sink</code> 方法（如果存在）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">[</span><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">]</span> <span class="k">does</span> <span class="k">role</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">method</span> <span class="nb">sink</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">sink called</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">foo</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: sink called </span>
</span></span></code></pre></div><h1 id="number-上下文httpsdocsrakuorglanguagecontexts___top"><a href="https://docs.raku.org/language/contexts#___top">Number 上下文</a></h1>
<p>这个上下文，可能除了上面的所有内容之外，都是<em>转换</em>或<em>解释</em>上下文，因为它们接收无类型或类型化的变量，并将其类型化为执行操作所需的任何内容。在某些情况下，这意味着转换（例如从 <a href="https://docs.raku.org/type/Str">Str</a> 到 <a href="https://docs.raku.org/type/Numeric">Numeric</a>）; 在其他情况下只是一种解释（<a href="https://docs.raku.org/type/IntStr">IntStr</a> 将被解释为 <a href="https://docs.raku.org/type/Int">Int</a> 或 <a href="https://docs.raku.org/type/Str">Str</a>）。</p>
<p>每当我们需要对变量应用数值运算时，就会调用<em>数字上下文</em>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$not-a-string</span><span class="o">=</span><span class="p">&#34;</span><span class="s2">1                 </span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$neither-a-string</span><span class="o">=</span><span class="p">&#34;</span><span class="s2">3                        </span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$not-a-string</span><span class="o">+</span><span class="nv">$neither-a-string</span><span class="p">;</span> <span class="c1"># OUTPUT: «4» </span>
</span></span></code></pre></div><p>在上面的代码中，只要只有几个数字而没有其他字符，字符串将在数字上下文中解释。但是，它可以具有任意数量的前导或尾随空格。</p>
<p>可以使用算术运算符强制数字上下文，例如 <code>+</code> 或 <code>-</code>。在该上下文中，<a href="https://docs.raku.org/routine/Numeric"><code>Numeric</code></a> 将调用该方法（如果可用），并将返回的值用作对象的数值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$t</span> <span class="o">=</span> <span class="kt">True</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$f</span> <span class="o">=</span> <span class="kt">False</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$t</span><span class="o">+</span><span class="nv">$f</span><span class="p">;</span>      <span class="c1"># OUTPUT: «1» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$t</span><span class="o">.</span><span class="kt">Numeric</span><span class="p">;</span> <span class="c1"># OUTPUT: «1» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$f</span><span class="o">.</span><span class="kt">Numeric</span><span class="p">;</span> <span class="c1"># OUTPUT: «0» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$list</span><span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="kt">True</span><span class="o">+</span><span class="nv">$list</span><span class="p">;</span> <span class="c1"># OUTPUT: «4» </span>
</span></span></code></pre></div><p>在<em>列表</em>那样的东西的情况下，数值通常等于 <code>.elems</code>; 在某些情况下，像<a href="https://docs.raku.org/routine/Numeric#%28Thread%29_method_Numeric">Thread</a> 一样，它将返回唯一的线程标识符。</p>
<h1 id="string-上下文httpsdocsrakuorglanguagecontexts___top"><a href="https://docs.raku.org/language/contexts#___top">String 上下文</a></h1>
<p>在<em>字符串上下文中</em>，值可以作为字符串进行操作。例如，此上下文用于强制非字符串值，以便可以将它们打印到标准输出。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">put</span> <span class="nv">$very-complicated-and-hairy-object</span><span class="p">;</span> <span class="c1"># OUTPUT: something meaningful </span>
</span></span></code></pre></div><p>或者当智能匹配正则表达式时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">put</span> <span class="mi">333444777</span> <span class="o">~~</span> <span class="p">/(</span><span class="mi">3</span><span class="o">+</span><span class="p">)/;</span> <span class="c1"># OUTPUT: «｢333｣ 0 =&gt; ｢333｣» </span>
</span></span></code></pre></div><p>通常，将在变量上调用 <a href="https://docs.raku.org/routine/Str"><code>Str</code></a> 例程以将其上下文化; 因为这个方法是从 <a href="https://docs.raku.org/type/Mu">Mu</a> 继承的，所以它始终存在，但并不总能保证工作。在某些核心类中，它会发出警告。</p>
<p><a href="https://docs.raku.org/routine/~"><code>~</code></a> 是（一元）字符串上下文化器。作为运算符，它连接字符串，但作为前缀运算符，它成为字符串上下文运算符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="o">[</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">]]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">~</span><span class="nv">@array</span><span class="p">;</span> <span class="c1"># OUTPUT: «1 2 3 4 5 6» </span>
</span></span></code></pre></div><p>当 <code>[~]</code> 应用于列表时，这也将在 <a href="https://docs.raku.org/language/operators#Reduction_operators"><em>reduction</em></a> 上下文中发生：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[~]</span> <span class="o">[</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">+</span><span class="mi">6</span><span class="no">i</span><span class="o">,</span> <span class="kt">Set</span><span class="p">(&lt;</span><span class="s">a b c</span><span class="p">&gt;)</span><span class="o">,</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">]</span><span class="p">;</span> <span class="c1"># OUTPUT: «35+6ic a b1 2 3» </span>
</span></span></code></pre></div><p>在那个情况下, 空列表或其它容器会字符串化为一个空字符串：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[~]</span> <span class="o">[]</span> <span class="p">;</span> <span class="c1"># OUTPUT: «␤» </span>
</span></span></code></pre></div><p>由于 <a href="https://docs.raku.org/routine/~#%28Operators%29_infix_~"><code>~</code></a> 也作为缓冲区连接运算符，因此必须检查每个元素是否为空，因为字符串上下文中的单个空缓冲区将表现为字符串，从而产生错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[~]</span> <span class="kt">Buf</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mh">0x3</span><span class="o">,</span><span class="mh">0x33</span><span class="p">)</span><span class="o">,</span> <span class="kt">Buf</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mh">0x2</span><span class="o">,</span><span class="mh">0x22</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Buf:0x&lt;03 33 02 22&gt;» </span>
</span></span></code></pre></div><p>然而,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$non-empty</span> <span class="o">=</span> <span class="kt">Buf</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mh">0x3</span><span class="o">,</span> <span class="mh">0x33</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$empty</span> <span class="o">=</span> <span class="o">[]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$non-empty-also</span> <span class="o">=</span> <span class="kt">Buf</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mh">0x2</span><span class="o">,</span><span class="mh">0x22</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[~]</span> <span class="nv">$non-empty</span><span class="o">,</span> <span class="nv">$empty</span><span class="o">,</span> <span class="nv">$non-empty-also</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Cannot use a Buf as a string, but you called the Stringy method on it </span>
</span></span></code></pre></div><p>由于 <code>~</code> 将字符串上下文放入此列表的第二个元素，<a href="https://docs.raku.org/routine/~#%28Operators%29_infix_~"><code>~</code></a> 将使用适用于字符串的第二个形式，从而产生所显示的错误。只需确保连接的所有内容都是缓冲区即可避免此问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$non-empty</span> <span class="o">=</span> <span class="kt">Buf</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mh">0x3</span><span class="o">,</span> <span class="mh">0x33</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$empty</span> <span class="o">=</span> <span class="kt">Buf</span><span class="o">.</span><span class="nb">new</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$non-empty-also</span> <span class="o">=</span> <span class="kt">Buf</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mh">0x2</span><span class="o">,</span><span class="mh">0x22</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[~]</span> <span class="nv">$non-empty</span><span class="o">,</span> <span class="nv">$empty</span><span class="o">,</span> <span class="nv">$non-empty-also</span><span class="p">;</span> <span class="c1"># OUTPUT: «Buf:0x&lt;03 33 02 22&gt;» </span>
</span></span></code></pre></div><p>通常，上下文会通过调用 contextualizer 将变量强制转换为特定类型; 在 mixins 的情况下，如果混合了上下文类，它将以这种方式运行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$described-number</span> <span class="o">=</span> <span class="mi">1</span><span class="no">i</span> <span class="k">but</span> <span class="nc">&#39;Unity</span> <span class="nb">in</span> <span class="n">complex</span> <span class="n">plane&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">put</span> <span class="nv">$described-number</span><span class="p">;</span> <span class="c1"># OUTPUT: «Unity in complex plane» </span>
</span></span></code></pre></div><p><code>but</code> 创建一个 mixin，它使用 <code>Str</code> 方法赋予复数。<code>put</code> 将它 <code>Str</code> 上下文化为一个字符串，即它调用字符串上下文，使用上面显示的结果。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[容器]]></title>
            <link href="http://localhost:1313/rakulang/37.containers/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/36.traps-to-avoid/?utm_source=atom_feed" rel="related" type="text/html" title="要避免的陷阱" />
                <link href="http://localhost:1313/rakulang/35.testing/?utm_source=atom_feed" rel="related" type="text/html" title="测试" />
                <link href="http://localhost:1313/rakulang/34.terms/?utm_source=atom_feed" rel="related" type="text/html" title="项" />
                <link href="http://localhost:1313/rakulang/33.pod-6-tables/?utm_source=atom_feed" rel="related" type="text/html" title="Pod 6 表" />
                <link href="http://localhost:1313/rakulang/32.perl-6-pod/?utm_source=atom_feed" rel="related" type="text/html" title="Raku pod" />
            
                <id>http://localhost:1313/rakulang/37.containers/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-12T21:13:31+08:00</published>
            <updated>2018-11-12T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>本节介绍了处理变量和容器元素时所涉及的间接级别。解释了 Raku 中使用的容器的不同类型，以及适用于它们的操作，如赋值，绑定和展平。最后讨论了更多高级主题，如自引用数据，类型约束和自定义容器。</p>
<h1 id="变量是什么httpsdocsrakuorglanguagecontainers___top"><a href="https://docs.raku.org/language/containers#___top">变量是什么?</a></h1>
<p>有些人喜欢说“一切都是对象”，但实际上在 Raku 中变量不是对用户暴露的对象。</p>
<p>当编译器遇到类似 <code>my $x</code> 的变量声明时，它会将其注册到某个内部符号表中。此内部符号表用于检测未声明的变量，并将变量的代码生成与正确的作用域联系起来。</p>
<p>在运行时，变量显示为<em>词法板中</em>的条目，或<em>简称</em>为<em>lexpad</em>。这是一个每个作用域的数据结构，它存储每个变量的指针。</p>
<p>在 <code>my $x</code> 这种情况下，变量的 <code>$x</code> 的 lexpad 条目是指向 <code>Scalar</code> 类型对象的指针，通常称为<em>容器</em>。</p>
<h1 id="标量容器httpsdocsrakuorglanguagecontainers___top"><a href="https://docs.raku.org/language/containers#___top">标量容器</a></h1>
<p>虽然 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 类型的对象在 Raku 中无处不在，但您很少直接将它们视为对象，因为大多数操作<em>都是去容器化的</em>，这意味着它们会对 <code>Scalar</code> 容器的内容而不是容器本身起作用。</p>
<p>在这样的代码中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>
</span></span></code></pre></div><p>赋值 <code>$x = 42</code> 在标量容器中存储指向 <code>Int</code> 对象 42 的指针，lexpad 条目 <code>$x</code> 指向该标量容器。</p>
<p>赋值运算符要求左侧的容器将值存储在其右侧。究竟是什么意思取决于容器类型。因为 <code>Scalar</code> 它意味着“用新的值替换先前存储的值”。</p>
<p>请注意，子例程签名允许传递容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nv">$a</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$a</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span><span class="p">(</span><span class="nv">$x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># OUTPUT: «23» </span>
</span></span></code></pre></div><p>在子例程内部，lexpad 条目 <code>$a</code> 指向 <code>$x</code> 指向子例程外部的同一容器。这就是为什么给 <code>$a</code> 赋值也修改了 <code>$x</code> 的内容。</p>
<p>同样，例程可以返回容器，如果它被标记为 <code>is rw</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">()</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span> <span class="nv">$x</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span><span class="p">()</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># OUTPUT: «42» </span>
</span></span></code></pre></div><p>对于显式返回，必须使用 <code>return-rw</code> 而不是 <code>return</code>。</p>
<p>返回容器是 <code>is rw</code> 属性访问器的工作方式。所以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.attr</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>相当于</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!attr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">attr</span><span class="p">()</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span> <span class="nv">$!attr</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>标量容器对类型检查和大多数只读访问都是透明的。<code>.VAR</code> 使它们可见：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>       <span class="c1"># OUTPUT: «Int» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="o">.</span><span class="nb">VAR</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>   <span class="c1"># OUTPUT: «Scalar» </span>
</span></span></code></pre></div><p>并且参数上的 <code>is rw</code> 需要存在可写的 Scalar 容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nv">$x</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$x</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::Parameter::RW: Parameter &#39;$x&#39; expected a writable container, but got Int value» </span>
</span></span></code></pre></div><h1 id="callable-容器httpsdocsrakuorglanguagecontainers___top"><a href="https://docs.raku.org/language/containers#___top">Callable 容器</a></h1>
<p>可调用容器在 <a href="https://docs.raku.org/type/Routine">Routine</a> 调用语法和存储在容器中的对象的 <a href="https://docs.raku.org/type/Callable#method_CALL-ME">CALL-ME</a> 方法的实际调用之间提供了桥梁。声明容器时需要使用符号 <code>&amp;</code>  ，执行时必须省略 <code>Callable</code>。默认类型约束是 <a href="https://docs.raku.org/type/Callable">Callable</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">&amp;callable</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="nv">$ν</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$ν</span><span class="s2"> is</span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$ν</span> <span class="o">~~</span> <span class="kt">Int</span><span class="o">??</span><span class="p">&#34;</span><span class="s2"> whole</span><span class="p">&#34;</span><span class="o">!!</span><span class="p">&#34;</span><span class="s2"> not whole</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">callable</span><span class="p">(</span> ⅓ <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">callable</span><span class="p">(</span> <span class="mi">3</span> <span class="p">);</span>
</span></span></code></pre></div><p>当提到存储在容器中的值时，必须提供 signal 符号。这反过来允许 <code>Routine</code> 被用作调用的<a href="https://docs.raku.org/type/Signature#Constraining_signatures_of_Callables">参数</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">&amp;g</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">caller</span><span class="p">(</span><span class="nv">&amp;c1</span><span class="o">,</span> <span class="nv">&amp;c2</span><span class="p">){</span> <span class="n">c1</span><span class="o">,</span> <span class="n">c2</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">caller</span><span class="p">(</span><span class="nv">&amp;f</span><span class="o">,</span> <span class="nv">&amp;g</span><span class="p">);</span>
</span></span></code></pre></div><h1 id="bindinghttpsdocsrakuorglanguagecontainers___top"><a href="https://docs.raku.org/language/containers#___top">Binding</a></h1>
<p>在赋值之后，Raku 还支持 <code>:=</code> <em>绑定</em>运算符。将值或容器绑定到变量时，会修改变量的 lexpad 条目（而不仅仅是它指向的容器）。如果你这样写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">:=</span> <span class="mi">42</span><span class="p">;</span>
</span></span></code></pre></div><p>然后 <code>$x</code> 的 lexpad 条目直接指向 <code>Int</code> 42. 这意味着你不能再给它赋值了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">:=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::AdHoc: Cannot assign to an immutable value» </span>
</span></span></code></pre></div><p>您还可以将变量绑定到其他变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$a</span> <span class="o">:=</span> <span class="nv">$b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$b</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="p">;</span>         <span class="c1"># OUTPUT: «42» </span>
</span></span></code></pre></div><p>这里，在初始绑定之后，<code>$a</code> 的 lexpad 条目和 <code>$b</code> 的lexpad 条目两者都指向同一个标量容器，因此给一个变量赋值也会改变另一个变量的内容。</p>
<p>您之前已经看到过这种情况：它正是签名参数标记为 <code>is rw</code> 的情况。</p>
<p>无符号变量和带有 <code>is raw</code> trait 的参数总是绑定的（无论使用 <code>=</code> 或 <code>:=</code> ）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\b</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="p">;</span>         <span class="c1"># OUTPUT: «43» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nv">$c</span> <span class="k">is</span> <span class="k">raw</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$c</span><span class="o">++</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="p">;</span>         <span class="c1"># OUTPUT: «44» </span>
</span></span></code></pre></div><h1 id="scalar-容器和-listy-thingshttpsdocsrakuorglanguagecontainers___top"><a href="https://docs.raku.org/language/containers#___top">Scalar 容器和 listy things</a></h1>
<p>在 Raku 中有许多位置容器类型，其语义略有不同。最基本的是 <a href="https://docs.raku.org/type/List">List</a>; 它由逗号运算符创建。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>    <span class="c1"># OUTPUT: «List» </span>
</span></span></code></pre></div><p>列表是不可变的，这意味着您无法更改列表中的元素数。但是，如果其中一个元素恰好是标量容器，您仍然可以给它赋值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">$x</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>                 <span class="c1"># OUTPUT: «23» </span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">$x</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>     <span class="c1"># Cannot modify an immutable value </span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::Assignment::RO: Cannot modify an immutable Int» </span>
</span></span></code></pre></div><p>所以列表不关心它的元素是值还是容器，它们只是存储和检索给它们的任何东西。</p>
<p>列表也可以是惰性的; 在这种情况下，最终的元素是根据迭代器的要求生成的。</p>
<p><code>Array</code> 就像一个列表，除了它强制所有元素都是容器，这意味着你总是可以给元素赋值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="p">;</span>         <span class="c1"># OUTPUT: «[42 2 3]» </span>
</span></span></code></pre></div><p><code>@a</code> 实际上存储了三个标量容器。<code>@a[0]</code> 返回其中一个，赋值运算符用新的整数替换该容器中存储的整数值 <code>42</code>。</p>
<h1 id="赋值和绑定给数组变量httpsdocsrakuorglanguagecontainers___top"><a href="https://docs.raku.org/language/containers#___top">赋值和绑定给数组变量</a></h1>
<p>对标量变量和数组变量的赋值都执行相同的操作：丢弃旧值，并输入一些新值。</p>
<p>然而，很容易观察到它们有多么不同：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="nb">say</span> <span class="nv">$x</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>   <span class="c1"># OUTPUT: «Int» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="nb">say</span> <span class="nv">@a</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>   <span class="c1"># OUTPUT: «Array» </span>
</span></span></code></pre></div><p>这是因为 <code>Scalar</code> 容器类型隐藏得很好，但 <code>Array</code> 没有这样的效果。对数组变量的赋值也是强制性的，因此可以将非数组值赋给数组变量。</p>
<p>要将非 <code>Array</code> 放入数组变量，绑定起作用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">:=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>               <span class="c1"># OUTPUT: «List» </span>
</span></span></code></pre></div><h1 id="绑定到数组元素httpsdocsrakuorglanguagecontainers___top"><a href="https://docs.raku.org/language/containers#___top">绑定到数组元素</a></h1>
<p>作为一个奇怪的旁注，Raku 支持绑定到数组元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">:=</span> <span class="k">my</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="p">;</span>                     <span class="c1"># OUTPUT: «[42 2 3]» </span>
</span></span></code></pre></div><p>如果您已经阅读并理解了之前的解释，那么现在是时候知道这是如何工作的了。毕竟，绑定到变量需要该变量的 lexpad 条目，虽然数组有一个 lexpad 条目 ，但每个数组元素都没有 lexpad 条目，因为您无法在运行时展开 lexpad。</p>
<p>答案是在语法级别识别绑定到数组元素，而不是为正常绑定操作发出代码，在数组上调用特殊方法（<code>BIND-KEY</code> 被调用）。此方法处理与数组元素的绑定。</p>
<p>请注意，虽然支持，但通常应避免直接将非容器化事物绑定到数组元素中。这样做可能会在以后使用数组时产生反直觉的结果。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">:=</span> <span class="mi">42</span><span class="p">;</span>         <span class="c1"># This is not recommended, use assignment instead. </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$b</span> <span class="o">:=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">:=</span> <span class="nv">$b</span><span class="p">;</span>         <span class="c1"># Nor is this. </span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$b</span><span class="p">;</span>          <span class="c1"># ...but this is fine. </span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1"># runtime error: X::Bind::Slice </span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::Bind::Slice: Cannot bind to Array slice» </span>
</span></span></code></pre></div><p>混合列表和数组的操作通常可以防止发生这种意外情况。</p>
<h1 id="展平-项和容器httpsdocsrakuorglanguagecontainers___top"><a href="https://docs.raku.org/language/containers#___top">展平, 项和容器</a></h1>
<p>Raku 中的 <code>%</code> 和 <code>@</code> Sigils 通常指示迭代构造的多个值，而 <code>$</code> sigil 仅指示一个值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@a</span> <span class="p">{</span> <span class="p">};</span>         <span class="c1"># 3 iterations </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">$a</span> <span class="p">{</span> <span class="p">};</span>         <span class="c1"># 1 iteration </span>
</span></span></code></pre></div><p><code>@</code>-sigiled 变量不会在列表上下文中展平：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@b</span> <span class="o">=</span> <span class="nv">@a</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@b</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>               <span class="c1"># OUTPUT: «3» </span>
</span></span></code></pre></div><p>有些操作会使不在标量容器内的子列表被展平：slurpy parameters（<code>*@a</code>）和显式调用 <code>flat</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="nb">flat</span> <span class="nv">@a</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>  <span class="c1"># OUTPUT: «5» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="o">*</span><span class="nv">@x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@x</span><span class="o">.</span><span class="nb">elems</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">f</span> <span class="nv">@a</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="p">;</span>             <span class="c1"># OUTPUT: «5» </span>
</span></span></code></pre></div><p>您还可以使用 <code>|</code> 创建 <a href="https://docs.raku.org/type/Slip">Slip</a>，将列表引入另一个列表中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@l</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="p">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="p">))</span><span class="o">,</span> <span class="o">[</span><span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="p">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="o">|</span><span class="nv">@l</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">12</span><span class="p">);</span>    <span class="c1"># OUTPUT: «(1 2 (3 4 (5 6)) [7 8 (9 10)] 11 12)» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="nb">flat</span> <span class="nv">@l</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">12</span><span class="p">)</span> <span class="c1"># OUTPUT: «(1 2 3 4 5 6 7 8 (9 10) 11 12)» </span>
</span></span></code></pre></div><p>在第一种情况下，<code>@l</code> 的每个元素都作为结果列表的相应元素<em>滑动</em>。另一方面，<code>flat</code> <em>扁平化</em>所有元素，包括所包含数组的元素，除了 <code>(9 10)</code>。</p>
<p>如上所述，标量容器可防止扁平化：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="o">*</span><span class="nv">@x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@x</span><span class="o">.</span><span class="nb">elems</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">f</span> <span class="nv">$@a</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="p">;</span>            <span class="c1"># OUTPUT: «3» </span>
</span></span></code></pre></div><p><code>@</code> 字符也可以用作将参数强制为列表的前缀，从而删除标量容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@$x</span><span class="p">;</span>               <span class="c1"># 3 iterations </span>
</span></span></code></pre></div><p>但是，<em>解容器</em>运算符 <code>&lt;&gt;</code> 更适合去除非列表项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="o">^</span><span class="nf">Inf</span> <span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="o">*.</span><span class="nb">is-prime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$_</span><span class="s2"> is prime</span><span class="p">&#34;</span> <span class="k">for</span> <span class="nv">@$x</span><span class="p">;</span>  <span class="c1"># WRONG! List keeps values, thus leaking memory </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$_</span><span class="s2"> is prime</span><span class="p">&#34;</span> <span class="k">for</span> <span class="nv">$x</span><span class="o">&lt;&gt;</span><span class="p">;</span> <span class="c1"># RIGHT. Simply decontainerize the Seq </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$y</span> <span class="o">:=</span> <span class="o">^</span><span class="nf">Inf</span> <span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="o">*.</span><span class="nb">is-prime</span><span class="p">;</span> <span class="c1"># Even better; no Scalars involved at all </span>
</span></span></code></pre></div><p>方法通常不关心他们的调用者是否在标量中，所以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">say</span><span class="p">);</span>              <span class="c1"># 3 iterations </span>
</span></span></code></pre></div><p>在三个元素的列表上 map，而不是在一个元素上 map。</p>
<h1 id="自引用数据httpsdocsrakuorglanguagecontainers___top"><a href="https://docs.raku.org/language/containers#___top">自引用数据</a></h1>
<p>容器类型（包括 <code>Array</code> 和 <code>Hash</code>）允许您创建自引用结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nv">@a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">put</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «((my @Array_75093712) = [@Array_75093712,])» </span>
</span></span></code></pre></div><p>虽然 Raku 不会阻止您创建和使用自引用数据，但这样做可能会导致您尝试转储数据。作为最后的手段，您可以使用 Promises 来<a href="https://docs.raku.org/type/Promise#method_in">处理</a>超时。</p>
<h1 id="类型约束httpsdocsrakuorglanguagecontainers___top"><a href="https://docs.raku.org/language/containers#___top">类型约束</a></h1>
<p>任何容器都可以具有<a href="https://docs.raku.org/language/typesystem#Type_objects">类型对象</a>或<a href="https://docs.raku.org/language/typesystem#subset">subset</a>形式的类型约束。两者都可以放在声明符和变量名之间，也可以放在 trait <a href="https://docs.raku.org/type/Variable#trait_is_dynamic">of</a>。之后。约束是变量的属性，而不是容器的属性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">subset</span> <span class="nc">Three-letter</span> <span class="k">of</span> <span class="kt">Str</span> <span class="k">where</span> <span class="o">.</span><span class="nb">chars</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">Three-letter</span> <span class="nv">$acronym</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">ÞFL</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>在这种情况下，类型约束是（编译类型定义的）subset <code>Three-letter</code>。</p>
<p>变量可能没有容器，但仍然提供重新绑定和类型检查重新绑定的能力。原因是在这种情况下绑定运算符<a href="https://docs.raku.org/language/operators#infix_%3A%3D"><code>:=</code></a> 执行类型检查：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> \<span class="nb">z</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">z</span> <span class="o">:=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1"># OK </span>
</span></span><span class="line"><span class="cl"><span class="nb">z</span> <span class="o">:=</span> <span class="p">&#34;</span><span class="s2">x</span><span class="p">&#34;;</span> <span class="c1"># Typecheck failure </span>
</span></span></code></pre></div><p>例如，当绑定到 <a href="https://docs.raku.org/type/Hash">Hash</a> 键时，情况并非如此，因为绑定随后由方法调用处理（即使语法保持不变，使用 <code>:=</code> 运算符）。</p>
<p><code>Scalar</code> 容器的默认类型约束是 <a href="https://docs.raku.org/type/Mu">Mu</a>。<code>.VAR.of</code> 方法提供了对容器类型约束的内省，对于 <code>@</code> 和 <code>%</code> sigiled 变量，它给出了值的约束：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Str</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="o">.</span><span class="nb">VAR</span><span class="o">.</span><span class="k">of</span><span class="p">;</span>  <span class="c1"># OUTPUT: «(Str)» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Num</span> <span class="nv">@a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">VAR</span><span class="o">.</span><span class="k">of</span><span class="p">;</span>  <span class="c1"># OUTPUT: «(Num)» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">%h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="o">.</span><span class="nb">VAR</span><span class="o">.</span><span class="k">of</span><span class="p">;</span>  <span class="c1"># OUTPUT: «(Int)» </span>
</span></span></code></pre></div><h2 id="definedness-约束httpsdocsrakuorglanguagecontainers___top"><a href="https://docs.raku.org/language/containers#___top">Definedness 约束</a></h2>
<p>容器还可以强制执行变量是定义的。在声明中放一个笑脸：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int:D</span> <span class="nv">$def</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$def</span><span class="p">;</span>   <span class="c1"># OUTPUT: «3» </span>
</span></span><span class="line"><span class="cl"><span class="nv">$def</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">;</span> <span class="c1"># Typecheck failure </span>
</span></span></code></pre></div><p>您还需要在声明中初始化变量，毕竟变量不能是未定义的。</p>
<p>也可以在使用<a href="https://docs.raku.org/language/variables#Default_defined_variables_pragma">默认定义变量 pragma</a> 的作用域中声明的所有变量中强制执行此约束。来自其他语言的人们总是会定义变量，他们希望看看。</p>
<h1 id="自定义容器httpsdocsrakuorglanguagecontainers___top"><a href="https://docs.raku.org/language/containers#___top">自定义容器</a></h1>
<p>为了提供自定义容器，Raku 提供了 <code>Proxy</code> 这个类 。当从容器中存储或提取值时，需要调用两个方法。类型检查不是由容器本身完成的，并且 readonlyness 等其他限制可以被破坏。因此，返回的值必须与它绑定的变量的类型相同。我们可以使用类型捕获来处理 Raku 中的类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">lucky</span><span class="p">(</span><span class="o">:</span><span class="p">:</span><span class="s">T</span> <span class="nv">$type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nb">T</span> <span class="nv">$c-value</span><span class="p">;</span> <span class="c1"># closure variable </span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kt">Proxy</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="s">FETCH</span> <span class="o">=&gt;</span> <span class="k">method</span> <span class="p">()</span> <span class="p">{</span> <span class="nv">$c-value</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="s">STORE</span> <span class="o">=&gt;</span> <span class="k">method</span> <span class="p">(</span><span class="nb">T</span> <span class="nv">$new-value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="ne">X::OutOfRange</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">what</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">number</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">got</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">13</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">range</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">-∞..12, 14..∞</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">throw</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nv">$new-value</span> <span class="o">==</span> <span class="mi">13</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$c-value</span> <span class="o">=</span> <span class="nv">$new-value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">$a</span> <span class="o">:=</span> <span class="nf">lucky</span><span class="p">(</span><span class="kt">Int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>    <span class="c1"># OUTPUT: «12» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">FOO</span><span class="p">&#39;;</span> <span class="c1"># X::TypeCheck::Binding </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>    <span class="c1"># X::OutOfRange </span>
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">};</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[要避免的陷阱]]></title>
            <link href="http://localhost:1313/rakulang/36.traps-to-avoid/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/35.testing/?utm_source=atom_feed" rel="related" type="text/html" title="测试" />
                <link href="http://localhost:1313/rakulang/34.terms/?utm_source=atom_feed" rel="related" type="text/html" title="项" />
                <link href="http://localhost:1313/rakulang/33.pod-6-tables/?utm_source=atom_feed" rel="related" type="text/html" title="Pod 6 表" />
                <link href="http://localhost:1313/rakulang/32.perl-6-pod/?utm_source=atom_feed" rel="related" type="text/html" title="Raku pod" />
                <link href="http://localhost:1313/rakulang/31.glossary/?utm_source=atom_feed" rel="related" type="text/html" title="术语" />
            
                <id>http://localhost:1313/rakulang/36.traps-to-avoid/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-11T21:13:31+08:00</published>
            <updated>2018-11-11T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>在学习一门编程语言时，可能有熟悉另一门编程语言的背景，总有一些事情会让您感到惊讶，并且可能会耗费宝贵的调试和发现时间。</p>
<p>本文件旨在展示常见的误解，以避免它们。</p>
<p>在编写 Raku 的过程中，我们付出了巨大的努力来消除语法中的瑕疵。然而，当你消灭一个瑕疵的时候，有时另一个会突然冒出来。所以我们花了很多时间去寻找最小数量的瑕疵或者试图把它们放在它们很少被看到的地方。正因为如此，Raku 的瑕疵出现在了不同的地方，而不是来自另一种语言时所期望的那样。</p>
<h1 id="变量和常量">变量和常量</h1>
<h2 id="常量在编译时计算">常量在编译时计算</h2>
<p>常量是在编译时计算的，所以如果在模块中使用它们，请记住，由于模块本身的预编译，它们的值将被冻结:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># WRONG (most likely): </span>
</span></span><span class="line"><span class="cl"><span class="k">unit</span> <span class="k">module</span> <span class="nn">Something::Or::Other</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">constant</span> <span class="nv">$config-file</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">config.txt</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>
</span></span></code></pre></div><p><code>$config-file</code> 将在预编译时一次性被读入。<code>config.txt</code> 文件的更改不会在你再次启动脚本时重新加载;只有当模块被重新编译时才会重新加载。</p>
<p>避免使用<a href="https://docs.raku.org/language/containers">容器</a>，而倾向于将值<a href="https://docs.raku.org/language/containers#Binding">绑定</a>到提供类似于常量行为的变量上，但允许更新值:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Good; file gets updated from &#39;config.txt&#39; file on each script run: </span>
</span></span><span class="line"><span class="cl"><span class="k">unit</span> <span class="k">module</span> <span class="nn">Something::Or::Other</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$config-file</span> <span class="o">:=</span> <span class="p">&#34;</span><span class="s2">config.txt</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>
</span></span></code></pre></div><h2 id="赋值为-nil-产生不同的值-通常是-any">赋值为 Nil 产生不同的值, 通常是 Any</h2>
<p>实际上，赋给 <code>Nil</code> 会<a href="https://docs.raku.org/type/Nil">将变量还原为其默认值</a>。所以:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">15</span><span class="o">,</span> <span class="mi">16</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="kt">Nil</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="p">;</span> <span class="c1"># OUTPUT: «[4 8 (Any) 16]␤» </span>
</span></span></code></pre></div><p>在本例中，<code>Any</code> 是 <code>Array</code> 元素的默认值。</p>
<p>你可以故意指定 <code>Nil</code> 作为默认值:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%h</span> <span class="k">is</span> <span class="k">default</span><span class="p">(</span><span class="kt">Nil</span><span class="p">)</span> <span class="o">=</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="kt">Nil</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%h</span><span class="p">;</span> <span class="c1"># OUTPUT: «Hash %h = {:a(Nil)}␤» </span>
</span></span></code></pre></div><p>或者将值绑定到 <code>Nil</code>，如果结果是你想要的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">:=</span> <span class="kt">Nil</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="p">;</span> <span class="c1"># OUTPUT: «[4 8 (Any) Nil]␤» </span>
</span></span></code></pre></div><p>这个陷阱可能隐藏在函数的结果中，比如匹配:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$result2</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">abcdef</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> dex </span><span class="p">/;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Result2 is </span><span class="p">{</span> <span class="nv">$result2</span><span class="o">.^</span><span class="nb">name</span> <span class="p">}&#34;;</span> <span class="c1"># OUTPUT: «Result2 is Any␤» </span>
</span></span></code></pre></div><p><a href="https://docs.raku.org/language/regexes#Literals">Match 将会是 Nil</a>如果什么也没有找到。但是，如果将 <code>Nil</code> 赋给上面的 <code>$result2</code>，则会得到其默认值，如所示为 <code>Any</code>。</p>
<h2 id="使用块来插入匿名状态变量">使用块来插入匿名状态变量</h2>
<p>程序员打算让代码计数程序被调用的次数，但是计数器没有增加:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">count-it</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Count is </span><span class="p">{</span><span class="nv">$</span><span class="o">++</span><span class="p">}&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">count-it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">count-it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Count is 0 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Count is 0 </span>
</span></span></code></pre></div><p>当涉及到状态变量时，每当该块的块被重新进入时，声明 vars 的块就会被克隆，vars 也会被重新初始化。这让像下面这样的结构表现得恰当;每次调用子程序时，循环内部的状态变量都会被重新初始化:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">count-it</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">^</span><span class="mi">3</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">state</span> <span class="nv">$count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Count is </span><span class="nv">$count</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">count-it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">…and again…</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="n">count-it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Count is 0 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Count is 1 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Count is 2 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># …and again… </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Count is 0 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Count is 1 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Count is 2 </span>
</span></span></code></pre></div><p>同样的布局存在于我们的 bug 程序中。双引号字符串中的 <code>{}</code> 不仅仅是执行一段代码的插值。它实际上是它自己的块，就像在上面的例子中，每次进入子例程时都会被克隆，重新初始化状态变量。为了得到正确的计数，我们需要去掉内部块，使用标量上下文分析器来插入我们的代码:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">count-it</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Count is $($++)</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">count-it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">count-it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Count is 0 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Count is 1 </span>
</span></span></code></pre></div><p>或者，也可以使用<a href="https://docs.raku.org/routine/~">连接运算符</a>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">count-it</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Count is </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$</span><span class="o">++</span> <span class="p">}</span>
</span></span></code></pre></div><h1 id="blocks">Blocks</h1>
<h2 id="提防空-block">提防空 &ldquo;block&rdquo;</h2>
<p>花括号用于声明块。然而，空花括号会声明一个哈希。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="o">=</span> <span class="p">{</span><span class="nb">say</span> <span class="mi">42</span><span class="p">;}</span> <span class="c1"># Block </span>
</span></span><span class="line"><span class="cl"><span class="nv">$</span> <span class="o">=</span> <span class="p">{;}</span>       <span class="c1"># Block </span>
</span></span><span class="line"><span class="cl"><span class="nv">$</span> <span class="o">=</span> <span class="p">{</span><span class="o">…</span><span class="p">}</span>       <span class="c1"># Block </span>
</span></span><span class="line"><span class="cl"><span class="nv">$</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span>       <span class="c1"># Hash </span>
</span></span></code></pre></div><p>如果你想有效地声明一个空的块，你可以使用第二种形式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">&amp;does-nothing</span> <span class="o">=</span> <span class="p">{;};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">does-nothing</span><span class="p">(</span><span class="mi">33</span><span class="p">);</span> <span class="c1"># OUTPUT: «Nil␤» </span>
</span></span></code></pre></div><h1 id="对象">对象</h1>
<h2 id="给属性赋值">给属性赋值</h2>
<p>新手通常会这样想，因为带有访问器的属性被声明为 <code>has $.x</code>，在类里面它们可以给 <code>$.x</code> 赋值 。事实并非如此。</p>
<p>例如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="ni">.c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">double</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$.x</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>   <span class="c1"># WRONG </span>
</span></span><span class="line"><span class="cl">        <span class="nv">$.y</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>   <span class="c1"># WRONG </span>
</span></span><span class="line"><span class="cl">        <span class="nb">self</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Point</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">y</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nf">double</span><span class="o">.</span><span class="nb">x</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Cannot assign to an immutable value␤» </span>
</span></span></code></pre></div><p>方法 <code>double</code> 中的第一行标记为 <code># WRONG</code>，因为 <code>$.x</code> 是 <code>$( self.x )</code> 的缩写。是对只读访问器的调用。</p>
<p>语法 <code>has $.x</code> 是 <code>has $!x; method x() { $!x }</code> 的简写，因此实际属性称为$!将自动生成只读访问器方法。</p>
<p>因此，编写方法 <code>double</code> 的正确方法是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">method</span> <span class="nf">double</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$!x</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$!y</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">self</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>它直接作用于属性。</p>
<h2 id="build-防止从构造函数参数中自动初始化属性">BUILD 防止从构造函数参数中自动初始化属性</h2>
<p>在定义自己的 <code>BUILD</code> 子方法时，必须自己初始化所有属性。例如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="ni">.c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">submethod</span> <span class="nb">BUILD</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!y</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="nb">x</span><span class="p">;</span>       <span class="c1"># OUTPUT: «Any␤» </span>
</span></span></code></pre></div><p>留下 <code>$!x</code> 未初始化，因为自定义的 <code>BUILD</code> 没有初始化它。</p>
<p><strong>注意</strong>:考虑使用 <a href="https://docs.raku.org/language/objects#index-entry-TWEAK">TWEAK</a>。<a href="https://docs.raku.org/language/glossary#Rakudo">Rakudo</a> 自发布 2016.11 以来支持 <a href="https://docs.raku.org/language/objects#index-entry-TWEAK">TWEAK</a> 方法。</p>
<p>一种可能的补救方法是显式地初始化 <code>BUILD</code> 中的属性:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(</span><span class="o">:</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$!y</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$!x</span> <span class="o">:=</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这可以简化为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(</span><span class="o">:</span><span class="nv">$!x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$!y</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>另一种更普遍的方法是不去管 <code>BUILD</code>，而是与 <code>BUILDALL</code> 机制挂钩:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="ni">.c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">BUILDALL</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">callsame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!y</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">self</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="nb">x</span><span class="p">;</span>       <span class="c1"># OUTPUT: «42␤» </span>
</span></span></code></pre></div><p>记住 <code>BUILDALL</code> 是一个方法，而不是子方法。这是因为在默认情况下，每个类层次结构只有一个这样的方法，而 <code>BUILD</code> 是每个类显式调用的。这就是为什么为了正确地初始化父对象，需要在 <code>BUILDALL</code> 中使用 <code>callsame</code>，而不是在 <code>BUILD</code> 中(关于该主题的更多信息请参阅<a href="https://docs.raku.org/language/objects#Object_construction">对象创建</a>)。</p>
<h1 id="空白">空白</h1>
<h2 id="regex-中的空白不按字面匹配">regex 中的空白不按字面匹配</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a b</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">a b</span><span class="p">/;</span> <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><p>默认情况下，regexe 中的空白被认为是一种可选的没有语义的填充，就像 Raku 语言的其他部分一样。</p>
<p>匹配空白的方法:</p>
<ul>
<li>
<p><code>\s</code> 匹配任何一个空白，<code>\s+</code> 匹配至少一个空白</p>
</li>
<li>
<p><code>' '</code>(引号中的空格)以匹配单个空格</p>
</li>
<li>
<p><code>\t</code>， <code>\n</code> 匹配特定空格(制表符，换行符)</p>
</li>
<li>
<p><code>\h</code>， <code>\v</code>，用于水平，垂直空白</p>
</li>
<li>
<p><code>.ws</code> 是一个内建的空白规则，它通常如你所愿</p>
</li>
<li>
<p>对于 <code>m:s/a b/</code> 或 <code>m:sigspace/a b/</code>， regex 中的空白匹配任意空格</p>
</li>
</ul>
<h2 id="模棱两可的解析">模棱两可的解析</h2>
<p>虽然有些语言允许您删除记号之间尽可能多的空白，但是 Raku 就不那么宽容了。最重要的准则是我们不鼓励使用代码高尔夫，所以不要在空格上浪费时间(这些限制背后更严重的潜在原因是单遍解析和解析 Raku 程序的能力，而实际上不需要<a href="https://en.wikipedia.org/wiki/Backtracking">回溯</a>)。</p>
<p>你应留意的常见区域是:</p>
<h3 id="块与散列切片的歧义性">块与散列切片的歧义性</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># WRONG; trying to hash-slice a Bool: </span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="nv">$</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">){</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># RIGHT: </span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="nv">$</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># EVEN BETTER; Raku does not require parentheses there: </span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="nv">$</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span>
</span></span></code></pre></div><h3 id="化简与数组构造函数的歧义性">化简与数组构造函数的歧义性</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># WRONG; ambiguity with `[&lt;]` meta op: </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="o">[[</span><span class="p">&lt;</span><span class="s">foo</span><span class="p">&gt;</span><span class="o">],]</span><span class="p">;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># RIGHT; reductions cannot have spaces in them, so put one in: </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="o">[[</span> <span class="p">&lt;</span><span class="s">foo</span><span class="p">&gt;</span><span class="o">],]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># No ambiguity here, natural spaces between items suffice to resolve it: </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="o">[[</span><span class="p">&lt;</span><span class="s">foo bar ber</span><span class="p">&gt;</span><span class="o">],]</span><span class="p">;</span>
</span></span></code></pre></div><h3 id="小于与单词引用关联索引">小于与单词引用/关联索引</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># WRONG; trying to index 3 associatively: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">3</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span><span class="mi">4</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># RIGHT; prefer some extra whitespace around infix operators: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">3</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">4</span>
</span></span></code></pre></div><h2 id="捕获">捕获</h2>
<h3 id="捕获中的容器与值">捕获中的容器与值</h3>
<h1 id="原文">原文</h1>
<p><a href="https://docs.raku.org/language/traps">https://docs.raku.org/language/traps</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[测试]]></title>
            <link href="http://localhost:1313/rakulang/35.testing/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/34.terms/?utm_source=atom_feed" rel="related" type="text/html" title="项" />
                <link href="http://localhost:1313/rakulang/33.pod-6-tables/?utm_source=atom_feed" rel="related" type="text/html" title="Pod 6 表" />
                <link href="http://localhost:1313/rakulang/32.perl-6-pod/?utm_source=atom_feed" rel="related" type="text/html" title="Raku pod" />
                <link href="http://localhost:1313/rakulang/31.glossary/?utm_source=atom_feed" rel="related" type="text/html" title="术语" />
                <link href="http://localhost:1313/rakulang/30.faq/?utm_source=atom_feed" rel="related" type="text/html" title="FAQ" />
            
                <id>http://localhost:1313/rakulang/35.testing/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-10T21:13:31+08:00</published>
            <updated>2018-11-10T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>测试代码是软件开发不可或缺的一部分。测试提供代码行为的自动，可重复的验证，并确保您的代码按预期工作。</p>
<p>在 Raku 中，<a href="https://docs.raku.org/type/Test">Test</a> 模块提供了一个测试框架，也被 Raku 的官方 spectest 套件使用。</p>
<p>测试函数发出符合 <a href="https://testanything.org/">Test Anything Protocol</a> 的输出。通常，它们用于 sink 上下文中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">ok</span> <span class="nf">check-name</span><span class="p">(</span><span class="nv">$meta</span><span class="o">,</span> <span class="o">:</span><span class="nv">$relaxed-name</span><span class="p">)</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">name has a hyphen rather than &#39;::&#39;</span><span class="p">&#34;</span>
</span></span></code></pre></div><p>但是不论测试成功与否，所有函数都会返回布尔值，如果测试失败，可以使用它来打印消息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">ok</span> <span class="nf">check-name</span><span class="p">(</span><span class="nv">$meta</span><span class="o">,</span> <span class="o">:</span><span class="nv">$relaxed-name</span><span class="p">)</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">name has a hyphen rather than &#39;::&#39;</span><span class="p">&#34;</span> \
</span></span><span class="line"><span class="cl">  <span class="ow">or</span> <span class="nb">diag</span> <span class="p">&#34;</span><span class="se">\n</span><span class="s2">To use hyphen in name, pass :relaxed-name to meta-ok</span><span class="se">\n</span><span class="p">&#34;;</span>
</span></span></code></pre></div><h1 id="写测试httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">写测试</a></h1>
<p>与任何 Perl 项目一样，测试位于项目基本目录的 <code>t</code> 目录下。</p>
<p>典型的测试文件看起来像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="ni">.c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">Test</span><span class="p">;</span>      <span class="c1"># a Standard module included with Rakudo </span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">lib</span> <span class="p">&#39;</span><span class="s1">lib</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">plan</span> <span class="nv">$num-tests</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># .... tests </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">done-testing</span><span class="p">;</span>  <span class="c1"># optional with &#39;plan&#39; </span>
</span></span></code></pre></div><p>我们确保通过 <code>use v6.c</code> 编译指令使用 Raku，然后加载 <code>Test</code> 模块并指定库的位置。然后我们指定我们<em>计划</em>运行多少个测试（这样测试框架可以告诉我们运行的测试是否比我们预期的要多），并且在完成测试后，我们使用<em>完成测试</em>来告诉框架我们已经完成。</p>
<h2 id="线程安全httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">线程安全</a></h2>
<p>请注意，<code>Test</code> 模块中的例程<em>不是</em>线程安全的。这意味着您不应该同时尝试在多个线程中使用测试例程，因为 <a href="https://testanything.org/">TAP</a> 输出可能会出现乱序并且会使解释它的程序迷惑。</p>
<p>目前没有计划使其线程安全。如果线程测试对您至关重要，您可能会发现一些合适的<a href="https://modules.raku.org/search/?q=Test">生态系统模块</a>，代替 <code>Test</code> 来满足您的测试需求。</p>
<h1 id="运行测试httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">运行测试</a></h1>
<p>可以通过在命令行上指定测试文件名来单独运行测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ raku t/test-filename.t
</span></span></code></pre></div><p>或者通过 Perl 5 中的 <a href="https://perldoc.perl.org/prove.html">prove</a> 命令，其中 <code>--exec</code> 用于指定运行测试的可执行文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ prove --exec raku -r t
</span></span></code></pre></div><p>要在第一次失败时中止测试套件，请设置 <code>PERL6_TEST_DIE_ON_FAIL</code> 环境变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ <span class="nv">PERL6_TEST_DIE_ON_FAIL</span><span class="o">=</span><span class="m">1</span> raku t/test-filename.t
</span></span></code></pre></div><p>可以在测试文件中使用相同的变量。在加载 <code>Test</code> 模块之前设置它：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">BEGIN %*ENV&lt;PERL6_TEST_DIE_ON_FAIL&gt; <span class="o">=</span> 1<span class="p">;</span>
</span></span><span class="line"><span class="cl">use Test<span class="p">;</span>
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></div><h1 id="测试计划httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">测试计划</a></h1>
<p>测试计划用 <a href="https://docs.raku.org/type/Test#plan"><code>plan</code></a> 声明将要完成的计划数量，或者可能会跳过的计划数量。如果没有声明计划，<a href="https://docs.raku.org/type/Test#done-testing"><code>done-testing</code></a> 则用于声明测试结束。</p>
<h1 id="测试返回值httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">测试返回值</a></h1>
<p><code>Test</code> 模块导出各种函数，用于检查给定表达式的返回值并生成标准化测试输出。</p>
<p>在实践中，表达式通常是对要进行单元测试的函数或方法的调用。<a href="https://docs.raku.org/type/Test#ok"><code>ok</code></a> 和 <a href="https://docs.raku.org/type/Test#nok"><code>nok</code></a> 将匹配 <code>True</code> 和 <code>False</code>。但是，在可能的情况下，最好使用下面的一个专门的比较测试函数，因为它们可以在比较失败时打印更有用的诊断输出。</p>
<h2 id="通过字符串比较httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">通过字符串比较</a></h2>
<p><a href="https://docs.raku.org/type/Test#is"><code>is</code></a> 和 <a href="https://docs.raku.org/type/Test#isnt"><code>nok</code></a> 使用适当的运算符测试相等性，具体取决于它所处理的对象（或类）。</p>
<h2 id="通过近似数字比较httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">通过近似数字比较</a></h2>
<p><a href="https://docs.raku.org/type/Test#is-approx"><code>is-approx</code></a> 比较具有一定精度的数字，可以是绝对的或相对的。它对于精度取决于内部表示的数值非常有用。</p>
<h2 id="通过结构比较httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">通过结构比较</a></h2>
<p>也可以使用 <a href="https://docs.raku.org/type/Test#is-deeply"><code>is-deeply</code></a> 比较结构，这将检查所比较的对象的内部结构是否相同。</p>
<h2 id="任意比较httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">任意比较</a></h2>
<p>您可以使用 <a href="https://docs.raku.org/type/Test#cmp-ok"><code>cmp-ok</code></a> 进行任何类型的比较，它将您想要用于比较的函数或运算符作为参数。</p>
<h2 id="通过对象类型比较httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">通过对象类型比较</a></h2>
<p><a href="https://docs.raku.org/type/Test#isa-ok"><code>isa-ok</code></a> 测试对象是否属于某种类型。</p>
<h2 id="通过方法名比较httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">通过方法名比较</a></h2>
<p><a href="https://docs.raku.org/type/Test#can-ok"><code>can-ok</code></a> 用于对象以检查它们是否具有该特定方法。</p>
<h2 id="通过角色比较httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">通过角色比较</a></h2>
<ul>
<li>does-ok($variable, $role, $description?)</li>
</ul>
<p><a href="https://docs.raku.org/type/Test#does-ok"><code>does-ok</code></a> 检查给定变量是否可以执行某个<a href="https://docs.raku.org/language/objects#Roles">角色</a>。</p>
<h2 id="通过正则表达式比较httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">通过正则表达式比较</a></h2>
<p><a href="https://docs.raku.org/type/Test#like"><code>like</code></a> 和 <a href="https://docs.raku.org/type/Test#unlike"><code>unlike</code></a> 使用正则表达式检查; 在第一种情况下，如果存在匹配则通过，在第二种情况下则不通过。</p>
<h1 id="测试模块httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">测试模块</a></h1>
<p>用 <a href="https://docs.raku.org/type/Test#use-ok"><code>use-ok</code></a> 实验性地加载模块，如果加载失败则会失败。</p>
<h1 id="测试异常httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">测试异常</a></h1>
<p><a href="https://docs.raku.org/type/Test#dies-ok"><code>dies-ok</code></a> 和 <a href="https://docs.raku.org/type/Test#lives-ok"><code>lives-ok</code></a> 是相反的测试代码的方法; 第一个检查是它抛出异常，第二个检查它不抛出异常; <a href="https://docs.raku.org/type/Test#throws-like"><code>throws-like</code></a> 检查代码是否抛出了作为参数传递的特定异常; <a href="https://docs.raku.org/type/Test#fails-like"><code>fails-like</code></a> 同样，检查代码是否返回特定类型的 <a href="https://docs.raku.org/type/Failure">Failure</a>。<a href="https://docs.raku.org/type/Test#eval-dies-ok"><code>eval-dies-ok</code></a> 和 <a href="https://docs.raku.org/type/Test#eval-lives-ok"><code>eval-lives-ok</code></a> 在测试之前计算的字符串上工作类似。</p>
<h1 id="grouping-testshttpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">Grouping tests</a></h1>
<p>只有在所有子测试都是 <code>ok</code> 的时候, 这组子测试的结果才是 <code>ok</code> 的; 他们按使用 <a href="https://docs.raku.org/type/Test#subtest"><code>subtest</code></a> 分组。</p>
<h1 id="跳过测试httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">跳过测试</a></h1>
<p>有时测试还没准备好运行，例如某个功能可能尚未实现，在这种情况下，测试可以标记为 <a href="https://docs.raku.org/type/Test#todo"><code>todo</code></a>。或者可能是某个特定功能仅适用于特定平台的情况 - 在这种情况下，可以在其他平台上 <a href="https://docs.raku.org/type/Test#skip"><code>skip</code></a> 这个测试; <a href="https://docs.raku.org/type/Test#skip-rest"><code>skip-rest</code></a> 将跳过剩余的测试，而不是跳过作为参数给出的特定数字的测试; <a href="https://docs.raku.org/type/Test#bail-out"><code>bail-out</code></a> 将简单地带着一条消息退出测试。</p>
<h1 id="手动控制httpsdocsrakuorglanguagetesting___top"><a href="https://docs.raku.org/language/testing#___top">手动控制</a></h1>
<p>如果上面记录的便利功能不符合您的需要，您可以使用以下函数手动指导测试套输出; <a href="https://docs.raku.org/type/Test#pass"><code>pass</code></a> 将打印测试已经通过，<a href="https://docs.raku.org/type/Test#diag"><code>diag</code></a> 将打印（可能）信息性消息。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[项]]></title>
            <link href="http://localhost:1313/rakulang/34.terms/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/33.pod-6-tables/?utm_source=atom_feed" rel="related" type="text/html" title="Pod 6 表" />
                <link href="http://localhost:1313/rakulang/32.perl-6-pod/?utm_source=atom_feed" rel="related" type="text/html" title="Raku pod" />
                <link href="http://localhost:1313/rakulang/31.glossary/?utm_source=atom_feed" rel="related" type="text/html" title="术语" />
                <link href="http://localhost:1313/rakulang/30.faq/?utm_source=atom_feed" rel="related" type="text/html" title="FAQ" />
                <link href="http://localhost:1313/rakulang/29.community/?utm_source=atom_feed" rel="related" type="text/html" title="社区" />
            
                <id>http://localhost:1313/rakulang/34.terms/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-09T21:13:31+08:00</published>
            <updated>2018-11-09T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>Raku 中的大部分句法结构能归类为项和操作符. 这儿你能找到各种不同类型的项的概览.</p>
<h2 id="literals">Literals</h2>
<h3 id="int">Int</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="mi">12_300_00</span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="mi">16</span><span class="p">&lt;</span><span class="s">DEAD_BEEF</span><span class="p">&gt;</span>    <span class="c1">#十六进制</span>
</span></span></code></pre></div><p>Int 字面量由数字组成, 并且能在数字之间包含下划线. 使用 <code>:radix&lt;number&gt;</code> 冒号对儿形式能指定 10 进制外的其它进制.</p>
<h3 id="rat---有理数">Rat   有理数</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mf">12.34</span>
</span></span><span class="line"><span class="cl"><span class="mf">1_200.345_678</span>
</span></span></code></pre></div><p>Rat(有理数)字面量由一个点号分割的两部分整数组成. 注意尾部的点号是不允许的, 所以你必须写成 <code>1.0</code> 而非 <code>1.</code> ( 这个规则很重要, 因为有一个以点号开头的中缀操作符, 例如 <code>..</code> 范围操作符 ).</p>
<h3 id="num--浮点数">Num  浮点数</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mf">12.3e-32</span>
</span></span><span class="line"><span class="cl"><span class="mf">3e8</span>
</span></span></code></pre></div><p>Num(浮点数)字面量由 Rat 或 Int 字面量后面再跟着一个字母 e 和 一个指数(可能为负)组成. <code>3e8</code> 使用 值 <code>3* 10**8</code> 构建了一个 Num.</p>
<h3 id="str">Str</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">a string</span><span class="p">&#39;&#39;</span><span class="s1">I</span><span class="se">\</span><span class="s1">&#39;m escaped!</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">I don&#39;t need to be</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">\&#34;But I still can be,\&#34; he said.</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">q</span><span class="p">|</span><span class="s">Other delimiters can be used too!</span><span class="p">|</span>
</span></span></code></pre></div><p>字符串字面量常常使用 <code>'</code> 或 <code>&quot;</code> 创建, 然儿, 字符串在 Raku 中其实是一种强大的子语言.</p>
<h3 id="regex">Regex</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> match some text </span><span class="p">/</span>
</span></span><span class="line"><span class="cl"><span class="k">rx</span><span class="p">/</span><span class="sr">slurp </span><span class="se">\s</span><span class="sr"> rest </span><span class="p">(</span><span class="ni">.</span><span class="o">*</span><span class="p">)</span><span class="sr"> </span><span class="ni">$</span><span class="p">/</span>
</span></span></code></pre></div><p>这两种会产生字面正则</p>
<h3 id="pair">Pair</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="s">identifier</span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="o">!</span><span class="s">identifier</span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="s">identifier</span><span class="p">&lt;</span><span class="s">value</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="s">identifier</span><span class="p">&lt;</span><span class="s">value1 value2</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="s">identifier</span><span class="p">(</span><span class="nv">$value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="s">identifier</span><span class="p">[&#39;</span><span class="s1">val1</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">val2</span><span class="p">&#39;]</span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="s">identifier</span><span class="p">{</span><span class="s">key1</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">val1</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">key2</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">value2</span><span class="p">&#39;}</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span><span class="nv">$item</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span><span class="nv">@array</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span><span class="nv">%hash</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span><span class="nv">&amp;callable</span>
</span></span></code></pre></div><p>Pair 对象的创建要么使用 <code>infix:«=&gt;»</code> (它会自动括起左边, 如果左边是标识符的话), 要么使用各种冒号对儿形式.  那些总是以一个冒号开头的创建形式, 冒号后面要么跟着一个标识符, 要么跟着一个已经存在的变量(不带符号的变量名作为 pair 的键, 变量的值作为 pair 的键值).</p>
<p>在标识符形式的冒号对儿中, 可选的值可以是任意环缀. 如果没有环缀, 那它的值就是 <code>Bool::True</code>. <code>!:identifier</code> 形式的值是 <code>Bool::False</code>.</p>
<p>如果冒号对儿在参数列表中, 所有的冒号对儿都会作为命名参数,   但是 <code>'quoted string' =&gt; $value</code> 除外.</p>
<h3 id="parcel">Parcel</h3>
<p>什么是 Parcel? -&gt; Immutable sequence of values - 不可变值的序列.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">calss</span> <span class="n">Parcel</span> <span class="k">is</span> <span class="kt">Cool</span> <span class="k">does</span> <span class="kt">Positional</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></div><p>Parcel 代表 <code>Parenthesis cell</code>, 例如, 被圆括号环绕的表达式. 除了空的 parcel 之外, 实际上是使用逗号来创建一个 Parcel.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># not a Parcel</span>
</span></span><span class="line"><span class="cl"><span class="p">()</span>       <span class="c1"># empty Parcel</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="p">)</span>     <span class="c1"># Parcel with one element</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="p">)</span>    <span class="c1"># Parcel with two element</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span>  <span class="c1"># parenthesis are optional</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span>  <span class="c1"># word-quoting</span>
</span></span><span class="line"><span class="cl"><span class="p">«</span><span class="s2">a b c</span><span class="p">»</span>  <span class="c1"># also word-quoting</span>
</span></span><span class="line"><span class="cl"><span class="k">q</span><span class="sa">w</span><span class="p">/</span><span class="s">a b c</span><span class="p">/</span>
</span></span></code></pre></div><p>Parcel 字面量有: 空的圆括号 (),  逗号分割的列表, 还有几种引号结构.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">WHAT</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">Parcel</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">WHAT</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">Parcel</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="nb">say</span> <span class="p">«</span><span class="s2">a b c</span><span class="p">»</span><span class="o">.</span><span class="nb">WHAT</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">Parcel</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="nb">say</span> <span class="p">(</span><span class="k">q</span><span class="sa">w</span><span class="p">/</span><span class="s">a b c</span><span class="p">/)</span><span class="o">.</span><span class="nb">WHAT</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">Parcel</span><span class="p">)</span>
</span></span></code></pre></div><p>Parcels 是不可变的, 但是能包含可变容器:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$p</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="nv">$x</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1"># can assign to $p[1], but not</span>
</span></span><span class="line"><span class="cl">                    <span class="c1"># to any other element of $p</span>
</span></span></code></pre></div><p>像 <code>&lt;...&gt;</code> 这种 <code>Word-quoting</code> 结构也会创建 parcels:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="c1"># 3-element Parcel</span>
</span></span></code></pre></div><p>在 flattening 列表上下文中, parcels 被展平并且会消失:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@flat</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&lt;</span><span class="s">c, d</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@flat</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
</span></span></code></pre></div><h3 id="term-">term *</h3>
<p><code>*</code> 会创建一个类型为 Whatever 的对象. 详情查看 <a href="http://doc.raku.org/type/Whatever">Whatever</a>.</p>
<h2 id="identifier-terms">Identifier terms</h2>
<p>Raku中有内建的标识符项, 列出如下. 此外, 使用该语法能添加新的标识符项.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">term</span><span class="o">:</span><span class="p">&lt;</span><span class="s">fourty-two</span><span class="p">&gt;</span> <span class="p">{</span> <span class="mi">42</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">fourty-two</span>
</span></span></code></pre></div><p>或者作为常量:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">constant</span> <span class="no">forty-two</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">fourty-two</span>
</span></span></code></pre></div><h3 id="self">self</h3>
<p>在方法中, self 指向方法的调用者( 例如, 方法被调用的对象). 如果把它用在没有意义的上下文中, 会抛出一个 <code> X::Syntax::NoSelf</code> 类型的编译时错误.</p>
<h3 id="now">now</h3>
<p>返回一个代表当前时间的实例对象.</p>
<h3 id="rand">rand</h3>
<p>返回一个范围为 <code>0..^1</code>的伪随机浮点数.</p>
<h3 id="pi">pi</h3>
<p>返回数值 pi, 例如, 圆的周长和半径之间的比率.</p>
<h3 id="e">e</h3>
<p>返回欧拉数值.</p>
<h3 id="i">i</h3>
<p>返回复数的虚部.</p>
<h2 id="variables">Variables</h2>
<p>变量在变量语言文档中讨论.</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Pod 6 表]]></title>
            <link href="http://localhost:1313/rakulang/33.pod-6-tables/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/32.perl-6-pod/?utm_source=atom_feed" rel="related" type="text/html" title="Raku pod" />
                <link href="http://localhost:1313/rakulang/31.glossary/?utm_source=atom_feed" rel="related" type="text/html" title="术语" />
                <link href="http://localhost:1313/rakulang/30.faq/?utm_source=atom_feed" rel="related" type="text/html" title="FAQ" />
                <link href="http://localhost:1313/rakulang/29.community/?utm_source=atom_feed" rel="related" type="text/html" title="社区" />
                <link href="http://localhost:1313/rakulang/28.about-the-docs/?utm_source=atom_feed" rel="related" type="text/html" title="关于文档" />
            
                <id>http://localhost:1313/rakulang/33.pod-6-tables/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-08T21:13:31+08:00</published>
            <updated>2018-11-08T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>Raku POD 表的官方规范位于文档规范中：<a href="https://raw.githubusercontent.com/raku/specs/master/S26-documentation.pod">表</a>。虽然 Pod 6 的规格尚未完全妥善处理，但仍有几个项目正在进行纠正。一个这样的项目是确保正确处理 Pod 6 表。</p>
<p>作为该工作的一部分，本文档通过示例解释了 Pod 6 表的当前状态：有效表，无效表和丑陋表（即，由于草率构造，可能导致与用户期望的不同的有效表） 。</p>
<h1 id="restrictionshttpsdocsrakuorglanguagetables___top"><a href="https://docs.raku.org/language/tables#___top">Restrictions</a></h1>
<p>1.唯一有效的列分隔符要么是可见的（<code>|</code> 或 <code>+</code>）（注意在可见列分隔符之前和之后至少需要一个空格）或不可见[两个或多个连续的空格（WS）字符（例如， &rsquo;  &lsquo;）]。在表格的左侧或右侧通常不会识别列分隔符，但是右侧的列分隔符可能会导致一个或多个空单元格，具体取决于其他行中单元格的数量。（请注意，作为单元格数据一部分的管道或加号字符将导致意外的额外列，除非使用反斜杠转义字符，例如 <code>\|</code> 或 <code>\+</code>。）</p>
<p>2.在同一个表中混合可见和不可见的列分隔符是非法的。</p>
<p>3.唯一有效的行分隔符字符是 <code>_</code>，<code>-</code>，<code>+</code>，<code>' '</code>，<code>|</code> 和 <code>=</code>。</p>
<p>4.连续的内部行分隔符是非法的。</p>
<p>5.前导和尾随行分隔符会生成警告。</p>
<p>6.当前忽略表格单元格中的格式，并将其视为纯文本。</p>
<p>提示：在开发过程中，使用环境变量 <code>RAKUDO_POD6_TABLE_DEBUG</code> 将向您展示 Rakudo 如何在将 pod 表传递给渲染器之前解释它们，例如 <strong>Pod::To::HTML</strong>，<strong>Pod::To::Text</strong> 和 <strong>Pod::To::Markdown</strong>。</p>
<h1 id="最佳实践httpsdocsrakuorglanguagetables___top"><a href="https://docs.raku.org/language/tables#___top">最佳实践</a></h1>
<p>提示：由于在表行上进行额外的循环，不遵循以下最佳实践可能需要更多的表处理。</p>
<p>1.对列分隔符使用 WS 很脆弱，它们只能用于简单表。以下 <code>Ugly Tables</code> 部分说明了这个问题。</p>
<p>2.仔细对齐表格列和行。请参阅后面的最佳实践中的示例。</p>
<p>3.不要在表上使用可见的边框。</p>
<p>4.对于具有标题和单行或多行内容的表，在标题后使用一个或多个连续的等号（&rsquo;=&rsquo;）作为行分隔符，并使用一个或多个连续的连字符（&rsquo;-&rsquo;）作为表的内容部分中的行分隔符。例如，</p>
<ul>
<li>标题和单行或多行内容</li>
</ul>
<pre tabindex="0"><code class="language-pod" data-lang="pod">=begin table
 hdr col 0 | hdr col 1
 ======================
 row 0     | row 0
 col 0     | col 1
 ----------------------
 row 1     | row 1
 col 0     | col 1
 ----------------------
=end table
</code></pre><ul>
<li>标题和单行内容</li>
</ul>
<pre tabindex="0"><code class="language-pod" data-lang="pod">=begin table
 hdr col 0   | hdr col 1
 ======================
 row 0 col 0 | row 0 col 1
 row 1 col 0 | row 1 col 1
=end table
</code></pre><p>5.对于没有标题和多行内容的表，请使用一个或多个连续连字符（&rsquo;-&rsquo;）作为表格内容部分中的行分隔符。例如，</p>
<pre tabindex="0"><code class="language-pod" data-lang="pod">=begin table
 row 0       | row 0
 col 0       | col 1
 ----------------------
 row 1 col 0 | row 1 col 1
=end table
</code></pre><p>6.对于具有许多行且没有多行内容的表，不使用行分隔符就可以了。但是，如果一行或多行包含多行内容，则通过在每个内容行之间使用行分隔线（可见或不可见）来确保正确的结果更容易。</p>
<p>7.确保故意空单元格具有列分隔符，否则会出现关于短行填充空单元格的警告。（表行总是与具有最多单元格的行具有相同数量的单元格。右边用空单元格填充短行并生成警告。）</p>
<p>8.此示例中使用的 <code>=begin table</code> 行可以为表添加标题：</p>
<pre tabindex="0"><code class="language-pod" data-lang="pod">=begin table :caption&lt;My Tasks&gt;
mow lawn
take out trash
=end table
</code></pre><p>虽然不是一个好的做法，但目前正在使用另一种定义标题的方法，如下例所示：</p>
<pre tabindex="0"><code class="language-pod" data-lang="pod">=begin table :config{caption =&gt; &#34;My Tasks&#34;}
mow lawn
take out trash
=end table
</code></pre><p>请注意，把标题放在 <code>config</code> 哈希中的替代方法必须在实现 <code>:caption</code> 方法之前，但现在认为该方法已被弃用。该练习将在已经发布的 <code>6.d</code> 版本中生成警告，并将在 <code>6.e</code> 版本中引发异常。</p>
<h1 id="good-tableshttpsdocsrakuorglanguagetables___top"><a href="https://docs.raku.org/language/tables#___top">Good tables</a></h1>
<p>以下是有效（好）表的示例（取自当前的<a href="https://github.com/raku/roast">规范测试</a>）。</p>
<pre tabindex="0"><code class="language-pod" data-lang="pod">=begin table
        The Shoveller   Eddie Stevens     King Arthur&#39;s singing shovel
        Blue Raja       Geoffrey Smith    Master of cutlery
        Mr Furious      Roy Orson         Ticking time bomb of fury
        The Bowler      Carol Pinnsler    Haunted bowling ball
=end table
=table
    Constants           1
    Variables           10
    Subroutines         33
    Everything else     57
 
=for table
    mouse    | mice
    horse    | horses
    elephant | elephants
 
=table
    Animal | Legs |    Eats
    =======================
    Zebra  +   4  + Cookies
    Human  +   2  +   Pizza
    Shark  +   0  +    Fish
 
=table
        Superhero     | Secret          |
                      | Identity        | Superpower
        ==============|=================|================================
        The Shoveller | Eddie Stevens   | King Arthur&#39;s singing shovel
 
=begin table
 
                        Secret
        Superhero       Identity          Superpower
        =============   ===============   ===================
        The Shoveller   Eddie Stevens     King Arthur&#39;s
                                          singing shovel
 
        Blue Raja       Geoffrey Smith    Master of cutlery
 
        Mr Furious      Roy Orson         Ticking time bomb
                                          of fury
 
        The Bowler      Carol Pinnsler    Haunted bowling ball
 
=end table
=table
    X | O |
   ---+---+---
      | X | O
   ---+---+---
      |   | X
 
=table
    X   O
   ===========
        X   O
   ===========
            X
 
=begin table
 
foo
bar
 
=end table
</code></pre><h1 id="bad-tableshttpsdocsrakuorglanguagetables___top"><a href="https://docs.raku.org/language/tables#___top">Bad tables</a></h1>
<p>以下是无效（坏）表的示例，它们应在解析期间触发未处理异常。</p>
<ul>
<li>同一行中不允许混合列分隔符类型：</li>
</ul>
<pre tabindex="0"><code class="language-pod" data-lang="pod">=begin table
r0c0 +  r0c1 | r0c3
=end table
</code></pre><ul>
<li>同一个表中不允许使用混合的可见和空格列分隔符类型：</li>
</ul>
<pre tabindex="0"><code class="language-pod" data-lang="pod">=begin table
r0c0 +  r0c1 | r0c3
r1c0    r0c1   r0c3
=end table
</code></pre><ul>
<li>不允许连续两个行内分隔符：</li>
</ul>
<pre tabindex="0"><code class="language-pod" data-lang="pod">=begin table
r0c0 |  r0c1
============
============
r1c0 |  r1c1
=end table
</code></pre><h1 id="ugly-tableshttpsdocsrakuorglanguagetables___top"><a href="https://docs.raku.org/language/tables#___top">Ugly tables</a></h1>
<p>以下是有效表可能是两列的示例，但列未对齐，因此每个列都将解析为单列表。</p>
<ul>
<li>带 WS 列分隔符的未对齐列：</li>
</ul>
<p>请注意，第二行的两个单词仅由<strong>一个</strong> WS 字符分隔，而至少需要<strong>两个</strong>相邻的 WS 字符才能定义列分隔。<strong>这是一个有效的表，但将被解析为单列表</strong>。</p>
<pre tabindex="0"><code class="language-pod" data-lang="pod">=begin table
r0c0    r0c1
 r1c0 r0c1
=end table
</code></pre><ul>
<li>带有可见列分隔符的未对齐列：</li>
</ul>
<p>请注意，第二行有两个单词由可见字符（<code>|</code>）分隔，但该字符不会被识别为列分隔符，因为它的两边都没有相邻的 WS 字符。虽然这是一个合法的表，但结果将不是用户的意图，因为第一行有两列，而第二行只有一列，因此它将有一个空的第二列。</p>
<pre tabindex="0"><code class="language-pod" data-lang="pod">=begin table
r0c0  |  r0c1
 r1c0 |r0c1
=end table
</code></pre>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku pod]]></title>
            <link href="http://localhost:1313/rakulang/32.perl-6-pod/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/31.glossary/?utm_source=atom_feed" rel="related" type="text/html" title="术语" />
                <link href="http://localhost:1313/rakulang/30.faq/?utm_source=atom_feed" rel="related" type="text/html" title="FAQ" />
                <link href="http://localhost:1313/rakulang/29.community/?utm_source=atom_feed" rel="related" type="text/html" title="社区" />
                <link href="http://localhost:1313/rakulang/28.about-the-docs/?utm_source=atom_feed" rel="related" type="text/html" title="关于文档" />
                <link href="http://localhost:1313/rakulang/27.regexes-best-practices-and-gotchas/?utm_source=atom_feed" rel="related" type="text/html" title="正则表达式最佳实践" />
            
                <id>http://localhost:1313/rakulang/32.perl-6-pod/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-07T21:13:31+08:00</published>
            <updated>2018-11-07T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>Raku Pod 是一种易于使用的标记语言。 Pod 可用于编写语言文档，用于文档化程序和模块，以及其他类型的文档组合。</p>
<p>每个 Pod 文档必须以 <code>=begin pod</code> 开头，以 <code>=end pod</code> 结束。这两个分隔符之间的所有内容都将被处理并用于生成文档。</p>
<pre tabindex="0"><code>=begin pod
 
A very simple Raku Pod document
 
=end pod
</code></pre><h2 id="块结构">块结构</h2>
<p>Pod 文档可能包含多个 Pod 块。有四种方法可以定义块（分隔符，段落，缩写和声明符）; 前三个产生相同的结果，但第四个不同。你可以使用最方便你的特定文档任务的任何形式。</p>
<h3 id="分割符块">分割符块</h3>
<p>分隔块由 <code>=begin</code> 和 <code>=end</code> 标记限定，两者都后跟有效的 Raku 标识符，后者是块的 <code>typename</code>。完全小写的类型名称（例如 <code>=begin head1</code>）或完全大写（例如：<code>=begin SYNOPSIS</code>）保留。</p>
<pre tabindex="0"><code>=begin head1
Top Level Heading
=end head1
</code></pre><h2 id="配置信息">配置信息</h2>
<p>在 typename 之后， <code>=begin</code> 标记行的其余部分被视为块的配置信息。此信息由不同类型的块以不同方式使用，但始终使用 Raku-ish 选项对指定。也就是说，任何：</p>
<table>
<thead>
<tr>
<th style="text-align:center">alue is&hellip;</th>
<th style="text-align:center">Specify with&hellip;</th>
<th style="text-align:center">Or with&hellip;</th>
<th style="text-align:center">Or with&hellip;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">List</td>
<td style="text-align:center">:key[$e1, $e2, &hellip;]</td>
<td style="text-align:center">:key($e1, $e2, &hellip;)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Hash</td>
<td style="text-align:center">:key{$k1=&gt;$v1, $k2=&gt;$v2}</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Boolean (true)</td>
<td style="text-align:center">:key</td>
<td style="text-align:center">:key(True)</td>
<td style="text-align:center">:key[True]</td>
</tr>
<tr>
<td style="text-align:center">Boolean (false)</td>
<td style="text-align:center">:!key</td>
<td style="text-align:center">:key(False)</td>
<td style="text-align:center">:key[False]</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">:key<!-- raw HTML omitted --></td>
<td style="text-align:center">:key(&lsquo;str&rsquo;)</td>
<td style="text-align:center">:key(&ldquo;str&rdquo;)</td>
</tr>
<tr>
<td style="text-align:center">Int</td>
<td style="text-align:center">:key(42)</td>
<td style="text-align:center">:key[42]</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">:key(2.3)</td>
<td style="text-align:center">:key[2.3]</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>其中&rsquo;$e1，$e2，&hellip;&lsquo;是 String，Int，Number 或 Boolean 类型的列表元素。列表可能具有混合元素类型。请注意，单元素列表将转换为其元素的类型（String，Int，Number 或 Boolean）。另请注意，如果需要，可以使用“bigints”。</p>
<p>对于散列，&rsquo;$k1，$k2，&hellip;&lsquo;是 Str 类型的键，&rsquo;$v1，$2，&hellip;&lsquo;是 String，Int，Number 或 Boolean 类型的值。</p>
<p>字符串由单引号或双引号分隔。空格在字符串之外是微不足道的。散列键不需要引用分隔，除非它们包含重要的空格。</p>
<p>当然，所有选项键和值必须是常量，因为Pod是一种规范语言，而不是编程语言。具体来说，选项值不能是闭包。有关各种Raku对符号的详细信息，请参见概要2。</p>
<p>配置部分可以通过在第一（虚拟）列中带有=后跟空白字符的那些行开始在后续行上扩展。 （注意：此功能尚未实现。当前所有配置信息必须与= begin标记行在同一行提供，或=为段落块的名称提供。）</p>
<h3 id="段落块">段落块</h3>
<p>段落块以 <code>=for</code> 标记开始，以下一个 Pod 指令或第一个空行结束。 <code>=for</code> 标记后面跟着块的类型名加上，可选地，跟上面描述的分隔块中的任何配置数据。</p>
<pre tabindex="0"><code>=for head1
Top Level Heading
</code></pre><h2 id="缩写块">缩写块</h2>
<p>缩写块以 <code>=</code> 符号开头，紧接着是块的类型名称。以下所有数据都是块内容的一部分，因此无法为缩写块指定配置数据。该块在下一个Pod指令或第一个空行结束。</p>
<pre tabindex="0"><code>=head1 Top Level Heading 
</code></pre><h2 id="声明器块">声明器块</h2>
<p>声明器块与其他声明块不同，没有特定类型，而是附加到某些源代码。</p>
<p>声明器块由特殊注释引入：<code>#=</code> 或 <code>#|</code>，必须紧跟空格或左括号。如果后跟一个空格，则该块在行尾终止;如果后跟一个或多个左括号，则该块由关闭括号的匹配序列终止。</p>
<p>以＃开头的块附加到它们之后的代码，以 <code>#=</code> 开头的块附加到它们之前的代码。</p>
<p>由于声明器块附加到源代码，因此它们可用于记录类，角色，子例程等。</p>
<p>WHY方法可用于这些类，角色，子例程等，以返回附加的 Pod 值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">Base class for magicians 
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">class</span> <span class="nc">Magician</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">has</span> <span class="kt">Int</span> <span class="nv">$.level</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">has</span> <span class="kt">Str</span> <span class="nv">@.spells</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">Fight mechanics 
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">sub</span> <span class="nf">duel</span><span class="p">(</span><span class="n">Magician</span> <span class="nv">$a</span><span class="o">,</span> <span class="n">Magician</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">#= </span><span class="sd">Magicians only, no mortals. 
</span></span></span><span class="line"><span class="cl"><span class="sd"></span> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Magician</span><span class="o">.</span><span class="nb">WHY</span><span class="p">;</span> <span class="c1"># OUTPUT: «Base class for magicians␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">&amp;duel</span><span class="o">.</span><span class="nb">WHY</span><span class="o">.</span><span class="nb">leading</span><span class="p">;</span> <span class="c1"># OUTPUT: «Fight mechanics␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">&amp;duel</span><span class="o">.</span><span class="nb">WHY</span><span class="o">.</span><span class="nb">trailing</span><span class="p">;</span> <span class="c1"># OUTPUT: «Magicians only, no mortals.␤» </span>
</span></span></code></pre></div><p>这些声明可以扩展多个块：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">#|</span><span class="p">(</span><span class="sd"> This is an example of stringification: 
</span></span></span><span class="line"><span class="cl"><span class="sd">    * Numbers turn into strings
</span></span></span><span class="line"><span class="cl"><span class="sd">    * Regexes operate on said strings
</span></span></span><span class="line"><span class="cl"><span class="sd">    * </span><span class="k">C</span><span class="p">&lt;</span><span class="sx">with</span><span class="p">&gt;</span><span class="sd"> topicalizes and places result into $_
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">search-in-seq</span><span class="p">(</span> <span class="kt">Int</span> <span class="nv">$end</span><span class="o">,</span> <span class="kt">Int</span> <span class="nv">$number</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">with</span> <span class="p">(</span><span class="o">^</span><span class="nv">$end</span><span class="p">)</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span> <span class="p">/</span><span class="ni">^</span><span class="nv">$number</span><span class="p">/</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">$_</span><span class="o">&lt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">#=</span><span class="p">«</span><span class="sd"> Uses 
</span></span></span><span class="line"><span class="cl"><span class="sd">    * topic
</span></span></span><span class="line"><span class="cl"><span class="sd">    * decont operator
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="p">»</span>
</span></span></code></pre></div><p>通过使用匹配的括号构造对，例如 <code>()</code> 或 <code>«»</code>，注释可以扩展多行。但是，这种格式不会转换为 <code>raku -doc</code> 的多行显示。</p>
<h2 id="块类型">块类型</h2>
<p>Pod提供多种标准块类型。</p>
<h3 id="标题">标题</h3>
<p>可以使用= headN来定义标题，其中N大于零（例如，= head1，= head2，&hellip;）。</p>
<pre tabindex="0"><code>=head1 A Top Level Heading 
 
=head2 A Second Level Heading 
 
=head3 A Third Level Heading 
</code></pre><h3 id="普通段落">普通段落</h3>
<p>普通段落由在当前嵌套级别格式化为文档的文本组成，其中空格被挤压，线条填充，并且应用了任何特殊的内联标记。</p>
<p>普通段落由一个或多个连续的文本行组成，每行文本以非空白字符开头。段落由第一个空行或块指令终止。</p>
<p>例如：</p>
<pre tabindex="0"><code>=head1 This is a heading block 
 
This is an ordinary paragraph.
Its text  will   be     squeezed     and
short lines filled. It is terminated by
the first blank line.
 
This is another ordinary paragraph.
Its     text    will  also be squeezed and
short lines filled. It is terminated by
the trailing directive on the next line.
 
=head2 This is another heading block 
 
This is yet another ordinary paragraph,
at the first virtual column set by the
previous directive
</code></pre><p>普通段落不需要明确的标记或分隔符。</p>
<p>或者，还有一个显式的 <code>=para</code> 标记，可用于明确标记段落。</p>
<pre tabindex="0"><code>=para
This is an ordinary paragraph.
Its text  will   be     squeezed     and
short lines filled.
</code></pre><p>另外，可以使用较长 <code>= begin para</code> 和 <code>=end para</code> 形式。</p>
<p>例如：</p>
<pre tabindex="0"><code>=begin para
This is an ordinary paragraph.
Its text  will   be     squeezed     and
short lines filled.
 
This is still part of the same paragraph,
which continues until an...
=end para
</code></pre><p>如前面的示例所示，在分隔 <code>=begin para</code> 和 <code>=end para</code> 块中，保留任何空行。</p>
<h2 id="代码块">代码块</h2>
<p>代码块用于指定源代码，应该在没有重新调整的情况下进行渲染，不需要空格压缩，也不需要识别任何内联格式代码。通常，这些块用于显示代码，标记或其他文本规范的示例，并使用固定宽度字体进行渲染。</p>
<p>代码块可以隐式地指定为一行或多行文本，每行文本以空白字符开头。然后通过空行终止隐式代码块。</p>
<p>例如：</p>
<pre tabindex="0"><code>This ordinary paragraph introduces a code block:
 
    my $name = &#39;John Doe&#39;;
    say $name;
</code></pre><p>代码块也可以通过将它们包含在= begin code和= end code中来显式定义</p>
<pre tabindex="0"><code>   =begin code
    my $name = &#39;John Doe&#39;;
    say $name;
   =end code
</code></pre><h2 id="io-块">I/O 块</h2>
<p>Pod 提供用于指定程序输入和输出的块。</p>
<p><code>=input</code> 块用于指定预先格式化的键盘输入，应该在不重新对齐或挤压空格的情况下进行渲染。</p>
<p><code>=output</code> 块用于指定预先格式化的终端或文件输出，也应该在没有重新调整或空白压缩的情况下进行渲染。</p>
<h2 id="列表">列表</h2>
<h3 id="无序列表">无序列表</h3>
<p>Pod 中的列表被指定为一系列 <code>=item</code> 块。</p>
<p>例如：</p>
<pre tabindex="0"><code>The three suspects are:
 
=item  Happy 
=item  Sleepy 
=item  Grumpy 
</code></pre><p>三名嫌犯是：</p>
<ul>
<li>Happy</li>
<li>Sleepy</li>
<li>Grumpy</li>
</ul>
<h3 id="定义列表">定义列表</h3>
<p>定义术语或命令的列表使用 <code>=defn</code>，等同于 HTML 中的 DL 列表</p>
<pre tabindex="0"><code>=defn Happy 
When you&#39;re not blue.
 
=defn blue 
When you&#39;re not happy.
</code></pre><p>将以这种方式呈现：</p>
<p>Happy When you&rsquo;re not blue.</p>
<p>Blue When you&rsquo;re not happy.</p>
<p>目前，它可能是一个简单的HTML段落，但将来可能会发生变化。</p>
<h3 id="多层级列表">多层级列表</h3>
<p>列表可以是多级的，使用 <code>=item1</code>，<code>=item2</code>，<code>=item3</code> 等块指定每个级别的项目。</p>
<p>请注意，<code>=item</code> 只是 <code>=item1</code> 的缩写。</p>
<p>例如：</p>
<pre tabindex="0"><code>=item1  Animal 
=item2     Vertebrate 
=item2     Invertebrate 
 
=item1  Phase 
=item2     Solid 
=item2     Liquid 
=item2     Gas 
</code></pre><ul>
<li>
<p>Animal</p>
</li>
<li>
<p>Vertebrate</p>
</li>
<li>
<p>Invertebrate</p>
</li>
<li>
<p>Phase</p>
</li>
<li>
<p>Solid</p>
</li>
<li>
<p>Liquid</p>
</li>
<li>
<p>Gas</p>
</li>
</ul>
<h3 id="多段落列表">多段落列表</h3>
<p>使用 <code>=item</code> 块（ <code>=begin item</code> 和 <code>=end item</code> ）的分隔形式，我们可以指定包含多个段落的项目。</p>
<p>例如：</p>
<pre tabindex="0"><code>Let&#39;s consider two common proverbs:
 
=begin item
I&lt;The rain in Spain falls mainly on the plain.&gt;
 
This is a common myth and an unconscionable slur on the Spanish
people, the majority of whom are extremely attractive.
=end item
 
=begin item
I&lt;The early bird gets the worm.&gt;
 
In deciding whether to become an early riser, it is worth
considering whether you would actually enjoy annelids
for breakfast.
=end item
 
As you can see, folk wisdom is often of dubious value.
</code></pre><p>让我们考虑两个常见的谚语：</p>
<ul>
<li>The rain in Spain falls mainly on the plain.</li>
</ul>
<p>This is a common myth and an unconscionable slur on the Spanish people, the majority of whom are extremely attractive.</p>
<ul>
<li>The early bird gets the worm.</li>
</ul>
<p>In deciding whether to become an early riser, it is worth considering whether you would actually enjoy annelids for breakfast.</p>
<p>正如你所看到的，民间智慧往往具有可疑的价值。</p>
<h2 id="表">表</h2>
<p>查看此页面以获取与<a href="https://docs.raku.org/language/tables">表</a>相关的文档</p>
<h2 id="pod-注释">Pod 注释</h2>
<p>Pod评论是Pod渲染器忽略的评论。</p>
<p>注释对于元文档（记录文档）很有用。单行注释使用comment关键字：</p>
<pre tabindex="0"><code>=comment Add more here about the algorithm 
</code></pre><p>对于多行注释，请使用带分隔符的注释块：</p>
<pre tabindex="0"><code>=begin comment
This comment is
multi-line.
=end comment
</code></pre><h2 id="语义块">语义块</h2>
<p>所有大写块类型名称都保留用于指定标准文档，发布，源组件或元信息。</p>
<pre tabindex="0"><code>=NAME
=AUTHOR
=VERSION
=TITLE
=SUBTITLE
</code></pre><h2 id="格式化代码">格式化代码</h2>
<p>格式代码提供了一种向一段文本添加内联标记的方法。
所有Pod格式代码都包含一个大写字母，紧接着是一组尖括号。
格式代码可以嵌套其他格式代码。</p>
<h3 id="粗体">粗体</h3>
<p>要以粗体格式化文本，请将其括在 <code>B&lt; &gt;</code> 中</p>
<pre tabindex="0"><code>Raku is B&lt;awesome&gt;
</code></pre><p>Raku is <strong>awesome</strong></p>
<h3 id="斜体">斜体</h3>
<p>要用斜体格式化文本，请将其括在 <code>I&lt; &gt;</code>中</p>
<pre tabindex="0"><code>Raku is I&lt;awesome&gt;
</code></pre><p>Raku is <em>awesome</em></p>
<h3 id="下划线">下划线</h3>
<p>要在文本下划线将其括在 <code>U&lt;&gt;</code> 中</p>
<pre tabindex="0"><code>Raku is U&lt;awesome&gt;
</code></pre><h3 id="代码">代码</h3>
<p>要将文本标记为代码并将其逐字处理，请将其括在 <code>C&lt; &gt;</code> 中</p>
<pre tabindex="0"><code>C&lt;my $var = 1; say $var;&gt;
</code></pre><p><code>my $var = 1; say $var;</code></p>
<h3 id="链接">链接</h3>
<p>要创建链接，请将其括在 <code>L&lt; &gt;</code> 中</p>
<pre tabindex="0"><code>Raku homepage L&lt;https://raku.org&gt;
L&lt;Raku homepage|https://raku.org&gt;
</code></pre><p>Raku homepage <a href="https://raku.org/">https://raku.org</a></p>
<p><a href="https://raku.org/">Raku homepage</a></p>
<p>要创建指向同一文档中某个部分的链接：</p>
<pre tabindex="0"><code>Comments L&lt;#Comments&gt;
</code></pre><p>Comments <a href="https://docs.raku.org/language/pod#Comments">Comments</a></p>
<h3 id="注释">注释</h3>
<p>注释是从不呈现的文本。</p>
<p>要创建注释，请将其括在 <code>Z&lt; &gt;</code> 中</p>
<pre tabindex="0"><code>Raku is awesome Z&lt;Of course it is!&gt;
</code></pre><p>Raku is awesome</p>
<h3 id="笔记">笔记</h3>
<p>注释呈现为脚注。</p>
<p>要创建一个注释，请将其括在 <code>N&lt; &gt;</code> 中</p>
<pre tabindex="0"><code>Raku is multi-paradigmatic N&lt;Supporting Procedural, Object Oriented, and Functional programming&gt;
</code></pre><h3 id="键盘输入">键盘输入</h3>
<p>要将文本标记为键盘输入，请将其括在 <code>K&lt; &gt;</code> 中</p>
<pre tabindex="0"><code>Enter your name K&lt;John Doe&gt;
</code></pre><h3 id="终端输出">终端输出</h3>
<p>要将文本标记为终端输出，请将其括在 <code>T&lt; &gt;</code> 中</p>
<pre tabindex="0"><code>Hello T&lt;John Doe&gt;
</code></pre><h3 id="unicode">Unicode</h3>
<p>要在 Pod 文档中包含 Unicode 代码点或 HTML5 字符引用，请将它们包含在 <code>E&lt; &gt;</code>中</p>
<p><code>E&lt; &gt;</code>可以包含一个数字，该数字被视为所需代码点的十进制 Unicode 值。它还可以使用 Raku 表示法为显式数字括起显式二进制，八进制，十进制或十六进制数字。</p>
<pre tabindex="0"><code>Raku makes considerable use of the E&lt;171&gt; and E&lt;187&gt; characters.
 
Raku makes considerable use of the E&lt;laquo&gt; and E&lt;raquo&gt; characters.
 
Raku makes considerable use of the E&lt;0b10101011&gt; and E&lt;0b10111011&gt; characters.
 
Raku makes considerable use of the E&lt;0o253&gt; and E&lt;0o273&gt; characters.
 
Raku makes considerable use of the E&lt;0d171&gt; and E&lt;0d187&gt; characters.
 
Raku makes considerable use of the E&lt;0xAB&gt; and E&lt;0xBB&gt; characters.
</code></pre><p>Raku makes considerable use of the « and » characters.</p>
<h2 id="渲染-pod">渲染 Pod</h2>
<h3 id="html">HTML</h3>
<p>要从 Pod 生成 HTML，你需要 <code>Pod::To::HTML</code> 模块。</p>
<p>如果尚未安装，请通过运行以下命令进行安装：<code>zef install Pod::To::HTML</code></p>
<p>使用终端运行以下命令：</p>
<pre tabindex="0"><code>raku --doc=HTML input.pod6 &gt; output.html
</code></pre><h3 id="markdown">Markdown</h3>
<p>要从 Pod 生 Markdown，你需要 <code>Pod::To::Markdown</code> 模块。</p>
<p>如果尚未安装，请通过运行以下命令进行安装：<code>zef install Pod::To::Markdown</code></p>
<p>使用终端运行以下命令：</p>
<pre tabindex="0"><code>raku --doc=Markdown input.pod6 &gt; output.md
</code></pre><h3 id="text">Text</h3>
<p>为了从 Pod 生成 Text，你可以使用默认的 <code>Pod::To::Text</code> 模块。</p>
<p>使用终端，运行以下命令：</p>
<pre tabindex="0"><code>raku --doc=Text input.pod6 &gt; output.txt
</code></pre><p>你可以省略 <code>=Text</code> 部分：</p>
<pre tabindex="0"><code>raku --doc input.pod6 &gt; output.txt
</code></pre><p>你甚至可以将 Pod 直接嵌入到你的程序中，并使用 multi MAIN 子例程将传统的 Unix 命令行 &ldquo;&ndash;man&rdquo; 选项添加到你的程序中，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Bool</span> <span class="o">:</span><span class="nv">$man</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">run</span> <span class="vg">$*EXECUTABLE</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">--doc</span><span class="p">&#39;</span><span class="o">,</span> <span class="vg">$*PROGRAM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>现在 <code>myprogram --man</code> 将输出你的 Pod 渲染为手册页。</p>
<h2 id="访问-pod">访问 Pod</h2>
<p>为了从 Raku 程序中访问 Pod 文档，需要使用特殊的 <code>=</code> twigil，如<a href="https://docs.raku.org/language/variables#The_%3D_Twigil">变量部分</a>所述。</p>
<p>= twigil 提供了对 Pod 结构的内省，提供了一个 <a href="https://docs.raku.org/type/Pod::Block">Pod::Block</a> 树根，从中可以访问 Pod 文档的整个结构。</p>
<p>例如，以下代码内省了自己的Pod文档：</p>
<pre tabindex="0"><code>=begin pod
 
=head1 This is an head1 title 
 
This is a paragraph.
 
=head2 Subsection 
 
Here some text for the subsection.
 
=end pod
 
for $=pod -&gt; $pod-item {
    for $pod-item.contents -&gt; $pod-block {
      $pod-block.perl.say;
    }
}
</code></pre><p>产生以下输出：</p>
<pre tabindex="0"><code>Pod::Heading.new(level =&gt; 1, config =&gt; {}, contents =&gt; [Pod::Block::Para.new(config =&gt; {}, contents =&gt; [&#34;This is an head1 title&#34;])]);
Pod::Block::Para.new(config =&gt; {}, contents =&gt; [&#34;This is a paragraph.&#34;]);
Pod::Heading.new(level =&gt; 2, config =&gt; {}, contents =&gt; [Pod::Block::Para.new(config =&gt; {}, contents =&gt; [&#34;Subsection&#34;])]);
Pod::Block::Para.new(config =&gt; {}, contents =&gt; [&#34;Here some text for the subsection.&#34;]);
</code></pre>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[术语]]></title>
            <link href="http://localhost:1313/rakulang/31.glossary/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/30.faq/?utm_source=atom_feed" rel="related" type="text/html" title="FAQ" />
                <link href="http://localhost:1313/rakulang/29.community/?utm_source=atom_feed" rel="related" type="text/html" title="社区" />
                <link href="http://localhost:1313/rakulang/28.about-the-docs/?utm_source=atom_feed" rel="related" type="text/html" title="关于文档" />
                <link href="http://localhost:1313/rakulang/27.regexes-best-practices-and-gotchas/?utm_source=atom_feed" rel="related" type="text/html" title="正则表达式最佳实践" />
                <link href="http://localhost:1313/rakulang/26.creating-operators/?utm_source=atom_feed" rel="related" type="text/html" title="创建操作符" />
            
                <id>http://localhost:1313/rakulang/31.glossary/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-06T21:13:31+08:00</published>
            <updated>2018-11-06T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h2 id="匿名">匿名</h2>
<p>子例程、方法或子方法，当它们不能通过名字调用时，就被称为匿名的</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># named subroutine</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">double</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="mi">2</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 匿名子例程,存储在一个具名的标量里</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$double</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="mi">2</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">};</span>
</span></span></code></pre></div><p>注意，匿名子例程仍然可以有名字</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># 使用 anon 关键字使子例程匿名</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="k">anon</span> <span class="k">sub</span> <span class="nf">triple</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="mi">3</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">name</span><span class="p">;</span>        <span class="c1"># triple</span>
</span></span></code></pre></div><h2 id="副词">副词</h2>
<p>通常, 副词是函数的命名参数.  也有一些其它特殊语法形式允许副词出现在某些合适的地方:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">q</span><span class="sa">:w</span><span class="p">&#34;</span><span class="s">foo bar</span><span class="p">&#34;</span>   <span class="c1"># &#34;:w&#34; is a Quotelike form modifier adverb</span>
</span></span><span class="line"><span class="cl"><span class="k">m</span><span class="p">:</span><span class="na">g</span><span class="p">/</span><span class="sr">a</span><span class="o">|</span><span class="sr">b</span><span class="o">|</span><span class="sr">c</span><span class="p">/</span>     <span class="c1"># &#34;:g&#34; is also</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="o">+&gt;</span> <span class="mi">5</span> <span class="p">:</span><span class="s">rotate</span> <span class="c1"># &#34;:rotate&#34; is an operator adverb</span>
</span></span><span class="line"><span class="cl"><span class="nv">@h</span><span class="p">{</span><span class="mi">3</span><span class="p">}:</span><span class="s">exists</span>   <span class="c1"># &#34;:exists&#34; is also, but is known as a subscript adverb</span>
</span></span></code></pre></div><p>副词通常使用冒号对儿标记来表示, 因为这个原因, 冒号对儿标记法也以副词对儿形式著称:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">:</span><span class="s">a</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>          <span class="c1"># Same as &#34;a&#34; =&gt; 4</span>
</span></span></code></pre></div><h2 id="autothreading">Autothreading</h2>
<p><code>Autothreading</code> 是这样的: 如果你传递一个 <code>junction</code> 给子例程, 该子例程期望的参数类型为<code>Any</code> 或它的子类型. 那么这个子例程调用会被执行多次, 每次使用一个不同的 junction 状态. 这些调用的结果被组合成一个跟原 <code>junction</code> 同类型的 <code>junction</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="mi">2</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">f</span><span class="p">(</span><span class="mi">1</span><span class="o">|</span><span class="mi">2</span><span class="o">|</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">success</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里 <code>f()</code> 是含有一个参数的子例程，然而因为它没有显式的类型声明，它就被隐式的声明为 <code>Any</code> 型。 Junction 参数使 <code>f(1|2|3)</code> 调用在内部作为 <code>f(1)|f(2)|f(3)</code> 执行,而结果是跟原 <code>junction</code> 同类型的 <code>junction</code> , 即  <code>2|4|6</code>.  这种把一个 <code>Junction</code> 分成对多次函数调用的处理就叫做 <code>autothreading</code>.</p>
<h2 id="colon-pair-and-colon-list">Colon Pair and Colon List</h2>
<p>冒号对儿是用于创建或 Pair 对象的便捷语法. 两种最常见的形式是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="p">:</span><span class="n">a</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>          <span class="c1"># Same as &#34;a&#34; =&gt; 4,   same as Pair.new(:key&lt;a&gt;,:value(5))</span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="n">a</span><span class="sr">&lt;4&gt;</span>          <span class="c1"># Same as &#34;a&#34; =&gt; &#34;4&#34;, same as Pair.new(:key&lt;a&gt;,:value&lt;5&gt;)</span>
</span></span></code></pre></div><p>这也是人们熟知的副词对儿形式. 注意, 当冒号后面括号前面的部分不是一个合法的标识符的时候, 会应用其它语义, 不是所有的副词对儿都创建 <code>Pair</code> 对象.
另外两个常见的形式是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">:</span><span class="s">a</span>             <span class="c1"># Same as :a(True)</span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="o">!</span><span class="s">a</span>            <span class="c1"># Same as :a(False)</span>
</span></span></code></pre></div><p>一个 colon 列表是一个仅包含冒号对儿的列表, 不需要逗号, 甚至不需要空格:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">:</span><span class="s">a</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span><span class="s">c</span><span class="p">:</span><span class="o">!</span><span class="s">d</span><span class="p">:</span><span class="s">c</span>   <span class="c1"># Same as a =&gt; 4, c =&gt; True, d =&gt; False, c =&gt; True</span>
</span></span></code></pre></div><h2 id="constraint">Constraint</h2>
<p>约束是给参数或 subset 类型添加的限制. 通过单词 where 引入约束. 在下面的例子中, 约束用于确保 , 当调用一个名为 abbreviate 的子例程, 其参数为一个长度小于 10 个字符的字符串时,会抛出一个错误:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">abbreviate</span> <span class="p">(</span><span class="kt">Str</span> <span class="nv">$thing</span> <span class="k">where</span> <span class="p">{</span> <span class="o">.</span><span class="nb">chars</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="p">})</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span></code></pre></div><p>上例中的 Str 也是一个约束, 但是经常作为&quot;类型约束&quot;.</p>
<h2 id="instance">Instance</h2>
<p>类的实例在其它编程语言中也叫对象. 对象存储属性, 通常是 new 方法调用的返回值, 或者是对象字面量.
大部分类型的实例被定义为 True, 例如 <code>defined($instance)</code> 为 True.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Str</span> <span class="nv">$str</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">hello</span><span class="p">&#34;;</span>  <span class="c1">## 这使用内建类型,例如 Str</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">defined</span><span class="p">(</span><span class="nv">$str</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Oh, yeah. I&#39;m defined.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No. Something off? </span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">## if you wanted objects...</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># nothing here for now.</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$an_instance</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$an_instance</span><span class="o">.</span><span class="nb">defined</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span><span class="c1"># defined($an_instance) works too.</span>
</span></span></code></pre></div><p>类拥有方法和属性的所有蓝图, 而类的实例把蓝图带到真实世界中.</p>
<h2 id="invocant">Invocant</h2>
<p>在 Raku 中调用方法的对象叫做调用者. 在方法中它就是 <code>self</code> 引用的东西.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">str</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">uc</span><span class="p">;</span>   <span class="c1"># &#39;str&#39; 是 方法 uc 的调用者</span>
</span></span></code></pre></div><h2 id="literal">Literal</h2>
<p>字面量是一块直接代表对象的代码, 通常指向对象自身.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>      <span class="c1"># the 2 is a literal</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># $x is not a literal, but a variable</span>
</span></span></code></pre></div><h2 id="lvalue">lvalue</h2>
<p>lvalue 或者左值是能出现在赋值操作符左侧的任何东西; 典型的左值有变量,私有属性和 <code>is rw</code>属性, 变量列表和左值子例程.
左值的例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">Declaration</span>             <span class="n">lvalue</span>          <span class="n">Comments</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span><span class="p">;</span>                  <span class="nv">$x</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">);</span>            <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">has</span> <span class="nv">$!attribute</span><span class="p">;</span>        <span class="nv">$!attribute</span>     <span class="n">Only</span> <span class="n">inside</span> <span class="n">classes</span>
</span></span><span class="line"><span class="cl"><span class="k">has</span> <span class="nv">$.attrib</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>     <span class="nv">$.attrib</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">a</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span> <span class="nv">$x</span> <span class="p">};</span>     <span class="nf">a</span><span class="p">()</span>
</span></span></code></pre></div><p>不是左值的例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">3</span>                        <span class="c1"># literals</span>
</span></span><span class="line"><span class="cl"><span class="k">constant</span> <span class="nb">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>          <span class="c1"># constants</span>
</span></span><span class="line"><span class="cl"><span class="k">has</span> <span class="nv">$.attrib</span><span class="p">;</span>            <span class="c1"># attributes; you can only assign to $!attrib</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span> <span class="p">{</span> <span class="p">};</span> <span class="nb">f</span><span class="p">();</span>          <span class="c1"># &#34;normal&#34; subs are not writable</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">};</span>    <span class="c1"># error - parameters are read-only by default</span>
</span></span></code></pre></div><h2 id="mainline">Mainline</h2>
<p><code>mainline</code> 是程序中不属于任何 block 的程序文本.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>     <span class="c1"># mainline</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># not in mainline, in sub f</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span><span class="p">();</span>        <span class="c1"># in mainline again</span>
</span></span></code></pre></div><h2 id="slurpy">Slurpy</h2>
<p>子例程或方法中的形参如果能接收任意数量的参数, 那这个形参就会被认为是 <code>slurpy</code> 的. 它由参数名字前面的星号标出.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">sum</span> <span class="p">(</span><span class="o">*</span><span class="nv">@numbers</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">[+]</span> <span class="nv">@numbers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="type-object">Type Object</h2>
<p>类型对象是一个代表类 <code>/role/package/grammar/enum</code> 的对象. 它通常和类型名相同.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">A</span><span class="p">;</span>              <span class="c1"># A is the type object</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">();</span>    <span class="c1"># same here</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="k">class</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">greet</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">hi</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># $x now holds a type object returned from the</span>
</span></span><span class="line"><span class="cl"><span class="c1"># anonymous class definition</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[FAQ]]></title>
            <link href="http://localhost:1313/rakulang/30.faq/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/29.community/?utm_source=atom_feed" rel="related" type="text/html" title="社区" />
                <link href="http://localhost:1313/rakulang/28.about-the-docs/?utm_source=atom_feed" rel="related" type="text/html" title="关于文档" />
                <link href="http://localhost:1313/rakulang/27.regexes-best-practices-and-gotchas/?utm_source=atom_feed" rel="related" type="text/html" title="正则表达式最佳实践" />
                <link href="http://localhost:1313/rakulang/26.creating-operators/?utm_source=atom_feed" rel="related" type="text/html" title="创建操作符" />
                <link href="http://localhost:1313/rakulang/25.modules/?utm_source=atom_feed" rel="related" type="text/html" title="模块" />
            
                <id>http://localhost:1313/rakulang/30.faq/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-05T21:13:31+08:00</published>
            <updated>2018-11-05T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>源文件可以在 <a href="https://github.com/raku/faq">github</a> 或 <a href="https://doc.raku.org/language/faq">raku.org</a>上找到.</p>
<h2 id="general">General</h2>
<h3 id="rakudo-和-raku-的区别是什么">Rakudo 和 Raku 的区别是什么？</h3>
<p>Rakudo 是 Raku 的一个实现。目前它是完成度最好的但是过去也有其它的实现, 将来也可能会有其它实现。Raku 是语言的定义。很多场合</p>
<p>这两个名字可以宽松地使用并互相替换。</p>
<h3 id="会有-raku-版本-600-吗">会有 Raku 版本 6.0.0 吗?</h3>
<p>第一个稳定语言版本的版本称为 v6.c，而不是 6.0.0。 不同的命名方案使得不太可能发布具有精确版本 6.0.0 的语言。</p>
<p>您可以使用下面的代码检查您的 Rakudo 编译器是当前至少是什么版本（注意这可能不是真正的供应商二进制文件）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">say q[too old] if $*PERL.version before Version.new(q[6.c])</span><span class="p">&#39;</span>
</span></span></code></pre></div><p>它首先由 Rakudo Raku 编译器版本的 2015.12 实现，并且可能通过使用 &lsquo;use 6.c&rsquo; 指令在可预见的未来支持后续版本。 下一个语言版本（无发布日期）为 v6.d.</p>
<h3 id="作为一个-raku-初学者我应该安装什么">作为一个 Raku 初学者我应该安装什么？</h3>
<p>如果你是一个 Linux 或 Mac 用户, 你可能需要下载 <a href="http://rakudo.org/downloads/star/">Rakudo Star</a> 并通过编译 MoarVM 版本安装（一个简单的处理）</p>
<p>如果你是一个 Windows 32 或 64 位用户, 那么 Rakudo Star 二进制版本在 rakudo 网站也能获得。你需要 Windows Git 来使用 panda。</p>
<p>Linux 和 Mac 二进制版本稍后也可能从供应商和第三方那儿获取到。尽管供应商版本可能过时了。</p>
<p>或者有一个官方的 rakudo star Docker 镜像, 地址为 <a href="https://hub.docker.com/_/rakudo-star/">https://hub.docker.com/_/rakudo-star/</a></p>
<h3 id="作为一个中高级用户我想跟进-rakudo-开发">作为一个中高级用户我想跟进 Rakudo 开发</h3>
<p>安装类似于 Perl 5 的 perlbrew &ndash; <a href="https://github.com/tadzik/rakudobrew">rakudobrew</a> , 同等的 Python 还有 Ruby 工具。</p>
<h3 id="从哪里能找到关于-raku-的好文档">从哪里能找到关于 Raku 的好文档？</h3>
<p>最令人信赖的信息能在 raku.org 或那儿的直接链接。</p>
<p>你也可以使用 <a href="https://www.google.co.uk/search?q=site:irclog.perlgeek.de+inurl:raku">Google</a> 搜索 Freenode #raku IRC 频道。</p>
<p><a href="http://www.raku.org/documentation/">http://www.raku.org/documentation/</a> 和 <a href="http://doc.raku.org/">http://doc.raku.org/</a></p>
<h3 id="什么是-raku-spec">什么是 Raku spec？</h3>
<p>&ldquo;spec&rdquo; 指的是 Raku的官方测试套件。它被称作 roast 并被托管在 <a href="https://github.com/raku/roast">github</a> 上.</p>
<p>它被用来测量一个 Raku 的实现有多彻底。</p>
<h3 id="有没有-raku-的术语相关的项目">有没有 Raku 的术语相关的项目？</h3>
<p>查看 <a href="http://design.raku.org/S99.html">glossary</a></p>
<h3 id="我是一个-perl-5-程序员-perl-5-和-raku-的区别在哪儿">我是一个 Perl 5 程序员. Perl 5 和 Raku 的区别在哪儿？</h3>
<p>在 <a href="https://docs.raku.org/language/5to6-nutshell"> https://docs.raku.org/language/5to6-nutshell</a> 下面查看 ‘5to6-nutshell’ pod 文档和相关页面。</p>
<h2 id="模块">模块</h2>
<h3 id="raku-有-cpan-吗-或者-raku-会使用-perl-5-的-cpan-吗">Raku 有 CPAN 吗? 或者 Raku 会使用 Perl 5 的 CPAN 吗?</h3>
<p>Raku 还没有像 CPAN 那样成熟的模块仓库. 但是 <a href="http://modules.raku.org/">modules.raku.org</a> 有很多已知的 Raku 模块, <a href="https://github.com/tadzik/panda/">panda</a> 能在 Rakudo 上安装这些模块.</p>
<h3 id="我能在-raku-中使用-perl-5的模块吗">我能在 Raku 中使用 Perl 5的模块吗？</h3>
<p>使用 <a href="https://github.com/niner/Inline-Perl5/">Inline::Perl5</a> 能让大部分 Perl 5 模块工作, 它甚至能很好地运行 Perl 5 的 Catalyst 和 DBI。</p>
<h3 id="我能在-raku-中使用-c-和-c-吗">我能在 Raku 中使用 C 和 C++ 吗？</h3>
<p><a href="http://docs.raku.org/language/nativecall">Nativecall</a> 让这个特别容易。</p>
<h3 id="nativecall-找不到-libfooso-并且我只有-libfooso12">Nativecall 找不到 libfoo.so 并且我只有 libfoo.so.1.2!</h3>
<p>这在 Debian 那样的系统中很常见。 你需要安装 &ldquo;libfoo-dev&rdquo; 来为丢失的文件设置符号链接。</p>
<h3 id="所有的传统-unix-库函数去哪儿了">所有的传统 Unix 库函数去哪儿了？</h3>
<p>使用 Nativecall 访问它们很容易。
<a href="https://github.com/cspencer/raku-posix">POSIX</a> 模块也可以。</p>
<h3 id="rakudo-有核心标准库吗">Rakudo 有核心标准库吗?</h3>
<p>Rakudo 是一个包含最小电量的编译器发布（Test 和 Nativecall等等），像 linux 内核一样。</p>
<p>Rakudo Star 是一个带有一些有用模块的 rakudo, 并且更多的模块可以从生态系统里安装。</p>
<h3 id="有像-bdeparse-那样的东西吗我怎么抓住-ast">有像 B::Deparse 那样的东西吗?/我怎么抓住 AST?</h3>
<p>使用 <code>raku --target=ast -e 'very-short-example()'</code> 来抓取编译单元的抽象语法树(AST)。</p>
<h2 id="语言特性">语言特性</h2>
<h3 id="我怎么-dump-raku-的数据结构就像-perl-5-的-datadumper-和类似的">我怎么 dump Raku 的数据结构(就像 Perl 5 的 Data::Dumper 和类似的)？</h3>
<p>examples:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$foo</span><span class="o">=</span><span class="p">&#34;</span><span class="s2">bar</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">$foo</span>        <span class="c1"># Str $foo = &#34;bar&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">:</span><span class="nv">$foo</span><span class="o">.</span><span class="nb">perl</span> <span class="c1"># :foo(&#34;bar&#34;)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">:</span><span class="nv">$foo</span><span class="o">.</span><span class="nb">gist</span> <span class="c1"># foo =&gt; bar</span>
</span></span></code></pre></div><p>生态系统中还有模块来做这个事情, 例如 <a href="https://github.com/tony-o/raku-data-dump/">Data::Dump</a> 使用颜色来 Dump。</p>
<h3 id="我怎么在-raku-提示符repl中找到历史命令行">我怎么在 Raku 提示符（REPL）中找到历史命令行？</h3>
<p>从生态系统中安装 <a href="https://github.com/hoelzro/p6-linenoise/">Linenoise</a>.</p>
<p>作为一种选择, 在 UNIX 那样的系统中可以安装 rlwrap。这在类 Debian 系统中可以通过<code>apt-get install rlwrap</code> 安装。</p>
<h3 id="为什么-rakudo-编译器有时候报错更友好">为什么 Rakudo 编译器有时候报错更友好？</h3>
<p>如果在输出中出现 <code>SORRY!</code> , 则错误是编译时错误, 否则是运行时错误。</p>
<p>Examples:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>     <span class="c1"># Attempt to divide 1 by zero using div</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span> <span class="p">(</span> <span class="kt">Int</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Int</span> <span class="nv">$b</span> <span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>      <span class="c1"># ===SORRY!=== Error while compiling ...</span>
</span></span></code></pre></div><h3 id="什么是-any">什么是 (Any)?</h3>
<p><a href="http://doc.raku.org/routine/type%2FAny">Any</a> 是一个用于新类的默认超类(superclass)的顶层类。
它经常在这样的上下文出现：变量被定义但没有被赋值， 这里它类似于其它语言中的 undef 或 null 值。</p>
<p>examples:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>       <span class="c1"># (Any) 注意圆括号表明的类型对象</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$foo</span><span class="o">.^</span><span class="nb">name</span>  <span class="c1"># Any</span>
</span></span></code></pre></div><p>(Any) 不应该被用于检查 definedness。 在 Raku 中, definedness 可能是一个对象的属性。 通常实例是被定义的, 而类型对象是未定义的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">.</span><span class="nb">defined</span>       <span class="c1"># True</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="kt">Any</span><span class="p">)</span><span class="o">.</span><span class="nb">defined</span>   <span class="c1"># False</span>
</span></span></code></pre></div><h3 id="so-是什么">so 是什么?</h3>
<p><code>so</code> 是一个松散优先级的操作符, 它强制上下文为 <a href="https://docs.raku.org/type/Bool">Bool</a>.</p>
<p><code>so</code> 拥有和 <code>?</code> 前缀操作符同样的语义, 就像 <code>and</code> 是 <code>&amp;&amp;</code> 的低优先级版本一样.</p>
<p>用法示例:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="mi">1</span><span class="o">|</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1"># Bool::True</span>
</span></span></code></pre></div><p>在这个例子中, 比较的结果(结果是 <a href="https://docs.raku.org/type/Junction">Junction</a>)在打印之前被转换为 Bool 值了.</p>
<h3 id="签名中的那些-d-和-u-是什么东东">签名中的那些 :D 和 :U 是什么东东？</h3>
<p>在 Raku 中, 类和其它类型是对象, 并且传递自身类型的类型检测。
例如如果你声明一个变量</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span></code></pre></div><p>那么, 你不仅可以给它赋值整数（即， Int 类的实例）, 还能给它赋值 Int 类型对象自身：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$x</span> <span class="o">=</span> <span class="kt">Int</span>
</span></span></code></pre></div><p>如果你想排除类型对象, 你可以追加一个 <code>:D</code> 类型微笑符, 它代表&quot;定义&quot;（definite）:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int:D</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">;</span>  <span class="c1"># dies with:</span>
</span></span><span class="line"><span class="cl">           <span class="c1"># Type check failed in assignment to $x;</span>
</span></span><span class="line"><span class="cl">           <span class="c1"># expected Int:D but got Int</span>
</span></span></code></pre></div><p>同样地, <code>:U</code> 约束为未定义的值, 即类型对象。
要显式地允许类型对象或实例, 你可以使用 <code>:_</code>。</p>
<h3 id="签名中的----是什么东东">签名中的 &ndash;&gt; 是什么东东？</h3>
<p><code>--&gt;</code> 是一个返回值约束, 要么是类型要么是有定义的值。</p>
<p>类型约束的例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">divide-to-int</span><span class="p">(</span> <span class="kt">Int</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Int</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="kt">Int</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">/</span> <span class="nv">$b</span><span class="p">)</span><span class="o">.</span><span class="nb">narrow</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">divide-to-int</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Type check failed for return value; expected Int but got Rat</span>
</span></span></code></pre></div><p>有明确返回值的例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">discard-random-number</span><span class="p">(</span> <span class="k">--&gt;</span> <span class="mi">42</span> <span class="p">)</span> <span class="p">{</span> <span class="nb">rand</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">discard-random-number</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 42</span>
</span></span></code></pre></div><p>在这种情况下，最终值被抛弃，因为已经指定了返回值。</p>
<h3 id="any-和-mu-的区别是什么">Any 和 Mu 的区别是什么?</h3>
<p><code>Mu</code> 是所派生出的所有其它类型的基类型. <code>Any</code> 是从  <code>Mu</code>派生来的, 代表着任何类型的 Raku 值. 主要区别是, <code>Any</code> 不包含 <code>Junction</code>.</p>
<p>子例程参数的默认类型是 <code>Any</code>, 以至于当你声明 <code>sub foo ($a)</code> 时, 你真正表达的是 <code>sub foo (Any $a)</code> . 类似地, 类的声明被假定继承自 <code>Any</code>, 除非使用了像 <code>is Mu</code> 这样的 trait 特征.</p>
<h3 id="怎么从-junction-中提取值">怎么从 Junction 中提取值?</h3>
<p>如果你想从 <a href="https://docs.raku.org/type/Junction">Junction</a> 中提取值(特征态), 那你可能正误入歧途. 应该使用 <a href="https://docs.raku.org/type/Set">Set</a> 代替</p>
<p>Junctions 作为匹配器, 而不是使用它们做代数.</p>
<p>如果你还是想那样做, 你可以滥用自动线程(autothreading):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">eigenstates</span><span class="p">(</span><span class="kt">Mu</span> <span class="nv">$j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">@states</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">-&gt;</span> <span class="kt">Any</span> <span class="nv">$s</span> <span class="p">{</span> <span class="nv">@states</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="nv">$s</span> <span class="p">}</span><span class="o">.</span><span class="p">(</span><span class="nv">$j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nv">@states</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">eigenstates</span><span class="p">(</span><span class="mi">1</span><span class="o">|</span><span class="mi">2</span><span class="o">|</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">, </span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># prints 1, 2, 3 or a permutation thereof</span>
</span></span></code></pre></div><h3 id="如果-str-是不可变的-那么-s-是怎么工作的-如果-int-是不可变的-i-是怎么工作的">如果 Str 是不可变的, 那么 <code>s///</code> 是怎么工作的? 如果 Int 是不可变的, <code>$i++</code> 是怎么工作的?</h3>
<p>在 Raku 中, 很多基本类型是不可变的, 但是保存它们的变量不是. <code>s///</code> 作用于变量上, 在这个变量中放入一个新创建的字符串对象. 同样地, <code>$i++</code> 作用于 <code>$i</code> 变量上, 而不是作用在它里面的值身上.</p>
<p>更多详情请查看:  <a href="http://doc.raku.org/language/containers">containers</a> 文档。</p>
<h3 id="什么是数组引用和自动解引用-我仍然需要--符号吗">什么是数组引用和自动解引用? 我仍然需要 @ 符号吗?</h3>
<p>在 Raku 中, 几乎所有的东西都是引用. 所以谈论 taking references 没有多大意义. 不像 Perl 5 那样, Raku 的标量变量也能直接包含数组:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="p">;</span>                 <span class="c1"># &#34;1 2 3\n&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>            <span class="c1"># (Array)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$scalar</span> <span class="o">=</span> <span class="nv">@a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$scalar</span><span class="p">;</span>            <span class="c1"># &#34;1 2 3\n&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$scalar</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>       <span class="c1"># (Array)</span>
</span></span></code></pre></div><p>最大的区别是, 标量中的数组在列表上下文中是一个值, 然而数组会被愉快地迭代:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="nv">@a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@a</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>          <span class="c1"># loop body executed 3 times</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">$s</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>          <span class="c1"># loop body executed only once</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@flat</span> <span class="o">=</span> <span class="nb">flat</span> <span class="nv">@a</span><span class="o">,</span> <span class="nv">@a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@flat</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>        <span class="c1"># 6</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@nested</span> <span class="o">=</span> <span class="nb">flat</span> <span class="nv">$s</span><span class="o">,</span> <span class="nv">$s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@nested</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>      <span class="c1"># 2</span>
</span></span></code></pre></div><p>你可以使用 <code>@( ... )</code> 或通过在表达式身上调用 <code>.list</code> 方法来强制展平, 使用 <code>$( ... )</code> 或通过在表达式身上调用 <code>.item</code> 方法强制为 item  上下文(不展平).</p>
<h3 id="为什么还要符号-你不能没有它们吗">为什么还要符号? 你不能没有它们吗?</h3>
<p>有几个原因:</p>
<ul>
<li>它们使插值变量到字符串中变得更容易</li>
<li>它们为不同的变量和 twigils 组成了微型命名空间, 因此避免了名字冲突</li>
<li>它们允许简单的 单数/复数 区别</li>
<li>它们像使用强制性名词标记的自然语言一样工作，所以我们的大脑为处理它而生</li>
<li>它们不是强制性的，因为你可以声明无符号名字（如果你不介意含糊不清）</li>
</ul>
<h3 id="类型-str-不支持关联索引">&ldquo;类型 Str 不支持关联索引&rdquo;</h3>
<p>你可能会把字符串插值和 HTML 搞混。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">abc</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$foo</span><span class="s2">&lt;html-tag&gt;</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>Raku 认为 <code>$foo</code> 是一个散列而 <code>&lt;html-tag&gt;</code> 是一个字符串字面量的散列键。使用闭包来帮助你理解吧。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">abc</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;{</span><span class="nv">$foo</span><span class="p">}</span><span class="s2">&lt;html-tag&gt;</span><span class="p">&#34;;</span>
</span></span></code></pre></div><h3 id="raku-有协程吗-什么是-yield-">Raku 有协程吗? 什么是 yield ?</h3>
<p>Raku 没有 Python 那样的 <code>yield</code> 语句, 但是它通过惰性列表却能提供类似的功能. 有两种很潮的方式来写出能返回惰性列表的例程:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># first method, gather/take</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@values</span> <span class="o">:=</span> <span class="k">gather</span> <span class="k">while</span> <span class="nf">have_data</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># do some computations</span>
</span></span><span class="line"><span class="cl">    <span class="nb">take</span> <span class="nf">some_data</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># do more computations</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># second method, use .map or similar method</span>
</span></span><span class="line"><span class="cl"><span class="c1"># on a lazy list</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@squares</span> <span class="o">:=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..*</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$x</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1"># or</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@squares</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..*</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="k">-&gt;</span> \<span class="nb">x</span> <span class="p">{</span> <span class="nb">x</span>² <span class="p">});</span>
</span></span></code></pre></div><h3 id="为什么我需要反斜线unspace在多行上分割方法调用">为什么我需要反斜线(unspace)在多行上分割方法调用?</h3>
<p>(请在这儿添加答案)</p>
<h3 id="为什么我不能从-new-方法初始化私有属性-我怎么修复它">为什么我不能从 new 方法初始化私有属性, 我怎么修复它?</h3>
<p>这样的代码:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">show-x</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$!x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="nf">show-x</span><span class="p">;</span>
</span></span></code></pre></div><p>不会打印出 5. Private 属性是私有的, 这意味着私有属性在外面是不可见的. 如果默认的构造器能够初始化私有属性, 那么这些私有属性就会泄露到公共 API 中.</p>
<p>如果你仍旧想让它工作, 你可以添加一个 <code>submethod BUILD</code> 来初始化它们:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(</span><span class="o">:</span><span class="nv">$!x</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">show-x</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$!x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="nf">show-x</span><span class="p">;</span>
</span></span></code></pre></div><p><code>BUILD</code> 由默认的构造器使用用户传递给构造器的所有具名参数调用（间接地, 更多细节查看<a href="https://docs.raku.org/language/objects#Object_Construction">Object Construction</a>）。 <code>:$!x</code> 是名为 <code>x</code> 的具名参数, 当使用名为 <code>x</code> 的具名参数来调用时, 它的值被绑定到属性 <code>$!x</code> 上.</p>
<p>但不要这样做。如果名字是 public 的，使用 <code>$.x</code> 以那样的方式声明没有什么不好，因为默认情况下外部视图是只读的(readonly)，你仍然可以使用 <code>$!x</code> 从内部访问它。</p>
<h3 id="say-put-和-print-怎么不同-为什么不同">say, put 和 print 怎么不同, 为什么不同?</h3>
<p>最明显的区别是, <code>say</code> 和 <code>put</code> 在输出后面添加了一个换行符, 而 <code>print</code> 没有.</p>
<p>但是还有另外一个区别: <code>print</code> 和 <code>put</code> 通过对每一个传递来的 item 调用 <code>Str</code> 方法来把它的参数转换为字符串, 相反,  <code>say</code> 使用  <code>gist</code> 方法. 前者是为计算机设计的, 后者是为人类.</p>
<p>或者它俩被解析的方式不同, <code>$obj.Str</code> 给出一个字符串表示, <code>$obj.gist</code> 是对象的一个简短总结, 适合编程人员的快速识别, <code>$obj.perl</code> 打印一个 Perlish 的表示.</p>
<p>例如, 类型对象, 也是熟知的 “未定义值”, 字符串化为一个空的字符串和警告, 而 <code>gist</code> 方法返回由一对圆括号包裹的类型的名字.(用于表明除了类型之外什么也没有).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Date</span> <span class="nv">$x</span><span class="p">;</span>     <span class="c1"># $x now contains the Date type object</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="nv">$x</span><span class="p">;</span>       <span class="c1"># empty string plus warning</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># (Date)\n</span>
</span></span></code></pre></div><p>所以, <code>say</code> 优化的用于调试和向人们展示, <code>print</code> 和 <code>put</code> 更适合于产生用于其它程序的输出.</p>
<p><code>put</code> 因此是 <code>print</code> 和 <code>say</code> 之间的一种混合; 像 <code>print</code>, 它的输出适合于其它程序, 也像 <code>say</code>, 它在输出的末尾添加了换行符。</p>
<h3 id="token-和-rule-之间的区别是什么">token 和 rule 之间的区别是什么?</h3>
<p><code>regex</code> , <code>token</code> 和 <code>rule</code> 这三个都引入了正则表达式, 但是语义略微有一点不同.</p>
<p><code>token</code> 隐含了 <code>:ratchet</code> 或 <code>:r</code> 修饰符, 这防止了 rule 的回溯.</p>
<p><code>rule</code> 隐含了 <code>:ratchet</code> 和  <code>:sigspace</code> (缩写为 <code>:s</code>)修饰符, 这意味着规则(rule)不会回溯, 并且它把 regex 的文本中的空白当作 <code>&lt;.ws&gt;</code> 调用(例如匹配空白, 除了在两个单词字符之间之外, 它是可选的).  regex 开头的空白和备选分支中每个分支开头的空白会被忽略.</p>
<p><code>regex</code> 声明一个简单的正则表达式，没有任何隐含的修饰符。</p>
<h3 id="die-和-fail-之间的区别是什么">die 和 fail 之间的区别是什么?</h3>
<p><code>die</code> 抛出一个异常.</p>
<p><code>fail</code> 返回一个 Failure 对象。 （如果调用者已经声明了 <code>use fatal;</code> 在调用作用域中, <code>fail</code> 会抛出一个异常而不返回）</p>
<p><code>Failure</code> 是一个 “未知的” 或 “懒惰的” 异常.它是一个含有异常的对象, 当这个 Failure 被用作普通的对象或者在 sink 上下文中忽略它时, 则会抛出一个异常.</p>
<p>Failure 从 <code>defined</code> 检查中返回 False, 并且你可以使用 <code>exception</code> 方法提取出异常.</p>
<h3 id="为什么-wantarray-或-want-不见了-我能在不同的上下文中返回不同的东西吗">为什么 wantarray 或 want 不见了? 我能在不同的上下文中返回不同的东西吗?</h3>
<p>Perl 拥有 <a href="https://docs.raku.org/language/5to6-perlfunc#wantarray">wantarray</a> 函数来告诉你这是在空上下文, 标量上下文,还是在列表上下文中调用的. Raku 没有与之等价的结构, 因为上下文不是向内流动的,  例如, 子例程不知道调用所在的上下文.</p>
<p>一个愿意是因为 Raku 有多重分派, 在这样一个例子中:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">w</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Int</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">w</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Str</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">w</span><span class="p">(</span><span class="nb">f</span><span class="p">());</span>
</span></span></code></pre></div><p>没办法决定子例程 <code>f</code> 的调用者想要一个字符串还是想要一个整数, 因为它还不知道调用者是什么. 通常这要求解决 halting 问题, 在这个问题上, 即使写 Raku编译器的人也会遇到麻烦.</p>
<p>在 Raku 中达到上下文敏感的方式是返回一个知道怎样响应方法调用的对象.</p>
<p>例如, regex 匹配返回 Match <a href="http://doc.raku.org/type/Match">对象</a>, 该对象知道怎样响应列表索引, 散列索引, 并能变成匹配的字符串.</p>
<h3 id="pointer-和-opaquepointer-的区别是声明">Pointer 和 OpaquePointer 的区别是声明?</h3>
<p><code>OpaquePointer</code> 被废弃了并且已经用 <code>Pointer</code> 代替了。</p>
<h2 id="raku-实现">Raku 实现</h2>
<h3 id="哪个-raku-的实现是可用的">哪个 Raku 的实现是可用的?</h3>
<p>当前开发最好的是 Rakudo(使用多个虚拟机后端)。历史上的实现还包括 Niecza (.NET) 和 Pugs (Haskell). 其它的列出在 <a href="https://www.raku.org/compilers/">Raku Compilers</a> 下面。</p>
<h3 id="rakudo-是用什么语言写的">Rakudo 是用什么语言写的?</h3>
<p>NQP 是（1）NQP 代码，（2）底层虚拟机使用的任何语言，（3）一些第三方 C 和 Java 库，以及（4）早期运行构建过程创建的一些引导文件的混合 。</p>
<h3 id="为什么我不能把所有的数值都赋值给-num-类型的变量">为什么我不能把所有的数值都赋值给 Num 类型的变量?</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Num</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># dies with</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Type check failed in assignment to &#39;$x&#39;; expected &#39;Num&#39; but got &#39;Int&#39;</span>
</span></span></code></pre></div><p><a href="http://doc.raku.org/type/Num">Num</a> 是浮点类型, 与 <a href="http://doc.raku.org/type/Int"> integers</a> 不兼容. 如果你想要一个允许任何数字值的类型约束, 使用 <a href="http://doc.raku.org/type/Numeric">Numeric</a> (它也允许<a href="http://doc.raku.org/type/Complex">复数</a>), 或 <a href="http://doc.raku.org/type/Real">Real</a>如果你想排除复数.</p>
<h2 id="元问题和宣传">元问题和宣传</h2>
<h3 id="raku-什么时间会准备好-就是现在吗">Raku 什么时间会准备好? 就是现在吗?</h3>
<p>编程语言和它们的编译器的准备就绪不是一个二元决策. 因为它们(语言和实现)能进化, 它们平稳地发展变得更可用. 根据你对编程语言的要求, 它可能适合也可能不适合你.</p>
<p>请查看 <a href="http://raku.org/compilers/features">功能对比矩阵</a> 了解更详尽的实现了的功能.</p>
<p>请注意, Larry Wall 已经在 FOSDEM 2015 会议上宣布, 一个产品级的 Rakudo Raku 将会在 2015 圣诞节发布.</p>
<h3 id="为什么我要学习-raku-它有什么了不起的吗">为什么我要学习 Raku? 它有什么了不起的吗?</h3>
<p>Raku 统一了很多其它编程语言中不经常有的伟大想法. 虽然其中的几种语言提供了其中的某些功能, 但是没有提供全部.</p>
<p>不像大部分语言那样, 它提供了：</p>
<ul>
<li>Raku 提供了过程式的, 面向对象的和函数式编程方法。</li>
<li>易于使用的一致性语法, 数据结构中的符号不变性。</li>
<li>完全基于字素的 Unicode 支持, 包括附件 #29</li>
<li>足够清晰的正则表达式, 更易读, 更多功能。</li>
<li>Junctions 允许多个可能性的简单检测, 例如 $a == 1|3|42（意思是 $a 等于 1 或 3 或 42）</li>
<li>相对于全局变量, 动态作用域变量提供了词法作用域备选</li>
<li>强调可组合性和本地作用域以阻止「超距作用」。例如, imports 总是本地作用域的。</li>
<li>易于理解的一致性作用域规则和闭包</li>
<li>强大的面向对象, 含有类和 roles(所有的东西都可以当做对象)。继承、子类型、代码复用。</li>
<li>内省到对象和元对象中（叠罗汉）</li>
<li>元对象协议允许元编程而不需要生成/解析代码。</li>
<li>子例程和方法签名，便于解包位置参数和命名参数。</li>
<li>根据元数,类型和可选的额外代码使用不同的签名对同一具名子例程/方法进行多重分派。</li>
<li>未知子例程/不可能的分派在编译时给出错误报告。</li>
<li>可选的渐进类型检查，无需额外的运行时成本。 还有可选类型注解。</li>
<li>基于对编译器/运行时状态的内省的高级错误报告。这意味着更有用，更精确的错误信息。</li>
<li>Phasers(如 BEGIN/END) 允许代码作用域 进入/退出, 首次循环/last/next 和其它更多上下文中执行。</li>
<li>高级并发模型，用于隐式以及显式多进程处理，这超越了原始线程和锁。 Raku 的并发提供了一组丰富的（可组合的）工具。</li>
<li>多核计算机越来越多地被使用，由于并行性使得 Raku 可以使用多核，包括隐式（例如使用&raquo;.方法）和显式 (start {code}) 。这很重要，因为摩尔定律正在结束。</li>
<li>提供结构化语言支持以实现异步执行代码的编程。</li>
<li>Supplies 允许在发生某些事情时执行代码（如定时器，信号或文件系统事件）。</li>
<li>react/whenever/supply 关键字允许容易地构建交互式，事件驱动的应用程序。</li>
<li>懒惰求值，如果可能的话，急切求值当需要或必要时。这意味着，例如，惰性列表，甚至无限延迟列表，如斐波纳契序列或所有素数。</li>
<li>原生数据类型用于更快的处理</li>
<li>使用 NativeCall 连接到 C/C++ 中的外部库非常简单。</li>
<li>使用 Inline::Perl5 和 Inline::Python 连接 Perl 5(CPAN)/Python 非常简单。</li>
<li>可以同时安装和加载模块的多个版本。</li>
<li>由于更简单的更新/升级策略，简化了系统管理。</li>
<li>简单的数值计算没有损失精度，因为 Rats（有理数）。</li>
<li>用于解析数据或代码的可扩展语法（Raku 用它解析自身）</li>
<li>Raku 是一种非常易变的语言（定义自己的函数，运算符，traits 和数据类型，为您修改解析器）。</li>
<li>很多的数据类型选择，加上创建自己的类型的可能性。</li>
<li>具有适当边界检查的多维成型的和/或原生数组</li>
<li>在某个匹配出现时, 词法解析期间随时执行代码</li>
<li>添加自定义运算符或添加 trait 特征和编写子例程一样简单。</li>
<li>在任何运算符（系统或自定义添加的）上自动生成超运算符。</li>
<li>运行在各种后端上。目前 MoarVM 和 JVM，JavaScript在开发中，可能会有更多。</li>
<li>执行期间（JIT）热代码路径的运行时优化。</li>
<li>运行在小型（例如 Raspberry Pi）和大型多处理器硬件上。</li>
<li>基于垃圾收集：没有及时销毁，所以引用计数没有必要。使用 phasers 用以及时的动作。</li>
<li>方法可以在运行时混合到任何实例化的对象中，例如。以允许添加带外数据。</li>
<li>通过使用具有多重分派和自动生成使用信息的 MAIN 子例程，使命令行接口易于访问。</li>
<li>更少的代码行创建更紧凑的程序。名字的霍夫曼编码允许更好的可读性。</li>
<li>使用简单的迭代器接口定义的惰性列表，任何类可以通过最小化的提供单个方法来提供。</li>
<li>Perl  6 的座右铭与 Perl一直保持不变：Perl是不同的。简而言之，Perl旨在&quot;使容易的工作变得容易，使困难的工作变得可能&quot;。和&quot;条条大路通罗马&quot;。现在有更多 -Ofun 添加进来。</li>
</ul>
<p>请查看 <a href="http://raku.org/compilers/features">功能比较矩阵</a> 获取更多信息.</p>
<h3 id="为什么不把它叫做除了-perl-以外的其它东西">为什么不把它叫做除了 Perl 以外的其它东西?</h3>
<p>很多人建议, Raku 跟之前的 Perl 版本的区别太大了, 我们应该考虑给它改名, 或者考虑到 Raku 伤害了 Perl 5, 仅仅拥有同样的名字却有更高的版本号.</p>
<p>Raku 仍然叫做 “Perl&quot; 的主要原因是:</p>
<ul>
<li>Raku 仍然是一个 perlish 风格的语言, 和之前的版本遵守相同的底层思想(用于微型命名空间的符号, 条条大路通罗马, 吸收了很多自然语言的思想..)</li>
<li>Raku 的代码很 perlish.</li>
<li>Perl 仍然是一个强健的品牌名, 我们不想马上抛弃它</li>
<li>找到一个替代的名字很困难. 而且, “camelia” 和 “rakudo&quot; 不是合适的编程语言名</li>
<li>即使 Raku 更改了它的名字, Perl 5 也不大可能增加它的版本号为 6.因为 Raku 已经根植于人们的头脑中了</li>
</ul>
<h3 id="raku-对我来说足够快了吗">Raku 对我来说足够快了吗?</h3>
<p>那取决于你正在做什么。Raku 一直奉行“做对的事情然后做的更快”的哲学进行开发。对于某些东西来说它够快了, 但是需要做的更多。
Raku 大部分是由志愿者开发的, 但是 Raku 的性能在不久的将来有待提高, 因为 MoarVM 后端包含一个现代的即时（JIT）编译器。
Perl 5 程序员应该意识到 Raku 在面向对象方面有很多内建函数并且还有更多其它的。
简单的基准测试会误导除非你在你的 Perl 5脚本中包含了诸如 Moose, 类型检测模块等。</p>
<p>下面这个粗超的基准测试, 使用了所有诸如此类的一般说明, 能展示 Raku 在某些类似任务上能和 Perl 5的速度接近。
在你的系统上尝试下, 你可能会感到很惊讶!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku version</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span> <span class="k">has</span> <span class="nv">$.i</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">1_000_000</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$obj</span> <span class="o">=</span> <span class="n">Foo</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$obj</span><span class="o">.</span><span class="nf">i</span> <span class="o">=</span> <span class="nv">$i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Perl 5 version</span>
</span></span><span class="line"><span class="cl"><span class="nb">package</span> <span class="nn">Foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Moose</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">has</span> <span class="s">i</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="s">is</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">rw</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">__PACKAGE__-</span><span class="o">&gt;</span><span class="n">meta-</span><span class="o">&gt;</span><span class="n">make_immutable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="k">my</span> <span class="nv">$i</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">1_000_000</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$obj</span> <span class="o">=</span> <span class="n">Foo-</span><span class="o">&gt;</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$obj-</span><span class="o">&gt;</span><span class="nf">i</span><span class="p">(</span><span class="nv">$i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Another Perl 5 version that offers bare-bones set of features</span>
</span></span><span class="line"><span class="cl"><span class="c1"># compared to Moose/Raku&#39;s version but those are not needed in this</span>
</span></span><span class="line"><span class="cl"><span class="c1"># specific, simple program anyway.</span>
</span></span><span class="line"><span class="cl"><span class="nb">package</span> <span class="nn">Foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Mojo::Base</span> <span class="o">-</span><span class="n">base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">has</span> <span class="p">&#39;</span><span class="s1">i</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="k">my</span> <span class="nv">$i</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">1_000_000</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$obj</span> <span class="o">=</span> <span class="n">Foo-</span><span class="o">&gt;</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$obj-</span><span class="o">&gt;</span><span class="nf">i</span><span class="p">(</span><span class="nv">$i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># A perl program which works under both perl5 (with perl -Mbigint)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># and raku</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">$prev</span><span class="o">,</span> <span class="nv">$current</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">100_000</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nv">$prev</span><span class="o">,</span> <span class="nv">$current</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$current</span><span class="o">,</span> <span class="nv">$prev</span> <span class="o">+</span> <span class="nv">$current</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="nv">$current</span><span class="p">;</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[社区]]></title>
            <link href="http://localhost:1313/rakulang/29.community/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/28.about-the-docs/?utm_source=atom_feed" rel="related" type="text/html" title="关于文档" />
                <link href="http://localhost:1313/rakulang/27.regexes-best-practices-and-gotchas/?utm_source=atom_feed" rel="related" type="text/html" title="正则表达式最佳实践" />
                <link href="http://localhost:1313/rakulang/26.creating-operators/?utm_source=atom_feed" rel="related" type="text/html" title="创建操作符" />
                <link href="http://localhost:1313/rakulang/25.modules/?utm_source=atom_feed" rel="related" type="text/html" title="模块" />
                <link href="http://localhost:1313/rakulang/24.module-packages/?utm_source=atom_feed" rel="related" type="text/html" title="模块包" />
            
                <id>http://localhost:1313/rakulang/29.community/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-04T21:13:31+08:00</published>
            <updated>2018-11-04T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h2 id="概览">概览</h2>
<p>“Perl 5是我对 Perl 的重写。我希望 Raku 能够成为社区重写的 Perl, 并且 Raku 是社区的 Perl。” - 拉里沃尔</p>
<h2 id="raku-社区">Raku 社区</h2>
<p><code>freenode.net</code> 上的 <code>#raku</code> 频道有很多人，他们很乐意提供支持和回答问题。可以在 <a href="https://raku.org/community/">raku.org 社区页面</a> 中找到更多资源。 <a href="https://raku.org/">Camelia</a> 是她身上带有 P 6 的多色蝴蝶，她是这个多元化和热情的社区的象征。我们广泛使用 <a href="https://raku.org/community/irc">#raku</a> IRC 频道进行沟通，提问和简单地闲逛。查看此<a href="http://www.ircbeginner.com/ircinfo/abbreviations.html">IRC术语</a>资源，了解那里经常使用的缩写。 <a href="https://stackoverflow.com/questions/tagged/raku">StackOverflow</a> 也是一个很好的资源，用于提出问题并帮助其他人解决他们的 Raku 问题和挑战。</p>
<h2 id="raku-周刊">Raku 周刊</h2>
<p>Elizabeth Mattijsen 通常在 “Raku Weekly” 博客中发帖，这是有关 Raku 的帖子，推文，评论和其他有趣花絮的摘要。是知道 Perl 社区正在发生什么的最佳单个资源。</p>
<h2 id="raku-降临节日历">Raku 降临节日历</h2>
<p>Raku 社区每年 12 月都会发布一个 <a href="https://rakuadvent.wordpress.com/">Advent Calendar</a>，每天都有 Raku 教程，直到圣诞节。通过不同的 Raku 频道和 <a href="https://github.com/raku/mu">Raku/mu</a> 存储库完成组织和日期分配。如果您想参与，它将在10月底开始组织，因此请查看上面的频道。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[关于文档]]></title>
            <link href="http://localhost:1313/rakulang/28.about-the-docs/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/27.regexes-best-practices-and-gotchas/?utm_source=atom_feed" rel="related" type="text/html" title="正则表达式最佳实践" />
                <link href="http://localhost:1313/rakulang/26.creating-operators/?utm_source=atom_feed" rel="related" type="text/html" title="创建操作符" />
                <link href="http://localhost:1313/rakulang/25.modules/?utm_source=atom_feed" rel="related" type="text/html" title="模块" />
                <link href="http://localhost:1313/rakulang/24.module-packages/?utm_source=atom_feed" rel="related" type="text/html" title="模块包" />
                <link href="http://localhost:1313/rakulang/23.module-development-utilities/?utm_source=atom_feed" rel="related" type="text/html" title="模块开发工具" />
            
                <id>http://localhost:1313/rakulang/28.about-the-docs/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-03T21:13:31+08:00</published>
            <updated>2018-11-03T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>本文档集代表了正在努力记录 Raku 编程语言的目标是：全面; 使用方便; 易于导航; 对新手和经验丰富的 Raku 程序员都很有用。</p>
<p>该文档的 HTML 版本位于线上的 <a href="https://docs.raku.org/">https://docs.raku.org</a>。</p>
<p>该文档的官方来源位于 <a href="https://github.com/raku/doc">GitHub上的raku/doc</a>。</p>
<p>本特定文档快速概述了<a href="https://github.com/raku/doc/blob/master/CONTRIBUTING.md">在GitHub上的贡献</a>中更详细描述的过程。本文档还简要介绍了编写 Raku Pod 文件，这些文件可以渲染为 HTML 和其他格式。</p>
<h1 id="结构httpsdocsrakuorglanguageabout___top"><a href="https://docs.raku.org/language/about#___top">结构</a></h1>
<p>所有文档都是用 Raku Pod 编写的，并保存在 <code>doc/</code> 目录 <code>doc/Language/</code> 和 <code>doc/Type/</code> 子目录中。这些文件作为定义集合或“文档”处理，然后进行后处理并链接在一起。</p>
<h1 id="从-pod-生成-htmlhttpsdocsrakuorglanguageabout___top"><a href="https://docs.raku.org/language/about#___top">从 Pod 生成 HTML</a></h1>
<p>要从 Pod 文件生成 HTML，你需要：</p>
<ul>
<li>最新版本的 Rakudo Raku 编译器</li>
<li>Raku 模块Pod::To::HTML，Pod::To::BigPage 和 URI::Escape（可以通过<a href="https://github.com/ugexe/zef">zef</a>安装）。</li>
<li><strong>可选</strong>：<a href="https://www.graphviz.org/">GraphViz</a>，用于创建 Raku 类型之间关系的图形</li>
<li><strong>可选</strong>：<a href="https://github.com/atom/highlights">Atom Highlights</a> 和 <a href="https://atom.io/packages/language-raku">language-raku</a>，用于语法高亮显示</li>
</ul>
<p>要在文件<code>html/</code>文件夹中生成文档，请运行：</p>
<pre tabindex="0"><code>raku htmlify.p6
</code></pre><p>要从 Web 服务器托管文档，请安装 Perl 5 和 Mojolicious::Lite，然后运行：</p>
<pre tabindex="0"><code>perl app.pl daemon
</code></pre><h1 id="贡献httpsdocsrakuorglanguageabout___top"><a href="https://docs.raku.org/language/about#___top">贡献</a></h1>
<p>文档是用 Raku Pod 编写的。</p>
<p>有关 Raku Pod 的快速介绍，请参阅<a href="https://docs.raku.org/language/pod">Raku Pod</a>。</p>
<p>有关 Raku Pod 规范的完整详细信息，请参见<a href="https://design.raku.org/S26.html">概要26,文档</a>。</p>
<h2 id="添加定义httpsdocsrakuorglanguageabout___top"><a href="https://docs.raku.org/language/about#___top">添加定义</a></h2>
<p>Documentables 可以使用 <code>=headN</code> Pod 指令来定义，其中 <code>N</code> 大于零（例如，<code>=head1</code>，<code>=head2</code>，&hellip;）。</p>
<p>该指令之后的所有段落和块，直到同一级别的下一个指令，将被视为可记录的一部分。所以，在：</p>
<pre tabindex="0"><code class="language-pod6" data-lang="pod6">=head2 My Definition

Some paragraphs, followed by some code:

    my Code $examples = &#34;amazing&#34;;

Mind === blown.

=head3 Minor details about My Definition

It&#39;s fantastic.

=head2 And now, for something completely different

…
</code></pre><p>可记录的 <code> My Definition</code> 延伸到了 <code>=head2 And now…</code>。</p>
<p>可记录文件可能包含其他文件。例如，类可记录文件通常包含类实现的方法。</p>
<p>定义必须采用下列形式之一才能被识别为名为 document 文件的起点。首先是文档源代码：</p>
<pre tabindex="0"><code class="language-pod6" data-lang="pod6">=item X&lt;C&lt;How to use the þ infix&gt; | infix,þ&gt; (This a special case, which 
is always considered a definition)
 
=item C&lt;The þ Infix&gt; 
 
=item B&lt;The C&lt;þ&gt; Infix&gt; 
 
=item C&lt;Infix þ&gt; 
 
=item B&lt;Infix C&lt;þ&gt;&gt; 
 
=item C&lt;trait is cached&gt; (A special case for the L&lt;trait|/language/functions#Traits&gt; documentables) 
 
</code></pre><p>然后是渲染页面上的结果：</p>
<ul>
<li><code>How to use the þ infix</code> （这是一种特殊情况，始终被视为定义）</li>
<li><code>The þ Infix</code></li>
<li><strong>The þ Infix</strong></li>
<li><code>Infix þ</code></li>
<li><strong>Infix þ</strong></li>
<li><code>trait is cached</code>（<a href="https://docs.raku.org/language/functions#Traits">trait</a>文档的特例）</li>
</ul>
<p>现在可以使用 HTML 文档中的搜索字段搜索这些项。</p>
<p>您可以使用粗体（<strong>B&lt;&gt;</strong>）或斜体（<strong>I&lt;&gt;</strong>）添加强调，可以使用或不使用代码格式（<strong>C&lt;&gt;</strong>）。由于当前的解析器限制，必须采取特殊步骤将**X&lt;&gt;**与其他格式代码一起使用; 例如：</p>
<pre tabindex="0"><code class="language-pod6" data-lang="pod6">=item X&lt;B&lt;foo&gt;|foo&gt; a fancy subroutine 
</code></pre><p>像这样渲染</p>
<ul>
<li><strong>foo</strong> a fancy subroutine</li>
</ul>
<p>请注意，管道（“|”）之后的文本没有格式。另请注意，**C&lt;&gt;**保留空格并将文本视为逐字处理。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[正则表达式最佳实践]]></title>
            <link href="http://localhost:1313/rakulang/27.regexes-best-practices-and-gotchas/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/26.creating-operators/?utm_source=atom_feed" rel="related" type="text/html" title="创建操作符" />
                <link href="http://localhost:1313/rakulang/25.modules/?utm_source=atom_feed" rel="related" type="text/html" title="模块" />
                <link href="http://localhost:1313/rakulang/24.module-packages/?utm_source=atom_feed" rel="related" type="text/html" title="模块包" />
                <link href="http://localhost:1313/rakulang/23.module-development-utilities/?utm_source=atom_feed" rel="related" type="text/html" title="模块开发工具" />
                <link href="http://localhost:1313/rakulang/22.iterating/?utm_source=atom_feed" rel="related" type="text/html" title="迭代" />
            
                <id>http://localhost:1313/rakulang/27.regexes-best-practices-and-gotchas/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-02T21:13:31+08:00</published>
            <updated>2018-11-02T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>为了提供强大的正则表达式和 grammar，这里有一些代码布局和可读性的最佳实践，实际匹配的内容，以及避免常见的陷阱。</p>
<h2 id="代码布局">代码布局</h2>
<p>如果没有 <code>:sigspace</code> 副词，在 Raku 正则表达式中空格并不重要。 使用它自己的优势，并插入空格，增加可读性。 此外，必要时插入注释。</p>
<p>比较非常紧凑的写法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">float</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="se">\d</span><span class="o">*</span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="se">\d</span><span class="o">+</span><span class="p">[</span><span class="sr">e</span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="se">\d</span><span class="o">+</span><span class="p">]</span><span class="o">?</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>和这种可读性更好的写法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">float</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="sr">        </span><span class="c1"># optional sign 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">     </span><span class="se">\d</span><span class="o">*</span><span class="sr">            </span><span class="c1"># leading digits, optional 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">     </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="se">\d</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">[</span><span class="sr">              </span><span class="c1"># optional exponent 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">        e </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="sr">  </span><span class="se">\d</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">]</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><p>根据经验， 在原子周围和组的内部使用空白; 将量词直接放在原子之后; 并垂直对齐开口和闭合关方括号和括号。</p>
<p>在括号或方括号内使用替换列表时，请对齐竖线：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">example</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">preamble</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">[</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">choice_1</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">choice_2</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">choice_3</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">]</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">postamble</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><h2 id="保持短小">保持短小</h2>
<p>正则代码通常比常规代码更紧凑。 因为他们用这么少的字符就做得那么多，所以保持了正则表达式的简短。</p>
<p>当你可以给正则表达式的一部分命名时，通常最好将它放入一个单独的，命名的正则表达式中。</p>
<p>例如，您可以以前面获取浮点正则表达式为例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">float</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="sr">        </span><span class="c1"># optional sign 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">     </span><span class="se">\d</span><span class="o">*</span><span class="sr">            </span><span class="c1"># leading digits, optional 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">     </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="se">\d</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">[</span><span class="sr">              </span><span class="c1"># optional exponent 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">        e </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="sr">  </span><span class="se">\d</span><span class="o">+</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">     </span><span class="p">]</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><p>并将其分解为部件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">token</span> <span class="nf">sign</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">token</span> <span class="nf">decimal</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">token</span> <span class="nf">exponent</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">e</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sign</span><span class="p">&gt;</span><span class="o">?</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">float</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">sign</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">exponent</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><p>这有助于，特别是当正则表达式变得更加复杂时。 例如，您可能希望在存在指数的情况下使小数点可选。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">float</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">sign</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">[</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">  </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">exponent</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">decimal</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">exponent</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">]</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><h2 id="要匹配什么">要匹配什么</h2>
<p>输入数据格式通常没有明确的规范，或者程序员不知道规范。 然后，按照你的期望自由是好的，但只要没有可能的含糊之处。</p>
<p>例如，在 <code>ini</code> 文件中：</p>
<pre tabindex="0"><code>[section]
key=value
</code></pre><p>section 标题内可以有什么内容？ 只允许一个词可能限制性太强。 有人可能会写<code>[two words]</code>，或使用破折号等。而不是问内部允许什么，可能值得问一下：什么是不允许的？</p>
<p>显然，不允许闭合方括号，因为 <code>[a]b]</code> 是不明确的。 根据同一论点，应禁止开口方括号。 这让我们失望了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">header</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> </span><span class="se">\</span><span class="sr">[</span><span class="se">\</span><span class="sr">] </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>如果你只处理一行就没问题。 但是，如果您正在处理整个文件，那么正则表达式会解析</p>
<pre tabindex="0"><code>[with a
newline in between]
</code></pre><p>这可能不是一个好主意。妥协是</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">header</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> </span><span class="se">\</span><span class="sr">[</span><span class="se">\</span><span class="sr">] </span><span class="se">\n</span><span class="sr"> </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>然后，在后处理中，从 section 标题中删除前导和尾随空格和制表符。</p>
<h2 id="匹配空白">匹配空白</h2>
<p><code>:sigspace</code> 副词（或使用 <code>rule</code> 声明符而不是 <code>token</code> 或 <code>regex</code>）非常便于隐式解析可能出现在许多地方的空格。</p>
<p>回到解析 <code>ini</code> 文件的例子，我们有</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">kvpair</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>这可能不像我们想要的那样的文字，因为用户可能在等号周围放置空格。 那么，我们可以试试这个：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">kvpair</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>但那看起来很笨重，所以我们尝试别的东西：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">rule</span> <span class="nf">kvpair</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>可是等等！ 值之后的隐式空格匹配会占用所有空格，包括换行符，因此 <code>\n+</code> 没有任何东西可以匹配（并且 <code>rule</code> 也禁用了回溯，因此没有运气）。</p>
<p>因此，将隐式空格的定义重新定义为输入格式中不重要的空白非常重要。</p>
<p>这通过重新定义 token <code>ws</code> 来工作; 但是，它只适用于 <a href="https://docs.raku.org/language/grammars">grammars</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">IniFormat</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">ws</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="ow">ww</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">header</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">(</span><span class="se">\w</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">identifier</span>  <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">kvpair</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">section</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">&lt;</span><span class="nf">header</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">&lt;</span><span class="nf">kvpair</span><span class="p">&gt;</span><span class="o">*</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">&lt;</span><span class="nf">section</span><span class="p">&gt;</span><span class="o">*</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$contents</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOI/;</span><span class="s"> 
</span></span></span><span class="line"><span class="cl"><span class="s">    [passwords]
</span></span></span><span class="line"><span class="cl"><span class="s">        jack = password1
</span></span></span><span class="line"><span class="cl"><span class="s">        joy = muchmoresecure123
</span></span></span><span class="line"><span class="cl"><span class="s">    [quotas]
</span></span></span><span class="line"><span class="cl"><span class="s">        jack = 123
</span></span></span><span class="line"><span class="cl"><span class="s">        joy = 42
</span></span></span><span class="line"><span class="cl"><span class="s"></span><span class="p">EOI</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="n">IniFormat</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$contents</span><span class="p">);</span>
</span></span></code></pre></div><p>除了将所有正则表达式都放入 grammar 并将其转换为 tokens（因为它们无论如何都不需要回溯），有趣的一点是</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">ws</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="ow">ww</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>在进行隐式空格分析的时候会调用该 token。 当它不在两个单词字符之间（ <code>&lt;!ww&gt;</code>，&ldquo;在单词中&quot;的否定断言）和零个或多个水平空格字符之间匹配。 对水平空格的限制很重要，因为换行符（垂直空格）会分隔记录，不应被隐式匹配。</p>
<p>不过，潜伏着一些与空白相关的麻烦。 正则表达式 <code>\n+</code> 与 <code>\n \n</code> 之类的字符串不匹配，因为两个换行符之间有空白。 要允许此类输入字符串，请将 <code>\n+</code> 替换为 <code>\n\s*</code>。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[创建操作符]]></title>
            <link href="http://localhost:1313/rakulang/26.creating-operators/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/25.modules/?utm_source=atom_feed" rel="related" type="text/html" title="模块" />
                <link href="http://localhost:1313/rakulang/24.module-packages/?utm_source=atom_feed" rel="related" type="text/html" title="模块包" />
                <link href="http://localhost:1313/rakulang/23.module-development-utilities/?utm_source=atom_feed" rel="related" type="text/html" title="模块开发工具" />
                <link href="http://localhost:1313/rakulang/22.iterating/?utm_source=atom_feed" rel="related" type="text/html" title="迭代" />
                <link href="http://localhost:1313/rakulang/21.inter-process-communication/?utm_source=atom_feed" rel="related" type="text/html" title="进程间通信" />
            
                <id>http://localhost:1313/rakulang/26.creating-operators/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-11-01T21:13:31+08:00</published>
            <updated>2018-11-01T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>通过使用 <code>sub</code> 关键字后跟 <code>prefix</code>, <code>infix</code>, <code>postfix</code>, <code>circumfix</code>, 或 <code>postcircumfix;</code> 声明运算符; 然后是冒号结构中的冒号和运算符名称。对于（后）环缀操作符，用空格分隔这两部分。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">hello</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, world!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">&amp;hello</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>   <span class="c1"># OUTPUT: «Sub␤» </span>
</span></span><span class="line"><span class="cl"><span class="n">hello</span><span class="p">;</span>              <span class="c1"># OUTPUT: «Hello, world!␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$s</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>       <span class="c1"># OUTPUT: «Sub␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$s</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="p">);</span>       <span class="c1"># OUTPUT: «7␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Alternatively we could create a more </span>
</span></span><span class="line"><span class="cl"><span class="c1"># general operator to sum n numbers </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">Σ</span><span class="p">&gt;(</span> <span class="o">*</span><span class="nv">@number-list</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">[+]</span> <span class="nv">@number-list</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Σ</span> <span class="p">(</span><span class="mi">13</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1"># OUTPUT: «30␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">:=:</span><span class="p">&gt;(</span> <span class="nv">$a</span> <span class="k">is</span> <span class="k">rw</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$b</span><span class="o">,</span> <span class="nv">$a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">$num</span><span class="o">,</span> <span class="nv">$letter</span><span class="p">)</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">A</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$num</span><span class="p">;</span>          <span class="c1"># OUTPUT: «A␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$letter</span><span class="p">;</span>       <span class="c1"># OUTPUT: «3␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Swap two variables&#39; values </span>
</span></span><span class="line"><span class="cl"><span class="nv">$num</span> <span class="o">:=:</span> <span class="nv">$letter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$num</span><span class="p">;</span>          <span class="c1"># OUTPUT: «3␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$letter</span><span class="p">;</span>       <span class="c1"># OUTPUT: «A␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!</span><span class="p">&gt;(</span> <span class="kt">Int</span> <span class="nv">$num</span> <span class="k">where</span> <span class="o">*</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span> <span class="o">[*]</span> <span class="mi">1</span><span class="o">..</span><span class="nv">$num</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">0</span><span class="o">!</span><span class="p">;</span>            <span class="c1"># OUTPUT: «1␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">5</span><span class="o">!</span><span class="p">;</span>            <span class="c1"># OUTPUT: «120␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">♥</span><span class="p">&gt;(</span> <span class="nv">$a</span> <span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> „<span class="n">I</span> <span class="n">love</span> <span class="nv">$a</span><span class="o">!</span>“ <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="mi">42</span>♥<span class="p">;</span>               <span class="c1"># OUTPUT: «I love 42!␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">postcircumfix:</span><span class="p">&lt;</span><span class="s">⸨ ⸩</span><span class="p">&gt;(</span> <span class="kt">Positional</span> <span class="nv">$a</span><span class="o">,</span> <span class="kt">Whatever</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$a</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="p">&#39;</span><span class="s1">…</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$a</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>⸨<span class="o">*</span>⸩<span class="p">;</span>      <span class="c1"># OUTPUT: «1…4␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">constant</span> <span class="nb">term</span><span class="o">:</span><span class="p">&lt;</span><span class="s">♥</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">♥</span><span class="p">&#34;;</span> <span class="c1"># We don&#39;t want to quote &#34;love&#34;, do we? </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">circumfix:</span><span class="p">&lt;</span><span class="s">α ω</span><span class="p">&gt;(</span> <span class="nv">$a</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> „<span class="nv">$a</span> <span class="k">is</span> <span class="nc">the</span> <span class="n">beginning</span> <span class="ow">and</span> <span class="n">the</span> <span class="nb">end</span><span class="o">.</span>“
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">α</span>♥<span class="n">ω</span><span class="p">;</span>               <span class="c1"># OUTPUT: «♥ is the beginning and the end.␤» </span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[模块]]></title>
            <link href="http://localhost:1313/rakulang/25.modules/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/24.module-packages/?utm_source=atom_feed" rel="related" type="text/html" title="模块包" />
                <link href="http://localhost:1313/rakulang/23.module-development-utilities/?utm_source=atom_feed" rel="related" type="text/html" title="模块开发工具" />
                <link href="http://localhost:1313/rakulang/22.iterating/?utm_source=atom_feed" rel="related" type="text/html" title="迭代" />
                <link href="http://localhost:1313/rakulang/21.inter-process-communication/?utm_source=atom_feed" rel="related" type="text/html" title="进程间通信" />
                <link href="http://localhost:1313/rakulang/20.input-and-output/?utm_source=atom_feed" rel="related" type="text/html" title="输入和输出" />
            
                <id>http://localhost:1313/rakulang/25.modules/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-31T21:13:31+08:00</published>
            <updated>2018-10-31T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="模块">模块</h1>
<h2 id="导出和选择性导出">导出和选择性导出</h2>
<h3 id="is-export">is export</h3>
<p>packages(包), subroutines(子例程), variables(变量), constants(常量) 和 enums(枚举) , 通过在它们的名字后面添加 <code>is export</code> 特性来导出。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">unit</span> <span class="k">module</span> <span class="nn">MyModule</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">our</span> <span class="nv">$var</span> <span class="k">is</span> <span class="k">export</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">foo</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">constant</span> <span class="nv">$FOO</span> <span class="k">is</span> <span class="k">export</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">foobar</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">FooBar</span> <span class="k">is</span> <span class="k">export</span> <span class="p">&lt;</span><span class="s">one two three</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Packages like classes can be exported too</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># If a subpackage is in the namespace of the current package</span>
</span></span><span class="line"><span class="cl"><span class="c1"># it doesn&#39;t need to be explicitly exported</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyModule::MyClass</span> <span class="p">{};</span>
</span></span></code></pre></div><p>就像所有的 traits 一样, 如果应用到子例程(routine)上, &ldquo;is export&rdquo; 应该出现在参数列表的后面:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span> <span class="p">(</span><span class="kt">Str</span> <span class="nv">$string</span><span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</span></span></code></pre></div><p>你可以给 <code>is export</code> 传递命名参数以组织要导出的符号, 然后导入程序 (importer) 可以剔除和选择导入哪一个。有 3 个预先定义好的标签： <code>ALL</code>, <code>DEFAULT</code>, <code>MANDATORY</code>（强制的）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># lib/MyModule.pm</span>
</span></span><span class="line"><span class="cl"><span class="k">unit</span> <span class="k">module</span> <span class="nn">MyModule</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">bag</span>        <span class="k">is</span> <span class="k">export</span>              <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">pants</span>      <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">MANDATORY</span><span class="p">)</span>  <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">sunglasses</span> <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">day</span><span class="p">)</span>        <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">torch</span>      <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">night</span><span class="p">)</span>      <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">underpants</span> <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">ALL</span><span class="p">)</span>        <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># main.pl</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">lib</span> <span class="p">&#39;</span><span class="s1">lib</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">MyModule</span><span class="p">;</span>           <span class="c1">#bag, pants</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">MyModule</span> <span class="p">:</span><span class="s">DEFAULT</span><span class="p">;</span>  <span class="c1">#the same</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">MyModule</span> <span class="p">:</span><span class="s">day</span><span class="p">;</span>      <span class="c1">#pants, sunglasses</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">MyModule</span> <span class="p">:</span><span class="s">night</span><span class="p">;</span>    <span class="c1">#pants, torch</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">MyModule</span> <span class="p">:</span><span class="s">ALL</span><span class="p">;</span>      <span class="c1">#bag, pants, sunglasses, torch, underpants</span>
</span></span></code></pre></div><h3 id="unitexport">UNIT::EXPORT::*</h3>
<p>表象之下, 其实 <code>is export</code> 是把符号添加到 <code>EXPORT</code> 命名空间中的 <code>UNIT</code> 作用域包中。例如, <code>is export(:FOO)</code> 会把目标添加到 <code>UNIT::EXPORT::FOO</code> 包中。这正是 Raku 决定导入什么所做的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">unit</span> <span class="k">module</span> <span class="nn">MyModule</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">foo</span> <span class="k">is</span> <span class="k">export</span>         <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">bar</span> <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">other</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span></code></pre></div><p>等价于:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">unit</span> <span class="k">module</span> <span class="nn">MyModule</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nb">package</span> <span class="nn">EXPORT::DEFAULT</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">our</span> <span class="k">sub</span> <span class="nf">foo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nb">package</span> <span class="nn">EXPORT::other</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">our</span> <span class="k">sub</span> <span class="nf">bar</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>多数时候, <code>is export</code> 足够用了, 但是当你想动态生成要导出的符号时, <code>EXPORT</code> 包就很有用了。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># lib/MyModule.pm</span>
</span></span><span class="line"><span class="cl"><span class="k">unit</span> <span class="k">module</span> <span class="nn">MuModule</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nb">package</span> <span class="nn">EXPORT::DEFAULT</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">&lt;</span><span class="s">zero one two three four</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$number</span><span class="o">,</span> <span class="nv">$name</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">&lt;</span><span class="s">sqrt log</span><span class="p">&gt;</span> <span class="k">-&gt;</span> <span class="nv">$func</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">OUR::</span><span class="p">{&#39;</span><span class="s1">&amp;</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$func</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">-of-</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$name</span> <span class="p">}</span> <span class="o">:=</span> <span class="k">sub</span> <span class="p">{</span> <span class="nv">$number</span><span class="o">.</span><span class="p">&#34;</span><span class="nv">$func</span><span class="p">()&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># main.pl</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">MyModule</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">sqrt-of-four</span><span class="p">;</span> <span class="c1">#-&gt; 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">log-of-zero</span><span class="p">;</span>  <span class="c1">#-&gt; -Inf</span>
</span></span></code></pre></div><h3 id="export">EXPORT</h3>
<p>你可以用一个 <code>EXPORT</code> 子例程导出任意符号。 <code>EXPORT</code> 必须返回一个 <code>Map</code>, 在 map 里面键是符号名, 键值是想要的值。符号名应该包含(如果有的话)关联类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyModule::Class</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">EXPORT</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="p">&#39;</span><span class="s1">$var</span><span class="p">&#39;</span>      <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">one</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">&#39;</span><span class="s1">@array</span><span class="p">&#39;</span>    <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="s">one two three</span><span class="p">&gt;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">&#39;</span><span class="s1">%hash</span><span class="p">&#39;</span>     <span class="o">=&gt;</span> <span class="p">{</span> <span class="s">one</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">two</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">three</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">four</span><span class="p">&#39;}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">&#39;</span><span class="s1">&amp;doit</span><span class="p">&#39;</span>     <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">&#39;</span><span class="s1">ShortName</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="n">MyModule::class</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># main.pl</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">lib</span> <span class="p">&#39;</span><span class="s1">lib</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">MyModule</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$var</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%hash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">doit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">ShortName</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>  <span class="c1">#-&gt; MyModule::Class.new</span>
</span></span></code></pre></div><p>注意, <code>EXPORT</code> 不能声明在包内, 因为目前的 rakudo(2015.09) 好像把 EXPORT 当作 compunit 的一部分而非包的一部分。</p>
<p>虽然 <code>UNIT::EXPORT</code> 包处理传递给 <code>use</code> 的命名参数, 而 <code>EXPORT</code> sub 处理位置参数。如果你把位置参数传递给 <code>use</code>, 那么这些参数会被传递给 <code>EXPORT</code>. 如果传递了位置参数, 那么 module 就不再需要导出默认符号了。你仍然可以伴随着你的位置参数, 通过显式地给 use 传递 <code>:DEFAULT</code> 参数来导入它们。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># lib/MyModule</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyModule::Class</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">EXPORT</span><span class="p">(</span><span class="nv">$short_name</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nb">do</span> <span class="nv">$short_name</span> <span class="o">=&gt;</span> <span class="n">MyModule::Class</span> <span class="k">if</span> <span class="nv">$short_name</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">always</span> <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">MANDATORY</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">works</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#import with :ALL or :DEFAULT to get</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">shy</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">you found me!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># main.pl</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">lib</span> <span class="p">&#39;</span><span class="s1">lib</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">MyModule</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">foo</span><span class="o">.</span><span class="nb">new</span><span class="p">();</span> <span class="c1">#MyModule::Class.new</span>
</span></span><span class="line"><span class="cl"><span class="nf">always</span><span class="p">();</span>      <span class="c1">#OK   - is imported</span>
</span></span><span class="line"><span class="cl"><span class="nf">shy</span><span class="p">();</span>         <span class="c1">#FAIL - won&#39;t be imported</span>
</span></span></code></pre></div><h2 id="发布模块">发布模块</h2>
<p>如果你已经写了一个 Raku模块, 你想把它分享到社区, 我们会很高兴地把它放到 Raku 模块文件夹清单中。<a href="http://modules.raku.org/">Raku modules directory</a></p>
<p>现在, 你需要使用 git 对你的模块进行版本控制。</p>
<p>这需要你有一个 Github 帐号, 以使你的模块能被从它的 Github 仓库中分享出去。</p>
<p>要分享你的模块, 按照下面说的做：</p>
<ul>
<li>
<p>创建一个以你的模块命名的工程文件夹。 例如, 如果你的模块是 <code>Vortex::TotalPerspective</code> , 那么就创建一个叫做 <code>Vortex::TotalPerspective</code> 的工程文件夹。这个工程目录的名字也会被用作 Github 仓库的名字。</p>
</li>
<li>
<p>让你的工程目录看起来像这样：</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">Vortex-TotalPerspective</span><span class="o">/</span>
</span></span><span class="line"><span class="cl"><span class="o">|--</span> <span class="kt">lib</span>
</span></span><span class="line"><span class="cl"><span class="o">|</span>   `<span class="o">--</span> <span class="n">Vortex</span>
</span></span><span class="line"><span class="cl"><span class="o">|</span>       `<span class="o">--</span> <span class="n">TotalPerspective</span><span class="o">.</span><span class="nf">pm</span>
</span></span><span class="line"><span class="cl"><span class="o">|--</span> <span class="n">LICENSE</span>
</span></span><span class="line"><span class="cl"><span class="o">|--</span> <span class="n">META</span><span class="o">.</span><span class="nf">info</span>
</span></span><span class="line"><span class="cl"><span class="o">|--</span> <span class="n">README</span><span class="o">.</span><span class="nf">md</span>
</span></span><span class="line"><span class="cl">`<span class="o">--</span> <span class="nb">t</span>
</span></span><span class="line"><span class="cl">    `<span class="o">--</span> <span class="n">basic</span><span class="o">.</span><span class="nb">t</span>
</span></span></code></pre></div><p>如果你的工程包含能帮助主模块完成工作的其它模块, 它们应该被放到你的 lib 目录中像这样组织：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="kt">lib</span>
</span></span><span class="line"><span class="cl">`<span class="o">--</span> <span class="n">Vortex</span>
</span></span><span class="line"><span class="cl">    <span class="o">|--</span> <span class="n">TotalPerspective</span><span class="o">.</span><span class="nf">pm</span>
</span></span><span class="line"><span class="cl">    `<span class="o">--</span> <span class="n">TotalPerspective</span>
</span></span><span class="line"><span class="cl">        <span class="o">|--</span> <span class="n">FairyCake</span><span class="o">.</span><span class="nf">pm</span>
</span></span><span class="line"><span class="cl">        `<span class="o">--</span> <span class="n">Gargravarr</span><span class="o">.</span><span class="nf">pm</span>
</span></span></code></pre></div><ul>
<li>
<p><code>README.md</code> 文件是一个 markdown 格式的文件, 它稍后会被 Github 自动渲染成 HTML</p>
</li>
<li>
<p>关于 LICENSE 文件, 如果你没有其它选择, 就是用和 Rakudo Raku 一样的 LICENSE 把。仅仅把它的原始 <a href="https://github.com/rakudo/rakudo/blob/nom/LICENSE">license</a> 复制/粘贴进你自己的 LICENSE 文件中。</p>
</li>
<li>
<p>如果你还没有任何测试, 现在你可以忽略 <code>t</code> 目录 和 <code>basic.t</code> 文件。关于如何写测试, 你可以看看其它模块是怎么使用 <code>Test</code> 的。它和 Perl'5 的 <code>Test::More</code> 很类似。</p>
</li>
<li>
<p>如果要文档化你的模块, 在你的模块中使用 <a href="http://design.raku.org/S26.html">Raku Pod</a> 标记。欢迎给模块写文档, 并且为了浏览的方便, 一旦 Raku module directory(或其它网站) 开始把 Pod 文档渲染成 HTML, 写文档尤为重要。</p>
</li>
<li>
<p>让你的 <code>META.info</code> 文件看起来像这样:</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#34;</span><span class="s2">name</span><span class="p">&#34;</span>        <span class="o">:</span> <span class="p">&#34;</span><span class="s2">Vortex::TotalPerspective</span><span class="p">&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#34;</span><span class="s2">version</span><span class="p">&#34;</span>     <span class="o">:</span> <span class="p">&#34;</span><span class="s2">0.1.0</span><span class="p">&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#34;</span><span class="s2">description</span><span class="p">&#34;</span> <span class="o">:</span> <span class="p">&#34;</span><span class="s2">Wonderful simulation to get some perspective.</span><span class="p">&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#34;</span><span class="s2">author</span><span class="p">&#34;</span>      <span class="o">:</span> <span class="p">&#34;</span><span class="s2">Your Name</span><span class="p">&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#34;</span><span class="s2">provides</span><span class="p">&#34;</span>    <span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="p">&#34;</span><span class="s2">Vortex::TotalPerspective</span><span class="p">&#34;</span> <span class="o">:</span> <span class="p">&#34;</span><span class="s2">lib/Vortex/TotalPerspective.pm</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#34;</span><span class="s2">depends</span><span class="p">&#34;</span>     <span class="o">:</span> <span class="o">[</span> <span class="o">],</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#34;</span><span class="s2">source-url</span><span class="p">&#34;</span>  <span class="o">:</span> <span class="p">&#34;</span><span class="s2">git://github.com/you/Vortex-TotalPerspective.git</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>关于选择版本号的方案, 或许使用 &ldquo;major.minor.patch&rdquo; （查看  the spec on versioning 获取详细信息 ）。如果版本号现在对你或你的用户来说不重要, 你可以给版本那儿放上一颗星(*)。</p>
<p>在 <code>provides</code> 一节, 包含进你的发布中提供的所有命名空间。</p>
<ul>
<li>把你的工程放在 git 版本控制之下, 如果你还未这样做。</li>
<li>一旦你对你的工程满意了, 在 Github 上为它创建一个仓库。必要的话,  查看 <a href="https://help.github.com/">Github&rsquo;s help docs</a>。 你的 Github 仓库的名字应该和你工程目录的名字一样。创建完 Githhub 仓库后, Github 会为你展示怎么配置你的本地仓库以获悉你的 Github 仓库。</li>
<li>把你的工程推送到 Github。</li>
<li>在 IRC 频道找个人帮你展示怎么把你的模块添加到<a href="https://github.com/raku/ecosystem">ecosystem</a>, 或者让他们是否能替你添加。</li>
<li>pull 请求被接收之后, 等个把小时。如果你的模块没有出现在  <a href="http://modules.raku.org/">http://modules.raku.org/</a> , 请到 <a href="http://modules.raku.org/log/update.log">http://modules.raku.org/log/update.log</a> 翻看log 日志文件, 以查找是否有错误。</li>
</ul>
<p>就是这样啦！ 感谢为 Raku 社区做贡献！</p>
<p>如果你想尝试安装你的模块, 使用熊猫 panda 安装工具, 这已经包含在 Rakudo Raku 中了:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">zef</span> <span class="nb">install</span> <span class="n">Vortex::TotalPerspective</span>
</span></span></code></pre></div><p>这会下载你的模块到它自己的工作目录(<code>~/.panda</code>), 在那儿创建 build, 并把模块安装到 <code>~/.raku</code></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[模块包]]></title>
            <link href="http://localhost:1313/rakulang/24.module-packages/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/23.module-development-utilities/?utm_source=atom_feed" rel="related" type="text/html" title="模块开发工具" />
                <link href="http://localhost:1313/rakulang/22.iterating/?utm_source=atom_feed" rel="related" type="text/html" title="迭代" />
                <link href="http://localhost:1313/rakulang/21.inter-process-communication/?utm_source=atom_feed" rel="related" type="text/html" title="进程间通信" />
                <link href="http://localhost:1313/rakulang/20.input-and-output/?utm_source=atom_feed" rel="related" type="text/html" title="输入和输出" />
                <link href="http://localhost:1313/rakulang/19.grammar-tutorial/?utm_source=atom_feed" rel="related" type="text/html" title="Grammar 指南" />
            
                <id>http://localhost:1313/rakulang/24.module-packages/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-30T21:13:31+08:00</published>
            <updated>2018-10-30T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p><em>N.B.</em> &ldquo;Module&rdquo; is an overloaded term in Raku; this document focuses on use of the <code>module</code> declarator.</p>
<p><em>注意</em> “模块”是 Raku 中的重载术语; 本文档重点介绍 <code>module</code> 声明符的使用。</p>
<h1 id="什么是模块httpsdocsrakuorglanguagemodule-packages___top"><a href="https://docs.raku.org/language/module-packages#___top">什么是模块?</a></h1>
<p>模块，如类和 grammars，是一种<a href="https://docs.raku.org/language/packages">包</a>。模块对象是 <code>ModuleHOW</code> 元类的实例; 这提供了某些功能，可用于创建命名空间，版本控制，代理和数据封装（另请参见<a href="https://docs.raku.org/syntax/class">类</a>和<a href="https://docs.raku.org/syntax/role">角色</a>）。</p>
<p>要创建模块，请使用 <code>module</code> 声明符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">module</span> <span class="nn">M</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">M</span><span class="o">.</span><span class="nb">HOW</span><span class="p">;</span>   <span class="c1"># OUTPUT: «Raku::Metamodel::ModuleHOW.new» </span>
</span></span></code></pre></div><p>这里我们定义一个名为 <code>M</code> 的新模块; 内省 <code>HOW</code> 确认了底层的元类 <code>M</code> 是 <code>Raku::Metamodel::ModuleHOW</code>。</p>
<h2 id="何时使用模块httpsdocsrakuorglanguagemodule-packages___top"><a href="https://docs.raku.org/language/module-packages#___top">何时使用模块</a></h2>
<p>模块主要用于封装不属于类或角色定义的代码和数据。模块内容（类，子程序，变量等）可以从具有 <code>is export</code> trait 的模块中导出; 一旦<code>import</code> 或 <code>use</code> 了模块，这些内容在调用者的命名空间中就可用了。模块还可以选择性地在其命名空间中通过 <code>our</code> 暴露符号以进行限定引用。</p>
<h2 id="使用模块httpsdocsrakuorglanguagemodule-packages___top"><a href="https://docs.raku.org/language/module-packages#___top">使用模块</a></h2>
<p>为了说明模块作用域和导出规则，我们首先定义一个简单的模块 <code>M</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">module</span> <span class="nn">M</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">sub</span> <span class="nf">greeting</span> <span class="p">(</span><span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Camelia</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Greetings, </span><span class="nv">$name</span><span class="s2">!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">our</span> <span class="k">sub</span> <span class="nf">loud-greeting</span> <span class="p">(</span><span class="k">--&gt;</span> <span class="kt">Str</span><span class="p">)</span>  <span class="p">{</span> <span class="nf">greeting</span><span class="p">()</span><span class="o">.</span><span class="nb">uc</span>       <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">sub</span> <span class="n">friendly-greeting</span> <span class="k">is</span> <span class="k">export</span>  <span class="p">{</span> <span class="nf">greeting</span><span class="p">(&#39;</span><span class="s1">friend</span><span class="p">&#39;)</span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>回想一下，子例程是词法作用域的，除非另有说明（声明符 <a href="https://docs.raku.org/syntax/sub"><code>sub</code></a> 等效于 <code>my sub</code>），因此<code>greeting</code> 在上面的示例中，词法作用域为模块并且在其外部不可访问。我们还使用 <code>our</code> 声明符定义了 <code>loud-greeting</code>，这意味着除了在词法作用域内，它还在模块的符号表中起了别名。最后，<code>friendly-greeting</code> 标记为导出; 导入模块时，它将在<em>调用者的</em>符号表中注册：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">import</span> <span class="n">M</span><span class="p">;</span>               <span class="c1"># import the module </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">M::loud-greeting</span><span class="p">;</span>   <span class="c1"># OUTPUT: «GREETINGS, CAMELIA!» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">friendly-greeting</span><span class="p">;</span>  <span class="c1"># OUTPUT: «Greetings, friend!» </span>
</span></span></code></pre></div><h1 id="磁盘上的模块httpsdocsrakuorglanguagemodule-packages___top"><a href="https://docs.raku.org/language/module-packages#___top">磁盘上的模块</a></h1>
<p>虽然 <code>.pm</code> 和 <code>.pm6</code> 文件（以下简称: <code>.pm6</code>) 有时被称为“模块”，但它们实际上只是在您写了 <code>need</code>，<code>use</code> 或者 <code>require</code> 时加载和编译的普通文件。</p>
<p>对于我们一直使用的意义上提供模块的 <code>.pm6</code>  文件，它需要如上所述用的用 <code>module</code> 声明一个模块。例如，通过将模块 <code>M</code> 放入 <code>Foo.pm6</code> 内部，我们可以按如下方式加载和使用模块：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Foo</span><span class="p">;</span>                <span class="c1"># find Foo.pm6, run need followed by import </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">M::loud-greeting</span><span class="p">;</span>   <span class="c1"># OUTPUT: «GREETINGS, CAMELIA!» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">friendly-greeting</span><span class="p">;</span>  <span class="c1"># OUTPUT: «Greetings, friend!» </span>
</span></span></code></pre></div><p>注意文件名和模块名之间的解耦 - <code>.pm6</code> 文件可以声明零个或多个具有任意标识符的模块。</p>
<h2 id="文件和模块命名httpsdocsrakuorglanguagemodule-packages___top"><a href="https://docs.raku.org/language/module-packages#___top">文件和模块命名</a></h2>
<p>我们通常希望 <code>.pm6</code> 文件提供<em>单个</em>模块，仅此而已。这里的常见约定是文件 basename 与模块名称匹配。回到 <code>Foo.pm6</code>，显而易见的是，它仅提供单个模块，<code>M</code>; 在这种情况下，我们可能想要重命名 <code>M</code> 为 <code>Foo</code>。修改后的文件将为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">module</span> <span class="nn">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">sub</span> <span class="nf">greeting</span> <span class="p">(</span><span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Camelia</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Greetings, </span><span class="nv">$name</span><span class="s2">!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">our</span> <span class="k">sub</span> <span class="nf">loud-greeting</span> <span class="p">(</span><span class="k">--&gt;</span> <span class="kt">Str</span><span class="p">)</span>  <span class="p">{</span> <span class="nf">greeting</span><span class="p">()</span><span class="o">.</span><span class="nb">uc</span>       <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">sub</span> <span class="n">friendly-greeting</span> <span class="k">is</span> <span class="k">export</span>  <span class="p">{</span> <span class="nf">greeting</span><span class="p">(&#39;</span><span class="s1">friend</span><span class="p">&#39;)</span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可被调用者更一致地使用（注意 <code>use Foo</code> 和 <code>Foo::</code> 之间的关系）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Foo::loud-greeting</span><span class="p">;</span>  <span class="c1"># OUTPUT: «GREETINGS, CAMELIA!» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">friendly-greeting</span><span class="p">;</span>   <span class="c1"># OUTPUT: «Greetings, friend!» </span>
</span></span></code></pre></div><p>如果 <code>Foo.pm6</code> 在源树中放置得更深，例如在 <code>lib/Utils/Foo.pm6</code> 中，我们可以选择命名模块 <code>Utils::Foo</code> 以保持一致性。</p>
<h3 id="unit-关键字httpsdocsrakuorglanguagemodule-packages___top"><a href="https://docs.raku.org/language/module-packages#___top"><code>unit</code> 关键字</a></h3>
<p>只提供单个模块的文件可以用 <code>unit</code> 关键字更简洁地编写; <code>unit module</code> 指定编译单元的其余部分是声明的模块的一部分。这里 <code>Foo.pm6</code> 使用 <code>unit</code> 重写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">unit</span> <span class="k">module</span> <span class="nn">Foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">greeting</span> <span class="p">(</span><span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Camelia</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Greetings, </span><span class="nv">$name</span><span class="s2">!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">our</span> <span class="k">sub</span> <span class="nf">loud-greeting</span> <span class="p">(</span><span class="k">--&gt;</span> <span class="kt">Str</span><span class="p">)</span>  <span class="p">{</span> <span class="nf">greeting</span><span class="p">()</span><span class="o">.</span><span class="nb">uc</span>       <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">friendly-greeting</span> <span class="k">is</span> <span class="k">export</span>  <span class="p">{</span> <span class="nf">greeting</span><span class="p">(&#39;</span><span class="s1">friend</span><span class="p">&#39;)</span>  <span class="p">}</span>
</span></span></code></pre></div><p>单元声明后的所有内容都是 <code>Foo</code> 模块规范的一部分。</p>
<p>（请注意，<code>unit</code> 也可以用于 <code>class</code>，<code>grammar</code> 和 <code>role</code>）。</p>
<h2 id="如果我省略了module会发生什么httpsdocsrakuorglanguagemodule-packages___top"><a href="https://docs.raku.org/language/module-packages#___top">如果我省略了<code>module</code>会发生什么?</a></h2>
<p>为了更好地理解在 <code>Foo.pm6</code> 中 <code>module</code> 声明符在做什么，让我们将它与变体文件 <code>Bar.pm6</code> 进行对比，它省略了声明。下面的子程序定义几乎相同（唯一的区别在于 <code>greeting</code> 的正文，为了清晰起见而修改）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">greeting</span> <span class="p">(</span><span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Camelia</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Greetings from Bar, </span><span class="nv">$name</span><span class="s2">!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">our</span> <span class="k">sub</span> <span class="nf">loud-greeting</span> <span class="p">(</span><span class="k">--&gt;</span> <span class="kt">Str</span><span class="p">)</span>  <span class="p">{</span> <span class="nf">greeting</span><span class="p">()</span><span class="o">.</span><span class="nb">uc</span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">friendly-greeting</span> <span class="k">is</span> <span class="k">export</span>  <span class="p">{</span> <span class="nf">greeting</span><span class="p">(&#39;</span><span class="s1">friend</span><span class="p">&#39;)</span>           <span class="p">}</span>
</span></span></code></pre></div><p>提醒一下，这是我们以前使用 <code>Foo.pm6</code> 的方式，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Foo::loud-greeting</span><span class="p">;</span>  <span class="c1"># OUTPUT: «GREETINGS, CAMELIA!» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">friendly-greeting</span><span class="p">;</span>   <span class="c1"># OUTPUT: «Greetings, friend!» </span>
</span></span></code></pre></div><p>这是我们使用 <code>Bar.pm6</code> 的方式，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Bar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">loud-greeting</span><span class="p">;</span>       <span class="c1"># OUTPUT: «GREETINGS FROM BAR, CAMELIA!» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">friendly-greeting</span><span class="p">;</span>   <span class="c1"># OUTPUT: «Greetings from Bar, friend!» </span>
</span></span></code></pre></div><p>注意 <code>loud-greeting</code> 的使用，而不是 <code>Bar::loud-greeting</code> 因为 <code>Bar</code> 不是已知符号（我们没有在 <code>Bar.pm6</code> 中创建一个以那个名字命名的 <code>module</code>）。但是为什么 <code>loud-greeting</code>是可调用的, 即使我们没有将其标记为导出。答案很简单，<code>Bar.pm6</code> 不创建一个新的包命名空间 - <code>$?PACKAGE</code> 仍设置为 <code>GLOBAL</code> 当我们将 <code>loud-greeting</code>声明为 <code>our</code> 时，它被注册到 <code>GLOBAL</code> 符号表中。</p>
<h3 id="词法别名和安全httpsdocsrakuorglanguagemodule-packages___top"><a href="https://docs.raku.org/language/module-packages#___top">词法别名和安全</a></h3>
<p>值得庆幸的是，Raku 保护我们免受意外调用地点定义的痛击（例如内置函数）。除了 <code>Bar.pm6</code> 考虑以下内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">our</span> <span class="k">sub</span> <span class="nb">say</span> <span class="p">(</span><span class="nv">$ignored</span><span class="p">)</span> <span class="p">{</span> <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">oh dear</span><span class="se">\n</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span></code></pre></div><p>这会创建一个词法别名，将内置 <code>say</code> 隐藏在 <code>Bar.pm6</code> <em>内部</em> 但保持调用者 <code>say</code> 不变。因此，以下 <code>say</code> 调用仍然按预期工作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Bar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Carry on, carry on...</span><span class="p">&#39;;</span>  <span class="c1"># OUTPUT: «Carry on, carry on...» </span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[模块开发工具]]></title>
            <link href="http://localhost:1313/rakulang/23.module-development-utilities/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/22.iterating/?utm_source=atom_feed" rel="related" type="text/html" title="迭代" />
                <link href="http://localhost:1313/rakulang/21.inter-process-communication/?utm_source=atom_feed" rel="related" type="text/html" title="进程间通信" />
                <link href="http://localhost:1313/rakulang/20.input-and-output/?utm_source=atom_feed" rel="related" type="text/html" title="输入和输出" />
                <link href="http://localhost:1313/rakulang/19.grammar-tutorial/?utm_source=atom_feed" rel="related" type="text/html" title="Grammar 指南" />
                <link href="http://localhost:1313/rakulang/18.entering-unicode-characters/?utm_source=atom_feed" rel="related" type="text/html" title="输入 Unicode 字符" />
            
                <id>http://localhost:1313/rakulang/23.module-development-utilities/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-29T21:13:31+08:00</published>
            <updated>2018-10-29T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>以下是您可以在 Raku 生态系统中找到的模块列表，旨在使开发 Raku 模块的体验更加有趣。</p>
<h2 id="模块构建器和创作工具">模块构建器和创作工具</h2>
<p>一些模块和工具可帮助您生成属于模块分发的文件。</p>
<ul>
<li><a href="https://modules.raku.org/dist/App::Assixt">App::Assixt</a> 模块开发者的助手</li>
<li><a href="https://modules.raku.org/dist/App::Mi6">App::Mi6</a> Raku 的最小创作工具</li>
<li><a href="https://modules.raku.org/dist/META6">META6</a> 用 Raku META 文件做事</li>
<li><a href="https://bitbucket.org/rightfold/module-skeleton">Module::Skeleton</a> 生成骨架模块</li>
<li><a href="https://modules.raku.org/dist/p6doc">p6doc</a> 生成文档最终产品</li>
</ul>
<h2 id="tests">Tests</h2>
<p>一些模块质量测试。</p>
<ul>
<li><a href="https://modules.raku.org/dist/Test::META">Test::META</a> 测试您的 META6.json 文件</li>
<li><a href="https://modules.raku.org/dist/Test::Output">Test::Output</a> 测试程序生成的 STDOUT 和 STDERR 的输出</li>
<li><a href="https://modules.raku.org/dist/Proc::Screen">Test::Screen</a> 使用<strong>GNU screen</strong>测试全屏VT应用程序</li>
<li><a href="https://modules.raku.org/dist/Test::When">Test::When</a> 控制测试运行时间（作者测试，在线测试等）</li>
</ul>
<h1 id="nativecallhttpsdocsrakuorglanguagemodules-extra___top"><a href="https://docs.raku.org/language/modules-extra#___top">NativeCall</a></h1>
<p>这里有一些模块可以帮助您使用 NativeCall。</p>
<ul>
<li><a href="https://modules.raku.org/dist/NativeHelpers::Array">NativeHelpers::Array</a> 提供处理 CArray 的例程</li>
<li><a href="https://modules.raku.org/dist/App::GPTrixie">App::GPTrixie</a> 从 C 头文件生成 NativeCall 代码</li>
<li><a href="https://modules.raku.org/dist/NativeCall::TypeDiag">NativeCall::TypeDiag</a> 提供测试 CStruct 的例程</li>
</ul>
<h1 id="sample-moduleshttpsdocsrakuorglanguagemodules-extra___top"><a href="https://docs.raku.org/language/modules-extra#___top">Sample modules</a></h1>
<p>仅作为极简主义示例，安装程序测试或骨架的模块。</p>
<ul>
<li><a href="https://modules.raku.org/dist/Foo">Foo</a> 具有两个不同版本分布的模块</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[迭代]]></title>
            <link href="http://localhost:1313/rakulang/22.iterating/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/21.inter-process-communication/?utm_source=atom_feed" rel="related" type="text/html" title="进程间通信" />
                <link href="http://localhost:1313/rakulang/20.input-and-output/?utm_source=atom_feed" rel="related" type="text/html" title="输入和输出" />
                <link href="http://localhost:1313/rakulang/19.grammar-tutorial/?utm_source=atom_feed" rel="related" type="text/html" title="Grammar 指南" />
                <link href="http://localhost:1313/rakulang/18.entering-unicode-characters/?utm_source=atom_feed" rel="related" type="text/html" title="输入 Unicode 字符" />
                <link href="http://localhost:1313/rakulang/17.doing-math-with-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="用 Raku 做数学" />
            
                <id>http://localhost:1313/rakulang/22.iterating/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-28T21:13:31+08:00</published>
            <updated>2018-10-28T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h2 id="iterator-和-iterable-角色">Iterator 和 Iterable 角色</h2>
<p>Raku 是一种函数式语言，但在处理复杂的数据结构时，函数需要保持住。特别是，他们需要一个可以应用于所有这些界面的统一接口。此接口由 <a href="https://docs.raku.org/type/Iterator">Iterator</a> 和 <a href="https://docs.raku.org/type/Iterable">Iterable</a> 角色提供。</p>
<p><code>Iterable</code> 角色相对简单。它为迭代器方法提供了一个存根，该方法实际上是由诸如 <code>for</code> 之类的语句使用的。 <code>for</code> 会在它前面的变量上调用 <code>.iterator</code>，然后为每个项目运行一次块。其他方法（如数组赋值）将使 <code>Iterable</code> 类以相同的方式运行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DNA</span> <span class="k">does</span> <span class="kt">Iterable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.chain</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">new</span> <span class="p">(</span><span class="nv">$chain</span> <span class="k">where</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                       <span class="nv">$chain</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^^</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr">ACGT</span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="ni">$$</span><span class="sr"> </span><span class="p">/</span> <span class="ow">and</span>
</span></span><span class="line"><span class="cl">                       <span class="nv">$chain</span><span class="o">.</span><span class="nb">chars</span> <span class="nv">%%</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span> <span class="o">:</span><span class="nv">$chain</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">iterator</span><span class="p">(</span><span class="n">DNA:D:</span><span class="p">){</span> <span class="nv">$.chain</span><span class="o">.</span><span class="nb">comb</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">iterator</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@longer-chain</span> <span class="o">=</span>  <span class="n">DNA</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">ACGTACGTT</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@longer-chain</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «[(&#34;A&#34;, &#34;C&#34;, &#34;G&#34;), (&#34;T&#34;, &#34;A&#34;, &#34;C&#34;), (&#34;G&#34;, &#34;T&#34;, &#34;T&#34;)]␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span>  <span class="nv">@longer-chain</span><span class="o">».</span><span class="nb">join</span><span class="p">(&#34;&#34;)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">|</span><span class="p">&#34;);</span> <span class="c1">#OUTPUT: «ACG|TAC|GTT␤» </span>
</span></span></code></pre></div><p>在这个示例中，它是 <a href="https://docs.raku.org/type/Iterable">Iterable</a> 中示例的扩展，显示了如何调用 <code>.iterator</code>，只是在将创建的对象分配给<a href="https://docs.raku.org/type/Positional">位置</a>变量 <code>@long-chain</code> 时调用此方法;这个变量是一个数组，我们在最后一个例子中对它进行操作。</p>
<p>（可能有点容易混淆）<code>Iterator</code> 角色比 <code>Iterable</code> 更复杂一点。首先，它提供了一个常量 <code>IterationEnd</code>，但它提供了一系列方法，如 <code>.pull-one</code>，它允许在几个上下文中进行更精细的迭代操作：添加或删除项目，或跳过它们以访问其他项目。实际上，该角色为所有其他方法提供了一个默认实现，因此唯一需要定义的方法就是 <code>pull-one</code>，其中只提供了一个 <code>stub</code>。虽然 <code>Iterable</code> 提供了高级变量循环，<code>Iterator</code> 提供了在循环的每次迭代中调用的低级函数。让我们用这个角色扩展前面的例子。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DNA</span> <span class="k">does</span> <span class="kt">Iterable</span> <span class="k">does</span> <span class="kt">Iterator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.chain</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Int</span> <span class="nv">$!index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">new</span> <span class="p">(</span><span class="nv">$chain</span> <span class="k">where</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                       <span class="nv">$chain</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^^</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr">ACGT</span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="ni">$$</span><span class="sr"> </span><span class="p">/</span> <span class="ow">and</span>
</span></span><span class="line"><span class="cl">                       <span class="nv">$chain</span><span class="o">.</span><span class="nb">chars</span> <span class="nv">%%</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span> <span class="o">:</span><span class="nv">$chain</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">iterator</span><span class="p">(</span> <span class="p">){</span> <span class="nb">self</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">pull-one</span><span class="p">(</span> <span class="k">--&gt;</span> <span class="kt">Mu</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nv">$!index</span> <span class="o">&lt;</span> <span class="nv">$.chain</span><span class="o">.</span><span class="nb">chars</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">my</span> <span class="nv">$codon</span> <span class="o">=</span> <span class="nv">$.chain</span><span class="o">.</span><span class="nb">comb</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">[</span><span class="nv">$!index</span> <span class="ow">div</span> <span class="mi">3</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$!index</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nv">$codon</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">IterationEnd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">:=</span> <span class="n">DNA</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">GAATCC</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1"># OUTPUT: «(G A A)␤(T C C)␤» </span>
</span></span></code></pre></div><p>我们声明一个 <code>DNA</code> 类，它扮演两个角色，<code>Iterator</code> 和 <code>Iterable</code>;该类将包含一个字符串，该字符串将被约束为长度为3的倍数且仅由 ACGT 组成。我们先来看看 <code>pull-one</code> 方法。每次发生新的迭代时都会调用这个，因此它必须保持最后一个的状态。 <code>$.index</code> 属性将在调用中保持该状态; <code>pull-one</code> 将检查链的末尾是否已到达，并将返回角色提供的 <code>IterationEnd</code> 常量。实际上，实现这种低级接口简化了 <code>Iterable</code> 接口的实现。现在迭代器将成为对象本身，因为我们可以在其上调用 <code>pull-one</code> 来依次访问每个成员;因此，<code>.iterator</code> 将回归自我;这是可能的，因为对象将同时是 <code>Iterable</code> 和 <code>Iterator</code>。</p>
<p>这并非总是如此，并且在大多数情况下 <code>.iterator</code> 将必须构建要返回的迭代器类型，例如我们在前面的示例中所做的;但是，此示例显示了构建满足迭代器和可迭代角色的类所需的最少代码。</p>
<h2 id="如何迭代上下文化和主题变量">如何迭代：上下文化和主题变量</h2>
<p><code>for</code> 和其他循环将每次迭代中生成的项放入<a href="https://docs.raku.org/language/variables#index-entry-topic_variable">主题变量</a> <code>$_</code> 中，或将它们捕获到与块一起声明的变量中。这些变量可以直接在循环中使用，而不需要使用 <a href="https://docs.raku.org/syntax/$CIRCUMFLEX_ACCENT#%28Traps_to_avoid%29_twigil_%5E"><code>^twigil</code></a> 来声明它们。</p>
<p>使用<a href="https://docs.raku.org/language/operators#index-entry-..._operators">序列运算符</a>时会发生隐式迭代。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span> <span class="p">{</span> <span class="nv">$^a</span>²<span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="nv">$^b</span><span class="o">+</span><span class="nv">$^c</span> <span class="p">}</span> <span class="o">…</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">;</span> <span class="c1"># OUTPUT: «(1 1 1 4 7 16 46 127 475) </span>
</span></span></code></pre></div><p>生成块正在运行一次，而完成序列的条件，在这种情况下，术语大于300，则不满足。这具有运行循环的副作用，但也创建了输出列表。</p>
<p>这可以通过使用 <a href="https://docs.raku.org/syntax/gather%20take">gather/take</a> 块来更系统地完成，这是一种不同类型的迭代构造，而不是在 sink 上下文中运行，每次迭代都返回一个项目。这个 <a href="https://rakuadvent.wordpress.com/2009/12/23/day-23-lazy-fruits-from-the-gather-of-eden/">Advent Calendar</a> 教程解释了这种循环的用例;实际上，<code>gather</code> 不是一个循环结构，而是一个语句前缀，它收集 <code>take</code> 生成的项并从中创建一个列表。</p>
<h2 id="经典循环以及为什么我们不喜欢它们">经典循环以及为什么我们不喜欢它们</h2>
<p>经典循环，循环变量递增，可以通过 <a href="https://docs.raku.org/language/control#loop">loop 关键字</a>在 Raku 中完成。其他 <a href="https://docs.raku.org/language/control#repeat%2Fwhile%2C_repeat%2Funtil">repeat</a>和 <a href="https://docs.raku.org/language/control#while%2C_until">while</a> 循环也是可能的。</p>
<p>但是，总的来说，他们是沮丧的。 Raku 是一种功能和并发语言;在 Raku 中编码时，你应该以功能的方式看待循环：逐个处理迭代器产生的项目，即将一个项目提供给一个没有任何辅助效果的块。该功能视图还允许通过<a href="https://docs.raku.org/routine/hyper">hyper</a>或<a href="https://docs.raku.org/routine/race">race</a>自动线程方法轻松并行化操作。</p>
<p>如果您对旧的循环感觉更舒服，该语言允许您使用它们。但是，在可能的情况下尝试使用功能和并发迭代构造被认为是更多的p6y。</p>
<p><em>注意：由于版本6.d循环可以从最后一个语句的值中生成值列表。</em></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[进程间通信]]></title>
            <link href="http://localhost:1313/rakulang/21.inter-process-communication/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/20.input-and-output/?utm_source=atom_feed" rel="related" type="text/html" title="输入和输出" />
                <link href="http://localhost:1313/rakulang/19.grammar-tutorial/?utm_source=atom_feed" rel="related" type="text/html" title="Grammar 指南" />
                <link href="http://localhost:1313/rakulang/18.entering-unicode-characters/?utm_source=atom_feed" rel="related" type="text/html" title="输入 Unicode 字符" />
                <link href="http://localhost:1313/rakulang/17.doing-math-with-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="用 Raku 做数学" />
                <link href="http://localhost:1313/rakulang/16.core-modules/?utm_source=atom_feed" rel="related" type="text/html" title="核心模块" />
            
                <id>http://localhost:1313/rakulang/21.inter-process-communication/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-27T21:13:31+08:00</published>
            <updated>2018-10-27T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="运行程序">运行程序</h1>
<p>许多程序需要能够运行其他程序，我们需要将信息传递给它们并接收它们的输出和退出状态。在 Raku 中运行程序非常简单：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">run</span> <span class="p">&#39;</span><span class="s1">git</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">status</span><span class="p">&#39;;</span>
</span></span></code></pre></div><p>这一行运行名为 “git” 的程序，并将 “git” 和 “status” 传递给它的命令行。它将使用 <code>%*ENV&lt;PATH&gt;</code> 设置找到该 git 程序。</p>
<p>如果您想通过向 shell 发送命令行来运行程序，那么也有一个工具。所有 shell 元字符都由 shell 解释，包括管道，重定向，环境变量替换等。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">shell</span> <span class="p">&#39;</span><span class="s1">ls -lR | gzip -9 &gt; ls-lR.gz</span><span class="p">&#39;;</span>
</span></span></code></pre></div><p>使用 <code>shell</code> 用户输入时应小心。</p>
<h1 id="proc对象httpsdocsrakuorglanguageipc___top"><a href="https://docs.raku.org/language/ipc#___top"><code>Proc</code>对象</a></h1>
<p><code>run</code> 和 <code>shell</code> 都返回一个<a href="https://docs.raku.org/type/Proc">PROC</a>对象，它可以使用具有更详细的进程进行通信。请注意，除非您关闭所有输出管道，否则程序通常不会终止。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$git</span> <span class="o">=</span> <span class="nb">run</span> <span class="p">&#39;</span><span class="s1">git</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">log</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">--oneline</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">$git</span><span class="o">.</span><span class="nf">out</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="p">(</span><span class="nv">$sha</span><span class="o">,</span> <span class="nv">$subject</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$subject</span><span class="s2"> [</span><span class="nv">$sha</span><span class="s2">]</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">$git</span><span class="o">.</span><span class="nf">out</span><span class="o">.</span><span class="nb">close</span><span class="p">();</span>
</span></span></code></pre></div><p>如果程序失败（以非零退出码退出），它将在返回的<a href="https://docs.raku.org/type/Proc">Proc</a>对象沉没时抛出异常。您可以将其保存为变量，甚至是匿名变量，以防止下沉：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="o">=</span> <span class="nb">run</span> <span class="p">&#39;</span><span class="s1">/bin/false</span><span class="p">&#39;;</span> <span class="c1"># does not sink the Proc and so does not throw </span>
</span></span></code></pre></div><p>您可以通过传递 <code>:out</code> 和 <code>:err</code> 标志来告诉 <code>Proc</code> 对象将输出捕获为文件句柄。您也可以通过 <code>:in</code> 标记传递输入。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$echo</span> <span class="o">=</span> <span class="nb">run</span> <span class="p">&#39;</span><span class="s1">echo</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Hello, world</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$cat</span>  <span class="o">=</span> <span class="nb">run</span> <span class="p">&#39;</span><span class="s1">cat</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">-n</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">in</span><span class="p">(</span><span class="nv">$echo</span><span class="o">.</span><span class="nf">out</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$cat</span><span class="o">.</span><span class="nf">out</span><span class="o">.</span><span class="nb">get</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$cat</span><span class="o">.</span><span class="nf">out</span><span class="o">.</span><span class="nb">close</span><span class="p">();</span>
</span></span></code></pre></div><p>您还可以使用 <code>Proc</code> 捕获PID，将信号发送到应用程序，并检查 exitcode。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$crontab</span> <span class="o">=</span> <span class="nb">run</span> <span class="p">&#39;</span><span class="s1">crontab</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">-l</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$crontab</span><span class="o">.</span><span class="nb">exitcode</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">crontab -l ran ok</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">something went wrong</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="procasync对象httpsdocsrakuorglanguageipc___top"><a href="https://docs.raku.org/language/ipc#___top"><code>Proc::Async</code>对象</a></h1>
<p>当您需要更多地控制与另一个进程的通信时，您将需要使用<a href="https://docs.raku.org/type/Proc::Async">Proc::Async</a>。该类提供对与程序进行异步通信的支持，以及向该程序发送信号的能力。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Get ready to run the program </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$log</span> <span class="o">=</span> <span class="kt">Proc::Async</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">tail</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">-f</span><span class="p">&#39;</span><span class="o">,</span>  <span class="p">&#39;</span><span class="s1">/var/log/system.log</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$log</span><span class="o">.</span><span class="nb">stdout</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$buf</span> <span class="p">{</span> <span class="nb">print</span> <span class="nv">$buf</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nv">$log</span><span class="o">.</span><span class="nb">stderr</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$buf</span> <span class="p">{</span> <span class="vg">$*ERR</span><span class="o">.</span><span class="nb">print</span><span class="p">(</span><span class="nv">$buf</span><span class="p">)</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Start the program </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$done</span> <span class="o">=</span> <span class="nv">$log</span><span class="o">.</span><span class="k">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">sleep</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Tell the program to stop </span>
</span></span><span class="line"><span class="cl"><span class="nv">$log</span><span class="o">.</span><span class="nb">kill</span><span class="p">(&#39;</span><span class="s1">QUIT</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Wait for the program to finish </span>
</span></span><span class="line"><span class="cl"><span class="nb">await</span> <span class="nv">$done</span><span class="p">;</span>
</span></span></code></pre></div><p>上面的小程序使用“tail”程序每 10 秒打印出名 <code>system.log</code> 的日志内容，然后通过 QUIT 信号告诉程序停止。</p>
<p>虽然 <code>Proc</code> 使用 <code>IO::Handle</code> 提供对输出的访问，但 <code>Proc::Async</code> 使用异步 supplies 提供访问（请参阅<a href="https://docs.raku.org/type/Supply">Supply</a>）。</p>
<p>如果要在等待原始程序完成时运行程序并执行某些工作，则 <code>start</code> 例程将返回<a href="https://docs.raku.org/type/Promise">Promise</a>，该程序在程序退出时保留(kept)。</p>
<p>使用 <code>write</code> 方法将数据传递到程序中。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[输入和输出]]></title>
            <link href="http://localhost:1313/rakulang/20.input-and-output/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/19.grammar-tutorial/?utm_source=atom_feed" rel="related" type="text/html" title="Grammar 指南" />
                <link href="http://localhost:1313/rakulang/18.entering-unicode-characters/?utm_source=atom_feed" rel="related" type="text/html" title="输入 Unicode 字符" />
                <link href="http://localhost:1313/rakulang/17.doing-math-with-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="用 Raku 做数学" />
                <link href="http://localhost:1313/rakulang/16.core-modules/?utm_source=atom_feed" rel="related" type="text/html" title="核心模块" />
                <link href="http://localhost:1313/rakulang/15.concurrency/?utm_source=atom_feed" rel="related" type="text/html" title="并发" />
            
                <id>http://localhost:1313/rakulang/20.input-and-output/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-26T21:13:31+08:00</published>
            <updated>2018-10-26T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>在这里，我们简要概述了与文件相关的输入/输出操作。详细信息可以在 <a href="https://docs.raku.org/type/IO">IO</a> 角色的文档中找到，也可以在 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a>  和 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 类型中找到。</p>
<h1 id="读取文件httpsdocsrakuorglanguageio___top"><a href="https://docs.raku.org/language/io#___top">读取文件</a></h1>
<p>读取文件内容的一种方法是通过带有 <code>:r</code>（读取）文件模式选项的 <code>open</code> 函数打开文件，并吞噬内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#34;</span><span class="s2">testfile</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">:</span><span class="s">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$contents</span> <span class="o">=</span> <span class="nv">$fh</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span></code></pre></div><p>这里我们使用 <code>IO::Handle</code> 对象上的 <code>close</code> 方法显式地关闭文件句柄。这是一种非常传统的读取文件内容的方法。但是，同样的事情可像这样更容易和更清楚地完成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$contents</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">testfile</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># or in procedural form: </span>
</span></span><span class="line"><span class="cl"><span class="nv">$contents</span> <span class="o">=</span> <span class="nb">slurp</span> <span class="p">&#34;</span><span class="s2">testfile</span><span class="p">&#34;</span>
</span></span></code></pre></div><p>通过将 <code>IO</code> 角色添加到文件名字符串中，我们实际上能够将字符串作为文件对象本身引用，从而直接吞噬其内容中。请注意，<code>slurp</code> 负责为你打开和关闭文件。</p>
<h2 id="逐行读取httpsdocsrakuorglanguageio___top"><a href="https://docs.raku.org/language/io#___top">逐行读取</a></h2>
<p>当然，我们也可以选择逐行读取文件。将排除新行分隔符（即  <code>$*IN.nl-in</code>）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">&#39;</span><span class="s1">huge-csv</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Do something with $line </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># or if you&#39;ll be processing later </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@lines</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">huge-csv</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>
</span></span></code></pre></div><h1 id="写文件httpsdocsrakuorglanguageio___top"><a href="https://docs.raku.org/language/io#___top">写文件</a></h1>
<p>要将数据写入文件，我们再次选择调用 <code>open</code> 函数的传统方法 - 这次使用 <code>:w</code>（write）选项 - 并将数据打印到文件中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#34;</span><span class="s2">testfile</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">:</span><span class="s">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span><span class="p">(&#34;</span><span class="s2">data and stuff</span><span class="se">\n</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span></code></pre></div><p>或者使用等效的 <code>say</code>，因此不再需要显式的换行符了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#34;</span><span class="s2">testfile</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">:</span><span class="s">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">say</span><span class="p">(&#34;</span><span class="s2">data and stuff</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span></code></pre></div><p>我们可以通过使用 <code>spurt</code> 在写入模式下打开文件，将数据写入文件并再次为我们关闭来简化此操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">spurt</span> <span class="p">&#34;</span><span class="s2">testfile</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">data and stuff</span><span class="se">\n</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>默认情况下，所有（文本）文件都写为 UTF-8，但是如果需要，可以通过 <code>:enc</code> 选项指定显式编码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">spurt</span> <span class="p">&#34;</span><span class="s2">testfile</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">latin1 text: äöüß</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">enc</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">latin1</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>要将格式化的字符串写入文件, 请使用 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 的 <a href="https://docs.raku.org/routine/printf">printf</a> 函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#34;</span><span class="s2">testfile</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">:</span><span class="s">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">printf</span><span class="p">(&#34;</span><span class="s2">formatted data </span><span class="nv">%04d</span><span class="se">\n</span><span class="p">&#34;</span><span class="o">,</span> <span class="mi">42</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span></code></pre></div><p>要追加到文件，请在显式地打开文件句柄时指定 <code>:a</code> 选项，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#34;</span><span class="s2">testfile</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">:</span><span class="s">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span><span class="p">(&#34;</span><span class="s2">more data</span><span class="se">\n</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span></code></pre></div><p>或者使用等效的 <code>say</code>，因此不再需要显式的换行符了,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#34;</span><span class="s2">testfile</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">:</span><span class="s">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">say</span><span class="p">(&#34;</span><span class="s2">more data</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span></code></pre></div><p>或者甚至在调用 <code>spurt</code> 时加上 <code>:append</code> 选项:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">spurt</span> <span class="p">&#34;</span><span class="s2">testfile</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">more data</span><span class="se">\n</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">:</span><span class="s">append</span><span class="p">;</span>
</span></span></code></pre></div><p>要将二进制数据显式地写入文件，请使用 <code>:bin</code> 选项打开它。然后输入/输出操作将使用 <code>Buf</code> 类型而不是 <code>Str</code> 类型。</p>
<h1 id="复制和重命名文件httpsdocsrakuorglanguageio___top"><a href="https://docs.raku.org/language/io#___top">复制和重命名文件</a></h1>
<p>例程 <code>copy</code>, <code>rename</code>, 和 <code>move</code> 是可用的以避免低级别的系统命令。 在 <a href="https://docs.raku.org/routine/copy">copy</a>, <a href="https://docs.raku.org/routine/rename">rename</a>, 和 <a href="https://docs.raku.org/routine/move">move</a> 查看详情. 一些例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$filea</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fileb</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">foo.bak</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$filec</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">/disk1/foo</span><span class="p">&#39;;</span>  <span class="c1"># note &#39;diskN&#39; is assumed to be a physical storage device </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">copy</span> <span class="nv">$filea</span><span class="o">,</span> <span class="nv">$fileb</span><span class="p">;</span>              <span class="c1"># overwrites $fileb if it exists </span>
</span></span><span class="line"><span class="cl"><span class="nb">copy</span> <span class="nv">$filea</span><span class="o">,</span> <span class="nv">$fileb</span><span class="o">,</span> <span class="p">:</span><span class="s">createonly</span><span class="p">;</span> <span class="c1"># fails if $fileb exists </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">rename</span> <span class="nv">$filea</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">new-foo</span><span class="p">&#39;;</span>              <span class="c1"># overwrites &#39;new-foo&#39; if it exists </span>
</span></span><span class="line"><span class="cl"><span class="nb">rename</span> <span class="nv">$filea</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">new-foo</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">createonly</span><span class="p">;</span> <span class="c1"># fails if &#39;new-foo&#39; exists </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># use move when a system-level rename may not work </span>
</span></span><span class="line"><span class="cl"><span class="nb">move</span> <span class="nv">$fileb</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">/disk2/foo</span><span class="p">&#39;;</span>              <span class="c1"># overwrites &#39;/disk2/foo&#39; if it exists </span>
</span></span><span class="line"><span class="cl"><span class="nb">move</span> <span class="nv">$fileb</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">/disk2/foo</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">createonly</span><span class="p">;</span> <span class="c1"># fails if &#39;/disk2/foo&#39; exists </span>
</span></span></code></pre></div><h1 id="检查文件和目录httpsdocsrakuorglanguageio___top"><a href="https://docs.raku.org/language/io#___top">检查文件和目录</a></h1>
<p>在 <code>IO::Handle</code> 对象上使用 <code>e</code> 方法来测试文件或目录是否存在。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#34;</span><span class="s2">nonexistent_file</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">e</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">file exists</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">file doesn&#39;t exist</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>也可以使用冒号对语法来实现相同的功能：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">&#34;</span><span class="s2">path/to/file</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span> <span class="o">~~</span> <span class="p">:</span><span class="s">e</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">file exists</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$file</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">path/to/file</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$file</span><span class="o">.</span><span class="kt">IO</span> <span class="o">~~</span> <span class="p">:</span><span class="s">e</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">file exists</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>与文件存在检查类似，也可以检查路径是否是目录。例如，假设文件 <code>testfile</code> 和目录  <code>lib</code> 存在，我们将从存在测试方法 <code>e</code> 获得相同的结果，即两者都存在：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">testfile</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">e</span><span class="p">;</span>  <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">lib</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">e</span><span class="p">;</span>       <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>但是，由于它们中只有一个是目录，因此目录测试方法 <code>d</code> 将给出不同的结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">testfile</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">d</span><span class="p">;</span>  <span class="c1"># OUTPUT: «False␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">lib</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">d</span><span class="p">;</span>       <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>当我们通过文件测试方法 <code>f</code> 检查路径是否是文件时，结果自然会反过来：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">testfile</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">f</span><span class="p">;</span>  <span class="c1"># OUTPUT: «True␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">lib</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">f</span><span class="p">;</span>       <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><p>还有其他方法可用于查询文件或目录，一些有用的方法是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$f</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">file</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$f</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">modified</span><span class="p">;</span> <span class="c1"># return time of last file (or directory) change </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$f</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">accessed</span><span class="p">;</span> <span class="c1"># return last time file (or directory) was read </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$f</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">s</span><span class="p">;</span>        <span class="c1"># return size of file (or directory inode) in bytes </span>
</span></span></code></pre></div><p>更多方法和详细信息请查看 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a>.</p>
<h1 id="获取目录列表httpsdocsrakuorglanguageio___top"><a href="https://docs.raku.org/language/io#___top">获取目录列表</a></h1>
<p>要列出当前目录的内容，请使用 <code>dir</code> 函数。它返回 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 对象的列表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">dir</span><span class="p">;</span>          <span class="c1"># OUTPUT: «&#34;/path/to/testfile&#34;.IO &#34;/path/to/lib&#34;.IO␤» </span>
</span></span></code></pre></div><p>要列出给定目录中的文件和目录，只需将路径作为参数传递给 <code>dir</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">dir</span> <span class="p">&#34;</span><span class="s2">/etc/</span><span class="p">&#34;;</span>  <span class="c1"># OUTPUT: «&#34;/etc/ld.so.conf&#34;.IO &#34;/etc/shadow&#34;.IO ....␤» </span>
</span></span></code></pre></div><h1 id="创建和移除目录httpsdocsrakuorglanguageio___top"><a href="https://docs.raku.org/language/io#___top">创建和移除目录</a></h1>
<p>要创建一个新目录，只需使用目录名作为参数调用函数 <code>mkdir</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">mkdir</span> <span class="p">&#34;</span><span class="s2">newdir</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>该函数在成功时返回创建目录的名称，在失败时返回 <code>Nil</code>。因此，标准的 Perl 惯用法按预期工作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">mkdir</span> <span class="p">&#34;</span><span class="s2">newdir</span><span class="p">&#34;</span> <span class="ow">or</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">$!</span><span class="p">&#34;;</span>
</span></span></code></pre></div><p>使用 <code>rmdir</code> 来移除<em>空</em>目录:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">rmdir</span> <span class="p">&#34;</span><span class="s2">newdir</span><span class="p">&#34;</span> <span class="ow">or</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">$!</span><span class="p">&#34;;</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Grammar 指南]]></title>
            <link href="http://localhost:1313/rakulang/19.grammar-tutorial/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/18.entering-unicode-characters/?utm_source=atom_feed" rel="related" type="text/html" title="输入 Unicode 字符" />
                <link href="http://localhost:1313/rakulang/17.doing-math-with-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="用 Raku 做数学" />
                <link href="http://localhost:1313/rakulang/16.core-modules/?utm_source=atom_feed" rel="related" type="text/html" title="核心模块" />
                <link href="http://localhost:1313/rakulang/15.concurrency/?utm_source=atom_feed" rel="related" type="text/html" title="并发" />
                <link href="http://localhost:1313/rakulang/14.command-line-interface/?utm_source=atom_feed" rel="related" type="text/html" title="命令行接口" />
            
                <id>http://localhost:1313/rakulang/19.grammar-tutorial/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-25T21:13:31+08:00</published>
            <updated>2018-10-25T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h2 id="开始之前">开始之前</h2>
<h3 id="为什么是-grammars">为什么是 grammars?</h3>
<p>Grammars 解析字符串并从这些字符串返回数据结构。Grammars 可用于编写执行程序以确定程序是否可以运行（如果它是一个有效的程序），将网页分解成组成部分，或在其它的东西中识别句子的不同部分。</p>
<h3 id="我什么时候该使用-grammars">我什么时候该使用 grammars?</h3>
<p>如果你有驯服或解释的字符串，grammar 提供工具来完成这项工作。</p>
<p>该字符串可能是一个文件, 您想把它拆分成多个章节; 也许是一个协议，比如 SMTP，你需要指定哪些“命令”来自用户提供的数据;也许你正在设计自己的领域特定语言。Grammars 可以提供帮助。</p>
<h3 id="grammars-的广义概念">grammars 的广义概念</h3>
<p>正则表达式（<a href="https://docs.raku.org/language/regexes">Regexes</a>）适用于查找字符串中的模式。然而，对于一些任务来说，如同时查找多个模式，或者组合模式，或者单独测试可能围绕字符串正则表达式的模式是不够的。</p>
<p>在使用 HTML 时，您可以定义一个 grammar 来识别 HTML 标记，包括开始和结束元素以及它们之间的文本。然后，您可以将这些元素组织到数据结构中，例如数组或散列。</p>
<h2 id="grammar-指南">Grammar 指南</h2>
<p>你总是会遇到令人头疼的字符串解析。举个例子, 据说  HTML 不能被有效地分解和解析，只需使用正则表达式来排序元素。另一个例子是定义单词和符号可能构成语言并提供含义的顺序。这正 和 Perl 的 Gramamr 系统完美契合。</p>
<p>Grammar 非常适合接受字符串，试图理解它们，然后将它们保存到一个你实际可以使用的数据结构中。如果你有某种带顺序或解释类型的字符串，Grammar 给你一些很强大的工具，使解析字符串更容易。</p>
<p>你的字符串可能是整个文件，你需要分成几个部分。也或许是一行一行的。也许你有一个正在使用的 SMTP 那样的协议，想要一个方便有条理的方式来定义哪些“命令”需要在用户数据的后面，使协议工作。也许你想创建自己的基于字符串的协议。也许你正在设计自己的语言。</p>
<p>正则表达式（regex）很好地在字符串中查找模式并操作它们。然而，当你需要同时找到多个模式，或者需要组合模式，或者测试可能围绕字符串的模式或其他模式 - 单单用正则表达式是不够的。</p>
<p>Grammar 提供了一种方式来定义如何使用正则表达式来检查字符串，并且可以将这些正则表达式组合在一起以提供更多的意义。</p>
<p>例如，在HTML的情况下，您可以定义一个语法，它可以识别HTML标记（开始和结束元素以及它们之间的文本），并通过将这些元素填充到数据结构中来对这些元素进行操作，例如数组或散列，然后可以轻松使用。实质上，Grammar 提供了一种定义可用于解析任意大小和复杂度的字符串的完整语言或规范的手段。</p>
<h2 id="更多-grammar-技术">更多 Grammar 技术</h2>
<h3 id="概念描述">概念描述</h3>
<p>Gramamr 被定义为对象, 就像 Perl 中的其它东西。从技术上讲, Gramamr 是普通的类加上一点额外的魔法, 我们稍后就说到它 &ndash; 还有一点限制。你像类那样命名和定义一个 Grammar, 除了使用「grammar」关键字代替「class」。</p>
<pre tabindex="0"><code>grammar My::Gram { ..methods &#39;n stuff... }
</code></pre><p>Grammar 包含像方法那样的元素, 这些方法叫做 <em>regex</em>, <em>token</em> 或 <em>rule</em>。这些方法是有名字的, 就像方法有名字一样。它们每一个都定义一个 regex, token 或 rule（它们几乎是同样的东西(并不真的一样)）。</p>
<p>一旦你定义了你的 Grammar, 在你的程序中通过 Grammar 的名字调用它并传递你想解析的字符串。该字符串将通过你的 regex, token 和 rule “方法”定义的规则运行。 完成后，将返回一个 Match 对象，该对象已填充了用于定义方法的名称所结构化并存储的数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$matchObject</span> <span class="o">=</span> <span class="n">My::Gram</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$what-a-big-string-you-have</span><span class="p">);</span>
</span></span></code></pre></div><p>现在，你可能想知道，如果我让所有这些定义的正则表达式只返回他们的结果，那么这该如何帮助在字符串中向前或向后解析东西呢，或需要从多个那样的正则表达式组合的东西。 ..这就是 grammar action 发挥作用的地方。</p>
<p>对于你的 grammar 中匹配的每个“方法”，你会得到一个可调用的动作，用那个匹配你可以做一些有趣或聪明的事情。 你还可以得到一个最重要的 action，你可以使用这个 action 把它们捆绑在一起，并自定义构建一个你可能想要返回的数据结构，其中所有疯狂的字符串解析在你很好的排序和定义的数据结构是有意义的。 默认情况下，此 over-arching 方法称为 TOP。 我们也会得到更多的。</p>
<h3 id="技术概览">技术概览</h3>
<p>Grammars  就像类那样定义, 除了使用 <code>grammar</code> 关键字代替 <code>class</code>. grammars 中的「methods」叫做 <em>regex</em>, <em>token</em>, 或 <em>rule</em>。虽然 Regex 方法慢但是彻底 &ndash; 它们会在字符串中向后查看并真的尝试匹配。Token 方法更快一点并且它们忽略空白。Rule 方法和 token 方法一样, 但是它们在你的&quot;regex&quot; 定义中消费空白。</p>
<p>当方法(regex, token 或 rule)在 grammar 中匹配后, 匹配到的字符串被放入最终将返回的 Match 对象中, 并且它将使用与您选择命名的方法相同的名称。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">My::Gram</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">thingy</span><span class="p">&gt;</span><span class="sr"> </span><span class="ni">.</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">token</span> <span class="nf">thingy</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">clever_text_keyword</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>所以在这里，如果你写 <code>my $match = My::Gram.parse($string)</code> - 并且你的字符串以 &lsquo;clever_text_keyword&rsquo; 开头, 那么你会得到一个匹配对象，在你的匹配对象中包含用「thingy」 标记的 &lsquo;clever_text_keyword&rsquo; 字符串。  这些可以变得越来越复杂，根据你的需要，如你所想。</p>
<p>现在, 我们说说 TOP。 TOP 方法(regex, token or rule)是必须匹配一切的(默认)的包罗万象的 regex。 如果传递进来解析的字符串与 TOP regex 不匹配，则返回的匹配对象将为空（<code>Any</code>）。</p>
<p>正如你可以看到的，在 TOP 中，提到了 <code>&lt;thingy&gt;</code> 标记。 <code>&lt;thingy&gt;</code> 被定义在下一行，<code>token thingy ...</code>。 这意味着 &lsquo;clever_text_keyword&rsquo; <strong>必须</strong>是传入的字符串中的第一个东西，否则 grammar 解析将失败，而我们将得到一个空匹配。 这对于识别有人可能给你应该被丢弃的畸形的东西是极好的。</p>
<h2 id="通过一个例子学习-grammar---rest-设计">通过一个例子学习 Grammar - REST 设计</h2>
<p>让我们假设我们要将一个 URL 解析成组成 RESTful 请求的组件部分。假设我们希望网址的工作方式如下：</p>
<ul>
<li>URI 的第一部分，我们称之为“主体”，如零件，产品或人。</li>
<li>URI 的第二部分，我们称之为“命令”，就像标准的 CRUD 东西（创建，检索，更新或删除）。</li>
<li>URI 的第三部分将是任意数据。也许我们将使用的具体ID，或者一个由“/”分隔的长列表数据。</li>
<li>当我们得到一个URL时，我们需要把上面的1-3放在一个很好的我们可以使用的数据结构中，而不必做各种分割，并且可以很容易地在未来改变或扩展（或扩展） 。</li>
</ul>
<p>因此，如果我们在服务器上有一个 &ldquo;/product/update/7/notify&rdquo; 的 URI，我们希望我们的 Grammar 给我们一个很好的 <code>$match</code> 对象，它有一个“product”“subject”，一个”更新““command和”7/notify“的”数据“（现在）。</p>
<p>我们做的第一件事是定义 grammar 类。我们将需要定义我们的主题，命令和数据。我想我们将为他们使用 token，因为我们不关心正则表达式中的空格。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">REST</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">token</span> <span class="nf">subject</span> <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">token</span> <span class="nf">command</span> <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">token</span> <span class="nf">data</span>    <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">*</span><span class="sr">  </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>到目前为止，这个 REST Grammar 说，我们想要一个只是单词字符的主题，一个只是单词字符的命令和剩余全部是字符串的数据（在这种情况下为 URI）。</p>
<p>但是在我们的大字符串中，我们不知道这些正则表达式匹配将会进入什么顺序。我们需要能够将这些匹配的 token 放在我们将作为该字符串传递的URI的更大的上下文中。 这就是 TOP 方法要做的。 因此，我们添加 TOP，并在其中放置我们的 token 名称，以及其它应该出现的有效字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">REST</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">/</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">subject</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">/</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">command</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">/</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">data</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">token</span> <span class="nf">subject</span> <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">token</span> <span class="nf">command</span> <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">token</span> <span class="nf">data</span>    <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">*</span><span class="sr">  </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>实际上，您可以用它从基本的 CRUD 的 URI 中提取您的数据，其中包含所有3个参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$match</span> <span class="o">=</span> <span class="n">REST</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">/product/update/7/notify</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$match</span><span class="p">;</span>
</span></span></code></pre></div><p>输出:</p>
<pre tabindex="0"><code>«｢/product/update/7/notify｣␤ 
 subject =&gt; ｢product｣ 
 command =&gt; ｢update｣ 
 data =&gt; ｢7/notify｣» 
</code></pre><p>当然，可以使用 <code>$match&lt;subject&gt;</code> 或 <code>$match&lt;command&gt;</code> 或 <code>$match&lt;data&gt;</code> 直接访问数据以返回解析的值。 它们每个都包含可以进一步工作的匹配对象，或强制转换为字符串（<code>$match&lt;command&gt;.Str</code>）</p>
<h3 id="添加一点灵活性">添加一点灵活性</h3>
<p>到目前为止，REST语法将处理检索，删除和更新。 但是，create 命令没有第三部分（数据部分）。 这意味着如果我们尝试解析 creat URL，我们的 Grammar 将无法匹配。 为了避免这种情况，我们需要使最后一个数据位置匹配可选，以及它前面的&rsquo;/&rsquo;。 这很容易通过为分组的&rsquo;/&lsquo;和 TOP token 的数据组件添加一个问号来表示它们的可选性质，就像一个普通的正则表达式那样。 所以现在我们有：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">REST</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span>     <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">/</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">subject</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">/</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">command</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">/</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">data</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">]</span><span class="o">?</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">subject</span> <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">command</span> <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">data</span>    <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$m</span> <span class="o">=</span> <span class="n">REST</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">/product/create</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$m</span><span class="p">&lt;</span><span class="s">subject</span><span class="p">&gt;</span><span class="o">,</span> <span class="nv">$m</span><span class="p">&lt;</span><span class="s">command</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «｢product｣｢create｣␤» </span>
</span></span></code></pre></div><p>让我们想象，为了演示的目的，我们可能想允许用户从终端输入这些相同的 URI。 在这种情况下，他们可能在&rsquo;/&lsquo;之间放置空格，因为用户容易破坏事物。 如果我们想要适应这种可能性，我们可以用另一个 token 替换 TOP 中的 &lsquo;/&rsquo;，以允许在它的任何一边的空格。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">REST</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span>     <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">slash</span><span class="p">&gt;&lt;</span><span class="nf">subject</span><span class="p">&gt;&lt;</span><span class="nf">slash</span><span class="p">&gt;&lt;</span><span class="nf">command</span><span class="p">&gt;[&lt;</span><span class="nf">slash</span><span class="p">&gt;&lt;</span><span class="nf">data</span><span class="p">&gt;]</span><span class="o">?</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">subject</span> <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">command</span> <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">data</span>    <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">slash</span>   <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">/</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$m</span> <span class="o">=</span> <span class="n">REST</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">/ product / update /7 /notify</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «｢/ product / update /7 /notify｣␤ </span>
</span></span><span class="line"><span class="cl"><span class="c1">#          slash =&gt; ｢/ ｣ </span>
</span></span><span class="line"><span class="cl"><span class="c1">#          subject =&gt; ｢product｣ </span>
</span></span><span class="line"><span class="cl"><span class="c1">#          slash =&gt; ｢ / ｣ </span>
</span></span><span class="line"><span class="cl"><span class="c1">#          command =&gt; ｢update｣ </span>
</span></span><span class="line"><span class="cl"><span class="c1">#          slash =&gt; ｢ /｣ </span>
</span></span><span class="line"><span class="cl"><span class="c1">#          data =&gt; ｢7 /notify｣» </span>
</span></span></code></pre></div><p>现在我们在我们的匹配对象中得到一些额外的垃圾，即那些斜线，但有一些非常好的方法，使我们得到一个整洁的返回值。</p>
<h3 id="添加一些约束">添加一些约束</h3>
<p>我们希望我们的 RESTful Grammar 只允许 CRUD 操作。 还有我们想要解析的东西。 这意味着我们上面的“命令”应该有四个值之一：create, retrieve, update 或 delete.。</p>
<p>有几种方法来完成这个。 例如，您可以更改 command 方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">command</span> <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ...becomes...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">command</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">create</span><span class="p">&#39;</span><span class="o">|</span><span class="p">&#39;</span><span class="s1">retrieve</span><span class="p">&#39;</span><span class="o">|</span><span class="p">&#39;</span><span class="s1">update</span><span class="p">&#39;</span><span class="o">|</span><span class="p">&#39;</span><span class="s1">delete</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>要成功解析 URI，<code>/</code> 之间的字符串的第二部分必须是那些 CRUD 值之一，否则解析失败。这正是我们想要的。</p>
<p>还有另一种技术可以在选项膨胀时提供更大的灵活性并提高可读性：原型正则表达式(proto-regexes)。</p>
<p>为了利用这些原型正则表达式（实际上是 multi methods）将我们限制为有效的 CRUD 选项，我们将用以下代替 <code>token command</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="k">token</span> <span class="nf">command</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">create</span><span class="p">&gt;</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">retrieve</span><span class="p">&gt;</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">update</span><span class="p">&gt;</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">delete</span><span class="p">&gt;</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p><code>sym</code> 关键字用于创建各种原型正则表达式(proto-regex)选项。每个选项都被命名(例如, <code>sym&lt;update&gt;</code>), 并且为了使用该选项，会使用相同的名字自动生成一个特殊的 <code>&lt;sym&gt;</code> token。</p>
<p>可以在原型正则表达式选项块中使用 <code>&lt;sym&gt;</code> token 以及其他用户定义的 tokens 来定义特定的“匹配条件”。正则表达式 tokens 是编译过的形式，一旦定义，随后就不能被副词动作(例如: i)修改。因此，由于它是自动生成的，所以特殊的 <code>&lt;sym&gt;</code> token 仅在需要与选项名称完全匹配时才有用。</p>
<p>如果对于其中一个原型正则表达式选项，出现匹配条件，则整个原型的搜索终止。匹配数据以匹配对象的形式分配给父原型 token。如果使用特殊 <code>&lt;sym&gt;</code> token，并形成全部或部分实际匹配，则将其保留为匹配对象中的子级别，否则它将不存在。</p>
<p>使用这样的原型正则表达式给了我们很大的灵活性。例如，不是返回 <code>&lt;sym&gt;</code>，在这种情况下是匹配的整个字符串，我们可以输入自己的字符串，或做其他有趣的事情。我们可以用“token subject”方法做同样的事，并将其限制为仅对有效主题（如&rsquo;part&rsquo;或&rsquo;people&rsquo;等）进行正确解析。</p>
<h3 id="把我们的-restful-grammar-组合在一块">把我们的 RESTful Grammar 组合在一块</h3>
<p>目前为止我们的 RESTful URIs 的处理如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">REST</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">slash</span><span class="p">&gt;&lt;</span><span class="nf">subject</span><span class="p">&gt;&lt;</span><span class="nf">slash</span><span class="p">&gt;&lt;</span><span class="nf">command</span><span class="p">&gt;[&lt;</span><span class="nf">slash</span><span class="p">&gt;&lt;</span><span class="nf">data</span><span class="p">&gt;]</span><span class="o">?</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">proto</span> <span class="k">token</span> <span class="nf">command</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">create</span><span class="p">&gt;</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">retrieve</span><span class="p">&gt;</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">update</span><span class="p">&gt;</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">delete</span><span class="p">&gt;</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">subject</span> <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">data</span>    <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">slash</span>   <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">/</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>让我们看看各种 URI，以及它们在通过我们的 Grammar 时是如何表现的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@uris</span> <span class="o">=</span> <span class="o">[</span><span class="p">&#39;</span><span class="s1">/product/update/7/notify</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="p">&#39;</span><span class="s1">/product/create</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="p">&#39;</span><span class="s1">/item/delete/4</span><span class="p">&#39;</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@uris</span> <span class="k">-&gt;</span> <span class="nv">$uri</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$m</span> <span class="o">=</span> <span class="n">REST</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$uri</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Sub: </span><span class="nv">$m</span><span class="s2">&lt;subject&gt; Cmd: </span><span class="nv">$m</span><span class="s2">&lt;command&gt; Dat: </span><span class="nv">$m</span><span class="s2">&lt;data&gt;</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Sub: product Cmd: update Dat: 7/notify␤ </span>
</span></span><span class="line"><span class="cl"><span class="c1">#          Sub: product Cmd: create Dat: </span>
</span></span><span class="line"><span class="cl"><span class="c1">#          Sub: item Cmd: delete Dat: 4» </span>
</span></span></code></pre></div><p>请注意，由于 <code>&lt;data&gt;</code> 与第二个字符串没有匹配，因此 <code>$m&lt;data&gt;</code> 将为 <code>Nil</code>，然后在 <code>say</code> 函数的字符串上下文中使用它会发出警告。</p>
<p>只用 grammar 的这一部分，我们就能获得几乎所有我们正在寻找的东西。 URI 被解析，我们得到一个数据结构。</p>
<p><em>data</em> token 将 URI 的整个末尾作为一个字符串返回。 4 很好。但是从 &lsquo;7/notify&rsquo; 中我们只需要那个 7。为了得到 7，我们将使用 grammar 类的另一个特性: actions。</p>
<h2 id="grammar-actions">Grammar Actions</h2>
<p>在 Grammar 类中使用 Grammar actions 来处理匹配。Actions 在它们自己的类中定义，与 grammar 类不同。</p>
<p>您可以将 grammar action 看作 grammar 插件扩展模块的一种。很多时候你都会很开心的使用 grammars。但是当你需要进一步处理其中的一些字符串时，你可以插入 Actions 扩展模块。</p>
<p>要使用 action，可以使用名为 <code>actions</code> 的命名参数，它应该包含 action 类的一个实例。通过上面的代码，如果我们的 action 类调用了 REST-actions，我们会像这样解析 URI 字符串：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$matchObject</span> <span class="o">=</span> <span class="n">REST</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$uri</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">REST-actions</span><span class="o">.</span><span class="nb">new</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1">#   …or if you prefer… </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$matchObject</span> <span class="o">=</span> <span class="n">REST</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$uri</span><span class="o">,</span> <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="n">REST-actions</span><span class="o">.</span><span class="nb">new</span><span class="p">));</span>
</span></span></code></pre></div><p>如果你将你的 action 方法命名为与你的 grammar 方法（tokens，regexes，rules）相同的名称，那么当您的 grammar 方法匹配时，具有相同名称的 action 方法将自动调用。该方法还将传递相应的匹配对象（由 <code>$/</code> 变量表示）。</p>
<p>我们来看一个例子。</p>
<p>我们回到我们离开的地方:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">REST</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">slash</span><span class="p">&gt;&lt;</span><span class="nf">subject</span><span class="p">&gt;&lt;</span><span class="nf">slash</span><span class="p">&gt;&lt;</span><span class="nf">command</span><span class="p">&gt;[&lt;</span><span class="nf">slash</span><span class="p">&gt;&lt;</span><span class="nf">data</span><span class="p">&gt;]</span><span class="o">?</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">proto</span> <span class="k">token</span> <span class="nf">command</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">create</span><span class="p">&gt;</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">retrieve</span><span class="p">&gt;</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">update</span><span class="p">&gt;</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">delete</span><span class="p">&gt;</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">subject</span> <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">data</span>    <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">slash</span>   <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">/</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>回想一下，我们想要进一步处理 data token &ldquo;7/notify&rdquo;, 以获得 7. 为此，我们将创建一个与具名 token 名称相同的方法的 action 类。在这种情况下，我们的 token 被命名为 <code>data</code>，因此我们的方法也被命名为 <code>data</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">REST-actions</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">data</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">/</span><span class="p">&#39;)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>现在，当我们通过 Grammar 传递 URI 字符串时，<em>data</em> token 匹配将传递给 REST-actions 的 <em>data</em> 方法。action 方法会按照 <code>/</code> 字符拆分字符串，返回列表的第一个元素将是 ID 号 (即 &ldquo;7/notify&rdquo; 中的 7)。</p>
<p>但你高兴的太早了。</p>
<h3 id="用-make-和-made-使-grammars-保持整洁">用 &ldquo;make&rdquo; 和 &ldquo;made&rdquo; 使 grammars 保持整洁</h3>
<p>如果 grammar 在 data 上调用上面的 action，那么 <em>data</em> 方法将被调用，但是返回到程序的大的 <code>TOP</code> grammar 匹配结果中不会显示任何内容。 为了使 action 的结果显示出来，我们需要在这个结果上调用 <a href="https://docs.raku.org/routine/make">make</a>，这个结果可以是很多东西，包括字符串，数组或散列结构。</p>
<p>你可以想象，<code>make</code> 把该结果存到 grammar 中一个特殊的容器化区域中。 我们所制作(<code>make</code>)的所有东西，稍后都可以通过 <a href="https://docs.raku.org/routine/made">made</a> 来访问。</p>
<p>因此，代替我们的上面的 REST-actions 类，我们应该写:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">REST-actions</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">data</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">/</span><span class="p">&#39;)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>当我们为 match split（它返回一个列表）中添加 <code>make</code> 时，这个 action 将返回一个<strong>数据结构</strong>给我们的 grammar，它将与原 grammar 的 <code>data</code> token 分开存储。 这样，如果我们需要，我们可以操作两者。</p>
<p>如果我们想从这个长的 URI 中访问 7 这个 ID, 那么我们访问从我们所制成的(<code>made</code>)的 <code>data</code> action 返回的列表的第一个元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$uri</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">/product/update/7/notify</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$match</span> <span class="o">=</span> <span class="n">REST</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$uri</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">REST-actions</span><span class="o">.</span><span class="nb">new</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$match</span><span class="p">&lt;</span><span class="s">data</span><span class="p">&gt;</span><span class="o">.</span><span class="k">made</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># OUTPUT: «7␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$match</span><span class="p">&lt;</span><span class="s">command</span><span class="p">&gt;</span><span class="o">.</span><span class="kt">Str</span><span class="p">;</span>   <span class="c1"># OUTPUT: «update␤» </span>
</span></span></code></pre></div><p>在这里，我们在 <em>data</em> 上调用 <code>made</code>，因为我们想要我们所制成的(<code>made</code>)（使用 <code>make</code>）action 的结果以得到分割后的数组。这好极了！但是，如果我们能够构造(<code>make</code>)一个包含我们想要的所有东西的更友好的数据结构，而不是强转类型和牢记数组，是不是更好？</p>
<p>就像 Grammar 中匹配整个字符串的 <code>TOP</code>, actions 也有一个 TOP 方法。我们可以构造(<code>make</code>)所有单独的匹配组件，如 <code>data</code> 或 <code>subject</code> 或 <code>command</code>，然后我们可以将它们放置在我们将在 TOP 中构造(<code>make</code>)的数据结构中。当我们返回最终的匹配对象时，之后就可以访问该数据结构了。</p>
<p>要做到这一点，我们要做的是将方法 <code>TOP</code> 添加到 action 类中，在该方法中，从组件片段中构造(<code>make</code>)出我们喜欢的任何数据结构。</p>
<p>所以，我们的 action 类现在变成:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">REST-actions</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">TOP</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">make</span> <span class="p">{</span> <span class="s">subject</span> <span class="o">=&gt;</span> <span class="nv">$&lt;subject&gt;</span><span class="o">.</span><span class="kt">Str</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">               <span class="s">command</span> <span class="o">=&gt;</span> <span class="nv">$&lt;command&gt;</span><span class="o">.</span><span class="kt">Str</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">               <span class="s">data</span>    <span class="o">=&gt;</span> <span class="nv">$&lt;data&gt;</span><span class="o">.</span><span class="k">made</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">data</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">/</span><span class="p">&#39;)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在我们的 <code>TOP</code> 方法中，<code>subject</code> 与我们在 grammar 中匹配的 <em>subject</em> 保持相同。 此外， <code>command</code> 返回匹配到的(create, update, retrieve, 或 delete)的有效 <code>&lt;sym&gt;</code>。 我们把每个匹配都强转为 <code>.Str</code>，因为我们不需要整个匹配对象。</p>
<p>但是我们想要确定的是，在 <code>$&lt;data&gt;</code> 对象上使用 <code>made</code> 方法，因为我们想要访问那个我们在 action 中使用 <code>make</code> 制成的(<code>made</code>)的分割，而不是正确的 <code>$&lt;data&gt;</code> 对象。</p>
<p>我们在 grammar action 的 <code>TOP</code> 方法中构造(<code>make</code>)一些东西之后，我们可以通过在 grammar 结果对象上通过调用 <code>made</code> 方法来访问所有的自定义值。 代码现在变成:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$uri</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">/product/update/7/notify</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$match</span> <span class="o">=</span> <span class="n">REST</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$uri</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">REST-actions</span><span class="o">.</span><span class="nb">new</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rest</span> <span class="o">=</span> <span class="nv">$match</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$rest</span><span class="p">&lt;</span><span class="s">data</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>   <span class="c1"># OUTPUT: «7␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$rest</span><span class="p">&lt;</span><span class="s">command</span><span class="p">&gt;;</span>   <span class="c1"># OUTPUT: «update␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$rest</span><span class="p">&lt;</span><span class="s">subject</span><span class="p">&gt;;</span>   <span class="c1"># OUTPUT: «product␤» </span>
</span></span></code></pre></div><p>如果你不需要完整的返回匹配对象，你可以从你的 actions 的 TOP 方法中只返回 made 后的数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$uri</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">/product/update/7/notify</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rest</span> <span class="o">=</span> <span class="n">REST</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$uri</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">REST-actions</span><span class="o">.</span><span class="nb">new</span><span class="p">)</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$rest</span><span class="p">&lt;</span><span class="s">data</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>   <span class="c1"># OUTPUT: «7␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$rest</span><span class="p">&lt;</span><span class="s">command</span><span class="p">&gt;;</span>   <span class="c1"># OUTPUT: «update␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$rest</span><span class="p">&lt;</span><span class="s">subject</span><span class="p">&gt;;</span>   <span class="c1"># OUTPUT: «product␤»</span>
</span></span></code></pre></div><p>哦，我们忘了摆脱那个丑陋的数组元素编号了吗？ 嗯。 让我们在 <code>TOP</code> grammar 的自定义返回中构造(<code>make</code>) 一个新东西 - 我们称之为 <code>subject-id</code>，并将它设置为 <code>&lt;data&gt;</code> 的第0个元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">REST-actions</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">TOP</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">make</span> <span class="p">{</span> <span class="s">subject</span>    <span class="o">=&gt;</span> <span class="nv">$&lt;subject&gt;</span><span class="o">.</span><span class="kt">Str</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">               <span class="s">command</span>    <span class="o">=&gt;</span> <span class="nv">$&lt;command&gt;</span><span class="o">.</span><span class="kt">Str</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">               <span class="s">data</span>       <span class="o">=&gt;</span> <span class="nv">$&lt;data&gt;</span><span class="o">.</span><span class="k">made</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">               <span class="s">subject-id</span> <span class="o">=&gt;</span> <span class="nv">$&lt;data&gt;</span><span class="o">.</span><span class="k">made</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">data</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">/</span><span class="p">&#39;)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>现在我们可以这样做:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$uri</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">/product/update/7/notify</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rest</span> <span class="o">=</span> <span class="n">REST</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$uri</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">REST-actions</span><span class="o">.</span><span class="nb">new</span><span class="p">)</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$rest</span><span class="p">&lt;</span><span class="s">command</span><span class="p">&gt;;</span>    <span class="c1"># OUTPUT: «update␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$rest</span><span class="p">&lt;</span><span class="s">subject</span><span class="p">&gt;;</span>    <span class="c1"># OUTPUT: «product␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$rest</span><span class="p">&lt;</span><span class="s">subject-id</span><span class="p">&gt;;</span> <span class="c1"># OUTPUT: «7␤» </span>
</span></span></code></pre></div><p>下面是完整的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">REST</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">slash</span><span class="p">&gt;&lt;</span><span class="nf">subject</span><span class="p">&gt;&lt;</span><span class="nf">slash</span><span class="p">&gt;&lt;</span><span class="nf">command</span><span class="p">&gt;[&lt;</span><span class="nf">slash</span><span class="p">&gt;&lt;</span><span class="nf">data</span><span class="p">&gt;]</span><span class="o">?</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">proto</span> <span class="k">token</span> <span class="nf">command</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">create</span><span class="p">&gt;</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">retrieve</span><span class="p">&gt;</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">update</span><span class="p">&gt;</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">command</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">delete</span><span class="p">&gt;</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">subject</span> <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">data</span>    <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">slash</span>   <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">/</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">REST-actions</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">TOP</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">make</span> <span class="p">{</span> <span class="s">subject</span>    <span class="o">=&gt;</span> <span class="nv">$&lt;subject&gt;</span><span class="o">.</span><span class="kt">Str</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">               <span class="s">command</span>    <span class="o">=&gt;</span> <span class="nv">$&lt;command&gt;</span><span class="o">.</span><span class="kt">Str</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">               <span class="s">data</span>       <span class="o">=&gt;</span> <span class="nv">$&lt;data&gt;</span><span class="o">.</span><span class="k">made</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">               <span class="s">subject-id</span> <span class="o">=&gt;</span> <span class="nv">$&lt;data&gt;</span><span class="o">.</span><span class="k">made</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">data</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">/</span><span class="p">&#39;)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="直接添加-actions">直接添加 actions</h3>
<p>上面我们看到如何将 grammars 与 actions 对象相关联，并在匹配对象上执行 actions。但是，当我们想要处理匹配对象时，这不是唯一的方法。看下面的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">G</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">function-define</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">rule</span> <span class="nf">function-define</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&#39;</span><span class="s1">sub</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">func </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$&lt;identifier&gt;</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">make</span> <span class="nv">$&lt;identifier&gt;</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">parameter</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">{</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">}</span><span class="p">&#39;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">end </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$/</span><span class="o">.</span><span class="k">made</span><span class="p">;</span> <span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">  </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">token</span> <span class="nf">identifier</span> <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span> <span class="o">~</span><span class="nv">$/</span><span class="p">;</span> <span class="p">}</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">token</span> <span class="nf">parameter</span> <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">param </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">;</span> <span class="p">}</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">G</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">sub f ( a ) { }</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «func f␤param a␤end f␤» </span>
</span></span></code></pre></div><p>这个例子是解析器的缩版。让我们更专注于它显示的功能。</p>
<p>首先，我们可以在 grammar 本身中添加 action，一旦正则表达式的控制流到达它们，就会执行这些 action。请注意，action 对象的方法将始终在整个正则表达式项匹配后执行。其次，它展示了 <code>make</code> 真正做了什么，它不过是 <code>$/.made = ...</code> 的语法糖。这个技巧引入了一种从正则表达式 item 中传递消息的方法。</p>
<p>希望这有助于向您介绍 Raku 中的 Grammar，并向您展示 grammar
和 grammar action 类是如何协同工作的。有关更多信息，请查看更高级的 <a href="https://docs.raku.org/language/grammars">Perl Grammar指南</a>。</p>
<p>对于更多的 Grammar 调试，请参见 <a href="https://github.com/jnthn/grammar-debugger">Grammar::Debugger</a>。它为每个 grammar tokens 提供了断点调试和颜色高亮的匹配(MATCH)和匹配失败(FAIL)的输出。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[输入 Unicode 字符]]></title>
            <link href="http://localhost:1313/rakulang/18.entering-unicode-characters/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/17.doing-math-with-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="用 Raku 做数学" />
                <link href="http://localhost:1313/rakulang/16.core-modules/?utm_source=atom_feed" rel="related" type="text/html" title="核心模块" />
                <link href="http://localhost:1313/rakulang/15.concurrency/?utm_source=atom_feed" rel="related" type="text/html" title="并发" />
                <link href="http://localhost:1313/rakulang/14.command-line-interface/?utm_source=atom_feed" rel="related" type="text/html" title="命令行接口" />
                <link href="http://localhost:1313/rakulang/13.classes-and-objects/?utm_source=atom_feed" rel="related" type="text/html" title="类和对象" />
            
                <id>http://localhost:1313/rakulang/18.entering-unicode-characters/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-24T21:13:31+08:00</published>
            <updated>2018-10-24T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="输入-unicode-字符">输入 Unicode 字符</h1>
<p>Raku 允许把 unicode 字符用作变量名. 很多操作符使用 unicode 符号(特别是在 set/bag 操作符中)还有一些引号结构. 因此, 知道如何把这些符号输入编辑器, Raku shell 和 命令行中是极好的, 特别是现实键盘中不存在那个符号的时候.</p>
<p>在各种操作系统和环境下关于输入 unicode 字符的通用信息可以在 Wikipedia <a href="https://en.wikipedia.org/wiki/Unicode_input">unicode 输入页</a> 中找到.</p>
<h2 id="编辑器和-shell">编辑器和 shell</h2>
<h3 id="vim">Vim</h3>
<p>在 Vim 中, unicode 字符是通过先按 <code>Ctrl-V</code>(也表示为 <code>^V</code>), 然后按下 <code>u</code> 和 要输入的 unicode 字符的十六进制值来输入的(在插入模式).  例如, 希腊字母  <code>λ</code> (lambda) 是通过组合键来输入的:</p>
<pre tabindex="0"><code>^Vu03BB
</code></pre><p>更多关于在 Vim 中输入特殊字符的信息可以在 Vim Wikia 页 <a href="http://vim.wikia.com/wiki/Entering_special_characters">键入特殊字符</a> 中找到.</p>
<h3 id="emacs">Emacs</h3>
<p>在 Emacs 中, unicode 字符的输入是首先输入和弦 <code>Ctrl-x 8 Enter</code> , 然后再输入 unicode 代码点的十六进制数字, 然后回车. 因此, 要输入希腊字母 <code>λ (lambda)</code> 使用下面的组合键(命令之间添加了空格以使清晰):</p>
<pre tabindex="0"><code>Ctrl-x 8 Enter 3bb Enter
</code></pre><p>更多关于在 Emacs 中输入 unicode 字符的信息可以在 <a href="http://www.emacswiki.org/emacs/UnicodeEncoding"> Unicode 编码 Emacs wiki 页面</a>  中找到.</p>
<h3 id="unix-shell">Unix shell</h3>
<p>在 bash shell 中, 要输入 unicode 字符先键入 <code>Ctrl-Shift-u</code>, 然后键入 unicode 代码点的值后回车. 例如, 要键入属于操作符(<code>∈</code>)这个 unicode 字符, 使用下面的组合键(添加的空白是为了清晰):</p>
<pre tabindex="0"><code>Ctrl-Shift-u 2208 Enter
</code></pre><p>如果在 Unix shell 中开启了 REPL, 这也是一种在 perl 6 的 REPL 中输入 unicode 字符的方式之一.</p>
<h2 id="raku中有用的-unicode-字符">Raku中有用的 Unicode 字符</h2>
<h3 id="引号">引号</h3>
<p>这些字符在法语和德语中是当作引号使用的. 在 Raku 中, 它们仍然用作引号(在 POD 中是单引号, 在普通代码中是双引号), 还可以标示超运算符. 下面是这些符号和它们的 unicode 十六进制值:</p>
<pre tabindex="0"><code>符号 unicode代码点 ascii equivalent
«	U+00AB	      &lt;&lt;
»	U+00BB	      &gt;&gt;
</code></pre><p>因此, 下面这些结构是可用的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">C</span><span class="p">«</span><span class="s2"> fixed-width POD text </span><span class="p">»</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">»+«</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">);</span>     <span class="c1"># 4 6 ; element-wise add</span>
</span></span><span class="line"><span class="cl"><span class="nv">@array</span> <span class="o">»+=»</span> <span class="mi">42</span><span class="p">;</span>            <span class="c1"># add 42 to each element of @array</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">«</span><span class="s2">moo</span><span class="p">»;</span>                 <span class="c1"># moo</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$baa</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span> <span class="nb">say</span> <span class="p">«</span><span class="nv">$baa</span><span class="p">»;</span> <span class="c1"># 123</span>
</span></span></code></pre></div><h3 id="setbag-操作符">Set/bag 操作符</h3>
<p>下面列出的 <a href="http://doc.raku.org/language/setbagmix#Set%2FBag_Operators">set/bag 操作符</a> 都有与集合理论相关的符号, unicode 代码点, 和它们的 ascii 等价物. 要构成这样的一个字符, 只需键入字符组合键(例如 Vim中的 <code>Ctrl-V u</code>, Bash 中的 <code>Ctrl-Shift-u</code>), 然后输入 unicode 代码点的十六进制数.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">操作符</span>	<span class="n">unicode代码点</span>	<span class="n">ascii</span> <span class="n">equivalent</span>
</span></span><span class="line"><span class="cl"><span class="o">∈</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">2208</span>	    <span class="ow">(elem)</span>
</span></span><span class="line"><span class="cl"><span class="o">∉</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">2209</span>	    <span class="o">!</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">∋</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">220</span><span class="n">B</span>	    <span class="ow">(cont)</span>
</span></span><span class="line"><span class="cl"><span class="o">∌</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">220</span><span class="n">C</span>	    <span class="o">!</span><span class="p">(</span><span class="n">cont</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">⊆</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">2286</span>	    <span class="ow">(&lt;=)</span>
</span></span><span class="line"><span class="cl"><span class="o">⊈</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">2288</span>	    <span class="o">!</span><span class="p">(</span><span class="o">&lt;=</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">⊂</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">2282</span>	    <span class="ow">(&lt;)</span>
</span></span><span class="line"><span class="cl"><span class="o">⊄</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">2284</span>	    <span class="o">!</span><span class="p">(</span><span class="o">&lt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">⊇</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">2287</span>	    <span class="ow">(&gt;=)</span>
</span></span><span class="line"><span class="cl"><span class="o">⊉</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">2289</span>	    <span class="o">!</span><span class="p">(</span><span class="o">&gt;=</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">⊃</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">2283</span>	    <span class="ow">(&gt;)</span>
</span></span><span class="line"><span class="cl"><span class="o">⊅</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">2285</span>	    <span class="o">!</span><span class="p">(</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">≼	  <span class="n">U</span><span class="o">+</span><span class="mi">227</span><span class="n">C</span>	    <span class="p">(</span><span class="o">&lt;+</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">≽	  <span class="n">U</span><span class="o">+</span><span class="mi">227</span><span class="n">D</span>	    <span class="p">(</span><span class="o">&gt;+</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">∪</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">222</span><span class="n">A</span>	    <span class="ow">(|)</span>
</span></span><span class="line"><span class="cl"><span class="o">∩</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">2229</span>	    <span class="ow">(&amp;)</span>
</span></span><span class="line"><span class="cl"><span class="o">∖</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">2216</span>	    <span class="ow">(-)</span>
</span></span><span class="line"><span class="cl"><span class="o">⊖</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">2296</span>	    <span class="ow">(^)</span>
</span></span><span class="line"><span class="cl"><span class="o">⊍</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">228</span><span class="n">D</span>	    <span class="ow">(.)</span>
</span></span><span class="line"><span class="cl"><span class="o">⊎</span>	  <span class="n">U</span><span class="o">+</span><span class="mi">228</span><span class="n">E</span>	    <span class="ow">(+)</span>
</span></span></code></pre></div><h3 id="数学符号">数学符号</h3>
<p>Wikipedia 包含了一个 <a href="https://en.wikipedia.org/wiki/Mathematical_operators_and_symbols_in_Unicode">unicode 中数学操作符和符号</a> 的完整列表, 还有它们数学意义的链接.</p>
<h3 id="希腊字符">希腊字符</h3>
<p>希腊字符可以用作变量名了. 查看 <a href="https://en.wikipedia.org/wiki/Greek_alphabet#Greek_in_Unicode">Greek in Unicode Wikipedia article</a> 列表获取希腊和埃及字符还有它们的 unicode 代码点.</p>
<p>例如, 把数值3赋值给 <code>π</code>, 在 Vim 中输入(添加的空格是为了清晰):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$Ctrl-V</span> <span class="n">u</span> <span class="mo">03</span><span class="n">C0</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1"># same as: my $π = 3;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$Ctrl-V</span> <span class="n">u</span> <span class="mo">03</span><span class="n">C0</span><span class="p">;</span>     <span class="c1"># 3    same as: say $π;</span>
</span></span></code></pre></div><h3 id="上标和下标">上标和下标</h3>
<p>使用 <code>U+207x</code>, <code>U+208x</code> 和 (less often)  <code>U+209x</code> 范围能直接创建一个有限的<a href="http://en.wikipedia.org/wiki/Superscripts_and_Subscripts">上标和下标</a>的集合. 然而, 要生成一个值的平方或立方, 你需要使用 <code>U+00B2</code> 和 <code>U+00B3</code> , 因为这些被定义在 <a href="http://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)"> Latin1 supplement Unicode block</a> 中.</p>
<p>因此, 要书写泰勒级数展开, 你可以在 Vim 中输入:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">exp</span><span class="p">(</span><span class="nb">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">x</span> <span class="o">+</span> <span class="n">xCtrl-V</span> <span class="n">u</span> <span class="mo">00</span><span class="n">B2</span><span class="o">/</span><span class="mi">2</span><span class="o">!</span> <span class="o">+</span> <span class="n">xCtrl-V</span> <span class="n">u</span> <span class="mo">00</span><span class="n">B3</span><span class="o">/</span><span class="mi">3</span><span class="o">!</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="n">xCtrl-V</span> <span class="n">u</span> <span class="mi">207</span><span class="n">F</span><span class="o">/</span><span class="n">n</span><span class="o">!</span>
</span></span><span class="line"><span class="cl"><span class="c1"># which would appear as</span>
</span></span><span class="line"><span class="cl"><span class="nb">exp</span><span class="p">(</span><span class="nb">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">x</span> <span class="o">+</span> <span class="nb">x</span>²<span class="o">/</span><span class="mi">2</span><span class="o">!</span> <span class="o">+</span> <span class="nb">x</span>³<span class="o">/</span><span class="mi">3</span><span class="o">!</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="n">xⁿ</span><span class="o">/</span><span class="n">n</span><span class="o">!</span>
</span></span></code></pre></div><p>或者指定列表中从1到k 的元素:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"> <span class="n">ACtrl-V</span> <span class="n">u</span> <span class="mi">2081</span><span class="o">,</span> <span class="n">ACtrl-V</span> <span class="n">u</span> <span class="mi">2082</span><span class="o">,</span> <span class="o">...,</span> <span class="n">ACtrl-V</span> <span class="n">u</span> <span class="mi">2096</span>
</span></span><span class="line"><span class="cl"> <span class="c1"># which would appear as</span>
</span></span><span class="line"><span class="cl"> <span class="n">A</span>₁<span class="o">,</span> <span class="n">A</span>₂<span class="o">,</span> <span class="o">...,</span> <span class="n">Aₖ</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[用 Raku 做数学]]></title>
            <link href="http://localhost:1313/rakulang/17.doing-math-with-perl-6/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/16.core-modules/?utm_source=atom_feed" rel="related" type="text/html" title="核心模块" />
                <link href="http://localhost:1313/rakulang/15.concurrency/?utm_source=atom_feed" rel="related" type="text/html" title="并发" />
                <link href="http://localhost:1313/rakulang/14.command-line-interface/?utm_source=atom_feed" rel="related" type="text/html" title="命令行接口" />
                <link href="http://localhost:1313/rakulang/13.classes-and-objects/?utm_source=atom_feed" rel="related" type="text/html" title="类和对象" />
                <link href="http://localhost:1313/rakulang/12.ruby-to-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Ruby 到 Raku" />
            
                <id>http://localhost:1313/rakulang/17.doing-math-with-perl-6/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-23T21:13:31+08:00</published>
            <updated>2018-10-23T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h2 id="sets">Sets</h2>
<p>Raku 包括 <a href="https://docs.raku.org/type/Set">Set</a> 数据类型，以及对<a href="https://docs.raku.org/language/setbagmix#Set%2FBag_Operators">大多数 set 操作</a>的支持。<a href="https://en.wikipedia.org/wiki/Algebra_of_sets">并集和交集</a>不仅是原生操作，它们使用自然符号 <code>∩</code> 和 <code>∪</code>。例如，此代码将检查有限数量集的集算术的基本定律：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@arbitrary-numbers</span> <span class="o">=</span> <span class="o">^</span><span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\U</span> <span class="o">=</span> <span class="nv">@arbitrary-numbers</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@sets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nv">@sets</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="kt">Set</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="nv">@arbitrary-numbers</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span> <span class="nv">@arbitrary-numbers</span><span class="o">.</span><span class="nb">elems</span><span class="o">.</span><span class="nb">rand</span><span class="p">))</span> <span class="k">for</span> <span class="nv">@arbitrary-numbers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">@union</span><span class="o">,</span> <span class="nv">@intersection</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@sets</span> <span class="k">-&gt;</span> <span class="nv">$set</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">@union</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="nv">$set</span> <span class="o">∩</span> <span class="nv">$set</span> <span class="o">===</span> <span class="nv">$set</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">@intersection</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="nv">$set</span> <span class="o">∪</span> <span class="nv">$set</span> <span class="o">===</span> <span class="nv">$set</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Idempotent union is </span><span class="p">&#34;</span><span class="o">,</span> <span class="nb">so</span> <span class="nv">@union</span><span class="o">.</span><span class="nb">all</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Idempotent union is True» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Idempotent intersection is </span><span class="p">&#34;</span><span class="o">,</span> <span class="nb">so</span> <span class="nv">@intersection</span><span class="o">.</span><span class="nb">all</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Idempotent intersection is True» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">@universe</span><span class="o">,</span> <span class="nv">@empty-set</span><span class="o">,</span> <span class="nv">@id-universe</span><span class="o">,</span> <span class="nv">@id-empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@sets</span> <span class="k">-&gt;</span> \<span class="n">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">@universe</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="n">A</span> <span class="o">∪</span> <span class="n">U</span> <span class="o">===</span> <span class="n">U</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">@id-universe</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="n">A</span> <span class="o">∩</span> <span class="n">U</span> <span class="o">===</span> <span class="n">A</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">@empty-set</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="n">A</span> <span class="o">∩</span> <span class="no">∅</span> <span class="o">===</span> <span class="no">∅</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">@id-empty</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="n">A</span> <span class="o">∪</span> <span class="no">∅</span> <span class="o">===</span> <span class="n">A</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Universe dominates </span><span class="p">&#34;</span><span class="o">,</span> <span class="nb">so</span> <span class="nv">@universe</span><span class="o">.</span><span class="nb">all</span><span class="p">;</span>    <span class="c1"># OUTPUT: «Universe dominates True» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Empty set dominates </span><span class="p">&#34;</span><span class="o">,</span> <span class="nb">so</span> <span class="nv">@empty-set</span><span class="o">.</span><span class="nb">all</span><span class="p">;</span>  <span class="c1"># OUTPUT: «Empty set dominates True» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Identity with U </span><span class="p">&#34;</span><span class="o">,</span> <span class="nb">so</span> <span class="nv">@id-universe</span><span class="o">.</span><span class="nb">all</span><span class="p">;</span>    <span class="c1"># OUTPUT: «Identity with U True» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Identity with ∅ </span><span class="p">&#34;</span><span class="o">,</span> <span class="nb">so</span> <span class="nv">@id-empty</span><span class="o">.</span><span class="nb">all</span><span class="p">;</span>       <span class="c1"># OUTPUT: «Identity with ∅ True» </span>
</span></span></code></pre></div><p>在这个使用 Raku 已经定义的<a href="https://docs.raku.org/language/setbagmix#term_%25E2%2588%2585">空集</a>的代码中，我们不仅检查集合代数中的等式是否成立，我们还通过<a href="https://docs.raku.org/language/variables#index-entry-%5C_%28sigilless_variables%29">无符号变量</a>和集合运算符的 Unicode 形式使用表达式。尽可能接近原始形式; 例如，<code>A ∪ U === U</code>，除了使用<a href="https://docs.raku.org/routine/===">值标识运算符 &lt;===&gt;</a> 与<a href="https://en.wikipedia.org/wiki/Algebra_of_sets">维基百科条目</a>中的实际数学表达式非常接近。</p>
<p>我们甚至可以测试摩根定律，如下面的代码所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@alphabet</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\U</span> <span class="o">=</span> <span class="nv">@alphabet</span><span class="o">.</span><span class="kt">Set</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">⁻</span><span class="p">&gt;(</span><span class="kt">Set</span> <span class="nv">$a</span><span class="p">)</span> <span class="p">{</span> <span class="n">U</span> <span class="o">⊖</span> <span class="nv">$a</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@sets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@sets</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="kt">Set</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="nv">@alphabet</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span> <span class="nv">@alphabet</span><span class="o">.</span><span class="nb">elems</span><span class="o">.</span><span class="nb">rand</span><span class="p">))</span> <span class="k">for</span> <span class="nv">@alphabet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">$de-Morgan1</span><span class="o">,</span><span class="nv">$de-Morgan2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">True</span><span class="o">,</span><span class="kt">True</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@sets</span> <span class="ow">X</span> <span class="nv">@sets</span> <span class="k">-&gt;</span> <span class="p">(</span>\<span class="n">A</span><span class="o">,</span> \<span class="n">B</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$de-Morgan1</span> <span class="o">&amp;&amp;=</span> <span class="p">(</span><span class="n">A</span> <span class="o">∪</span> <span class="n">B</span><span class="p">)</span><span class="o">⁻</span>  <span class="o">===</span> <span class="n">A</span><span class="o">⁻</span> <span class="o">∩</span> <span class="n">B</span><span class="o">⁻</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$de-Morgan2</span> <span class="o">&amp;&amp;=</span> <span class="p">(</span><span class="n">A</span> <span class="o">∩</span> <span class="n">B</span><span class="p">)</span><span class="o">⁻</span>  <span class="o">===</span> <span class="n">A</span><span class="o">⁻</span> <span class="o">∪</span> <span class="n">B</span><span class="o">⁻</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">1st De Morgan is </span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$de-Morgan1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">2nd De Morgan is </span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$de-Morgan2</span><span class="p">;</span>
</span></span></code></pre></div><p>我们声明 - 作为补语运算，它计算通用集U和我们集之间的对称差⊖。一旦宣布这一点，就可以比较容易地表达诸如A和B的并集 <code>(A ∪ B)⁻</code> 的补集，其符号与原始数学符号非常接近。</p>
<h2 id="算术">算术</h2>
<p>Raku 可以使用不同的数据类型进行算术运算。 <a href="https://docs.raku.org/type/Num">Num</a>，<a href="https://docs.raku.org/type/Rat">Rat</a> 和 <a href="https://docs.raku.org/type/Complex">Complex</a> 都可以<a href="https://en.wikipedia.org/wiki/Field_(mathematics)">在操作加法，减法，乘法和除法下作为场</a>运行。等效的数学领域是：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Raku class</th>
<th style="text-align:center">Field</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">C<!-- raw HTML omitted --></td>
<td style="text-align:center">ℚ</td>
</tr>
<tr>
<td style="text-align:center">C<!-- raw HTML omitted --></td>
<td style="text-align:center">ℝ</td>
</tr>
<tr>
<td style="text-align:center">C<!-- raw HTML omitted --></td>
<td style="text-align:center">ℂ</td>
</tr>
</tbody>
</table>
<p><code>Int</code>s 虽然在技术上与 <strong>Z</strong> 相对应，但它并不是真正的数学领域，因为它们不是在四个算术运算下关闭的，并且整数不满足<a href="https://math.stackexchange.com/questions/2192317/set-of-integers-not-a-field/2192330">同一性公理</a>。但是，如果使用整数除法 <code>div</code>，它们的操作将始终产生其他整数;但是，如果使用 <code>/</code>，通常结果将是 <a href="https://docs.raku.org/type/Rat">Rat</a>。</p>
<p>此外，<code>Int</code> 可以进行无限精度算术（或者至少在存储器允许的情况下无限制;还可以发生数字溢出(<code>Numeric overflow</code>)），如果数字太大则不会回落到 <a href="https://docs.raku.org/type/Num">Num</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@powers</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="o">*</span> <span class="o">...</span> <span class="no">Inf</span><span class="p">;</span> <span class="nb">say</span> <span class="nv">@powers</span><span class="o">[</span><span class="mi">4</span><span class="o">].</span><span class="nb">chars</span><span class="p">;</span> <span class="c1"># OUTPUT: «19729␤» </span>
</span></span></code></pre></div><p>同样严格地说，行为类似于数学领域的 Rational 类是 <a href="https://docs.raku.org/type/FatRat">FatRat</a>。出于效率原因，当数字足够大或者分子和分母之间存在很大差异时，操作 <code>Rats</code> 时会回落到 <code>Num</code>。 <code>FatRat</code> 可以使用任意精度，与默认的 <code>Int</code> 类相同。</p>
<p>生态系统中的某些模块可以使用数学方法处理其他数据类型：</p>
<ul>
<li><a href="https://github.com/pierre-vigier/Raku-Math-Matrix">Math::Matrix</a> 操作矩阵字段。</li>
<li><a href="https://github.com/Util/Raku-Math-Quaternion">Math::Quaternion</a> 操作<a href="https://en.wikipedia.org/wiki/Quaternion">四元数字段</a>，这是复数的推广。</li>
<li><a href="https://github.com/colomon/Math-Polynomial">Math::Polynomial</a> 与多项式一起使用，并且能够用它们进行简单的算术运算。</li>
<li><a href="https://github.com/raydiak/Math-Symbolic">Math::Symbolic</a>，用于符号数学</li>
</ul>
<p>数字会自动变为其实际表示的数字类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">.^</span><span class="nb">name</span><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="p">(</span><span class="mi">4</span><span class="o">,</span> ⅗<span class="o">,</span> <span class="mf">1e-9</span><span class="o">,</span> <span class="mi">3</span><span class="o">+</span><span class="mf">.1</span><span class="no">i</span><span class="p">);</span> <span class="c1"># OUTPUT: «Int␤Rat␤Num␤Complex␤» </span>
</span></span></code></pre></div><p>这也使算术运算最适合特定类型</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mf">.33</span><span class="o">-</span><span class="mf">.22</span><span class="o">-</span><span class="mf">.11</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>在这儿，所有数字都被解释为 <code>Rat</code>s，这使得操作准确。通常，大多数语言会将它们解释为浮点数，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mf">.33</span><span class="o">.</span><span class="kt">Num</span> <span class="o">-</span><span class="mf">.22</span><span class="o">.</span><span class="kt">Num</span> <span class="o">-</span> <span class="mf">.11</span><span class="o">.</span><span class="kt">Num</span><span class="p">;</span> <span class="c1"># OUTPUT: «1.3877787807814457e-17␤» </span>
</span></span></code></pre></div><p>对于这样的情况，Raku 还包括一个近似相等的运算符(<code>approximately equal</code>)，<a href="https://docs.raku.org/language/operators#infix_%3D~%3D">≅</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mf">.33</span><span class="o">.</span><span class="kt">Num</span> <span class="o">-</span><span class="mf">.22</span><span class="o">.</span><span class="kt">Num</span> <span class="o">-</span> <span class="mf">.11</span><span class="o">.</span><span class="kt">Num</span> <span class="o">≅</span> <span class="mi">0</span><span class="p">;</span> <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><h2 id="序列">序列</h2>
<p><a href="https://en.wikipedia.org/wiki/Sequence">序列</a>是允许重复的对象的枚举集合，也是 Raku 中称为 <a href="https://docs.raku.org/type/Seq">Seq</a> 的第一类数据类型。 <code>Seq</code> 能够表示无限序列，如自然数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\𝕟</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span> <span class="o">…</span> <span class="no">∞</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">𝕟</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">;</span><span class="c1"># OUTPUT: «4␤» </span>
</span></span></code></pre></div><p>无限序列使用 ∞，<code>Inf</code> 或 <code>*</code>（Whatever）作为终止符。 <code>...</code> 是列表生成器，只要插入第一个数字，它实际上可以理解算术和几何级数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">9</span> <span class="o">…</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «(1 5 9 13 17 21 25 29 33 37 41 45 49 53 57 61 65 69 73 77 81 85 89 93 97 101)␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">9</span> <span class="o">…</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">337</span><span class="p">;</span> <span class="c1"># OUTPUT: «(1 3 9 27 81 243 729)␤» </span>
</span></span></code></pre></div><p>当生成的数字大于 100 时，第一个序列将终止; 第二个序列，当它大于 337 时，是几何级数。</p>
<p>可以使用任意生成器的事实可以很容易地生成像 <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci</a> 这样的序列：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span> <span class="o">*</span> <span class="o">+</span> <span class="o">*</span> <span class="o">…</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">;</span><span class="c1">#  OUTPUT: «(1 1 2 3 5 8 13 21 34 55)␤» </span>
</span></span></code></pre></div><p>事实上，我们可以通过这种方式计算<a href="https://en.wikipedia.org/wiki/Golden_ratio">黄金比例</a>的近似值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@phis</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">.</span><span class="kt">FatRat</span><span class="o">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="o">*</span> <span class="o">...</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@otherphi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nv">@phis</span><span class="o">[</span><span class="mi">200</span><span class="o">],</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="o">*</span> <span class="o">...</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@otherphi</span><span class="o">[^</span><span class="mi">10</span><span class="o">,</span> <span class="o">|</span><span class="p">(</span><span class="mi">20</span><span class="o">,</span> <span class="mi">30</span> <span class="o">...</span> <span class="mi">100</span><span class="p">)</span><span class="o">]</span><span class="p">;</span><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># «((-0.61803398874989484820458683436563811772030918 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># -0.61803398874989484820458683436563811772030918 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># -0.61803398874989484820458683436563811772030918 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># -0.61803398874989484820458683436563811772030918 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># -0.61803398874989484820458683436563811772030918 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># -0.618033…» </span>
</span></span></code></pre></div><p><a href="https://github.com/ajs/raku-Math-Sequences">Math::Sequences</a> 模块包含许多已为你定义的数学序列。它定义了<a href="https://oeis.org/">百科全书中的许多序列</a>，其中一些序列的原始名称，如 ℤ 或 ℝ。</p>
<p>一些集合运算符也对序列进行操作，它们可用于查明对象是否是其中的一部分：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">876</span> <span class="o">∈</span> <span class="p">(</span><span class="mi">7</span><span class="o">,</span><span class="mi">14</span> <span class="o">…</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">;</span> <span class="c1"># OUTPUT: «False␤» </span>
</span></span></code></pre></div><p>在这种特殊情况下，我们可以看出 <code>876</code> 是否是 7 的直接倍数，但同样的原理适用于使用复杂发生器的其他序列。我们也可以使用集合包含运算符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">55</span><span class="o">,</span><span class="mi">89</span><span class="p">)</span><span class="o">.</span><span class="kt">Set</span> <span class="o">⊂</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span> <span class="o">*</span> <span class="o">+</span> <span class="o">*</span> <span class="o">…</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">);</span> <span class="c1"># OUTPUT: «True␤» </span>
</span></span></code></pre></div><p>虽然它没有考虑到它是否实际上是一个子序列，但这里只是存在两个元素;集合没有顺序，即使您没有将子序列显式地转换为Set或显式地将其转换为Seq，它也会被强制转换为包含运算符的应用程序。</p>
<h2 id="数学常数">数学常数</h2>
<p>Raku 已经包含了一组数学常量作为核心的一部分。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="no">π</span><span class="p">;</span> <span class="c1"># OUTPUT: «3.141592653589793» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="no">τ</span><span class="p">;</span> <span class="c1"># Equivalent to 2π; OUTPUT: «6.283185307179586» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="no">𝑒</span><span class="p">;</span> <span class="c1"># OUTPUT: «2.718281828459045␤» </span>
</span></span></code></pre></div><p>它们的拉丁名字 <code>e</code>, <code>pi</code> 和 <code>tau</code> 也是可得的, 具有相同的值 (尽管 <code>𝑒</code> 在 MoarVM 外面访问不了).</p>
<p><a href="https://github.com/JJ/p6-math-constants/pulls">Math::Constants</a> 模块包括一系列额外的物理和数学常数，例如前面提到的黄金比率 <code>φ</code> 或普朗克常数 <code>ℎ</code>。</p>
<p>由于 Raku 允许定义使用 Unicode 字形的变量，以及没有任何类型的 sigil 的变量和常量名称，因此使用概念的实际数学名称来尽可能地命名它们被认为是一种好的做法。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[核心模块]]></title>
            <link href="http://localhost:1313/rakulang/16.core-modules/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/15.concurrency/?utm_source=atom_feed" rel="related" type="text/html" title="并发" />
                <link href="http://localhost:1313/rakulang/14.command-line-interface/?utm_source=atom_feed" rel="related" type="text/html" title="命令行接口" />
                <link href="http://localhost:1313/rakulang/13.classes-and-objects/?utm_source=atom_feed" rel="related" type="text/html" title="类和对象" />
                <link href="http://localhost:1313/rakulang/12.ruby-to-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Ruby 到 Raku" />
                <link href="http://localhost:1313/rakulang/11.python-to-perl6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Python 到 Raku - 简而言之" />
            
                <id>http://localhost:1313/rakulang/16.core-modules/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-22T21:13:31+08:00</published>
            <updated>2018-10-22T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>Rakudo 实现包含一些您可能想要使用的模块。以下是它们的列表，以及它们的源代码的链接。</p>
<h2 id="compunit-模块和角色-httpsdocsrakuorglanguagemodules-core___top"><a href="https://docs.raku.org/language/modules-core#___top"><code>CompUnit::*</code> 模块和角色 </a></h2>
<p>这些模块主要由分发构建工具使用，并不打算由最终用户使用（至少在版本6.c之前）。</p>
<ul>
<li><a href="https://github.com/rakudo/rakudo/blob/master/lib/CompUnit/Repository/Staging.pm6"><code>CompUnit::Repository::Staging</code></a>.</li>
<li><a href="https://github.com/rakudo/rakudo/blob/master/src/core/CompUnit/RepositoryRegistry.pm6"><code>CompUnit::Repository::(FileSystem|Installation|AbsolutePath|Unknown|NQP|Raku|RepositoryRegistry)</code></a>.</li>
</ul>
<h2 id="nativecall-模块httpsdocsrakuorglanguagemodules-core___top"><a href="https://docs.raku.org/language/modules-core#___top"><code>NativeCall</code> 模块</a></h2>
<ul>
<li><a href="https://github.com/rakudo/rakudo/blob/master/lib/NativeCall.pm6"><code>NativeCall</code></a> 原生调用接口 (<a href="https://docs.raku.org/language/nativecall.html">docs</a>)</li>
<li><a href="https://github.com/rakudo/rakudo/blob/master/lib/NativeCall/Types.pm6"><code>NativeCall::Types</code></a> 由 <code>NativeCall</code> 使用</li>
<li><a href="https://github.com/rakudo/rakudo/blob/master/lib/NativeCall/Compiler/GNU.pm6"><code>NativeCall::Compiler::GNU</code></a> 由 <code>NativeCall</code> 使用</li>
<li><a href="https://github.com/rakudo/rakudo/blob/master/lib/NativeCall/Compiler/MSVC.pm6"><code>NativeCall::Compiler::MSVC</code></a> 由 <code>NativeCall</code> 使用</li>
</ul>
<h2 id="other-moduleshttpsdocsrakuorglanguagemodules-core___top"><a href="https://docs.raku.org/language/modules-core#___top">Other modules</a></h2>
<ul>
<li><a href="https://github.com/rakudo/rakudo/blob/master/lib/Pod/To/Text.pm6"><code>Pod::To::Text</code></a> 由多个外部模块使用</li>
<li><a href="https://github.com/rakudo/rakudo/blob/master/lib/Test.pm6"><code>Test</code></a> Test 子例程 (<a href="https://docs.raku.org/language/testing">docs</a>)</li>
<li><a href="https://github.com/rakudo/rakudo/blob/master/lib/experimental.pm6"><code>experimental</code></a></li>
<li><a href="https://github.com/rakudo/rakudo/blob/master/lib/newline.pm6"><code>newline</code></a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[并发]]></title>
            <link href="http://localhost:1313/rakulang/15.concurrency/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/14.command-line-interface/?utm_source=atom_feed" rel="related" type="text/html" title="命令行接口" />
                <link href="http://localhost:1313/rakulang/13.classes-and-objects/?utm_source=atom_feed" rel="related" type="text/html" title="类和对象" />
                <link href="http://localhost:1313/rakulang/12.ruby-to-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Ruby 到 Raku" />
                <link href="http://localhost:1313/rakulang/11.python-to-perl6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Python 到 Raku - 简而言之" />
                <link href="http://localhost:1313/rakulang/9.haskell-to-perl-6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Haskell 到 Raku - 简而言之" />
            
                <id>http://localhost:1313/rakulang/15.concurrency/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-21T21:13:31+08:00</published>
            <updated>2018-10-21T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p><a href="https://docs.raku.org/language/concurrency">Concurrency</a></p>
<p>与大多数现代编程语言一样，Raku 被设计为<a href="https://en.wikipedia.org/wiki/Concurrent_computing">支持并发</a>（允许多个事件同时发生）和异步编程（有时称为事件驱动或反应式编程 - 即程序某些部分的事件或变化可能会导致程序流异步地改变程序的其它部分）。</p>
<p>Perl 的并发设计的目的是提供一个高层级的，可组合的，一致的接口，而不管如下所述的虚拟机通过工具层怎样为特定操作的系统来实现它。</p>
<p>此外，某些 Perl 的特性可以隐式地以异步的方式操作，所以为了确保这些特性可预测的互通，用户代码应在可能情况下，避免较低层级的并发的 API（即<a href="https://docs.raku.org/type/Thread">线程</a>和<a href="https://docs.raku.org/type/Scheduler">调度器</a>），并使用高层级接口。</p>
<h2 id="high-level-apis">High-level APIs</h2>
<h3 id="promises">Promises</h3>
<p><a href="https://docs.raku.org/type/Promise">Promise</a>（在其他编程环境中也被称为 <em>future</em>）封装了在获得 promise 时可能尚未完成或甚至未开始的计算结果。<code>Promise</code> 从 <code>Planned</code> 状态开始, 结果要么是 <code>Kept</code> 状态, 这意味着该 promise 已成功完成, 要么是 <code>Broken</code> 状态, 意味着该 promise 已失败。 通常这就是用户代码需要以并行或异步方式操作的使用最多的功能。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$p1</span> <span class="o">=</span> <span class="kt">Promise</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$p1</span><span class="o">.</span><span class="nb">status</span><span class="p">;</span>       <span class="c1"># OUTPUT: «Planned␤»</span>
</span></span><span class="line"><span class="cl"><span class="nv">$p1</span><span class="o">.</span><span class="nb">keep</span><span class="p">(&#39;</span><span class="s1">Result</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$p1</span><span class="o">.</span><span class="nb">status</span><span class="p">;</span>       <span class="c1"># OUTPUT: «Kept␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$p1</span><span class="o">.</span><span class="nb">result</span><span class="p">;</span>       <span class="c1"># OUTPUT: «Result␤» </span>
</span></span><span class="line"><span class="cl">                      <span class="c1"># (since it has been kept, a result is available!)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$p2</span> <span class="o">=</span> <span class="kt">Promise</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$p2</span><span class="o">.</span><span class="nb">break</span><span class="p">(&#39;</span><span class="s1">oh no</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$p2</span><span class="o">.</span><span class="nb">status</span><span class="p">;</span>       <span class="c1"># Broken</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$p2</span><span class="o">.</span><span class="nb">result</span><span class="p">;</span>       <span class="c1"># dies, because the promise has been broken</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="kt">Str</span> <span class="p">}</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «X::AdHoc+{X::Promise::Broken}: oh no␤»</span>
</span></span></code></pre></div><p><code>Promise</code> 通过组合, 例如通过链接(chaining), 通常通过 <a href="https://docs.raku.org/type/Promise#method_then">then</a> 方法获取更多力量:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$promise1</span> <span class="o">=</span> <span class="kt">Promise</span><span class="o">.</span><span class="nb">new</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$promise2</span> <span class="o">=</span> <span class="nv">$promise1</span><span class="o">.</span><span class="nb">then</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$v</span><span class="o">.</span><span class="nb">result</span><span class="p">;</span> <span class="p">&#34;</span><span class="s2">Second Result</span><span class="p">&#34;}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$promise1</span><span class="o">.</span><span class="nb">keep</span><span class="p">(&#34;</span><span class="s2">First Result</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$promise2</span><span class="o">.</span><span class="nb">result</span><span class="p">;</span>   <span class="c1"># First Result \n Second Result</span>
</span></span></code></pre></div><p>在这里 <a href="https://docs.raku.org/type/Promise#method_then">then</a> 方法安排代码(即圆括号中的闭包)在第一个 <a href="https://docs.raku.org/type/Promise">Promise</a> 为 kept 或 broken 时执行, 它自身返回一个新的 Promise, 这个新的 Promise 会在执行代码时与结果一块保存。 (如果代码执行失败则 broken ) <code>keep</code> 更改 promise 的状态为 <strong>Kept</strong>, 并设置结果为位置参数。<code>result</code> 阻塞当前执行的线程直到那个 promise 变为 kept 或 broken, 如果它是 kept, 那么它会返回那个结果(即传递给 <code>keep</code> 的值, ) 否则它会根据传递给 <code>break</code> 的值抛出异常。后者的行为如下所示:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$promise1</span> <span class="o">=</span> <span class="kt">Promise</span><span class="o">.</span><span class="nb">new</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$promise2</span> <span class="o">=</span> <span class="nv">$promise1</span><span class="o">.</span><span class="nb">then</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Handled but : </span><span class="p">&#34;;</span> <span class="nb">say</span> <span class="nv">$v</span><span class="o">.</span><span class="nb">result</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nv">$promise1</span><span class="o">.</span><span class="nb">break</span><span class="p">(&#34;</span><span class="s2">First Result</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="nv">$promise2</span><span class="o">.</span><span class="nb">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$promise2</span><span class="o">.</span><span class="nb">cause</span><span class="p">;</span>        <span class="c1"># Handled but : \n First Result</span>
</span></span></code></pre></div><p>当它在原来的作为参数传递的 promise 上调用 <code>result</code> 方法时, 这里的 <code>break</code> 会导致 <code>then</code> 代码块抛出异常, 这随后会导致第二个 promise 变为 broken, 在它的结果被接收时反过来引发一个异常。然后能从 <code>cause</code> 中访问那个实际的 <a href="https://docs.raku.org/type/Exception">Exception</a> 对象。如果那个 promise 还没有变为 broken, 那么 <code>cause</code> 会引发 <a href="https://docs.raku.org/type/X$COLON$COLONPromise$COLON$COLONCauseOnlyValidOnBroken">X::Promise::CauseOnlyValidOnBroken</a> 异常。</p>
<p><a href="https://docs.raku.org/type/Promise">Promise</a> 也可以安排在未来自动保存(kept):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$promise1</span> <span class="o">=</span> <span class="kt">Promise</span><span class="o">.</span><span class="nb">in</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$promise2</span> <span class="o">=</span> <span class="nv">$promise1</span><span class="o">.</span><span class="nb">then</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$v</span><span class="o">.</span><span class="nb">status</span><span class="p">;</span> <span class="p">&#39;</span><span class="s1">Second Result</span><span class="p">&#39;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$promise2</span><span class="o">.</span><span class="nb">result</span><span class="p">;</span> <span class="c1"># 5 秒后打印出: Kept\n Second Result</span>
</span></span></code></pre></div><p><a href="https://docs.raku.org/type/Promise#method_in">in</a> 方法创建了一个新的 promise 并安排一个新的任务在不早于所提供的秒数内在它身上调用 <code>keep</code>, 返回一个新的 <a href="https://docs.raku.org/type/Promise">Promise</a> 对象。</p>
<p>promises 的一个非常频繁的用法是运行一段代码, 并且一旦它成功地返回就 keep 那个 promise, 或者当那块代码死掉时中断(break)那个 promise。<a href="https://docs.raku.org/type/Promise#method_start">start</a> 方法为此提供了一种快捷方式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$promise</span> <span class="o">=</span> <span class="kt">Promise</span><span class="o">.</span><span class="k">start</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span> <span class="p">{</span> <span class="nv">$i</span> <span class="o">+=</span> <span class="nv">$_</span> <span class="p">};</span> <span class="nv">$i</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$promise</span><span class="o">.</span><span class="nb">status</span><span class="p">;</span>    <span class="c1"># Kept</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$promise</span><span class="o">.</span><span class="nb">result</span><span class="p">;</span>    <span class="c1"># 55</span>
</span></span></code></pre></div><p>这里返回的 promise 的结果(<code>result</code>)是从代码返回的值。类似地, 如果那段代码失败了(那个 promise 也因此被中断), 那么 <code>cause</code> 会成为抛出的那个 <a href="https://docs.raku.org/type/Exception">Exception</a> 对象:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$promise</span> <span class="o">=</span> <span class="kt">Promise</span><span class="o">.</span><span class="k">start</span><span class="p">({</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Broken Promise</span><span class="p">&#34;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="nv">$promise</span><span class="o">.</span><span class="nb">result</span><span class="p">;</span> <span class="c1"># Nil</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$promise</span><span class="o">.</span><span class="nb">cause</span><span class="p">;</span>  <span class="c1"># Broken Promise</span>
</span></span><span class="line"><span class="cl">                     <span class="c1">#  in block &lt;unit&gt; at &lt;unknown file&gt; line 1</span>
</span></span></code></pre></div><p>这个模式太常见了以至于它还提供了子例程形式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$promise</span> <span class="o">=</span> <span class="k">start</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$i</span> <span class="o">+=</span> <span class="nv">$_</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$i</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$result</span> <span class="o">=</span> <span class="nb">await</span> <span class="nv">$promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$result</span><span class="p">;</span>
</span></span></code></pre></div><p><code>await</code> 几乎等价于在由 <code>start</code> 返回的 promise 对象身上调用 <code>result</code> 但是它也会接受一组 promises 并返回每个 promise 的结果:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$p1</span> <span class="o">=</span> <span class="k">start</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$i</span> <span class="o">+=</span> <span class="nv">$_</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$i</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$p2</span> <span class="o">=</span> <span class="k">start</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$i</span> <span class="o">-=</span> <span class="nv">$_</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$i</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@result</span> <span class="o">=</span> <span class="nb">await</span> <span class="nv">$p1</span><span class="o">,</span> <span class="nv">$p2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@result</span><span class="p">;</span>            <span class="c1"># [55 -55]</span>
</span></span></code></pre></div><p>除了 <code>await</code> 之外, 两个类方法把几个 <a href="https://docs.raku.org/type/Promise">Promise</a> 对象合并到一个新的 promise 对象中: 当所有原来的 promises 是 kept 或 broken 时, <code>allof</code> 返回一个 kept 状态的 promise:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$promise</span> <span class="o">=</span> <span class="kt">Promise</span><span class="o">.</span><span class="nb">allof</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Promise</span><span class="o">.</span><span class="nb">in</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Promise</span><span class="o">.</span><span class="nb">in</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">await</span> <span class="nv">$promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">All done</span><span class="p">&#34;;</span> <span class="c1"># Should be not much more than three seconds later</span>
</span></span></code></pre></div><p>并且当原 promises 中的任何一个的状态变为 kept 或 broken 时, <code>anyof</code> 返回将为 kept 的新 promise:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$promise</span> <span class="o">=</span> <span class="kt">Promise</span><span class="o">.</span><span class="nb">anyof</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Promise</span><span class="o">.</span><span class="nb">in</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Promise</span><span class="o">.</span><span class="nb">in</span><span class="p">(</span><span class="mi">8600</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">await</span> <span class="nv">$promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">All done</span><span class="p">&#34;;</span> <span class="c1"># Should be about 3 seconds later</span>
</span></span></code></pre></div><p>不同于 <code>await</code>，然而如果不引用原来的 promise, 那么就访问不了原来状态为 kept 的 promise 的结果，因此当任务的完成或其他方面对于消费者来说比实际结果更重要时，或者当通过其它方式收集结果时。 你可能，例如，您可以创建一个依赖的Promise，它会检查每个原始的 promise：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@promises</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">5</span> <span class="k">-&gt;</span> <span class="nv">$t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">push</span> <span class="nv">@promises</span><span class="o">,</span> <span class="k">start</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">sleep</span> <span class="nv">$t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">Bool</span><span class="o">.</span><span class="nb">pick</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">await</span> <span class="kt">Promise</span><span class="o">.</span><span class="nb">allof</span><span class="p">(</span><span class="nv">@promises</span><span class="p">)</span><span class="o">.</span><span class="nb">then</span><span class="p">({</span> <span class="nb">so</span> <span class="nb">all</span><span class="p">(</span><span class="nv">@promises</span><span class="o">&gt;&gt;.</span><span class="nb">result</span><span class="p">)</span> <span class="p">});</span>
</span></span></code></pre></div><p>如果所有的 promise 都保持为 True, 那么它会打印 True, 否则会打印 False。</p>
<p>如果你正在创建一个 promise，你打算保持或中断自己，那么在你做之前, 你可能不想要任何可能会收到 promise 以无意（或否则）保持或中断该 promise 的代码。 为了这个目的，就有了方法 <a href="https://docs.raku.org/type/Promise#method_vow">vow</a>，它返回一个 <a href="https://docs.raku.org/type/Vow">Vow</a> 对象，它成为 promise 能被保留或中断的唯一机制。 如果试图直接保持或断开这个 Promise ，则会抛出 <a href="https://docs.raku.org/type/X$COLON$COLONPromise$COLON$COLONVowed">X::Promise::Vowed</a> 异常，只要 <code>vow</code> 对象保持私有，那么 promise 的状态就是安全的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">get_promise</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$promise</span> <span class="o">=</span> <span class="kt">Promise</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$vow</span> <span class="o">=</span> <span class="nv">$promise</span><span class="o">.</span><span class="nb">vow</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Promise</span><span class="o">.</span><span class="nb">in</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="nb">then</span><span class="p">({</span><span class="nv">$vow</span><span class="o">.</span><span class="nb">keep</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$promise</span> <span class="o">=</span> <span class="nf">get_promise</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Will throw an exception</span>
</span></span><span class="line"><span class="cl"><span class="c1"># &#34;Access denied to keep/break this Promise; already vowed&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$promise</span><span class="o">.</span><span class="nb">keep</span><span class="p">;</span>
</span></span></code></pre></div><p>返回一个将被自动保存或断开的 promise 的方法，如 <code>in</code> 或 <code>start</code> 将会做到这一点，所以没有必要这样做。</p>
<h3 id="supplies">Supplies</h3>
<p><a href="https://docs.raku.org/type/Supply">Supply</a> 是异步数据流传输机制，其可以以类似于其他编程语言中的&quot;事件&quot;的方式同时由一个或多个消费者消费，并且可以被视为开启&quot;事件驱动&quot;或反应式设计。</p>
<p>最简单的是，Supply 是一个消息流，可以有多个通过方法 <code>tap</code> 创建的订阅者，其数据项可以使用 <code>emit</code> 放置。</p>
<p>Supply 可以是现场的(<code>live</code>)或按需的(<code>on-demand</code>)。 现场(<code>live</code>)供应就像电视广播：那些调入(收听/收看)的人不会得到先前发出的值。 点播(<code>on-demand</code>)广播就像 Netflix：每个开始流式传输电影（点击电源）的人，总是从头开始（获取所有的值），不管有多少人正在观看它。 请注意，没有为<code>按需</code>供应保留历史记录，而是为供应的每次点击运行 <code>supply</code> 块。</p>
<blockquote>
<p>Netflix: 在线观看电影的网站</p>
</blockquote>
<p>实时供应(<code>live Supply</code>)由 <a href="https://docs.raku.org/type/Supplier">Supplier</a> 工厂创建，每个发出的值在添加时传递给所有活动的 tappers：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supplier</span> <span class="o">=</span> <span class="kt">Supplier</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supply</span>   <span class="o">=</span> <span class="nv">$supplier</span><span class="o">.</span><span class="kt">Supply</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$supply</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span> <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$v</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$supplier</span><span class="o">.</span><span class="nb">emit</span><span class="p">(</span><span class="nv">$_</span><span class="p">);</span> <span class="c1"># 1\n2\n3\n4\n5\n6\n7\n8\n9\n10</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>请注意，<code>tap</code> 在供应商<a href="https://docs.raku.org/type/Supplier">Supplier</a>创建的 Supply 对象上调用，并且新值在供应商<a href="https://docs.raku.org/type/Supplier">Supplier</a>上发出。</p>
<p>或者作为由 <code>supply</code> 关键字创建的按需供应 <a href="https://docs.raku.org/type/Supply">Supply</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supply</span> <span class="o">=</span> <span class="k">supply</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">emit</span><span class="p">(</span><span class="nv">$_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">$supply</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span> <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$v</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1\n2\n3\n4\n5\n6\n7\n8\n9\n10</span>
</span></span></code></pre></div><p>在这种情况下，供应块中的代码在每次供应返回的供应被窃取时执行，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supply</span> <span class="o">=</span> <span class="k">supply</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">emit</span><span class="p">(</span><span class="nv">$_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">$supply</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span> <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">First : </span><span class="nv">$v</span><span class="p">&#34;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nv">$supply</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span> <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Second : </span><span class="nv">$v</span><span class="p">&#34;</span> <span class="p">});</span>
</span></span></code></pre></div><p><code>tap</code> 方法返回一个 <a href="https://docs.raku.org/type/Tap">Tap</a> 对象，它可以用来获取关于 tap 的信息，并且当我们不再对事件感兴趣时关闭它：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supplier</span> <span class="o">=</span> <span class="kt">Supplier</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supply</span>   <span class="o">=</span> <span class="nv">$supplier</span><span class="o">.</span><span class="kt">Supply</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$tap</span> <span class="o">=</span> <span class="nv">$supply</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span> <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$v</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$supplier</span><span class="o">.</span><span class="nb">emit</span><span class="p">(&#34;</span><span class="s2">OK</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$tap</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$supplier</span><span class="o">.</span><span class="nb">emit</span><span class="p">(&#34;</span><span class="s2">Won&#39;t trigger the tap</span><span class="p">&#34;);</span>
</span></span></code></pre></div><p>在供应对象(supply object)上调用 <code>done</code> 调用可以为任何 tap 指定的 <code>done</code> 回调，但不会阻止任何其他事件被发送到流，或者接收它们。</p>
<p>方法 <code>interval</code> 返回一个新的按需供应，它会以指定的间隔定期发出一个新事件。 发出的数据是从0开始的整数，对于每个事件递增。 以下代码输出 0 .. 5：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supply</span> <span class="o">=</span> <span class="kt">Supply</span><span class="o">.</span><span class="nb">interval</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$supply</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$v</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nb">sleep</span> <span class="mi">10</span><span class="p">;</span>
</span></span></code></pre></div><p>这也可以使用 <code>react</code> 关键字书写(输出0..4)：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">react</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">whenever</span> <span class="kt">Supply</span><span class="o">.</span><span class="nb">interval</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">done</span><span class="p">()</span> <span class="k">if</span> <span class="nv">$v</span> <span class="o">==</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里，<a href="https://docs.raku.org/language/concurrency#index-entry-whenever">whenever</a> 关键字使用 <a href="https://docs.raku.org/type/Supply#method_act">.act</a> 从提供的块在 Supply 上创建一个 tap。 当在其中一个 tap 中调用 <code>done()</code> 时，退出 <code>react</code> 块。</p>
<p>第二个参数可以提供给 <code>interval</code>，它指定第一个事件触发之前的延迟（以秒为单位）。 通过 <code>interval</code> 创建的 supply 的每个 tap 都有自0开始的自身序列，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supply</span> <span class="o">=</span> <span class="kt">Supply</span><span class="o">.</span><span class="nb">interval</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$supply</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">First </span><span class="nv">$v</span><span class="p">&#34;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nb">sleep</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$supply</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Second </span><span class="nv">$v</span><span class="p">&#34;});</span>
</span></span><span class="line"><span class="cl"><span class="nb">sleep</span> <span class="mi">10</span><span class="p">;</span>
</span></span></code></pre></div><p>也可以从将要依次发出的值的列表中按需创建 Supply(供给)，因此第一个按需示例（打印1到10）可以写作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">react</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">whenever</span> <span class="kt">Supply</span><span class="o">.</span><span class="nb">from-list</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以使用方法 <code>grep</code> 和 <code>map</code> 分别过滤或转换现有的供应对象(supply object)，以类似具名列表方法的方式创建新供应(supply)：<code>grep</code> 返回这样一个供应(supply)，以至于只有在源流上发出的那些事件的 <code>grep</code> 条件为真时才在第二个 supply 上发出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supplier</span> <span class="o">=</span> <span class="kt">Supplier</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supply</span> <span class="o">=</span> <span class="nv">$supplier</span><span class="o">.</span><span class="kt">Supply</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$supply</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Original : </span><span class="nv">$v</span><span class="p">&#34;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$odd_supply</span> <span class="o">=</span> <span class="nv">$supply</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="nv">$_</span> <span class="nv">%</span> <span class="mi">2</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nv">$odd_supply</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Odd : </span><span class="nv">$v</span><span class="p">&#34;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$even_supply</span> <span class="o">=</span> <span class="nv">$supply</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="nb">not</span> <span class="nv">$_</span> <span class="nv">%</span> <span class="mi">2</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nv">$even_supply</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Even : </span><span class="nv">$v</span><span class="p">&#34;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">0</span> <span class="o">..</span> <span class="mi">10</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$supplier</span><span class="o">.</span><span class="nb">emit</span><span class="p">(</span><span class="nv">$_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>map</code> 返回一个新的 supply(供应)，使得对于发送到原始供应的每个项目，发出作为传递给 <code>map</code> 表达式的结果的新项目：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supplier</span> <span class="o">=</span> <span class="kt">Supplier</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supply</span> <span class="o">=</span> <span class="nv">$supplier</span><span class="o">.</span><span class="kt">Supply</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$supply</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Original : </span><span class="nv">$v</span><span class="p">&#34;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$half_supply</span> <span class="o">=</span> <span class="nv">$supply</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="nv">$_</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nv">$half_supply</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Half : </span><span class="nv">$v</span><span class="p">&#34;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">0</span> <span class="o">..</span> <span class="mi">10</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$supplier</span><span class="o">.</span><span class="nb">emit</span><span class="p">(</span><span class="nv">$_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果您需要在 supply(供应)完成时运行一个操作，您可以通过在对 <code>tap</code> 的调用中设置 <code>done</code> 和 <code>quit</code> 选项来完成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$supply</span><span class="o">.</span><span class="nb">tap</span><span class="o">:</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">done</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Job is done.</span><span class="p">&#39;</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">quit</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="ne">X::MyApp::Error</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">App Error: </span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">message</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span></code></pre></div><p><code>quit</code> 块的工作方式非常类似于 <code>CATCH</code>。 如果异常被标记为由 <code>when</code> 或 <code>default</code> 块看到，那么异常会被捕获并处理。 否则，异常继续沿调用树向上（即，与没有设置 <code>quit</code> 时行为相同）。</p>
<p>如果你伴随着 <code>whenever</code> 使用 <code>react</code> 或者 <code>supply</code> block 语法，你可以在你的 <code>whenever</code> 块中添加 phasers 来处理来自 tapped supply 的 <code>done</code> 和 <code>quit</code> 消息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">react</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">whenever</span> <span class="nv">$supply</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">...</span><span class="p">;</span> <span class="c1"># your usual supply tap code here</span>
</span></span><span class="line"><span class="cl">        <span class="k">LAST</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Job is done.</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">QUIT</span> <span class="p">{</span> <span class="k">when</span> <span class="ne">X::MyApp::Error</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">App Error: </span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">message</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里的行为与在 <code>tap</code> 上设置 <code>done</code> 和 <code>quit</code> 相同。</p>
<h3 id="channels">Channels</h3>
<p>通道(<a href="https://docs.raku.org/type/Channel">Channel</a>)是线程安全的队列，可以具有多个读取器和写入器，可以被认为在操作上与“fifo”(先进先出)或命名管道相似，除了它不启用进程间通信之外。 应该注意的是，作为真正的队列，发送到通道的每个值将仅在先读，先服务的基础上对于单个读取器可用：如果想要多个读取器能够接收可能想要发送的每个项目那么请考虑<a href="https://docs.raku.org/type/Supply">Supply</a>。</p>
<p>项目(item)通过方法 <a href="https://docs.raku.org/type/Channel#method_send">send</a> 排队到通道上，方法 <a href="https://docs.raku.org/type/Channel#method_receive">receive</a> 从队列中删除一个项目并返回，如果队列为空，则阻塞它直到发送新项目：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$channel</span> <span class="o">=</span> <span class="kt">Channel</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$channel</span><span class="o">.</span><span class="nb">send</span><span class="p">(&#39;</span><span class="s1">Channel One</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$channel</span><span class="o">.</span><span class="nb">receive</span><span class="p">;</span>  <span class="c1"># &#39;Channel One&#39;</span>
</span></span></code></pre></div><p>如果使用 <a href="https://docs.raku.org/type/Channel#method_close">close</a> 方法关闭了通道，那么任何发送(<code>send</code>)都将导致抛出异常 <a href="https://docs.raku.org/type/X$COLON$COLONChannel$COLON$COLONSendOnClosed">X::Channel::SendOnClosed</a>，并且如果队列中没有更多的项目，接收(<code>receive</code>) 将抛出一个 <a href="https://docs.raku.org/type/X$COLON$COLONChannel$COLON$COLONReceiveOnClosed">X::Channel::ReceiveOnClosed</a> 异常。</p>
<p>方法<a href="https://docs.raku.org/type/Channel#method_list">list</a>返回通道上的所有项目，并将阻塞，直到其他项目被排队，除非通道关闭：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$channel</span> <span class="o">=</span> <span class="kt">Channel</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">await</span> <span class="p">(</span><span class="o">^</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="k">-&gt;</span> <span class="nv">$r</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">start</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">sleep</span> <span class="nv">$r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$channel</span><span class="o">.</span><span class="nb">send</span><span class="p">(</span><span class="nv">$r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">$channel</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">$channel</span><span class="o">.</span><span class="nb">list</span> <span class="k">-&gt;</span> <span class="nv">$r</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>还有从通道返回可用项目的非阻塞方法<a href="https://docs.raku.org/type/Channel#method_poll">poll</a>, 或者, 如果没有项目或通道被关闭则返回 <a href="https://docs.raku.org/type/Nil">Nil</a>，这当然意味着必须检查通道以确定其是否关闭：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="kt">Channel</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Start three Promises that sleep for 1..3 seconds, and then</span>
</span></span><span class="line"><span class="cl"><span class="c1"># send a value to our Channel</span>
</span></span><span class="line"><span class="cl"><span class="o">^</span><span class="mi">3</span> <span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">start</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">sleep</span> <span class="mi">3</span> <span class="o">-</span> <span class="nv">$v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$c</span><span class="o">.</span><span class="nb">send</span><span class="o">:</span> <span class="p">&#34;</span><span class="nv">$v</span><span class="s2"> from thread </span><span class="p">{</span><span class="vg">$*THREAD</span><span class="o">.</span><span class="nb">id</span><span class="p">}&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Wait 3 seconds before closing the channel</span>
</span></span><span class="line"><span class="cl"><span class="kt">Promise</span><span class="o">.</span><span class="nb">in</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">then</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$c</span><span class="o">.</span><span class="nb">close</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Continuously loop and poll the channel, until it&#39;s closed</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$is-closed</span> <span class="o">=</span> <span class="nv">$c</span><span class="o">.</span><span class="nb">closed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">loop</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$c</span><span class="o">.</span><span class="nb">poll</span> <span class="k">-&gt;</span> <span class="nv">$item</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$item</span><span class="s2"> received after </span><span class="p">{</span><span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">}</span><span class="s2"> seconds</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">elsif</span> <span class="nv">$is-closed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Doing some unrelated things...</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">sleep</span> <span class="mf">.6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Doing some unrelated things...</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Doing some unrelated things...</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2 from thread 5 received after 1.2063182 seconds</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Doing some unrelated things...</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Doing some unrelated things...</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1 from thread 4 received after 2.41117376 seconds</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Doing some unrelated things...</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 0 from thread 3 received after 3.01364461 seconds</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Doing some unrelated things...</span>
</span></span></code></pre></div><p>方法 <a href="https://docs.raku.org/type/Channel#method_closed">closed</a> 返回一个 Promise，当通道关闭时，它将被保存(kept)（因此在布尔上下文中将被计算为 True）。</p>
<p><code>.poll</code> 方法可以与 <code>.receive</code> 方法结合使用，作为一种缓存机制，其中 <code>.poll</code> 返回的值不足是需要获取更多值并加载到通道的信号：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">get-value</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nv">$c</span><span class="o">.</span><span class="nb">poll</span> <span class="o">//</span> <span class="nb">do</span> <span class="p">{</span> <span class="k">start</span> <span class="n">replenish-cache</span><span class="p">;</span> <span class="nv">$c</span><span class="o">.</span><span class="nb">receive</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">replenish-cache</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">^</span><span class="mi">20</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$c</span><span class="o">.</span><span class="nb">send</span><span class="o">:</span> <span class="nv">$_</span> <span class="k">for</span> <span class="nf">slowly-fetch-a-thing</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以使用通道代替前面描述的 <code>whenever</code> 和 <code>react</code> 块中的 <a href="https://docs.raku.org/type/Supply">Supply</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$channel</span> <span class="o">=</span> <span class="kt">Channel</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$p</span> <span class="o">=</span> <span class="k">start</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">react</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">whenever</span> <span class="nv">$channel</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="nv">$_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">await</span> <span class="p">(</span><span class="o">^</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="k">-&gt;</span> <span class="nv">$r</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">start</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">sleep</span> <span class="nv">$r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$channel</span><span class="o">.</span><span class="nb">send</span><span class="p">(</span><span class="nv">$r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$channel</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">await</span> <span class="nv">$p</span><span class="p">;</span>
</span></span></code></pre></div><p>还可以使用<a href="https://docs.raku.org/type/Supply#method_Channel">通道方法</a>从<a href="https://docs.raku.org/type/Supply">Supply</a>获得<a href="https://docs.raku.org/type/Channel">通道</a>，该通道方法返回通过 <a href="https://docs.raku.org/type/Supply">Supply</a> 上的 <code>tap</code> 馈送的通道：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supplier</span> <span class="o">=</span> <span class="kt">Supplier</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$supply</span>   <span class="o">=</span> <span class="nv">$supplier</span><span class="o">.</span><span class="kt">Supply</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$channel</span> <span class="o">=</span> <span class="nv">$supply</span><span class="o">.</span><span class="kt">Channel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$p</span> <span class="o">=</span> <span class="k">start</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">react</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">whenever</span> <span class="nv">$channel</span> <span class="k">-&gt;</span> <span class="nv">$item</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">via Channel: </span><span class="nv">$item</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">await</span> <span class="p">(</span><span class="o">^</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="k">-&gt;</span> <span class="nv">$r</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">start</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">sleep</span> <span class="nv">$r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$supplier</span><span class="o">.</span><span class="nb">emit</span><span class="p">(</span><span class="nv">$r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$supplier</span><span class="o">.</span><span class="nb">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">await</span> <span class="nv">$p</span><span class="p">;</span>
</span></span></code></pre></div><p><code>Channel</code> 将返回一个不同的通道，每次调用时都会使用相同的数据。 这可以用于例如将 <a href="https://docs.raku.org/type/Supply">Supply</a> 输出到一个或多个通道以在程序中提供的不同接口。</p>
<h3 id="procasync">Proc::Async</h3>
<p><a href="https://docs.raku.org/type/Proc$COLON$COLONAsync">Proc::Async</a> 构建在所描述的设施上以异步方式运行并与外部程序交互：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$proc</span> <span class="o">=</span> <span class="kt">Proc::Async</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">echo</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">bar</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$proc</span><span class="o">.</span><span class="nb">stdout</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">Output: </span><span class="nv">$v</span><span class="p">&#34;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nv">$proc</span><span class="o">.</span><span class="nb">stderr</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">Error:  </span><span class="nv">$v</span><span class="p">&#34;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Starting...</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$promise</span> <span class="o">=</span> <span class="nv">$proc</span><span class="o">.</span><span class="k">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">await</span> <span class="nv">$promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Done.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Output:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Starting...</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Output: foo bar</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Done.</span>
</span></span></code></pre></div><p>命令的路径以及命令的任何参数都提供给该构造函数。 该命令将不被执行，直到调用 <a href="https://docs.raku.org/type/Proc$COLON$COLONAsync#method_start">start</a>，它将返回一个 Promise，当程序退出时该 Promise 变为 kept 状态。 程序的标准输出和标准错误分别从 <a href="https://docs.raku.org/type/Proc$COLON$COLONAsync#method_stdout">stdout</a> 和 <a href="https://docs.raku.org/type/Proc$COLON$COLONAsync#method_stderr">stderr</a> 方法中作为 Supply 对象提供，可以根据需要进行分接。</p>
<p>如果要写入程序的标准输入，您可以给构造函数提供 <code>:w</code> 副词，并使用方法 <a href="https://docs.raku.org/type/Proc$COLON$COLONAsync#method_write">write</a>，<a href="https://docs.raku.org/type/Proc$COLON$COLONAsync#method_print">print</a> 或 <a href="https://docs.raku.org/type/Proc$COLON$COLONAsync#method_say">say</a> 在程序启动后写入打开的管道：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$proc</span> <span class="o">=</span> <span class="kt">Proc::Async</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">w</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">grep</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$proc</span><span class="o">.</span><span class="nb">stdout</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">Output: </span><span class="nv">$v</span><span class="p">&#34;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Starting...</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$promise</span> <span class="o">=</span> <span class="nv">$proc</span><span class="o">.</span><span class="k">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$proc</span><span class="o">.</span><span class="nb">say</span><span class="p">(&#34;</span><span class="s2">this line has foo</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$proc</span><span class="o">.</span><span class="nb">say</span><span class="p">(&#34;</span><span class="s2">this one doesn&#39;t</span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$proc</span><span class="o">.</span><span class="nb">close-stdin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">await</span> <span class="nv">$promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Done.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Output:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Starting...</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Output: this line has foo</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Done.</span>
</span></span></code></pre></div><p>一些程序（例如本例中没有文件参数的 <code>grep</code>）在关闭标准输入之前不会退出，因此在完成写入后可以调用 <a href="https://docs.raku.org/type/Proc$COLON$COLONAsync#method_close-stdin">close-stdin</a>，以允许由 <code>start</code> 返回的 Promise 的状态变为 kept。</p>
<h2 id="low-level-apis">Low-level APIs</h2>
<h3 id="threads">Threads</h3>
<p>最低级别的并发接口由 <a href="https://docs.raku.org/type/Thread">Thread</a> 提供。 线程可以被认为是可以最终在处理器上运行的一段代码，其布置几乎完全由虚拟机和/或操作系统完成。 线程应该被考虑，对于所有意图，很大程度上是不受管理的，应避免在用户代码中直接使用它们。</p>
<p>线程可以被创建，然后随后实际运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$thread</span> <span class="o">=</span> <span class="kt">Thread</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">code</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">for</span>  <span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span>  <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$v</span> <span class="p">}});</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ...</span>
</span></span><span class="line"><span class="cl"><span class="nv">$thread</span><span class="o">.</span><span class="nb">run</span><span class="p">;</span>
</span></span></code></pre></div><p>或者可以在单个调用中创建和运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$thread</span> <span class="o">=</span> <span class="kt">Thread</span><span class="o">.</span><span class="k">start</span><span class="p">({</span> <span class="k">for</span>  <span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span>  <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$v</span> <span class="p">}});</span>
</span></span></code></pre></div><p>在这两种情况下，由 <a href="https://docs.raku.org/type/Thread">Thread</a> 对象封装的代码的完成可以用 <code>finish</code> 方法来等待，该方法将阻塞直到线程完成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$thread</span><span class="o">.</span><span class="nb">finish</span><span class="p">;</span>
</span></span></code></pre></div><p>除此之外，没有用于同步或资源共享的其他设施，这主要是为什么应当强调线程不可能直接用于用户代码。</p>
<h3 id="schedulers">Schedulers</h3>
<p>并发 API 的下一级由实现角色<a href="https://docs.raku.org/type/Scheduler">Scheduler</a>定义的接口的类提供。 调度程序接口的目的是提供一种机制来确定使用哪些资源来运行特定任务以及何时运行它。 大多数较高级别的并发 API 是基于调度器构建的，并且用户代码根本不需要使用它们，尽管一些方法，例如在 <a href="https://docs.raku.org/type/Proc$COLON$COLONAsync">Proc::Async</a>，<a href="https://docs.raku.org/type/Promise">Promise</a> 和 <a href="https://docs.raku.org/type/Supply">Supply</a> 中找到的方法允许您明确地提供调度器。</p>
<p>当前缺省全局调度程序在变量 <code>$*SCHEDULER</code> 中可用。</p>
<p>调度程序的主接口（确实是<a href="https://docs.raku.org/type/Scheduler">Scheduler</a>接口所需的唯一方法）是 <code>cue</code> 方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">method</span> <span class="nb">cue</span><span class="p">(</span><span class="o">:</span><span class="nv">&amp;code</span><span class="o">,</span> <span class="kt">Instant</span> <span class="o">:</span><span class="nv">$at</span><span class="o">,</span> <span class="o">:</span><span class="nv">$in</span><span class="o">,</span> <span class="o">:</span><span class="nv">$every</span><span class="o">,</span> <span class="o">:</span><span class="nv">$times</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">:</span><span class="nv">&amp;catch</span><span class="p">)</span>
</span></span></code></pre></div><p>这将按照由副词（如在<a href="https://docs.raku.org/type/Scheduler">Scheduler</a>中记录的）所确定的方式使用由调度器实现的执行方案来调度 <code>&amp;code</code> 中的 <code>Callable</code> 以执行。 例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$cancellation</span> <span class="o">=</span> <span class="vg">$*SCHEDULER</span><span class="o">.</span><span class="nb">cue</span><span class="p">({</span> <span class="nb">say</span> <span class="nv">$i</span><span class="o">++</span><span class="p">}</span><span class="o">,</span> <span class="s">every</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">sleep</span> <span class="mi">20</span><span class="p">;</span>
</span></span></code></pre></div><p>假设 <code>$*SCHEDULER</code> 没有从默认值改变，将以大约每两秒打印数字0到10（即使用操作系统调度容差）。 在这种情况下，代码将被调度运行，直到程序正常结束，但是该方法返回一个 <a href="https://docs.raku.org/type/Cancellation">Cancellation</a> 对象，它可以用来在正常完成之前取消调度执行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$cancellation</span> <span class="o">=</span> <span class="vg">$*SCHEDULER</span><span class="o">.</span><span class="nb">cue</span><span class="p">({</span> <span class="nb">say</span> <span class="nv">$i</span><span class="o">++</span><span class="p">}</span><span class="o">,</span> <span class="s">every</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">sleep</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$cancellation</span><span class="o">.</span><span class="nb">cancel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">sleep</span> <span class="mi">10</span><span class="p">;</span>
</span></span></code></pre></div><p>应该只输出 0 到 5，</p>
<p>尽管 <a href="https://docs.raku.org/type/Scheduler">Scheduler</a> 接口提供的所有功能明显优于 <a href="https://docs.raku.org/type/Thread">Thread</a> 提供的，但是通过更高级别的接口可以获得所有的功能，并且不应该有必要直接使用调度器，除非在上述情况下，调度器可以被明确地提供给某些方法。</p>
<p>如果库具有特殊要求，例如 UI 库可能希望所有代码在单个 UI 线程中运行，或者可能需要一些定制的优先级机制，则库可能希望提供备选的调度器实现，然而，被作为标准的实现和下面的描述应该足以满足大多数用户代码。</p>
<h3 id="threadpoolscheduler">ThreadPoolScheduler</h3>
<p><a href="https://docs.raku.org/type/ThreadPoolScheduler">ThreadPoolScheduler</a> 是默认调度程序，它维护一个根据需要分配的线程池，根据需要创建新的线程，直到创建调度程序对象时作为参数给出的最大数目（默认值为16）。如果超过最大值 那么 <code>cue</code> 可以对代码进行排队，直到线程变得可用为止。</p>
<p>Rakudo 允许在程序启动时由环境变量 <code>RAKUDO_MAX_THREADS</code> 在默认调度程序中设置允许的最大线程数。</p>
<h3 id="currentthreadscheduler">CurrentThreadScheduler</h3>
<p><a href="https://docs.raku.org/type/CurrentThreadScheduler">CurrentThreadScheduler</a> 是一个非常简单的调度程序，它将始终调度代码在当前线程上立即运行。 暗示这个调度器的 <code>cue</code> 将阻塞，直到代码完成执行，把它的效用限制在某些特殊情况，如测试。</p>
<h3 id="locks">Locks</h3>
<p>类 <a href="https://docs.raku.org/type/Lock">Lock</a> 在并发环境中提供了保护共享数据的低级机制，并因此是高级 API 中支持线程安全性的关键，这在其他编程语言中有时称为 “Mutex”。 因为较高级别的类（<a href="https://docs.raku.org/type/Promise">Promise</a>，<a href="https://docs.raku.org/type/Supply">Supply</a> 和 <a href="https://docs.raku.org/type/Channel">Channel</a>）在需要时使用 <a href="https://docs.raku.org/type/Lock">Lock</a>，所以用户代码不可能直接使用 Lock。</p>
<p><a href="https://docs.raku.org/type/Lock">Lock</a> 的主接口是方法 <a href="https://docs.raku.org/type/Lock#method_protect">protect</a>，它确保一个代码块（通常称为“临界区”）只能在一个线程中同时执行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$lock</span> <span class="o">=</span> <span class="kt">Lock</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">await</span> <span class="p">(</span><span class="o">^</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">start</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$lock</span><span class="o">.</span><span class="nb">protect</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">                <span class="k">my</span> <span class="nv">$r</span> <span class="o">=</span> <span class="nb">rand</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="nb">sleep</span> <span class="nv">$r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="nv">$a</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1"># 10</span>
</span></span></code></pre></div><p><code>protect</code> 返回代码块返回任何东西。</p>
<p>因为 <code>protect</code> 将阻止任何等着要执行临界区的线程，所以代码应该尽可能快。</p>
<h2 id="safety-concerns">Safety Concerns</h2>
<p>一些共享数据并发问题相比其他问题并不明显。 关于这个问题的好文章请看这个<a href="https://6guts.wordpress.com/2014/04/17/racing-to-writeness-to-wrongness-leads/">博客</a>。</p>
<p>要注意的一个特别的问题是当容器自动更新或发生扩展时。 当<a href="https://docs.raku.org/type/Array">数组</a>或<a href="https://docs.raku.org/type/Hash">哈希</a>条目被赋初始值时，底层结构被更改，并且那个操作不是异步安全的。 例如，在这段代码中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$slot</span> <span class="o">:=</span> <span class="nv">@array</span><span class="o">[</span><span class="mi">20</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$slot</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;;</span>
</span></span></code></pre></div><p>第三行是临界区，因为那就是数组被扩展之时。 最简单的解决方法是使用 <code>&lt;Lock&gt;</code> 来保护临界区。 一个可能更好的解决方案是重构代码，以使共享容器不是必需的。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[命令行接口]]></title>
            <link href="http://localhost:1313/rakulang/14.command-line-interface/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/13.classes-and-objects/?utm_source=atom_feed" rel="related" type="text/html" title="类和对象" />
                <link href="http://localhost:1313/rakulang/12.ruby-to-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Ruby 到 Raku" />
                <link href="http://localhost:1313/rakulang/11.python-to-perl6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Python 到 Raku - 简而言之" />
                <link href="http://localhost:1313/rakulang/9.haskell-to-perl-6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Haskell 到 Raku - 简而言之" />
                <link href="http://localhost:1313/rakulang/10.javascript-node.js-to-perl-6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Javascript(Node.js) 到 Raku - 简而言之" />
            
                <id>http://localhost:1313/rakulang/14.command-line-interface/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-20T21:13:31+08:00</published>
            <updated>2018-10-20T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h2 id="命令行接口---概述">命令行接口 - 概述</h2>
<p>Raku 脚本的默认命令行界面由三部分组成：</p>
<h3 id="将命令行参数解析为捕获">将命令行参数解析为捕获</h3>
<p>这将查看 <a href="https://docs.raku.org/language/variables#index-entry-%40%2AARGS">@*ARGS</a> 中的值，根据某些策略解释这些值，并创建一个 <code>Capture</code> 对象。解析器的替代方式可以由开发者提供或使用模块安装。</p>
<h3 id="使用该捕获调用提供的main子例程">使用该捕获调用提供的MAIN子例程</h3>
<p>标准多<a href="https://docs.raku.org/language/functions#index-entry-declarator_multi-Multi-dispatch">分重分派</a>用于使用生成的 <code>Capture</code> 对象调用 MAIN 子例程。这意味着您的 MAIN子 例程可能是一个 <code>multi sub</code>，其中每个候选程序负责处理给定命令行参数的某些部分。</p>
<h3 id="如果调用-main-失败则创建显示使用信息">如果调用 MAIN 失败，则创建/显示使用信息</h3>
<p>如果多重分派失败，则应尽可能通知脚本的用户失败的原因。默认情况下，这是通过检查每个 MAIN 候选 sub 的签名以及任何关联的 pod 信息来完成的。然后在 STDERR 上向用户显示结果（如果指定了 <code>--help</code>，则在 STDOUT 上显示）。生成使用信息的替代方式可以由开发者提供或使用模块安装。</p>
<h2 id="sub-main">sub MAIN</h2>
<p>在运行所有相关的输入phasers（<code>BEGIN</code>，<code>CHECK</code>，<code>INIT</code>，<code>PRE</code>，<code>ENTER</code>）并执行脚本的主线之后，将执行具有特殊名称 MAIN 的子程序。如果没有 MAIN sub，则不会发生错误：您的脚本只需要在脚本的主线中执行工作，例如参数解析。</p>
<p>从 MAIN sub 的任何正常退出将导致退出代码为 <code>0</code>，表示成功。 MAIN 子的任何返回值都将被忽略。如果抛出未在 MAIN 子内部处理的异常，则退出代码将为 <code>1</code>。如果调度到 <code>MAIN</code> 失败，则在 STDERR 上将显示一条用法消息，退出代码将为 2。</p>
<p>命令行参数存在于 <code>@*ARGS</code> 动态变量中，并且可以在调用 MAIN 单元之前在脚本的主线中进行更改。</p>
<p>（多个子 MAIN 的候选者）的签名确定使用标准<a href="https://docs.raku.org/language/glossary#index-entry-Multi-Dispatch">多重分派</a>语义实际调用哪个候选者。</p>
<p>一个简单的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># inside file &#39;hello.p6&#39; </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello </span><span class="nv">$name</span><span class="s2">, how are you?</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果您调用该脚本没有任何参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ raku hello.p6
</span></span><span class="line"><span class="cl">Usage:
</span></span><span class="line"><span class="cl">  hello.p6 &lt;name&gt;
</span></span></code></pre></div><p>但是，如果为参数指定默认值，则无论是否指定名称，运行脚本始终有效：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># inside file &#39;hello.p6&#39; </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">bashful</span><span class="p">&#39;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello </span><span class="nv">$name</span><span class="s2">, how are you?</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ raku hello.p6
</span></span><span class="line"><span class="cl">Hello bashful, how are you?
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ raku hello.p6 Liz
</span></span><span class="line"><span class="cl">Hello Liz, how are you?
</span></span></code></pre></div><p>另一种方法是使 <code>sub MAIN</code> 成为一个 <code>multi sub</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># inside file &#39;hello.p6&#39; </span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">()</span>      <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello bashful, how are you?</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello </span><span class="nv">$name</span><span class="s2">, how are you?</span><span class="p">&#34;</span>   <span class="p">}</span>
</span></span></code></pre></div><p>这将提供与上述示例相同的输出。您是否应该使用任何一种方法来实现预期目标完全取决于您。</p>
<p>使用单个位置和多个命名参数的更复杂的示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># inside &#34;frobnicate.p6&#34; </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="kt">Str</span>   <span class="nv">$file</span> <span class="k">where</span> <span class="o">*.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">f</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">file.dat</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="kt">Int</span>  <span class="o">:</span><span class="nv">$length</span> <span class="o">=</span> <span class="mi">24</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="kt">Bool</span> <span class="o">:</span><span class="nv">$verbose</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$length</span> <span class="k">if</span> <span class="nv">$length</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$file</span>   <span class="k">if</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Verbosity </span><span class="p">&#39;</span><span class="o">,</span> <span class="p">(</span><span class="nv">$verbose</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">on</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">off</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>有了 <code>file.dat</code>，这将以这种方式工作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ raku frobnicate.p6
</span></span><span class="line"><span class="cl"><span class="m">24</span>
</span></span><span class="line"><span class="cl">file.dat
</span></span><span class="line"><span class="cl">Verbosity off
</span></span></code></pre></div><p>或者这样 <code>--verbose</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ raku frobnicate.p6 --verbose
</span></span><span class="line"><span class="cl"><span class="m">24</span>
</span></span><span class="line"><span class="cl">file.dat
</span></span><span class="line"><span class="cl">Verbosity on
</span></span></code></pre></div><p>如果文件 <code>file.dat</code> 不存在，或者您指定了另一个不存在的文件名，您将获得从 <code>MAIN</code> 子的内省创建的标准用法消息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ raku frobnicate.p6 doesntexist.dat
</span></span><span class="line"><span class="cl">Usage:
</span></span><span class="line"><span class="cl">  frobnicate.p6 <span class="o">[</span>--length<span class="o">=</span>&lt;Int&gt;<span class="o">]</span> <span class="o">[</span>--verbose<span class="o">]</span> <span class="o">[</span>&lt;file&gt;<span class="o">]</span>
</span></span></code></pre></div><p>虽然您不必在代码中执行任何操作，但它仍然可能被视为有点简洁。但是通过使用 pod 功能提供提示，有一种简单的方法可以更好地使用该消息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># inside &#34;frobnicate.p6&#34; </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="kt">Str</span>   <span class="nv">$file</span> <span class="k">where</span> <span class="o">*.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">f</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">file.dat</span><span class="p">&#39;</span><span class="o">,</span>  <span class="k">#= </span><span class="sd">an existing file to frobnicate 
</span></span></span><span class="line"><span class="cl"><span class="sd"></span>  <span class="kt">Int</span>  <span class="o">:</span><span class="nv">$length</span> <span class="o">=</span> <span class="mi">24</span><span class="o">,</span>                     <span class="k">#= </span><span class="sd">length needed for frobnication 
</span></span></span><span class="line"><span class="cl"><span class="sd"></span>  <span class="kt">Bool</span> <span class="o">:</span><span class="nv">$verbose</span><span class="o">,</span>                         <span class="k">#= </span><span class="sd">required verbosity 
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$length</span> <span class="k">if</span> <span class="nv">$length</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$file</span>   <span class="k">if</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Verbosity </span><span class="p">&#39;</span><span class="o">,</span> <span class="p">(</span><span class="nv">$verbose</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">on</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">off</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>哪个会改善这样的用法消息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ raku frobnicate.p6 doesntexist.dat
</span></span><span class="line"><span class="cl">Usage:
</span></span><span class="line"><span class="cl">  frobnicate.p6 <span class="o">[</span>--length<span class="o">=</span>&lt;Int&gt;<span class="o">]</span> <span class="o">[</span>--verbose<span class="o">]</span> <span class="o">[</span>&lt;file&gt;<span class="o">]</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="o">[</span>&lt;file&gt;<span class="o">]</span>          an existing file to frobnicate
</span></span><span class="line"><span class="cl">    --length<span class="o">=</span>&lt;Int&gt;    length needed <span class="k">for</span> frobnication
</span></span><span class="line"><span class="cl">    --verbose         required verbosity
</span></span></code></pre></div><h2 id="sub-main-opts">%*SUB-MAIN-OPTS</h2>
<p>通过设置 <code>%*SUB-MAIN-OPTS</code> 哈希中的选项，可以在将参数传递给 <code>sub MAIN {}</code> 之前更改参数的处理方式。由于动态变量的性质，需要设置 <code>%*SUB-MAIN-OPTS</code> 哈希并使用适当的设置填充它。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="vg">%*SUB-MAIN-OPTS</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="p">:</span><span class="s">named-anywhere</span><span class="o">,</span>    <span class="c1"># allow named variables at any location </span>
</span></span><span class="line"><span class="cl">  <span class="c1"># other possible future options / custom options </span>
</span></span><span class="line"><span class="cl"><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="o">,</span> <span class="o">:</span><span class="nv">$c</span><span class="o">,</span> <span class="o">:</span><span class="nv">$d</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Accepted!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可用选项包括：</p>
<h3 id="named-anywhere">named-anywhere</h3>
<p>默认情况下，传递给程序的命名参数（即 <code>MAIN</code>）在任何位置参数后都不会出现。但是，如果将 <code>%*SUB-MAIN-OPTS&lt;named-anywhere&gt;</code> 设置为 true 值，则可以在任何位置指定命名参数，即使在位置参数之后也是如此。例如，可以使用以下命令调用上述程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ raku example.p6 <span class="m">1</span> --c<span class="o">=</span><span class="m">2</span> <span class="m">3</span> --d<span class="o">=</span><span class="m">4</span>
</span></span></code></pre></div><h3 id="is-hidden-from-usage">is hidden-from-USAGE</h3>
<p>有时您希望排除MAIN候选者显示在任何自动生成的使用消息中。这可以通过向您不想显示的 MAIN 候选者的规范添加 <code>hidden-from-USAGE</code> 特征来实现。扩展前面的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># inside file &#39;hello.p6&#39; </span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">()</span> <span class="k">is</span> <span class="nc">hidden-from-USAGE</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello bashful, how are you?</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>  <span class="k">#= </span><span class="sd">the name by which you would like to be called 
</span></span></span><span class="line"><span class="cl"><span class="sd"></span>    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello </span><span class="nv">$name</span><span class="s2">, how are you?</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>因此，如果您只使用命名变量调用此脚本，您将获得以下用法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="nb">raku</span> <span class="n">hello</span><span class="o">.</span><span class="nf">p6</span> <span class="o">--</span><span class="nf">verbose</span>
</span></span><span class="line"><span class="cl"><span class="n">Usage:</span>
</span></span><span class="line"><span class="cl">  <span class="n">hello</span><span class="o">.</span><span class="nf">p6</span> <span class="o">&lt;</span><span class="nb">name</span><span class="o">&gt;</span> <span class="o">--</span> <span class="n">the</span> <span class="nb">name</span> <span class="n">by</span> <span class="n">which</span> <span class="n">you</span> <span class="n">would</span> <span class="nb">like</span> <span class="nb">to</span> <span class="n">be</span> <span class="n">called</span>
</span></span></code></pre></div><p>没有第一个候选者 <code>hidden-from-USAGE</code> 特征，它看起来像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="nb">raku</span> <span class="n">hello</span><span class="o">.</span><span class="nf">p6</span> <span class="o">--</span><span class="nf">verbose</span>
</span></span><span class="line"><span class="cl"><span class="n">Usage:</span>
</span></span><span class="line"><span class="cl">  <span class="n">hello</span><span class="o">.</span><span class="nf">p6</span>
</span></span><span class="line"><span class="cl">  <span class="n">hello</span><span class="o">.</span><span class="nf">p6</span> <span class="o">&lt;</span><span class="nb">name</span><span class="o">&gt;</span> <span class="o">--</span> <span class="n">the</span> <span class="nb">name</span> <span class="n">by</span> <span class="n">which</span> <span class="n">you</span> <span class="n">would</span> <span class="nb">like</span> <span class="nb">to</span> <span class="n">be</span> <span class="n">called</span>
</span></span></code></pre></div><p>虽然技术上是正确的，但也不能读。</p>
<h3 id="main-的单位作用域定义">MAIN 的单位作用域定义</h3>
<p>如果整个程序体驻留在 <code>MAIN</code> 中，则可以使用单位声明符，如下所示（调整前面的示例）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">unit</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="kt">Str</span>   <span class="nv">$file</span> <span class="k">where</span> <span class="o">*.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">f</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">file.dat</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="kt">Int</span>  <span class="o">:</span><span class="nv">$length</span> <span class="o">=</span> <span class="mi">24</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="kt">Bool</span> <span class="o">:</span><span class="nv">$verbose</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>  <span class="c1"># &lt;- note semicolon here </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$length</span> <span class="k">if</span> <span class="nv">$length</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$file</span>   <span class="k">if</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Verbosity </span><span class="p">&#39;</span><span class="o">,</span> <span class="p">(</span><span class="nv">$verbose</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">on</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">off</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># rest of script is part of MAIN </span>
</span></span></code></pre></div><p>请注意，这只适用于只有一个（仅）<code>sub MAIN</code> 的情况。</p>
<h2 id="sub-usage">sub USAGE</h2>
<p>如果找不到给定命令行参数的 <code>MAIN</code> 的多候选者，则调用 sub <code>USAGE</code>。如果未找到此类方法，编译器将输出默认用法消息。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">#|</span><span class="p">(</span><span class="sd">is it the answer</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$i</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$i</span> <span class="o">==</span> <span class="mi">42</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">answer</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">dunno</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">#|</span><span class="p">(</span><span class="sd">divide two numbers</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">MAIN</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">){</span> <span class="nb">say</span> <span class="nv">$a</span><span class="o">/</span><span class="nv">$b</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">USAGE</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="k">Q</span><span class="sa">:c:to</span><span class="p">/EOH/;</span><span class="s"> 
</span></span></span><span class="line"><span class="cl"><span class="s">    Usage: </span><span class="p">{</span><span class="vg">$*PROGRAM-NAME</span><span class="p">}</span><span class="s"> [number]
</span></span></span><span class="line"><span class="cl"><span class="s"> 
</span></span></span><span class="line"><span class="cl"><span class="s">    Prints the answer or &#39;dunno&#39;.
</span></span></span><span class="line"><span class="cl"><span class="s"></span><span class="p">EOH</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>通过只读 <code>$*USAGE</code> 变量，sub <code>USAGE</code> 内的默认用法消息可用。它将基于可用的 <code>sub MAIN</code> 候选者及其参数生成。如前所示，您可以使用 <code>#|(...)</code> Pod 块为每个候选项指定其他扩展描述以设置 <a href="https://docs.raku.org/routine/WHY">WHY</a>。</p>
<h2 id="拦截-cli-参数解析201810-v6d-and-later">拦截 CLI 参数解析(2018.10, v6.d and later)</h2>
<p>您可以通过自己提供 <code>ARGS-TO-CAPTURE</code> 子例程，或者从生态系统中可用的任何 <a href="https://modules.raku.org/search/?q=getopt">Getopt</a> 模块中导入一个子例程来替换或扩充参数解析的默认方式。</p>
<h3 id="sub-args-to-capture">sub ARGS-TO-CAPTURE</h3>
<p><code>ARGS-TO-CAPTURE</code> 子程序应该接受两个参数：一个 <a href="https://docs.raku.org/type/Callable">Callable</a> 表示要执行的 <code>MAIN</code> 单元（因此可以在必要时进行内省）和一个带有来自命令行的参数的数组。它应该返回一个将用于调度 <code>MAIN</code> 单元的 <a href="https://docs.raku.org/type/Capture">Capture</a> 对象。一个非常人为的例子，它将根据输入的某个关键字创建一个 <code>Capture</code>（在测试脚本的命令行界面时可以很方便）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">ARGS-TO-CAPTURE</span><span class="p">(</span><span class="nv">&amp;main</span><span class="o">,</span> <span class="nv">@args</span> <span class="k">--&gt;</span> <span class="kt">Capture</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># if we only specified &#34;frobnicate&#34; as an argument </span>
</span></span><span class="line"><span class="cl">    <span class="nv">@args</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nv">@args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">frobnicate</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl">      <span class="c1"># then dispatch as MAIN(&#34;foo&#34;,&#34;bar&#34;,verbose =&gt; 2) </span>
</span></span><span class="line"><span class="cl">      <span class="o">??</span> <span class="kt">Capture</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">list</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="s">foo bar</span><span class="p">&gt;</span><span class="o">,</span> <span class="s">hash</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="s">verbose</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="c1"># otherwise, use default processing of args </span>
</span></span><span class="line"><span class="cl">      <span class="o">!!</span> <span class="vg">&amp;*ARGS-TO-CAPTURE</span><span class="p">(</span><span class="nv">&amp;main</span><span class="o">,</span> <span class="nv">@args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>请注意，动态变量 <a href="https://docs.raku.org/language/variables#%26%2AARGS-TO-CAPTURE">&amp;*ARGS-TO-CAPTURE</a> 可用于执行捕获处理的默认命令行参数，因此如果您不想，则不必重新发明整个轮子。</p>
<h3 id="拦截使用消息生成201810v6d及更高版本">拦截使用消息生成（2018.10，v6.d及更高版本）</h3>
<p>您可以通过自己提供 <code>GENERATE-USAGE</code> 子例程，或者从生态系统中可用的任何 <a href="https://modules.raku.org/search/?q=getopt">Getopt</a> 模块导入一个子例程来替换或扩充默认的使用方式消息生成方式（在向 MAIN 发送失败之后）。</p>
<h4 id="sub-run-main">sub RUN-MAIN</h4>
<p>定义为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">RUN-MAIN</span><span class="p">(</span><span class="nv">&amp;main</span><span class="o">,</span> <span class="nv">$mainline</span><span class="o">,</span> <span class="o">:</span><span class="nv">$in-as-argsfiles</span><span class="p">)</span>
</span></span></code></pre></div><p>该程序允许完全控制 <code>MAIN</code> 的处理。它得到一个 <code>Callable</code>，它是应该执行的 <code>MAIN</code>，主线执行的返回值和其他命名变量:: <code>in-as-argsfiles</code> 如果 STDIN 应该被视为 <code>$*ARGFILES</code>，它将为 <code>True</code>。</p>
<p>如果未提供 <code>RUN-MAIN</code>，将运行默认的 <code>RUN-MAIN</code> 以查找旧接口的子例程，例如 <code>MAIN_HELPER</code> 和 <code>USAGE</code>。如果找到，将执行“旧”语义。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Hero</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">@!inventory</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Str</span> <span class="nv">$.name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(</span> <span class="o">:</span><span class="nv">$name</span><span class="o">,</span> <span class="o">:</span><span class="nv">@inventory</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!name</span> <span class="o">=</span> <span class="nv">$name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">@!inventory</span> <span class="o">=</span> <span class="nv">@inventory</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">new-main</span><span class="p">(</span><span class="nv">$name</span><span class="o">,</span> <span class="o">*</span><span class="nv">@stuff</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Hero</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">inventory</span><span class="p">(</span><span class="nv">@stuff</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="nb">perl</span><span class="o">.</span><span class="nb">say</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">RUN-MAIN</span><span class="p">(</span> <span class="nv">&amp;new-main</span><span class="o">,</span> <span class="kt">Nil</span> <span class="p">);</span>
</span></span></code></pre></div><p>这将打印生成的对象的名称（第一个参数）。</p>
<h3 id="sub-generate-usage">sub GENERATE-USAGE</h3>
<p><code>GENERATE-USAGE</code> 子例程应该接受一个 <code>Callable</code>，表示由于调度失败而未执行的 <code>MAIN</code> 子例程。这可以用于内省。所有其他参数都是设置为发送到MAIN的参数。它应该返回您想要显示给用户的使用信息的字符串。这个例子只是重新创建从处理参数创建的 <code>Capture</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">GENERATE-USAGE</span><span class="p">(</span><span class="nv">&amp;main</span><span class="o">,</span> <span class="o">|</span><span class="nb">capture</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">capture</span><span class="p">&lt;</span><span class="s">foo</span><span class="p">&gt;:</span><span class="s">exists</span>
</span></span><span class="line"><span class="cl">      <span class="o">??</span> <span class="p">&#34;</span><span class="s2">You&#39;re not allowed to specify a --foo</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="o">!!</span> <span class="vg">&amp;*GENERATE-USAGE</span><span class="p">(</span><span class="nv">&amp;main</span><span class="o">,</span> <span class="o">|</span><span class="nb">capture</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>您还可以使用 multi 子例程来创建相同的效果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">GENERATE-USAGE</span><span class="p">(</span><span class="nv">&amp;main</span><span class="o">,</span> <span class="o">:</span><span class="nv">$foo</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">&#34;</span><span class="s2">You&#39;re not allowed to specify a --foo</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">GENERATE-USAGE</span><span class="p">(</span><span class="nv">&amp;main</span><span class="o">,</span> <span class="o">|</span><span class="nb">capture</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="vg">&amp;*GENERATE-USAGE</span><span class="p">(</span><span class="nv">&amp;main</span><span class="o">,</span> <span class="o">|</span><span class="nb">capture</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>请注意，动态变量 <a href="https://docs.raku.org/language/variables#%26%2AGENERATE-USAGE"><code>&amp;*GENERATE-USAGE</code></a> 可用于执行默认使用消息生成，因此您不必重新发明整个轮子。</p>
<h3 id="拦截-main-调用201810之前v6e">拦截 MAIN 调用（2018.10之前，v6.e）</h3>
<p>较旧的接口使得一个接口完全拦截对 <code>MAIN</code> 的调用。这取决于是否存在 <code>MAIN_HELPER</code> 子程序，如果在程序的主线中找到 <code>MAIN</code> 子程序，则该子程序将被调用。</p>
<p>此接口从未记录过。但是，使用此未记录的界面的任何程序将继续运行，直到 <code>v6.e</code>。从 <code>v6.d</code> 开始，使用未记录的 API 将导致 <code>DEPRECATED</code> 消息。</p>
<p>生态系统模块可以提供新旧接口，以便与旧版本的 Raku 兼容：如果较新的 Raku 识别出新的（记录的）接口，它将使用它。如果没有可用的新接口子例程，但旧的 <code>MAIN_HELPER</code> 接口是，那么它将使用旧接口。</p>
<p>如果模块开发人员决定仅为 <code>v6.d</code> 或更高版本提供模块，则可以从模块中删除对旧接口的支持。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[类和对象]]></title>
            <link href="http://localhost:1313/rakulang/13.classes-and-objects/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/12.ruby-to-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Ruby 到 Raku" />
                <link href="http://localhost:1313/rakulang/11.python-to-perl6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Python 到 Raku - 简而言之" />
                <link href="http://localhost:1313/rakulang/9.haskell-to-perl-6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Haskell 到 Raku - 简而言之" />
                <link href="http://localhost:1313/rakulang/10.javascript-node.js-to-perl-6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Javascript(Node.js) 到 Raku - 简而言之" />
                <link href="http://localhost:1313/rakulang/8.perl-5-to-perl-6-guide---special-variables/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 特殊变量" />
            
                <id>http://localhost:1313/rakulang/13.classes-and-objects/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-19T21:13:31+08:00</published>
            <updated>2018-10-19T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>Raku 有一个丰富的内置语法来定义和使用类。</p>
<p>默认构造函数允许为创建的对象设置属性:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Int</span> <span class="nv">$.x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Int</span> <span class="nv">$.y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Rectangle</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="n">Point</span> <span class="nv">$.lower</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="n">Point</span> <span class="nv">$.upper</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">area</span><span class="p">()</span> <span class="k">returns</span> <span class="kt">Int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="nv">$!upper</span><span class="o">.</span><span class="nb">x</span> <span class="o">-</span> <span class="nv">$!lower</span><span class="o">.</span><span class="nb">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span> <span class="nv">$!upper</span><span class="o">.</span><span class="nf">y</span> <span class="o">-</span> <span class="nv">$!lower</span><span class="o">.</span><span class="nf">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Create a new Rectangle from two Points </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$r</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">lower</span> <span class="o">=&gt;</span> <span class="n">Point</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="s">y</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">,</span> <span class="s">upper</span> <span class="o">=&gt;</span> <span class="n">Point</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="o">,</span> <span class="s">y</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$r</span><span class="o">.</span><span class="nf">area</span><span class="p">();</span> <span class="c1"># OUTPUT: «100␤» </span>
</span></span></code></pre></div><p>您也可以提供自己的构建和构建实现。下面更详细的例子展示了 Raku 中依赖处理器的外观。它展示了自定义构造函数，私有属性和公共属性，方法以及签名的各个方面。它代码不多，但结果是有趣和有用的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Task</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span>      <span class="nv">&amp;!callback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="n">Task</span> <span class="nv">@!dependencies</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Bool</span> <span class="nv">$.done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="c1"># Normally doesn&#39;t need to be written </span>
</span></span><span class="line"><span class="cl">    <span class="c1"># BUILD is the equivalent of a constructor in other languages </span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span><span class="nv">&amp;callback</span><span class="o">,</span> <span class="o">*</span><span class="nv">@dependencies</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span><span class="o">:</span><span class="nv">&amp;callback</span><span class="o">,</span> <span class="o">:</span><span class="nv">@dependencies</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(</span><span class="o">:</span><span class="nv">&amp;!callback</span><span class="o">,</span> <span class="o">:</span><span class="nv">@!dependencies</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">add-dependency</span><span class="p">(</span><span class="n">Task</span> <span class="nv">$dependency</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">push</span> <span class="nv">@!dependencies</span><span class="o">,</span> <span class="nv">$dependency</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">perform</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">unless</span> <span class="nv">$!done</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="nf">perform</span><span class="p">()</span> <span class="k">for</span> <span class="nv">@!dependencies</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">&amp;!callback</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$!done</span> <span class="o">=</span> <span class="kt">True</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$eat</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">Task</span><span class="o">.</span><span class="nb">new</span><span class="p">({</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">eating dinner. NOM!</span><span class="p">&#39;</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">Task</span><span class="o">.</span><span class="nb">new</span><span class="p">({</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">making dinner</span><span class="p">&#39;</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">Task</span><span class="o">.</span><span class="nb">new</span><span class="p">({</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">buying food</span><span class="p">&#39;</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">Task</span><span class="o">.</span><span class="nb">new</span><span class="p">({</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">making some money</span><span class="p">&#39;</span> <span class="p">})</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">Task</span><span class="o">.</span><span class="nb">new</span><span class="p">({</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">going to the store</span><span class="p">&#39;</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">            <span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">Task</span><span class="o">.</span><span class="nb">new</span><span class="p">({</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">cleaning kitchen</span><span class="p">&#39;</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nv">$eat</span><span class="o">.</span><span class="nf">perform</span><span class="p">();</span>
</span></span></code></pre></div><h2 id="从类开始">从类开始</h2>
<p>和许多其他语言一样，Raku 使用 <code>class</code> 关键字来定义一个类。接下来的块可能包含任意代码，就像其他块一样，但类通常包含状态和行为声明。示例代码包括通过 <code>has</code> 关键字引入的属性(状态)以及通过 <code>method</code> 关键字引入的行为。</p>
<p>声明一个类会创建一个新的<em>类型对象</em>，默认情况下，它将被安装到当前包中(就像使用 <code>our</code> 作用域声明的变量一样)。此类型对象是类的“空实例”。例如，<code>Int</code> 和 <code>Str</code> 等类型引用 Raku 内置类之一的类型对象。上面的示例使用类名称 <code>Task</code>，以便其他代码稍后可以引用它，例如通过调用 <code>new</code> 方法来创建类实例。</p>
<p>您可以使用 <code>.DEFINITE</code> 方法来确定你拥有的是实例还是类型对象:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="kt">Int</span><span class="o">.</span><span class="nb">DEFINITE</span><span class="p">;</span> <span class="c1"># OUTPUT: «False␤» (type object) </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">426</span><span class="o">.</span><span class="nb">DEFINITE</span><span class="p">;</span> <span class="c1"># OUTPUT: «True␤»  (instance) </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Foo</span><span class="o">.</span><span class="nb">DEFINITE</span><span class="p">;</span>     <span class="c1"># OUTPUT: «False␤» (type object) </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Foo</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nb">DEFINITE</span><span class="p">;</span> <span class="c1"># OUTPUT: «True␤»  (instance) </span>
</span></span></code></pre></div><p>你还可以使用类型表情符号来仅接受实例或类型对象:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">foo</span> <span class="p">(</span><span class="kt">Int:U</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">It&#39;s a type object!</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">foo</span> <span class="p">(</span><span class="kt">Int:D</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">It&#39;s an instance!</span><span class="p">&#34;</span>   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">foo</span> <span class="kt">Int</span><span class="p">;</span> <span class="c1"># OUTPUT: «It&#39;s a type object!␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">foo</span> <span class="mi">42</span><span class="p">;</span>  <span class="c1"># OUTPUT: «It&#39;s an instance!␤» </span>
</span></span></code></pre></div><h2 id="状态">状态</h2>
<p>类块中的前三行声明所有属性(在其他语言中称为字段或实例存储)。就像 <code>my</code> 变量不能从其声明的作用域之外访问一样，属性不能在类的外面访问。这种封装是面向对象设计的关键原则之一。</p>
<p>第一个声明指定回调的实例存储 - 为执行对象表示的任务而调用的一些代码:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">has</span> <span class="nv">&amp;!callback</span><span class="p">;</span>
</span></span></code></pre></div><p><code>&amp;</code> sigil 表示该属性代表可调用的内容。 <code>!</code> 字符是一个 <em>twigil</em>，或 <em>secondary sigil</em>。twigil 组成变量名称的一部分。在这种情况下，<code>!</code> twigil 强调，这个属性对类是私有的。</p>
<p>第二个声明也使用私有 twigil:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">has</span> <span class="n">Task</span> <span class="nv">@!dependencies</span><span class="p">;</span>
</span></span></code></pre></div><p>然而，这个属性表示一个项目的数组，所以它需要 <code>@</code> sigil。这些项目分别指定一个任务，在完成之前必须先完成这些任务。而且，这个属性的类型声明表明该数组只能包含 <code>Task</code> 类的实例(或者它的某个子类)。</p>
<p>第三个属性表示任务完成的状态:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">has</span> <span class="kt">Bool</span> <span class="nv">$.done</span><span class="p">;</span>
</span></span></code></pre></div><p>这个标量属性(带有 <code>$</code> sigil)有一个 <code>Bool</code> 类型。而不是 <code>!</code> twigil，使用 <code>.</code> twigil。尽管 Raku 确实对属性进行了封装，但它也可以避免编写访问器方法。替换！与。都声明属性 $!done 和一个名为 done 的访问器方法。就好像你写了:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">has</span> <span class="kt">Bool</span> <span class="nv">$!done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">method</span> <span class="nb">done</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nv">$!done</span> <span class="p">}</span>
</span></span></code></pre></div><p>请注意，这不像某些语言允许的那样声明公共属性;你真的得到了一个私有属性和一个方法，而无需手动编写该方法。你可以自由地编写自己的访问器方法，如果你将来需要做一些比返回值更复杂的事情。</p>
<p>请注意，使用。 twigil创建了一个方法，将提供对该属性的只读访问权限。如果该对象的用户应该能够重置任务的完成状态(也许再次执行)，则可以更改属性声明:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">has</span> <span class="kt">Bool</span> <span class="nv">$.done</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span></code></pre></div><p>rw特征会导致生成的访问器方法返回一些外部代码可以修改的内容以更改该属性的值。</p>
<p>您还可以为属性提供默认值(对于有和没有访问者的情况，这些默认值同样适用):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">has</span> <span class="kt">Bool</span> <span class="nv">$.done</span> <span class="o">=</span> <span class="kt">False</span><span class="p">;</span>
</span></span></code></pre></div><p>分配是在对象构建时进行的。此时评估右侧，甚至可以引用早期的属性:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">has</span> <span class="n">Task</span> <span class="nv">@!dependencies</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">has</span> <span class="nv">$.ready</span> <span class="o">=</span> <span class="nb">not</span> <span class="nv">@!dependencies</span><span class="p">;</span>
</span></span></code></pre></div><h2 id="静态字段">静态字段?</h2>
<p>Raku 没有静态关键字。尽管如此，任何类都可以声明模块可以做的任何事情，所以使范围变量听起来像是个好主意。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Singleton</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="n">Singleton</span> <span class="nv">$instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">new</span> <span class="p">{</span><span class="o">!!!</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">submethod</span> <span class="n">instance</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$instance</span> <span class="o">=</span> <span class="n">Singleton</span><span class="o">.</span><span class="nb">bless</span> <span class="k">unless</span> <span class="nv">$instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span></code></pre></div><p>由我或我们定义的类属性也可以在声明时初始化，但是我们在这里实现Singleton模式，并且必须在第一次使用时创建对象。预测执行属性初始化的时刻不是100％，因为它可以在编译，运行时或两者期间发生，尤其是在使用use关键字导入类时。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">HaveStaticAttr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">my</span> <span class="n">Foo</span> <span class="nv">$.foo</span> <span class="o">=</span> <span class="n">some_complicated_subroutine</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>类属性也可以用辅助sigil声明 - 以类似于对象属性的方式 - 如果属性将被公开，将生成只读访问器。</p>
<h2 id="方法">方法</h2>
<p>虽然属性赋予对象状态，但方法赋予对象行为。我们暂时忽略新方法;这是一种特殊的方法。考虑第二种方法add-dependency，它将一项新任务添加到任务的依赖列表中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">method</span> <span class="nf">add-dependency</span><span class="p">(</span><span class="n">Task</span> <span class="nv">$dependency</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">push</span> <span class="nv">@!dependencies</span><span class="o">,</span> <span class="nv">$dependency</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在许多方面，这看起来很像一个子声明。但是，有两个重要的区别。首先，将此例程声明为方法将其添加到当前类的方法列表中，因此Task类的任何实例都可以使用它调用它。方法调用操作符。其次，一种方法将其调用者放入特殊变量 <code>self</code> 中。</p>
<p>该方法本身将传入的参数(它必须是Task类的一个实例)并将其推送到invocant的@！dependencies属性上。</p>
<p>执行方法包含依赖性处理程序的主要逻辑:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">method</span> <span class="nf">perform</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">unless</span> <span class="nv">$!done</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="nf">perform</span><span class="p">()</span> <span class="k">for</span> <span class="nv">@!dependencies</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">&amp;!callback</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!done</span> <span class="o">=</span> <span class="kt">True</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>它不需要参数，而是使用对象的属性。首先，通过检查$！done属性来检查任务是否已经完成。如果是这样，那就没有什么可做的了。</p>
<p>否则，该方法执行所有任务的依赖关系，使用 <code>for</code> 构造遍历 <code>@!dependencies</code> 属性中的所有项。此迭代将每个项目(每个项目都放置一个Task对象)放入主题变量 <code>$_</code> 中。使用 。方法调用操作符而不指定明确的调用者将当前主题用作调用者。因此，迭代构造对当前调用者的 <code>@!dependencies</code> 属性中的每个Task对象调用 <code>.perform()</code> 方法。</p>
<p>在所有的依赖关系完成之后，通过直接调用 <code>&amp;!</code> 回调属性来执行当前任务的任务。这是括号的目的。最后，该方法将 <code>$!done</code> 属性设置为 <code>True</code>，以便后续对该对象执行的调用(例如，如果此 Task 是另一个 Task 的依赖项)将不会重复该任务。</p>
<h2 id="私有方法">私有方法</h2>
<p>就像属性一样，方法也可以是私有的。私有方法声明带有前缀感叹号。他们被称为 <code>self!</code>, 随后是方法的名称。要调用另一个类的私有方法，调用类必须被调用类信任。信任关系是用信任声明的，而且要信任的类必须已经声明。调用另一个类的私有方法需要该类的实例和该方法的全限定名称。信任也允许访问私有属性</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">trusts</span> <span class="n">B</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!hidden</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">invisible</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">!not-yours</span> <span class="p">()</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">hidden</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">yours-to-use</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$!hidden</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">self</span><span class="o">!</span><span class="ow">not</span><span class="o">-</span><span class="nf">yours</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">i-am-trusted</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="n">C</span> <span class="nv">$c</span><span class="o">.=</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$c</span><span class="o">!</span><span class="nf">C::not-yours</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">yours-to-use</span><span class="p">();</span> <span class="c1"># the context of this call is GLOBAL, and not trusted by C </span>
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">i-am-trusted</span><span class="p">();</span>
</span></span></code></pre></div><p>信任关系不受继承。要信任全局名称空间，可以使用伪包GLOBAL。</p>
<h2 id="构造函数">构造函数</h2>
<p>Raku比构造函数领域的许多语言更自由。构造函数是任何返回类实例的东西。而且，构造函数是普通的方法。您从基类 <code>Mu</code> 继承了一个名为 <code>new</code> 的默认构造函数，但您可以自由覆盖 <code>new</code>，如下例所示:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">method</span> <span class="nb">new</span><span class="p">(</span><span class="nv">&amp;callback</span><span class="o">,</span> <span class="o">*</span><span class="nv">@dependencies</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span><span class="o">:</span><span class="nv">&amp;callback</span><span class="o">,</span> <span class="o">:</span><span class="nv">@dependencies</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Raku 中的构造函数和 <code>C#</code> 和 <code>Java</code> 等语言中的构造函数最大的不同之处在于，它不是以某种方式为已经神奇创建的对象设置状态，而是由 Raku 构造函数自己创建对象。最简单的方法是调用也是从Mu继承的祝福方法。 <code>bless</code> 方法期望一组命名参数为每个属性提供初始值。</p>
<p>该示例的构造函数将位置参数转换为命名参数，以便该类可以为其用户提供一个很好的构造函数。第一个参数是回调(将执行任务的东西)。其余参数是相关的 Task 实例。构造函数将这些捕获到 <code>@dependencies</code> slurpy 数组中，并将它们作为命名参数传递给bless(注意: <code>&amp;callback</code> 使用变量的名称 - 减去 sigil  - 作为参数的名称)。</p>
<p>私有属性确实是私有的。这意味着 <code>bless</code> 不允许直接将事物绑定到 <code>&amp;!callback</code> 和 <code>@!</code> 依赖关系。为了做到这一点，我们重写 <code>BUILD</code> 子方法，这是通过 <code>bless</code> 在全新对象上调用的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(</span><span class="o">:</span><span class="nv">&amp;!callback</span><span class="o">,</span> <span class="o">:</span><span class="nv">@!dependencies</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></div><p>由于 <code>BUILD</code> 在新创建的 Task 对象的上下文中运行，因此可以操作这些私有属性。这里的技巧是使用私有属性( <code>&amp;!callback</code> 和 <code>@!</code> 依赖项)作为 <code>BUILD</code> 参数的绑定目标。零样板初始化！查看对象获取更多信息。</p>
<p>BUILD方法负责初始化所有属性，还必须处理默认值:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">has</span> <span class="nv">&amp;!callback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">has</span> <span class="nv">@!dependencies</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">has</span> <span class="kt">Bool</span> <span class="p">(</span><span class="nv">$.done</span><span class="o">,</span> <span class="nv">$.ready</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span><span class="nv">&amp;!callback</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span><span class="nv">@!dependencies</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span><span class="nv">$!done</span> <span class="o">=</span> <span class="kt">False</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span><span class="nv">$!ready</span> <span class="o">=</span> <span class="nb">not</span> <span class="nv">@!dependencies</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></div><p>请参阅对象构造以获取更多影响对象构造和属性初始化的选项。</p>
<h2 id="消费我们的类">消费我们的类</h2>
<p>创建一个类后，您可以创建该类的实例。声明一个自定义构造函数提供了一种简单的方式来声明任务及其依赖关系。要创建没有依赖关系的单个任务，请写下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$eat</span> <span class="o">=</span> <span class="n">Task</span><span class="o">.</span><span class="nb">new</span><span class="p">({</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">eating dinner. NOM!</span><span class="p">&#39;</span> <span class="p">});</span>
</span></span></code></pre></div><p>前面的章节解释说，声明类Task在命名空间中安装了一个类型对象。这个类型对象是类的一个“空实例”，特别是没有任何状态的实例。您可以调用该实例的方法，只要它们不尝试访问任何状态;新是一个例子，因为它创建了一个新对象，而不是修改或访问现有对象。</p>
<p>不幸的是，晚餐从未奇迹般地发生。它有依赖任务:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$eat</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">Task</span><span class="o">.</span><span class="nb">new</span><span class="p">({</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">eating dinner. NOM!</span><span class="p">&#39;</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">Task</span><span class="o">.</span><span class="nb">new</span><span class="p">({</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">making dinner</span><span class="p">&#39;</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">Task</span><span class="o">.</span><span class="nb">new</span><span class="p">({</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">buying food</span><span class="p">&#39;</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">Task</span><span class="o">.</span><span class="nb">new</span><span class="p">({</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">making some money</span><span class="p">&#39;</span> <span class="p">})</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">Task</span><span class="o">.</span><span class="nb">new</span><span class="p">({</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">going to the store</span><span class="p">&#39;</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">            <span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">Task</span><span class="o">.</span><span class="nb">new</span><span class="p">({</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">cleaning kitchen</span><span class="p">&#39;</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span></code></pre></div><p>注意自定义构造函数和明智的空白使用如何清除任务依赖关系。</p>
<p>最后，<code>perform</code> 方法调用按顺序递归调用各种其他依赖项上的 <code>perform</code> 方法，并给出以下输出:</p>
<pre tabindex="0"><code>making some money
going to the store
buying food
cleaning kitchen
making dinner
eating dinner. NOM!
</code></pre><h2 id="继承">继承</h2>
<p>面向对象编程提供了继承的概念，作为代码重用的机制之一。 Raku 支持一个类从一个或多个类继承的能力。当一个类从另一个类继承时，它会通知方法调度器遵循继承链寻找一个派发方法。对于通过方法关键字定义的标准方法以及通过其他方式(如属性访问器)生成的方法，都会发生这种情况。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Employee</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.salary</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Programmer</span> <span class="k">is</span> <span class="nc">Employee</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">@.known_languages</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.favorite_editor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">code_to_solve</span><span class="p">(</span> <span class="nv">$problem</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">&#34;</span><span class="s2">Solving </span><span class="nv">$problem</span><span class="s2"> using </span><span class="nv">$.favorite_editor</span><span class="s2"> in </span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="o">~</span> <span class="nv">$.known_languages</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>现在，Programmer类型的任何对象都可以使用Employee类中定义的方法和访问器，就像它们来自Programmer类一样。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$programmer</span> <span class="o">=</span> <span class="n">Programmer</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">salary</span> <span class="o">=&gt;</span> <span class="mi">100_000</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">known_languages</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="s">Perl5 Raku Erlang C++</span><span class="p">&gt;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">favorite_editor</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">vim</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$programmer</span><span class="o">.</span><span class="nf">code_to_solve</span><span class="p">(&#39;</span><span class="s1">halting problem</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2"> will get </span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$programmer</span><span class="o">.</span><span class="nf">salary</span><span class="p">()</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">\$</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#OUTPUT: «Solving halting problem using vim in Perl5 will get 100000$␤» </span>
</span></span></code></pre></div><h3 id="重写继承到的方法">重写继承到的方法</h3>
<p>当然，类可以通过定义它们自己来覆盖由父类定义的方法和属性。下面的例子演示了 Baker 类覆盖 Cook 的 <code>cook</code> 方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cook</span> <span class="k">is</span> <span class="nc">Employee</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">@.utensils</span>  <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">@.cookbooks</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">cook</span><span class="p">(</span> <span class="nv">$food</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Cooking </span><span class="nv">$food</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">clean_utensils</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Cleaning </span><span class="nv">$_</span><span class="p">&#34;</span> <span class="k">for</span> <span class="nv">@.utensils</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Baker</span> <span class="k">is</span> <span class="nc">Cook</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">cook</span><span class="p">(</span> <span class="nv">$confection</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Baking a tasty </span><span class="nv">$confection</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$cook</span> <span class="o">=</span> <span class="n">Cook</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">utensils</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="s">spoon ladle knife pan</span><span class="p">&gt;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">cookbooks</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">The Joy of Cooking</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">salary</span> <span class="o">=&gt;</span> <span class="mi">40000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nv">$cook</span><span class="o">.</span><span class="nf">cook</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">pizza</span><span class="p">&#39;</span> <span class="p">);</span>       <span class="c1"># OUTPUT: «Cooking pizza␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$cook</span><span class="o">.</span><span class="nf">utensils</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>     <span class="c1"># OUTPUT: «[&#34;spoon&#34;, &#34;ladle&#34;, &#34;knife&#34;, &#34;pan&#34;]␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$cook</span><span class="o">.</span><span class="nf">cookbooks</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>    <span class="c1"># OUTPUT: «[&#34;The Joy of Cooking&#34;]␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$cook</span><span class="o">.</span><span class="nf">salary</span><span class="p">;</span>            <span class="c1"># OUTPUT: «40000␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$baker</span> <span class="o">=</span> <span class="n">Baker</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">utensils</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">self cleaning oven</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">cookbooks</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">The Baker&#39;s Apprentice</span><span class="p">&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">salary</span> <span class="o">=&gt;</span> <span class="mi">50000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nv">$baker</span><span class="o">.</span><span class="nf">cook</span><span class="p">(&#39;</span><span class="s1">brioche</span><span class="p">&#39;);</span>      <span class="c1"># OUTPUT: «Baking a tasty brioche␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$baker</span><span class="o">.</span><span class="nf">utensils</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>    <span class="c1"># OUTPUT: «[&#34;self cleaning oven&#34;]␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$baker</span><span class="o">.</span><span class="nf">cookbooks</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>   <span class="c1"># OUTPUT: «[&#34;The Baker&#39;s Apprentice&#34;]␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$baker</span><span class="o">.</span><span class="nf">salary</span><span class="p">;</span>           <span class="c1"># OUTPUT: «50000␤» </span>
</span></span></code></pre></div><p>因为调度员会在 Baker 上移到父级之前看到 Cook 的 <code>cook</code> 方法，所以调用 Baker 的 <code>cook</code> 方法。</p>
<p>要访问继承链中的方法，请使用重新分派或 <code>MOP</code>。</p>
<h2 id="多重继承">多重继承</h2>
<p>如前所述，一个类可以从多个类继承。当一个类从多个类继承时，调度员知道在查找方法时要查看这两个类。 Raku 使用 <code>C3</code> 算法对多个继承层次进行线性化，这比深度优先搜索更好地处理多重继承。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">GeekCook</span> <span class="k">is</span> <span class="nc">Programmer</span> <span class="k">is</span> <span class="nc">Cook</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span> <span class="o">*</span><span class="nv">%params</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">push</span><span class="p">(</span> <span class="nv">%params</span><span class="p">&lt;</span><span class="s">cookbooks</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Cooking for Geeks</span><span class="p">&#34;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span><span class="o">|</span><span class="nv">%params</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$geek</span> <span class="o">=</span> <span class="n">GeekCook</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">books</span>           <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Learning Raku</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">utensils</span>        <span class="o">=&gt;</span> <span class="p">(&#39;</span><span class="s1">stainless steel pot</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">knife</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">calibrated oven</span><span class="p">&#39;)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">favorite_editor</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">MacVim</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">known_languages</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="s">Raku</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nv">$geek</span><span class="o">.</span><span class="nf">cook</span><span class="p">(&#39;</span><span class="s1">pizza</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$geek</span><span class="o">.</span><span class="nf">code_to_solve</span><span class="p">(&#39;</span><span class="s1">P =? NP</span><span class="p">&#39;);</span>
</span></span></code></pre></div><p>现在所有可用于 Programmer 和 Cook 类的方法都可以从 GeekCook 类中获得。</p>
<p>虽然多重继承是知道和偶尔使用的有用概念，但重要的是要了解有更多有用的 OOP 概念。当达到多重继承时，最好考虑是否通过使用角色来更好地实现设计，这通常更安全，因为它们强制类作者明确地解决冲突的方法名称。有关角色的更多信息，请参阅角色。</p>
<h2 id="also-声明符">also 声明符</h2>
<p>通过在特征前加上也可以在类声明主体中列出要继承的类。这也适用于角色组合特质。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">GeekCook</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">also</span> <span class="k">is</span> <span class="nc">Programmer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">also</span> <span class="k">is</span> <span class="nc">Cook</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ... </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">A</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">B</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="k">also</span> <span class="k">does</span> <span class="nc">A</span><span class="p">;</span> <span class="k">also</span> <span class="k">does</span> <span class="nc">B</span> <span class="p">}</span>
</span></span></code></pre></div><h2 id="自省">自省</h2>
<p>自省是在程序中收集有关某些对象的信息的过程，而不是通过阅读源代码，而是通过查询对象(或控制对象)来获取某些属性，例如其类型。</p>
<p>给定一个对象 <code>$o</code> 和前面几节的类定义，我们可以问一些问题:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$o</span> <span class="o">~~</span> <span class="n">Employee</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">It&#39;s an employee</span><span class="p">&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$o</span> <span class="o">~~</span> <span class="n">GeekCook</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">It&#39;s a geeky cook</span><span class="p">&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$o</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$o</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$o</span><span class="o">.^</span><span class="nb">methods</span><span class="p">(:</span><span class="s">local</span><span class="p">)</span><span class="o">».</span><span class="nb">name</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">, </span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$o</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
</span></span></code></pre></div><p>输出可能如下所示:</p>
<pre tabindex="0"><code>It&#39;s an employee
(Programmer)
Programmer.new(known_languages =&gt; [&#34;Perl&#34;, &#34;Python&#34;, &#34;Pascal&#34;],
        favorite_editor =&gt; &#34;gvim&#34;, salary =&gt; &#34;too small&#34;)
code_to_solve, known_languages, favorite_editor
Programmer
</code></pre><p>前两个测试每个智能匹配类名称。如果对象是该类或继承类，则返回 true。因此，所讨论的对象是 <code>Employee</code> 类，或者是继承它的类，但不是 <code>GeekCook</code>。</p>
<p><code>.WHAT</code> 方法返回与对象 <code>$o</code> 关联的类型对象，它告诉我们 <code>$o</code> 的确切类型:在这种情况下是 <code>Programmer</code>。</p>
<p><code>$o.perl</code> 返回一个可以作为 Perl 代码执行的字符串，并且再现原始对象 <code>$o</code>。虽然这在所有情况下都不能很好地工作，但它对调试简单对象非常有用。 <code>$o.^methods(:local)</code> 产生一个可以在 <code>$o</code> 上调用的方法列表。 <code>:local</code> 命名参数将返回的方法限制为在 Programmer 类中定义的方法，并排除继承的方法。</p>
<p>使用 <code>.^</code> 而不是单个点调用方法的语法意味着它实际上是对其元类的一个方法调用，该类是管理 Programmer 类的属性的类 - 或者您感兴趣的任何其他类。班级也启用了其他反省方式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$o</span><span class="o">.^</span><span class="nb">attributes</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">, </span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$o</span><span class="o">.^</span><span class="nb">parents</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="nv">$_</span><span class="o">.^</span><span class="nb">name</span> <span class="p">})</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">, </span><span class="p">&#39;);</span>
</span></span></code></pre></div><p>最后，<code>$o.^name</code> 调用元对象的名称方法，这毫不意外地返回类名称。</p>
<p>自省对于调试和学习语言和新库非常有用。当一个函数或方法返回一个你不知道的对象时，用 <code>.WHAT</code> 查找它的类型，用 <code>.perl</code> 等等来查看它的构造方法，你会很清楚它的返回值是什么。使用 <code>.^</code> 方法，您可以了解您可以对课程做些什么。</p>
<p>但也有其他应用程序:将对象序列化为一串字节的例程需要知道该对象的属性，可以通过内省查找该对象的属性。</p>
<h2 id="重写默认的-gist-方法">重写默认的 gist 方法</h2>
<p>有些类可能需要它自己的版本，它会覆盖当被调用以提供类的默认表示时被打印的简洁方式。例如，异常可能只想写入有效负载而不是完整对象，以便更清楚发生了什么。但是，每个班级你都可以这样做:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cook</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">@.utensils</span>  <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">@.cookbooks</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">cook</span><span class="p">(</span> <span class="nv">$food</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">&#34;</span><span class="s2">Cooking </span><span class="nv">$food</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">clean_utensils</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">&#34;</span><span class="s2">Cleaning </span><span class="nv">$_</span><span class="p">&#34;</span> <span class="k">for</span> <span class="nv">@.utensils</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nb">gist</span><span class="p">(</span><span class="n">Cook:U:</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#39;</span><span class="s1">⚗</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nb">self</span><span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">⚗</span><span class="p">&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nb">gist</span><span class="p">(</span><span class="n">Cook:D:</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#39;</span><span class="s1">⚗ Cooks with </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">@.utensils</span><span class="o">.</span><span class="nb">join</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2"> ‣ </span><span class="p">&#34;)</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> using </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">@.cookbooks</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">«</span><span class="p">&#34;</span> <span class="o">~</span> <span class="o">*</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">»</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">join</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2"> and </span><span class="p">&#34;)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$cook</span> <span class="o">=</span> <span class="n">Cook</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">utensils</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="s">spoon ladle knife pan</span><span class="p">&gt;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">cookbooks</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="p">&#39;</span><span class="s1">Cooking for geeks</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">The French Chef Cookbook</span><span class="p">&#39;</span><span class="o">]</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Cook</span><span class="o">.</span><span class="nb">gist</span><span class="p">;</span> <span class="c1"># OUTPUT: «⚗Cook⚗» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$cook</span><span class="o">.</span><span class="nb">gist</span><span class="p">;</span> <span class="c1"># OUTPUT: «⚗ Cooks with spoon ‣ ladle ‣ knife ‣ pan using «Cooking for geeks» and «The French Chef Cookbook»␤»</span>
</span></span></code></pre></div><p>通常你会想定义两个方法，一个用于类，另一个用于实例;在这种情况下，类方法使用 alambic 符号，下面定义的实例方法聚合了我们在厨师上的数据以叙述方式显示。</p>
<ol>
<li>例如，封闭不容易以这种方式复制;如果你不知道封闭是什么，不要担心。此外，当前的实现方式在倾倒循环数据结构方面存在问题，但预期它们可以在某些时候由 <code>.perl</code> 正确处理。</li>
</ol>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Ruby 到 Raku]]></title>
            <link href="http://localhost:1313/rakulang/12.ruby-to-perl-6/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/11.python-to-perl6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Python 到 Raku - 简而言之" />
                <link href="http://localhost:1313/rakulang/9.haskell-to-perl-6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Haskell 到 Raku - 简而言之" />
                <link href="http://localhost:1313/rakulang/10.javascript-node.js-to-perl-6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Javascript(Node.js) 到 Raku - 简而言之" />
                <link href="http://localhost:1313/rakulang/8.perl-5-to-perl-6-guide---special-variables/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 特殊变量" />
                <link href="http://localhost:1313/rakulang/7.perl-5-to-perl-6-guide---syntax/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 语法" />
            
                <id>http://localhost:1313/rakulang/12.ruby-to-perl-6/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-18T21:13:31+08:00</published>
            <updated>2018-10-18T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p><a href="https://docs.raku.org/language/rb-nutshell">Raku from Ruby - Nutshell</a></p>
<h2 id="基本语法">基本语法</h2>
<h3 id="语句结束分号">语句结束分号</h3>
<p>Ruby 使用换行(有几个例外)来探测大部分语句的结束, 只要表达式已经完成。通过把运算符挂在行的末尾以保证解析会继续而打断一个长的表达式的做法很常见:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="cl"><span class="n">foo</span> <span class="o">+</span>     <span class="c1"># 在 Ruby  中结尾的运算符意味着解析会继续</span>
</span></span><span class="line"><span class="cl">  <span class="n">bar</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">  <span class="n">baz</span>
</span></span></code></pre></div><p>在 Raku 中你必须显式地使用 <code>;</code> 来结束语句, 这允许更好的反馈和更灵活的断行。有两个例外不需要显式的 <code>;</code>,  块儿中的最后一条语句, 在块自身的闭合花括号<strong>之后</strong>(如果那一行上没有任何其它东西):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">5</span> <span class="o">&lt;</span> <span class="nv">$x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Yep!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$x</span> <span class="o">=</span> <span class="mi">17</span>     <span class="c1"># 在闭合花括号 } 之前不需要分号 ;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>               <span class="c1"># 因为换行, 在闭合花括号 } 之后不需要分号 ;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Done!</span><span class="p">&#34;;</span>    <span class="c1"># 如果后面什么也没有, 那么这儿的分号也不需要</span>
</span></span></code></pre></div><h3 id="空白">空白</h3>
<p>Ruby 中允许使用大量令人吃惊的灵活的空白, 即使在开启了严格模式和警告的情况下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="cl"><span class="c1"># 不符合习惯但是在 Ruby 中是合法的</span>
</span></span><span class="line"><span class="cl"><span class="nb">puts</span><span class="s2">&#34;Hello &#34;</span><span class="o">+</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">people</span> <span class="o">[</span> <span class="n">i</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span> <span class="nb">name</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="o">.</span> <span class="n">upcase</span><span class="o">+</span><span class="s2">&#34;!&#34;</span><span class="k">if</span><span class="vg">$greeted</span><span class="o">[</span><span class="n">i</span><span class="o">]&lt;</span><span class="mi">1</span>
</span></span></code></pre></div><p>Perl  6 也遵从程序员的自由和创造力，但是平衡的语法灵活性与其设计目标是一致的&mdash;确定性的，可扩展的语法，支持单程解析和有用的错误消息，组合功能，如利落地自定义运算符，不会导致程序员意外弄错他们的意图。 此外，不再强调 &ldquo;代码高尔夫&rdquo;; Raku 在概念上更为简洁, 而不是在少敲了几次键上。</p>
<p>因此，在语法中有很多地方，在 Ruby 中空格是可选的但是在 Raku 中却是强制的或禁止的。许多这些限制不太可能涉及很多现实的 Perl 代码（例如，在数组变量和它的方括号之间不允许有空格 ），但不幸的是有一些与某些 Ruby 黑客的习惯编码风格冲突：</p>
<ul>
<li>在参数列表的开括号「<code>(</code>」之前不允许有空格</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">foo</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1"># 在 Ruby 或 Raku 中都不正确 ( 在 Raku 中这会</span>
</span></span><span class="line"><span class="cl">               <span class="c1"># 尝试为 foo 传递一个 List 类型的单个参数)</span>
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1"># Ruby 和 Raku 中都可以</span>
</span></span><span class="line"><span class="cl"><span class="n">foo</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1"># Ruby 和 Raku 中都可以 - 圆括号是可供选择的-less style</span>
</span></span></code></pre></div><ul>
<li>关键字后面立刻需要跟着空格</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span> <span class="o">...</span><span class="p">;</span> <span class="nb">end</span>         <span class="c1"># OK in Ruby</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>         <span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$a</span> <span class="o">&lt;</span> <span class="mi">0</span>   <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>         <span class="c1"># Raku, 更地道</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="nb">x</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">);</span> <span class="o">...</span><span class="p">;</span> <span class="nb">end</span>      <span class="c1"># OK in Ruby</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="nv">$x</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>      <span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="nv">$x</span> <span class="o">&gt;</span> <span class="mi">5</span>   <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>      <span class="c1"># Raku, 更地道</span>
</span></span></code></pre></div><ul>
<li>后缀/后环缀 操作符(包括数组/散列下标)前面不允许有空格。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">seen</span> <span class="o">[</span> <span class="p">:</span><span class="s">fish</span> <span class="o">]</span> <span class="o">=</span> <span class="mi">1</span>    <span class="c1"># Ruby, 不地道, 但是允许这样写</span>
</span></span><span class="line"><span class="cl"><span class="nv">%seen</span><span class="p">&lt;</span><span class="s"> fish </span><span class="p">&gt;</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="c1"># Raku, &#39;seen&#39; 后面不允许出现空格</span>
</span></span></code></pre></div><ul>
<li>中缀操作符之前需要空格, 如果它和已经存在的后缀/后环缀 操作符冲突的话。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">n</span><span class="o">&lt;</span><span class="mi">1</span>     <span class="c1"># Ruby (in Raku this would conflict with postcircumfix &lt; &gt;)</span>
</span></span><span class="line"><span class="cl"><span class="nv">$n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1"># Raku</span>
</span></span></code></pre></div><h3 id="方法调用-send">方法调用, .send</h3>
<p>方法调用使用点语法, 就像 Ruby 那样:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">person</span><span class="o">.</span><span class="nb">name</span>    <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="nv">$person</span><span class="o">.</span><span class="nb">name</span>   <span class="c1"># Raku</span>
</span></span></code></pre></div><p>要调用一个直到运行时才直到名字的方法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">object</span><span class="o">.</span><span class="nb">send</span><span class="p">(</span><span class="n">methodname</span><span class="o">,</span> <span class="nb">args</span><span class="p">);</span>  <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="nv">$object</span><span class="o">.</span><span class="p">&#34;</span><span class="nv">$methodname</span><span class="p">&#34;(</span><span class="nv">@args</span><span class="p">);</span>   <span class="c1"># Raku</span>
</span></span></code></pre></div><p>如果你遗漏了双引号, 那么 Raku 会期望 <code>$methodname</code> 包含一个 <code>Method</code> 对象, 而不是单单是那个方法名的字符串表示。</p>
<h3 id="变量符号作用域-和通用类型">变量、符号、作用域 和通用类型</h3>
<p>在 Ruby 中，变量主要使用 sigils 指示作用域。 <code>$</code> 用于全局作用域，<code>@@</code> 用于类作用域，<code>@</code> 用作实例作用域，无符号用于局部变量（包括参数）。 <code>&amp;</code> 符号也用于表示方法引用。符号的前缀为 <code>:</code>，但它们不是可变的，所以不是真正的符号。</p>
<p>在 Raku 中，符号主要用于指代包含的值实现的角色，表明值的类型（或至少接口）。 符号是不变的，不管变量是如何使用的 - 你可以把它们看作变量名的一部分。</p>
<p>变量的作用域改为由声明本身（my，has，our，etc）表示。</p>
<h4 id="变量作用域">变量作用域</h4>
<p>对于局部变量，Ruby 在赋值时使用隐式变量声明，并限于当前块。 在 Ruby 中，if 或 while 内置结构的内容不是块或作用域。</p>
<p>Raku 使用显式作用域指示符，并且不会隐式地创建变量。 每一个地方你看到的 <code>{...}</code> 都是一个作用域，它包括一个条件或循环的主体。 常用的作用域声明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">foo</span> <span class="o">=</span> <span class="mi">7</span>        <span class="c1"># Ruby, variable scope is defined by first assignment and</span>
</span></span><span class="line"><span class="cl">               <span class="c1"># extends to the end of the current block</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span>  <span class="nv">$foo</span> <span class="o">=</span> <span class="mi">7</span>   <span class="c1"># Raku, lexical scoped to the current block</span>
</span></span><span class="line"><span class="cl"><span class="k">our</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="mi">7</span>   <span class="c1"># Raku, package scoped</span>
</span></span><span class="line"><span class="cl"><span class="k">has</span> <span class="nv">$!foo</span> <span class="o">=</span> <span class="mi">7</span>  <span class="c1"># Raku, instance scoped (attribute)</span>
</span></span></code></pre></div><h4 id="-标量"><code>$</code> 标量</h4>
<p><code>$</code> 符号始终与&quot;标量&quot;变量（例如 <code>$name</code>）一起使用。这些是单值(single-value) 容器。</p>
<p>这是最通用的变量类型，对其内容没有限制。 注意，你仍然可以寻址/使用它的内容，如 <code>$x[1]</code>，<code>$x{&quot;foo&quot;}</code> 和 <code>$f(&quot;foo&quot;)</code>。</p>
<h4 id="-数组"><code>@</code> 数组</h4>
<p><code>@</code> 总是与&quot;数组&quot;变量一起使用（例如 <code>@months</code>，<code>@months[2]</code>，<code>@months[2,4]</code> 用于数组切片）。 使用 <code>@</code> 符号的变量只能包含执行 Positional 角色的东西，Positional 角色指的是位置索引和切片功能。</p>
<ul>
<li>索引</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">puts</span> <span class="n">months</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span> <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@months</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span> <span class="c1"># Raku</span>
</span></span></code></pre></div><ul>
<li>值切片</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">puts</span> <span class="n">months</span><span class="o">[</span><span class="mi">8</span><span class="o">..</span><span class="mi">11</span><span class="o">].</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;)</span> <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@months</span><span class="o">[</span><span class="mi">8</span><span class="o">..</span><span class="mi">11</span><span class="o">].</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;)</span> <span class="c1"># Raku</span>
</span></span></code></pre></div><h4 id="-散列"><code>%</code> 散列</h4>
<p><code>%</code> 符号始终与&quot;散列&quot;变量一起使用（例如<code>%calories</code>, <code>%calories&lt;apple&gt;</code>, <code>%calories&lt;pear plum&gt;</code>）。 使用 <code>%</code> 符号的变量只能包含执行关联(<code>Associative</code>)角色的内容。</p>
<p>Ruby 使用方括号来访问数组和哈希值。 Raku 使用花括号来代替散列。 尖括号版本也是可用的，它总是自动引起其内容（不带引号的字符串）：</p>
<p>副词可以用来控制切片的类型。</p>
<ul>
<li>索引</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">puts</span> <span class="n">calories</span><span class="o">[</span><span class="p">&#34;</span><span class="s2">apple</span><span class="p">&#34;</span><span class="o">]</span>  <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%calories</span><span class="p">{&#34;</span><span class="s2">apple</span><span class="p">&#34;};</span> <span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">puts</span> <span class="n">calories</span><span class="o">[</span><span class="p">&#34;</span><span class="s2">apple</span><span class="p">&#34;</span><span class="o">]</span>  <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="n">puts</span> <span class="n">calories</span><span class="o">[</span><span class="p">:</span><span class="s">apple</span><span class="o">]</span>   <span class="c1"># Ruby, symbols for keys are common</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%calories</span><span class="p">&lt;</span><span class="s">apple</span><span class="p">&gt;;</span>   <span class="c1"># Raku - angle brackets instead of single-quotes</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%calories</span><span class="p">«</span><span class="nv">$key</span><span class="p">»;</span>    <span class="c1"># Raku - double angles interpolate as double-quotes</span>
</span></span></code></pre></div><ul>
<li>值切片</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">puts</span> <span class="n">calories</span><span class="o">.</span><span class="nf">values_at</span><span class="p">(&#39;</span><span class="s1">pear</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">plum</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;)</span> <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="n">puts</span> <span class="n">calories</span><span class="o">.</span><span class="nf">values_at</span><span class="p">(</span><span class="nv">%w</span><span class="p">(</span><span class="n">pear</span> <span class="n">plum</span><span class="p">))</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;)</span>  <span class="c1"># Ruby, pretty?</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%calories</span><span class="p">{&#39;</span><span class="s1">pear</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">plum</span><span class="p">&#39;}</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;);</span>          <span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%calories</span><span class="p">&lt;</span><span class="s">pear plum</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;);</span>               <span class="c1"># Raku (prettier)</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$keys</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">pear plum</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%calories</span><span class="p">«</span><span class="nv">$keys</span><span class="p">»</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;);</span> <span class="c1"># Raku, interpolated split</span>
</span></span></code></pre></div><ul>
<li>键/值切片</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">calories</span><span class="o">.</span><span class="nf">slice</span><span class="p">(&#39;</span><span class="s1">pear</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">plum</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;);</span> <span class="c1"># Ruby, with ActiveRecord</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%calories</span><span class="p">{&#39;</span><span class="s1">pear</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">plum</span><span class="p">&#39;}:</span><span class="s">kv</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;);</span>   <span class="c1"># Raku - 使用 :kv 副词</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%calories</span><span class="p">&lt;</span><span class="s">pear plum</span><span class="p">&gt;:</span><span class="s">kv</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;);</span>        <span class="c1"># Raku (更好看的版本)</span>
</span></span></code></pre></div><h4 id="-sub"><code>&amp;</code> Sub</h4>
<p><code>&amp;</code> 符号与 Ruby 的 <code>&amp;</code> 非常类似，用于引用一个具名的子例程/操作符的函数对象，而不调用它，即把名字用作&quot;名词&quot;而不是&quot;动词&quot;。 使用 <code>&amp;</code> 符号的变量只能包含 <code>Callable</code> 角色的内容。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">add</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="n">n</span><span class="o">,</span> <span class="k">m</span> <span class="p">{</span><span class="sr"> n </span><span class="o">+</span><span class="sr"> m </span><span class="p">}</span> <span class="c1"># Ruby lambda for an addition function</span>
</span></span><span class="line"><span class="cl"><span class="nb">add</span><span class="o">.</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span>              <span class="c1"># =&gt; 5, Ruby invocation of a lambda</span>
</span></span><span class="line"><span class="cl"><span class="nb">add</span><span class="o">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span>          <span class="c1"># =&gt; 5, Ruby invocation of a lambda</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">&amp;add</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="nv">$n</span><span class="o">,</span> <span class="nv">$m</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">+</span> <span class="nv">$m</span> <span class="p">}</span> <span class="c1"># Raku addition function</span>
</span></span><span class="line"><span class="cl"><span class="nv">&amp;add</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span>                      <span class="c1"># =&gt; 5, you can keep the sigil</span>
</span></span><span class="line"><span class="cl"><span class="nb">add</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span>                       <span class="c1"># =&gt; 5, and it works without it</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">foo_method</span> <span class="o">=</span> <span class="nv">&amp;foo</span><span class="p">;</span>     <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">&amp;foo_method</span> <span class="o">=</span> <span class="nv">&amp;foo</span><span class="p">;</span> <span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">some_func</span><span class="p">(</span><span class="nv">&amp;say</span><span class="p">)</span> <span class="c1"># Ruby pass a function reference</span>
</span></span><span class="line"><span class="cl"><span class="nf">some_func</span><span class="p">(</span><span class="nv">&amp;say</span><span class="p">)</span> <span class="c1"># Raku passes function references the same way</span>
</span></span></code></pre></div><p>通常在 Ruby 中，我们传递一个块作为最后一个参数，这是特别用于 DSL 中。 这可以是通过 <code>yield</code> 调用的隐式参数，也可以是带有前缀 <code>&amp;</code> 的显式块。 在 Raku 中，Callable 参数总是被变量名称（而不是yield）列出和调用，并且有多种调用函数的方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Ruby, declare a method and call the implicit block argument</span>
</span></span><span class="line"><span class="cl"><span class="n">def</span> <span class="nb">f</span>
</span></span><span class="line"><span class="cl">  <span class="nb">yield</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="nb">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Ruby, invoke f, pass it a block with 1 argument</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span> <span class="nb">do</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span>
</span></span><span class="line"><span class="cl">  <span class="n">puts</span> <span class="p">&#34;</span><span class="s2">Hi #</span><span class="p">{</span><span class="n">n</span><span class="p">}&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Raku, declare a method with an explicit block argument</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nv">&amp;g:</span><span class="p">(</span><span class="nv">$</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">g</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Raku, invoke f, pass it a block with 1 argument</span>
</span></span><span class="line"><span class="cl"><span class="c1"># There are several other ways to do this</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hi </span><span class="p">{</span><span class="nv">$n</span><span class="p">}&#34;</span> <span class="p">})</span> <span class="c1"># Explicit argument</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hi </span><span class="p">{</span><span class="nv">$n</span><span class="p">}&#34;</span> <span class="p">}</span>  <span class="c1"># Explicit argument, no parenthesis</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hi </span><span class="p">{</span><span class="nv">$^n</span><span class="p">}&#34;</span> <span class="p">}</span>       <span class="c1"># Implicit argument</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Additionally, if &#39;f&#39; is a method on instance &#39;obj&#39; you can use C&lt;:&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># instead of parenthesis</span>
</span></span><span class="line"><span class="cl"><span class="n">obj</span><span class="o">.</span><span class="nb">f</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hi </span><span class="p">{</span><span class="nv">$n</span><span class="p">}&#34;</span> <span class="p">})</span>  <span class="c1"># Explicit argument</span>
</span></span><span class="line"><span class="cl"><span class="n">obj</span><span class="o">.</span><span class="nb">f</span><span class="o">:</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hi </span><span class="p">{</span><span class="nv">$n</span><span class="p">}&#34;</span> <span class="p">}</span>  <span class="c1"># Explicit argument, no parenthesis</span>
</span></span><span class="line"><span class="cl"><span class="n">obj</span><span class="o">.</span><span class="nb">f</span><span class="o">:</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hi </span><span class="p">{</span><span class="nv">$^n</span><span class="p">}&#34;</span> <span class="p">}</span>       <span class="c1"># Implicit argument, no parenthesis</span>
</span></span></code></pre></div><h4 id="-吞噬参数-参数扩展"><code>*</code> 吞噬参数/ 参数扩展</h4>
<p>在 Ruby 中，你可以声明一个参数，使用 <code>*</code> 前缀将所传递参数的剩余部分传递到数组中。 它在 Raku 中的工作方式相同：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">def</span> <span class="nf">foo</span><span class="p">(</span><span class="o">*</span><span class="nb">args</span><span class="p">);</span> <span class="n">puts</span> <span class="p">&#34;</span><span class="s2">I got #</span><span class="p">{</span><span class="nb">args</span><span class="o">.</span><span class="nf">length</span><span class="p">}</span><span class="s2"> args!</span><span class="p">&#34;;</span> <span class="nb">end</span> <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="o">*</span><span class="nv">@args</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I got #</span><span class="p">{</span><span class="nv">@args</span><span class="o">.</span><span class="nb">elems</span><span class="p">}</span><span class="s2"> args!</span><span class="p">&#34;</span> <span class="p">}</span>   <span class="c1"># Raku</span>
</span></span></code></pre></div><p>您可能想将数组扩展为一组参数。 在 Raku 中，这也使用 <code>*</code> 前缀：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">args</span> <span class="o">=</span> <span class="nv">%w</span><span class="p">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span>         <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="o">*</span><span class="nb">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@args</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span>       <span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="o">*</span><span class="nv">@args</span><span class="p">)</span>
</span></span></code></pre></div><p>Raku 有许多更高级的传递参数和接收参数的方法，参见<a href="https://docs.raku.org/language/functions#Signatures">签名</a>和<a href="https://docs.raku.org/type/Capture">捕获</a>。</p>
<h4 id="twigils">Twigils</h4>
<p>Raku 另外还使用 &ldquo;twigs&rdquo;，它是关于变量的进一步指示符，并且在符号和变量名的其余部分之间。 例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$foo</span>     <span class="c1"># Scalar with no twigil</span>
</span></span><span class="line"><span class="cl"><span class="nv">$!foo</span>    <span class="c1"># 私有实例变量</span>
</span></span><span class="line"><span class="cl"><span class="nv">$.foo</span>    <span class="c1"># Instance variable accessor</span>
</span></span><span class="line"><span class="cl"><span class="vg">$*foo</span>    <span class="c1"># Dynamically scoped variable</span>
</span></span><span class="line"><span class="cl"><span class="nv">$^foo</span>    <span class="c1"># A positional (placeholder) parameter to a block</span>
</span></span><span class="line"><span class="cl"><span class="nv">$:foo</span>    <span class="c1"># 具名参数</span>
</span></span><span class="line"><span class="cl"><span class="nv">$=foo</span>    <span class="c1"># POD (文档) 变量</span>
</span></span><span class="line"><span class="cl"><span class="nv">$?FILE</span>   <span class="c1"># Current source filename. ? twigil 表明这是一个编译时值</span>
</span></span><span class="line"><span class="cl"><span class="nv">$~foo</span>    <span class="c1"># Sublanguage seen by parser, uncommon</span>
</span></span></code></pre></div><p>虽然每个例子都使用 <code>$</code> 符号，但大多数可以使用 <code>@</code>（Positional）或 <code>%</code>（Associative）。</p>
<h4 id="-符号"><code>:</code> 符号</h4>
<p>Raku 通常在 Ruby 使用符号的地方使用字符串。 关于这点的一个主要例子是散列键。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">address</span><span class="o">[</span><span class="p">:</span><span class="s">joe</span><span class="o">][</span><span class="p">:</span><span class="s">street</span><span class="o">]</span> <span class="c1"># Typical Ruby nested hash with symbol keys</span>
</span></span><span class="line"><span class="cl"><span class="nv">%address</span><span class="p">&lt;</span><span class="s">joe</span><span class="p">&gt;&lt;</span><span class="s">street</span><span class="p">&gt;</span>  <span class="c1"># Typical Raku nested hash with string keys</span>
</span></span></code></pre></div><p>Raku 有冒号对语法，有时看起来像Ruby符号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">:</span><span class="s">age</span>            <span class="c1"># Ruby symbol</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># All of these are equivalent for Raku</span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="s">age</span>            <span class="c1"># Raku pair with implicit True value</span>
</span></span><span class="line"><span class="cl"><span class="p">:</span><span class="s">age</span><span class="p">(</span><span class="kt">True</span><span class="p">)</span>      <span class="c1"># Raku pair with explicit True value</span>
</span></span><span class="line"><span class="cl"><span class="s">age</span> <span class="o">=&gt;</span> <span class="kt">True</span>     <span class="c1"># Raku pair using arrow notation</span>
</span></span><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">age</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="kt">True</span>   <span class="c1"># Raku pair using arrow notation and explicit quotes</span>
</span></span></code></pre></div><p>很多时候你可能会使用一个没有显式值的冒号对，并假装它是一个 Ruby 符号，但它不是惯用的 Raku。</p>
<h2 id="操作符">操作符</h2>
<p>许多操作符在 Ruby 和 Raku 中有类似的用法：</p>
<ul>
<li>, 列表分割符</li>
<li><code>+</code> 数值加法</li>
<li><code>-</code> 数值减法</li>
<li><code>*</code> 数值乘法</li>
<li>/ 数值除法</li>
<li>% 数值求模</li>
<li>** 数值指数</li>
<li>! &amp;&amp; || 布尔, 高优先级</li>
<li>not and or 布尔, 低优先级</li>
</ul>
<p>您可以使用 <code>$x++</code> 而不是 <code>x += 1</code> 作为递增变量的快捷方式。这可以用作预增量 <code>++$x</code>（增量，返回新值）或后增量 <code>$x++</code>（增量，返回旧值）。</p>
<p>您可以使用 <code>$x--</code> 而不是 <code>x -= 1</code> 作为递减变量的快捷方式。这可以用作预减量 <code>--$x</code>（递减，返回新值）或递减后 <code>$x--</code>（递减，返回旧值）。</p>
<h3 id="------比较">== != &lt; &gt; &lt;= &gt;= 比较</h3>
<p>Raku 中, 数字和字符串之间比较是分开的，以避免常见错误。</p>
<ul>
<li>
<p>== != &lt; &gt; &lt;= &gt;= 比较</p>
</li>
<li>
<p>eq ne lt gt le ge 字符串比较</p>
</li>
</ul>
<p>例如，使用 <code>==</code> 尝试将值转换为数字，并且 <code>eq</code> 尝试将值转换为字符串。</p>
<h3 id="-三向比较"><code>&lt;=&gt;</code> 三向比较</h3>
<p>在 Ruby 中，<code>&lt;=&gt;</code> 运算符返回 -1,0 或1。 在 Raku 中，它们返回 <code>Order :: Less</code>，<code>Order :: Same</code> 或 <code>Order :: More</code>。</p>
<p><code>&lt;=&gt;</code> 用于强制数字上下文比较。</p>
<p><code>leg</code>（&ldquo;Less，Equal 或者 Greater?&quot;）用于强制字符串上下文比较。</p>
<p><code>cmp</code> 要么是 <code>&lt;=&gt;</code> 比较, 要么是 <code>leg</code> 比较，这取决于它的参数的现有类型。</p>
<h3 id="-智能匹配运算符"><code>~~</code> 智能匹配运算符</h3>
<p>这是一个非常常见的匹配运算符，它不存在于 Ruby 中。这里有些例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">match!</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$foo</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">bar</span><span class="p">/;</span>      <span class="c1"># Regex match</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">match!</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$foo</span> <span class="o">~~</span> <span class="p">&#34;</span><span class="s2">bar</span><span class="p">&#34;;</span>      <span class="c1"># String match</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">match!</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$foo</span> <span class="o">~~</span> <span class="o">:</span><span class="p">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Str</span><span class="p">)</span> <span class="c1"># Signature match (destructure)</span>
</span></span></code></pre></div><p>参见 <a href="https://design.raku.org/S03.html#Smart_matching">S03/智能匹配</a></p>
<h3 id="---数字位操作">&amp; | ^ 数字位操作</h3>
<h3 id="---布尔运算">&amp; | ^ 布尔运算</h3>
<p>在 Raku 中，这些单字符操作被移除了，并被两个字符操作代替，它们将它们的参数强制到所需的上下文中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Infix ops (two arguments; one on each side of the op)</span>
</span></span><span class="line"><span class="cl"><span class="o">+&amp;</span>  <span class="o">+|</span>  <span class="o">+^</span>  <span class="n">And</span> <span class="nf">Or</span> <span class="n">Xor:</span> <span class="kt">Numeric</span>
</span></span><span class="line"><span class="cl"><span class="o">~&amp;</span>  <span class="o">~|</span>  <span class="o">~^</span>  <span class="n">And</span> <span class="nf">Or</span> <span class="n">Xor:</span> <span class="n">String</span>
</span></span><span class="line"><span class="cl"><span class="o">?&amp;</span>  <span class="o">?|</span>  <span class="o">?^</span>  <span class="n">And</span> <span class="nf">Or</span> <span class="n">Xor:</span> <span class="n">Boolean</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Prefix ops (one argument, after the op)</span>
</span></span><span class="line"><span class="cl"><span class="o">+^</span>  <span class="n">Not:</span> <span class="kt">Numeric</span>
</span></span><span class="line"><span class="cl"><span class="o">~^</span>  <span class="n">Not:</span> <span class="n">String</span>
</span></span><span class="line"><span class="cl"><span class="o">?^</span>  <span class="n">Not:</span> <span class="n">Boolean</span> <span class="p">(</span><span class="n">same</span> <span class="n">as</span> <span class="n">the</span> <span class="o">!</span> <span class="n">op</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="-条件链式操作符"><code>&amp;.</code> 条件链式操作符</h3>
<p>Ruby 使用  <code>&amp;.</code> 运算符链接方法，而不会在一个返回 nil 的调用中产生错误。在 Raku 中因为同样的目的使用 <code>.?</code>。</p>
<h3 id="--数值左右移位操作符铲shovel操作符">&laquo; &raquo; 数值左/右移位操作符，铲(shovel)操作符</h3>
<p>替换为 <code>+&lt;</code> 和 <code>+&gt;</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">puts</span> <span class="mi">42</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span>  <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span>  <span class="mi">42</span> <span class="o">+&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="c1"># Raku</span>
</span></span></code></pre></div><p>注意，Ruby 经常使用 <code>&lt;&lt;</code> 运算符作为&quot;铲操作符&rdquo;，这类似于<code>.push</code>。这种用法在 Raku 中不常见。</p>
<h3 id="和--键-值分隔符"><code>=&gt;</code>和 <code>:</code> 键-值分隔符</h3>
<p>在 Ruby 中，<code>=&gt;</code> 用于 Hash 字面声明和参数传递的键/值对的上下文中。 当左边是符号时用 <code>:</code> 作速记符。</p>
<p>在 Raku 中，<code>=&gt;</code> 是对(Pair)运算符，这在原理上是非常不同的，但在许多情况下工作相同。</p>
<p>如果你在哈希字面值中使用 <code>=&gt;</code>，那么用法非常类似：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">hash</span> <span class="o">=</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">AAA</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">BBB</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="p">}</span>  <span class="c1"># Ruby, though symbol keys are more common</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%hash</span> <span class="o">=</span> <span class="p">(</span> <span class="s">AAA</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">BBB</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="p">);</span> <span class="c1"># Raku, uses ()&#39;s though {} usually work</span>
</span></span></code></pre></div><h3 id="-三目运算符"><code>?:</code> 三目运算符</h3>
<p>在 Raku 中，这被拼写为两个问号，而不是一个问号，和两个感叹号而不是一个冒号。这种与常见三目运算符的偏离消除了多种歧义的情况，并使得假的情况更突出。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">result</span>     <span class="o">=</span> <span class="p">(</span>  <span class="n">score</span> <span class="o">&gt;</span> <span class="mi">60</span> <span class="p">)</span>  <span class="o">?</span> <span class="p">&#39;</span><span class="s1">Pass</span><span class="p">&#39;</span>  <span class="o">:</span> <span class="p">&#39;</span><span class="s1">Fail</span><span class="p">&#39;;</span> <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$result</span> <span class="o">=</span> <span class="p">(</span> <span class="nv">$score</span> <span class="o">&gt;</span> <span class="mi">60</span> <span class="p">)</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">Pass</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">Fail</span><span class="p">&#39;;</span> <span class="c1"># Raku</span>
</span></span></code></pre></div><h3 id="-字符串连接"><code>+</code> 字符串连接</h3>
<p>替换为波浪线符号（<code>~</code>）。助记符：想想用针和线缝合两个字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$food</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">grape</span><span class="p">&#39;</span> <span class="o">+</span> <span class="p">&#39;</span><span class="s1">fruit</span><span class="p">&#39;</span>  <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="nv">$food</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">grape</span><span class="p">&#39;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">fruit</span><span class="p">&#39;;</span> <span class="c1"># Raku</span>
</span></span></code></pre></div><h3 id="字符串插值">字符串插值</h3>
<p>在 Ruby 中，&quot;#{foo}s&quot; 界定嵌入在双引号字符串中的块。在 Raku 中删除 <code>#</code> 前缀：&quot;{$foo}s&quot;。和 Ruby 一样，你可以将任意代码放在嵌入式块中，它将在字符串上下文中渲染。</p>
<p>简单变量可以插入到双引号字符串中，而不使用块语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="nb">name</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Bob</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">puts</span> <span class="p">&#34;</span><span class="s2">Hello! My name is #</span><span class="p">{</span><span class="nb">name</span><span class="p">}</span><span class="s2">!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$name</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Bob</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello! My name is </span><span class="nv">$name</span><span class="s2">!</span><span class="p">&#34;</span>
</span></span></code></pre></div><p>Ruby 中的嵌入式块的结果使用 <code>.to_s</code> 来获取字符串上下文。 Raku 使用 <code>.Str</code> 或 <code>.gist</code> 得到相同的效果。</p>
<h2 id="复合语句">复合语句</h2>
<h3 id="条件">条件</h3>
<h4 id="if-elsif-else-unless">if elsif else unless§</h4>
<p>这在 Ruby 和 Raku 之间非常相似，但是 Raku 使用 <code>{}</code> 来清楚地描述块。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">x</span> <span class="o">&gt;</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl">    <span class="n">puts</span> <span class="p">&#34;</span><span class="s2">Bigger!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">elsif</span> <span class="nb">x</span> <span class="o">==</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl">    <span class="n">puts</span> <span class="p">&#34;</span><span class="s2">The same!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="n">puts</span> <span class="p">&#34;</span><span class="s2">Smaller!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">x</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Bigger!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">elsif</span> <span class="nb">x</span> <span class="o">==</span> <span class="mi">5</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">puts</span> <span class="p">&#34;</span><span class="s2">The same!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">puts</span> <span class="p">&#34;</span><span class="s2">Smaller!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>将条件表达式绑定到变量上有一点不同：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">x</span> <span class="o">=</span> <span class="nf">dostuff</span><span class="p">();</span> <span class="o">...</span><span class="p">;</span> <span class="nb">end</span>   <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nf">dostuff</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$x</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>     <span class="c1"># Raku, block-assignment uses arrow</span>
</span></span></code></pre></div><p><code>unless</code> 条件仅允许 Raku 中的单个块; 它不允许 <code>elsif</code> 或 <code>else</code> 子句。</p>
<h4 id="cese-when"><code>cese-when</code></h4>
<p>Raku 的 <code>given-when</code> 结构像一个 <code>if-elsif-else</code> 语句链或者类似于 Ruby 中的 <code>case-when</code>。一个很大的区别是，Ruby 使用 <code>==</code> 比较每个条件，但 Raku 使用更一般的智能匹配 <code>~~</code> 运算符。</p>
<p>它具有以下一般结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="n">EXPR</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="n">EXPR</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="n">EXPR</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在其最简单的形式中，构造如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="nv">$value</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="p">&#34;</span><span class="s2">a match</span><span class="p">&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">do-something</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="p">&#34;</span><span class="s2">another match</span><span class="p">&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">do-something-else</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">do-default-thing</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这在 <code>when</code> 语句中匹配标量值的情况下是简单的。更一般地，匹配实际上是对输入值的智能匹配，使得可以使用更复杂的诸如正则表达式的实体的而非标量值来查找。</p>
<h3 id="循环">循环</h3>
<h4 id="while-until">while until</h4>
<p>大部分不变;圆括号周围的条件是可选的，但如果使用了，不能立即跟随关键字，否则它将被视为一个函数调用。将条件表达式绑定到变量上也有一些不同：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">while</span> <span class="nb">x</span> <span class="o">=</span> <span class="nf">dostuff</span><span class="p">();</span> <span class="o">...</span><span class="p">;</span> <span class="nb">end</span>    <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="nf">dostuff</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$x</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>      <span class="c1"># Raku</span>
</span></span></code></pre></div><h4 id="for-each">for .each</h4>
<p>for 循环在 Ruby 中是罕见的，我们通常在可枚举上使用 <code>.each</code>。对 Raku 的最直接的翻译是对 <code>.each</code> 和 <code>.map</code> 都使用 <code>.map</code>，但是我们通常直接使用 <code>for</code> 循环。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Ruby for loop</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">n</span> <span class="nb">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">5</span>
</span></span><span class="line"><span class="cl">    <span class="nf">puts</span> <span class="p">&#34;</span><span class="s2">n: #</span><span class="p">{</span><span class="n">n</span><span class="p">}&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Ruby, more common usage of .each</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="nf">each</span> <span class="nb">do</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span>
</span></span><span class="line"><span class="cl">    <span class="nf">puts</span> <span class="p">&#34;</span><span class="s2">n: #</span><span class="p">{</span><span class="n">n</span><span class="p">}&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">5</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">n: </span><span class="nv">$n</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Raku, mis-using .map</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">n: </span><span class="nv">$n</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在 Ruby 中，.each 的迭代变量是列表元素的副本，修改它对原始列表没有影响。请注意，它是 REFERENCE 的副本，因此您仍然可以更改其引用的值。</p>
<p>在 Raku 中，该别名是只读的（为了安全起见），因此它的行为与 Ruby 完全一样，除非把 <code>-&gt;</code> 改为 <code>&lt;-&gt;</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">cars</span><span class="o">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">car</span><span class="o">|</span> <span class="o">...</span> <span class="p">}</span>    <span class="c1"># Ruby; read-only reference</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@cars</span>  <span class="k">-&gt;</span> <span class="nv">$car</span>   <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1"># Raku; read-only</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@cars</span> <span class="o">&lt;-&gt;</span> <span class="nv">$car</span>   <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1"># Raku; read-write</span>
</span></span></code></pre></div><h3 id="流程中断语句">流程中断语句</h3>
<p>与 Ruby 相同：</p>
<ul>
<li>next</li>
<li>redo</li>
<li>break</li>
</ul>
<p>这在 Raku 中是 <code>last</code>。</p>
<h2 id="正则表达式regex--regexp">正则表达式（Regex / Regexp）</h2>
<p>Raku 中的正则表达式与 Ruby 中的正则表达式明显不同，它更强大。例如，默认情况下，Raku 将忽略空格，所有字符必须转移。正则表达式可以很容易地以组合和声明的方式建立高效的 grammars。</p>
<p>有很多强大的 Raku regex 的特性，特别是使用相同的语法定义整个 gramamrs。请参阅<a href="https://docs.raku.org/language/regexes">正则表达式</a>和 <a href="https://docs.raku.org/language/grammars">Grammars</a>。</p>
<h3 id="match-方法和--运算符">.match 方法和 =~ 运算符</h3>
<p>在 Ruby 中，可以使用 <code>=~</code> regexp 匹配运算符或 <code>.match</code> 方法对变量执行正则表达式匹配。在 Raku 中，使用 ~~ 智能匹配运算符，或 <code>.match</code> 方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">next</span> <span class="k">if</span> <span class="nb">line</span>   <span class="o">=~</span> <span class="o">/</span><span class="n">static</span><span class="o">/</span>   <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="nb">next</span> <span class="k">if</span> <span class="nv">$line</span>  <span class="o">~~</span> <span class="p">/</span><span class="sr">static</span><span class="p">/;</span>  <span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">next</span> <span class="k">if</span> <span class="nb">line</span>  <span class="o">!~</span>  <span class="o">/</span><span class="k">dynamic</span><span class="o">/</span> <span class="p">;</span> <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="nb">next</span> <span class="k">if</span> <span class="nv">$line</span> <span class="o">!~~</span> <span class="p">/</span><span class="sr">dynamic</span><span class="p">/</span> <span class="p">;</span> <span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">next</span> <span class="k">if</span> <span class="nb">line</span><span class="o">.</span><span class="nb">match</span><span class="p">(/</span><span class="sr">static</span><span class="p">/)</span>    <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="nb">next</span> <span class="k">if</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">match</span><span class="p">(/</span><span class="sr">static</span><span class="p">/);</span>  <span class="c1"># Raku</span>
</span></span></code></pre></div><p>或者，可以使用 <code>.match</code>和 <code>.subst</code> 方法。注意 <code>.subst</code> 是不可变的。参见 <a href="https://design.raku.org/S05.html#Substitution">S05/替换</a>。</p>
<h3 id="sub-和-sub"><code>.sub</code> 和 <code>.sub!</code></h3>
<p>在 Raku 中，通常使用 <code>s///</code> 运算符来执行正则表达式替换。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">fixed</span> <span class="o">=</span> <span class="nb">line</span><span class="o">.</span><span class="k">sub</span><span class="p">(/</span><span class="sr">foo</span><span class="p">/</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">bar</span><span class="p">&#39;)</span>        <span class="c1"># Ruby, non-mutating</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fixed</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">subst</span><span class="p">(/</span><span class="sr">foo</span><span class="p">/</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">bar</span><span class="p">&#39;)</span> <span class="c1"># Raku, non-mutating</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">line</span><span class="o">.</span><span class="k">sub</span><span class="o">!</span><span class="p">(/</span><span class="sr">foo</span><span class="p">/</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">bar</span><span class="p">&#39;)</span>   <span class="c1"># Ruby, mutating</span>
</span></span><span class="line"><span class="cl"><span class="nv">$line</span> <span class="o">~~</span> <span class="k">s</span><span class="p">/</span><span class="sr">foo</span><span class="p">/</span><span class="s2">bar</span><span class="p">/;</span>      <span class="c1"># Raku, mutating</span>
</span></span></code></pre></div><h3 id="正则表达式选项">正则表达式选项</h3>
<p>将任何选项从正则表达式的结尾移动到开头。这可能需要您在 <code>/abc/</code> 等纯匹配中添加可选的 <code>m</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">next</span> <span class="k">if</span> <span class="nv">$line</span> <span class="o">=~</span>    <span class="o">/</span><span class="n">static</span><span class="o">/</span><span class="no">i</span> <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="nb">next</span> <span class="k">if</span> <span class="nv">$line</span> <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">i</span><span class="p">/</span><span class="sr">static</span><span class="p">/;</span> <span class="c1"># Raku</span>
</span></span></code></pre></div><h3 id="空格被忽略大多数东西必须被引起来">空格被忽略，大多数东西必须被引起来</h3>
<p>为了帮助可读性和可重用性，在 Raku 的正则表达式中，空格并不重要。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr">this is a test</span><span class="p">/</span> <span class="c1"># Ruby, boring string</span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr">this</span><span class="ni">.</span><span class="o">*</span><span class="p">/</span>         <span class="c1"># Ruby, possibly interesting string</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> this </span><span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span><span class="sr"> is </span><span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span><span class="sr"> a </span><span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span><span class="sr"> test </span><span class="p">/</span> <span class="c1"># Raku, each space is quoted</span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> </span><span class="p">&#34;</span><span class="s2">this is a test</span><span class="p">&#34;</span><span class="sr"> </span><span class="p">/</span> <span class="c1"># Raku, quoting the whole string</span>
</span></span><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> this </span><span class="ni">.</span><span class="o">*</span><span class="sr"> </span><span class="p">/</span>          <span class="c1"># Raku, possibly interesting string</span>
</span></span></code></pre></div><h3 id="特殊匹配器通常属于--语法">特殊匹配器通常属于 <code>&lt;&gt;</code> 语法</h3>
<p>Raku 的正则表达式有很多支持特殊匹配语法的情况。它们不会全部列在这里，但通常不是被 <code>()</code> 包围，断言将被 <code>&lt;&gt;</code> 包围。</p>
<p>对于字符类，这意味着：</p>
<ul>
<li><code>[abc]</code> 变为 <code>&lt;[abc]&gt;</code></li>
<li><code>[^abc]</code> 变为 <code>&lt;-[abc]&gt;</code></li>
<li><code>[a-zA-Z]</code> 变为 <code>&lt;[a..zA..Z]&gt;</code></li>
<li><code>[[:upper:]]</code> 变为 <code>&lt;:upper&gt;</code></li>
<li><code>[abc[:upper:]]</code> 变为 <code>&lt;[abc]+:Upper&gt;</code></li>
</ul>
<p>对于环视断言：</p>
<ul>
<li><code>(?=[abc])</code> 变为 <code>&lt;?[abc]&gt;</code></li>
<li><code>(?=ar?bitrary* pattern)</code> 变为 <code>&lt;before ar?bitrary* pattern&gt;</code></li>
<li><code>(?!=[abc])</code> 变为 <code>&lt;![abc]&gt;</code></li>
<li><code>(?!=ar?bitrary* pattern)</code> 变为 <code>&lt;!before ar?bitrary* pattern&gt;</code></li>
<li><code>(?&lt;=ar?bitrary* pattern)</code> 变为 <code>&lt;after ar?bitrary* pattern&gt;</code></li>
<li><code>(?&lt;!ar?bitrary* pattern)</code> 变为 <code>&lt;!after ar?bitrary* pattern&gt;</code></li>
<li><code>(Unrelated to &lt;&gt; syntax, the &quot;lookaround&quot; /foo\Kbar/</code> 变为 <code>/foo &lt;( bar )&gt; /</code></li>
<li><code>(?(?{condition))yes-pattern|no-pattern)</code> 变为 <code>[ &lt;?{condition}&gt; yes-pattern | no-pattern ]</code></li>
</ul>
<h3 id="最长令牌匹配ltm替代交替">最长令牌匹配（LTM）替代交替</h3>
<p>在 Raku regexes 中，<code>|</code> 执行最长令牌匹配（LTM），它决定哪个备选分支根据一组规则赢得模棱两可的匹配，而不是根据在正则表达式中首先写出哪个备选分支。</p>
<p>要避免新的逻辑，请在你的 Ruby 正则表达式中把任何 <code>|</code> 更改为 <code>||</code>。</p>
<h2 id="文件相关操作">文件相关操作</h2>
<h3 id="将文本文件的行读入数组">将文本文件的行读入数组</h3>
<p>Ruby 和 Raku 都很容易将文件中的所有行读取到单个变量中，在这两种情况下，每一行都删除了换行符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">lines</span> <span class="o">=</span> <span class="n">File</span><span class="o">.</span><span class="nf">readlines</span><span class="p">(&#34;</span><span class="s2">file</span><span class="p">&#34;)</span>   <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@lines</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">file</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>     <span class="c1"># Raku, create an IO object from a string</span>
</span></span></code></pre></div><h3 id="迭代文本文件的行">迭代文本文件的行</h3>
<p>不建议将整个文件读入内存。 Raku 中的 <code>.lines</code> 方法返回一个延迟序列，但是赋值给数组会强制读取文件。最好迭代结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="n">File</span><span class="o">.</span><span class="nf">foreach</span><span class="p">(&#34;</span><span class="s2">file</span><span class="p">&#34;)</span> <span class="nb">do</span> <span class="o">|</span><span class="nb">line</span><span class="o">|</span>
</span></span><span class="line"><span class="cl">    <span class="n">puts</span> <span class="nb">line</span>
</span></span><span class="line"><span class="cl"><span class="nb">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">&#34;</span><span class="s2">file</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$line</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="面向对象">面向对象</h2>
<h3 id="基本类方法属性">基本类，方法，属性</h3>
<p>在 Ruby 和 Raku 之间类的定义是相似的。 Ruby 使用 <code>def</code> 定义方法，而 Raku 使用 <code>method</code> 定义方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Foo</span>
</span></span><span class="line"><span class="cl">    <span class="n">def</span> <span class="nf">greet</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">puts</span> <span class="p">&#34;</span><span class="s2">Hi #</span><span class="p">{</span><span class="nb">name</span><span class="p">}</span><span class="s2">!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">end</span>
</span></span><span class="line"><span class="cl"><span class="nb">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">greet</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hi </span><span class="nv">$name</span><span class="s2">!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在 Ruby 中，你可以使用一个属性而不预先声明它，你可以告诉它这是一个属性，因为 <code>@</code> 符号。您还可以使用 <code>attr_accessor</code> 及其变体轻松创建访问器。在 Raku 中，你使用 <code>has</code> 声明符和各种符号。你可以使用 <code>!</code> twigil 作为私有属性或 <code>.</code> 创建一个访问器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span>
</span></span><span class="line"><span class="cl">    <span class="n">attr_accessor</span> <span class="p">:</span><span class="s">age</span>    <span class="c1"># Declare .age as an accessor method for @age</span>
</span></span><span class="line"><span class="cl">    <span class="n">def</span> <span class="n">initialize</span>
</span></span><span class="line"><span class="cl">        <span class="nv">@name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">default</span><span class="p">&#39;</span> <span class="c1"># Assign default value to private instance var</span>
</span></span><span class="line"><span class="cl">    <span class="nb">end</span>
</span></span><span class="line"><span class="cl"><span class="nb">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.age</span><span class="p">;</span>              <span class="c1"># Declare $!age and accessor methods</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">default</span><span class="p">&#39;;</span> <span class="c1"># Assign default value to private instance var</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>使用 <code>.new</code> 方法创建类的新实例。在 Ruby 中，您必须在 <code>initialize</code> 内根据需要手动给实例变量赋值。在 Raku 中，您将获得一个接受访问器属性的键/值对的默认构造函数，并可以在 <code>BUILD</code> 方法中进一步设置。像 Ruby 一样，你可以重写 <code>new</code> 自身以获取更高级的功能，但这是罕见的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span>
</span></span><span class="line"><span class="cl">    <span class="n">attr_accessor</span> <span class="p">:</span><span class="s">name</span><span class="o">,</span> <span class="p">:</span><span class="s">age</span>
</span></span><span class="line"><span class="cl">    <span class="n">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nv">@name</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">[</span><span class="p">:</span><span class="s">name</span><span class="o">]</span> <span class="o">||</span> <span class="p">&#39;</span><span class="s1">Jill</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">@age</span>  <span class="o">=</span> <span class="n">attrs</span><span class="o">[</span><span class="p">:</span><span class="s">age</span><span class="o">]</span> <span class="o">||</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl">        <span class="nv">@birth_year</span> <span class="o">=</span> <span class="n">Time</span><span class="o">.</span><span class="nb">now</span><span class="o">.</span><span class="nb">year</span> <span class="o">-</span> <span class="nv">@age</span>
</span></span><span class="line"><span class="cl">    <span class="nb">end</span>
</span></span><span class="line"><span class="cl"><span class="nb">end</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="nb">name</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">Jack</span><span class="p">&#39;</span><span class="o">,</span> <span class="n">age:</span> <span class="mi">23</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Jill</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.age</span>  <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!birth_year</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">BUILD</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!birth_year</span> <span class="o">=</span> <span class="nb">now</span><span class="o">.</span><span class="kt">Date</span><span class="o">.</span><span class="nb">year</span> <span class="o">-</span> <span class="nv">$.age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">p = Person.new( name =&gt; &#39;Jack&#39;, age =&gt; 23 )
</span></span></span></code></pre></div><h3 id="私有方法">私有方法</h3>
<p>Raku 中的私有方法声明的时候在他们的名字前置一个 <code>!</code> 符号，并且调用的时候使用 <code>!</code> 代替 <code>.</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Foo</span>
</span></span><span class="line"><span class="cl">    <span class="n">def</span> <span class="n">visible</span>
</span></span><span class="line"><span class="cl">        <span class="n">puts</span> <span class="p">&#34;</span><span class="s2">I can be seen!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">hidden</span>
</span></span><span class="line"><span class="cl">    <span class="nb">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">private</span>
</span></span><span class="line"><span class="cl">    <span class="n">def</span> <span class="nb">hidden</span>
</span></span><span class="line"><span class="cl">        <span class="n">puts</span> <span class="p">&#34;</span><span class="s2">I cannot easily be called!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">end</span>
</span></span><span class="line"><span class="cl"><span class="nb">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">visible</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I can be seen!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">self</span><span class="o">!</span><span class="nb">hidden</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">!hidden</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I cannot easily be called!</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>一个重要的注意事项是，在 Ruby 中孩子对象可以看到父对象中的私有方法（所以他们更像是其他语言中的&quot;受保护&quot;的方法）。在 Raku 中，孩子对象不能调用父对象中的私有方法。</p>
<h3 id="元">元</h3>
<p>这里有一些元编程的例子。注意，Raku 将元方法与常规方法分离开了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">person</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="nb">new</span>       <span class="c1"># Ruby, create a new person</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$person</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="nb">new</span>   <span class="c1"># Raku, create a new person</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">person</span><span class="o">.</span><span class="k">class</span>              <span class="c1"># Ruby, returns Person (class)</span>
</span></span><span class="line"><span class="cl"><span class="nv">$person</span><span class="o">.</span><span class="nb">WHAT</span>              <span class="c1"># Raku, returns Person (class)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">person</span><span class="o">.</span><span class="nb">methods</span>            <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="nv">$person</span><span class="o">.^</span><span class="nb">methods</span>          <span class="c1"># Raku, using .^ syntax to access meta-methods</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">person</span><span class="o">.</span><span class="nf">instance_variables</span> <span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="nv">$person</span><span class="o">.^</span><span class="nb">attributes</span>       <span class="c1"># Raku</span>
</span></span></code></pre></div><p>像 Ruby 一样，在 Raku 中，一切都是对象，但并不是所有的操作都等同于 <code>.send</code>。许多运算符是使用类型化多重分派（具有类型的函数签名）来决定使用哪个实现的全局函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">5</span><span class="o">.</span><span class="nb">send</span><span class="p">(</span><span class="o">:+,</span> <span class="mi">3</span><span class="p">)</span>    <span class="c1"># =&gt; 8, Ruby</span>
</span></span><span class="line"><span class="cl"><span class="o">&amp;[+]</span><span class="p">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span>       <span class="c1"># =&gt; 8, Raku, reference to infix addition operator</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&amp;[+].^</span><span class="nb">candidates</span> <span class="c1"># Raku, lists all signatures for the + operator</span>
</span></span></code></pre></div><p>有关更多详细信息，请参阅<a href="https://docs.raku.org/language/mop">元对象协议</a>。</p>
<h2 id="环境变量">环境变量</h2>
<h3 id="perl-模块库路径">Perl 模块库路径</h3>
<p>在 Ruby 中，为模块指定额外搜索路径的环境变量之一是 <code>RUBYLIB</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="cl"><span class="err">$</span> <span class="no">RUBYLIB</span><span class="o">=</span><span class="s2">&#34;/some/module/lib&#34;</span> <span class="n">ruby</span> <span class="n">program</span><span class="o">.</span><span class="n">rb</span>
</span></span></code></pre></div><p>在 Raku 中，这是相似的，你只需要更改名称。正如你可能猜到的，你只需要使用 <code>PERL6LIB</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="n">PERL6LIB</span><span class="o">=</span><span class="p">&#34;</span><span class="s2">/some/module/lib</span><span class="p">&#34;</span> <span class="nb">raku</span> <span class="n">program</span><span class="o">.</span><span class="nf">p6</span>
</span></span></code></pre></div><p>与 Ruby 一样，如果不指定 <code>PERL6LIB</code>，则需要通过 <code>use lib</code> 指令在程序中指定库路径：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Ruby and Raku</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">lib</span> <span class="p">&#39;</span><span class="s1">/some/module/lib</span><span class="p">&#39;;</span>
</span></span></code></pre></div><h2 id="misc">Misc.</h2>
<h3 id="从模块导入特定函数">从模块导入特定函数</h3>
<p>在 Ruby 中没有内置的方法来选择性地从模块中导入/导出方法。</p>
<p>在 Raku 中，通过在相关的 subs 上使用 &ldquo;is export&rdquo; 角色来指定要导出的函数，然后导出所有具有此角色的 subs。因此，下面的 <code>Bar</code> 模块导出 subs <code>foo</code> 和 <code>bar</code>，但不导出 <code>baz</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">unit</span> <span class="k">module</span> <span class="nn">Bar</span><span class="p">;</span> <span class="c1"># remainder of the file is in module Bar { ... }</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foo </span><span class="nv">$a</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">bar</span><span class="p">(</span><span class="nv">$b</span><span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">bar </span><span class="nv">$b</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">baz</span><span class="p">(</span><span class="nv">$z</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">baz </span><span class="nv">$z</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span></code></pre></div><p>要使用此模块，只需 <code>use Bar</code>，函数 <code>foo</code> 和 <code>bar</code> 将可用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Bar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>    <span class="c1">#=&gt; &#34;foo 1&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nf">bar</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>    <span class="c1">#=&gt; &#34;bar 2&#34;</span>
</span></span></code></pre></div><p>如果您尝试使用 <code>baz</code>， 那么在编译时会引发 &ldquo;Undeclared routine&rdquo; 的错误。</p>
<p>一些模块允许选择性地导入函数，它们看起来像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Bar</span> <span class="p">&lt;</span><span class="s">foo</span><span class="p">&gt;;</span> <span class="c1"># Import only foo</span>
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>        <span class="c1">#=&gt; &#34;foo 1&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nf">bar</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>        <span class="c1"># Error!</span>
</span></span></code></pre></div><h2 id="optionparser解析命令行标志">OptionParser，解析命令行标志</h2>
<p>Raku 中的命令行参数开关解析由 <code>MAIN</code> 子例程的参数列表完成。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Ruby</span>
</span></span><span class="line"><span class="cl"><span class="k">require</span> <span class="p">&#39;</span><span class="s1">optparse</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="n">OptionParser</span><span class="o">.</span><span class="nb">new</span> <span class="nb">do</span> <span class="o">|</span><span class="n">opts</span><span class="o">|</span>
</span></span><span class="line"><span class="cl">    <span class="n">opts</span><span class="o">.</span><span class="nf">banner</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Usage: example.rb --length=abc</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="n">opts</span><span class="o">.</span><span class="nf">on</span><span class="p">(&#34;</span><span class="s2">--length</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Set the file</span><span class="p">&#34;)</span> <span class="nb">do</span> <span class="o">|</span><span class="n">length</span><span class="o">|</span>
</span></span><span class="line"><span class="cl">        <span class="n">raise</span> <span class="p">&#34;</span><span class="s2">Length must be &gt; 0</span><span class="p">&#34;</span> <span class="k">unless</span> <span class="n">length</span><span class="o">.</span><span class="nf">to_i</span> <span class="o">&gt;</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="n">options</span><span class="o">[</span><span class="p">:</span><span class="s">length</span><span class="o">]</span> <span class="o">=</span> <span class="n">length</span>
</span></span><span class="line"><span class="cl">    <span class="nb">end</span>
</span></span><span class="line"><span class="cl">    <span class="n">opts</span><span class="o">.</span><span class="nf">on</span><span class="p">(&#34;</span><span class="s2">--filename</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Set the file</span><span class="p">&#34;)</span> <span class="nb">do</span> <span class="o">|</span><span class="nb">filename</span><span class="o">|</span>
</span></span><span class="line"><span class="cl">        <span class="n">options</span><span class="o">[</span><span class="p">:</span><span class="s">file</span><span class="o">]</span> <span class="o">=</span> <span class="nb">filename</span>
</span></span><span class="line"><span class="cl">    <span class="nb">end</span>
</span></span><span class="line"><span class="cl">    <span class="n">opts</span><span class="o">.</span><span class="nf">on</span><span class="p">(&#34;</span><span class="s2">--verbose</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Increase verbosity</span><span class="p">&#34;)</span> <span class="nb">do</span> <span class="o">|</span><span class="n">verbose</span><span class="o">|</span>
</span></span><span class="line"><span class="cl">        <span class="n">options</span><span class="o">[</span><span class="p">:</span><span class="s">verbose</span><span class="o">]</span> <span class="o">=</span> <span class="n">true</span>
</span></span><span class="line"><span class="cl">    <span class="nb">end</span>
</span></span><span class="line"><span class="cl"><span class="nb">end</span><span class="o">.</span><span class="nb">parse</span><span class="o">!</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">puts</span> <span class="n">options</span><span class="o">[</span><span class="p">:</span><span class="s">length</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="n">puts</span> <span class="n">options</span><span class="o">[</span><span class="p">:</span><span class="s">filename</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="n">puts</span> <span class="p">&#39;</span><span class="s1">Verbosity </span><span class="p">&#39;</span><span class="o">,</span> <span class="p">(</span><span class="n">options</span><span class="o">[</span><span class="p">:</span><span class="s">verbose</span><span class="o">]</span> <span class="o">?</span> <span class="p">&#39;</span><span class="s1">on</span><span class="p">&#39;</span> <span class="o">:</span> <span class="p">&#39;</span><span class="s1">off</span><span class="p">&#39;)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ruby</span> <span class="n">example</span><span class="o">.</span><span class="nf">rb</span> <span class="o">--</span><span class="n">filename</span><span class="o">=</span><span class="n">foo</span> <span class="o">--</span><span class="n">length</span><span class="o">=</span><span class="mi">42</span> <span class="o">--</span><span class="n">verbose</span>
</span></span><span class="line"><span class="cl">    <span class="mi">42</span>
</span></span><span class="line"><span class="cl">    <span class="n">foo</span>
</span></span><span class="line"><span class="cl">    <span class="n">Verbosity</span> <span class="n">on</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ruby</span> <span class="n">example</span><span class="o">.</span><span class="nf">rb</span> <span class="o">--</span><span class="n">length</span><span class="o">=</span><span class="n">abc</span>
</span></span><span class="line"><span class="cl">    <span class="n">Length</span> <span class="n">must</span> <span class="n">be</span> <span class="o">&gt;</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span> <span class="kt">Int</span> <span class="o">:</span><span class="nv">$length</span> <span class="k">where</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="p">:</span><span class="s">filename</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">file.dat</span><span class="p">&#39;</span><span class="o">,</span> <span class="kt">Bool</span> <span class="o">:</span><span class="nv">$verbose</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Verbosity </span><span class="p">&#39;</span><span class="o">,</span> <span class="p">(</span><span class="nv">$verbose</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">on</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">off</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">raku</span> <span class="n">example</span><span class="o">.</span><span class="nf">p6</span> <span class="o">--</span><span class="n">file</span><span class="o">=</span><span class="n">foo</span> <span class="o">--</span><span class="n">length</span><span class="o">=</span><span class="mi">42</span> <span class="o">--</span><span class="n">verbose</span>
</span></span><span class="line"><span class="cl">    <span class="mi">42</span>
</span></span><span class="line"><span class="cl">    <span class="n">foo</span>
</span></span><span class="line"><span class="cl">    <span class="n">Verbosity</span> <span class="n">on</span>
</span></span><span class="line"><span class="cl"><span class="nb">raku</span> <span class="n">example</span><span class="o">.</span><span class="nf">p6</span> <span class="o">--</span><span class="n">length</span><span class="o">=</span><span class="nf">abc</span>
</span></span><span class="line"><span class="cl">    <span class="n">Usage:</span>
</span></span><span class="line"><span class="cl">      <span class="n">c</span><span class="o">.</span><span class="nf">p6</span> <span class="o">[--</span><span class="n">length</span><span class="o">=</span><span class="p">&lt;</span><span class="s">Int</span><span class="p">&gt;</span><span class="o">]</span> <span class="o">[--</span><span class="n">file</span><span class="o">=</span><span class="p">&lt;</span><span class="s">Any</span><span class="p">&gt;</span><span class="o">]</span> <span class="o">[--</span><span class="n">verbose</span><span class="o">]</span>
</span></span></code></pre></div><p>注意，Raku 在命令行解析错误时会自动生成一个完整的使用消息。</p>
<h2 id="rubygems外部库">RubyGems，外部库</h2>
<p>请参阅 <a href="https://modules.raku.org/">https://modules.raku.org/</a>，其中提供了越来越多的 Raku 库以及管理它们的工具。</p>
<p>如果您使用的模块尚未转换为 Raku，并且本文档中未列出任何备选方案，那么它在 Raku 下的使用可能尚未解决。</p>
<p>你可以尝试使用 <code>Inline::Ruby</code> 从 Raku 程序中调用现有的 Ruby 代码。这使用 ruby 解释器的嵌入式实例来运行从 Raku 脚本调用的 Ruby 代码。注意，这是一个 EXPERIMENTAL 库。类似地你可以使用 <code>Inline::Perl5</code>，<code>Inline::Python</code> 和其他调用其他语言的库。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Python 到 Raku - 简而言之]]></title>
            <link href="http://localhost:1313/rakulang/11.python-to-perl6---nutshell/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/9.haskell-to-perl-6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Haskell 到 Raku - 简而言之" />
                <link href="http://localhost:1313/rakulang/10.javascript-node.js-to-perl-6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Javascript(Node.js) 到 Raku - 简而言之" />
                <link href="http://localhost:1313/rakulang/8.perl-5-to-perl-6-guide---special-variables/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 特殊变量" />
                <link href="http://localhost:1313/rakulang/7.perl-5-to-perl-6-guide---syntax/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 语法" />
                <link href="http://localhost:1313/rakulang/6.perl-5-to-perl-6-guide---operators/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 运算符" />
            
                <id>http://localhost:1313/rakulang/11.python-to-perl6---nutshell/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-17T21:13:31+08:00</published>
            <updated>2018-10-17T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>此页面试图为来自 Python 背景的人们提供学习 Raku 的方法。我们在 Raku 中讨论了许多 Python 构造和惯用法的等价语法。</p>
<h2 id="基本语法">基本语法</h2>
<h3 id="hello-world">Hello, world</h3>
<p>让我们从打印 &ldquo;Hello, world!&rdquo; 开始吧。 Raku 中的 <a href="https://docs.raku.org/routine/put">put</a> 关键字相当于 Python 中的 <a href="https://docs.raku.org/routine/print">print</a>。与 Python 2 一样，括号是可选的。换行符添加到行尾。</p>
<ul>
<li>Python 2</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">print</span> <span class="s2">&#34;Hello, world!&#34;</span>
</span></span></code></pre></div><ul>
<li>Python 3</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Hello, world!&#34;</span><span class="p">)</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">put</span> <span class="p">&#34;</span><span class="s2">Hello, world!</span><span class="p">&#34;</span>
</span></span></code></pre></div><p>还有 <a href="https://docs.raku.org/routine/say">say</a> 关键字，其行为类似，但会调用其参数的 <a href="https://docs.raku.org/routine/gist">gist</a> 方法。</p>
<ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$hello</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Hello, world!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$hello</span><span class="p">;</span>  <span class="c1"># also prints &#34;Hello, world!&#34; </span>
</span></span><span class="line"><span class="cl">             <span class="c1"># same as: put $hello.gist </span>
</span></span></code></pre></div><p>在 Python 中 <code>'</code> 和 <code>&quot;</code> 是可互换的。在 Raku 中两者都可用于引用, 但双引号(<code>&quot;</code>)表示应该进行插值。例如, 以 <code>$</code> 开头的变量和包含在花括号中的表达式会被插值。</p>
<ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$planet</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">earth</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, </span><span class="nv">$planet</span><span class="p">&#34;;</span>   <span class="c1"># Hello, earth </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Hello, $planet</span><span class="p">&#39;;</span>   <span class="c1"># Hello, $planet </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, planet number </span><span class="p">{</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">}&#34;;</span> <span class="c1"># Hello, planet number 3 </span>
</span></span></code></pre></div><h3 id="语句分隔符">语句分隔符</h3>
<p>在 Python 中，换行符表示语句的结束。有一些例外：换行符之前的反斜杠继续跨行语句。此外，如果有一个不匹配的开括号，方括号或花括号，则该语句将继续跨行，直到匹配的花括号被关闭。</p>
<p>在 Raku 中，分号表示语句的结束。如果分号是块的最后一个语句，则可以省略分号。如果有一个结束花括号后跟换行符，也可以省略分号。</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">print</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> \
</span></span><span class="line"><span class="cl">    <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">    <span class="mi">2</span> <span class="p">)</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">    <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">1</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">    <span class="mi">2</span><span class="p">;</span>
</span></span></code></pre></div><h3 id="块儿">块儿</h3>
<p>在 Python 中，缩进用于表示块。 Raku 使用花括号表示块儿。</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="s2">&#34;Wait, what?&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="s2">&#34;1 is not 2.&#34;</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Wait, what?</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">1 is not 2.</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对于条件句中的表达式，括号在两种语言中都是可选的，如上所示。</p>
<h3 id="变量">变量</h3>
<p>在 Python 中，变量是同时声明和初始化的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">foo</span> <span class="o">=</span> <span class="mi">12</span>
</span></span><span class="line"><span class="cl"><span class="n">bar</span> <span class="o">=</span> <span class="mi">19</span>
</span></span></code></pre></div><p>在 Raku 中，<code>my</code> 声明符声明了一个词法变量。变量可以用 <code>=</code> 初始化。此变量可以先声明，然后再初始化或声明并立即初始化。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$foo</span><span class="p">;</span>       <span class="c1"># declare </span>
</span></span><span class="line"><span class="cl"><span class="nv">$foo</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>     <span class="c1"># initialize </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$bar</span> <span class="o">=</span> <span class="mi">19</span><span class="p">;</span>  <span class="c1"># both at once </span>
</span></span></code></pre></div><p>此外，你可能已经注意到，Raku 中的变量通常以符号开头 - 符号表示其容器的类型。 以 <code>$</code> 开头的变量持有标量。 以 <code>@</code> 开头的变量持有数组和以 <code>%</code> 开头的变量持有一个 hash(dict)。 如果用 <code>\</code> 声明它们，则不可变变量可以是无符号的。</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">s</span> <span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span> <span class="o">=</span> <span class="p">{</span> <span class="n">a</span> <span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="n">b</span> <span class="p">:</span> <span class="mi">99</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="n">s</span> 
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 10, 2, 12 </span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@l</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%d</span> <span class="o">=</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">12</span><span class="o">,</span> <span class="s">b</span> <span class="o">=&gt;</span> <span class="mi">99</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\x</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@l</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%d</span><span class="p">&lt;</span><span class="s">a</span><span class="p">&gt;;</span>  <span class="c1"># or %d{&#39;a&#39;} </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 10, 2, 12, 99 </span>
</span></span></code></pre></div><h3 id="作用域">作用域</h3>
<p>在 Python 中，函数和类创建一个新的作用域，但没有其他的块构造函数（例如循环，条件）创建一个作用域。在 Python 2 中，列表推导不会创建新的作用域，但在 Python 3 中，它们创建新的作用域。</p>
<p>在 Raku 中，每个块都创建了一个词法作用域</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl"><span class="c1"># x is now 10 </span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="kt">True</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span>
</span></span><span class="line"><span class="cl"><span class="c1"># error, $x is not declared in this scope </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="kt">True</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$x</span> <span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ok, $x is 10 </span>
</span></span></code></pre></div><ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">   <span class="k">pass</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl"><span class="c1"># x is 3 </span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="k">-&gt;</span> \<span class="nb">x</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># do nothing </span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># x is 10 </span>
</span></span></code></pre></div><p>Python 中的 Lambdas 可以在 Raku 中写为块或尖号块。</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">l</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">12</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$l</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span> <span class="nv">$i</span> <span class="o">+</span> <span class="mi">12</span> <span class="p">}</span>
</span></span></code></pre></div><p>构建 lambdas 的另一个Raku 惯用法是使用 Whatever star, <code>*</code>。</p>
<ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$l</span> <span class="o">=</span> <span class="o">*</span> <span class="o">+</span> <span class="mi">12</span>    <span class="c1"># same as above </span>
</span></span></code></pre></div><p>表达式中的 <code>*</code> 将成为参数的占位符，并在编译时将表达式转换为 lambda。 表达式中的每个 <code>*</code> 都是一个单独的位置参数。</p>
<p>有关子例程和块的更多结构，请参阅以下部分。</p>
<p>另一个例子(来自Python <a href="https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result">FAQ</a>):</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">squares</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="n">squares</span><span class="p">[</span><span class="mi">4</span><span class="p">]()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># both 16 since there is only one x </span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\squares</span> <span class="o">=</span> <span class="o">[]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">^</span><span class="mi">5</span> <span class="k">-&gt;</span> \<span class="nb">x</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">squares</span><span class="o">.</span><span class="nb">append</span><span class="p">({</span> <span class="nb">x</span>² <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">squares</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">squares</span><span class="o">[</span><span class="mi">4</span><span class="o">]</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 4, 16 since each loop iteration has a lexically scoped x, </span>
</span></span></code></pre></div><p>注意，<code>^N</code> 类似于 <code>range(N)</code>。 类似地，<code>N..^M</code> 的作用类似于 <code>range(N,M)</code>（从 N 到 M-1 的列表）。 范围 <code>N..M</code> 是从 N 到 M 的列表。<code>..</code> 之前或之后的 <code>^</code> 表示应排除列表的开始或结束端点（或两者都）。</p>
<p>另外，<code>x²</code> 是一种编写 <code>x ** 2</code> 的可爱方式（也可以正常工作）; unicode 上标 2 是一个数字。 许多其他 unicode 运算符正如你所期望的那样工作(指数, 分数, π)，但是可以在 Raku 中使用的每个 unicode 运算符或符号都具有 ASCII 等价物。</p>
<h3 id="控制流">控制流</h3>
<p>Python 有 <code>for</code> 循环和 <code>while</code> 循环:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl"><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="n">j</span>
</span></span><span class="line"><span class="cl">    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 1,2,1,2    </span>
</span></span></code></pre></div><p>Raku 也有 <code>for</code> 循环和 <code>while</code> 循环:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$i</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="nv">$j</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$j</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(Raku 还有一些循环结构：<code>repeat ... until</code>，<code>repeat ... while</code>，<code>until</code> 和 <code>loop</code>。)</p>
<p><code>last</code> 在 Raku 中退出一个循环，类似于 Python 中的 <code>break</code>。 Python 中的 <code>continue</code> 在 Raku 中是 <code>next</code>。</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">continue</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="n">i</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="o">^</span><span class="mi">10</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">next</span> <span class="k">if</span> <span class="nv">$i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">last</span> <span class="k">if</span> <span class="nv">$i</span> <span class="o">==</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>使用 <code>if</code> 作为语句修饰符(如上所述)在 Raku 中是可接受的，甚至在列表解析之外也可以。</p>
<p>Python <code>for</code> 循环中的 <code>yield</code> 语句生成一个 <code>generator</code>，就像 Raku 中的 <code>gather/take</code> 构造一样。这两个都打印 1,2,3。</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">count</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">yield</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">count</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="n">c</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">count</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">gather</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">take</span> <span class="nv">$i</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nb">count</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$c</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="lambdas-函数和子例程">Lambdas， 函数和子例程</h3>
<p>在 Python 中用 <code>def</code> 声明的函数（子例程）在 Raku 中是用 <code>sub</code> 来完成的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">def</span> <span class="nb">add</span><span class="p">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">add</span><span class="p">(</span>\<span class="n">a</span><span class="o">,</span> \<span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>return</code> 是可选的; 最后一个表达式的值被用作返回值:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">add</span><span class="p">(</span>\<span class="n">a</span><span class="o">,</span> \<span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># using variables with sigils </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">add</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以使用位置参数或关键字参数调用 Python 2 函数。这些是由调用者决定的。在 Python 3 中，一些参数可能是&quot;keyword only&quot;的。在 Raku 中，位置参数和命名参数由例程的签名确定。</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">speak</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span> <span class="n">word</span>
</span></span><span class="line"><span class="cl"><span class="n">speak</span><span class="p">(</span><span class="s1">&#39;hi&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">speak</span><span class="p">(</span><span class="n">word</span><span class="o">=</span><span class="s1">&#39;hi&#39;</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<p>位置参数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">speak</span><span class="p">(</span><span class="nv">$word</span><span class="o">,</span> <span class="nv">$times</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nb">say</span> <span class="nv">$word</span> <span class="k">for</span> <span class="o">^</span><span class="nv">$times</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">speak</span><span class="p">(&#39;</span><span class="s1">hi</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span></code></pre></div><p>以冒号开头的命名参数:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">speak</span><span class="p">(</span><span class="o">:</span><span class="nv">$word</span><span class="o">,</span> <span class="o">:</span><span class="nv">$times</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nb">say</span> <span class="nv">$word</span> <span class="k">for</span> <span class="o">^</span><span class="nv">$times</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">speak</span><span class="p">(</span><span class="s">word</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">hi</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">times</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">speak</span><span class="p">(:</span><span class="s">word</span><span class="p">&lt;</span><span class="s">hi</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">times</span><span class="p">&lt;</span><span class="s">2</span><span class="p">&gt;);</span>      <span class="c1"># Alternative, more idiomatic </span>
</span></span></code></pre></div><p>Raku 支持多重分派，因此可以通过将例程声明为 <code>multi</code> 来提供多个签名。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">speak</span><span class="p">(</span><span class="nv">$word</span><span class="o">,</span> <span class="nv">$times</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nb">say</span> <span class="nv">$word</span> <span class="k">for</span> <span class="o">^</span><span class="nv">$times</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">speak</span><span class="p">(</span><span class="o">:</span><span class="nv">$word</span><span class="o">,</span> <span class="o">:</span><span class="nv">$times</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">speak</span><span class="p">(</span><span class="nv">$word</span><span class="o">,</span> <span class="nv">$times</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">speak</span><span class="p">(&#39;</span><span class="s1">hi</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">speak</span><span class="p">(:</span><span class="s">word</span><span class="p">&lt;</span><span class="s">hi</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">times</span><span class="p">&lt;</span><span class="s">2</span><span class="p">&gt;);</span>
</span></span></code></pre></div><p>可以使用多种格式发送命名参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">hello</span> <span class="p">{</span><span class="o">...</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1"># all the same </span>
</span></span><span class="line"><span class="cl"><span class="nf">hello</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;);</span> <span class="c1"># fat arrow syntax </span>
</span></span><span class="line"><span class="cl"><span class="nf">hello</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">world</span><span class="p">&#39;));</span>  <span class="c1"># pair constructor </span>
</span></span><span class="line"><span class="cl"><span class="n">hello</span> <span class="p">:</span><span class="s">name</span><span class="p">&lt;</span><span class="s">world</span><span class="p">&gt;;</span>     <span class="c1"># &lt;&gt; quotes words and makes a list </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nf">hello</span><span class="p">(</span><span class="o">:</span><span class="nv">$name</span><span class="p">);</span>          <span class="c1"># lexical var with the same name </span>
</span></span></code></pre></div><p>创建匿名函数可以使用带有块或尖号块的 <code>sub</code> 来完成。</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">square</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$square</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">};</span>  <span class="c1"># anonymous sub </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$square</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="nv">$x</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">};</span>     <span class="c1"># pointy block </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$square</span> <span class="o">=</span> <span class="p">{</span> <span class="nv">$^x</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">};</span>          <span class="c1"># placeholder variable </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$square</span> <span class="o">=</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">};</span>           <span class="c1"># topic variable </span>
</span></span></code></pre></div><p>占位符变量按字典顺序排列以形成位置参数。 因此这些是相同的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$power</span> <span class="o">=</span> <span class="p">{</span> <span class="nv">$^x</span> <span class="o">**</span> <span class="nv">$^y</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$power</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="nv">$x</span><span class="o">,</span> <span class="nv">$y</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">**</span> <span class="nv">$y</span> <span class="p">};</span>
</span></span></code></pre></div><h3 id="列表解析">列表解析</h3>
<p>可以组合 Postfix 语句修饰符和块以在 Raku 中轻松创建列表解析。</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">print</span> <span class="o">[</span> <span class="no">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="no">i</span> <span class="nb">in</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">9</span> <span class="o">]</span>                      <span class="c1"># OUTPUT: «[6, 18]␤» </span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span> <span class="nv">$_</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">9</span> <span class="p">);</span>                           <span class="c1"># OUTPUT: «(6 18)␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span> <span class="p">{</span> <span class="nv">$^i</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">}</span> <span class="k">for</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">9</span> <span class="p">);</span>                      <span class="c1"># OUTPUT: «(6 18)␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span> <span class="k">-&gt;</span> \<span class="no">i</span> <span class="p">{</span> <span class="no">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">}</span> <span class="k">for</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">9</span> <span class="p">);</span>                  <span class="c1"># OUTPUT: «(6 18)␤» </span>
</span></span></code></pre></div><p>可以应用条件，但 <code>if</code> 关键字首先出现，而不像 Python 那样，<code>if</code> 是第二个出现。</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">print</span> <span class="p">[</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">]</span>          <span class="c1"># OUTPUT: «[4, 6]␤» </span>
</span></span></code></pre></div><p>vs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span> <span class="nv">$_</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">if</span> <span class="nv">$_</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="p">);</span>              <span class="c1"># OUTPUT: «(4 6)␤» </span>
</span></span></code></pre></div><p>对于嵌套循环，交叉乘积运算符 <code>X</code> 将会有帮助：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">print</span> <span class="p">[</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">3</span><span class="p">,</span><span class="mi">9</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="mi">2</span><span class="p">,</span><span class="mi">10</span> <span class="p">]</span>         <span class="c1"># OUTPUT: «[5, 13, 11, 19]␤» </span>
</span></span></code></pre></div><p>变成以下任何一个：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span> <span class="p">{</span> <span class="nv">$_</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="nv">$_</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="p">}</span> <span class="k">for</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">9</span><span class="p">)</span> <span class="ow">X</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">10</span><span class="p">)</span> <span class="p">);</span>      <span class="c1"># OUTPUT: «(5 13 11 19)␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span> <span class="k">-&gt;</span> <span class="p">(</span>\<span class="no">i</span><span class="o">,</span> \<span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="no">i</span> <span class="o">+</span> <span class="n">j</span> <span class="p">}</span> <span class="k">for</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">9</span><span class="p">)</span> <span class="ow">X</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">10</span><span class="p">)</span> <span class="p">);</span>  <span class="c1"># OUTPUT: «(5 13 11 19)␤» </span>
</span></span></code></pre></div><p>使用 <code>map</code>（就像 Python 的 <code>map</code> 一样）和 <code>grep</code>（就像 Python 的 <code>filter</code> 一样）是另一种选择。</p>
<h3 id="类和对象">类和对象</h3>
<p>这是 Python <a href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables">文档</a>中的一个示例。首先让我们回顾一下&quot;实例变量&quot;，这些变量在 Raku 中称为属性:</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Dog</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对于每个创建的类，Raku 默认提供构造函数方法 <code>new</code>，它接受命名参数。</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$d</span> <span class="o">=</span> <span class="n">Dog</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">&lt;</span><span class="s">Fido</span><span class="p">&gt;);</span> <span class="c1"># or: Dog.new(name =&gt; &#39;Fido&#39;) </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$e</span> <span class="o">=</span> <span class="n">Dog</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">&lt;</span><span class="s">Buddy</span><span class="p">&gt;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$d</span><span class="o">.</span><span class="nb">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$e</span><span class="o">.</span><span class="nb">name</span><span class="p">;</span>
</span></span></code></pre></div><p>Raku 中的类属性可以通过几种方式声明。一种方法是仅声明一个词法变量和一个访问它的方法。</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;canine&#39;</span>                <span class="c1"># class attribute </span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>           <span class="c1"># instance attribute </span>
</span></span><span class="line"><span class="cl"><span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="n">d</span><span class="o">.</span><span class="n">kind</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="n">e</span><span class="o">.</span><span class="n">kind</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Dog</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$kind</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">canine</span><span class="p">&#39;;</span>           <span class="c1"># class attribute </span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">kind</span> <span class="p">{</span> <span class="nv">$kind</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>                    <span class="c1"># instance attribute </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$d</span> <span class="o">=</span> <span class="n">Dog</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">&lt;</span><span class="s">Fido</span><span class="p">&gt;);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$e</span> <span class="o">=</span> <span class="n">Dog</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">&lt;</span><span class="s">Buddy</span><span class="p">&gt;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$d</span><span class="o">.</span><span class="nf">kind</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$e</span><span class="o">.</span><span class="nf">kind</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$d</span><span class="o">.</span><span class="nb">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$e</span><span class="o">.</span><span class="nb">name</span><span class="p">;</span>
</span></span></code></pre></div><p>为了在 Raku 中改变属性，必须在属性上使用 <code>is rw</code> trait：</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;rover&#39;</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Dog</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.name</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$d</span> <span class="o">=</span> <span class="n">Dog</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$d</span><span class="o">.</span><span class="nb">name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">rover</span><span class="p">&#39;;</span>
</span></span></code></pre></div><p>继承使用 <code>is</code> 来完成:</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Animal</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">jump</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span> <span class="p">(</span><span class="s2">&#34;I am jumping&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Dog</span><span class="p">(</span><span class="n">Animal</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">pass</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span><span class="o">.</span><span class="n">jump</span><span class="p">()</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">jump</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I am jumping</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Dog</span> <span class="k">is</span> <span class="nc">Animal</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$d</span> <span class="o">=</span> <span class="n">Dog</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$d</span><span class="o">.</span><span class="nf">jump</span><span class="p">;</span>
</span></span></code></pre></div><p>根据需要多次使用 <code>is</code> trait 可以实现多重继承。或者，它可以与 <code>also</code> 关键字一起使用。</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Dog</span><span class="p">(</span><span class="n">Animal</span><span class="p">,</span> <span class="n">Friend</span><span class="p">,</span> <span class="n">Pet</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">pass</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{};</span> <span class="k">class</span> <span class="nc">Friend</span> <span class="p">{};</span> <span class="k">class</span> <span class="nc">Pet</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Dog</span> <span class="k">is</span> <span class="nc">Animal</span> <span class="k">is</span> <span class="nc">Friend</span> <span class="k">is</span> <span class="nc">Pet</span> <span class="p">{};</span>
</span></span></code></pre></div><p>或</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{};</span> <span class="k">class</span> <span class="nc">Friend</span> <span class="p">{};</span> <span class="k">class</span> <span class="nc">Pet</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Dog</span> <span class="k">is</span> <span class="nc">Animal</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">also</span> <span class="k">is</span> <span class="nc">Friend</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">also</span> <span class="k">is</span> <span class="nc">Pet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="装饰器">装饰器</h3>
<p>Python 中的装饰器是一种将函数包装在另一个函数中的方法。在 Raku 中，这是通过 <code>wrap</code> 完成的。</p>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">greeter</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">new</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span> <span class="s1">&#39;hello&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">new</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nd">@greeter</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">world</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="s1">&#39;world&#39;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">world</span><span class="p">();</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">world</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nv">&amp;world</span><span class="o">.</span><span class="nb">wrap</span><span class="p">(</span><span class="k">sub</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">hello</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">callsame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">world</span><span class="p">;</span>
</span></span></code></pre></div><p>另一种方法是使用 trait：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># declare the trait &#39;greeter&#39; </span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">trait_mod</span><span class="o">:</span><span class="p">&lt;</span><span class="s">is</span><span class="p">&gt;(</span><span class="kt">Routine</span> <span class="nv">$r</span><span class="o">,</span> <span class="o">:</span><span class="nv">$greeter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$r</span><span class="o">.</span><span class="nb">wrap</span><span class="p">(</span><span class="k">sub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">hello</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">callsame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="n">world</span> <span class="k">is</span> <span class="nc">greeter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">world</span><span class="p">;</span>
</span></span></code></pre></div><h3 id="上下文管理">上下文管理</h3>
<p>Python 中的上下文管理器声明了在进入或退出作用域时发生的操作。</p>
<p>这是一个 Python 上下文管理器，可以打印字符串&rsquo;hello&rsquo;，&lsquo;world&rsquo;和&rsquo;bye&rsquo;。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">hello</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span> <span class="s1">&#39;bye&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span> <span class="s1">&#39;hello&#39;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">with</span> <span class="n">hello</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="s1">&#39;world&#39;</span>
</span></span></code></pre></div><p>对于 &ldquo;enter&rdquo; 和 &ldquo;exit&rdquo; 事件，将块作为参数传递将是一种方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">hello</span><span class="p">(</span><span class="kt">Block</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">hello</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$b</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">bye</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">hello</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>一个相关的想法是&rsquo;<a href="https://docs.raku.org/language/phasers">Phasers</a>&rsquo;，它可以设置为在进入或离开一个区块时运行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">LEAVE</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">bye</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">ENTER</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">hello</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="input">input</h3>
<p>在 Python 3 中，<code>input</code> 关键字用于提示用户。可以为此关键字提供可选参数，该参数将写入标准输出而不带尾随换行符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">user_input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&#34;Say hi → &#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">user_input</span><span class="p">)</span>
</span></span></code></pre></div><p>出现提示时，您可以输入 <code>Hi</code> 或任何其他字符串，这些字符串将存储在 <code>user_input</code> 变量中。这类似于 Raku 中的 <a href="https://docs.raku.org/routine/prompt">prompt</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$user_input</span> <span class="o">=</span> <span class="nb">prompt</span><span class="p">(&#34;</span><span class="s2">Say hi → </span><span class="p">&#34;);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$user_input</span><span class="p">;</span> <span class="c1"># OUTPUT: whatever you entered. </span>
</span></span></code></pre></div><p>原文： <a href="https://docs.raku.org/language/py-nutshell">https://docs.raku.org/language/py-nutshell</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Haskell 到 Raku - 简而言之]]></title>
            <link href="http://localhost:1313/rakulang/9.haskell-to-perl-6---nutshell/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/10.javascript-node.js-to-perl-6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Javascript(Node.js) 到 Raku - 简而言之" />
                <link href="http://localhost:1313/rakulang/8.perl-5-to-perl-6-guide---special-variables/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 特殊变量" />
                <link href="http://localhost:1313/rakulang/7.perl-5-to-perl-6-guide---syntax/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 语法" />
                <link href="http://localhost:1313/rakulang/6.perl-5-to-perl-6-guide---operators/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 运算符" />
                <link href="http://localhost:1313/rakulang/4.perl-5-to-perl-6-guide---overview/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 概览" />
            
                <id>http://localhost:1313/rakulang/9.haskell-to-perl-6---nutshell/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-16T21:13:31+08:00</published>
            <updated>2018-10-16T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>Haskell 和 Raku 是非常不同的语言。这很明显。 但是，这并不意味着没有相似之处或共同的想法！ 此页面尝试让一个 Haskell 用户启动并运行 Raku。Haskell 用户可能会发现，在用 Raku 编写脚本时，他们不需要放弃所有 Haskelly 的想法。</p>
<p>请注意，这不应该被误认为是初学者教程或 Raku 概述; 它旨在作为具有强大 Haskell 背景的 Raku 学习者的技术参考。</p>
<h2 id="类型">类型</h2>
<h3 id="类型-vs-值">类型 vs 值</h3>
<p>在 Haskell 中, 您有类型级编程, 然后进行值级编程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">plusTwo</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>   <span class="c1">-- Types</span>
</span></span><span class="line"><span class="cl"><span class="nf">plusTwo</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>               <span class="c1">-- Values</span>
</span></span></code></pre></div><p>您不要像下面那样在 Haskell 中混合类型和值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">plusTwo</span> <span class="mi">2</span>          <span class="o">--</span> <span class="n">This</span> <span class="k">is</span> <span class="nc">valid</span>
</span></span><span class="line"><span class="cl"><span class="n">plusTwo</span> <span class="n">Integer</span>    <span class="o">--</span> <span class="n">This</span> <span class="k">is</span> <span class="nb">not</span> <span class="n">valid</span>
</span></span></code></pre></div><p>在 Raku 中, 类型(亦称为类型对象)和值处于同样的级别</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">plus-two</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$x</span> <span class="k">--&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">plus-two</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>   <span class="c1"># This is valid</span>
</span></span><span class="line"><span class="cl"><span class="nf">plus-two</span><span class="p">(</span><span class="kt">Int</span><span class="p">);</span> <span class="c1"># This is valid</span>
</span></span></code></pre></div><p>我将再用一个例子来说明 Raku 这个独特之处:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">is-string</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$</span> <span class="k">--&gt;</span> <span class="kt">True</span><span class="p">)</span>  <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">is-string</span><span class="p">(</span><span class="kt">Any</span> <span class="nv">$</span> <span class="k">--&gt;</span> <span class="kt">False</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nf">is-string</span><span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;);</span>    <span class="c1">#True </span>
</span></span><span class="line"><span class="cl"><span class="nf">is-string</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>          <span class="c1">#False </span>
</span></span></code></pre></div><h3 id="maybe">Maybe</h3>
<p>在 Haskell 中，您有一个 Maybe 类型, 可以让您放弃空类型的烦恼。 假设您有一个将 String 解析为 Integer 的假设函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nf">parseInt</span> <span class="o">::</span> <span class="n">String</span> <span class="k">-&gt;</span> <span class="n">Maybe</span> <span class="n">Integer</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">case</span> <span class="n">parseInt</span> <span class="n">myString</span> <span class="k">of</span>
</span></span><span class="line"><span class="cl">  <span class="nc">Just</span> <span class="nb">x</span>  <span class="k">-&gt;</span> <span class="nb">x</span>
</span></span><span class="line"><span class="cl">  <span class="n">Nothing</span> <span class="k">-&gt;</span> <span class="mi">0</span>
</span></span></code></pre></div><p>在 Raku 中, 由于类型对象与常规对象共存，因此我们拥有 <code>Defined</code> 和 <code>Undefined</code> 对象的概念。 平常的类型对象是 undefined 的, 而实例化后的对象是 defined 的。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Javascript(Node.js) 到 Raku - 简而言之]]></title>
            <link href="http://localhost:1313/rakulang/10.javascript-node.js-to-perl-6---nutshell/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/9.haskell-to-perl-6---nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Haskell 到 Raku - 简而言之" />
                <link href="http://localhost:1313/rakulang/8.perl-5-to-perl-6-guide---special-variables/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 特殊变量" />
                <link href="http://localhost:1313/rakulang/7.perl-5-to-perl-6-guide---syntax/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 语法" />
                <link href="http://localhost:1313/rakulang/6.perl-5-to-perl-6-guide---operators/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 运算符" />
                <link href="http://localhost:1313/rakulang/4.perl-5-to-perl-6-guide---overview/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 概览" />
            
                <id>http://localhost:1313/rakulang/10.javascript-node.js-to-perl-6---nutshell/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-16T21:13:31+08:00</published>
            <updated>2018-10-16T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>大西瓜啊，忘记翻译了！</p>
<p>This page attempts to provide a way for users experienced in Node.js to learn Raku. Features shared between the two languages will be explained here, as well as major differences in syntax and features.</p>
<p>This is not a tutorial for learning Raku; this is a reference for users who are already at an intermediate to advanced skill level with Node.js.</p>
<p>此页面试图为在Node.js中有经验的用户提供学习Raku的方法。这里将解释两种语言之间共享的功能，以及语法和功能的主要差异。</p>
<p>这不是学习Raku的教程; 对于已经使用Node.js处于中级到高级技能级别的用户，这是一个参考。</p>
<h1 id="基础语法httpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">基础语法</a></h1>
<h2 id="hello-worldhttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">&ldquo;Hello, world!&rdquo;</a></h2>
<p>Let&rsquo;s start with the typical first program when learning new languages. In Node.js, a hello world program would be written like this:</p>
<p>让我们从学习新语言时的典型第一个程序开始。在Node.js中，一个hello world程序将编写如下：</p>
<pre tabindex="0"><code>console.log(&#39;Hello, world!&#39;);
</code></pre><p>Here are a couple ways to write this in the same way in Raku:</p>
<p>以下是在Raku中以相同方式编写此内容的几种方法：</p>
<pre tabindex="0"><code>say(&#39;Hello, world!&#39;);
say &#39;Hello, world!&#39;;
</code></pre><p>Parentheses are optional for function calls in Raku. While semicolons are, for the most part, optional in Node.js, they are mandatory for expressions in Raku.</p>
<p>Now that we&rsquo;ve greeted the world, let&rsquo;s greet our good friend, Joe. We&rsquo;ll start with Node.js again:</p>
<p>对于Raku中的函数调用，括号是可选的。虽然分号在Node.js中大多数是可选的，但它们对于Raku中的表达式是必需的。</p>
<p>现在我们迎接了世界，让我们迎接我们的好朋友乔。我们将再次从Node.js开始：</p>
<pre tabindex="0"><code>let name = &#39;Joe&#39;;
console.log(&#39;What\&#39;s up,&#39; + name + &#39;?&#39;);
console.log(`What&#39;s up, {name}?`);
console.log(&#34;What&#39;s up, &#34;, name, &#34;?&#34;);
</code></pre><p>Since he didn&rsquo;t hear us, let&rsquo;s greet him again, this time in Raku:</p>
<p>因为他没有听到我们，所以让我再次问候他，这次是在Raku中：</p>
<pre tabindex="0"><code>my $name = &#39;Joe&#39;;
say &#39;What\&#39;s up, &#39; ~ $name ~ &#39;?&#39;;
say &#34;What&#39;s up, $name?&#34;;
say &#34;What&#39;s up, &#34;, $name, &#34;?&#34;;
</code></pre><p>Here, there are only a couple differences: most variables in Raku have what are called sigils, which are what the <code>$</code> in front of its name is, and string concatenation uses the <code>~</code> operator instead of <code>+</code>. What the two languages share in common here is support for string interpolation.</p>
<p>Now that the basic examples are out of the way, let&rsquo;s explain the similarities between the two languages in greater detail.</p>
<p>这里只有几个不同之处：Raku中的大多数变量都有所谓的sigils，这就是<code>$</code>它名称前面的变量，字符串连接使用<code>~</code>运算符代替<code>+</code>。这两种语言的共同点是支持字符串插值。</p>
<p>现在基本的例子已经不在了，让我们更详细地解释两种语言之间的相似之处。</p>
<h2 id="变量httpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">变量</a></h2>
<p>Variables in Node.js can be defined like this;</p>
<p>Node.js中的变量可以像这样定义;</p>
<pre tabindex="0"><code>var foo = 1;    // Lexically scoped with functions and modules
let foo = 1;    // Lexically scoped with blocks
const foo = 1;  // Lexically scoped with blocks; constant
 
global.foo = 1; // Dynamically scoped; global
foo = 1;        // Ditto, but implicit; forbidden in strict mode
</code></pre><p>In Raku there is no equivalent to <code>var</code>. An important note to make is that there is no variable hoisting in Raku; variables are defined and assigned at the line they&rsquo;re on, not defined at the top of its scope and later assigned at that line.</p>
<p>This is how the equivalent types of variables are defined in Raku:</p>
<p>在Raku中没有相当于<code>var</code>。需要注意的一点是，Raku中没有可变的吊装; 变量在它们所在的行上定义和分配，未在其范围的顶部定义，稍后在该行分配。</p>
<p>这是在Raku中定义等效类型的变量的方式：</p>
<pre tabindex="0"><code>my $foo = 1;      # Lexically scoped with blocks 
our $foo = 1;     # Lexically scoped with blocks and modules 
constant foo = 1; # Lexically scoped with blocks and modules; constant 
 
my $*foo = 1;       # Dynamically scoped with blocks 
OUR::&lt;$foo&gt; = 1;    # Dynamically scoped with blocks and modules 
GLOBAL::&lt;$foo&gt; = 1; # Dynamically scoped; global 
</code></pre><p>Use <code>my</code> where you&rsquo;d use <code>let</code>, <code>our</code> for variables you&rsquo;d define in the outermost scope needed, and <code>constant</code> where you&rsquo;d uses <code>const</code>.</p>
<p>Dynamically scoped variables are not referred to in the same way as lexically scoped ones like they are in Node.js. User-defined ones use either a <code>$*</code>, <code>@*</code>, <code>%*</code>, or <code>&amp;*</code> twigil. Refer to the documentation on <a href="https://docs.raku.org/language/variables">variables</a> for more information on sigils, twigils, and variable containers.</p>
<p>Variables in Node.js can override others from outer scopes with the same name (though linters will usually complain about it depending on how they&rsquo;re configured):</p>
<p>使用<code>my</code>您使用的位置<code>let</code>，<code>our</code>您需要在最外层范围内定义的变量以及<code>constant</code>您使用的位置<code>const</code>。</p>
<p>动态范围变量的引用方式与它们在Node.js中的词汇范围变量相同。用户定义的那些使用一个<code>$*</code>，<code>@*</code>，<code>%*</code>，或<code>&amp;*</code>twigil。有关sigils，twigils和变量容器的更多信息，请参阅有关<a href="https://docs.raku.org/language/variables">变量</a>的文档。</p>
<p>Node.js中的变量可以覆盖具有相同名称的外部作用域中的其他变量（尽管linters通常会根据它们的配置方式来抱怨它）：</p>
<pre tabindex="0"><code>let foo = 1;
function logDupe() {
    let foo = 2;
    console.log(foo);
}
 
logDupe(2);       // 2
console.log(foo); // 1
</code></pre><p>Raku also allows this:</p>
<p>Raku 也允许这样：</p>
<pre tabindex="0"><code>my $foo = 1;
sub log-dupe {
    my $foo = 2;
    say $foo;
}
 
log-dupe; # 2 
say $foo; # 1 
</code></pre><h2 id="运算符httpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">运算符</a></h2>
<h3 id="赋值httpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">赋值</a></h3>
<p>The <code>=</code> operator works the same across both languages.</p>
<p>The <code>:=</code> operator in Raku binds a value to a variable. Binding a variable to another variable gives them the same value and container, meaning mutating attributes of one will mutate the other&rsquo;s as well. Bound variables cannot be reassigned with <code>=</code> or mutated with <code>++</code>, <code>--</code>, etc. but they can be bound to another value again:</p>
<p><code>=</code> 运算符可以跨两种语言相同。</p>
<p>Raku 中的 <code>:=</code> 运算符将值绑定到变量。将变量绑定到另一个变量会为它们提供相同的值和容器，这意味着一个变量属性也会改变另一个变量。绑定变量不能被重新分配<code>=</code>或突变<code>++</code>，<code>--</code>等，但它们可以被重新绑定到另一个值：</p>
<pre tabindex="0"><code>my %map;            # This is a hash, roughly equivalent to a JS object or map 
my %unbound = %map;
my %bound := %map;
%map&lt;foo&gt; = &#39;bar&#39;;
say %unbound;       # {} 
say %bound;         # {foo =&gt; bar} 
 
%bound := %unbound;
say %bound;         # {} 
</code></pre><h3 id="相等httpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">相等</a></h3>
<p>Node.js has two equality operators: <code>==</code> and <code>===</code>.</p>
<p><code>==</code> is the loose equality operator. When comparing operands with the same type, it will return true if both operands are equal. However, if the operands are different types, they are both cast to their primitives before being compared, meaning these will return true:</p>
<p>Node.js有两个相等运算符：<code>==</code>和<code>===</code>。</p>
<p><code>==</code>是松散的平等算子。比较具有相同类型的操作数时，如果两个操作数相等，则返回true。但是，如果操作数是不同的类型，它们在被比较之前都被转换为它们的基元，这意味着它们将返回true：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">console</span><span class="o">.</span><span class="nb">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>   <span class="o">//</span> <span class="n">true</span>
</span></span><span class="line"><span class="cl"><span class="n">console</span><span class="o">.</span><span class="nb">log</span><span class="p">(&#39;</span><span class="s1">1</span><span class="p">&#39;</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span> <span class="o">//</span> <span class="n">true</span>
</span></span><span class="line"><span class="cl"><span class="n">console</span><span class="o">.</span><span class="nb">log</span><span class="p">(</span><span class="o">[]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>  <span class="o">//</span> <span class="n">true</span>
</span></span></code></pre></div><p>Similarly, in Raku, both operands are cast to Numeric before comparison if they don&rsquo;t share the same type:</p>
<p>类似地，在Raku中，如果它们不共享相同的类型，则在比较之前将两个操作数强制转换为Numeric：</p>
<pre tabindex="0"><code>say 1 == 1;       # True 
say &#39;1&#39; == 1;     # True 
say [1,2,3] == 3; # True, since the array has three elements 
</code></pre><p>The inverse of <code>==</code> is <code>!=</code>.</p>
<p>Raku has another operator similar to <code>==</code>: <code>eq</code>. Instead of casting operands to Numeric if they&rsquo;re different types, <code>eq</code> will cast them to strings:</p>
<p>倒数<code>==</code>是<code>!=</code>。</p>
<p>Raku有另一个类似于的运算符<code>==</code>：<code>eq</code>。如果它们是不同的类型，而不是将操作数转换为Numeric，而不是<code>eq</code>将它们转换为字符串：</p>
<pre tabindex="0"><code>say &#39;1&#39; eq &#39;1&#39;; # True 
say 1 eq &#39;1&#39;;   # True 
</code></pre><p>The inverse of <code>eq</code> is <code>ne</code> or <code>!eq</code>.</p>
<p><code>===</code> is the strict equality operator. This returns true if both operands are the same value. When comparing objects, this will <em>only</em> return true if they are the exact same object:</p>
<p>逆的<code>eq</code>是<code>ne</code>或<code>!eq</code>。</p>
<p><code>===</code>是严格的相等运算符。如果两个操作数是相同的值，则返回true。比较对象时，如果它们是完全相同的对象，<em>则只</em>返回true：</p>
<pre tabindex="0"><code>console.log(1 === 1);   // true
console.log(&#39;1&#39; === 1); // false
console.log({} === {}); // false
 
let obj = {};
let obj2 = obj;
console.log(obj === obj2); // true;
</code></pre><p>In Raku, the operator behaves the same, with one exception: two objects that have the same value, but different containers, will return false:</p>
<p>在Raku中，运算符的行为相同，但有一个例外：两个具有相同值但容器不同的对象将返回false：</p>
<pre tabindex="0"><code>say 1 === 1; # True 
say &#39;1&#39; === 1; # True 
say {} === {};  # False 
 
my \hash = {};
my %hash = hash;
say hash === %hash; # False 
</code></pre><p>In the last case it&rsquo;s the same object, but containers are different, which is why it returns False.</p>
<p>The inverse of <code>===</code> is <code>!==</code>.</p>
<p>This is where Raku&rsquo;s other equality operators are useful. If the values have different containers, the <code>eqv</code> operator can be used. This operator can be also be used to check for deep equality, which you would normally need to use a library for in Node.js:</p>
<p>在最后一种情况下，它是相同的对象，但容器是不同的，这就是它返回False的原因。</p>
<p>倒数<code>===</code>是<code>!==</code>。</p>
<p>这是Raku的其他相等运算符很有用的地方。如果值具有不同的容器，则<code>eqv</code>可以使用操作员。此运算符也可用于检查深度相等性，通常需要在Node.js中使用库：</p>
<pre tabindex="0"><code>say {a =&gt; 1} eqv {a =&gt; 1}; # True; 
 
my \hash = {};
my %hash := hash;
say hash eqv %hash; # True 
</code></pre><p>In the case you need to check if two variables have the same container and value, use the <code>=:=</code> operator.</p>
<p>如果您需要检查两个变量是否具有相同的容器和值，请使用<code>=:=</code>运算符。</p>
<pre tabindex="0"><code>my @arr = [1,2,3];
my @arr2 := @arr;   # Bound variables keep the container of the other variable 
say @arr =:= @arr2; # True 
</code></pre><h3 id="smartmatchinghttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">Smartmatching</a></h3>
<p>Raku has one last operator for comparing values, but it is not exactly an equality operator. This is <code>~~</code>, the smartmatch operator. This has several uses: it can be used like <code>instanceof</code> in Node.js, to match a regex, and to check if a value is a key in a hash, bag, set, or map:</p>
<p>Raku有一个用于比较值的最后一个运算符，但它不完全是一个相等运算符。这就是<code>~~</code>smartmatch运营商。这有几个用途：它可以像<code>instanceof</code>在Node.js中一样使用，以匹配正则表达式，并检查值是否是散列，包，集或映射中的键：</p>
<pre tabindex="0"><code>say &#39;foo&#39; ~~ Str; # True 
 
my %hash = a =&gt; 1;
say &#39;a&#39; ~~ %hash; # True 
 
my $str = &#39;abc&#39;;
$str ~~ s/abc/def/; # Mutates $str, like foo.replace(&#39;abc&#39;, &#39;def&#39;) 
say $str;           # def 
</code></pre><p>While we are talking about <code>instanceof</code>, the equivalent to the <code>constructor</code> property on Node.js objects in Raku is the <code>WHAT</code>attribute:</p>
<p>在我们讨论的时候<code>instanceof</code>，<code>constructor</code>Raku中Node.js对象的属性相当于<code>WHAT</code>属性：</p>
<pre tabindex="0"><code>console.log(&#39;foo&#39;.constructor); // OUTPUT: String
say &#39;foo&#39;.WHAT; # OUTPUT: Str 
</code></pre><h3 id="numerichttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">Numeric</a></h3>
<p>Node.js has <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code>, and (in ES6) <code>**</code> as numeric operators. When the operands are different types, similarly to the equality operators, are cast to their primitives before following through with the operation, making this possible:</p>
<p>Node.js的有<code>+</code>，<code>-</code>，<code>/</code>，<code>*</code>，<code>%</code>，和（在ES6）<code>**</code>作为数字运算符。当操作数是不同类型时，类似于相等运算符，在执行操作之前会转换为它们的基元，从而使这成为可能：</p>
<pre tabindex="0"><code>console.log(1 + 2);   // 3
console.log([] + {}); // [object Object]
console.log({} + []); // 0
</code></pre><p>In Raku, again, they are converted to a Numeric type, as before:</p>
<p>在Raku中，它们再次转换为数字类型，如前所述：</p>
<pre tabindex="0"><code>say 1 + 2;        # 3 
say [] + {};      # 0 
say {} + [1,2,3]; # 3 
</code></pre><p>In addition, Raku has <code>div</code> and <code>%%</code>. <code>div</code> behaves like <code>int</code> division in C, while <code>%%</code> checks if one number is cleanly divisible by another or not:</p>
<p>另外，Raku有<code>div</code>和<code>%%</code>。<code>div</code>表现得像<code>int</code>C中的分裂，同时<code>%%</code>检查一个数字是否可以被另一个数字完全整除：</p>
<pre tabindex="0"><code>say 4 div 3; # 1 
say 4 %% 3;  # False 
say 6 %% 3;  # True 
</code></pre><h3 id="bitwisehttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">Bitwise</a></h3>
<p>Node.js has <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, and <code>~</code> for bitwise operators:</p>
<p>Node.js的有<code>&amp;</code>，<code>|</code>，<code>^</code>，<code>~</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>，<code>&gt;&gt;&gt;</code>，和<code>~</code>对位运算符：</p>
<pre tabindex="0"><code>console.log(1 &lt;&lt; 1);  // 2
console.log(1 &gt;&gt; 1);  // 0
console.log(1 &gt;&gt;&gt; 1); // 0
console.log(1 &amp; 1);   // 1
console.log(0 | 1);   // 1
console.log(1 ^ 1);   // 0
console.log(~1);      // -2
</code></pre><p>In Raku, there is no equivalent to <code>&gt;&gt;&gt;</code>. All bitwise operators are prefixed with <code>+</code>, however two&rsquo;s complement uses <code>+^</code> instead of <code>~</code>:</p>
<p>在Raku中，没有相当于<code>&gt;&gt;&gt;</code>。所有按位运算符都以前缀为前缀<code>+</code>，但是使用两个补码<code>+^</code>而不是<code>~</code>：</p>
<pre tabindex="0"><code>say 1 +&lt; 1; # 2 
say 1 +&gt; 1; # 0 
            # No equivalent for &gt;&gt;&gt; 
say 1 +&amp; 1; # 1 
say 0 +| 1; # 1 
say 1 +^ 1; # 0 
say +^1;    # -2 
</code></pre><h3 id="custom-operators-and-operator-overloadinghttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">Custom operators and operator overloading</a></h3>
<p>Node.js does not allow operator overloading without having to use a Makefile or build Node.js with a custom version of V8. Raku allows custom operators and operator overloading natively! Since all operators are subroutines, you can define your own like so:</p>
<p>Node.js不允许运算符重载而不必使用Makefile或使用自定义版本的V8构建Node.js. Raku允许自定义操作符和操作符本机重载！由于所有运算符都是子程序，因此您可以像这样定义自己的运算符：</p>
<pre tabindex="0"><code>multi sub infix:&lt;||=&gt;($a, $b) is equiv(&amp;infix:&lt;+=&gt;) { $a || $b }
 
my $foo = 0;
$foo ||= 1;
say $foo; # OUTPUT: 1 
</code></pre><p>Operators can be defined as <code>prefix</code>, <code>infix</code>, or <code>postfix</code>. The <code>is tighter</code>, <code>is equiv</code>, and <code>is looser</code> traits optionally define the operator&rsquo;s precedence. In this case, <code>||=</code> has the same precedence as <code>+=</code>.</p>
<p>Note how <code>multi</code> is used when declaring the operator subroutines. This allows multiple subroutines with the same name to be declared while also having different signatures. This will be explained in greater detail in the <a href="https://docs.raku.org/language/js-nutshell#Functions">Functions</a> section. For now, all we need to know is that it allows us to override any native operator we want:</p>
<p>运算符可以定义为<code>prefix</code>，<code>infix</code>，或<code>postfix</code>。的<code>is tighter</code>，<code>is equiv</code>和<code>is looser</code>性状选择定义操作的优先级。在这种情况下，<code>||=</code>具有相同的优先级<code>+=</code>。</p>
<p>注意<code>multi</code>在声明操作符子例程时如何使用。这允许声明具有相同名称的多个子例程，同时具有不同的签名。这将在“ <a href="https://docs.raku.org/language/js-nutshell#Functions">功能”</a>部分中详细说明。目前，我们需要知道的是它允许我们覆盖我们想要的任何本机运算符：</p>
<pre tabindex="0"><code># Using the `is default` trait here forces this subroutine to be chosen first, 
# so long as the signature of the subroutine matches. 
multi sub prefix:&lt;++&gt;($a) is default { $a - 1 }
 
my $foo = 1;
say ++$foo; # OUTPUT: 0 
</code></pre><h2 id="control-flowhttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">Control flow</a></h2>
<h3 id="ifelsehttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">if/else</a></h3>
<p>You should be familiar with how <code>if</code>/<code>else</code> looks in JavaScript:</p>
<p>您应该熟悉 JavaScript 中的 <code>if</code>/ <code>else</code>：</p>
<pre tabindex="0"><code>let diceRoll = Math.ceil(Math.random() * 6) + Math.ceil(Math.random() * 6);
if (diceRoll === 2) {
    console.log(&#39;Snake eyes!&#39;);
} else if (diceRoll === 16) {
    console.log(&#39;Boxcars!&#39;);
} else {
    console.log(`Rolled ${diceRoll}.`);
}
</code></pre><p>In Raku, <code>if</code>/<code>else</code> works largely the same, with a few key differences. One, parentheses are not required. Two, <code>else if</code> is written as <code>elsif</code>. Three, the if clause may be written <em>after</em> a statement:</p>
<p>在Raku中，<code>if</code>/的<code>else</code>工作方式基本相同，只有一些关键的区别。一，括号不是必需的。二，<code>else if</code>写成<code>elsif</code>。三，if语句可以<em>在</em>声明<em>后</em>写出：</p>
<pre tabindex="0"><code>my Int $dice-roll = ceiling rand * 12 + ceiling rand * 12;
if $dice-roll == 2 {
    say &#39;Snake eyes!&#39;;
} elsif $dice-roll == 16 {
    say &#39;Boxcars!&#39;;
} else {
    say &#34;Rolled $dice-roll.&#34;;
}
</code></pre><p>Alternatively, though less efficient, this could be written to use <code>if</code> after statements:</p>
<p>或者，虽然效率较低，但可以<code>if</code>在语句后使用：</p>
<pre tabindex="0"><code>my Int $dice-roll = ceiling rand * 12 + ceiling rand * 12;
say &#39;Snake eyes!&#39;        if $dice-roll == 2;
say &#39;Boxcars!&#39;           if $dice-roll == 16;
say &#34;Rolled $dice-roll.&#34; if $dice-roll !~~ 2 | 16;
</code></pre><p>Raku also has <code>when</code>, which is like <code>if</code>, but if the condition given is true, no code past the <code>when</code> block within the block it&rsquo;s in is executed:</p>
<p>Raku也有<code>when</code>，就像是<code>if</code>，但是如果给出的条件为真，<code>when</code>那么执行它所执行的块中没有代码超过块：</p>
<pre tabindex="0"><code>{
    when True {
        say &#39;In when block!&#39;; # OUTPUT: In when block! 
    }
    say &#39;This will never be output!&#39;;
}
</code></pre><p>Additionally, Raku has <code>with</code>, <code>orwith</code>, and <code>without</code>, which are like <code>if</code>, <code>else if</code>, and <code>else</code> respectively, but instead of checking whether their condition is true, they check if it&rsquo;s defined.</p>
<p>此外，Raku的有<code>with</code>，<code>orwith</code>和<code>without</code>，这是一样<code>if</code>，<code>else if</code>和，<code>else</code>分别但是，不是检查自己的条件是否为真，他们检查，如果它被定义。</p>
<h3 id="switchhttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">switch</a></h3>
<p>Switch statements are a way of checking for equality between a given value and a list of values and run some code if one matches. <code>case</code> statements define each value to compare to. <code>default</code>, if included, acts as a fallback for when the given value matches no cases. After matching a case, <code>break</code> is typically used to prevent the code from the cases that follow the one matched from being executed, though rarely this is intentionally omitted.</p>
<p>Switch语句是一种检查给定值和值列表之间相等性的方法，并在匹配时运行一些代码。<code>case</code>语句定义要比较的每个值。<code>default</code>，如果包含，则作为给定值不匹配任何情况的后备。在匹配案例之后，<code>break</code>通常用于防止代码跟随匹配的案例执行，尽管很少有意省略。</p>
<pre tabindex="0"><code>const ranklist = [2, 3, 4, 5, 6, 7, 8, 9, &#39;Jack&#39;, &#39;Queen&#39;, &#39;King&#39;, &#39;Ace&#39;];
const ranks    = Array.from(Array(3), () =&gt; ranklist[Math.floor(Math.random() * ranks.length)]);
let   score    = 0;
 
for (let rank of ranks) {
    switch (rank) {
        case &#39;Jack&#39;:
        case &#39;Queen&#39;:
        case &#39;King&#39;:
            score += 10;
            break;
        case &#39;Ace&#39;;
            score += (score &lt;= 11) ? 10 : 1;
            break;
        default:
            score += rank;
            break;
    }
}
</code></pre><p>In Raku, <code>given</code> can be used like switch statements. There is no equivalent to <code>break</code> since <code>when</code> blocks are most commonly used like <code>case</code> statements. One major difference between <code>switch</code> and <code>given</code> is that a value passed to a <code>switch</code> statement will only match cases that are exactly equal to the value; <code>given</code> values are smartmatched (<code>~~</code>) against the <code>when</code> values.</p>
<p>在Raku中，<code>given</code>可以像switch语句一样使用。没有相应的，<code>break</code>因为<code>when</code>块最常用于<code>case</code>语句。<code>switch</code>和之间的一个主要区别<code>given</code>是传递给<code>switch</code>语句的值只匹配与值完全相等的情况; <code>given</code>值是<code>~~</code>针对值的smartmatched（）<code>when</code>。</p>
<pre tabindex="0"><code>my     @ranklist = [2, 3, 4, 5, 6, 7, 8, 9, &#39;Jack&#39;, &#39;Queen&#39;, &#39;King&#39;, &#39;Ace&#39;];
my     @ranks    = @ranklist.pick: 3;
my Int $score    = 0;
 
for @ranks -&gt; $rank {
    # The when blocks implicitly return the last statement they contain. 
    $score += do given $rank {
        when &#39;Jack&#39; | &#39;Queen&#39; | &#39;King&#39; { 10 }
        when &#39;Ace&#39; { $score &lt;= 11 ?? 10 !! 1 }
        default { $_ }
    };
}
</code></pre><p>If there are multiple <code>when</code> blocks that match the value passed to <code>given</code> and you wish to run more than one of them, use <code>proceed</code>. <code>succeed</code> may be used to exit both the <code>when</code> block it&rsquo;s in and the given block, preventing any following statements from being executed:</p>
<p>如果有多个<code>when</code>块与传递的值匹配，<code>given</code>并且您希望运行多个块，请使用<code>proceed</code>。<code>succeed</code>可用于退出<code>when</code>它所在的块和给定的块，防止执行以下任何语句：</p>
<pre tabindex="0"><code>given Int {
    when Int     { say &#39;Int is Int&#39;;     proceed }
    when Numeric { say &#39;Int is Numeric&#39;; proceed }
    when Any     { say &#39;Int is Any&#39;;     succeed }
    when Mu      { say &#39;Int is Mu&#39;               } # Won&#39;t output 
}
 
# OUTPUT: 
# Int is Int 
# Int is Numeric 
# Int is Any 
</code></pre><h3 id="for-while-and-dowhilehttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">for, while, and do/while</a></h3>
<p>There are three different types of for loops in JavaScript:</p>
<p>JavaScript中有三种不同类型的for循环：</p>
<pre tabindex="0"><code>// C-style for loops
const letters = {};
for (let ord = 0x61; ord &lt;= 0x7A; ord++) {
    let letter = String.fromCharCode(ord);
    letters[letter] = letter.toUpperCase();
}
 
// for..in loops (typically used on objects)
for (let letter in letters) {
    console.log(letters[letter]);
    # OUTPUT: 
    # A 
    # B 
    # C 
    # etc. 
}
 
// for..of loops (typically used on arrays, maps, and sets)
for (let letter of Object.values(letters)) {
    console.log(letter);
    # OUTPUT: 
    # A 
    # B 
    # C 
    # etc. 
}
</code></pre><p>Raku <code>for</code> loops most closely resemble <code>for..of</code> loops, since they work on anything as long as it&rsquo;s iterable. C-style loops are possible to write using <code>loop</code>, but this is discouraged since they&rsquo;re better written as <code>for</code> loops using ranges. Like <code>if</code> statements, <code>for</code> may follow a statement, with the current iteration being accessible using the <code>$_</code> variable (known as &ldquo;it&rdquo;). Methods on <code>$_</code> may be called without specifying the variable:</p>
<p>Raku <code>for</code>循环最接近<code>for..of</code>循环，因为只要它是可迭代的，它们就可以处理任何东西。C风格的循环可以使用<code>loop</code>，但不鼓励这样做，因为它们更好地编写为<code>for</code>使用范围的循环。类似<code>if</code>语句，<code>for</code>可以遵循一个语句，当前迭代可以使用<code>$_</code>变量（称为“它”）访问。<code>$_</code>可以在不指定变量的情况下调用方法：</p>
<pre tabindex="0"><code>my Str %letters{Str};
%letters{$_} = .uc for &#39;a&#39;..&#39;z&#39;;
.say for %letters.values;
# OUTPUT: 
# A 
# B 
# C 
# etc. 
</code></pre><p><code>while</code> loops work identically between JavaScript and Raku. Raku also has <code>until</code> loops, where instead of iterating until the given condition is false, they iterate until the condition is true.</p>
<p><code>do/while</code> loops are known as <code>repeat/while</code> loops in Raku. Likewise with <code>while</code>, <code>repeat/until</code> loops also exist and loop until the given condition is false.</p>
<p>To write infinite loops in Raku, use <code>loop</code> rather than <code>for</code> or <code>while</code>.</p>
<p>In JavaScript, <code>continue</code> is used to skip to the next iteration in a loop, and <code>break</code> is used to exit a loop early:</p>
<p><code>while</code>循环在JavaScript和Raku之间的工作相同.Raku也有<code>until</code>循环，而不是迭代直到给定条件为假，它们迭代直到条件为真。</p>
<p><code>do/while</code>循环<code>repeat/while</code>在Raku 中称为循环。同样<code>while</code>，<code>repeat/until</code>循环也存在并循环，直到给定条件为假。</p>
<p>要在Raku中编写无限循环，请使用<code>loop</code>而不是<code>for</code>或<code>while</code>。</p>
<p>在JavaScript中，<code>continue</code>用于跳转到循环中的下一个迭代，并<code>break</code>用于提前退出循环：</p>
<pre tabindex="0"><code>let primes = new Set();
let i      = 2;
 
do {
    let isPrime = true;
    for (let prime of primes) {
        if (i % prime == 0) {
            isPrime = false;
            break;
        }
    }
    if (!isPrime) continue;
    primes.add(i);
} while (++i &lt; 20);
 
console.log(primes); # OUTPUT: Set { 2, 3, 5, 7, 11, 13, 17, 19 } 
</code></pre><p>In Raku, these are known as <code>next</code> and <code>last</code> respectively. There is also <code>redo</code>, which repeats the current iteration without evaluating the loop&rsquo;s condition again.</p>
<p><code>next</code>/<code>redo</code>/<code>last</code> statements may be followed by a label defined before an outer loop to make the statement work on the loop the label refers to, rather than the loop the statement is in:</p>
<p>在Raku中，这些分别称为<code>next</code>和<code>last</code>。还有<code>redo</code>，它重复当前迭代而不再评估循环的条件。</p>
<p><code>next</code>/ <code>redo</code>/ <code>last</code>语句后跟一个在外部循环之前定义的标签，以使该语句在标签所引用的循环上起作用，而不是该语句所在的循环：</p>
<pre tabindex="0"><code>my %primes is SetHash;
my Int $i = 2;
 
OUTSIDE:
repeat {
    next OUTSIDE if $i %% $_ for %primes.keys;
    %primes{$i}++;
} while ++$i &lt; 20;
 
say %primes; # OUTPUT: SetHash(11 13 17 19 2 3 5 7) 
</code></pre><h3 id="dohttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">do</a></h3>
<p><code>do</code> is not currently a feature in JavaScript, however a proposal has been made to <a href="https://github.com/tc39/proposal-do-expressions">add it to ECMAScript</a>. <code>do</code> expressions evaluate a block and return the result:</p>
<p><code>do</code>目前不是JavaScript中的一项功能，但已提出<a href="https://github.com/tc39/proposal-do-expressions">将其添加到ECMAScript</a>的提案。<code>do</code>表达式计算一个块并返回结果：</p>
<pre tabindex="0"><code>constant VERSION        = v2.0.0;
constant VERSION_NUMBER = do {
    my @digits = VERSION.Str.comb(/\d+/);
    :16(sprintf &#34;%02x%02x%04x&#34;, |@digits)
};
say VERSION_NUMBER; # OUTPUT: 33554432 
</code></pre><h2 id="typeshttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">Types</a></h2>
<h3 id="creating-typeshttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">Creating types</a></h3>
<p>In JavaScript, types are created by making a class (or a constructor in ES5 and earlier). If you&rsquo;ve used TypeScript, you can define a type as a subset of other types like so:</p>
<p>在JavaScript中，通过创建类（或ES5及更早版本中的构造函数）来创建类型。如果您使用过TypeScript，则可以将类型定义为其他类型的子集，如下所示：</p>
<pre tabindex="0"><code>type ID = string | number;
</code></pre><p>In Raku, classes, roles, subsets, and enums are considered types. Creating classes and roles will be discussed in <a href="https://docs.raku.org/language/js-nutshell#Object-oriented_programming">the OOP section of this article</a>. Creating an ID subset can be done like so:</p>
<p>在Raku中，类，角色，子集和枚举被视为类型。创建类和角色将在本文<a href="https://docs.raku.org/language/js-nutshell#Object-oriented_programming">的OOP部分中讨论</a>。创建ID子集可以这样完成：</p>
<pre tabindex="0"><code>subset ID where Str | Int;
</code></pre><p>See the documentation on <a href="https://docs.raku.org/language/typesystem#subset">subset</a> and <a href="https://docs.raku.org/type/Junction">Junction</a> for more information.</p>
<p>TypeScript enums may have numbers or strings as their values. Defining the values is optional; by default, the value of the first key is 0, the next key, 1, the next, 2, etc. For example, here is an enum that defines directions for extended ASCII arrow symbols (perhaps for a TUI game):</p>
<p>有关更多信息，请参阅<a href="https://docs.raku.org/language/typesystem#subset">子集</a>和<a href="https://docs.raku.org/type/Junction">连接</a>的文档。</p>
<p>TypeScript枚举可以包含数字或字符串作为其值。定义值是可选的; 默认情况下，第一个键的值为0，下一个键为1，下一个键为2，等等。例如，这是一个枚举，用于定义扩展ASCII箭头符号的方向（可能用于TUI游戏）：</p>
<pre tabindex="0"><code>enum Direction (
    UP    = &#39;↑&#39;,
    DOWN  = &#39;↓&#39;,
    LEFT  = &#39;←&#39;,
    RIGHT = &#39;→&#39;
);
</code></pre><p>Enums in Raku may have any type as their keys&rsquo; values. Enum keys (and optionally, values) can be defined by writing <code>enum</code>, followed by the name of the enum, then the list of keys (and optionally, values), which can be done using <a href="https://docs.raku.org/language/quoting#Word_quoting%3A_%3C_%3E">&lt; &gt;</a>, <a href="https://docs.raku.org/language/quoting#Word_quoting_with_interpolation_and_quote_protection%3A_%C2%AB_%C2%BB">« »</a>, or <a href="https://docs.raku.org/language/operators#term_%28_%29">( )</a>. <code>( )</code> must be used if you want to define values for the enum&rsquo;s keys. Here is the Direction enum as written in Raku:</p>
<p>Raku中的枚举可以使用任何类型作为其键值。枚举键（以及可选的值）可以通过写入来定义<code>enum</code>，然后是枚举的名称，然后是键列表（以及可选的值），可以使用<a href="https://docs.raku.org/language/quoting#Word_quoting%3A_%3C_%3E">&lt;&gt;</a>，<a href="https://docs.raku.org/language/quoting#Word_quoting_with_interpolation_and_quote_protection%3A_%C2%AB_%C2%BB">«»</a>或<a href="https://docs.raku.org/language/operators#term_%28_%29">（）来完成</a>。<code>( )</code>如果要为枚举键定义值，则必须使用。这是Raku中编写的Direction枚举：</p>
<pre tabindex="0"><code>enum Direction (
    UP    =&gt; &#39;↑&#39;,
    DOWN  =&gt; &#39;↓&#39;,
    LEFT  =&gt; &#39;←&#39;,
    RIGHT =&gt; &#39;→&#39;
);
</code></pre><p>See the documentation on <a href="https://docs.raku.org/language/typesystem#enum">enum</a> for more information.</p>
<p>有关更多信息，请参阅<a href="https://docs.raku.org/language/typesystem#enum">枚举</a>文档。</p>
<h3 id="using-typeshttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">Using types</a></h3>
<p>In TypeScript, you can define the type of variables. Attempting to assign a value that doesn&rsquo;t match the type of the variable will make the transpiler error out. This is done like so:</p>
<p>在TypeScript中，您可以定义变量的类型。尝试分配与变量类型不匹配的值将导致转换器错误。这样做是这样的：</p>
<pre tabindex="0"><code>enum Name (Phoebe, Daniel, Joe);
let name: string = &#39;Phoebe&#39;;
name = Phoebe; # Causes tsc to error out 
 
let hobbies: [string] = [&#39;origami&#39;, &#39;playing instruments&#39;, &#39;programming&#39;];
 
let todo: Map&lt;string, boolean&gt; = new Map([
    [&#39;clean the bathroom&#39;, false],
    [&#39;walk the dog&#39;, true],
    [&#39;wash the dishes&#39;, true]
]);
 
let doJob: (job: string) =&gt; boolean = function (job: string): boolean {
    todo.set(job, true);
    return true;
};
</code></pre><p>In Raku, variables can be typed by placing the type between the declarator (<code>my</code>, <code>our</code>, etc.) and the variable name. Assigning a value that doesn&rsquo;t match the variable&rsquo;s type will throw either a compile-time or runtime error, depending on how the value is evaluated:</p>
<p>在Raku中，变量可以通过将说明符（之间的类型被键入<code>my</code>，<code>our</code>等）和变量名。分配与变量类型不匹配的值将引发编译时或运行时错误，具体取决于值的计算方式：</p>
<pre tabindex="0"><code>enum Name &lt;Phoebe Daniel Joe&gt;;
my Str $name = &#39;Phoebe&#39;;
$name = Phoebe; # Throws a compile-time error 
 
# The type here defines the type of the elements of the array. 
my Str @hobbies = [&#39;origami&#39;, &#39;playing instruments&#39;, &#39;programming&#39;];
 
# The type between the declarator and variable defines the type of the values 
# of the hash. 
# The type in the curly braces defines the type of the keys of the hash. 
my Bool %todo{Str} = (
    &#39;clean the bathroom&#39; =&gt; False,
    &#39;walk the dog&#39;       =&gt; True,
    &#39;wash the dishes&#39;    =&gt; True
);
 
# The type here defines the return value of the routine. 
my Bool &amp;do-job = sub (Str $job --&gt; Bool) {
    %todo{$job} = True;
};
</code></pre><h3 id="比较-javascript-和-raku-的类型httpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">比较 JavaScript 和 Raku 的类型</a></h3>
<p>Here is a table of some JavaScript types and their equivalents in Raku:</p>
<p>以下是Raku中一些JavaScript类型及其等价物的表格：</p>
<table>
<thead>
<tr>
<th style="text-align:left">JavaScript</th>
<th style="text-align:left">Raku</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Object</td>
<td style="text-align:left">Mu, Any, Hash</td>
</tr>
<tr>
<td style="text-align:left">Array</td>
<td style="text-align:left">List, Array, Seq</td>
</tr>
<tr>
<td style="text-align:left">String</td>
<td style="text-align:left">Str</td>
</tr>
<tr>
<td style="text-align:left">Number</td>
<td style="text-align:left">Int, Num, Rat</td>
</tr>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">Bool</td>
</tr>
<tr>
<td style="text-align:left">Map</td>
<td style="text-align:left">Map, Hash</td>
</tr>
<tr>
<td style="text-align:left">Set</td>
<td style="text-align:left">Set, SetHash</td>
</tr>
</tbody>
</table>
<p><code>Object</code> is both a superclass of all types in JavaScript and a way to create a hash. In Raku, <a href="https://docs.raku.org/type/Mu">Mu</a> is a superclass of all types, though usually you want to use <a href="https://docs.raku.org/type/Any">Any</a> instead, which is a subclass of <code>Mu</code> but also a superclass of nearly every type, with <a href="https://docs.raku.org/type/Junction">Junction</a> being an exception. When using <code>Object</code> as a hash, <a href="https://docs.raku.org/type/Hash">Hash</a> is what you want to use.</p>
<p>There are three types equivalent to <code>Array</code>. <a href="https://docs.raku.org/type/Array">Array</a> is most similar to <code>Array</code>, since it acts as a mutable array. <a href="https://docs.raku.org/type/List">List</a> is similar to <code>Array</code>, but is immutable. <a href="https://docs.raku.org/type/Seq">Seq</a> is used to create lazy arrays.</p>
<p><code>String</code> and <a href="https://docs.raku.org/type/Str">Str</a> are for the most part used identically.</p>
<p>There are several different types in Raku equivalent to <code>Number</code>, but the three you&rsquo;ll most commonly see are <a href="https://docs.raku.org/type/Int">Int</a>, <a href="https://docs.raku.org/type/Num">Num</a>, and <a href="https://docs.raku.org/type/Rat">Rat</a>. <code>Int</code>represents an integer. <code>Num</code> represents a floating-point number, making it the most similar to <code>Number</code>. <code>Rat</code> represents a fraction of two numbers, and is used when <code>Num</code> cannot provide precise enough values.</p>
<p><code>Boolean</code> and <a href="https://docs.raku.org/type/Bool">Bool</a> are for the most part used identically.</p>
<p><code>Map</code> has both a mutable and an immutable equivalent in Raku. <a href="https://docs.raku.org/type/Map">Map</a> is the immutable one, and <a href="https://docs.raku.org/type/Hash">Hash</a> is the mutable one. Don&rsquo;t get them mixed up! Like <code>Map</code> in JavaScript, <code>Map</code> and <code>Hash</code> can have any type of key or value, not just strings for keys.</p>
<p>Like <code>Map</code>, <code>Set</code> also has both a mutable and an immutable equivalent in Raku. <a href="https://docs.raku.org/type/Set">Set</a> is the immutable one, and <a href="https://docs.raku.org/type/SetHash">SetHash</a> is the mutable one.</p>
<p><code>Object</code>既是JavaScript中所有类型的超类，也是创建哈希的方法。在Raku中，<a href="https://docs.raku.org/type/Mu">穆</a>是所有类型的超类，尽管通常要使用<a href="https://docs.raku.org/type/Any">任何</a>代替，这是的一个子类<code>Mu</code>，而且几乎所有类型的超类，与<a href="https://docs.raku.org/type/Junction">接线</a>是一个例外。当<code>Object</code>用作哈希时，<a href="https://docs.raku.org/type/Hash">哈希</a>就是你想要使用的。</p>
<p>有三种类型相当于<code>Array</code>。<a href="https://docs.raku.org/type/Array">数组</a>最相似<code>Array</code>，因为它充当可变数组。<a href="https://docs.raku.org/type/List">列表</a>类似于<code>Array</code>，但是是不可变的。<a href="https://docs.raku.org/type/Seq">Seq</a>用于创建惰性数组。</p>
<p><code>String</code>和<a href="https://docs.raku.org/type/Str">Str</a>在大多数情况下使用相同。</p>
<p>Raku中有几种不同的类型相当于<code>Number</code>，但你最常见的三种是<a href="https://docs.raku.org/type/Int">Int</a>，<a href="https://docs.raku.org/type/Num">Num</a>和<a href="https://docs.raku.org/type/Rat">Rat</a>。<code>Int</code>表示整数。<code>Num</code>表示一个浮点数，使其最相似<code>Number</code>。<code>Rat</code>表示两个数字的一小部分，并且在<code>Num</code>无法提供足够精确的值时使用。</p>
<p><code>Boolean</code>和<a href="https://docs.raku.org/type/Bool">Bool</a>在大多数情况下使用相同。</p>
<p><code>Map</code>既具有可变的，并且在Raku的不可变等效<a href="https://docs.raku.org/type/Map">地图</a>是不可变的一个，并且<a href="https://docs.raku.org/type/Hash">哈希</a>是可变的一个。不要混淆他们！就像<code>Map</code>在JavaScript中，<code>Map</code>并且<code>Hash</code>可以有任何类型的键或值，而不仅仅是钥匙串。</p>
<p>像<code>Map</code>，<code>Set</code>也都一个可变的和Raku中一个不变的等效<a href="https://docs.raku.org/type/Set">设置</a>是不可变的一个，并且<a href="https://docs.raku.org/type/SetHash">SetHash</a>是可变的。</p>
<h2 id="函数httpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">函数</a></h2>
<p># TBD</p>
<h1 id="面向对象编程httpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">面向对象编程</a></h1>
<p># TBD</p>
<h1 id="异步编程httpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">异步编程</a></h1>
<p># TBD</p>
<h1 id="网络-apihttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">网络 API</a></h1>
<h2 id="网络httpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">网络</a></h2>
<p>In Raku, there are two APIs for dealing with networking: <code>IO::Socket::INET</code> (for synchronous networking), and <code>IO::Socket::Async</code> (for asynchronous networking).</p>
<p><code>IO::Socket::INET</code> currently only supports TCP connections. Its API resembles that of C&rsquo;s socket API. If you&rsquo;re familiar with that, then it won&rsquo;t take long to understand how to use it. For example, here&rsquo;s an echo server that closes the connection after receiving its first message:</p>
<p>在Raku中，有两个用于处理网络的API :( <code>IO::Socket::INET</code>用于同步网络）和<code>IO::Socket::Async</code>（用于异步网络）。</p>
<p><code>IO::Socket::INET</code>目前只支持TCP连接。它的API类似于C的套接字API。如果您熟悉它，那么理解如何使用它不会花费很长时间。例如，这是一个echo服务器，它在收到第一条消息后关闭连接：</p>
<pre tabindex="0"><code>my IO::Socket::INET $server .= new:
    :localhost&lt;localhost&gt;,
    :localport&lt;8000&gt;,
    :listen;
 
my IO::Socket::INET $client .= new: :host&lt;localhost&gt;, :port&lt;8000&gt;;
$client.print: &#39;Hello, world!&#39;;
 
my IO::Socket::INET $conn = $server.accept;
my Str $msg               = $conn.recv;
say $msg; # OUTPUT: Hello, world! 
$conn.print($msg);
 
say $client.recv; # OUTPUT: Hello, world! 
$conn.close;
$client.close;
$server.close;
</code></pre><p>By default, <code>IO::Socket::INET</code> connections are IPv4 only. To use IPv6 instead, pass <code>:family(PF_INET6)</code> when constructing a server or a client.</p>
<p>In contrast, <code>IO::Socket::Async</code> supports both IPv4 and IPv6 without the need to specify which family you wish to use. It also supports UDP sockets. Here&rsquo;s how you would write the same echo server as above asynchronously (note that <code>Supply.tap</code> is multithreaded; if this is undesirable, use <code>Supply.act</code> instead:</p>
<p>默认情况下，<code>IO::Socket::INET</code>连接仅限IPv4。要使用IPv6，请<code>:family(PF_INET6)</code>在构建服务器或客户端时传递。</p>
<p>相反，<code>IO::Socket::Async</code>支持IPv4和IPv6，无需指定要使用的族。它还支持UDP套接字。以下是如何异步编写与上面相同的echo服务器（请注意，这<code>Supply.tap</code>是多线程的;如果这是不合需要的，请<code>Supply.act</code>改用：</p>
<pre tabindex="0"><code>my $supply = IO::Socket::Async.listen(&#39;localhost&#39;, 8000);
my $server = $supply.tap(-&gt; $conn {
    $conn.Supply.tap(-&gt; $data {
        say $data; # OUTPUT: Hello, world! 
        await $conn.print: $data;
        $conn.close;
    })
});
 
my $client = await IO::Socket::Async.connect(&#39;localhost&#39;, 8000);
$client.Supply.tap(-&gt; $data {
    say $data; # OUTPUT: Hello, world! 
    $client.close;
    $server.close;
});
 
await $client.print: &#39;Hello, world!&#39;;
</code></pre><p>The equivalent code in Node.js looks like this:</p>
<p>Node.js中的等效代码如下所示：</p>
<pre tabindex="0"><code>const net = require(&#39;net&#39;);
 
const server = net.createServer(conn =&gt; {
    conn.setEncoding(&#39;utf8&#39;);
    conn.on(&#39;data&#39;, data =&gt; {
        console.log(data); # OUTPUT: Hello, world! 
        conn.write(data);
        conn.end();
    });
}).listen(8000, &#39;localhost&#39;);
 
const client = net.createConnection(8000, &#39;localhost&#39;, () =&gt; {
    client.setEncoding(&#39;utf8&#39;);
    client.on(&#39;data&#39;, data =&gt; {
        console.log(data); # OUTPUT: Hello, world! 
        client.end();
        server.close();
    });
    client.write(&#34;Hello, world!&#34;);
});
</code></pre><h2 id="httphttpshttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">HTTP/HTTPS</a></h2>
<p>Raku doesn&rsquo;t natively support HTTP/HTTPS. However, CPAN packages such as <a href="https://cro.services/">Cro</a> help fill the gap.</p>
<p>Raku本身不支持HTTP / HTTPS。然而，像<a href="https://cro.services/">Cro</a>这样的CPAN包填补了这个空白。</p>
<h2 id="dnshttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">DNS</a></h2>
<p>Raku does not currently support the majority of the features that Node.js&rsquo;s DNS module implements. <code>IO::Socket::INET</code> and <code>IO::Socket::Async</code> can resolve hostnames, but features like resolving DNS records and reverse IP lookups are not implemented yet. There are some modules that are a work in progress, such as <a href="https://github.com/tbrowder/Net-DNS-BIND-Manage-Raku/">Net::DNS::BIND::Manage</a>, that aim to improve DNS support.</p>
<p>Raku目前不支持Node.js的DNS模块实现的大多数功能。<code>IO::Socket::INET</code>并且<code>IO::Socket::Async</code>可以解析主机名，但尚未实现解析DNS记录和反向IP查找等功能。有些模块正在进行中，例如<a href="https://github.com/tbrowder/Net-DNS-BIND-Manage-Raku/">Net :: DNS :: BIND :: Manage</a>，旨在改善DNS支持。</p>
<h2 id="punycodehttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">Punycode</a></h2>
<p>Punycode support is available through the <a href="https://github.com/Kaiepi/p6-Net-LibIDN">Net::LibIDN</a>, <a href="https://github.com/Kaiepi/p6-Net-LibIDN2">Net::LibIDN2</a>, and <a href="https://github.com/FROGGS/p6-IDNA-Punycode">IDNA::Punycode</a> modules on CPAN.</p>
<p>通过CPAN上的<a href="https://github.com/Kaiepi/p6-Net-LibIDN">Net :: LibIDN</a>，<a href="https://github.com/Kaiepi/p6-Net-LibIDN2">Net :: LibIDN2</a>和<a href="https://github.com/FROGGS/p6-IDNA-Punycode">IDNA :: Punycode</a>模块可以获得Punycode支持。</p>
<h1 id="文件系统-apihttpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">文件系统 API</a></h1>
<p># TBD</p>
<h1 id="模块和包httpsdocsrakuorglanguagejs-nutshell___top"><a href="https://docs.raku.org/language/js-nutshell#___top">模块和包</a></h1>
<p># TBD</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Perl 5 到 Raku 指南 - 特殊变量]]></title>
            <link href="http://localhost:1313/rakulang/8.perl-5-to-perl-6-guide---special-variables/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/7.perl-5-to-perl-6-guide---syntax/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 语法" />
                <link href="http://localhost:1313/rakulang/6.perl-5-to-perl-6-guide---operators/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 运算符" />
                <link href="http://localhost:1313/rakulang/4.perl-5-to-perl-6-guide---overview/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 概览" />
                <link href="http://localhost:1313/rakulang/3.perl-5-to-perl-6-guide---in-a-nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 简而言之" />
                <link href="http://localhost:1313/rakulang/2.perl-6-by-example-p6-101/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 101 例" />
            
                <id>http://localhost:1313/rakulang/8.perl-5-to-perl-6-guide---special-variables/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-15T21:13:31+08:00</published>
            <updated>2018-10-15T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h2 id="描述">描述</h2>
<p>一个（希望）全面的 Perl 5 特殊变量列表及其 Raku 等价物，并在必要时记录它们之间的变化。</p>
<h2 id="注意">注意</h2>
<p>本文档试图引导读者从 Perl 5 中的特殊变量到 Raku 中的等效变量。有关 Raku 特殊变量的完整文档，请参阅每个变量的 Raku 文档。</p>
<h2 id="特殊变量">特殊变量</h2>
<h3 id="通用变量">通用变量</h3>
<ul>
<li>$ARG</li>
<li>$_</li>
</ul>
<p>值得庆幸的是， <code>$_</code> 是 Perl 5 中的常规默认变量。Raku 的主要区别在于现在你可以在它身上调用方法。 例如，Perl 5 的 <code>say $_</code> 可以在 Raku 中以 <code>$_.say</code> 表示。 此外，因为它是默认变量，您甚至不需要使用变量名称。 前面的例子也可以 通过使用 <code>.say</code> 实现。</p>
<ul>
<li>@ARG</li>
<li>@_</li>
</ul>
<p>由于 Raku 现在具有函数签名，您的参数可以去那里，而不是依赖于 <code>@_</code>。 事实上，如果你使用函数签名，使用 <code>@_</code> 会吐出你告诉它不能覆盖一个现有签名。</p>
<p>但是，如果您不使用函数签名，则 <code>@_</code> 将包含您传递给函数的参数, 就像它在Perl 5中那样。再次，与 <code>$_</code> 一样 ，您可以在其上调用方法。 与 <code>$_</code> 不同，你不能假设 <code>@_</code> 为 这些方法的默认变量（即 <code>@_.shift</code> works， <code>.shift</code> 不 work）。</p>
<ul>
<li>$LIST_SEPARATOR</li>
<li>$&quot;</li>
</ul>
<p>目前，Raku 中没有与 List Separator 变量等效的设计文档 S28 在那里说 不是一个，所以你可能不想屏住呼吸。</p>
<ul>
<li>$PROCESS_ID</li>
<li>$PID</li>
<li>$$</li>
</ul>
<p>在 Raku 中用 <code>$*PID</code> 替换 <code>$$</code></p>
<ul>
<li>$PROGRAM_NAME</li>
<li>$0</li>
</ul>
<p>您可以通过 <code>$*PROGRAM-NAME</code> 访问 Raku 中的程序名称 。 注意： Raku 中的 <code>$0</code> 是保持正则表达式匹配中第一个捕获值的变量（即捕获变量现在从 <code>$0</code> 而不是 <code>$1</code> 开始 )。</p>
<ul>
<li>$REAL_GROUP_ID</li>
<li>$GID</li>
<li>$(</li>
</ul>
<p>在 Raku 中，组信息由 <code>$*GROUP</code> 处理 ，它包含一个 IntStr 类型的对象  因此 可以在字符串或数字上下文中使用。 因此，组ID通过 <code>+$*GROUP</code> 获得 ， 而组名通过 <code>~$*GROUP</code> 获得 。</p>
<ul>
<li>$EFFECTIVE_GROUP_ID</li>
<li>$EGID</li>
<li>$)</li>
</ul>
<p>Raku目前似乎没有提供有效的组ID。</p>
<ul>
<li>$REAL_USER_ID</li>
<li>$UID</li>
<li>$&lt;</li>
</ul>
<p>在 Raku 中，用户信息由 <code>$*USER</code>处理 ，后者持有 IntStr 类型的对象，因此可以 可以在字符串或数字上下文中使用（这类似于处理组信息的方式） 由 <code>$*GROUP</code> 对象）。 因此，用户ID通过 <code>+$*USER</code> 获得 ，而用户名通过 <code>~$*USER</code> 获得 。</p>
<ul>
<li>$EFFECTIVE_USER_ID</li>
<li>$EUID</li>
<li>$&gt;</li>
</ul>
<p>Raku当前似乎没有提供有效的用户ID。</p>
<ul>
<li>$SUBSCRIPT_SEPARATOR</li>
<li>$SUBSEP</li>
<li>$;</li>
</ul>
<p>Raku中不包含下标分隔符变量。坦率地说，如果你的Perl 5代码正在使用它，那就是 几乎可以肯定，真的很老。</p>
<ul>
<li>$a</li>
<li>$b</li>
</ul>
<p><code>$a</code> 和 <code>$b</code> 在 Raku 中没有特殊含义 <code>.sort()</code> 不会将它们用于任何特殊的东西。 他们只是常规的旧变量。 通过使用具有更多功能的占位符参数的块来扩展此功能。 占位符变量是使用 <code>^twigil</code> 创建的 （例如 <code>$^z</code> 。它们可以在裸块中使用或在没有显式参数列表的子程序。 块的参数将分配给占位符 Unicode 顺序中的变量。 I. e。 即使变量出现在块中的顺序 （<code>$^q</code>, <code>$^z</code>, <code>$^a</code>） ，它们将按顺序分配 （<code>$^a</code>, <code>$^q</code>, <code>$^z</code>） 。 人机工程学：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">sort</span> <span class="p">{</span> <span class="nv">$^a</span> <span class="ow">cmp</span> <span class="nv">$^z</span> <span class="p">}</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «(1 2 3 4 5 6)␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">sort</span> <span class="p">{</span> <span class="nv">$^g</span> <span class="ow">cmp</span> <span class="nv">$^a</span> <span class="p">}</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «(6 5 4 3 2 1)␤» </span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">9</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$^c</span><span class="o">,</span> <span class="nv">$^a</span><span class="o">,</span> <span class="nv">$^b</span><span class="p">;</span> <span class="nb">last</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «312␤» </span>
</span></span></code></pre></div><p>有关占位符变量的更多信息，请参阅<a href="https://docs.raku.org/language/variables#The_%5E_Twigil">此页面</a></p>
<ul>
<li>%ENV</li>
</ul>
<p>％ENV已被Raku中的％*ENV取代。请注意，此哈希的键可能不完全是 在Perl 5和Raku之间相同。例如， Raku的％ENV中缺少OLDPWD 。</p>
<ul>
<li>$OLD_PERL_VERSION</li>
<li>$]</li>
</ul>
<p>Raku 的运行版本由 <code>$*PERL</code> 特殊变量保存，即一个对象。 正在运行的版本是 通过 <code>$*PERL.version</code> 检索 ，返回类似 <code>v6.c</code> 的内容 ; Perl 的完整字符串化版本解释器是通过 <code>~$*PERL</code> 获得的 ，它返回类似于 Raku（6.c）的内容 。</p>
<ul>
<li>$SYSTEM_FD_MAX</li>
<li>$^F</li>
</ul>
<p>虽然设计文件（S28）表明这可能会变成 <code>$*SYS_FD_MAX</code> ，但这还没有b被实现。</p>
<ul>
<li>@F</li>
</ul>
<p>[需要进一步研究]此时有点混乱。 设计文档S28表示 @F in Perl 5在Raku中被 @_ 取代 ，但目前还不清楚它是如何工作的。 另一方面，它是目前的 有点问题，因为 Perl 5 to Raku Translation doc 指出 <code>-a</code> 和 <code>-F</code> 命令 - rakudo 尚未实现行开关。</p>
<ul>
<li>@INC</li>
</ul>
<p>Raku 中不再存在。请使用“use lib”来操作要搜索的模块存储库。 该 最接近 <code>@INC</code> 的是 <code>$*REPO</code>。 但这与@INC完全不同 因为 Raku 的预编译功能。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Print out a list of compunit repositories </span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="vg">$*REPO</span><span class="o">.</span><span class="nf">repo-chain</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li>%INC</li>
</ul>
<p>Raku 中不再存在。因为每个 Repository 都负责记住哪些模块已经装好了。 您可以获得所有已加载模块（编译单元）的列表，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">Test</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">MyModule</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">flat</span> <span class="vg">$*REPO</span><span class="o">.</span><span class="nf">repo-chain</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">loaded</span><span class="p">);</span> <span class="c1">#-&gt; (MyModule Test) </span>
</span></span></code></pre></div><ul>
<li>$INPLACE_EDIT</li>
<li>$^I</li>
</ul>
<p>S28 建议使用 <code>$*INPLACE_EDIT</code>，但它尚不存在。</p>
<ul>
<li>$^M</li>
</ul>
<p>S28 建议使用 <code>$*EMERGENCY_MEMORY</code>，但它尚不存在。</p>
<ul>
<li>$OSNAME</li>
<li>$^o</li>
</ul>
<p>这有点不清楚。 它可能取决于你的意思是“操作系统的名称” 作为设计文档 <a href="https://design.raku.org/S28.html">S28</a> 有三个不同的建议，所有建议都给出了不同的答案。</p>
<p>目前有三个主要对象包含有关“运行环境”的信息：</p>
<ul>
<li><code>$*KERNEL</code> 提供有关正在运行的操作系统内核的信息;</li>
<li><code>$*DISTRO</code> 提供有关操作系统分发的信息;</li>
<li><code>$*VM</code> 提供有关 Raku 的运行后端机器的信息。</li>
</ul>
<p>以上所有对象都有共同的方法：</p>
<ul>
<li><code>version</code> 提供该组件的版本号;</li>
<li><code>name</code> 提供该组件的助记符名称;</li>
<li><code>auth</code> 为该组件提供已知作者。</li>
</ul>
<p>作为一个简短示例，以下代码打印有关上述所有组件的信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="vg">$*KERNEL</span><span class="o">,</span> <span class="vg">$*DISTRO</span><span class="o">,</span> <span class="vg">$*VM</span> <span class="k">-&gt;</span> <span class="nv">$what</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$what</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">version </span><span class="p">&#39;</span>  <span class="o">~</span> <span class="nv">$what</span><span class="o">.</span><span class="nb">version</span>
</span></span><span class="line"><span class="cl">        <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> named </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$what</span><span class="o">.</span><span class="nb">name</span>
</span></span><span class="line"><span class="cl">        <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> by </span><span class="p">&#39;</span>    <span class="o">~</span> <span class="nv">$what</span><span class="o">.</span><span class="nb">auth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Kernel </span>
</span></span><span class="line"><span class="cl"><span class="c1"># version 4.10.0.42.generic named linux by unknown </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Distro </span>
</span></span><span class="line"><span class="cl"><span class="c1"># version 17.04.Zesty.Zapus named ubuntu by https://www.ubuntu.com/ </span>
</span></span><span class="line"><span class="cl"><span class="c1"># VM </span>
</span></span><span class="line"><span class="cl"><span class="c1"># version 2017.11 named moar by The MoarVM Team </span>
</span></span></code></pre></div><p>上面所有的 <code>Str</code> 方法产生了当前时间的信息的短版本名字 。</p>
<p>所有对象都有其他方法，在尝试识别正确运行的实例时非常有用， 有关更多信息，请使用 <code>&lt;.^methods&gt;</code> 来内省以上所有内容。</p>
<ul>
<li>%SIG</li>
</ul>
<p>没有等效变量。 要在接收信号时执行代码，您可以调用 <a href="https://docs.raku.org/routine/signal#%28Supply%29_sub_signal">signal</a> 子程序，返回可以点击的 <code>Supply</code> 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$SIG</span><span class="p">{&#34;</span><span class="s2">INT</span><span class="p">&#34;}</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">bye</span><span class="p">&#34;;</span> <span class="nb">exit</span> <span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">)</span><span class="o">.</span><span class="nb">tap</span><span class="o">:</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">bye</span><span class="p">&#34;;</span> <span class="nb">exit</span> <span class="p">};</span> <span class="k">loop</span> <span class="p">{}</span>
</span></span></code></pre></div><p>或者，如果您有一个通用代码，想知道它得到了哪个信号：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">)</span><span class="o">.</span><span class="nb">tap</span><span class="o">:</span> <span class="k">-&gt;</span> <span class="nv">$signal</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">bye with </span><span class="nv">$signal</span><span class="p">&#34;;</span> <span class="nb">exit</span> <span class="p">};</span> <span class="k">loop</span> <span class="p">{}</span>
</span></span></code></pre></div><p>在事件驱动的情况下使用信号的更惯用的方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">react</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">whenever</span> <span class="nb">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">goodbye</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">done</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>$BASETIME</li>
<li>$^T</li>
</ul>
<p>在 Raku 中用 <code>$*INIT-INSTANT</code> 替换 。 与 Perl 5 不同，这不是自纪元以来的秒数，而是一个 <a href="https://docs.raku.org/type/Instant">Instant</a> 对象，以原子秒计，带有分数。</p>
<ul>
<li>$PERL_VERSION</li>
<li>$^V</li>
</ul>
<p>与 <code>$]</code> 一样，这已被 <code>$*PERL.version</code> 取代。</p>
<ul>
<li>${^WIN32_SLOPPY_STAT}</li>
</ul>
<p>在 Raku 中没有类似的东西。</p>
<ul>
<li>$EXECUTABLE_NAME</li>
<li>$^X</li>
</ul>
<p>这已被 <code>$*EXECUTABLE-NAME</code> 取代 。 请注意，还有 <code>$*EXECUTABLE</code> ，这在 Raku 中是一个 <code>IO</code> 对象。</p>
<h3 id="与正则表达式相关的变量">与正则表达式相关的变量</h3>
<h4 id="性能问题">性能问题</h4>
<p>如下所示，  <code>$``, </code>$&amp;<code>和</code>$&rsquo;<code>从 Raku 中删除了，主要由</code>$/` 和它的变体代替， 消除它们，Perl 5 中的相关性能问题不适用。</p>
<ul>
<li><code>$&lt;digits&gt; ($1, $2, ...)</code></li>
</ul>
<p>Raku 中的这些现有变量与 Perl 5 中的相同，除了它们现在从 <code>$0</code> 开始而不是 <code>$1</code>。 此外，它们是匹配变量 <code>$/</code> 中索引项的同义词。 例如  <code>$0</code> 相当于 <code>$/[0]， </code>$1<code>相当于</code>$/[1]`等。</p>
<ul>
<li>$MATCH</li>
<li>$＆</li>
</ul>
<p><code>$/</code> 现在包含<a href="https://docs.raku.org/type/Match">匹配</a>对象，因此 <code>$＆</code> 的 Perl 5 行为可以通过字符串化来获得，即 <code>~$/</code> 。 请注意，虽然 <code>$/.Str</code> 也可以工作， 但 <code>~$/</code> 目前是更常见的用法。</p>
<ul>
<li>${^MATCH}</li>
</ul>
<p>由于以前的性能问题已经废除，因此 Raku 中没有使用此变量。</p>
<ul>
<li>$PREMATCH</li>
<li>$`</li>
</ul>
<p>替换为 <code>$/.prematch</code> 。</p>
<ul>
<li>${^PREMATCH}</li>
</ul>
<p>由于以前的性能问题已经废除，因此 Raku 中没有使用此变量。</p>
<ul>
<li>$POSTMATCH</li>
<li>$'</li>
</ul>
<p>替换为 <code>$/.postmatch</code>。</p>
<ul>
<li>${^POSTMATCH}</li>
</ul>
<p>由于以前的性能问题已经废除，因此 Raku 中没有使用此变量。</p>
<ul>
<li>$LAST_PAREN_MATCH</li>
<li>$+</li>
</ul>
<p>在 Raku 中不存在，但你可以使用 <code>$/[*-1].Str</code> 获得相同的信息。(<code>$/[*-1]</code> 将是匹配对象，而不是实际的字符串)。</p>
<p>如果您想了解其工作原理，可以查看以下文档：</p>
<ul>
<li><a href="https://docs.raku.org/routine/%5B%20%5D#language_documentation_Operators">[]routine</a> 例程</li>
<li><a href="https://docs.raku.org/type/Whatever">Whatever</a></li>
</ul>
<p>可能</p>
<ul>
<li><a href="https://design.raku.org/S02.html#line_1126">https://design.raku.org/S02.html#line_1126</a></li>
</ul>
<p>虽然设计文件并不总是最新的。</p>
<ul>
<li>$LAST_SUBMATCH_RESULT</li>
<li>$^N</li>
</ul>
<p>S28 建议 <code>$*MOST_RECENT_CAPTURED_MATCH</code> ，但似乎没有任何实现的变量匹配 <code>$^N</code>.</p>
<ul>
<li>@LAST_MATCH_END</li>
<li>@+</li>
</ul>
<p>与大多数正则表达式相关的变量一样，此功能至少部分地移至 Raku 中的 <code>$/</code>  变量。或者，在这种情况下，编号变量是索引的别名。 偏移是通过使用 <code>.to</code> 方法找到。 例如, 第一个偏移是 <code>$/[0].to</code> ，它与 <code>$0.to</code> 同义。 Perl 5 提供的 <code>$+[0]</code>  由 <code>$/.to</code> 提供。</p>
<ul>
<li>%LAST_PAREN_MATCH</li>
<li>%+</li>
</ul>
<p>再一次，我们转移到 <code>$/</code>。 前面的 <code>$+{$match}</code> 是 <code>$/{$match}</code>。</p>
<ul>
<li>@LAST_MATCH_START</li>
<li>@-</li>
</ul>
<p>类似于使用 <code>.to</code> 方法替换 <code>@+</code> ，使用 <code>$/</code> 上的 <code>.from</code> 方法替换 <code>@-</code> 及其变化。 第一个偏移是 <code>$/[0].from</code> 或等价的 <code>$0.from</code>。 Perl 5 的 <code>$-[0]</code> 是 <code>$/.from</code>。</p>
<ul>
<li>%LAST_MATCH_START</li>
<li>%-</li>
</ul>
<p>与 <code>%+</code> 非常相似 ，使用 <code>%-{$match}</code> 将替换为 <code>$/{$match}</code> 。</p>
<ul>
<li>$LAST_REGEXP_CODE_RESULT</li>
<li>$^R</li>
</ul>
<p>没有等价物。</p>
<ul>
<li>${^RE_DEBUG_FLAGS}</li>
</ul>
<p>没有等价物。</p>
<ul>
<li>${^RE_TRIE_MAXBUF}</li>
</ul>
<p>没有等价物。</p>
<h4 id="与文件句柄相关的变量">与文件句柄相关的变量</h4>
<ul>
<li>$ARGV</li>
</ul>
<p>读取行时当前文件的名称可以通过 <code>$*ARGFILES.path</code> 获得。</p>
<ul>
<li>@ARGV</li>
</ul>
<p><code>@*ARGS</code> 包含命令行参数。</p>
<ul>
<li>ARGV</li>
</ul>
<p>这被 <code>$*ARGFILES</code> 取代 。</p>
<ul>
<li>ARGVOUT</li>
</ul>
<p>由于尚未实现 <code>-i</code> 命令行开关，因此还没有相当于 <code>ARGVOUT</code> 的功能 。</p>
<ul>
<li>$OUTPUT_FIELD_SEPARATOR</li>
<li>$OFS</li>
<li>$</li>
</ul>
<p>目前没有明显的等价物</p>
<ul>
<li>$INPUT_LINE_NUMBER</li>
<li>$NR</li>
<li>$.</li>
</ul>
<p>不存在直接替代品。</p>
<p>迭代时使用 行方法 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 或 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 类型，您可以在其上调用 <code>.kv</code> 方法 获取交错的索引和值列表（然后每个循环迭代2次）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">lines</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$n</span><span class="o">,</span> <span class="nv">$line</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;{</span><span class="nv">$n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span><span class="s2">: </span><span class="nv">$line</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1: a </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2: b </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 3: c </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 4: d </span>
</span></span></code></pre></div><p>对于 <a href="https://docs.raku.org/type/IO::CatHandle">IO::CatHandle</a> 类型（其中 <code>$*ARGFILES</code> 是一个），你可以使用 <a href="https://docs.raku.org/type/IO::CatHandle#method_on-switch">on-switch</a> hook 在句柄开关上重置行号，并手动递增。 另请参阅 <a href="https://modules.raku.org/repo/IO::CatHandle::AutoLines">IO::CatHandle::AutoLines</a> 和 <a href="https://modules.raku.org/repo/LN">LN</a> 模块简化此操作。</p>
<ul>
<li>$INPUT_RECORD_SEPARATOR</li>
<li>$RS</li>
<li>$/</li>
</ul>
<p>这可以通过文件句柄上的 <code>.nl-in</code> 方法访问 。 例如。 <code>$*IN.nl-in</code>。</p>
<ul>
<li>$OUTPUT_RECORD_SEPARATOR</li>
<li>$ORS</li>
<li>$\</li>
</ul>
<p>这可以通过文件句柄上的 <code>.nl-out</code> 方法访问 。 例如 <code>$*OUT.nl-out</code>。</p>
<ul>
<li>$OUTPUT_AUTOFLUSH</li>
<li>$|</li>
</ul>
<p>没有全球替代品。 对于其他设置，TTY 句柄默认是无缓冲的 <a href="https://docs.raku.org/routine/out-buffer">out-buffer</a> 设置为零或者使用 <code>:!out-buffer</code> 在特定的 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a>上和 open 一块使用 。</p>
<ul>
<li>${^LAST_FH}</li>
</ul>
<p>在 Raku 中没有实现。</p>
<h4 id="与格式相关的变量">与格式相关的变量</h4>
<p>Raku中没有内置格式。</p>
<h3 id="错误变量">错误变量</h3>
<p>关于 Raku 中的错误变量如何变化，因此这里不再详细说明。</p>
<p>引用 Raku <a href="https://docs.raku.org/language/variables#index-entry-%2524%21">docs</a> 中的说法，<code>$!</code> 是错误变量。</p>
<p>与 Raku 的其余部分一样，它是一个根据类型返回各种内容的错误类型或<a href="https://docs.raku.org/type/Exception">异常</a> 。</p>
<p>特别是在处理<a href="https://docs.raku.org/type/Exception">异常</a>时, <code>$!</code> 提供有关抛出异常的信息， 假设程序没有停止：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">fail</span> <span class="p">&#34;</span><span class="s2">Boooh</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">CATCH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># within the catch block </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># the exception is placed into $_ </span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">within the catch:</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$_</span><span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> : </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">message</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$_</span><span class="o">.</span><span class="nb">resume</span><span class="p">;</span> <span class="c1"># do not abort </span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># outside the catch block the exception is placed </span>
</span></span><span class="line"><span class="cl"><span class="c1"># into $! </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">outside the catch:</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$!</span><span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> : </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$!</span><span class="o">.</span><span class="nb">message</span><span class="p">;</span>
</span></span></code></pre></div><p>以上代码生成以下输出</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">within</span> <span class="nf">the</span> <span class="nf">catch:</span>
</span></span><span class="line"><span class="cl"><span class="ne">X::AdHoc</span> <span class="o">:</span> <span class="n">Boooh</span>
</span></span><span class="line"><span class="cl"><span class="n">outside</span> <span class="nf">the</span> <span class="nf">catch:</span>
</span></span><span class="line"><span class="cl"><span class="ne">X::AdHoc</span> <span class="o">:</span> <span class="n">Boooh</span>
</span></span></code></pre></div><p>因此，如前所述， <code>$!</code> 变量保存异常对象。</p>
<h3 id="与解释器状态相关的变量">与解释器状态相关的变量</h3>
<ul>
<li>$COMPILING</li>
<li>$^C</li>
<li>$^D</li>
</ul>
<p>目前没有这些变量的等价物。</p>
<ul>
<li>${^ENCODING}</li>
</ul>
<p>虽然在 Perl 5 中已弃用 ，但在 <code>$?ENC</code> 中 可能有某种等价物 ，但这还远未明朗。</p>
<ul>
<li>${^GLOBAL_PHASE}</li>
</ul>
<p>没有 Raku 等价物。</p>
<ul>
<li>$^H</li>
<li>%^H</li>
<li>${^OPEN}</li>
</ul>
<p>在 Raku 中可能有也可能没有这些等价物，但它们是内部的，你不应该搞乱 与他们在一起 - 当然，如果您对 Raku 的理解需要您阅读本文，那么肯定不会阅读该文献&hellip;</p>
<ul>
<li>$PERLDB</li>
<li>$^P</li>
</ul>
<p>Raku 调试器与 Perl 5 调试器相似的可能性最小，此时此处也是如此，似乎不等于这个变量。</p>
<ul>
<li>${^TAINT}</li>
</ul>
<p>S28 声称这个变量是“待定”的。 目前不在 Raku 中。</p>
<ul>
<li>${^UNICODE}</li>
<li>${^UTF8CACHE}</li>
<li>${^UTF8LOCALE}</li>
</ul>
<p>这些与 Unicode 相关的变量似乎不存在于 Raku 中，但是 - 也许？ - 可能在某处有 <code>$?ENC</code> 类似物吗？  然而，这完全未经证实。</p>
<h3 id="弃用和删除变量">弃用和删除变量</h3>
<p>不言而喻，因为已经从 Perl 5 中删除了这些，所以应该没有必要告诉你如何在 Raku 中使用它们。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Perl 5 到 Raku 指南 - 语法]]></title>
            <link href="http://localhost:1313/rakulang/7.perl-5-to-perl-6-guide---syntax/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/6.perl-5-to-perl-6-guide---operators/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 运算符" />
                <link href="http://localhost:1313/rakulang/4.perl-5-to-perl-6-guide---overview/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 概览" />
                <link href="http://localhost:1313/rakulang/3.perl-5-to-perl-6-guide---in-a-nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 简而言之" />
                <link href="http://localhost:1313/rakulang/2.perl-6-by-example-p6-101/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 101 例" />
                <link href="http://localhost:1313/rakulang/1.brief-introduction/?utm_source=atom_feed" rel="related" type="text/html" title="简介" />
            
                <id>http://localhost:1313/rakulang/7.perl-5-to-perl-6-guide---syntax/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-14T21:13:31+08:00</published>
            <updated>2018-10-14T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="描述httpsdocsrakuorglanguage5to6-perlsyn___top"><a href="https://docs.raku.org/language/5to6-perlsyn#___top">描述</a></h1>
<p>关于 Perl 5 和 Raku 之间差异的全面（希望）描述。</p>
<h1 id="注意httpsdocsrakuorglanguage5to6-perlsyn___top"><a href="https://docs.raku.org/language/5to6-perlsyn#___top">注意</a></h1>
<p>我<em>不会</em>详细解释 Raku 语法。本文档旨在指导你从 Perl 5 中的工作原理过渡到 Raku 中的等效工具。有关 Raku 语法的完整文档，请参阅 Raku 文档。</p>
<h1 id="自由形式httpsdocsrakuorglanguage5to6-perlsyn___top"><a href="https://docs.raku.org/language/5to6-perlsyn#___top">自由形式</a></h1>
<p>Raku 仍然<em>主要是</em>自由形式。但是，有一些情况下，空白的存在或缺失现在很重要。例如，在 Perl 5 中，你可以省略关键字后面的空格（例如 <code>while($x &lt; 5)</code> 或 <code>my($x, $y)</code>）。在 Raku 中，这个空白是必需的，因此 <code>while ($x &lt; 5)</code> 或 <code>my ($x, $y)</code>。但是，在 Raku 中，你可以完全省略括号：<code>while $x &lt; 5 </code>。这适用于 <code>if</code>，<code>for</code> 等等。</p>
<p>奇怪的是，在 Perl 5 中，你可以在数组或散列与其下标之间以及后缀运算符之间留出空格。所以 <code>$seen {$_} ++</code> 是有效的。Raku 再不这样了。Raku 中现在必须是 <code>%seen{$_}++</code>。</p>
<p>如果能让你感觉更好，你可以使用反斜杠来 “unspace” 空格，这样你就可以使用空格，否则它将被禁止。</p>
<p>有关详细信息，请参阅<a href="https://docs.raku.org/language/5to6-nutshell#Whitespace">空白</a>。</p>
<h2 id="声明httpsdocsrakuorglanguage5to6-perlsyn___top"><a href="https://docs.raku.org/language/5to6-perlsyn#___top">声明</a></h2>
<p>正如<a href="https://docs.raku.org/language/5to6-perlfunc">函数</a> 指南中所述，Raku 中没有 <code>undef</code> 。声明但未初始化的标量变量将计算其类型。换句话说，<code>my $x;say $x;</code> 会给你&quot;(Any)&quot;。<code>my Int $y;say $y;</code> 会给你&quot;(Int)&quot;。</p>
<h2 id="注释httpsdocsrakuorglanguage5to6-perlsyn___top"><a href="https://docs.raku.org/language/5to6-perlsyn#___top">注释</a></h2>
<p><code>#</code> 在 Perl 5 中开始一个运行到行尾的注释。</p>
<p>嵌入式注释以井号字符和反引号开头，后跟开口括号字符，并持续到匹配的闭合括号字符。像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="cm">#`( why would I ever write an inline comment here? )</span> <span class="kt">True</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">something stupid</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>与 Perl 5 一样，你可以使用 pod 指令在注释 <code>=begin comment</code> 之前和 <code>=end comment</code> 之后创建多行注释。</p>
<h2 id="真和假httpsdocsrakuorglanguage5to6-perlsyn___top"><a href="https://docs.raku.org/language/5to6-perlsyn#___top">真和假</a></h2>
<p>Perl 5 与 Raku 之间的一个真正区别在于，与 Perl 5 不同，Raku 将字符串<code>&quot;0&quot;</code> 视为真。数字 <code>0</code> 仍为 <code>false</code>，你可以使用前缀 <code>+</code> 将字符串 <code>&quot;0&quot;</code> 强制转换为数字以使其为 <code>false</code>。Raku 还具有实际的布尔类型，因此，在许多情况下，你可以使用 <code>True</code> 和 <code>False</code>，而无需担心哪些值计为 true 和 false。</p>
<h2 id="语句修饰符httpsdocsrakuorglanguage5to6-perlsyn___top"><a href="https://docs.raku.org/language/5to6-perlsyn#___top">语句修饰符</a></h2>
<p>大多数情况下，语句修饰符仍然有效，但有一些例外。</p>
<p>首先，<code>for</code> 循环是 Perl 5 中已知的 <code>foreach</code> 循环，C 风格的 <code>for</code>循环不用于 Raku。要获得该行为，你需要 <code>loop</code>。<code>loop</code> 不能用作语句修饰符。</p>
<p>在 Raku 中，你无法使用 <code>do {...} while $x</code> 形式。你将需要用 <code>repeat</code> 替换 <code>do</code> 形式。<code>do {...} until $x</code> 类似。</p>
<h2 id="复合语句httpsdocsrakuorglanguage5to6-perlsyn___top"><a href="https://docs.raku.org/language/5to6-perlsyn#___top">复合语句</a></h2>
<p>Perl 5 的最大变化是 <code>given</code> 在 Raku 中默认不是实验性质的或禁用的了。有关 <code>given</code> 的详细信息，请参阅<a href="https://docs.raku.org/language/control#given">此页面</a>。</p>
<h2 id="循环控制httpsdocsrakuorglanguage5to6-perlsyn___top"><a href="https://docs.raku.org/language/5to6-perlsyn#___top">循环控制</a></h2>
<p><code>next</code>，<code>last</code> 和 <code>redo</code> 在 Perl 5 到 Raku 中没有变化。</p>
<p>但是 <code>continue</code>，在 Raku 中不存在。你将在循环体中使用 <code>NEXT</code> 块。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="p">&#39;&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">next</span> <span class="k">if</span> <span class="nv">$_</span> <span class="nv">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$str</span> <span class="o">.=</span> <span class="nv">$_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">continue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$str</span> <span class="o">.=</span> <span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="p">&#39;&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">next</span> <span class="k">if</span> <span class="nv">$_</span> <span class="nv">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$str</span> <span class="o">~=</span> <span class="nv">$_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">NEXT</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$str</span> <span class="o">~=</span> <span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="for-循环httpsdocsrakuorglanguage5to6-perlsyn___top"><a href="https://docs.raku.org/language/5to6-perlsyn#___top">For 循环</a></h2>
<p>如上所述，C 风格的 <code>for</code> 循环在 Raku 中不称为 <code>for</code> 循环。它们只是 <code>loop</code> 循环。要编写无限循环，你不需要使用C语言风格的 <code>loop (;;) {...}</code>，只是完全省略规范：<code>loop {...}</code></p>
<h2 id="foreach-循环httpsdocsrakuorglanguage5to6-perlsyn___top"><a href="https://docs.raku.org/language/5to6-perlsyn#___top">Foreach 循环</a></h2>
<p>在 Perl 5 中，<code>for</code> 除了用于 C 风格的 <code>for</code> 循环之外，它还是<code>foreach</code> 的同义词。在 Raku 中，<code>for</code> 仅用于 <code>foreach</code> 样式的循环。</p>
<h2 id="switch-语句httpsdocsrakuorglanguage5to6-perlsyn___top"><a href="https://docs.raku.org/language/5to6-perlsyn#___top">Switch 语句</a></h2>
<p>Raku 具有真实的 switch 语句，通过提供 <code>given</code> 与由处理的单个情况的 <code>when</code> 和 <code>default</code>。基本语法是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="n">EXPR</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="n">EXPR</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="n">EXPR</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>完整的细节可以在<a href="https://docs.raku.org/language/control#given">这里</a>找到。</p>
<h2 id="gotohttpsdocsrakuorglanguage5to6-perlsyn___top"><a href="https://docs.raku.org/language/5to6-perlsyn#___top">Goto</a></h2>
<p><code>goto</code> 目前尚未实施（尚未）。标签<strong>已</strong>实现，可用作 <code>next</code>，<code>last</code> 和 <code>redo</code> 的目标：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">FOO:</span>                         <span class="c1"># Labels end with colons, like in Perl 5 </span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="o">^</span><span class="mi">10</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">outer for before</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">^</span><span class="mi">10</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">inner for</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">last</span> <span class="n">FOO</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">outer for after</span><span class="p">&#34;;</span>   <span class="c1"># Will not show because of the &#34;last&#34; </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># outer for before </span>
</span></span><span class="line"><span class="cl"><span class="c1"># inner for </span>
</span></span></code></pre></div><p>有关 <code>goto</code> 的计划，请参阅 <a href="https://design.raku.org/S04.html#The_goto_statement">https://design.raku.org/S04.html#The_goto_statement</a>。</p>
<h2 id="省略语句httpsdocsrakuorglanguage5to6-perlsyn___top"><a href="https://docs.raku.org/language/5to6-perlsyn#___top">省略语句</a></h2>
<p><code>...</code>（以及 <code>!!!</code> 和 <code>???</code>）用于创建存根(stub)声明。这比 Perl 5 中使用的 <code>...</code> 要复杂得多，所以你可能想要查看 <a href="https://design.raku.org/S06.html#Stub_declarations">https://design.raku.org/S06.html#Stub_declarations</a> 以了解详细信息。尽管如此，尽管它在 Raku 中的作用得到了扩展，但它似乎还没有<em>明显的</em>理由说明它为什么不能完成它在 Perl 5 中所扮演的角色。</p>
<h2 id="pods-嵌入式文档httpsdocsrakuorglanguage5to6-perlsyn___top"><a href="https://docs.raku.org/language/5to6-perlsyn#___top">PODs: 嵌入式文档</a></h2>
<p>Pod 已经在 Perl 5 和 Raku 之间发生了变化。可能最大的区别在于你需要将你的 pod 放在 <code>=begin pod</code> 和 <code>=end pod</code> 指令之间。这里和那里也有一些调整。例如，正如我在编写这些文档时发现的那样，垂直条（<code>|</code>）在 <code>X&lt;&gt;</code> 代码中很重要，并且不清楚如何将字面 <code>|</code> 插入他们。你最好的选择可能是使用 Raku 解释器检查你的 pod。你可以使 <code>--doc</code> 开关执行此操作。例如 <code>raku --doc Whatever.pod</code>。这将输出任何问题到标准错误。（根据你安装 raku 的方式/位置，你可能需要指定 <code>Pod::To::Text</code> 的位置。）有关 Raku 样式 pod 的详细信息，请访问 <a href="https://design.raku.org/S26.html">https://design.raku.org/S26.html</a>。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Perl 5 到 Raku 指南 - 运算符]]></title>
            <link href="http://localhost:1313/rakulang/6.perl-5-to-perl-6-guide---operators/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/4.perl-5-to-perl-6-guide---overview/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 概览" />
                <link href="http://localhost:1313/rakulang/3.perl-5-to-perl-6-guide---in-a-nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 简而言之" />
                <link href="http://localhost:1313/rakulang/2.perl-6-by-example-p6-101/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 101 例" />
                <link href="http://localhost:1313/rakulang/1.brief-introduction/?utm_source=atom_feed" rel="related" type="text/html" title="简介" />
                <link href="http://localhost:1313/rakulang/2018-10-08-mapgroupswithstate/?utm_source=atom_feed" rel="related" type="text/html" title="mapGroupsWithState" />
            
                <id>http://localhost:1313/rakulang/6.perl-5-to-perl-6-guide---operators/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-13T21:13:31+08:00</published>
            <updated>2018-10-13T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="描述httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">描述</a></h1>
<p>一个（希望）全面的 Perl 5 运算符列表及其 Raku 等价物，并在必要时记录它们之间的差异。</p>
<h1 id="注意httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">注意</a></h1>
<p>本文档<em>没有</em>详细解释运算符。本文档旨在指导您从 Perl 5 <code>perlop</code> 文档中的操作符过渡到 Raku 中的等效文档。有关 Raku 等效文档的完整文档，请参阅<a href="https://docs.raku.org/language/operators">Raku文档</a>。</p>
<h2 id="运算符优先级和关联性httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">运算符优先级和关联性</a></h2>
<p>运算符优先级表在 Raku 中与在 Perl 5 中有所不同，因此这里不再详述。如果您需要知道 Raku 中给定运算符的优先级和关联性，请参阅<a href="https://docs.raku.org/language/operators#Operator_precedence">运算符优先级</a>。</p>
<h2 id="项和列表运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">项和列表运算符</a></h2>
<p>Perl 5 <code>perlop</code> 文档中列出的作为一元运算符和列表运算符的内容在这个章节里往往可以被视为函数，例如 <code>print</code> 和 <code>chdir</code>。因此，您可以在<a href="https://docs.raku.org/language/5to6-perlfunc">函数</a>指南中找到有关它们的信息。括号仍用于分组。有一点需要注意：在 Raku 中，是<code>,</code>（逗号）创建列表<strong>而不是</strong>圆括号。所以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="p">;</span>   <span class="c1"># no parentheses needed </span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="p">;</span>    <span class="c1"># also no parentheses </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$scalar</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>      <span class="c1"># *not* a list, as there is no comma </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$list</span>   <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="p">);</span>     <span class="c1"># a List in a scalar container </span>
</span></span></code></pre></div><h2 id="箭头运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">箭头运算符</a></h2>
<p>由于您通常不会在 Raku 中使用引用，因此箭头作为解除引用运算符可能不太有用。但是，如果您确实需要解引用某些内容，则箭头就是点号。它也是方法调用的中的点号。因此，Perl 5 中的 <code>$arrayref-&gt;[7] </code> 在 Raku 中变成 <code>$arrayref.[7]</code>，类似地, <code>$user-&gt;name</code> 变成了 <code>$user.name</code>。<code>=&gt;</code> 箭头用于构建 Pair 对，参考<a href="https://docs.raku.org/language/terms#Pair">Pair 术语文档</a>。</p>
<h2 id="自动递增和自动递减httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">自动递增和自动递减</a></h2>
<p>和 Perl 5 中工作的一样。一个可能的警告是对于 <code>++</code> 它们调用 <code>succ</code> 方法, 对于 <code>--</code> 他们调用 <code>pred</code> 方法。对于内置数字类型，这是不太可能做一些不寻常的，但自定义类型可以定义自己的 <code>succ</code> 和 <code>pred</code> 方法，所以在这种情况下，你应该注意的是什么是 <code>++</code> 和 <code>--</code> <em>真正</em>能做的。</p>
<h2 id="指数httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">指数</a></h2>
<p>像你期望的那样工作。在 Perl 5 的 perlop 中关于 <code>**</code> 绑定比一元减号更紧密的警告（即 <code>-2 ** 4</code> 被计算为 <code>-(2 ** 4)</code> 而不是 <code>(-2) ** 4</code>）也适用于 Raku。</p>
<h2 id="符号一元运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">符号一元运算符</a></h2>
<p>如在 Perl 5 中那样，一元 <code>!</code> 和 <code>-</code> 进行逻辑和算术否定。<code>?^</code> 用于按位逻辑否定，文档指出这相当于 <code>!</code>。值得注意的是，这些分别强制他们的参数 为 <code>Bool</code> 和 <code>Numeric</code> 类型。</p>
<p>一元 <code>~</code> 是 Raku 中的字符串上下文运算符，因此使用前缀 <code>+^</code> 进行逐位整数否定。假设两个补码。</p>
<p><code>+</code> <em>确实</em>在 Raku 中产生作用，强转其参数为数值类型。</p>
<p>一元 <code>\</code> 没有了。如果你真的想要对现有的命名变量进行“引用”，你可以使用项上下文，如下所示：<code>$aref = item(@array)</code> 或者可以通过更熟悉的前缀 <code>$</code>： <code>$aref = $@array</code>。请注意，您并没有真正获得引用，而是一个带有引用对象的标量容器。</p>
<p>您可以使用 <code>&amp;</code> sigil 获取命名子例程的“引用” ：<code>$sref = &amp;foo</code>。匿名数组，散列和 sub 创建过程中<strong>立即</strong>返回底层对象：<code>$sref = sub { }</code>。</p>
<h2 id="绑定运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">绑定运算符</a></h2>
<p><code>=~</code> 和 <code>!~</code> 分别被 <code>~~</code> 和 <code>!~~</code> 取代。那些认为 Perl 5 中的智能匹配坏掉的人会很高兴听到它在 Raku 中运行得更好，因为更强的坚定意味着更少的猜测。有关<a href="https://docs.raku.org/language/operators#index-entry-smartmatch_operator">smartmatch</a>在 Raku 中的工作原理的更详细说明，请参阅<a href="https://docs.raku.org/language/operators#index-entry-smartmatch_operator">smartmatch 文档</a>。</p>
<h2 id="乘法运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">乘法运算符</a></h2>
<p>二元 <code>*</code>，<code>/</code> 和 <code>%</code> 分别执行乘法，除法和取模运算，和 Perl 5 中一样。</p>
<p>二元 <code>x</code> 运算符在 Raku 中略有不同，并且他有一个同伴儿。<code>print '-' x 80;</code> 给你一个 80 个破折号的字符串，但是对于 <code>@ones = (1) x 80;</code> 给你一个 80 个 “1” 的列表的 Perl 5行为，你会使用 <code>@ones = 1 xx 80;</code>。</p>
<h2 id="加法运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">加法运算符</a></h2>
<p>二元 <code>+</code> 和 <code>-</code> 分别进行加法和减法运算，如您所料。</p>
<p>由于 <code>.</code> 是方法调用运算符，所以二元 <code>~</code> 在 Raku 中充当字符串连接运算符。</p>
<h2 id="shift-operatorshttpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">Shift operators</a></h2>
<p><code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 已被 <code>+&lt;</code> 和 <code>+&gt;</code> 取代。</p>
<h2 id="命名一元运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">命名一元运算符</a></h2>
<p>如上所述，您可以在<a href="https://docs.raku.org/language/5to6-perlfunc">函数</a>指南中找到它们。</p>
<h2 id="关系运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">关系运算符</a></h2>
<p>这些都像 Perl 5 中那样工作。</p>
<h2 id="相等运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">相等运算符</a></h2>
<p><code>==</code> 和  <code>!=</code> 都像 Perl 5 中那样工作。</p>
<p><code>&lt;=&gt; </code> 和 <code>cmp</code> 在 Raku 中有不同的行为。<code>&lt;=&gt; </code> 做数值比较，但返回 <code>Order::Less</code>、<code>Order::Same</code> 或者 <code>Order::More</code> 而不是Perl 5 中的 <code>-1</code>、<code>0</code> 或 <code>1</code>。要获得 <code>cmp</code> 的 Perl 5 行为（使用它返回 <code>Order</code> 对象而不是整数的更改），您应该使用 <code>leg</code> 运算符。</p>
<p><code>cmp</code> 要么做 <code>&lt;=&gt;</code> 要么做 <code>leg</code>，这取决于其参数的现有类型。</p>
<p><code>~~</code> 是 Perl 5 中的智能匹配运算符，但它也<em>只是</em> Raku 中的匹配运算符，如上所述。有关智能匹配在 Raku 中的工作原理，请参阅<a href="https://docs.raku.org/language/operators#index-entry-smartmatch_operator">smartmatch文档</a>。</p>
<h2 id="智能匹配运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">智能匹配运算符</a></h2>
<p>有关<a href="https://docs.raku.org/language/operators#index-entry-smartmatch_operator">smartmatch</a>在 Raku 中的工作原理的更详细说明，请参阅<a href="https://docs.raku.org/language/operators#index-entry-smartmatch_operator">smartmatch文档</a>。</p>
<h2 id="bitwise-andhttpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">Bitwise And</a></h2>
<p>二元 <code>&amp;</code> 在 Raku 中是 <code>+&amp;</code>。</p>
<h2 id="bitwise-or-and-exclusive-orhttpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">Bitwise Or and Exclusive Or</a></h2>
<p>按位或已经从 Perl 5 中的 <code>|</code> 变成 Raku 中的 <code>+|</code>。同样地，按位 XOR <code>^</code> 变成了 <code>+^</code>。</p>
<h2 id="c-style-的逻辑和httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">C-style 的逻辑和</a></h2>
<p>不变。</p>
<h2 id="c-style-逻辑或httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">C-style 逻辑或</a></h2>
<p>不变。</p>
<h2 id="logical-defined-orhttpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">Logical Defined-Or</a></h2>
<p>在 Raku 中保持为 <code>//</code>。返回第一个有定义的操作数，或者返回最后一个操作数。此外，还有一个低优先级版本，称为 <code>orelse</code>。</p>
<h2 id="range-运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">Range 运算符</a></h2>
<p>在列表上下文中，<code>..</code> 作为范围运算符运行，不需要更改。也就是说，存在可能有用的排他性范围运算符。这些是：</p>
<ul>
<li>中缀 <code>..^</code> 不包括末端;</li>
<li>中缀 <code>^..</code> 不包括起点;</li>
<li>中缀 ``^..^` 不包括起点和末端;</li>
<li><code>^</code> 从零开始的前缀，不包括末端。</li>
</ul>
<p>以下示例显示了所有上述范围运算符的效果（请注意圆括号仅用于允许方法调用）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">..^</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="nb">list</span><span class="p">;</span>  <span class="c1"># (1 2 3 4) </span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">^..</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="nb">list</span><span class="p">;</span>  <span class="c1"># (2 3 4 5) </span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">^..^</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="nb">list</span><span class="p">;</span> <span class="c1"># (2 3 4) </span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="o">^</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="nb">list</span><span class="p">;</span>     <span class="c1"># (0 1 2 3 4) </span>
</span></span></code></pre></div><p>在 Perl 5 中，在标量上下文中，运算符 <code>..</code> 和 <code>...</code> 像触发器(flip-flop)操作符一样，即使它们鲜为人知且可能较少使用。Raku 中的那些运算符分别由<a href="https://docs.raku.org/routine/ff">ff</a>和<a href="https://docs.raku.org/routine/fff">fff</a>代替。</p>
<h2 id="条件运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">条件运算符</a></h2>
<p>条件运算符 <code>?:</code> 已替换为 <code>?? !!</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$x</span> <span class="o">=</span> <span class="nv">$ok</span>  <span class="o">?</span> <span class="nv">$yes</span>  <span class="o">:</span> <span class="nv">$no</span><span class="p">;</span>  <span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span> <span class="o">=</span> <span class="nv">$ok</span> <span class="o">??</span> <span class="nv">$yes</span> <span class="o">!!</span> <span class="nv">$no</span><span class="p">;</span>  <span class="c1"># Raku </span>
</span></span></code></pre></div><h2 id="赋值运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">赋值运算符</a></h2>
<p>虽然没有完整记录，但 S03 表明数学和逻辑赋值运算符应该像您期望的那样工作。一个值得注意的变化是 <code>.=</code> 在左侧的对象上调用可变方法（也可以是类型对象）。这允许以下有用的惯用法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LongClassName</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.frobnicate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">LongClassName</span> <span class="nv">$bar</span> <span class="o">.=</span> <span class="nb">new</span><span class="p">(</span> <span class="s">frobnicate</span> <span class="o">=&gt;</span> <span class="mi">42</span> <span class="p">);</span> <span class="c1"># no need to repeat class name </span>
</span></span></code></pre></div><p>这确保了 <code>$bar</code> 只能包含一个 <code>LongClassName</code> 对象，并且不必重复（并且可能拼写错误）类名。</p>
<p><code>~=</code> 是字符串连接赋值，正如您可能期望的更改 <code>.</code> 和 <code>~</code>。此外，按位赋值运算符可能不会分为数字和字符串版本（<code>&amp;=</code> 等等，相对 <code>&amp;.=</code> 等），因为该功能目前在 Perl 5 本身中是实验性的 - 尽管，这并没有具体记录。</p>
<h2 id="逗号运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">逗号运算符</a></h2>
<p>逗号运算符大多按预期工作，但从技术上讲，它创建<a href="https://docs.raku.org/type/List">列表</a>）或分隔函数调用中的参数。此外，还有一个 <code>:</code> 变体可以将函数调用转换为方法调用 - 请参阅<a href="https://docs.raku.org/language/operators#infix_%253A">此页面</a>。</p>
<p><code>=&gt; </code>运算符，或<em>胖箭头</em>，工作方式类似于 Perl 5 的“胖逗号”，因为它允许在其左侧的无引号（普通）标识符，但在 Raku 中它构造 Pair 对象，而不是仅仅作为分隔符发挥作用。如果您试图将一行 Perl 5 代码直接翻译为 Raku，它应该会按预期运行。</p>
<h2 id="列表运算符-rightwardhttpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">列表运算符 (rightward)</a></h2>
<p>与命名一元运算符一样，您可以在<a href="https://docs.raku.org/language/5to6-perlfunc">函数</a>下找到这些。</p>
<h2 id="逻辑非httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">逻辑非</a></h2>
<p><code>!</code> 的优先级较低版本。对于 <code>!</code>，强转其参数为 <code>Bool</code>。</p>
<h2 id="逻辑和httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">逻辑和</a></h2>
<p>如 Perl 5 中的 较低优先级版本的 <code>&amp;&amp;</code> 一样。</p>
<h2 id="逻辑或或独占或httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">逻辑或或独占或</a></h2>
<p><code>or</code> 是低优先级版本的 <code>||</code>，并且 <code>xor</code> 是低优先级版本的 <code>^^</code>。</p>
<p>此外，还有一个低优先级版本的 <code>//</code>，称为 <code>orelse</code>。</p>
<h2 id="引用和引用类似的运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">引用和引用类似的运算符</a></h2>
<p>有关引用构造的所有详细信息，请参阅<a href="https://docs.raku.org/language/quoting">引用</a>。</p>
<p>有一个引用运算符，允许绝对的文字字符串：<code>Q</code> 或者 <code>｢…｣</code>，尽管后者可能很难在你的键盘上找到，这取决于你的键盘&hellip;&hellip;反斜杠转义也<em>没有</em>应用在 <code>Q</code> 引用的字符串上。例如 <code>Q{This is still a closing curly brace → \}</code> 合成的是 &ldquo;This is still a closing curly brace → &quot;。</p>
<p><code>q</code> 做你期望的，允许反斜杠转义。例如 <code>q{This is not a closing curly brace → \}, but this is → }</code> 返回 &ldquo;This is not a closing curly brace → }, but this is →&quot;。与 Perl 5 一样，您可以使用单引号获得此行为。</p>
<p><code>qq</code> 允许变量插值。但是，默认情况下，只插入标量变量。要获得其他变量插值，您需要在它们后面放置方括号（所谓的<a href="https://docs.raku.org/language/subscripts#index-entry-Zen_slices">zen-slice</a>）以使它们进行插值。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">1 2 3</span><span class="p">&gt;;</span> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="k">qq</span><span class="p">/</span><span class="nv">@a</span><span class="s2">[] example</span><span class="nv">@example</span><span class="s2">.com</span><span class="p">/;</span>
</span></span></code></pre></div><p>结果为 “1 2 3 <a href="mailto:example@example.com">example@example.com</a>”。哈希以相同的方式进行插值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="nv">%a</span><span class="p">{}&#34;;</span>
</span></span></code></pre></div><p>导致空格分隔 Pair 对儿, Tab 将每对中的键与值分开（因为这是 <code>Pair</code> 的标准字符串化，并且哈希在字符串化时充当 <code>Pair</code> 的列表）。您还可以使用花括号在字符串中插入 Raku 代码。有关所有详细信息，请参阅<a href="https://docs.raku.org/language/quoting#Interpolation%253A_qq">插值</a>。</p>
<p><code>qw</code> 像 Perl 5 中那样工作，也可以呈现为 <code>&lt;...&gt;</code>。例如 <code>qw/a b c/</code> 相当于 <code>&lt;a b c&gt;</code>。</p>
<p>还有一个能插值的 <code>qw</code> 版本，即 <code>qqw</code>。所以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="k">qq</span><span class="sa">w</span><span class="p">/</span><span class="nv">$a</span><span class="s2"> b c</span><span class="p">/;</span>
</span></span></code></pre></div><p>给你 “42 b c”。</p>
<p>Shell 引用可以通过 <code>qx</code> 获得，但是你应该注意，反引号不像 Perl 5 那样进行 shell 引用，并且 Perl 变量<em>不</em>在 <code>qx</code> 字符串中进行插值。如果需要在 shell 命令字符串中插入 Perl 变量，则可以改为使用 <code>qqx</code>。</p>
<p>Raku 中没有 <code>qr</code> 运算符了。</p>
<p><code>tr///</code> 与 Perl 5 中的工作方式类似。需要注意的是范围的指定方式不同。您可以使用“a..z”代替使用范围“a-z”，即使用 Perl 的范围运算符。<code>tr///</code> 有一个方法版本，记录的更好，称为 <code>.trans</code>。<code>.trans</code> 使用 Pair 对儿的列表，如下所示：可以在<a href="https://design.raku.org/S05.html#Transliteration">https://design.raku.org/S05.html#Transliteration中</a>找到更广泛的使用说明。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$x</span><span class="o">.</span><span class="nb">trans</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">[</span><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="p">&#39;</span><span class="s1">A</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">C</span><span class="p">&#39;</span><span class="o">],</span> 
</span></span><span class="line"><span class="cl">    <span class="o">[</span><span class="p">&#39;</span><span class="s1">d</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="p">&#39;</span><span class="s1">D</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">Q</span><span class="p">&#39;</span><span class="o">],</span> 
</span></span><span class="line"><span class="cl">    <span class="o">[</span><span class="p">&#39;</span><span class="s1">r</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="p">&#39;</span><span class="s1">R</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span></code></pre></div><p>等价的 <code>y///</code> 已经废除了。</p>
<p>在 Raku 中 <code>:to</code> 以不同方式指定了 Heredocs。您可以使用引号运算符，例如，<code>q:to/END/;</code> 将以 “END” 开头的 heredoc 结尾。类似地，您可以根据引用运算符进行转义和插值，即带有 <code>Q</code> 的文字值, 带有 <code>q</code>  的反斜杠转义和带有插值的 <code>qq</code>。</p>
<h2 id="io-运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">I/O 运算符</a></h2>
<p>有关 Raku 中输入/输出的完整详细信息，请参阅<a href="https://docs.raku.org/language/io">io</a>。</p>
<p>因为 <code>&lt;...&gt; </code> 与 Raku 中的 quote-words 构造一样，<code>&lt;&gt; </code> 不用于从文件中读取行。您可以通过 <code>IO</code> 从文件名创建对象或使用打开的文件句柄然后在任何一种情况下在它身上调用 <code>.lines</code> 来实现。或者例如 <code>my @a = &quot;filename&quot;.IO.lines;</code> 或 <code>my $fh = open &quot;filename&quot;, :r;my @a = $fh.lines;</code>（在后一种情况下，我们使用 <code>:r</code> 专门打开用于读取的文件）。要以迭代方式执行此操作，可以用以下方式 使用 <code>for</code> 循环：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">&#39;</span><span class="s1">huge-csv</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Do something with $line </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意那里的 <code>-&gt;</code> 用法。这是块语法的一部分，而在 Raku 中要用在 <code>if</code>，<code>for</code>，<code>while</code> 等块中。</p>
<p>如果你想将整个文件 slurp 为标量，你会惊讶的！- 使用 <code>.slurp</code> 方法。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">filename</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ... or ... </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#34;</span><span class="s2">filename</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">:</span><span class="s">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="nv">$fh</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>
</span></span></code></pre></div><p>如<a href="https://docs.raku.org/language/5to6-perlvar">特殊变量</a>指南中所述，<code>ARGV</code> 魔术输入文件句柄已被替换 <code>$*ARGFILES</code>，并且<code>@ARGV</code> 命令行参数数组已被替换 <code>@*ARGS</code>。</p>
<h2 id="no-opshttpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">No-ops</a></h2>
<p><code>1 while foo();</code> 与 Perl 5 中的工作方式相同，但它会生成警告。在 Raku 中，这个惯用法现在被写成了 <code>Nil while foo();</code>。</p>
<h2 id="按位字符串运算符httpsdocsrakuorglanguage5to6-perlop___top"><a href="https://docs.raku.org/language/5to6-perlop#___top">按位字符串运算符</a></h2>
<p>单独记录在上面了，但总结如下&hellip;&hellip;</p>
<p>按位整数否定加上前缀 <code>+^</code>。按位布尔否定是 <code>?^</code>。</p>
<p>按位与是 <code>+&amp;</code>。</p>
<p>按位整数或是 <code>+|</code>。按位整数 xor 是中缀 <code>+^</code>。按位布尔或是 <code>?|</code>。</p>
<p>左移和右移是 <code>+&lt;</code> 和 <code>+&gt;</code>。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Perl 5 到 Raku 指南 - 概览]]></title>
            <link href="http://localhost:1313/rakulang/4.perl-5-to-perl-6-guide---overview/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/3.perl-5-to-perl-6-guide---in-a-nutshell/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 5 到 Raku 指南 - 简而言之" />
                <link href="http://localhost:1313/rakulang/2.perl-6-by-example-p6-101/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 101 例" />
                <link href="http://localhost:1313/rakulang/1.brief-introduction/?utm_source=atom_feed" rel="related" type="text/html" title="简介" />
                <link href="http://localhost:1313/rakulang/2018-10-08-mapgroupswithstate/?utm_source=atom_feed" rel="related" type="text/html" title="mapGroupsWithState" />
                <link href="http://localhost:1313/rakulang/2018-10-05-command-line-arguments-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的命令行参数" />
            
                <id>http://localhost:1313/rakulang/4.perl-5-to-perl-6-guide---overview/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-12T21:13:31+08:00</published>
            <updated>2018-10-12T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>这些文档不应该被误认为是初学者教程或 Raku 的宣传概述; 它旨在作为具有很强 Perl 5 背景的人学习 Raku 的技术参考，以及任何将 Perl 5 代码移植到 Raku 的人。</p>
<h1 id="raku-in-a-nutshellhttpsdocsrakuorglanguage5to6-overview___top"><a href="https://docs.raku.org/language/5to6-overview#___top">Raku in a nutshell</a></h1>
<p><a href="https://docs.raku.org/language/5to6-nutshell">果壳中的 Raku</a>提供了语法，运算符，复合语句，正则表达式，命令行标志以及各种其他零碎内容的快速概述。</p>
<h1 id="句法差异httpsdocsrakuorglanguage5to6-overview___top"><a href="https://docs.raku.org/language/5to6-overview#___top">句法差异</a></h1>
<p><a href="https://docs.raku.org/language/5to6-perlsyn">语法章节</a>提供的 Perl 5 和 Raku 之间的语法区别的一个概述：它是如何保持大部分形式自由的，写注释的其他方法，以及 <code>switch</code> 如何是一个很 Raku 的东西。</p>
<h1 id="raku-中的运算符httpsdocsrakuorglanguage5to6-overview___top"><a href="https://docs.raku.org/language/5to6-overview#___top">Raku 中的运算符</a></h1>
<p><a href="https://docs.raku.org/language/5to6-perlop">运算符章节</a>将引导您从<a href="https://metacpan.org/pod/distribution/perl/pod/perlop.pod">Perl 5 的 perlop</a>运算符在Raku 中的等价物。</p>
<h1 id="raku-中的函数httpsdocsrakuorglanguage5to6-overview___top"><a href="https://docs.raku.org/language/5to6-overview#___top">Raku 中的函数</a></h1>
<p>该<a href="https://docs.raku.org/language/5to6-perlfunc">函数章节</a>描述了所有的 Perl 5 函数和它们的 Raku 等价物和任何行为差异。它还提供了对提供 Perl 5 函数行为的生态系统模块的引用，这些函数存在于 Raku 中，具有稍微不同的语义（例如 <code>shift</code>），或者在 Raku 中不存在（例如 <code>tie</code>）。</p>
<h1 id="raku-中的特殊变量httpsdocsrakuorglanguage5to6-overview___top"><a href="https://docs.raku.org/language/5to6-overview#___top">Raku 中的特殊变量</a></h1>
<p><a href="https://docs.raku.org/language/5to6-perlvar">特殊变量章节</a>描述很多 Perl 5 中的特殊（标点符号）变量是否以及如何在 Raku 中的支持。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Perl 5 到 Raku 指南 - 简而言之]]></title>
            <link href="http://localhost:1313/rakulang/3.perl-5-to-perl-6-guide---in-a-nutshell/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/2.perl-6-by-example-p6-101/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 101 例" />
                <link href="http://localhost:1313/rakulang/1.brief-introduction/?utm_source=atom_feed" rel="related" type="text/html" title="简介" />
                <link href="http://localhost:1313/rakulang/2018-10-08-mapgroupswithstate/?utm_source=atom_feed" rel="related" type="text/html" title="mapGroupsWithState" />
                <link href="http://localhost:1313/rakulang/2018-10-05-command-line-arguments-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的命令行参数" />
                <link href="http://localhost:1313/rakulang/2018-10-04-perl-6-code-in-rmarkdown/?utm_source=atom_feed" rel="related" type="text/html" title="Rmarkdown 中的 Raku 代码" />
            
                <id>http://localhost:1313/rakulang/3.perl-5-to-perl-6-guide---in-a-nutshell/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-11T21:13:31+08:00</published>
            <updated>2018-10-11T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>这个页面试图提供从 Perl 5 到 Raku 的语法和语义变化的快速路径。无论在 Perl 5 中有什么用，必须在 Raku 中以不同的方式编写，这里应该列出（而许多新的 Raku 特性和惯用法）不需要）。</p>
<p>因此，这不应该被误认为初学者教程或 Raku 的宣传概述;它旨在作为 Raku 学习者的技术参考，具有强大的 Perl 5 背景，以及任何将 Perl 5 代码移植到 Raku 的人（尽管注意到自动翻译可能更方便）。</p>
<p>关于语义的注释;当我们在本文档中说“现在”时，我们大多只是说“现在你正在试用 Raku”。我们并不是要暗示 Perl 5 现在突然过时了。恰恰相反，我们大多数人都喜欢 Perl 5，我们期望 Perl 5 能够继续使用多年。实际上，我们更重要的目标之一是使 Perl 5 和 Raku 之间的交互顺利进行。然而，我们也喜欢 Raku 中的设计决策，它们比 Perl 5 中的许多历史设计决策更新，可以说是更好的集成。我们很多人都希望在接下来的十年或两年内，Raku 将成为更主要的语言。如果你想在未来的意义上采取“现在”，那也没关系。但是我们根本不会对导致战斗的任何/或者思考感兴趣。</p>
<h2 id="cpan">CPAN</h2>
<p>参考 <a href="https://modules.raku.org/">https://modules.raku.org/</a></p>
<p>如果您使用的模块尚未转换为 Raku，并且本文档中未列出任何替代方案，则可能尚未解决其在 Raku 下的使用问题。</p>
<p><a href="https://github.com/niner/Inline-Perl5/">Inline::Perl5</a> 项目通过使用 Perl 解释器的嵌入式实例来运行 Perl 5 代码，可以直接从 Raku 代码中使用 Perl 5 模块。</p>
<p>这很简单：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># the :from&lt;Perl5&gt; makes Raku load Inline::Perl5 first (if installed) </span>
</span></span><span class="line"><span class="cl"><span class="c1"># and then load the Scalar::Util module from Perl 5 </span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Scalar::Util</span><span class="p">:</span><span class="n">from</span><span class="sr">&lt;Perl5&gt;</span> <span class="sr">&lt;looks_like_number&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">looks_like_number</span> <span class="s">&#34;foo&#34;</span><span class="p">;</span>   <span class="c1"># 0 </span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">looks_like_number</span> <span class="s">&#34;42&#34;</span><span class="p">;</span>    <span class="c1"># 1 </span>
</span></span></code></pre></div><p>许多 Perl 5 模块已经移植到 Raku，试图尽可能多地维护这些模块的 API，作为 CPAN Butterfly Plan 的一部分。 这些可以在 <a href="https://modules.raku.org/t/CPAN5">https://modules.raku.org/t/CPAN5</a> 找到。</p>
<p>许多 Perl 5 内置函数（目前大约 100个）已经以相同的语义移植到 Raku。 考虑一下 Perl 5 中的 shift 函数默认情况下从 <code>@_</code> 或 <code>@ARGV</code> 转移，具体取决于上下文。 这些可以在 <a href="https://modules.raku.org/t/Perl5">https://modules.raku.org/t/Perl5</a> 找到，作为可单独加载的模块，在 <a href="https://modules.raku.org/dist/P5built-ins">P5built-ins</a> 包中可以一次性获取所有这些模块。</p>
<h2 id="语法">语法</h2>
<p>两种语言之间的语法有一些差异，从如何定义标识符开始。</p>
<h3 id="标识符">标识符</h3>
<p>Raku 允许在标识符中使用破折号（ <code>-</code> ），下划线（<code>_</code>），撇号（<code>'</code>）和字母数字：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">test-doesn&#39;t-hang</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$ความสงบ</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\Δ</span> <span class="o">=</span> <span class="mi">72</span><span class="p">;</span> <span class="nb">say</span> <span class="mi">72</span> <span class="o">-</span> <span class="n">Δ</span><span class="p">;</span>
</span></span></code></pre></div><h3 id="-httpsdocsrakuorglanguage5to6-nutshell___top-方法调用"><a href="https://docs.raku.org/language/5to6-nutshell#___top">-&gt;</a> 方法调用</h3>
<p>如果您已经阅读过任何 Raku 代码，那么很明显，方法调用语法现在使用的是点而不是箭头：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="nv">$person</span><span class="o">-&gt;</span><span class="n">name</span>  <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$person</span><span class="o">.</span><span class="nb">name</span>   <span class="c1"># Raku </span>
</span></span></code></pre></div><p>点符号更容易键入，更符合行业标准。 但我们也想偷取其他东西的箭头。 （如果你想知道的话，现在用 <code>~</code> 运算符完成连接。）</p>
<p>要调用在运行时之前名称未知的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="nv">$object</span><span class="o">-&gt;</span><span class="nv">$methodname</span><span class="p">(</span><span class="nv">@args</span><span class="p">);</span>  <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$object</span><span class="o">.</span><span class="p">&#34;</span><span class="nv">$methodname</span><span class="p">&#34;(</span><span class="nv">@args</span><span class="p">);</span> <span class="c1"># Raku</span>
</span></span></code></pre></div><p>如果省略引号，那么 Raku 要求 <code>$methodname</code> 包含一个 <code>Method</code> 对象，而不是该方法的简单字符串名称。 是的，Raku 中的所有内容都可以被视为一个对象。</p>
<h2 id="空白">空白</h2>
<p>即使启用了严格的模式和警告，Perl 5也允许在使用空格时具有惊人的灵活性：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># unidiomatic but valid Perl 5 </span>
</span></span><span class="line"><span class="cl"><span class="n">say</span><span class="s">&#34;Hello &#34;</span><span class="o">.</span><span class="nb">ucfirst</span>  <span class="p">(</span><span class="nv">$people</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="nv">$</span> <span class="nv">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">-&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="s">&#34;!&#34;</span><span class="k">if</span><span class="nv">$greeted</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">;</span>
</span></span></code></pre></div><p>Raku 还支持程序员的自由和创造力，但平衡语法灵活性与其设计目标一致，即具有支持单遍解析和有用错误消息的一致，确定性，可扩展语法，干净地集成自定义运算符等功能，并且不会引导程序员 意外地错误表达他们的意图。 此外，“代码高尔夫”的实践略微不再强调; Raku 的设计理念比按键更简洁。</p>
<p>因此，语法中有许多地方，其中空格在 Perl 5 中是可选的，但在 Raku 中是强制的或禁止的。许多这些限制不太可能涉及很多真实的 Perl 代码（例如，不允许在空白之间使用空格） sigil和变量的名称），但有一些不幸与 Perl 黑客的习惯编码风格冲突：</p>
<p>在参数列表的左括号之前不允许有空格。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="nb">substr</span> <span class="p">(</span><span class="nv">$s</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1"># Perl 5 (in Raku this would try to pass a single </span>
</span></span><span class="line"><span class="cl">                       <span class="c1">#         argument of type List to substr) </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">substr</span><span class="p">(</span><span class="nv">$s</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl"><span class="nb">substr</span> <span class="nv">$s</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1"># Raku - alternative parentheses-less style </span>
</span></span></code></pre></div><p>如果这真的是一个问题，那么你可能想看看 Raku 生态系统中的 <code>Slang::Tuxic</code> 模块：它改变了 Raku 的语法，你可以在开放之前有一个空格 参数列表的括号。</p>
<ul>
<li>关键字后立即需要空格</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span><span class="p">(</span><span class="nv">$alpha</span><span class="p">,</span> <span class="nv">$beta</span><span class="p">);</span>          <span class="c1"># Perl 5, tries to call my() sub in Raku </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">$alpha</span><span class="o">,</span> <span class="nv">$beta</span><span class="p">);</span>         <span class="c1"># Raku </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="nv">$a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>          <span class="c1"># Perl 5, dies in Raku </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>         <span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>           <span class="c1"># Raku, more idiomatic </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="nv">$x--</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>     <span class="c1"># Perl 5, dies in Raku </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="nv">$x--</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>    <span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="nv">$x--</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>      <span class="c1"># Raku, more idiomatic </span>
</span></span></code></pre></div><ul>
<li>前缀运算符之后或 postfix/postcircumfix运算符（包括数组/散列下标）之前不允许有空格。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="nv">$seen</span> <span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="o">++</span><span class="p">;</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">%seen</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>   <span class="c1"># Raku </span>
</span></span></code></pre></div><ul>
<li>中缀运算符之前所需的空白，如果它与现有的 postfix/postcircumfix运算符冲突。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="nv">$n</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">;</span>   <span class="c1"># Perl 5 (in Raku this would conflict with postcircumfix &lt; &gt;) </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1"># Raku </span>
</span></span></code></pre></div><ul>
<li>但是，在方法调用期间允许使用空格！</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@books</span> <span class="o">=</span> <span class="nv">$xml</span>
</span></span><span class="line"><span class="cl">  <span class="o">-&gt;</span><span class="n">parse_file</span><span class="p">(</span><span class="nv">$file</span><span class="p">)</span>          <span class="c1"># some comment </span>
</span></span><span class="line"><span class="cl">  <span class="o">-&gt;</span><span class="n">findnodes</span><span class="p">(</span><span class="s">&#34;/library/book&#34;</span><span class="p">);</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@books</span> <span class="o">=</span> <span class="nv">$xml</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="nf">parse-file</span><span class="p">(</span><span class="nv">$file</span><span class="p">)</span>           <span class="c1"># some comment </span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="nf">findnodes</span><span class="p">(&#34;</span><span class="s2">/library/book</span><span class="p">&#34;);</span>
</span></span></code></pre></div><p>但是，请注意，您可以使用<a href="https://docs.raku.org/language/syntax#Unspace">unspace</a>在Raku代码中添加空格，否则不允许这样做。</p>
<p>另请参见<a href="https://docs.raku.org/language/syntax#Lexical_conventions">语法页面中的其他词法约定</a>。</p>
<h2 id="符号">符号</h2>
<p>在 Perl 5 中，数组和哈希值根据访问方式使用更改的符号。在 Raku 中，无论变量如何被使用，这些符号都是不变的 - 您可以将它们视为变量名称的一部分。</p>
<h3 id="-标量">$ 标量</h3>
<p><code>$</code> 符号现在总是与“标量”变量（例如 <code>$name</code>）一起使用，而不再用于<a href="https://docs.raku.org/language/5to6-nutshell#%5B%5D_Array_indexing%2Fslicing">数组索引</a>和<a href="https://docs.raku.org/language/5to6-nutshell#%7B%7D_Hash_indexing%2Fslicing">散列索引</a>。 也就是说，您仍然可以使用 <code>$x[1]</code> 和 <code>$x{&quot;foo&quot;}</code>，但它将作用于 <code>$x</code>，对类似名称的 <code>@x</code> 或 <code>%x</code>没有影响。 现在可以使用<code>@x[1]</code> 和 <code>%x{&quot;foo&quot;}</code> 访问这些内容。</p>
<h3 id="-数组">@ 数组</h3>
<p>@ 符号现在总是与&quot;数组&quot;变量一起使用（例如 <code>@months</code>，<code>@months[2]</code>，<code>@months[2, 4]</code>），而不再用于<a href="https://docs.raku.org/language/5to6-nutshell#%7B%7D_Hash_indexing%2Fslicing">值切片哈希</a>。</p>
<h3 id="-散列">% 散列</h3>
<p><code>%</code> 符号现在总是与“哈希”变量一起使用（例如 <code>%calories</code>, <code>%calories&lt;apple&gt;</code>, <code>%calories&lt;pear plum&gt;</code>），而不再用于<a href="https://docs.raku.org/language/5to6-nutshell#%5B%5D_Array_indexing%2Fslicing">键/值切片数组</a>。</p>
<h3 id="sub">Sub</h3>
<p><code>&amp;</code> 符号现在一直使用（并且没有反斜杠的帮助）来引用命名子例程/运算符的函数对象而不调用它，即使用名称作为“名词”而不是“动词”：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$sub</span> <span class="o">=</span> <span class="o">\&amp;</span><span class="n">foo</span><span class="p">;</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$sub</span> <span class="o">=</span> <span class="nv">&amp;foo</span><span class="p">;</span>  <span class="c1"># Raku </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">callback</span> <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="n">say</span> <span class="nv">@_</span> <span class="p">}</span>  <span class="c1"># Perl 5 - can&#39;t pass built-in sub directly </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="s">callback</span> <span class="o">=&gt;</span> <span class="nv">&amp;say</span>            <span class="c1"># Raku - &amp; gives &#34;noun&#34; form of any sub </span>
</span></span></code></pre></div><p>由于 Raku 在完成编译后不允许在词法范围内添加/删除符号，因此没有等效于 Perl 5 的 undef＆foo;，并且将定义与 Perl 5 定义的 ＆foo 最接近的符号::（&rsquo;＆foo&rsquo;） （使用“动态符号查找”语法）。 但是，您可以使用我的＆foo声明一个可变的命名子例程; 然后通过分配给＆foo在运行时更改其含义。</p>
<p>在 Perl 5 中，与普通子调用相比，＆符号可以另外用于以特殊方式调用子例程，具有略微不同的行为。 在 Raku 中，这些特殊形式不再可用：</p>
<ul>
<li>&amp;foo(&hellip;) 用于规避函数原型</li>
</ul>
<p>在 Raku 中没有原型，不管你是否传递一个文字代码块或一个包含代码对象的变量作为参数，它就不再有区别了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># Perl 5: </span>
</span></span><span class="line"><span class="cl"><span class="n">first_index</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="p">}</span> <span class="nv">@values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">&amp;</span><span class="n">first_index</span><span class="p">(</span><span class="nv">$coderef</span><span class="p">,</span> <span class="nv">@values</span><span class="p">);</span> <span class="c1"># (disabling the prototype that parses a </span>
</span></span><span class="line"><span class="cl">                                     <span class="c1"># literal block as the first argument) </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku: </span>
</span></span><span class="line"><span class="cl"><span class="nb">first</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="p">}</span><span class="o">,</span> <span class="nv">@values</span><span class="o">,</span> <span class="p">:</span><span class="s">k</span><span class="p">;</span>   <span class="c1"># the :k makes first return an index </span>
</span></span><span class="line"><span class="cl"><span class="nb">first</span> <span class="nv">$coderef</span><span class="o">,</span> <span class="nv">@values</span><span class="o">,</span> <span class="p">:</span><span class="s">k</span><span class="p">;</span>
</span></span></code></pre></div><p>＆FOO; 和goto＆foo; 重新使用调用者的参数列表/替换调用堆栈中的调用者。 Raku可以使用callame进行重新调度，也可以使用nextsame和nextx，它们在Perl 5中没有完全等效。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span> <span class="p">{</span> <span class="n">say</span> <span class="s">&#34;before&#34;</span><span class="p">;</span> <span class="o">&amp;</span><span class="n">bar</span><span class="p">;</span>     <span class="n">say</span> <span class="s">&#34;after&#34;</span> <span class="p">}</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">before</span><span class="p">&#34;;</span> <span class="nf">bar</span><span class="p">(</span><span class="o">|</span><span class="nv">@_</span><span class="p">);</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">after</span><span class="p">&#34;</span> <span class="p">}</span> <span class="c1"># Raku - have to be explicit </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span> <span class="p">{</span> <span class="n">say</span> <span class="s">&#34;before&#34;</span><span class="p">;</span> <span class="nb">goto</span> <span class="o">&amp;</span><span class="n">bar</span> <span class="p">}</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">proto</span> <span class="n">foo</span> <span class="ow">(|)</span> <span class="p">{</span><span class="o">*</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">foo</span> <span class="p">(</span> <span class="kt">Any</span> <span class="nv">$n</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Any</span><span class="p">&#34;;</span> <span class="nb">say</span> <span class="nv">$n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nf">foo</span> <span class="p">(</span> <span class="kt">Int</span> <span class="nv">$n</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Int</span><span class="p">&#34;;</span> <span class="nb">callsame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1"># /language/functions#index-entry-dispatch_callsame </span>
</span></span></code></pre></div><h3 id="-glob">* Glob</h3>
<p>在Perl 5中，<code>*</code> sigil引用了 Perl 用于存储非词法变量，文件句柄，子和格式的 GLOB 结构。</p>
<p>当文件句柄需要传递给子文件时，您最有可能在早期Perl版本上编写的代码中遇到 GLOB，该版本不支持词法文件句柄。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># Perl 5 - ancient method </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">read_2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">local</span> <span class="p">(</span><span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">scalar</span><span class="p">(</span><span class="sr">&lt;H&gt;</span><span class="p">),</span> <span class="nb">scalar</span><span class="p">(</span><span class="sr">&lt;H&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">open</span> <span class="n">FILE</span><span class="p">,</span> <span class="s">&#39;&lt;&#39;</span><span class="p">,</span> <span class="nv">$path</span> <span class="ow">or</span> <span class="nb">die</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">$line1</span><span class="p">,</span> <span class="nv">$line2</span><span class="p">)</span> <span class="o">=</span> <span class="n">read_2</span><span class="p">(</span><span class="o">*</span><span class="n">FILE</span><span class="p">);</span>
</span></span></code></pre></div><p>在转换为 Raku 之前，您应该重构 Perl 5 代码以消除对 GLOB 的需求。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># Perl 5 - modern use of lexical filehandles </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">read_2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="p">(</span><span class="nv">$fh</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">scalar</span><span class="p">(</span><span class="sr">&lt;$fh&gt;</span><span class="p">),</span> <span class="nb">scalar</span><span class="p">(</span><span class="sr">&lt;$fh&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">open</span> <span class="k">my</span> <span class="nv">$in_file</span><span class="p">,</span> <span class="s">&#39;&lt;&#39;</span><span class="p">,</span> <span class="nv">$path</span> <span class="ow">or</span> <span class="nb">die</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">$line1</span><span class="p">,</span> <span class="nv">$line2</span><span class="p">)</span> <span class="o">=</span> <span class="n">read_2</span><span class="p">(</span><span class="nv">$in_file</span><span class="p">);</span>
</span></span></code></pre></div><p>这里只是一个可能的 Raku 翻译：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">read-n</span><span class="p">(</span><span class="nv">$fh</span><span class="o">,</span> <span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nv">$fh</span><span class="o">.</span><span class="nb">get</span> <span class="ow">xx</span> <span class="nv">$n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$in-file</span> <span class="o">=</span> <span class="nb">open</span> <span class="nv">$path</span> <span class="ow">or</span> <span class="nb">die</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">$line1</span><span class="o">,</span> <span class="nv">$line2</span><span class="p">)</span> <span class="o">=</span> <span class="nf">read-n</span><span class="p">(</span><span class="nv">$in-file</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span></code></pre></div><h2 id="数组索引切片">数组索引/切片</h2>
<p>数组上的索引和切片操作不再会影响变量的符号，副词可用于控制切片的类型：</p>
<ul>
<li>索引</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="nv">$months</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@months</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span> <span class="c1"># Raku - @ instead of $ </span>
</span></span></code></pre></div><ul>
<li>值切片</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="nb">join</span> <span class="s">&#39;,&#39;</span><span class="p">,</span> <span class="nv">@months</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="o">..</span><span class="mi">11</span><span class="p">];</span> <span class="c1"># Perl 5 and Raku </span>
</span></span></code></pre></div><ul>
<li>键/值切片</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">join</span> <span class="p">&#39;</span><span class="s1">,</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">%months</span><span class="o">[</span><span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">..</span><span class="mi">11</span><span class="o">]</span><span class="p">;</span>    <span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">join</span> <span class="p">&#39;</span><span class="s1">,</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">@months</span><span class="o">[</span><span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">..</span><span class="mi">11</span><span class="o">]</span><span class="p">:</span><span class="s">kv</span><span class="p">;</span> <span class="c1"># Raku - @ instead of %; use :kv adverb </span>
</span></span></code></pre></div><p>另请注意，下标方括号现在是一个普通的postcircumfix运算符，而不是一个特殊的句法形式，因此<a href="https://docs.raku.org/language/5to6-nutshell#exists">检查元素的存在</a>和<a href="https://docs.raku.org/language/5to6-nutshell#delete">未设置元素</a>是通过副词完成的。</p>
<h2 id="-散列索引切片">{} 散列索引/切片</h2>
<p>散列上的索引和切片操作不再影响变量的符号，副词可用于控制切片的类型。此外，单字下标不再在花括号内神奇地自动引用;相反，新的尖括号版本可用，它始终自动引用其内容（使用与 <code>qw</code> //引用构造相同的规则）：</p>
<ul>
<li>索引</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="nv">$calories</span><span class="p">{</span><span class="s">&#34;apple&#34;</span><span class="p">};</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%calories</span><span class="p">{&#34;</span><span class="s2">apple</span><span class="p">&#34;};</span> <span class="c1"># Raku - % instead of $ </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="nv">$calories</span><span class="p">{</span><span class="n">apple</span><span class="p">};</span>   <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%calories</span><span class="p">&lt;</span><span class="s">apple</span><span class="p">&gt;;</span>   <span class="c1"># Raku - angle brackets; % instead of $ </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">%calories</span><span class="p">«</span><span class="s2">&#34;</span><span class="nv">$key</span><span class="s2">&#34;</span><span class="p">»;</span>  <span class="c1"># Raku - double angles interpolate as a list of Str </span>
</span></span></code></pre></div><ul>
<li>值切片</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="nb">join</span> <span class="s">&#39;,&#39;</span><span class="p">,</span> <span class="nv">@calories</span><span class="p">{</span><span class="s">&#39;pear&#39;</span><span class="p">,</span> <span class="s">&#39;plum&#39;</span><span class="p">};</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">join</span> <span class="p">&#39;</span><span class="s1">,</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">%calories</span><span class="p">{&#39;</span><span class="s1">pear</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">plum</span><span class="p">&#39;};</span> <span class="c1"># Raku - % instead of @ </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">join</span> <span class="p">&#39;</span><span class="s1">,</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">%calories</span><span class="p">&lt;</span><span class="s">pear plum</span><span class="p">&gt;;</span>      <span class="c1"># Raku (prettier version) </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$keys</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">pear plum</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">join</span> <span class="p">&#39;</span><span class="s1">,</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">%calories</span><span class="p">«</span><span class="nv">$keys</span><span class="p">»;</span>          <span class="c1"># Raku the split is done after interpolation</span>
</span></span></code></pre></div><ul>
<li>键/值索引</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="nb">join</span> <span class="s">&#39;,&#39;</span><span class="p">,</span> <span class="nv">%calories</span><span class="p">{</span><span class="s">&#39;pear&#39;</span><span class="p">,</span> <span class="s">&#39;plum&#39;</span><span class="p">};</span>    <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">join</span> <span class="p">&#39;</span><span class="s1">,</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">%calories</span><span class="p">{&#39;</span><span class="s1">pear</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">plum</span><span class="p">&#39;}:</span><span class="s">kv</span><span class="p">;</span> <span class="c1"># Raku - use :kv adverb </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">join</span> <span class="p">&#39;</span><span class="s1">,</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">%calories</span><span class="p">&lt;</span><span class="s">pear plum</span><span class="p">&gt;:</span><span class="s">kv</span><span class="p">;</span>      <span class="c1"># Raku (prettier version) </span>
</span></span></code></pre></div><p>还要注意，下标花括号现在是一个普通的 postcircumfix 操作符而不是一个特殊的语法形式，因此检查键的存在和删除键是用副词完成的。</p>
<h2 id="创建引用并使用它们">创建引用并使用它们</h2>
<p>在 Perl 5 中，在创建时返回对匿名数组和散列和 subs 的引用。 使用\运算符生成对现有命名变量和 subs 的引用。 “引用/解除引用”这个比喻并没有干净地映射到实际的 Raku 容器系统，所以我们必须关注引用运算符的意图而不是实际的语法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$aref</span> <span class="o">=</span> <span class="o">\</span><span class="nv">@aaa</span>  <span class="p">;</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><p>例如，这可能用于将引用传递给例程。但是在Raku中，传递了（单个）底层对象（你可以认为它是一种通过引用传递）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="mi">4</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">15</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="nv">$_</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">66</span> <span class="p">}(</span><span class="nv">@array</span><span class="p">);</span>   <span class="c1"># run the block with @array aliased to $_ </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@array</span><span class="p">;</span> <span class="c1">#  OUTPUT: «[66 8 15]» </span>
</span></span></code></pre></div><p>传递 <code>@array</code> 的基础Array对象，并在声明的例程中修改其第一个值。</p>
<p>在 Perl 5 中，取消引用整个引用的语法是 type-sigil 和花括号，在花括号内引用。 在 Raku 中，这个概念根本不适用，因为参考隐喻并不真正适用。</p>
<p>在 Perl 5 中，箭头运算符 <code>-&gt;</code> 用于单个访问复合引用或通过引用调用 sub。 在 Raku 中，点运算符。 始终用于对象方法，但其余方法并不真正适用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="nv">$arrayref</span><span class="o">-&gt;</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="nv">$hashref</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;fire bad&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="nv">$subref</span><span class="o">-&gt;</span><span class="p">(</span><span class="nv">$foo</span><span class="p">,</span> <span class="nv">$bar</span><span class="p">);</span>
</span></span></code></pre></div><p>在相对较新版本的 Perl 5（5.20及更高版本）中，新功能允许使用箭头运算符进行解除引用：请参阅 <a href="https://metacpan.org/pod/release/SHAY/perl-5.20.1/pod/perl5200delta.pod#Experimental_Postfix_Dereferencing">Postfix Dereferencing</a>。 这可以用于从标量创建数组。 此操作通常称为 decont，如在去包容化中，并且在Raku中使用诸如 <code>.list</code> 和 <code>.hash</code> 之类的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># Perl 5.20 </span>
</span></span><span class="line"><span class="cl">    <span class="k">use</span> <span class="nn">experimental</span> <span class="sx">qw&lt; postderef &gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="nv">$arrayref</span><span class="o">-&gt;</span><span class="nv">@</span><span class="err">*;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="nv">$hashref</span><span class="o">-&gt;</span><span class="nv">%</span><span class="err">*;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">my</span> <span class="nv">@slice</span> <span class="o">=</span> <span class="nv">$arrayref</span><span class="o">-&gt;</span><span class="nv">@</span><span class="err">[</span><span class="nv">3</span><span class="o">..</span><span class="mi">7</span><span class="p">];</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="nv">$contains-an-array</span><span class="o">.</span><span class="nb">list</span><span class="p">;</span>        <span class="c1"># or @($arrayref) </span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="nv">$contains-a-hash</span><span class="o">.</span><span class="nb">hash</span><span class="p">;</span>          <span class="c1"># or %($hashref) </span>
</span></span></code></pre></div><p>“Zen” 切片做同样的事情：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="nv">$contains-an-array</span><span class="o">[]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="nv">$contains-a-hash</span><span class="p">{};</span>
</span></span></code></pre></div><p>有关详细信息，请参阅<a href="https://docs.raku.org/language/containers">文档的“容器”部分</a>。</p>
<h2 id="运算符">运算符</h2>
<p>有关所有运算符的完整详细信息，请参阅<a href="https://docs.raku.org/language/operators">运算符文档</a>。</p>
<p>没发生变化的：</p>
<ul>
<li><code>+</code> 数字加法</li>
<li><code>-</code> 数字减法</li>
<li><code>*</code> 数字乘法</li>
<li><code>/</code> 数字除法</li>
<li><code>%</code> 数字求模</li>
<li><code>**</code> 数字指数</li>
<li><code>++</code> 数字递增</li>
<li><code>--</code> 数字递减</li>
<li><code>! &amp;&amp; || ^</code> 布尔，高优先级</li>
<li><code>not and or xor</code> 布尔，低优先级</li>
<li><code>== != &lt; &gt; &lt;= &gt;=</code> 数字比较</li>
<li><code>eq ne lt gt le ge</code> 字符串比较</li>
</ul>
<h2 id="-逗号-列表分割符">, (逗号) 列表分割符</h2>
<p>没有改变，但请注意，为了将数组变量展平为列表（为了追加或添加更多项目的前缀），应该使用|操作员（另见<a href="https://docs.raku.org/type/Slip">Slip</a>）。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@numbers</span> <span class="o">=</span> <span class="mi">100</span><span class="o">,</span> <span class="mi">200</span><span class="o">,</span> <span class="mi">300</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@more_numbers</span> <span class="o">=</span> <span class="mi">500</span><span class="o">,</span> <span class="mi">600</span><span class="o">,</span> <span class="mi">700</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@all_numbers</span> <span class="o">=</span> <span class="o">|</span><span class="nv">@numbers</span><span class="o">,</span> <span class="mi">400</span><span class="o">,</span> <span class="o">|</span><span class="nv">@more_numbers</span><span class="p">;</span>
</span></span></code></pre></div><p>这样就可以连接数组。</p>
<p>请注意，右侧不需要任何括号：List Separator 负责创建列表，而不是括号！</p>
<h3 id="-cmp-三路比较">&lt;=&gt; cmp 三路比较</h3>
<p>在 Perl 5 中，这些运算符返回 -1, 0 或 1。在 Raku 中，它们返回 <code>Order::Less</code>，<code>Order::Same</code> 或 <code>Order::More</code>。</p>
<p><code>cmp</code> 现在命名为 <code>leg</code>; 它强制字符串上下文进行比较。</p>
<p><code>&lt;=&gt;</code> 仍然强制数字上下文。</p>
<p>Raku 中的 <code>cmp</code> 执行 <code>&lt;=&gt;</code> 或 <code>leg</code>，具体取决于其参数的现有类型。</p>
<h3 id="-智能匹配运算符">~~ 智能匹配运算符</h3>
<p>虽然运算符没有改变，但确切匹配的规则取决于两个参数的类型，并且这些规则在 Perl 5 和 Raku 中大不相同。请参阅 <a href="https://docs.raku.org/routine/~~">~~</a>和 <a href="https://docs.raku.org/language/operators#index-entry-smartmatch_operator">smartmatch 运算符</a>。</p>
<h3 id="---字符串位运算符">&amp; | ^ 字符串位运算符</h3>
<h3 id="---数字位运算符">&amp; | ^ 数字位运算符</h3>
<h3 id="---布尔运算符">&amp; | ^ 布尔运算符</h3>
<p>在 Perl 5 中，<code>&amp; | ^</code> 根据参数的内容调用。例如，<code>31 | 33</code> 返回与 <code>“31”|“33”</code> 不同的结果。</p>
<p>在 Raku 中，这些单字符操作已被删除，并被两个字符的操作系统取代，这些操作将他们的参数强制转换为所需的上下文。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Infix ops (two arguments; one on each side of the op) </span>
</span></span><span class="line"><span class="cl"><span class="o">+&amp;</span>  <span class="o">+|</span>  <span class="o">+^</span>  <span class="n">And</span> <span class="nf">Or</span> <span class="n">Xor:</span> <span class="kt">Numeric</span>
</span></span><span class="line"><span class="cl"><span class="o">~&amp;</span>  <span class="o">~|</span>  <span class="o">~^</span>  <span class="n">And</span> <span class="nf">Or</span> <span class="n">Xor:</span> <span class="n">String</span>
</span></span><span class="line"><span class="cl"><span class="o">?&amp;</span>  <span class="o">?|</span>  <span class="o">?^</span>  <span class="n">And</span> <span class="nf">Or</span> <span class="n">Xor:</span> <span class="n">Boolean</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Prefix ops (one argument, after the op) </span>
</span></span><span class="line"><span class="cl"><span class="o">+^</span>  <span class="n">Not:</span> <span class="kt">Numeric</span>
</span></span><span class="line"><span class="cl"><span class="o">~^</span>  <span class="n">Not:</span> <span class="n">String</span>
</span></span><span class="line"><span class="cl"><span class="o">?^</span>  <span class="n">Not:</span> <span class="n">Boolean</span> <span class="p">(</span><span class="n">same</span> <span class="n">as</span> <span class="n">the</span> <span class="o">!</span> <span class="n">op</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="--数字左移右移运算符">&laquo; &raquo; 数字左移|右移运算符</h3>
<p>由 <code>+&lt;</code> 和 <code>+&gt;</code> 代替。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="mi">42</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">42</span> <span class="o">+&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="c1"># Raku </span>
</span></span></code></pre></div><h3 id="-胖逗号">=&gt; 胖逗号</h3>
<p>在 Perl 5 中，<code>=&gt;</code> 的行为就像一个逗号，但也引用了它的左侧。</p>
<p>在 Raku 中，<code>=&gt;</code> 是 <a href="https://docs.raku.org/type/Pair">Pair</a> 运算符，原理上完全不同，但在许多情况下都是相同的。</p>
<p>如果您在哈希初始化中使用 <code>=&gt;</code>，或者将参数传递给期望 hashref 的 sub，则用法可能相同。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">get_the_loot</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span> <span class="c1"># Raku stub </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Works in Perl 5 and Raku </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%hash</span> <span class="o">=</span> <span class="p">(</span> <span class="s">AAA</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">BBB</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">get_the_loot</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">diamonds</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">{</span> <span class="s">quiet_level</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">very</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">quantity</span> <span class="o">=&gt;</span> <span class="mi">9</span> <span class="p">});</span> <span class="c1"># Note the curly braces </span>
</span></span></code></pre></div><p>如果你使用 <code>=&gt;</code> 作为一个方便的快捷方式，不必引用列表的一部分，或者将参数传递给一个需要 <code>KEY</code>，<code>VALUE</code>，<code>KEY</code>，<code>VALUE</code> 的平面列表的子，那么继续使用 <code>=&gt;</code> 可能会破坏你的代码。 最简单的解决方法是将该胖箭头更改为常规逗号，并手动将引号添加到其左侧。 或者，您可以更改 sub 的API以<a href="https://docs.raku.org/type/Signature#Slurpy_%28A.K.A._variadic%29_parameters">slurp哈希</a>。 一个更好的长期解决方案是将sub的API改为期望Pairs; 但是，这需要您一次更改所有 sub 调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">get_the_loot</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$loot</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">%options</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ... </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Note: no curly braces in this sub call </span>
</span></span><span class="line"><span class="cl"><span class="n">get_the_loot</span><span class="p">(</span> <span class="s">&#39;diamonds&#39;</span><span class="p">,</span> <span class="n">quiet_level</span> <span class="o">=&gt;</span> <span class="s">&#39;very&#39;</span><span class="p">,</span> <span class="n">quantity</span> <span class="o">=&gt;</span> <span class="mi">9</span> <span class="p">);</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku, original API </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">get_the_loot</span><span class="p">(</span> <span class="nv">$loot</span><span class="o">,</span> <span class="o">*</span><span class="nv">%options</span> <span class="p">)</span> <span class="p">{</span> <span class="c1"># The * means to slurp everything </span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">get_the_loot</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">diamonds</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">quiet_level</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">very</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">quantity</span> <span class="o">=&gt;</span> <span class="mi">9</span> <span class="p">);</span> <span class="c1"># Note: no curly braces in this API </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Raku, API changed to specify valid options </span>
</span></span><span class="line"><span class="cl"><span class="c1"># The colon before the sigils means to expect a named variable, </span>
</span></span><span class="line"><span class="cl"><span class="c1"># with the key having the same name as the variable. </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">get_the_loot</span><span class="p">(</span> <span class="nv">$loot</span><span class="o">,</span> <span class="o">:</span><span class="nv">$quiet_level</span><span class="o">?,</span> <span class="o">:</span><span class="nv">$quantity</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># This version will check for unexpected arguments! </span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">get_the_loot</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">diamonds</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">quietlevel</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">very</span><span class="p">&#39;</span> <span class="p">);</span> <span class="c1"># Throws error for misspelled parameter name </span>
</span></span></code></pre></div><h3 id="---三元运算符">?  : 三元运算符</h3>
<p>条件运算符 <code>? :</code> 已经被替换成 <code>?? !! </code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$result</span> <span class="o">=</span> <span class="nv">$score</span> <span class="o">&gt;</span> <span class="mi">60</span> <span class="p">?</span>  <span class="s">&#39;Pass&#39;</span> <span class="p">:</span>  <span class="s">&#39;Fail&#39;</span><span class="p">;</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$result</span> <span class="o">=</span> <span class="nv">$score</span> <span class="o">&gt;</span> <span class="mi">60</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">Pass</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">Fail</span><span class="p">&#39;;</span> <span class="c1"># Raku </span>
</span></span></code></pre></div><h3 id="点号-字符串连接">.(点号) 字符串连接</h3>
<p>替换为波浪号。</p>
<p>助记：想到用针和线将两个字符串“拼接”在一起。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="nv">$food</span> <span class="o">=</span> <span class="s">&#39;grape&#39;</span> <span class="o">.</span> <span class="s">&#39;fruit&#39;</span><span class="p">;</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$food</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">grape</span><span class="p">&#39;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">fruit</span><span class="p">&#39;;</span> <span class="c1"># Raku </span>
</span></span></code></pre></div><h3 id="x-列表复制或字符串复制运算符">x 列表复制或字符串复制运算符</h3>
<p>在 Perl 5 中，x 是复制运算符，它在标量或列表上下文中的行为有所不同：</p>
<ul>
<li>在标量上下文中，<code>x</code> 重复一个字符串;</li>
<li>在列表上下文中 <code>x</code> 重复一个列表，但前提是左参数是括号！</li>
</ul>
<p>Raku 使用两个不同的复制运算符来实现上述目的：</p>
<ul>
<li><code>x</code> 表示字符串重复（在任何上下文中）;</li>
<li><code>xx</code> 表示列表重复（在任何上下文中）。</li>
</ul>
<p>助记符：<code>x</code> 很短，<code>xx</code> 很长，所以 <code>xx</code> 是用于列表的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl">    <span class="k">print</span> <span class="s">&#39;-&#39;</span> <span class="n">x</span> <span class="mi">80</span><span class="p">;</span>             <span class="c1"># Print row of dashes </span>
</span></span><span class="line"><span class="cl">    <span class="nv">@ones</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">x</span> <span class="mi">80</span><span class="p">;</span>           <span class="c1"># A list of 80 1&#39;s </span>
</span></span><span class="line"><span class="cl">    <span class="nv">@ones</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="n">x</span> <span class="nv">@ones</span><span class="p">;</span>        <span class="c1"># Set all elements to 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">80</span><span class="p">;</span>             <span class="c1"># Unchanged </span>
</span></span><span class="line"><span class="cl">    <span class="nv">@ones</span> <span class="o">=</span> <span class="mi">1</span> <span class="ow">xx</span> <span class="mi">80</span><span class="p">;</span>            <span class="c1"># Parentheses no longer needed </span>
</span></span><span class="line"><span class="cl">    <span class="nv">@ones</span> <span class="o">=</span> <span class="mi">5</span> <span class="ow">xx</span> <span class="nv">@ones</span><span class="p">;</span>         <span class="c1"># Parentheses no longer needed </span>
</span></span></code></pre></div><h3 id="--两个点或三个点范围操作或-flipflop-运算符">.. &hellip; 两个点或三个点，范围操作或 flipflop 运算符</h3>
<p>在 Perl 5 中，<code>..</code> 是两个完全不同的运算符之一，具体取决于上下文。</p>
<p>在列表上下文中，<code>..</code> 是熟悉的范围运算符。 Perl 5 代码的范围不应该要求翻译。</p>
<p>在标量上下文中，<code>..</code> 和 <code>...</code> 是鲜为人知的 Flipflop 运算符。 它们已被 <code>ff</code> 和 <code>fff</code> 取代。</p>
<h3 id="字符串插值">字符串插值</h3>
<p>在 Perl 5 中，<code>&quot;${foo}s&quot;</code> 从其旁边的常规文本中删除变量名。 在 Raku 中，只需将花括号扩展为包括sigil：<code>&quot;{$foo}s&quot;</code>。 事实上，这是插入表达式的一个非常简单的例子。</p>
<h3 id="复合语句">复合语句</h3>
<p>这些语句包括条件和循环。</p>
<h4 id="条件语句">条件语句</h4>
<h5 id="if-elsif-else-unless">if elsif else unless</h5>
<p>大部分没有变化; 条件周围的括号现在是可选的，但如果使用，则不能立即跟随关键字，否则它将被视为函数调用。 将条件表达式绑定到变量也有一点不同：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="n">dostuff</span><span class="p">())</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>  <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="nf">dostuff</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$x</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>      <span class="c1"># Raku </span>
</span></span></code></pre></div><p>（您仍然可以在 Raku 中使用我的表单，但它将扩展到外部块，而不是内部。）</p>
<p>除非条件仅允许 Raku 中的单个块;它不允许使用 elsif 或 else 子句。</p>
<h5 id="given-when">given-when</h5>
<p>给定时构造类似于 <code>if-elsif-else</code> 语句链或类似于例如 <code>switch-case</code> 构造。 C. 它具有一般结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="n">EXPR</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="n">EXPR</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="n">EXPR</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在其最简单的形式中，构造如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="nv">$value</span> <span class="p">{</span>                   <span class="c1"># assigns $_ </span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="p">&#34;</span><span class="s2">a match</span><span class="p">&#34;</span> <span class="p">{</span>             <span class="c1"># if $_ ~~ &#34;a match&#34; </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># do-something(); </span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="p">&#34;</span><span class="s2">another match</span><span class="p">&#34;</span> <span class="p">{</span>       <span class="c1"># elsif $_ ~~ &#34;another match&#34; </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># do-something-else(); </span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span> <span class="p">{</span>                    <span class="c1"># else </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># do-default-thing(); </span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这是很简单的，因为标量值在 <code>when</code> 语句中与 <code>$_</code> 匹配，这是由给定的设置。更一般地说，匹配实际上是 <code>$_</code> 上的智能匹配，这样可以使用更复杂的实体（如regexp）进行查找而不是标量值。</p>
<p>另请参阅上面的smartmatch op上的警告。</p>
<h2 id="循环">循环</h2>
<h3 id="while-until">while until</h3>
<p>大部分没有变化;条件周围的括号现在是可选的，但如果使用，则不能立即跟随关键字，否则它将被视为函数调用。将条件表达式绑定到变量也有一点不同：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="n">dostuff</span><span class="p">())</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>  <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">while</span> <span class="nf">dostuff</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$x</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>      <span class="c1"># Raku </span>
</span></span></code></pre></div><p>（您仍然可以在 Raku 中使用我的表单，但它将扩展到外部块，而不是内部。）</p>
<p>请注意，从文件句柄逐行读取已更改。</p>
<p>在 Perl 5 中，它是使用菱形运算符在while循环中完成的。使用for而不是while是一个常见的错误，因为for会导致整个文件立即被吸入，从而淹没了程序的内存使用情况。</p>
<p>在 Raku 中，<code>for</code> 语句是<strong>惰性</strong>的，所以我们使用 <code>.lines</code> 方法在 <code>for</code> 循环中逐行读取。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="sr">&lt;IN_FH&gt;</span><span class="p">)</span>  <span class="p">{</span> <span class="p">}</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">$IN_FH</span><span class="o">.</span><span class="nb">lines</span> <span class="p">{</span> <span class="p">}</span> <span class="c1"># Raku </span>
</span></span></code></pre></div><p>另请注意，在 Raku 中，默认情况下会 chomp 行。</p>
<h3 id="do-whileuntil">do while/until</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl"><span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">while</span> <span class="nv">$x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">until</span> <span class="nv">$x</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">;</span>
</span></span></code></pre></div><p>该构造仍然存在，但是 <code>do</code> 被重命名为 <code>repeat</code>，以更好地表示构造的作用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl"><span class="k">repeat</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">while</span> <span class="nv">$x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">repeat</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">until</span> <span class="nv">$x</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">;</span>
</span></span></code></pre></div><h3 id="for-foreach">for foreach</h3>
<p>首先要注意关于 <code>for</code> 和 <code>foreach</code> 关键字的这种常见误解：许多程序员认为他们区分C风格的三表达形式和列表迭代器形式;他们不！事实上，关键词是可以互换的; Perl 5 编译器在括号中查找分号以确定要解析的循环类型。</p>
<p>C 风格的三因子形式现在使用 <code>loop</code> 关键字，否则保持不变。括号仍然是必需的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">for</span>  <span class="p">(</span> <span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nv">$i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">loop</span> <span class="p">(</span> <span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nv">$i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># Raku</span>
</span></span></code></pre></div><p>循环迭代器表单以Raku命名，foreach不再是关键字。 for循环具有以下规则：</p>
<ul>
<li>括号是可选的;</li>
<li>迭代变量（如果有的话）已经从列表前面出现，再出现在列表和添加的箭头操作符之后;</li>
<li>迭代变量现在总是词法的：<code>my</code> 既不需要也不允许;</li>
<li>迭代变量是当前列表元素的只读别名（在 Perl 5 中它是一个读写别名！）。如果需要读写别名，请将迭代变量前面的 <code>-&gt;</code> 更改为 <code>&lt;-&gt;</code>。从 Perl 5 进行翻译时，检查循环变量的使用以确定是否需要读写。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">for</span> <span class="k">my</span> <span class="nv">$car</span> <span class="p">(</span><span class="nv">@cars</span><span class="p">)</span>  <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1"># Perl 5; read-write </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@cars</span>  <span class="k">-&gt;</span> <span class="nv">$car</span>   <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1"># Raku; read-only </span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@cars</span> <span class="o">&lt;-&gt;</span> <span class="nv">$car</span>   <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1"># Raku; read-write </span>
</span></span></code></pre></div><p>如果正在使用默认主题 <code>$_</code>，那么它也是读写的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="nv">@cars</span><span class="p">)</span>      <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1"># Perl 5; $_ is read-write </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@cars</span>        <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1"># Raku; $_ is read-write </span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@cars</span> <span class="o">&lt;-&gt;</span> <span class="nv">$_</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="c1"># Raku; $_ is also read-write </span>
</span></span></code></pre></div><p>在每次迭代中可以使用列表中多个元素，只需在箭头操作符后指定多个变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@array</span> <span class="k">-&gt;</span> <span class="nv">$first</span><span class="o">,</span> <span class="nv">$second</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">First is </span><span class="nv">$first</span><span class="s2">, second is </span><span class="nv">$second</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="each">each</h3>
<p>这是 Perl 5 的 <code>while…each(%hash) or while…each(@array)</code> 的等价物，（即迭代数据结构的键/索引和值）而 Raku 中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="k">my</span> <span class="p">(</span><span class="nv">$i</span><span class="p">,</span> <span class="nv">$v</span><span class="p">)</span> <span class="o">=</span> <span class="nb">each</span><span class="p">(</span><span class="nv">@array</span><span class="p">))</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@array</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$i</span><span class="o">,</span> <span class="nv">$v</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># Raku </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="k">my</span> <span class="p">(</span><span class="nv">$k</span><span class="p">,</span> <span class="nv">$v</span><span class="p">)</span> <span class="o">=</span> <span class="nb">each</span><span class="p">(</span><span class="nv">%hash</span><span class="p">))</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">%hash</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$k</span><span class="o">,</span> <span class="nv">$v</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># Raku </span>
</span></span></code></pre></div><h3 id="控制流语句">控制流语句</h3>
<p>没发生变化的：</p>
<ul>
<li>next</li>
<li>last</li>
<li>redo</li>
</ul>
<h4 id="continue">continue</h4>
<p>不再有 <code>continue</code> 块了。而是在循环体内使用 <code>NEXT</code> 块（phaser）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">next</span> <span class="k">if</span> <span class="nv">$_</span> <span class="nv">%</span> <span class="nv">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$str</span> <span class="o">.=</span> <span class="nv">$_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">continue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$str</span> <span class="o">.=</span> <span class="s">&#39;:&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="p">&#39;&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">next</span> <span class="k">if</span> <span class="nv">$_</span> <span class="nv">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$str</span> <span class="o">~=</span> <span class="nv">$_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">NEXT</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$str</span> <span class="o">~=</span> <span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>请注意，phasers 并不需要块。当您不想要另一个作用域时，这非常方便：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="p">&#39;&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">next</span> <span class="k">if</span> <span class="nv">$_</span> <span class="nv">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$str</span> <span class="o">~=</span> <span class="nv">$_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">NEXT</span> <span class="nv">$str</span> <span class="o">~=</span> <span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><h2 id="函数">函数</h2>
<h3 id="带有裸块的内置函数">带有裸块的内置函数</h3>
<p>之前接受裸块的内置函数，其后没有逗号，其余参数现在需要在块和参数之间使用逗号，例如 <code>map</code>，<code>grep</code> 等。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@results</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span> <span class="nv">$_</span> <span class="ow">eq</span> <span class="s">&#34;bars&#34;</span> <span class="p">}</span> <span class="nv">@foo</span><span class="p">;</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@results</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span> <span class="nv">$_</span> <span class="ow">eq</span> <span class="p">&#34;</span><span class="s2">bars</span><span class="p">&#34;</span> <span class="p">}</span><span class="o">,</span> <span class="nv">@foo</span><span class="p">;</span> <span class="c1"># Raku </span>
</span></span></code></pre></div><h3 id="delete">delete</h3>
<p>变成了 <a href="https://docs.raku.org/language/5to6-nutshell#%7B%7D_Hash_indexing%2Fslicing">{} 哈希下标</a>和<a href="https://docs.raku.org/language/5to6-nutshell#%5B%5D_Array_indexing%2Fslicing">[]数组下标</a>运算符的副词。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$deleted_value</span> <span class="o">=</span> <span class="nb">delete</span> <span class="nv">$hash</span><span class="p">{</span><span class="nv">$key</span><span class="p">};</span>  <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$deleted_value</span> <span class="o">=</span> <span class="nv">%hash</span><span class="p">{</span><span class="nv">$key</span><span class="p">}:</span><span class="s">delete</span><span class="p">;</span>  <span class="c1"># Raku - use :delete adverb </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$deleted_value</span> <span class="o">=</span> <span class="nb">delete</span> <span class="nv">$array</span><span class="p">[</span><span class="nv">$i</span><span class="p">];</span>  <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$deleted_value</span> <span class="o">=</span> <span class="nv">@array</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span><span class="p">:</span><span class="s">delete</span><span class="p">;</span>  <span class="c1"># Raku - use :delete adverb </span>
</span></span></code></pre></div><h3 id="exists">exists</h3>
<p>变成了 <a href="https://docs.raku.org/language/5to6-nutshell#%7B%7D_Hash_indexing%2Fslicing">{} 哈希下标</a>和<a href="https://docs.raku.org/language/5to6-nutshell#%5B%5D_Array_indexing%2Fslicing">[]数组下标</a>运算符的副词。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;element exists&#34;</span> <span class="k">if</span> <span class="nb">exists</span> <span class="nv">$hash</span><span class="p">{</span><span class="nv">$key</span><span class="p">};</span>  <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">element exists</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">%hash</span><span class="p">{</span><span class="nv">$key</span><span class="p">}:</span><span class="s">exists</span><span class="p">;</span>  <span class="c1"># Raku - use :exists adverb </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;element exists&#34;</span> <span class="k">if</span> <span class="nb">exists</span> <span class="nv">$array</span><span class="p">[</span><span class="nv">$i</span><span class="p">];</span>  <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">element exists</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">@array</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span><span class="p">:</span><span class="s">exists</span><span class="p">;</span>  <span class="c1"># Raku - use :exists adverb</span>
</span></span></code></pre></div><h2 id="正则表达式-regexregexp">正则表达式 (regex/regexp)</h2>
<h3 id="-和--变成了--和-">=~ 和 !~ 变成了 ~~ 和 !~~</h3>
<p>在 Perl 5 中，使用 <code>=~</code> 正则表达式绑定运算符对变量进行匹配和替换。</p>
<p>在 Raku 中，使用了 <code>~~</code> 智能匹配运算符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">next</span> <span class="k">if</span> <span class="nv">$line</span>  <span class="o">=~</span><span class="sr"> /static/</span>  <span class="p">;</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">next</span> <span class="k">if</span> <span class="nv">$line</span>  <span class="o">~~</span> <span class="p">/</span><span class="sr">static</span><span class="p">/</span>  <span class="p">;</span> <span class="c1"># Raku </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">next</span> <span class="k">if</span> <span class="nv">$line</span>  <span class="o">!~</span> <span class="sr">/dynamic/</span> <span class="p">;</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">next</span> <span class="k">if</span> <span class="nv">$line</span> <span class="o">!~~</span> <span class="p">/</span><span class="sr">dynamic</span><span class="p">/</span> <span class="p">;</span> <span class="c1"># Raku </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="nv">$line</span> <span class="o">=~</span> <span class="sr">s/abc/123/</span><span class="p">;</span>          <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$line</span> <span class="o">~~</span> <span class="k">s</span><span class="p">/</span><span class="sr">abc</span><span class="p">/</span><span class="s2">123</span><span class="p">/;</span>          <span class="c1"># Raku</span>
</span></span></code></pre></div><p>或者，可以使用新的 <code>.match</code> 和 <code>.subst</code> 方法。请注意，<a href="https://docs.raku.org/routine/subst">.subst是非可变的</a>。</p>
<h3 id="捕获从-0-开始而非从-1-开始">捕获从 0 开始而非从 1 开始</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="sr">/(.+)/</span> <span class="ow">and</span> <span class="k">print</span> <span class="nv">$1</span><span class="p">;</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/(</span><span class="ni">.</span><span class="o">+</span><span class="p">)/</span> <span class="ow">and</span> <span class="nb">print</span> <span class="nv">$0</span><span class="p">;</span> <span class="c1"># Raku </span>
</span></span></code></pre></div><h3 id="移动修饰符">移动修饰符</h3>
<p>将任何修饰符从正则表达式的末尾移动到开头。这可能需要您在 <code>/abc/</code> 这样的普通匹配上添加可选的 <code>m</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">next</span> <span class="k">if</span> <span class="nv">$line</span> <span class="o">=~</span><span class="sr">    /static/i</span> <span class="p">;</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">next</span> <span class="k">if</span> <span class="nv">$line</span> <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">i</span><span class="p">/</span><span class="sr">static</span><span class="p">/</span>  <span class="p">;</span> <span class="c1"># Raku </span>
</span></span></code></pre></div><h3 id="添加-p5-或-perl5-副词">添加 :P5 或 :Perl5 副词</h3>
<p>如果实际的正则表达式很复杂，您可能希望通过添加 <code>P5</code> 修饰符来原样使用它。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">next</span> <span class="k">if</span> <span class="nv">$line</span> <span class="o">=~</span>    <span class="sr">m/[aeiou]/</span>   <span class="p">;</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">next</span> <span class="k">if</span> <span class="nv">$line</span> <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">P5</span><span class="p">/[</span><span class="sr">aeiou</span><span class="p">]/</span>   <span class="p">;</span> <span class="c1"># Raku, using P5 modifier </span>
</span></span><span class="line"><span class="cl"><span class="nb">next</span> <span class="k">if</span> <span class="nv">$line</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr">  </span><span class="p">&lt;[</span><span class="sr">aeiou</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">/</span> <span class="p">;</span> <span class="c1"># Raku, native new syntax </span>
</span></span></code></pre></div><p>请注意，Perl 5 正则表达式语法可以追溯到很多年前，可能缺少自 Raku 项目开始以来添加的功能。</p>
<h3 id="特殊匹配器通常属于--语法">特殊匹配器通常属于 &lt;&gt; 语法</h3>
<p>Perl 5 正则表达式支持许多特殊匹配语法的情况。它们不会全部列在这里，但通常不是被 <code>()</code> 包围，断言将被 <code>&lt;&gt;</code> 包围着。</p>
<p>对于字符类，这意味着：</p>
<ul>
<li><code>[abc]</code> 变成了 <code>&lt;[abc]&gt;</code></li>
<li><code>[^abc]</code> 变成了 <code>&lt;-[abc]&gt;</code></li>
<li><code>[a-zA-Z]</code> 变成了 <code>&lt;[a..zA..Z]&gt;</code></li>
<li><code>[[:upper:]]</code>变成了 <code>&lt;:Upper&gt;</code></li>
<li><code>[abc[:upper:]]</code> 变成了 <code>&lt;[abc]+:Upper&gt;</code></li>
</ul>
<p>对于环视断言：</p>
<ul>
<li><code>(?=[abc])</code> 变成了 <code>&lt;?[abc]&gt;</code></li>
<li><code>(?=ar?bitrary* pattern)</code> 变成了 <code>&lt;before ar?bitrary* pattern&gt;</code></li>
<li><code>(?!=[abc])</code> 变成了 <code>&lt;![abc]&gt;</code></li>
<li><code>(?!=ar?bitrary* pattern)</code> 变成了 <code>&lt;!before ar?bitrary* pattern&gt;</code></li>
<li><code>(?&lt;=ar?bitrary* pattern)</code> 变成了 <code>&lt;after ar?bitrary* pattern&gt;</code></li>
<li><code>(?&lt;!ar?bitrary* pattern)</code> 变成了 <code>&lt;!after ar?bitrary* pattern&gt;</code></li>
</ul>
<p>有关更多信息，请参阅<a href="https://docs.raku.org/language/regexes#Lookahead_assertions_%3C%3Fbefore_pattern%3E">向前查看断言</a>。</p>
<p>（和 &lt;&gt; 语法无关, “环视” <code>/foo\Kbar/</code> 变成了 <code>/foo &lt;( bar )&gt; /</code>）</p>
<ul>
<li><code>(?(?{condition))yes-pattern|no-pattern)</code> 变成了 <code>[ &lt;?{condition}&gt; yes-pattern | no-pattern ]</code></li>
</ul>
<h3 id="最长-token-匹配ltm-取代了备选分支">最长 token 匹配(LTM) 取代了备选分支</h3>
<p>在 Raku 正则表达式中，<code>|</code> 遵循 LTM，它根据一组规则决定哪个备选分支赢得了一个模糊匹配，而不是先写出哪个。</p>
<p>解决这个问题最简单的方法就是在你的 Perl 5 正则表达式中把任何 <code>|</code> 更改为 <code>||</code>。</p>
<p>但是，如果正则表达式用 <code>||</code> 写的是继承或组成使用 <code>|</code> 的语法无论是设计还是拼写错误，结果可能无法按预期工作。因此，当匹配过程变得复杂时，您最终需要对两者都有所了解，尤其是 LTM 策略的工作原理。此外，`|  可能是语法重用的更好选择。</p>
<h3 id="命名捕获">命名捕获</h3>
<p>这些工作方式略有不同;他们也只使用最新版本的 Perl 5。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">v5</span><span class="mf">.22</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;þor is mighty&#34;</span> <span class="o">=~</span><span class="sr"> /is (?&lt;iswhat&gt;\w+)/</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="vg">$+</span><span class="p">{</span><span class="n">iswhat</span><span class="p">};</span>
</span></span></code></pre></div><p>非捕获组中的内容用于实现捕获后面的内容，直到组的末尾（the）。捕获转到带有捕获名称的键下的 <code>%+</code> 哈希。在 Raku 中，<a href="https://docs.raku.org/language/regexes#Capturing_groups">命名捕获以这种方式工作</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&#34;</span><span class="s2">þor is mighty</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">is </span><span class="se">\s</span><span class="o">+</span><span class="sr"> </span><span class="nv">$&lt;iswhat&gt;</span><span class="o">=</span><span class="p">(</span><span class="se">\w</span><span class="o">+</span><span class="p">)/;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$&lt;iswhat&gt;</span><span class="p">;</span>
</span></span></code></pre></div><p>在正则表达式中进行实际赋值;这与用于外部变量的语法相同。</p>
<h3 id="注释">注释</h3>
<p>与 Perl 5 一样，注释在正则表达式中照常工作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">/</span><span class="sr"> word #`</span><span class="p">(</span><span class="sr">match lexical </span><span class="p">&#34;</span><span class="s2">word</span><span class="p">&#34;)</span><span class="sr"> </span><span class="p">/</span> 
</span></span></code></pre></div><h2 id="begin-unitcheck-check-init-和-end">BEGIN, UNITCHECK, CHECK, INIT 和 END</h2>
<p>除了 <code>UNITCHECK</code> 之外，所有这些特殊块也存在于 Raku 中。在 Raku 中，这些被称为 <a href="https://docs.raku.org/language/phasers">Phasers</a>。但是有一些差异！</p>
<h3 id="unitcheck-变为-check">UNITCHECK 变为 CHECK</h3>
<p>Raku 中目前没有直接等效的 <code>CHECK</code> 块。Raku 中的 <code>CHECK</code> phaser 与 Perl 5 中的 <code>UNITCHECK</code> 块具有相同的语义：只要它出现的编译单元完成解析，它就会运行。这被认为是比 Perl 5 中 <code>CHECK</code> 块的当前语义更加理智的语义。但出于兼容性原因，不可能在 Perl 5 中更改 <code>CHECK</code> 块的语义，因此在 5.10 中引入了 <code>UNITCHECK</code> 块。因此决定 Raku <code>CHECK</code> phaser 将遵循更健全的 Perl 5 <code>UNITCHECK</code> 语义。</p>
<h3 id="不再需要块">不再需要块</h3>
<p>在 Perl 5 中，这些特殊块必须具有花括号，这意味着单独的范围。在 Raku 中，这不是必需的，允许这些特殊块与周围的词法范围共享它们的范围。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$foo</span><span class="p">;</span>             <span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl"><span class="k">BEGIN</span> <span class="p">{</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="mi">42</span> <span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">BEGIN</span> <span class="k">my</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>  <span class="c1"># Raku </span>
</span></span></code></pre></div><h3 id="关于预编译改变了语义">关于预编译改变了语义</h3>
<p>如果将其放在正在预编译的模块中，则这些步骤将仅在预编译期间执行，而不是在加载预编译模块时执行。 因此，当从 Perl 5 移植模块代码时，您可能需要更改 <code>BEGIN</code> 和 <code>CHECK</code>。</p>
<h2 id="编译指令">编译指令</h2>
<h3 id="strict">strict</h3>
<p>严格模式现在默认启用。</p>
<h3 id="warnings">warnings</h3>
<p>警告现在默认开启。</p>
<p>目前 <code>no warnings</code> <a href="https://docs.raku.org/language/glossary#NYI">还未实现</a> ，但是把东西放在一个安静的 <code>{}</code> 中会让其沉默。</p>
<h3 id="autodie">autodie</h3>
<p>由 <code>autodie</code> 更改以在异常时抛出异常的函数现在通常默认返回 <code>Failures</code>。您可以毫无问题地测试失败的定义/真实性。如果以任何其他方式使用 <code>Failure</code>，则将抛出由 <code>Failure</code> 封装的 <code>Exception</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl"><span class="nb">open</span> <span class="k">my</span> <span class="nv">$i_fh</span><span class="p">,</span> <span class="s">&#39;&lt;&#39;</span><span class="p">,</span> <span class="nv">$input_path</span><span class="p">;</span>  <span class="c1"># Fails silently on error </span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">autodie</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">open</span> <span class="k">my</span> <span class="nv">$o_fh</span><span class="p">,</span> <span class="s">&#39;&gt;&#39;</span><span class="p">,</span> <span class="nv">$output_path</span><span class="p">;</span> <span class="c1"># Throws exception on error </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$i_fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="nv">$input_path</span><span class="o">,</span>  <span class="p">:</span><span class="s">r</span><span class="p">;</span> <span class="c1"># Returns Failure on error </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$o_fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="nv">$output_path</span><span class="o">,</span> <span class="p">:</span><span class="s">w</span><span class="p">;</span> <span class="c1"># Returns Failure on error </span>
</span></span></code></pre></div><p>因为您可以毫无问题地检查真实性，所以您可以在 <code>if</code> 语句中使用 <code>open</code> 的结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">open</span><span class="p">(</span><span class="nv">$input_path</span><span class="o">,</span><span class="p">:</span><span class="s">r</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$handle</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">$handle</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># gracefully handle the fact that the open() failed </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="base-parent">base, parent</h3>
<p>在类声明中，<code>is</code> 关键字在 Raku 中替换了 <code>use base</code> 和 <code>use parent</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl"><span class="k">package</span> <span class="nn">Cat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">base</span> <span class="sx">qw(Animal)</span><span class="p">;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cat</span> <span class="k">is</span> <span class="nc">Animal</span> <span class="p">{}</span>
</span></span></code></pre></div><p>请注意，必须在编译时知道 <code>Animal</code> 类才能继承它。</p>
<h3 id="bigint-bignum-bigrat">bigint bignum bigrat</h3>
<p>不再相关。</p>
<p><code>Int</code> 现在是任意精度，因为 <code>Rat</code> 的分子（分母限制为 <code>2**64</code>，之后它将自动升级到 <code>Num</code> 以保持性能）。如果你想要一个具有任意精度分母的 <code>Rat</code>，可以使用 <code>FatRat</code>。</p>
<h3 id="constant">constant</h3>
<p>在 Raku 中，<code>constant</code> 是变量的声明符，就像 <code>my</code> 一样，除了变量永久锁定到其初始化表达式的结果（在编译时计算）。</p>
<p>所以，将 <code>=&gt;</code> 更改为 <code>=</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">constant</span> <span class="n">DEBUG</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">constant</span> <span class="no">DEBUG</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1"># Raku </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">constant</span> <span class="n">pi</span> <span class="o">=&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="nb">atan2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1"># Perl 5 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">tau</span><span class="o">,</span> <span class="no">pi</span><span class="o">,</span> <span class="nb">e</span><span class="o">,</span> <span class="no">i</span><span class="p">;</span> <span class="c1"># built-in constants in Raku </span>
</span></span><span class="line"><span class="cl"><span class="no">τ</span><span class="o">,</span> <span class="no">π</span><span class="o">,</span> <span class="no">𝑒</span>        <span class="c1"># and their unicode equivalents </span>
</span></span></code></pre></div><h3 id="编码">编码</h3>
<p>允许您以非 ascii 或非 utf8 编写脚本。 Raku 目前仅使用 utf8 作为其脚本。</p>
<h3 id="整数">整数</h3>
<p>Perl pragma 使用整数运算而不是浮点运算。在 Raku 中没有这样的等价物。如果你在计算中使用原生整数，那么这将是最接近的事情。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">int</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">int</span> <span class="nv">$bar</span> <span class="o">=</span> <span class="mi">666</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$foo</span> <span class="o">*</span> <span class="nv">$bar</span><span class="p">;</span>    <span class="c1"># uses native integer multiplication </span>
</span></span></code></pre></div><h3 id="lib">lib</h3>
<p>处理在编译时查找模块的位置。底层逻辑与 Perl 5 <strong>非常</strong>不同，但在使用等效语法的情况下，在 Raku 中 <code>use lib</code> 与 Perl 5 中的相同。</p>
<h3 id="mro">mro</h3>
<p>不再相关。</p>
<p>在 Raku 中，方法调用现在始终使用 C3 方法解析顺序。如果需要查找给定类的父类，可以这样调用 <code>mro</code> 元方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Animal</span><span class="o">.^</span><span class="nb">mro</span><span class="p">;</span>    <span class="c1"># .^ indicates calling a meta-method on the object </span>
</span></span></code></pre></div><h3 id="uft8">uft8</h3>
<p>不再相关：在 Raku 中，源代码应该采用 utf8 编码。</p>
<h3 id="vars">vars</h3>
<p>在 Perl 5 中不鼓励使用。 参阅 <a href="https://perldoc.perl.org/vars.html">https://perldoc.perl.org/vars.html</a>。</p>
<p>在转换为 Raku 之前，您应该重构 Perl 5 代码以消除 <code>use vars</code> 的需要。</p>
<h2 id="命令行标记">命令行标记</h2>
<p>请参阅 <a href="https://github.com/rakudo/rakudo/wiki/Running-rakudo-from-the-command-line">Rakudo 使用的命令行标记</a></p>
<p>不变的：</p>
<p>-c -e -h -I -n -p -v -V</p>
<ul>
<li>-a</li>
</ul>
<p>更改您的代码以手动使用 <code>.split</code>。</p>
<ul>
<li>-F</li>
</ul>
<p>更改您的代码以手动使用 <code>.split</code>。</p>
<ul>
<li>-l</li>
</ul>
<p>现在这是默认行为。</p>
<ul>
<li>-M -m</li>
</ul>
<p>只有 <code>-M</code> 仍然存在。而且，由于您不能再使用“no Module”语法，因此不再使用带有 <code>-</code> 的 <code>-M</code> 来 “no” 模块。</p>
<ul>
<li>-E</li>
</ul>
<p>由于已启用所有功能，因此只需使用小写 <code>-e</code>。</p>
<ul>
<li>-d, -dt, -d:foo, -D, etc.</li>
</ul>
<p>替换为 <code>++BUG</code> metasyntactic 选项。</p>
<ul>
<li>-s</li>
</ul>
<p>切换解析现在由 MAIN 子例程的参数列表完成。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl">    <span class="c1">#!/usr/bin/perl -s </span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nv">$xyz</span><span class="p">)</span> <span class="p">{</span> <span class="k">print</span> <span class="s">&#34;$xyz\n&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">./</span><span class="n">example</span><span class="o">.</span><span class="n">pl</span> <span class="o">-</span><span class="n">xyz</span><span class="o">=</span><span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span> <span class="kt">Int</span> <span class="o">:</span><span class="nv">$xyz</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$xyz</span> <span class="k">if</span> <span class="nv">$xyz</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">raku example.p6 --xyz<span class="o">=</span><span class="m">5</span>
</span></span><span class="line"><span class="cl"><span class="m">5</span>
</span></span><span class="line"><span class="cl">raku example.p6 -xyz<span class="o">=</span><span class="m">5</span>
</span></span><span class="line"><span class="cl"><span class="m">5</span>
</span></span></code></pre></div><ul>
<li>it</li>
</ul>
<p>被移除了</p>
<ul>
<li>-P -u -U -W -X</li>
</ul>
<p>被移除了，参阅 <a href="https://design.raku.org/S19.html#Removed_Syntactic_Features">S19#Removed Syntactic Features.</a></p>
<ul>
<li>-w</li>
</ul>
<p>现在是默认行为。</p>
<ul>
<li>-s, -T</li>
</ul>
<p>这已被淘汰。 <a href="https://www.reddit.com/r/raku/comments/718z4o/taint_mode_for_perl_6/">Reddit 讨论了几种复制“污点”模式的方法</a>。</p>
<h2 id="文件相关的运算符">文件相关的运算符</h2>
<h3 id="将文本文件的行读入数组">将文本文件的行读入数组</h3>
<p>在 Perl 5 中，读取文本文件行的常用习惯用法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="nb">open</span> <span class="k">my</span> <span class="nv">$fh</span><span class="p">,</span> <span class="s">&#34;&lt;&#34;</span><span class="p">,</span> <span class="s">&#34;file&#34;</span> <span class="ow">or</span> <span class="nb">die</span> <span class="s">&#34;$!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@lines</span> <span class="o">=</span> <span class="sr">&lt;$fh&gt;</span><span class="p">;</span>                <span class="c1"># lines are NOT chomped </span>
</span></span><span class="line"><span class="cl"><span class="nb">close</span> <span class="nv">$fh</span><span class="p">;</span>
</span></span></code></pre></div><p>在 Raku 中，这已经简化为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@lines</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">file</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>  <span class="c1"># auto-chomped </span>
</span></span></code></pre></div><p>不要试图尝试在文件中进行 slurping 并将结果字符串拆分为换行符，因为这会给出一个带有尾随空元素的数组，这比你预期的要多一些（它也更复杂），例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># initialize the file to read </span>
</span></span><span class="line"><span class="cl"><span class="nb">spurt</span> <span class="p">&#34;</span><span class="s2">test-file</span><span class="p">&#34;</span><span class="o">,</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/END/;</span><span class="s"> 
</span></span></span><span class="line"><span class="cl"><span class="s">first line
</span></span></span><span class="line"><span class="cl"><span class="s">second line
</span></span></span><span class="line"><span class="cl"><span class="s">third line
</span></span></span><span class="line"><span class="cl"><span class="s"></span><span class="p">END</span>
</span></span><span class="line"><span class="cl"><span class="c1"># read the file </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@lines</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">test-file</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">slurp</span><span class="o">.</span><span class="nb">split</span><span class="p">(/</span><span class="se">\n</span><span class="p">/);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@lines</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>    <span class="c1">#-&gt; 4 </span>
</span></span></code></pre></div><p>如果由于某种原因你想要首先 slurp 文件，那么你可以在 <code>slurp</code> 的结果上调用 <code>lines</code> 方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@lines</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">test-file</span><span class="p">&#34;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">slurp</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>  <span class="c1"># also auto-chomps </span>
</span></span></code></pre></div><p>另外，请注意 <code>$!</code> 与 Raku 中的文件操作失败无关。一个 IO 操作无法返回失败而不是抛出异常。 如果要返回失败消息，则它本身就是失败，而不是 <code>$!</code>. 要做同样的事情，我需要检查并报告 Perl 5：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;./bad/path/to/file&#39;</span><span class="p">,</span> <span class="p">:</span><span class="n">w</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">die</span> <span class="nv">$fh</span><span class="p">;</span>
</span></span></code></pre></div><p>注意：<code>$fh</code> 而不是 <code>$!</code>. 现在，您可以将 <code>$_</code> 设置为失败并使用 <code>$_</code> 来消亡：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(&#39;</span><span class="s1">./bad/path/to/file</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">w</span><span class="p">)</span> <span class="ow">orelse</span> <span class="o">.</span><span class="nb">die</span><span class="p">;</span>
</span></span></code></pre></div><p>尝试使用失败的任何操作都将导致程序出错并终止。即使只是调用 <code>.self</code> 方法也足够了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(&#39;</span><span class="s1">./bad/path/to/file</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">w</span><span class="p">)</span><span class="o">.</span><span class="nb">self</span><span class="p">;</span>
</span></span></code></pre></div><h3 id="捕获可执行文件的标准输出">捕获可执行文件的标准输出。</h3>
<p>而在 Perl 5 中，你会这样做</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$arg</span> <span class="o">=</span> <span class="s">&#39;Hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$captured</span> <span class="o">=</span> <span class="sb">`echo \Q$arg\E`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$captured</span> <span class="o">=</span> <span class="sx">qx(echo \Q$arg\E)</span><span class="p">;</span>
</span></span></code></pre></div><p>或者使用 <code>String::ShellQuote</code>（因为 <code>\Q...\E</code> 不完全正确）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$arg</span> <span class="o">=</span> <span class="n">shell_quote</span> <span class="s">&#39;Hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$captured</span> <span class="o">=</span> <span class="sb">`echo $arg`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$captured</span> <span class="o">=</span> <span class="sx">qx(echo $arg)</span><span class="p">;</span>
</span></span></code></pre></div><p>在 Raku 中，您可能希望在不使用 shell 的情况下运行命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$arg</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Hello</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$captured</span> <span class="o">=</span> <span class="nb">run</span><span class="p">(&#39;</span><span class="s1">echo</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$arg</span><span class="o">,</span> <span class="p">:</span><span class="s">out</span><span class="p">)</span><span class="o">.</span><span class="nf">out</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$captured</span> <span class="o">=</span> <span class="nb">run</span><span class="p">(«</span><span class="s2">echo &#34;</span><span class="nv">$arg</span><span class="s2">&#34;</span><span class="p">»</span><span class="o">,</span> <span class="p">:</span><span class="s">out</span><span class="p">)</span><span class="o">.</span><span class="nf">out</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>
</span></span></code></pre></div><p>如果你真的想要，你也可以使用 shell：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$arg</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Hello</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$captured</span> <span class="o">=</span> <span class="nb">shell</span><span class="p">(&#34;</span><span class="s2">echo </span><span class="nv">$arg</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">:</span><span class="s">out</span><span class="p">)</span><span class="o">.</span><span class="nf">out</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$captured</span> <span class="o">=</span> <span class="k">qq</span><span class="sa">x</span><span class="p">{</span><span class="s2">echo </span><span class="nv">$arg</span><span class="p">};</span>
</span></span></code></pre></div><p>但请注意，在这种情况下根本没有保护！ <code>run</code> 不使用 shell，因此不需要转义参数（参数直接传递）。如果你使用 shell 或 <code>qqx</code>，那么一切都会变成一个长字符串，然后传递给 shell。除非您非常仔细地验证您的参数，否则很有可能使用此类代码引入 shell 注入漏洞。</p>
<h2 id="环境变量">环境变量</h2>
<h3 id="perl-模块库路径">Perl 模块库路径</h3>
<p>在 Perl 5 中，为 Perl 模块指定额外搜索路径的环境变量之一是 <code>PERL5LIB</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ <span class="nv">PERL5LIB</span><span class="o">=</span><span class="s2">&#34;/some/module/lib&#34;</span> perl program.pl
</span></span></code></pre></div><p>在 Raku 中，这是类似的，只需要改变一个数字！您可能已经猜到了，您只需要使用 <code>PERL6LIB</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ <span class="nv">PERL6LIB</span><span class="o">=</span><span class="s2">&#34;/some/module/lib&#34;</span> raku program.p6
</span></span></code></pre></div><p>在 Perl 5 中，使用 &lsquo;:&rsquo;（冒号）作为 <code>PERL5LIB</code> 的目录分隔符，但在 Raku 中使用 &lsquo;,&rsquo;（逗号）。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ <span class="nb">export</span> <span class="nv">PERL5LIB</span><span class="o">=</span>/module/dir1:/module/dir2<span class="p">;</span>
</span></span></code></pre></div><p>但是</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="k">export</span> <span class="n">PERL6LIB</span><span class="o">=</span><span class="p">/</span><span class="sr">module</span><span class="p">/</span><span class="n">dir1</span><span class="o">,</span><span class="p">/</span><span class="sr">module</span><span class="p">/</span><span class="n">dir2</span><span class="p">;</span>
</span></span></code></pre></div><p>（Raku 无法识别 <code>PERL5LIB</code> 或旧的 Perl 环境变量 <code>PERLLIB</code>。）</p>
<p>与 Perl 5 一样，如果未指定 <code>PERL6LIB</code>，则需要通过 <code>use lib</code> pragma 指定程序中的库路径：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="kt">lib</span> <span class="p">&#39;</span><span class="s1">/some/module/lib</span><span class="p">&#39;</span>
</span></span></code></pre></div><p>请注意，<code>PERL6LIB</code> 在 Raku 中更具开发人员便利性（与 Perl5 中 <code>PERL5LIB</code> 的等效用法相反），模块消费者不应使用它，因为将来可能会将其删除。这是因为 Raku 的模块加载与操作系统路径不直接兼容。</p>
<h2 id="misc">Misc</h2>
<h3 id="0-为真">&lsquo;0&rsquo; 为真</h3>
<p>与 Perl 5 不同，只包含零（&lsquo;0&rsquo;）的字符串为 <code>True</code>。由于 Raku 具有核心类型，因此更有意义。这也意味着常见的模式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="o">...</span> <span class="k">if</span> <span class="nb">defined</span> <span class="nv">$x</span> <span class="ow">and</span> <span class="nb">length</span> <span class="nv">$x</span><span class="p">;</span> <span class="c1"># or just length() in modern perls </span>
</span></span></code></pre></div><p>在 Raku 中变的简单</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="o">...</span> <span class="k">if</span> <span class="nv">$x</span><span class="p">;</span>
</span></span></code></pre></div><h3 id="dump">dump</h3>
<p>不见了。</p>
<p>Raku 设计允许自动透明地保存和加载编译的字节码。</p>
<p>到目前为止，Rakudo 仅支持模块。</p>
<h2 id="autoload">AUTOLOAD</h2>
<p><a href="https://docs.raku.org/language/typesystem#index-entry-FALLBACK_%28method%29">FALLBACK</a> 方法提供类似的功能。</p>
<h3 id="从模块导入特定函数">从模块导入特定函数</h3>
<p>在 Perl 5 中，可以选择性地从给定模块导入函数，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">ModuleName</span> <span class="sx">qw{foo bar baz}</span><span class="p">;</span>
</span></span></code></pre></div><p>在 Raku 中，通过使用相关子节点上的 <code>is export</code> 角色来指定要导出的函数;然后导出具有此角色的所有 <em>subs</em>。因此，以下模块 <code>Bar</code> 导出 subs <code>foo</code> 和 <code>bar</code> 但不导出 <code>baz</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">unit</span> <span class="k">module</span> <span class="nn">Bar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foo </span><span class="nv">$a</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">bar</span><span class="p">(</span><span class="nv">$b</span><span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">bar </span><span class="nv">$b</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">baz</span><span class="p">(</span><span class="nv">$z</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">baz </span><span class="nv">$z</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span></code></pre></div><p>要使用此模块，只需 <code>use Bar</code>，即可使用 <code>foo</code> 和 <code>bar</code> 函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Bar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>    <span class="c1">#=&gt; &#34;foo 1&#34; </span>
</span></span><span class="line"><span class="cl"><span class="nf">bar</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>    <span class="c1">#=&gt; &#34;bar 2&#34; </span>
</span></span></code></pre></div><p>如果尝试使用 <code>baz</code>，则会在编译时引发“未声明的例程”错误。</p>
<p>那么，如何重新创建能够有选择地导入函数的 Perl 5 行为呢？通过在模块内定义一个 <code>EXPORT</code> sub，它指定要导出的函数并删除 <code>module Bar</code> 语句。</p>
<p>以前的模块 <code>Bar</code> 现在只是一个名为 <code>Bar.pm6</code> 的文件，其中包含以下内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">EXPORT</span><span class="p">(</span><span class="o">*</span><span class="nv">@import-list</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">%exportable-subs</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#39;</span><span class="s1">&amp;foo</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="nv">&amp;foo</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#39;</span><span class="s1">&amp;bar</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="nv">&amp;bar</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">%subs-to-export</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nv">@import-list</span> <span class="k">-&gt;</span> <span class="nv">$import</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nb">grep</span> <span class="nv">$sub-name</span><span class="o">,</span> <span class="nv">%exportable-subs</span><span class="o">.</span><span class="nb">keys</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%subs-to-export</span><span class="p">{</span><span class="nv">$sub-name</span><span class="p">}</span> <span class="o">=</span> <span class="nv">%exportable-subs</span><span class="p">{</span><span class="nv">$sub-name</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nv">%subs-to-export</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="o">,</span> <span class="nv">$c</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foo, </span><span class="nv">$a</span><span class="s2">, </span><span class="nv">$b</span><span class="s2">, </span><span class="nv">$c</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">bar</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">bar, </span><span class="nv">$a</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">baz</span><span class="p">(</span><span class="nv">$z</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">baz, </span><span class="nv">$z</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span></code></pre></div><p>注意，不再通过 <code>is export</code> 角色显式地导出 subs，而是通过 <code>EXPORT</code> sub 指定我们想要导出的模块中的 subs，然后我们填充一个包含实际将被导出的 subs 的哈希。 <code>@import-list</code> 由调用代码中的 <code>use</code> 语句设置，因此允许我们有选择地导入模块可用的 subs。</p>
<p>因此，要仅导入 <code>foo</code> 例程，我们在调用代码中执行以下操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Bar</span> <span class="p">&lt;</span><span class="s">foo</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>       <span class="c1">#=&gt; &#34;foo 1&#34; </span>
</span></span></code></pre></div><p>在这里我们看到即使 <code>bar</code> 是可导出的，如果我们没有明确地导入它，它也无法使用。因此，这会在编译时导致“未声明的例程”错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Bar</span> <span class="p">&lt;</span><span class="s">foo</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">bar</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>       <span class="c1">#!&gt; &#34;Undeclared routine: bar used at line 3&#34; </span>
</span></span></code></pre></div><p>但是，这将有效</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Bar</span> <span class="p">&lt;</span><span class="s">foo bar</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>       <span class="c1">#=&gt; &#34;foo 1&#34; </span>
</span></span><span class="line"><span class="cl"><span class="nf">bar</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>       <span class="c1">#=&gt; &#34;bar 5&#34; </span>
</span></span></code></pre></div><p>另请注意，即使在 <code>use</code> 语句中指定，<code>baz</code> 仍然不可导致：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Bar</span> <span class="p">&lt;</span><span class="s">foo bar baz</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nf">baz</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>       <span class="c1">#!&gt; &#34;Undeclared routine: baz used at line 2&#34; </span>
</span></span></code></pre></div><p>为了使这个工作，显然必须跳过许多箍。在标准用例中，通过 <code>is export</code> 角色指定要导出的函数，Raku 会以正确的方式为您自动创建 <code>EXPORT</code> sub，因此应该非常仔细地考虑是否值得编写自己的 <code>EXPORT</code> 例程。</p>
<h3 id="从模块导入特定函数组">从模块导入特定函数组</h3>
<p>如果要从模块中导出函数组，只需要为组分配名称，其余的将自动运行。如果在 sub 声明中指定 <code>is  export</code>，则实际上是将此子例程添加到 <code>:DEFAULT</code> 导出组。但是您可以将子例程添加到另一个组或多个组：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">unit</span> <span class="k">module</span> <span class="nn">Bar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span> <span class="p">}</span>                   <span class="c1"># added by default to :DEFAULT </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">bar</span><span class="p">()</span> <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">FNORBL</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>          <span class="c1"># added to the FNORBL export group </span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">baz</span><span class="p">()</span> <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">DEFAULT</span><span class="p">:</span><span class="s">FNORBL</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>  <span class="c1"># added to both </span>
</span></span></code></pre></div><p>所以现在你可以像这样使用 <code>Bar</code> 模块：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Bar</span><span class="p">;</span>                     <span class="c1"># imports foo / baz </span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Bar</span> <span class="p">:</span><span class="s">FNORBL</span><span class="p">;</span>             <span class="c1"># imports bar / baz </span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Bar</span> <span class="p">:</span><span class="s">ALL</span><span class="p">;</span>                <span class="c1"># imports foo / bar / baz </span>
</span></span></code></pre></div><p>请注意 <code>:ALL</code> 是一个自动生成的组，它包含具有 <code>is export</code> trait 的所有子例程。</p>
<h2 id="核心模块">核心模块</h2>
<h3 id="datadumper">Data::Dumper</h3>
<p>在 Perl 5 中，<a href="https://metacpan.org/pod/Data::Dumper">Data::Dumper</a> 模块用于序列化，以及程序员调试程序数据结构的视图。</p>
<p>在 Raku 中，这些任务是使用 <code>.perl</code> 方法完成的，每个对象都有 <code>.perl</code> 方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># Given: </span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">@array_of_hashes</span> <span class="o">=</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span> <span class="n">NAME</span> <span class="o">=&gt;</span> <span class="s">&#39;apple&#39;</span><span class="p">,</span>   <span class="n">type</span> <span class="o">=&gt;</span> <span class="s">&#39;fruit&#39;</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span> <span class="n">NAME</span> <span class="o">=&gt;</span> <span class="s">&#39;cabbage&#39;</span><span class="p">,</span> <span class="n">type</span> <span class="o">=&gt;</span> <span class="s">&#39;no, please no&#39;</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl">    <span class="k">use</span> <span class="nn">Data::Dumper</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$</span><span class="nn">Data::Dumper::</span><span class="nv">Useqq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">print</span> <span class="n">Dumper</span> <span class="o">\</span><span class="nv">@array_of_hashes</span><span class="p">;</span> <span class="c1"># Note the backslash. </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@array_of_hashes</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span> <span class="c1"># .perl on the array, not on its reference. </span>
</span></span></code></pre></div><p>在 Perl 5 中，Data::Dumper 具有更复杂的可选调用约定，允许命名 VAR。</p>
<p>在 Raku 中，在变量的 sigil 前面放置一个冒号，将其转换为一个 Pair，其中包含 var 名称的键和 var 值的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Given: </span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="p">(</span> <span class="nv">$foo</span><span class="o">,</span> <span class="nv">$bar</span> <span class="p">)</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">44</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">@baz</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">32</span><span class="o">,</span> <span class="mi">64</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Hike!</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl">    <span class="k">use</span> <span class="nn">Data::Dumper</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="n">Data::Dumper-</span><span class="o">&gt;</span><span class="nf">Dump</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="o">[</span>     <span class="nv">$foo</span><span class="o">,</span> <span class="nv">$bar</span><span class="o">,</span> \<span class="nv">@baz</span>   <span class="o">],</span>
</span></span><span class="line"><span class="cl">        <span class="o">[</span> <span class="k">q</span><span class="sa">w</span><span class="p">(</span><span class="s">  foo   bar   *baz </span><span class="p">)</span> <span class="o">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Output </span>
</span></span><span class="line"><span class="cl"><span class="c1">#    $foo = 42; </span>
</span></span><span class="line"><span class="cl"><span class="c1">#    $bar = 44; </span>
</span></span><span class="line"><span class="cl"><span class="c1">#    @baz = ( </span>
</span></span><span class="line"><span class="cl"><span class="c1">#             16, </span>
</span></span><span class="line"><span class="cl"><span class="c1">#             32, </span>
</span></span><span class="line"><span class="cl"><span class="c1">#             64, </span>
</span></span><span class="line"><span class="cl"><span class="c1">#             &#39;Hike!&#39; </span>
</span></span><span class="line"><span class="cl"><span class="c1">#           ); </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="o">[</span> <span class="o">:</span><span class="nv">$foo</span><span class="o">,</span> <span class="o">:</span><span class="nv">$bar</span><span class="o">,</span> <span class="o">:</span><span class="nv">@baz</span> <span class="o">].</span><span class="nb">perl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «[&#34;foo&#34; =&gt; 42, &#34;bar&#34; =&gt; 44, &#34;baz&#34; =&gt; [16, 32, 64, &#34;Hike!&#34;]]» </span>
</span></span></code></pre></div><p>对于开发人员来说，还有一个特定于 Rakudo 的调试辅助工具，称为 <code>dd</code>（Tiny Data Dumper，它很小，它失去了“t”）。这将打印 STDERR 上给定变量的 <code>.perl</code> 表示和一些可以反省的额外信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl"><span class="n">dd</span> <span class="nv">$foo</span><span class="o">,</span> <span class="nv">$bar</span><span class="o">,</span> <span class="nv">@baz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «Int $foo = 42</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Int $bar = 44</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Array @baz = [16, 32, 64, &#34;Hike!&#34;]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># » </span>
</span></span></code></pre></div><h3 id="getoptlong">Getopt::Long</h3>
<p>切换解析现在由 <code>MAIN</code> 子例程的参数列表完成。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="c1"># Perl 5 </span>
</span></span><span class="line"><span class="cl">    <span class="k">use</span> <span class="mf">5.010</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">use</span> <span class="nn">Getopt::Long</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">GetOptions</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#39;length=i&#39;</span> <span class="o">=&gt;</span> <span class="o">\</span><span class="p">(</span> <span class="k">my</span> <span class="nv">$length</span> <span class="o">=</span> <span class="mi">24</span>       <span class="p">),</span> <span class="c1"># numeric </span>
</span></span><span class="line"><span class="cl">        <span class="s">&#39;file=s&#39;</span>   <span class="o">=&gt;</span> <span class="o">\</span><span class="p">(</span> <span class="k">my</span> <span class="nv">$data</span> <span class="o">=</span> <span class="s">&#39;file.dat&#39;</span> <span class="p">),</span> <span class="c1"># string </span>
</span></span><span class="line"><span class="cl">        <span class="s">&#39;verbose&#39;</span>  <span class="o">=&gt;</span> <span class="o">\</span><span class="p">(</span> <span class="k">my</span> <span class="nv">$verbose</span>           <span class="p">),</span> <span class="c1"># flag </span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="ow">or</span> <span class="nb">die</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="nv">$length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="nv">$data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#39;Verbosity &#39;</span><span class="p">,</span> <span class="p">(</span><span class="nv">$verbose</span> <span class="p">?</span> <span class="s">&#39;on&#39;</span> <span class="p">:</span> <span class="s">&#39;off&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">defined</span> <span class="nv">$verbose</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">perl</span> <span class="n">example</span><span class="o">.</span><span class="n">pl</span>
</span></span><span class="line"><span class="cl">    <span class="mi">24</span>
</span></span><span class="line"><span class="cl">    <span class="n">file</span><span class="o">.</span><span class="n">dat</span>
</span></span><span class="line"><span class="cl"><span class="n">perl</span> <span class="n">example</span><span class="o">.</span><span class="n">pl</span> <span class="o">--</span><span class="n">file</span><span class="o">=</span><span class="n">foo</span> <span class="o">--</span><span class="nb">length</span><span class="o">=</span><span class="mi">42</span> <span class="o">--</span><span class="n">verbose</span>
</span></span><span class="line"><span class="cl">    <span class="mi">42</span>
</span></span><span class="line"><span class="cl">    <span class="n">foo</span>
</span></span><span class="line"><span class="cl">    <span class="n">Verbosity</span> <span class="n">on</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">perl</span> <span class="n">example</span><span class="o">.</span><span class="n">pl</span> <span class="o">--</span><span class="nb">length</span><span class="o">=</span><span class="n">abc</span>
</span></span><span class="line"><span class="cl">    <span class="n">Value</span> <span class="s">&#34;abc&#34;</span> <span class="n">invalid</span> <span class="k">for</span> <span class="n">option</span> <span class="nb">length</span> <span class="p">(</span><span class="n">number</span> <span class="n">expected</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">Died</span> <span class="n">at</span> <span class="n">c</span><span class="o">.</span><span class="n">pl</span> <span class="n">line</span> <span class="mi">3</span><span class="o">.</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku </span>
</span></span><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span> <span class="kt">Int</span> <span class="o">:</span><span class="nv">$length</span> <span class="o">=</span> <span class="mi">24</span><span class="o">,</span> <span class="p">:</span><span class="s">file</span><span class="p">(</span><span class="nv">$data</span><span class="p">)</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">file.dat</span><span class="p">&#39;</span><span class="o">,</span> <span class="kt">Bool</span> <span class="o">:</span><span class="nv">$verbose</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$length</span> <span class="k">if</span> <span class="nv">$length</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$data</span>   <span class="k">if</span> <span class="nv">$data</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Verbosity </span><span class="p">&#39;</span><span class="o">,</span> <span class="p">(</span><span class="nv">$verbose</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">on</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">off</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">raku example.p6
</span></span><span class="line"><span class="cl">    <span class="m">24</span>
</span></span><span class="line"><span class="cl">    file.dat
</span></span><span class="line"><span class="cl">    Verbosity off
</span></span><span class="line"><span class="cl">raku example.p6 --file<span class="o">=</span>foo --length<span class="o">=</span><span class="m">42</span> --verbose
</span></span><span class="line"><span class="cl">    <span class="m">42</span>
</span></span><span class="line"><span class="cl">    foo
</span></span><span class="line"><span class="cl">    Verbosity on
</span></span><span class="line"><span class="cl">raku example.p6 --length<span class="o">=</span>abc
</span></span><span class="line"><span class="cl">    Usage:
</span></span><span class="line"><span class="cl">      c.p6 <span class="o">[</span>--length<span class="o">=</span>&lt;Int&gt;<span class="o">]</span> <span class="o">[</span>--file<span class="o">=</span>&lt;Any&gt;<span class="o">]</span> <span class="o">[</span>--verbose<span class="o">]</span>
</span></span></code></pre></div><p>请注意，Raku 会在命令行解析时自动生成错误的完整用法消息。</p>
<h2 id="自动翻译">自动翻译</h2>
<p>查找 Raku 版本的 Perl 5 构造的快速方法是通过自动翻译器运行它。</p>
<p>注意：这些翻译人员尚未完成。</p>
<h3 id="蓝虎">蓝虎</h3>
<p>该项目致力于 Perl 代码的自动化现代化。它（还）没有 Web 前端，因此必须在本地安装才有用。它还包含一个单独的程序，用于将 Perl 5 正则表达式转换为 Raku。</p>
<p><a href="https://github.com/Util/Blue_Tiger/">https://github.com/Util/Blue_Tiger/</a></p>
<h3 id="perlito">Perlito</h3>
<p>在线翻译！</p>
<p>该项目是一套 Perl 交叉编译器，包括 Perl 5 到 6 的转换。它有一个 Web 前端，因此无需安装即可使用。到目前为止，它仅支持 Perl 5 语法的子集。</p>
<p><a href="https://fglock.github.io/Perlito/perlito/perlito5.html">https://fglock.github.io/Perlito/perlito/perlito5.html</a></p>
<h3 id="perl-toraku">Perl-ToRaku</h3>
<p>Jeff Goff 为 Perl 5 设计的 <a href="https://metacpan.org/release/JGOFF/Perl-ToRaku-0.03">Perl::ToRaku</a> 模块是围绕 Perl::Critic 的框架设计的。它旨在将 Perl5 转换为可编译（如果不一定运行）的 Raku 代码，只需进行最少的更改。代码转换器是可配置和可插拔的，因此您可以创建和贡献自己的转换，并根据自己的需要定制现有的转换。您可以从 CPAN 安装最新版本，也可以在 GitHub 上实时关注项目。在线转换器可能在某些时候可用。</p>
<h3 id="其他翻译知识来源">其他翻译知识来源</h3>
<ul>
<li><a href="https://perlgeek.de/en/article/5-to-6">https://perlgeek.de/en/article/5-to-6</a></li>
<li><a href="https://github.com/Util/Blue_Tiger/">https://github.com/Util/Blue_Tiger/</a></li>
<li><a href="https://rakuadvent.wordpress.com/2011/12/23/day-23-idiomatic-perl-6/">https://rakuadvent.wordpress.com/2011/12/23/day-23-idiomatic-perl-6/</a></li>
<li><a href="https://docs.raku.org/language/5to6-overview">/language/5to6-overview</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 101 例]]></title>
            <link href="http://localhost:1313/rakulang/2.perl-6-by-example-p6-101/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/1.brief-introduction/?utm_source=atom_feed" rel="related" type="text/html" title="简介" />
                <link href="http://localhost:1313/rakulang/2018-10-08-mapgroupswithstate/?utm_source=atom_feed" rel="related" type="text/html" title="mapGroupsWithState" />
                <link href="http://localhost:1313/rakulang/2018-10-05-command-line-arguments-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的命令行参数" />
                <link href="http://localhost:1313/rakulang/2018-10-04-perl-6-code-in-rmarkdown/?utm_source=atom_feed" rel="related" type="text/html" title="Rmarkdown 中的 Raku 代码" />
                <link href="http://localhost:1313/rakulang/2018-10-03-a-naive-introduction-to-object-orientation-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 面向对象简单入门" />
            
                <id>http://localhost:1313/rakulang/2.perl-6-by-example-p6-101/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-10T21:13:31+08:00</published>
            <updated>2018-10-10T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>假设您举办乒乓球锦标赛。裁判员以格式告诉你每场比赛的结果 <code>Player1 Player2 | 3:2</code>，这意味着 Player1 赢 Player2 了3到2局。你需要一个脚本来总结每个玩家赢得的比赛和数量，以确定总冠军。</p>
<p>输入数据（存储在一个名为的文件中scores.txt）如下所示：</p>
<pre tabindex="0"><code>Beth Ana Charlie Dave
Ana Dave | 3:0
Charlie Beth | 3:1
Ana Beth | 2:3
Dave Charlie | 3:0
Ana Charlie | 3:1
Beth Dave | 0:3
</code></pre><p>第一行是球员名单。每个后续行记录匹配的结果。</p>
<p>这是在Raku中解决该问题的一种方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$file</span>  <span class="o">=</span> <span class="nb">open</span> <span class="p">&#39;</span><span class="s1">scores.txt</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">get</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%matches</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%sets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">next</span> <span class="k">unless</span> <span class="nv">$line</span><span class="p">;</span> <span class="c1"># ignore any empty lines </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="p">(</span><span class="nv">$pairing</span><span class="o">,</span> <span class="nv">$result</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> | </span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="p">(</span><span class="nv">$p1</span><span class="o">,</span> <span class="nv">$p2</span><span class="p">)</span>          <span class="o">=</span> <span class="nv">$pairing</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="p">(</span><span class="nv">$r1</span><span class="o">,</span> <span class="nv">$r2</span><span class="p">)</span>          <span class="o">=</span> <span class="nv">$result</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">:</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="nv">%sets</span><span class="p">{</span><span class="nv">$p1</span><span class="p">}</span> <span class="o">+=</span> <span class="nv">$r1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">%sets</span><span class="p">{</span><span class="nv">$p2</span><span class="p">}</span> <span class="o">+=</span> <span class="nv">$r2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$r1</span> <span class="o">&gt;</span> <span class="nv">$r2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">%matches</span><span class="p">{</span><span class="nv">$p1</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">%matches</span><span class="p">{</span><span class="nv">$p2</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@names</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@sorted</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$n</span><span class="s2"> has won </span><span class="nv">%matches</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span><span class="s2"> matches and </span><span class="nv">%sets</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span><span class="s2"> sets</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这会产生输出：</p>
<pre tabindex="0"><code>Ana has won 2 matches and 8 sets
Dave has won 2 matches and 6 sets
Charlie has won 1 matches and 4 sets
Beth has won 1 matches and 4 sets
</code></pre><h2 id="v6">v6</h2>
<p>每个Raku程序都应该以类似于的行开头use v6;。该行告诉编译器程序期望的Perl版本。如果您不小心使用Perl 5运行该文件，您将收到有用的错误消息。6.c是Raku版本的示例。</p>
<h2 id="statement">statement</h2>
<p>Raku程序由零个或多个语句组成。甲语句用分号或在线的端部的大括号结束：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$file</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#39;</span><span class="s1">scores.txt</span><span class="p">&#39;;</span>
</span></span></code></pre></div><h2 id="lexical和block">lexical和block</h2>
<p>my声明一个词法变量，它只在从声明点到块结尾的当前块中可见。如果没有封闭块，则在整个文件的剩余部分（它实际上是封闭块）中可见。块是大括号之间的代码的任何部分{ }。</p>
<h2 id="sigil-和-identifier">sigil 和 identifier</h2>
<p>变量名开始于印记，这是因为这样的非字母数字符号$，@，%，或&amp;&ndash;or偶尔双冒号::。Sigils指示变量的结构接口，例如它是否应被视为单个值，复合值，子例程等。在sigil之后出现一个标识符，可以由字母，数字和下划线组成。在字母之间你也可以使用破折号-或撇号&rsquo;，因此isn&rsquo;t并且double-click是有效的标识符。</p>
<h2 id="scalar">scalar</h2>
<p>Sigils指示变量的默认访问方法。带有@印记的变量可以在位置上访问; 带有%sigil的变量由字符串键访问。的$印记，然而，指示可以包含任何单个值和以任何方式进行访问的通用标量容器中。标量甚至可以包含像a Array或a 这样的复合对象Hash; 的$印记表示这应该被视为一个单一的值，即使在期望多个值（如用一个上下文Array或Hash）。</p>
<h2 id="filehandle-和-assignment">filehandle 和 assignment</h2>
<p>内置函数open打开一个文件，此处命名scores，并返回一个文件句柄 - 表示该文件的对象。等号将该文件句柄= 分配给左侧的变量，这意味着$file现在存储文件句柄。</p>
<h2 id="string-literal">string literal</h2>
<p>&lsquo;scores.txt&rsquo;是一个字符串文字。字符串是一段文本，字符串文字是直接出现在程序中的字符串。在这一行中，它是提供给的参数open。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">get</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>
</span></span></code></pre></div><h2 id="arraymethod-和-invocant">array，method 和 invocant</h2>
<p>右侧调用一个方法 - 一个命名的行为组 - 以get存储在其中的文件句柄命名$file。该get方法从文件中读取并返回一行，删除行结尾。如果您$file在打电话后打印内容get，您将看到第一行不再在那里。words也是一个方法，在返回的字符串上调用get。words将其调用者 - 它所操作的字符串 - 分解为一个单词列表，这里的意思是由空格分隔的字符串。它将单个字符串&rsquo;Beth Ana Charlie Dave&rsquo;转换为字符串列表&rsquo;Beth&rsquo;, &lsquo;Ana&rsquo;, &lsquo;Charlie&rsquo;, &lsquo;Dave&rsquo;。</p>
<p>最后，此列表存储在<a href="https://docs.raku.org/type/Array">Array</a>中 @names。该@印记标志着声明的变量作为Array。数组存储有序列表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%matches</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">%sets</span><span class="p">;</span>
</span></span></code></pre></div><h2 id="hash">hash</h2>
<p>这两行代码声明了两个哈希值。的%印记标记每个变量作为Hash。A Hash是键值对的无序集合。其他编程语言称为哈希表，字典或映射。您可以查询一个哈希表对应于一定的值$key用%hash{$key}。</p>
<p>在得分计数程序中，%matches存储每个玩家赢得的比赛数量。%sets存储每个玩家赢得的套数。这两个哈希都是由玩家的名字索引的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="for-和-block">for 和 block</h2>
<p>for生成一个循环，该循环运行由花括号分隔的块一次，用于列表的每个项目，将变量设置$line为每次迭代的当前值。$file.lines生成从文件读取的行列表，从文件scores.txt的第二行开始，因为我们已经调用$file.get过一次，然后一直到文件的末尾。</p>
<p>在第一次迭代期间，$line将包含字符串Ana Dave | 3:0; 在第二次，Charlie Beth | 3:1等等。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">$pairing</span><span class="o">,</span> <span class="nv">$result</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> | </span><span class="p">&#39;);</span>
</span></span></code></pre></div><p>my可以同时声明多个变量。赋值的右侧是对名为的方法的调用split，将该字符串&rsquo; | &lsquo;作为参数传递。</p>
<p>split将其调用者分解为字符串列表，以便将列表项与分隔符连接将&rsquo; | &lsquo;生成原始字符串。</p>
<p>$pairing获取返回列表的第一项，$result第二项。</p>
<p>处理完第一行后，$pairing将保持字符串Ana Dave和$result 3:0。</p>
<p>接下来的两行遵循相同的模式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">$p1</span><span class="o">,</span> <span class="nv">$p2</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$pairing</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="p">(</span><span class="nv">$r1</span><span class="o">,</span> <span class="nv">$r2</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$result</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">:</span><span class="p">&#39;);</span>
</span></span></code></pre></div><p>第一个提取并存储变量$p1和中两个玩家的名字$p2。第二个为每个玩家提取结果并将其存储在$r1和中$r2。</p>
<p>处理完文件的第一行后，变量包含值：cell &lsquo;0&rsquo;</p>
<table>
<thead>
<tr>
<th style="text-align:left">Variable</th>
<th style="text-align:left">Contents</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$line</td>
<td style="text-align:left">&lsquo;Ana Dave `</td>
</tr>
<tr>
<td style="text-align:left">$pairing</td>
<td style="text-align:left">&lsquo;Ana Dave&rsquo;</td>
</tr>
<tr>
<td style="text-align:left">$result</td>
<td style="text-align:left">&lsquo;3:0&rsquo;</td>
</tr>
<tr>
<td style="text-align:left">$p1</td>
<td style="text-align:left">&lsquo;Ana&rsquo;</td>
</tr>
<tr>
<td style="text-align:left">$p2</td>
<td style="text-align:left">&lsquo;Dave&rsquo;</td>
</tr>
<tr>
<td style="text-align:left">$r1</td>
<td style="text-align:left">&lsquo;3&rsquo;</td>
</tr>
<tr>
<td style="text-align:left">$r2</td>
<td style="text-align:left">&lsquo;0&rsquo;</td>
</tr>
</tbody>
</table>
<p>然后程序计算每个玩家赢得的次数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">%sets</span><span class="p">{</span><span class="nv">$p1</span><span class="p">}</span> <span class="o">+=</span> <span class="nv">$r1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">%sets</span><span class="p">{</span><span class="nv">$p2</span><span class="p">}</span> <span class="o">+=</span> <span class="nv">$r2</span><span class="p">;</span>
</span></span></code></pre></div><p><code>+=</code> 赋值运算符是一个快捷方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">%sets</span><span class="p">{</span><span class="nv">$p1</span><span class="p">}</span> <span class="o">=</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$p1</span><span class="p">}</span> <span class="o">+</span> <span class="nv">$r1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">%sets</span><span class="p">{</span><span class="nv">$p2</span><span class="p">}</span> <span class="o">=</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$p2</span><span class="p">}</span> <span class="o">+</span> <span class="nv">$r2</span><span class="p">;</span>
</span></span></code></pre></div><h2 id="any-和-">Any 和 +=</h2>
<p>+= $r1表示将左侧变量中的值增加$ r1。在第一次迭代%sets{$p1}中尚未设置，因此它默认为一个名为的特殊值Any。加法和递增运算符视为Any零的数字; 字符串会自动转换为数字，因为加法是一个数字运算。</p>
<p>fat arrow，pair和autovivification
在这两行执行之前，%sets为空。添加到不在散列中的条目将导致该条目即时生成，其值从零开始。（这是autovivification）。在这两行第一次运行后，%sets包含&rsquo;Ana&rsquo; =&gt; 3, &lsquo;Dave&rsquo; =&gt; 0 。（胖箭头=&gt; 分隔键中的键和值Pair。）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$r1</span> <span class="o">&gt;</span> <span class="nv">$r2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">%matches</span><span class="p">{</span><span class="nv">$p1</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">%matches</span><span class="p">{</span><span class="nv">$p2</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果$r1在数值上大于$r2，则%matches{$p1}增加1。如果$r1不大于$r2，则%matches{$p2}递增。正如在这种情况下+=，如果之前不存在任何一个哈希值，它将通过增量操作自动生成。</p>
<h2 id="postincrement-和-preincrement">postincrement 和 preincrement</h2>
<p>$thing++是$thing += 1或的缩写$thing = $thing + 1，除了表达式的返回值在增量$thing 之前的小异常，而不是递增的值。与许多其他编程语言一样，您可以将其++用作前缀。然后它返回递增的值; my $x = 1; say ++$x打印2。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@names</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>
</span></span></code></pre></div><h2 id="variables-_">variables, $_</h2>
<p>该行包含三个单独的简单步骤。数组的sort方法返回数组内容的排序版本。但是，数组上的默认排序按其内容排序。要以获胜者优先顺序打印玩家名称，代码必须按照玩家的分数而不是他们的名字对数组进行排序。该sort方法的参数是一个块，用于将数组元素（播放器的名称）转换为要排序的数据。数组项通过主题变量 传入$_。</p>
<h2 id="block">block</h2>
<p>您之前已经看过块：for循环-&gt; $line { &hellip; } 和if语句都在块上运行。块是一个独立的Raku代码片段，带有可选的签名（-&gt; $line 部分）。</p>
<p>按分数对玩家进行排序的最简单方法是@names.sort({ %matches{$_} })，根据赢得的匹配数进行排序。然而Ana和Dave都赢了两场比赛。这种简单的排序并没有考虑赢得的套数，这是决定谁赢得锦标赛的次要标准。</p>
<h2 id="stable-sort">stable sort</h2>
<p>当两个数组项具有相同的值时，sort将它们保留为找到它们的顺序。计算机科学家称之为稳定的。该程序利用Raku的这个属性sort通过两次排序来实现目标：首先是赢得的集合数量（次要标准），然后是赢得的匹配数量。</p>
<p>在第一个排序步骤之后，名称在顺序中Beth Charlie Dave Ana。在第二个排序步骤之后，它仍然是相同的，因为没有人比其他人赢得更少的比赛但是更多的比赛。这样的情况是完全可能的，特别是在较大的比赛中。</p>
<p>sort从最小到最大按升序排序。这与所需顺序相反。因此，代码.reverse在第二次排序的结果上调用方法，并将最终列表存储在其中@sorted。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@sorted</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$n</span><span class="s2"> has won </span><span class="nv">%matches</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span><span class="s2"> matches and </span><span class="nv">%sets</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span><span class="s2"> sets</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="sayprint-和-put">say，print 和 put</h2>
<p>为了打印出玩家及其分数，代码循环@sorted，$n依次设置每个玩家的名字。将此代码读作“对于已排序的每个元素，设置$n为元素，然后执行以下块的内容”。say将其参数打印到标准输出（通常是屏幕），然后是换行符。（print如果您不想在最后使用换行符，请使用。）</p>
<p>请注意，say通过调用.gist方法将截断某些数据结构，因此put如果您想要精确输出则更安全。</p>
<h2 id="interpolation">interpolation</h2>
<p>当您运行该程序时，您将看到它say不会逐字打印该字符串的内容。代替$n它打印变量的内容$n- 存储在其中的玩家的名字$n。代码及其内容的自动替换是插值。此插值仅在由双引号分隔的字符串中发生&quot;&hellip;&quot;。单引号字符串&rsquo;&hellip;&lsquo;不进行插值：</p>
<h2 id="double-quoted-strings-和-single-quoted-strings">double-quoted strings 和 single-quoted strings</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$names</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">things</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Do not call me $names</span><span class="p">&#39;;</span> <span class="c1"># OUTPUT: «Do not call me $names␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Do not call me </span><span class="nv">$names</span><span class="p">&#34;;</span> <span class="c1"># OUTPUT: «Do not call me things␤» </span>
</span></span></code></pre></div><p>Raku中的双引号字符串可以使用$sigil以及花括号中的代码块来插入变量。由于任何Perl代码都可以出现在花括号中，因此可以通过将它们放在花括号中来插入Arrays和Hashes。</p>
<p>花括号内的数组使用每个项目之间的单个空格字符进行插值。花括号内的哈希值被插值为一系列线条。每行包含一个键，后跟一个制表符，然后是与该键相关的值，最后是换行符。</p>
<p>我们现在看一个例子吧。</p>
<p>在此示例中，您将看到一些特殊语法，可以更轻松地创建字符串列表。这是&lt;&hellip;&gt; <a href="https://docs.raku.org/language/operators#index-entry-qw-quote-words-quote-words">引用词</a>构造。当您在&lt;和&gt;之间放置单词时，它们都被假定为字符串，因此您不需要将它们分别用双引号括起来&quot;&hellip;&quot; 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Math: </span><span class="p">{</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">}&#34;;</span>                  <span class="c1"># OUTPUT: «Math: 3␤» </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@people</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">Luke Matthew Mark</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The synoptics are: </span><span class="p">{</span><span class="nv">@people</span><span class="p">}&#34;;</span>     <span class="c1"># OUTPUT: «The synoptics are: Luke Matthew Mark␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;{</span><span class="nv">%sets</span><span class="p">}</span><span class="s2">␤</span><span class="p">&#34;;</span>                         <span class="c1"># From the table tennis tournament </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Charlie 4 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Dave    6 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Ana     8 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># Beth    4 </span>
</span></span></code></pre></div><p>当数组和散列变量直接出现在双引号字符串中（而不是在大括号内）时，如果它们的名称后跟postcircumfix - 一个跟在语句后面的包围对，它们只会被插值。在变量名和postcircumfix之间进行方法调用也没问题。</p>
<h2 id="zen-slice">Zen slice</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@flavors</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">vanilla peach</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavors</span><span class="p">&#34;;</span>           <span class="c1"># OUTPUT: «we have @flavors␤» </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavors</span><span class="s2">[0]</span><span class="p">&#34;;</span>        <span class="c1"># OUTPUT: «we have vanilla␤» </span>
</span></span><span class="line"><span class="cl"><span class="c1"># so-called &#34;Zen slice&#34; </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavors</span><span class="s2">[]</span><span class="p">&#34;;</span>         <span class="c1"># OUTPUT: «we have vanilla peach␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># method calls ending in postcircumfix </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavors</span><span class="o">.</span><span class="nf">sort</span><span class="p">()&#34;;</span>    <span class="c1"># OUTPUT: «we have peach vanilla␤» </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># chained method calls: </span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavors</span><span class="s2">.sort.join(&#39;, &#39;)</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">                                <span class="c1"># OUTPUT: «we have peach, vanilla␤» </span>
</span></span></code></pre></div><h1 id="练习">练习</h1>
<p>1.示例程序的输入格式是多余的：第一行包含所有玩家的名字是不必要的，因为你可以通过查看后续行中的名字来找出参加锦标赛的玩家。</p>
<p>如果不使用@names变量，如何使程序运行？提示：%hash.keys返回存储的所有密钥的列表%hash。</p>
<p>答：删除该行my @names = $file.get.words;，然后更改：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@names</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>
</span></span></code></pre></div><p>为:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">%sets</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>
</span></span></code></pre></div><p>除了删除冗余@names变量之外，您还可以使用它来警告播放器是否出现在第一行中未提及的情况，例如由于拼写错误。你会如何修改你的程序来实现这一目标？</p>
<p>提示：尝试使用成员资格运算符。</p>
<p>答：更改@names到@valid-players。当通过文件的行循环，请检查$p1和$p2在@valid-players。请注意，对于<a href="https://docs.raku.org/routine/(elem)">成员运算符</a>，您也可以使用(elem)和!(elem)。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">...</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@valid-players</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">get</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="p">(</span><span class="nv">$pairing</span><span class="o">,</span> <span class="nv">$result</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> | </span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="p">(</span><span class="nv">$p1</span><span class="o">,</span> <span class="nv">$p2</span><span class="p">)</span>          <span class="o">=</span> <span class="nv">$pairing</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$p1</span> <span class="o">∉</span> <span class="nv">@valid-players</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Warning: &#39;</span><span class="nv">$p1&#39;</span><span class="s2"> is not on our list!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$p2</span> <span class="o">∉</span> <span class="nv">@valid-players</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Warning: &#39;</span><span class="nv">$p2&#39;</span><span class="s2"> is not on our list!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[简介]]></title>
            <link href="http://localhost:1313/rakulang/1.brief-introduction/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/2018-10-08-mapgroupswithstate/?utm_source=atom_feed" rel="related" type="text/html" title="mapGroupsWithState" />
                <link href="http://localhost:1313/rakulang/2018-10-05-command-line-arguments-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的命令行参数" />
                <link href="http://localhost:1313/rakulang/2018-10-04-perl-6-code-in-rmarkdown/?utm_source=atom_feed" rel="related" type="text/html" title="Rmarkdown 中的 Raku 代码" />
                <link href="http://localhost:1313/rakulang/2018-10-03-a-naive-introduction-to-object-orientation-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 面向对象简单入门" />
                <link href="http://localhost:1313/notes/%E4%BD%BF%E7%94%A8-spark-%E8%AF%BB%E5%86%99-hbase-%E6%95%B0%E6%8D%AE/?utm_source=atom_feed" rel="related" type="text/html" title="Use Spark to read and write HBase data" />
            
                <id>http://localhost:1313/rakulang/1.brief-introduction/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-09T21:13:31+08:00</published>
            <updated>2018-10-09T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>记录像 Raku 这样的大型语言必须平衡几个相互矛盾的目标，例如简洁而全面，迎合具有丰富经验的专业开发人员，同时也可以迎合接触到该语言的新手。</p>
<p>有关快速实践的介绍，有一个简短的<a href="https://docs.raku.org/language/101-basics">注释编程示例</a>。</p>
<p>对于具有其他语言经验的程序员，有许多<strong>迁移</strong>指南可以将 Raku 的功能与其他语言进行比较和对比。</p>
<p>许多教程涵盖了 Raku 特别具有创新性的几个领域。节标题应该有助于导航剩余的文档。</p>
<p>raku.org 网站上的其他地方列出了许多<a href="https://raku.org/resources">有用的资源</a>。这些包括文章，书籍，幻灯片演示和视频。</p>
<p>已经发现，Raku 的新手经常会提出问题，这些问题表明了其他编程范例带来的假设。建议首先审查基本主题部分中的以下部分。</p>
<ul>
<li><a href="https://docs.raku.org/type/Signature">签名</a> - 每个例程（包括子例程和方法）都有签名。理解子或方法的签名中给出的信息提供了一种快速掌握例程的操作和效果的方法。</li>
<li><a href="https://docs.raku.org/language/containers">容器</a> - 变量，就像计算机语言的名词一样，是存储信息的容器。容器正式名称中的第一个字母，例如 <code>$my-variable</code> 的 <code>'$'</code>，或 <code>@an-array-of-things</code> 的 <code>'@'</code>，或 <code>%the-score-in-the</code> 的 <code>'％'</code> - 携带有关容器的信息。但是，Raku 比其他语言更抽象，可以存储在容器中。因此，例如，$scalar 容器可以包含实际上是数组的对象。</li>
<li><a href="https://docs.raku.org/language/classtut">类和角色</a> -  Raku 基本上基于对象，它们根据类和角色进行描述。与某些语言不同，Raku 并没有强制使用面向对象的编程实践，并且可以编写有用的程序，就好像 Raku 纯粹是程序性的。然而，复杂的软件，例如 Raku 的 Rakudo 编译器，通过编写面向对象的惯用法变得更加简单，这就是为什么通过查看类是什么以及角色是什么来更容易理解 Raku 文档。如果不了解类和角色，就很难理解类型，文档的整个部分都是专门用的。</li>
<li><a href="https://docs.raku.org/language/traps">要避免的陷阱</a> - 一些常见的假设导致代码无法像程序员想要的那样工作。本节标识了一些。当某些事情没有成功时，值得回顾一下。</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[mapGroupsWithState]]></title>
            <link href="http://localhost:1313/rakulang/2018-10-08-mapgroupswithstate/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/2018-10-05-command-line-arguments-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的命令行参数" />
                <link href="http://localhost:1313/rakulang/2018-10-04-perl-6-code-in-rmarkdown/?utm_source=atom_feed" rel="related" type="text/html" title="Rmarkdown 中的 Raku 代码" />
                <link href="http://localhost:1313/rakulang/2018-10-03-a-naive-introduction-to-object-orientation-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 面向对象简单入门" />
                <link href="http://localhost:1313/notes/%E4%BD%BF%E7%94%A8-spark-%E8%AF%BB%E5%86%99-hbase-%E6%95%B0%E6%8D%AE/?utm_source=atom_feed" rel="related" type="text/html" title="Use Spark to read and write HBase data" />
                <link href="http://localhost:1313/notes/%E5%83%8F%E6%88%91%E8%BF%99%E6%A0%B7%E7%9A%84-jar-%E5%8C%85/?utm_source=atom_feed" rel="related" type="text/html" title="添加第三方 pom 仓库" />
            
                <id>http://localhost:1313/rakulang/2018-10-08-mapgroupswithstate/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-08T14:18:20+08:00</published>
            <updated>2018-10-08T14:18:20+08:00</updated>
            
            
            <content type="html"><![CDATA[<pre tabindex="0"><code>  /**
   * ::Experimental::
   * (Scala-specific)
   * Applies the given function to each group of data, while maintaining a user-defined per-group
   * state. The result Dataset will represent the objects returned by the function.
   * For a static batch Dataset, the function will be invoked once per group. For a streaming
   * Dataset, the function will be invoked for each group repeatedly in every trigger, and
   * updates to each group&#39;s state will be saved across invocations.
   * See [[org.apache.spark.sql.streaming.GroupState]] for more details.
   *
   * @tparam S The type of the user-defined state. Must be encodable to Spark SQL types.
   * @tparam U The type of the output objects. Must be encodable to Spark SQL types.
   * @param func Function to be called on every group.
   * @param timeoutConf Timeout configuration for groups that do not receive data for a while.
   *
   * See [[Encoder]] for more details on what types are encodable to Spark SQL.
   * @since 2.2.0
   */
  @Experimental
  @InterfaceStability.Evolving
  def mapGroupsWithState[S: Encoder, U: Encoder](
      timeoutConf: GroupStateTimeout)(
      func: (K, Iterator[V], GroupState[S]) =&gt; U): Dataset[U] = {
    val flatMapFunc = (key: K, it: Iterator[V], s: GroupState[S]) =&gt; Iterator(func(key, it, s))
    Dataset[U](
      sparkSession,
      FlatMapGroupsWithState[K, V, S, U](
        flatMapFunc.asInstanceOf[(Any, Iterator[Any], LogicalGroupState[Any]) =&gt; Iterator[Any]],
        groupingAttributes,
        dataAttributes,
        OutputMode.Update,
        isMapGroupsWithState = true,
        timeoutConf,
        child = logicalPlan))
  }
</code></pre><p>看这个函数的注释：</p>
<pre tabindex="0"><code>  /**
   * ::Experimental::
   * (Scala-specific)
   * Applies the given function to each group of data, while maintaining a user-defined per-group
   * state. The result Dataset will represent the objects returned by the function.
   * For a static batch Dataset, the function will be invoked once per group. For a streaming
   * Dataset, the function will be invoked for each group repeatedly in every trigger, and
   * updates to each group&#39;s state will be saved across invocations.
   * See [[org.apache.spark.sql.streaming.GroupState]] for more details.
   *
   * @tparam S The type of the user-defined state. Must be encodable to Spark SQL types.
   * @tparam U The type of the output objects. Must be encodable to Spark SQL types.
   * @param func Function to be called on every group.
   * @param timeoutConf Timeout configuration for groups that do not receive data for a while.
   *
   * See [[Encoder]] for more details on what types are encodable to Spark SQL.
   * @since 2.2.0
   */
</code></pre><p>这个函数还是实验性质的，并且是 Scala 特定的，Spark 2.2.0 以后才支持这个 API。它还是个柯里化函数。</p>
<p>将给定的函数应用于每组数据，同时维护每个组的用户定义状态。结果数据集将代表该函数返回的对象。对于静态批数据集，每组调用一次函数。对于流数据集，该函数将在每次触发时为每个组重复调用，并且对每组状态的更新将跨调用保存。</p>
<h2 id="参数">参数</h2>
<ul>
<li>@tparam S 用户定义状态的<strong>类型</strong>。必须编码为 Spark SQL 类型。</li>
<li>@tparam U 输出对象的<strong>类型</strong>。必须编码为 Saprk SQL 类型。</li>
<li>@param func 每个组上调用的函数。</li>
<li>@param timeoutConf 在一段时间内不接收数据的组的超时配置。</li>
</ul>
<p>注意 <code>tparam</code> 带了个字母 t, 说明这个参数是<strong>类型参数</strong>。 mapGroupsWithState 这个函数真正接收的是 2 个参数，一个是超时时间， 一个是 func 函数。</p>
<pre tabindex="0"><code>func: (K, Iterator[V], GroupState[S]) =&gt; U)
</code></pre><p>看一下这个函数的签名，函数的类型是含有三个元素的元组，函数的返回值是一个 <code>U</code>, 代表输出对象的<strong>类型</strong>。重点来看一下 func 这个函数的接收的参数：</p>
<ul>
<li>K 明显是一个类型，例如 Int, String，用作 groupByKey 中的键的类型。</li>
<li>Iterator[V] V incoming messages of type V</li>
<li>GroupState[S] S 输出对象的类型</li>
</ul>
<p>我们来看一下 func</p>
<pre tabindex="0"><code>  def updateSessionEvents(
      id: Int,
      userEvents: Iterator[UserEvent],
      state: GroupState[UserSession]): Option[UserSession] = { ... }
</code></pre><p>看到 func 函数里面的参数都是普通的参数， 就是带了类型而已。但是 <code>func: (K, Iterator[V], GroupState[S]) =&gt; U)</code> 里面的参数，看着好像都是类型参数，而不是普通的函数参数。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的命令行参数]]></title>
            <link href="http://localhost:1313/rakulang/2018-10-05-command-line-arguments-in-perl-6/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/2018-10-04-perl-6-code-in-rmarkdown/?utm_source=atom_feed" rel="related" type="text/html" title="Rmarkdown 中的 Raku 代码" />
                <link href="http://localhost:1313/rakulang/2018-10-03-a-naive-introduction-to-object-orientation-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 面向对象简单入门" />
                <link href="http://localhost:1313/notes/%E4%BD%BF%E7%94%A8-spark-%E8%AF%BB%E5%86%99-hbase-%E6%95%B0%E6%8D%AE/?utm_source=atom_feed" rel="related" type="text/html" title="Use Spark to read and write HBase data" />
                <link href="http://localhost:1313/notes/%E5%83%8F%E6%88%91%E8%BF%99%E6%A0%B7%E7%9A%84-jar-%E5%8C%85/?utm_source=atom_feed" rel="related" type="text/html" title="添加第三方 pom 仓库" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%B8%89%E6%96%B9-python-%E5%BA%93/?utm_source=atom_feed" rel="related" type="text/html" title="Python 第三方库" />
            
                <id>http://localhost:1313/rakulang/2018-10-05-command-line-arguments-in-perl-6/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-03T21:33:03+08:00</published>
            <updated>2018-10-03T21:33:03+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="sub-main">Sub MAIN</h1>
<p>在 Raku 中，命令行参数的解析是通过 <code>MAIN</code> 子例程完成的，<code>MAIN</code> 子例程是一种特殊的子例程，它根据 <code>MAIN</code> 子例程的签名解析命令行参数。与其他子例程一样，<code>MAIN</code> 子例程可以具有命名参数和位置参数、可选(和必需)参数、多重分派等等。</p>
<p>有了 <code>MAIN</code> 子例程的定义，<code>USAGE</code> 子例程将由编译器自动生成。可以修改此子例程以返回定制的使用消息。所有命令行参数也可以在特殊变量 <code>@*ARGS</code> 中使用，它可以在 <code>MAIN</code> 处理之前发生转变。</p>
<h1 id="命名参数和位置参数">命名参数和位置参数</h1>
<h2 id="命名参数">命名参数</h2>
<p>让我们从一个简单的程序开始(保存为 <code>prog.p6</code>):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="o">:</span><span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span><span class="o">,</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="o">:</span><span class="nv">$last-name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Doe</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$formatted-name</span> <span class="o">=</span> <span class="p">&#34;</span><span class="nv">$name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$last-name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$formatted-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这个 <code>MAIN</code> 子句中，我们通过前置 <code>:</code> 到子例程签名中的每个变量上，创建了两个带有类型约束(<code>Str</code>)的命名参数，<code>$name</code> 和 <code>$last-name</code>。这些参数也有默认值，这是通过给参数赋值来实现的。在本例中，我们将 <code>$name</code> 设置为默认值 “John”，将 <code>$last-name</code> 设置为 “Doe”。如果执行 <code>prog.p6</code> 时命令行参数与 <code>MAIN</code> 签名匹配，则会打印出一个格式化的全名:</p>
<pre tabindex="0"><code>$ raku prog.p6
John Doe
$ raku prog.p6 --name=&#39;carl&#39; --last-name=&#39;sagan&#39;
Carl Sagan
$ raku prog.p6 --last-name=&#39;sagan&#39; --name=&#39;carl&#39;
Carl Sagan
</code></pre><p>如您所见，命名参数可以按任何顺序传递。</p>
<p>如果没有匹配 <code>MAIN</code> 签名，则会得到一条使用信息:</p>
<pre tabindex="0"><code>$ p6 prog.p6 --name=&#39;Carl&#39; --last-name=&#39;Sagan&#39; --career=&#39;astronomer&#39;
prog.p6 [--name=&lt;Str&gt;] [--last-name=&lt;Str&gt;]
</code></pre><h2 id="位置参数">位置参数</h2>
<p>如果我们想使用位置参数，我们可以重新定义子例程的签名，只解析位置参数。与之前的版本一样，我们将为参数设置默认值，但是这些参数现在是位置的，并且必须按照签名定义的顺序提供:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span><span class="o">,</span>       <span class="c1"># No colon(:) in the variable </span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="nv">$last-name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Doe</span><span class="p">&#39;</span><span class="o">,</span>   <span class="c1"># No colon(:) in the variable </span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$formatted-name</span> <span class="o">=</span> <span class="p">&#34;</span><span class="nv">$name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$last-name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$formatted-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>用匹配的签名执行 <code>prog.p6</code> 将打印以下输出:</p>
<pre tabindex="0"><code>$ raku prog.p6
John Doe

$ raku prog.p6 carl sagan
Carl Sagan
</code></pre><p>如果签名不匹配，则它给出如下用法信息：</p>
<pre tabindex="0"><code>$ raku prog.p6 carl sagan astronomer
prog.p6 [&lt;name&gt;] [&lt;last-name&gt;]
</code></pre><h2 id="多重分派">多重分派</h2>
<p>我们可能更喜欢在我们的小程序中同时使用命名参数和位置参数。如前所述，我们可以使用多重分派(几个名称相同但签名不同的子例程)来声明具有自己签名的多个 <code>MAIN</code> 子例程。为了做到这一点，每个候选用 <code>multi</code> 关键字来声明，而不是 <code>sub</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">MAIN</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="o">:</span><span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span><span class="o">,</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="o">:</span><span class="nv">$last-name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Doe</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$formatted-name</span> <span class="o">=</span> <span class="p">&#34;</span><span class="nv">$name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$last-name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$formatted-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">MAIN</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span><span class="o">,</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="nv">$last-name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Doe</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$formatted-name</span> <span class="o">=</span> <span class="p">&#34;</span><span class="nv">$name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$last-name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$formatted-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这两个 <code>MAIN</code> 子例程看起来非常相似，但是它们有不同的签名来描述预期的命令行参数。</p>
<p>如果我们执行 <code>prog.p6</code> 的命令行参数匹配任何 <code>MAIN</code> 签名，我们将得到格式化的全名:</p>
<pre tabindex="0"><code>$ p6 prog.p6 --name=&#39;ada&#39; --last-name=&#39;lovelace&#39;
Ada Lovelace

$ p6 prog.p6 marcus aurelius
Marcus Aurelius
</code></pre><p>如果没有匹配的签名，我们将得到一个用法消息，详细说明我们的 <code>MAIN</code> 子例程可能的签名:</p>
<pre tabindex="0"><code>$ p6 prog.p6 --name=&#39;Ada&#39; --last-name=&#39;Lovelace&#39; --title=&#39;Ms&#39;
Usage:
  prog.p6 [--name=&lt;Str&gt;] [--last-name=&lt;Str&gt;] 
  prog.p6 [&lt;name&gt;] [&lt;last-name&gt;] 
</code></pre><h2 id="组合命名参数和位置参数">组合命名参数和位置参数</h2>
<p>定义不同的签名来处理不同的命令行参数(在我们的示例中是命名参数和位置参数)是可以的。但是，如果您想在 <code>MAIN</code> 签名中混合命名参数和位置参数呢? 这很容易做到，尽管位置参数必须在命名参数之前定义。</p>
<p>让我们通过添加位置参数到第一个 <code>multi</code> 子例程来更新我们的简单程序 <code>prog.p6</code> 到最新版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">MAIN</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="nv">$title</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Mr</span><span class="p">&#39;</span><span class="o">,</span>      <span class="c1"># Our positional parameter defined before named ones</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="o">:</span><span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span><span class="o">,</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="o">:</span><span class="nv">$last-name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Doe</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$formatted-name</span> <span class="o">=</span> <span class="p">&#34;</span><span class="nv">$title</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$last-name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$formatted-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">MAIN</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="nv">$title</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span><span class="o">,</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="nv">$last-name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Doe</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$formatted-name</span> <span class="o">=</span> <span class="p">&#34;</span><span class="nv">$title</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$last-name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$formatted-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="可选参数和必须参数">可选参数和必须参数</h1>
<p><strong>默认情况下，命名参数是可选的</strong>。尽管如此，可以通过使用 <code>!</code> 附加各自的词法变量来将它们标记为必须的。例如，<code>MAIN( :$first, :$second, :$operator ){ ... }</code>， 如果不带某些命令行参数调用 <code>MAIN( :$first!, :$second!, :$operator! ){ ... }</code> 则不会打印用法信息。考虑到参数现在是必须的了，调用者必须传递必须的参数才行。</p>
<p>另一方面，<strong>位置参数在默认情况下是必需的</strong>，但是可以通过使用 <code>?</code> 附加相应的词法变量来将它标记为可选的。例如，<code>MAIN( $first, $second, $operator ){ ... }</code>， 如果在没有命令行参数的情况下调用 <code>MAIN( $first?, $second?, $operator? ){ ... }</code> 则不会打印用法信息，因为参数现在是可选的。</p>
<p>位置参数也可以通过设置默认值来定义为可选的，比如在 <code>multi MAIN( $title, $name = 'John', $last-name = 'Doe' ) { ... }</code> 中使用的 <code>$name</code> 和 <code>$last-name</code>。</p>
<h1 id="别名或替换命名参数">别名或替换命名参数</h1>
<p>命名参数及其别名是通过使用冒号对语法(<code>:</code>)提供的。冒号的存在将决定我们是否创建一个新的命名参数。</p>
<p>让我们修改 <code>prog.p6</code> 中的第一个 <code>multi</code> 以包括一些别名:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">MAIN</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="nv">$title</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Mr</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="o">:</span><span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span><span class="o">,</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="p">:</span><span class="s">last-name</span><span class="p">(</span><span class="nv">$surname</span><span class="p">)</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Doe</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Bool</span> <span class="p">:</span><span class="s">p</span><span class="p">(</span><span class="o">:</span><span class="nv">$print</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$formatted-name</span> <span class="o">=</span> <span class="p">&#34;</span><span class="nv">$title</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$surname</span><span class="o">.</span><span class="nf">tc</span><span class="p">()&#34;;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$print</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$formatted-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span></code></pre></div><p><code>MAIN</code> 定义了两种别名：</p>
<ul>
<li><code>:last-name($surname)</code> 只将传递给命令行参数的内容别名 <code>-—last-name</code> 到变量 <code>$surname</code> (注意缺少 <code>:</code>)。这意味着 <code>$surname</code> 将只是别名变量的名字，而不创建新的命名参数:</li>
</ul>
<pre tabindex="0"><code>$ p6 prog.p6 --name=&#39;alan&#39; --last-name=&#39;turing&#39; -p
Alan Turing

$ p6 prog.p6 --name=&#39;alan&#39; --surname=&#39;turing&#39;
Usage:
  pos-named.p6 [--name=&lt;Str&gt;] [--last-name=&lt;Str&gt;] [-p|--print] [&lt;title&gt;]
</code></pre><ul>
<li><code>:$print</code> 不仅是别名变量的名称，而且是一个新的命名参数，旁边还有 <code>:p</code>:</li>
</ul>
<pre tabindex="0"><code>$ p6 prog.p6 --name=&#39;alan&#39; --last-name=&#39;turing&#39;

$ p6 prog.p6 --name=&#39;alan&#39; --last-name=&#39;turing&#39; -p
Alan Turing

$ p6 prog.p6 --name=&#39;alan&#39; --last-name=&#39;turing&#39; -print
Alan Turing
</code></pre><p>正如您可能已经注意到的，如果要打印此人的格式化全名，现在必须指定标记 <code>-p</code> (或 <code>-print</code>)。这是因为 <code>Bool</code> 类型使 <code>$print</code> 成为一个二进制标记，如果不存在，则为 <code>False</code>。如果调用，则标志为 <code>True</code>，使执行简单的 <code>if $print { ... }</code> 语句变得可能。</p>
<p>使用别名是为参数创建长形式和短形式选项名的一种简单方法。我们可以进一步修改 <code>prog.p6</code> 中的第一个 <code>multi</code>，以便为 <code>-—name</code> 和 <code>-—last-name</code> 提供一个简短的形式选项名:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">MAIN</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="nv">$title</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Mr</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="p">:</span><span class="s">n</span><span class="p">(</span><span class="o">:</span><span class="nv">$name</span><span class="p">)</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span><span class="o">,</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="p">:</span><span class="s">l</span><span class="p">(:</span><span class="s">last-name</span><span class="p">(</span><span class="nv">$surname</span><span class="p">))</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Doe</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Bool</span> <span class="p">:</span><span class="s">p</span><span class="p">(</span><span class="o">:</span><span class="nv">$print</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$formatted-name</span> <span class="o">=</span> <span class="p">&#34;</span><span class="nv">$title</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$surname</span><span class="o">.</span><span class="nf">tc</span><span class="p">()&#34;;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$print</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$formatted-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span></code></pre></div><p>通过执行带有不同形式选项的 <code>prog.p6</code>，我们得到:</p>
<pre tabindex="0"><code>p6 prog.p6 --name=&#39;alan&#39; --last-name=&#39;turing&#39; -print
Mr. Alan Turing

p6 prog.p6 -n=&#39;grace&#39; -l=&#39;hopper&#39; -p &#39;Ms&#39;
Ms. Grace Hopper
</code></pre><p>如果没有匹配的签名，我们就会得到使用信息:</p>
<pre tabindex="0"><code>p6 prog.p6 -n=&#39;alan&#39; -l=&#39;turing&#39; -p --career=&#39;mathematician&#39;
Usage:
  prog.p6 [-n|--name=&lt;Str&gt;] [-l|--last-name=&lt;Str&gt;] [-p|--print] [&lt;title&gt;] 
  prog.p6 [&lt;title&gt;] [&lt;name&gt;] [&lt;last-name&gt;]
</code></pre><h1 id="sub-usage">Sub USAGE</h1>
<p>没有匹配的签名，这是我们小程序 <code>prog.p6</code> 的最新版本会打印以下使用信息:</p>
<pre tabindex="0"><code>Usage:
  prog.p6 [-n|--name=&lt;Str&gt;] [-l|--last-name=&lt;Str&gt;] [-p|--print] [&lt;title&gt;] 
  prog.p6 &lt;title&gt; [&lt;name&gt;] [&lt;last-name&gt;] 
</code></pre><p>这是由于，在没有向 <code>MAIN</code> 子例程提供匹配的签名时，将自动调用 <code>USAGE</code> 子例程。如果没有找到这样的子例程，编译器将输出一个默认生成的使用消息，这意味着我们可以定义它以提供更详细的(如果我们想要的话!)使用消息。</p>
<p>这是带有修改过的 <code>USAGE</code> sub 的 <code>prog.p6</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">MAIN</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="nv">$title</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Mr</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="p">:</span><span class="s">n</span><span class="p">(</span><span class="o">:</span><span class="nv">$name</span><span class="p">)</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span><span class="o">,</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="p">:</span><span class="s">l</span><span class="p">(:</span><span class="s">last-name</span><span class="p">(</span><span class="nv">$surname</span><span class="p">))</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Doe</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Bool</span> <span class="p">:</span><span class="s">p</span><span class="p">(</span><span class="o">:</span><span class="nv">$print</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$formatted-name</span> <span class="o">=</span> <span class="p">&#34;</span><span class="nv">$title</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$surname</span><span class="o">.</span><span class="nf">tc</span><span class="p">()&#34;;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$print</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$formatted-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">MAIN</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="nv">$title</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Mr</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span><span class="o">,</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">Str</span> <span class="nv">$last-name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Doe</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$formatted-name</span> <span class="o">=</span> <span class="p">&#34;</span><span class="nv">$title</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()</span><span class="s2"> </span><span class="nv">$last-name</span><span class="o">.</span><span class="nf">tc</span><span class="p">()&#34;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$formatted-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">USAGE</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span> <span class="k">Q</span><span class="sa">:c:to</span><span class="p">/END/;</span><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">Usage:
</span></span></span><span class="line"><span class="cl"><span class="s">  </span><span class="p">{</span><span class="vg">$*PROGRAM-NAME</span><span class="p">}</span><span class="s"> [-n|--name=&lt;Str&gt;] [-l|--last-name=&lt;Str&gt;] [-p|--print] [&lt;title&gt;] 
</span></span></span><span class="line"><span class="cl"><span class="s">  </span><span class="p">{</span><span class="vg">$*PROGRAM-NAME</span><span class="p">}</span><span class="s"> [&lt;title&gt;] [&lt;name&gt;] [&lt;last-name&gt;] 
</span></span></span><span class="line"><span class="cl"><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">optional arguments:
</span></span></span><span class="line"><span class="cl"><span class="s">  -h, --help                     show this help message and exit
</span></span></span><span class="line"><span class="cl"><span class="s">  -n=PERSON_NAME, --name=PERSON_NAME
</span></span></span><span class="line"><span class="cl"><span class="s">                                 specify person&#39;s name
</span></span></span><span class="line"><span class="cl"><span class="s">  -l=PERSON_LAST_NAME, --last-name=PERSON_LAST_NAME
</span></span></span><span class="line"><span class="cl"><span class="s">                                 specify person&#39;s last name
</span></span></span><span class="line"><span class="cl"><span class="s">  -p , --print                   print person&#39;s full name
</span></span></span><span class="line"><span class="cl"><span class="s">  &lt;title&gt;                        specify person&#39;s title (&#39;Mr&#39; by default)
</span></span></span><span class="line"><span class="cl"><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">  Examples:
</span></span></span><span class="line"><span class="cl"><span class="s">    </span><span class="p">{</span><span class="vg">$*PROGRAM-NAME</span><span class="p">}</span><span class="s"> --name=&#39;richard&#39; --last-name=&#39;feynman&#39; -p
</span></span></span><span class="line"><span class="cl"><span class="s">    </span><span class="p">{</span><span class="vg">$*PROGRAM-NAME</span><span class="p">}</span><span class="s"> --name=&#39;sophie&#39; --last-name=&#39;germain&#39; -p &#39;Ms&#39;
</span></span></span><span class="line"><span class="cl"><span class="s">    </span><span class="p">{</span><span class="vg">$*PROGRAM-NAME</span><span class="p">}</span><span class="s"> &#39;leonhard&#39; &#39;euler&#39;
</span></span></span><span class="line"><span class="cl"><span class="s"></span><span class="p">END</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意，用法消息中提到了 <code>-h</code>(和 <code>--help</code>)标志，我们不需要显式地定义它们，因为它们是自动生成的。如果我们现在执行带有 <code>--help</code>(或<code>-h</code>)标志的 <code>prog.p6</code>，或不提供匹配签名，我们得到新的使用信息:</p>
<pre tabindex="0"><code>Usage:
  prog.p6 [-n|--name=&lt;Str&gt;] [-l|--last-name=&lt;Str&gt;] [-p|--print] [&lt;title&gt;] 
  prog.p6 [&lt;title&gt;] [&lt;name&gt;] [&lt;last-name&gt;] 

optional arguments:
  -h, --help                     show this help message and exit
  -n=PERSON_NAME, --name=PERSON_NAME
                                 specify person&#39;s name
  -l=PERSON_LAST_NAME, --last-name=PERSON_LAST_NAME
                                 specify person&#39;s last name
  -p , --print                   print person&#39;s full name
  &lt;title&gt;                        specify person&#39;s title (&#39;Mr&#39; by default)

  Examples:
   prog.p6 --name=&#39;richard&#39; --last-name=&#39;feynman&#39; -p
   prog.p6 --name=&#39;sophie&#39; --last-name=&#39;germain&#39; -p &#39;Ms&#39;
   prog.p6 &#39;leonhard&#39; &#39;euler&#39;
</code></pre><h1 id="结论">结论</h1>
<p>这当然只是对 <code>MAIN</code> 和 <code>USAGE</code> 子例程的简单介绍。就像在 Raku 中一样，总有比看起来更多的东西。例如，如果希望将命名参数放在命令行中的任何位置(甚至在位置参数之后)，可以修改 hash <code>%*SUB-MAIN-OPTS</code> 以允许这种行为。如果你想了解更多细节，我在下面提供了一些有用的链接。</p>
<h2 id="另请参阅">另请参阅</h2>
<ul>
<li><a href="https://docs.raku.org/language/functions">More about subroutines, blocks, signatures, return values, MAIN sub, etc.</a></li>
<li><a href="https://rakuadvent.wordpress.com/2010/12/02/day-2-interacting-with-the-command-line-with-main-subs/">Interacting with the command line with MAIN subs</a></li>
<li><a href="http://www.jnthn.net/papers/2010-osdc.fr-signatures.pdf">Raku Signatures - Jonathan Worthington</a></li>
<li><a href="http://linuxtot.com/parsing-command-line-arguments-in-perl-6/">Parsing Command Line Arguments in Raku</a></li>
<li><a href="http://rakumaven.com/parsing-command-line-arguments-raku">Parsing command line arguments in Raku</a></li>
<li><a href="https://stackoverflow.com/a/29704107">How do I parse and validate command line arguments in Raku?</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Rmarkdown 中的 Raku 代码]]></title>
            <link href="http://localhost:1313/rakulang/2018-10-04-perl-6-code-in-rmarkdown/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/rakulang/2018-10-03-a-naive-introduction-to-object-orientation-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 面向对象简单入门" />
                <link href="http://localhost:1313/notes/%E4%BD%BF%E7%94%A8-spark-%E8%AF%BB%E5%86%99-hbase-%E6%95%B0%E6%8D%AE/?utm_source=atom_feed" rel="related" type="text/html" title="Use Spark to read and write HBase data" />
                <link href="http://localhost:1313/notes/%E5%83%8F%E6%88%91%E8%BF%99%E6%A0%B7%E7%9A%84-jar-%E5%8C%85/?utm_source=atom_feed" rel="related" type="text/html" title="添加第三方 pom 仓库" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%B8%89%E6%96%B9-python-%E5%BA%93/?utm_source=atom_feed" rel="related" type="text/html" title="Python 第三方库" />
                <link href="http://localhost:1313/notes/%E7%88%AC%E5%8F%96%E9%A5%AD%E5%90%A6%E4%B8%8A%E7%9A%84%E5%B8%96%E5%AD%90/?utm_source=atom_feed" rel="related" type="text/html" title="一步一步学习小爬虫" />
            
                <id>http://localhost:1313/rakulang/2018-10-04-perl-6-code-in-rmarkdown/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-03T21:32:27+08:00</published>
            <updated>2018-10-03T21:32:27+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="安装">安装</h1>
<p>首先，首先安装 <code>R</code> 编程语言。在此之后，运行 <code>R</code> 并执行以下命令来安装 <code>rmarkdown</code>: <code>install.packages(&quot;rmarkdown&quot;)</code>。在安装 rmarkdown 时，我收到以下错误消息:</p>
<pre tabindex="0"><code>Error: .onLoad failed in loadNamespace() for &#39;tcltk&#39;, details:
  call: dyn.load(file, DLLpath = DLLpath, ...)
  error: unable to load shared object &#39;/usr/lib/R/library/tcltk/libs/tcltk.so&#39;:
  libtk8.6.so: cannot open shared object file: No such file or directory
</code></pre><p>这可以通过安装包 <code>tk</code> 来解决，然后继续安装 rmarkdown。</p>
<h1 id="rmarkdown-的代码块">Rmarkdown 的代码块</h1>
<p>你可以用 rmarkdown 做的几乎所有都可以用“常规” markdown 来做的事情。然而，rmarkdown 的一个突出特性是它能够执行代码块并返回结果。为此，rmarkdown 使用了 <a href="https://yihui.name/knitr/">knitr</a> 包，这是一个使用 R 生成动态报告的引擎，除了 R 之外，它还支持其他语言引擎，您可以使用这些引擎来计算来自其他语言的代码。要列出可用引擎的名称，请在 R REPL 中执行 <code>names(knitr::knit_engines$get())</code> 命令。就像“常规” markdown 一样，代码块可以用三个反勾号创建，然后是代码，最后是另外三个反勾号。如果希望计算代码块，请在花括号 <code>{}</code> 中指定语言，该语言位于前三个反勾号之后。例如，要执行 Perl 5 代码，可以在 <code>{}</code> 中指定 <code>perl</code>:</p>
<pre><code>```{perl}
sub factorial {
    my ($n) = @_;
    return 1 if $n == 0;
    return factorial($n - 1) * $n;
}

for (1..4) {
    print &quot;Factorial of $_: &quot;, factorial($_), &quot;\n&quot;;
} 
```
</code></pre>
<p>如果任何表达式求值了，将按照如下方式处理，结果将显示在源代码下面:</p>
<pre><code>sub factorial {
    my ($n) = @_;
    return 1 if $n == 0;
    return factorial($n - 1) * $n;
}

for (1..4) {
    print &quot;Factorial of $_: &quot;, factorial($_), &quot;\n&quot;;
} 
## Factorial of 1: 1
## Factorial of 2: 2
## Factorial of 3: 6
## Factorial of 4: 24
</code></pre>
<p>代码块的选项可以在花括号中指定。例如，为了防止对代码块的计算，您必须将 <code>eval</code> 设置为 <code>FALSE</code>:</p>
<pre><code>```{perl, eval=FALSE}
my $name = 'Nemy';
print &quot;Hello, $name!\n&quot;;
```
</code></pre>
<p>这阻止了代码块的求值，只显示源代码:</p>
<pre><code>my $name = 'Nemy';
print &quot;Hello, $name!\n&quot;;
</code></pre>
<p>要隐藏源代码并且仍然显示它的求值，可以将 <code>echo</code> 设置为 <code>FALSE</code>:</p>
<pre><code>```{perl, echo=FALSE}
my $name = 'Nemy';
print &quot;Hello, $name!\n&quot;;
```
</code></pre>
<p>只有结果被展示出来：</p>
<pre tabindex="0"><code>## Hello, Nemy!
</code></pre><p>在花括号中可以指定一些选项。下面是我常用的一些选项的小列表:</p>
<ul>
<li><strong>engine</strong>-默认为<code>R</code>。<code>knitr</code> 将用命名语言计算这个块，例如 <code>engine = 'python'</code>。</li>
<li><strong>eval</strong>-默认情况下为 <code>TRUE</code>。如果为 <code>FALSE</code>, knitr 将不会在代码块中运行代码。</li>
<li><strong>echo</strong>-默认情况下为 <code>TRUE</code>。如果为 <code>FALSE</code>, knitr 将不会在最终文档中显示其结果上面的代码块中的代码。</li>
<li><strong>collapse</strong>-默认为 <code>FALSE</code>。如果为 <code>TRUE</code>，knitr 将把该块创建的所有源代码块和输出块折叠成单个块。</li>
<li><strong>comment</strong>-默认情况下是 <code>##</code>。knitr 将在最终文档的每行结果的开头添加的一个字符串，例如 <code>comment = '#=&gt;'</code>。</li>
</ul>
<p>在这里可以找到关于<a href="https://yihui.name/knitr/options/">不同选项</a>的更多信息。</p>
<h1 id="rmarkdown-中的-raku">Rmarkdown 中的 Raku</h1>
<p>到目前为止，knitr 不支持 Raku 的语言引擎。但是，您可以使用 knitr 的引擎语言可扩展性来执行 rmarkdown 中的 Raku 代码块，方法是在您的文件中添加以下 R 代码块:</p>
<pre><code>```{r setup}
library(knitr)
eng_raku &lt;- function(options) {
  # create a temporary file
  f &lt;- basename(tempfile(&quot;raku&quot;, '.', paste('.', &quot;raku&quot;, sep = '')))
  on.exit(unlink(f)) # cleanup temp file on function exit
  writeLines(options$code, f)
  out &lt;- ''

  # if eval != FALSE compile/run the code, preserving output
  if (options$eval) {
    out &lt;- system(sprintf('raku %s', paste(f, options$engine.opts)), intern=TRUE)
  }

  # spit back stuff to the user
  engine_output(options, options$code, out)
}

knitr::knit_engines$set(raku=eng_raku)
```
</code></pre>
<p>这个变通方法是从<a href="https://stackoverflow.com/questions/45857934/executing-perl-6-code-in-rmarkdown/45864801#45864801">这里</a>和<a href="https://www.r-bloggers.com/running-go-language-chunks-in-r-markdown-rmd-files/">这里</a> 得到的。</p>
<p>这将允许你这样做:</p>
<pre><code>```{r, engine='raku'}
say [*] 1..5;
```
</code></pre>
<p>但是，您可以使用 Perl 5 的引擎语言并通过将 <code>engine.path</code> 设置为 <code>raku</code> 使其路径更改为 Raku 可执行文件的路径，而不是在每个正在处理 Raku 代码的文件中添加这段 R 代码。然后，您可以通过如下方式处理 Raku 代码:</p>
<pre><code>```{perl, engine.path='raku'}
say [*] 1..5;
```
</code></pre>
<p>现在您应该能够计算 Raku 代码块:</p>
<pre><code>```{perl, engine.path='raku', comment='#=&gt;', collapse=TRUE}
class Point {
    has $.x = 0;
    has $.y = 0;
    method distance-to-center() {
        return sqrt($!x**2 + $!y**2);
    }
}

my $p = Point.new(x =&gt; 3, y =&gt; 4);
say $p.distance-to-center();
```
</code></pre>
<p>会被处理成如下这样：</p>
<pre><code>class Point {
    has $.x = 0;
    has $.y = 0;
    method distance-to-center() {
        return sqrt($!x**2 + $!y**2);
    }
}

my $p = Point.new(x =&gt; 3, y =&gt; 4);
say $p.distance-to-center();

#=&gt; 5
</code></pre>
<h1 id="补遗">补遗</h1>
<p>这篇文章是受我的启发，我希望有一个简单的设置，转录课堂笔记使用 <code>vim</code>。注释可能闪烁着 <code>LATEX</code>，一些代码片段，并转换为 <code>.pdf</code> 文件，以便在此过程中进行审阅。rmarkdown 的易用性和广泛的功能使其成为这项工作的合适工具。</p>
<p>要从 vim 直接将 <code>.rmd</code> 转换为 <code>.pdf</code> 文件，我的 <code>.vimrc</code> 中有以下一行映射到 F5，以简化过程:</p>
<pre tabindex="0"><code>autocmd Filetype rmd map &lt;F5&gt; :!echo&lt;space&gt;&#34;require(rmarkdown);
&lt;space&gt;render(&#39;&lt;c-r&gt;%&#39;)&#34;&lt;space&gt;\|&lt;space&gt;R&lt;space&gt;--vanilla&lt;enter&gt;
</code></pre><p>如您所见，这只是在 R 中加载 rmarkdown 包，将当前 .rmd 文件传递给函数 <code>render</code>，并将其结果传递给 <code>R --vanilla</code> 以使程序非交互式。</p>
<p>注意，您可能需要安装 <code>pandoc</code> 才能正常工作。对于 pandoc latex 模板，我使用了 <a href="https://github.com/Wandmalfarbe/pandoc-latex-template">eisvogel.latex</a> 的一个稍微改进版本。</p>
<p>以下是所有注释的 YAML 前言(元数据)的示例:</p>
<pre><code>---
title: &quot;Raku in rmarkdown&quot;
author: &quot;Luis F. Uceta&quot;
date: Aug 13, 2018

output: 
    pdf_document:
        latex_engine: pdflatex
        toc: true
        template: eisvogel.latex

fontsize: 12pt
geometry: margin=1in 
linkcolor: red
urlcolor: blue
---
</code></pre>
<p>这是这个文件的 <code>pdf</code>，使用了之前的 <code>YAML</code> 前言和前面提到的 latex 模板。请注意，此 pdf 可能不反映对本文所做的最新更改。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 面向对象简单入门]]></title>
            <link href="http://localhost:1313/rakulang/2018-10-03-a-naive-introduction-to-object-orientation-in-perl-6/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/%E4%BD%BF%E7%94%A8-spark-%E8%AF%BB%E5%86%99-hbase-%E6%95%B0%E6%8D%AE/?utm_source=atom_feed" rel="related" type="text/html" title="Use Spark to read and write HBase data" />
                <link href="http://localhost:1313/notes/%E5%83%8F%E6%88%91%E8%BF%99%E6%A0%B7%E7%9A%84-jar-%E5%8C%85/?utm_source=atom_feed" rel="related" type="text/html" title="添加第三方 pom 仓库" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%B8%89%E6%96%B9-python-%E5%BA%93/?utm_source=atom_feed" rel="related" type="text/html" title="Python 第三方库" />
                <link href="http://localhost:1313/notes/%E7%88%AC%E5%8F%96%E9%A5%AD%E5%90%A6%E4%B8%8A%E7%9A%84%E5%B8%96%E5%AD%90/?utm_source=atom_feed" rel="related" type="text/html" title="一步一步学习小爬虫" />
                <link href="http://localhost:1313/notes/%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7%E7%9A%84%E5%B8%96%E5%AD%90/?utm_source=atom_feed" rel="related" type="text/html" title="爬取百度贴吧尝试" />
            
                <id>http://localhost:1313/rakulang/2018-10-03-a-naive-introduction-to-object-orientation-in-perl-6/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-03T21:13:31+08:00</published>
            <updated>2018-10-03T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="序言">序言</h1>
<h2 id="介绍">介绍</h2>
<p>本教程最多只关注 Raku 中的面向对象编程(OOP)的基本知识。因此，对语句/表达式、变量、条件、循环、子例程(函数)等有一个基本的了解是很重要的，如果不在 Raku 中，至少在另一种编程语言中是这样的。此外，您至少应该对类、属性和方法有一般的了解。作为对 Raku 的介绍，我强烈推荐 <a href="https://rakuintro.com/">Raku introduction</a>。下一步是 Raku 文档。</p>
<p>确保你已经设置好了 Raku 编译器。如果你还没有设置好，请看<a href="https://raku.org/getting-started/">这里</a>。
从这里开始，你可能会厌倦代词“我们”，但它的使用是经过深思熟虑的。这是一个教程，希望你能跟上。所以，是的，我们在一起工作，你应该做好准备。顺便说一下，本教程是冗长的，这是故意的，但也是手把手教程的副产品。</p>
<h2 id="问题陈述">问题陈述</h2>
<p>我们将从现实生活中的问题开始，并尝试以面向对象的方式对其进行建模。问题陈述如下:
在她的数学101课程中，一位教授记录了三个作业(2个作业和1个考试)的分数，按照学生交作业的顺序:</p>
<pre><code>Bill Jones:1:35
Sara Tims:2:45
Sara Tims:1:39
Bill Jones:1:42
Bill Jones:E1:72
</code></pre>
<p>在一个名为 MATH-101 的简单文本文件中。您可以假设有更多的学生，而这只是数据文件的一个代表性块。在这个文件中，每行记录学生的姓名、作业编号(作业编号为1,2，第一次考试为E1)和学生获得的原始分数。
教授使用另一个扩展名为 .std 的文件存储她课程的学生名单:</p>
<pre><code>Bill Jones
Ana Smith
Sara Tims
Frank Horza
</code></pre>
<p>除了 MATH-101，这位教授还教其他课程，并设计了一个扩展名为 .cfg 的配置文件来存储给定课程的配置格式。她这样做的目的是在她的其他课程中也使用它。配置文件格式指定了作业的类型、作业编号、作业的总分以及作业对最终课程成绩的贡献。她的数学101课程的 .cfg 文件如下:</p>
<pre><code>Homework:1:50:25
Homework:2:50:25
Exam:1:75:50
</code></pre>
<p>您的任务是创建一个名为 report.p6 的程序。该程序生成一个报告，其中列出了班级中每个学生的姓名、每次作业的分数和最终成绩。该程序应该假设具有扩展名 .cgf 和 .std 的文件在执行该程序的目录中可用。另一方面，包含学生成绩的文件必须通过命令行传递给程序。为了简单起见，您可以假设每个文件都是根据课程命名的。对于她的数学101课程，教授会有以下的文件: MATH-101, MATH-101.std 和 MATH-101.cfg，还有脚本 report.p6。</p>
<h2 id="分析">分析</h2>
<p>如果我们看问题陈述，我们可以把所有的东西分成三类:课程，学生和作业。就目前而言，每个类别都可以被视为具有状态和行为的类。我们将从最简单的类别，作业类别，到最一般的类别，课程类别。为了做到这一点，我们首先学习 Raku 中类的定义。</p>
<h1 id="raku-类">Raku 类</h1>
<h2 id="类定义">类定义</h2>
<p>在 Raku 中，类是用 class 关键字定义的，通常后面跟着类名（通常以首字母大写形式）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Name-of-class</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="属性定义">属性定义</h2>
<p>所有的 Raku 属性默认都是私有的，这意味着它们只能在类中访问。属性是使用 <code>has</code> 关键字和 <code>!</code> twigil 定义的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Name-of-class</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!attribute-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>属性也可以使用 <code>.</code> twigil。这个 twigil 声明，应该生成一个以属性命名的只读访问器方法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Name-of-class</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.attribute-name</span><span class="p">;</span> <span class="c1"># $!attribute-name + attribute-name()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这等价于:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Name-of-class</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!attribute-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">attribute-name</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">$!attribute-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>生成的访问器方法是只读的，因为属性默认是只读的(从类的外部)。为了允许通过访问器方法修改属性，必须向属性添加 <code>is rw</code> 特质。其他特质也可以用于属性。有关特质的更多信息，请参阅文档。</p>
<h1 id="作业类">作业类</h1>
<p>让我们从详细描述 <code>Assignment</code> 类所需的属性开始:</p>
<ul>
<li><code>type</code>——作业的类型(作业或考试)。</li>
<li><code>number</code>——作业编号(1,2等)。</li>
<li><code>score</code>——这个作业的分数。</li>
<li><code>raw</code>——给定作业的最大点数。</li>
<li><code>contrib</code>——作业对最终成绩的贡献。</li>
<li><code>adjusted-score</code>——基于 <code>score</code>，<code>raw</code> 和 <code>contrib</code> 属性的格式化的分数。</li>
<li><code>config</code>——一个包含课程配置文件的散列。</li>
</ul>
<p>关于 <code>config</code> 哈希，每个赋值的信息将存储在一个数组中，这个数组将根据每个赋值(作业或考试)在数组中的赋值号进行索引。由于没有零赋值，这个槽将用于存储已处理的赋值总数。MATH-101.cfg 的 <code>config</code> 散列是这样的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">%</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">Homework</span> <span class="o">=&gt;</span> <span class="o">[</span> <span class="p">{</span><span class="s">total</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">}</span><span class="o">,</span> <span class="p">(</span><span class="mi">50</span><span class="o">,</span> <span class="mi">25</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="mi">50</span><span class="o">,</span> <span class="mi">25</span><span class="p">)</span> <span class="o">],</span>
</span></span><span class="line"><span class="cl">    <span class="s">Exam</span> <span class="o">=&gt;</span> <span class="o">[</span> <span class="p">{</span><span class="s">total</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">}</span><span class="o">,</span> <span class="p">(</span><span class="mi">75</span><span class="o">,</span> <span class="mi">50</span><span class="p">)</span> <span class="o">],</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>这导致了下面的类:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Assignment</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># attributes with a read-only accessor</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">%.config</span><span class="p">;</span>   <span class="c1"># given that a hash is used, the $ (scalar) is replaced</span>
</span></span><span class="line"><span class="cl">                    <span class="c1"># with a % (hash).</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># private attributes hence the ! twigil.</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!raw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!contrib</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!adjusted-score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>为了创建 <code>Assignment</code> 类的实例并初始化它，我们将命名参数传递给 Raku 提供的默认的 <code>new</code> 构造函数方法，并由所有类继承:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># create a new instance object and initialize its attributes. </span>
</span></span><span class="line"><span class="cl"><span class="c1"># The new constructor is called on Assignment, the type object of </span>
</span></span><span class="line"><span class="cl"><span class="c1"># the class Assignment.</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$assign01</span> <span class="o">=</span> <span class="n">Assignment</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">type</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Homework</span><span class="p">&#39;</span><span class="o">,</span> <span class="c1"># named argument </span>
</span></span><span class="line"><span class="cl">    <span class="p">:</span><span class="s">number</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">,</span>         <span class="c1"># Alternate colon-pair syntax for named arguments</span>
</span></span><span class="line"><span class="cl">    <span class="p">:</span><span class="s">score</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">:</span><span class="s">config</span><span class="p">(</span><span class="nv">%</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="s">Homework</span> <span class="o">=&gt;</span> <span class="o">[</span> <span class="p">{</span><span class="s">total</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">}</span><span class="o">,</span> <span class="p">(</span><span class="mi">50</span><span class="o">,</span> <span class="mi">25</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="mi">50</span><span class="o">,</span> <span class="mi">25</span><span class="p">)</span> <span class="o">],</span>
</span></span><span class="line"><span class="cl">        <span class="s">Exam</span> <span class="o">=&gt;</span> <span class="o">[</span> <span class="p">{</span><span class="s">total</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">}</span><span class="o">,</span> <span class="p">(</span><span class="mi">75</span><span class="o">,</span> <span class="mi">50</span><span class="p">)</span> <span class="o">]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># accessing the instance object&#39;s attributes </span>
</span></span><span class="line"><span class="cl"><span class="c1"># through their accessor method:</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$assign01</span><span class="o">.</span><span class="nb">type</span><span class="p">();</span>     <span class="c1"># OUTPUT: &#39;Homework&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$assign01</span><span class="o">.</span><span class="nf">number</span><span class="p">();</span>   <span class="c1"># OUTPUT: 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$assign01</span><span class="o">.</span><span class="nf">score</span><span class="p">();</span>    <span class="c1"># OUTPUT: 45</span>
</span></span></code></pre></div><blockquote>
<p><strong>注意</strong>: 如果属性是用 <code>!</code> twigil 定义的，那么不能使用 <code>new</code> 构造函数方法来初始化它。正如前面提到的，这是由于属性是私有的，这意味着它不能从类外部访问，甚至不能通过<code>new</code> 构造函数访问。但是，这个默认行为可以用 <code>BUILD</code> 子方法重写。有关 <code>BUILD</code> 子方法的更多信息，请参阅<a href="https://docs.raku.org/language/objects#Object_Construction">文档</a>。</p>
</blockquote>
<p>我们已经知道赋值的类型总是字符串，数字总是整数，调整后的分数是 rational 等等，所以我们也可以相应地键入属性:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Assignment</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Str</span> <span class="nv">$.type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Int</span> <span class="nv">$.number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">%.config</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!raw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!contrib</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Rat</span> <span class="nv">$!adjusted-score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>有关类型的更多信息，请参阅<a href="https://docs.raku.org/language/typesystem">文档</a>。
<code>Assignment</code> 类的行为在很大程度上取决于每个学生的数据，但我们对 <code>Student</code> 类的结构还一无所知。出于这个原因，我们将继续学习 <code>Student</code> 类，稍后再回到这个话题。</p>
<h1 id="student-类">Student 类</h1>
<p>与 <code>Assignment</code> 类类似，让我们从详细描述 <code>Assignment</code> 类将具有的属性开始:</p>
<ul>
<li><code>name</code>——表示学生名字的字符串。</li>
<li><code>assign-num</code>——作业的数量(一个整数)。</li>
<li><code>assignments</code>——我们希望将作业分成不同的类型(作业或考试)，所以我们将使用哈希。每个键将指向它们各自的赋值对象的数组。</li>
<li><code>config</code>——在 <code>Assignment</code> 类中描述的课程的配置文件。</li>
</ul>
<p>这导致了下面的类:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Student</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Str</span> <span class="nv">$.name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Int</span> <span class="nv">$!assign-num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">%!assignments</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">%.config</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们应该能够将作业附加到 <code>Student</code> 类的一个实例中，并从中获得作业、考试等等。这些行为表示类的行为，并通过使用方法来实现。</p>
<h2 id="公共和私有方法">公共和私有方法</h2>
<p>正如在 <a href="https://rakuintro.com/#_methods">Raku 介绍</a>中所述，“方法是对象的子例程，就像子例程一样，它们是打包一组功能的方法，它们接受参数，具有签名，可以定义为 <code>multi</code>。”</p>
<p>Raku 方法是使用 <code>method</code> 关键字定义的，它是在 invocant 上使用点(<code>.</code>)调用的。默认情况下，所有方法都是公共的。但是，方法可以通过在名称前面加上感叹号(<code>!</code>)来定义为私有的。在这种情况下，使用感叹号而不是点来调用它们。</p>
<p>有了这些知识，我们现在将向 <code>Student</code> 类添加一个 <code>add-assignment</code> 方法。这个方法需要作业的编号(1、2、3等，或者E1、E2等)和收到的分数。不会提供作业的类别，但我们可以使用编号来确定:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Student</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same attributes as before.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">add-assignment</span><span class="p">(</span> <span class="nv">$number</span> <span class="k">is</span> <span class="nb">copy</span><span class="o">,</span> <span class="nv">$score</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl">        <span class="c1"># determine the assignment type.</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nv">$number</span> <span class="o">~~</span> <span class="k">s</span><span class="p">/</span><span class="ni">^</span><span class="sr">E</span><span class="p">//</span> <span class="p">{</span>   <span class="c1"># do replacement in place</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$type</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Exam</span><span class="p">&#39;;</span>      <span class="c1"># to obtain the exam&#39;s number.</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$type</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Homework</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="c1"># coerce assignment number to an integer.</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$number</span> <span class="o">.=</span> <span class="kt">Int</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># create an Assignment object from available information.</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$assign-obj</span> <span class="o">=</span> <span class="n">Assignment</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s">type</span>   <span class="o">=&gt;</span> <span class="nv">$type</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">number</span> <span class="o">=&gt;</span> <span class="nv">$number</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">score</span>  <span class="o">=&gt;</span> <span class="nv">$score</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">config</span> <span class="o">=&gt;</span> <span class="nv">%!config</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="c1"># add assignment into its type indexed by its number.</span>
</span></span><span class="line"><span class="cl">        <span class="nv">%!assignments</span><span class="p">{</span><span class="nv">$type</span><span class="p">}</span><span class="o">[</span><span class="nv">$number</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$assign-obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="c1"># increment number of assignments by 1.</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!assign-num</span><span class="o">++</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>为了展示私有方法的创建，我们将在 <code>add-assignment</code> 方法中把创建 <code>Assignment</code> 对象外包给一个名为 <code>create-assignment</code> 的私有方法，该方法返回一个 <code>Assignment</code> 对象:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Student</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same as before</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># notice the ! twigil before the method&#39;s name.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">!create-assignment</span><span class="p">(</span> <span class="kt">Str</span> <span class="nv">$type</span><span class="o">,</span> <span class="kt">Int</span> <span class="nv">$number</span><span class="o">,</span> <span class="nv">$score</span> <span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Assignment</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s">type</span>   <span class="o">=&gt;</span> <span class="nv">$type</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">number</span> <span class="o">=&gt;</span> <span class="nv">$number</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">score</span>  <span class="o">=&gt;</span> <span class="nv">$score</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">config</span> <span class="o">=&gt;</span> <span class="nv">%!config</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">add-assignment</span><span class="p">(</span> <span class="nv">$number</span> <span class="k">is</span> <span class="nb">copy</span><span class="o">,</span> <span class="nv">$score</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># same code as before.</span>
</span></span><span class="line"><span class="cl">  		        
</span></span><span class="line"><span class="cl">        <span class="c1"># create an Assignment object with this information.</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$assign-obj</span> <span class="o">=</span> <span class="nb">self</span><span class="o">!</span><span class="nf">create-assignment</span><span class="p">(</span><span class="nv">$type</span><span class="o">,</span> <span class="nv">$number</span><span class="o">,</span> <span class="nv">$score</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># same code as before.</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>正如您可能已经注意到的，<code>self</code> 关键字用于调用 <code>add-assignment</code> 方法中的 <code>create-assignment</code> 方法。<code>self</code> 是绑定到 invocant 的特殊变量，在方法内部可用。此变量可用于调用程序上的进一步方法。其内部方法调用如下:</p>
<ul>
<li>
<p><code>self!method($arg)</code> 用于私有方法。</p>
</li>
<li>
<p><code>self.method($arg)</code> 用于公共方法。 <code>$.method($arg)</code> 是它的快捷形式。注意，方法参数(位置和命名)的冒号语法只支持在使用 <code>self</code> 时调用方法，而不支持快捷形式。所以:</p>
</li>
<li>
<p>self.method: arg1, arg2&hellip; is supported.</p>
</li>
<li>
<p>$.method: arg1, arg2&hellip; is not supported.</p>
</li>
</ul>
<p>方法的签名总是传递 <code>self</code> 作为它的第一个参数。但是，我们可以通过提供第一个参数和一个冒号来为方法指定一个显式调用者。此参数将充当方法的调用方，并允许方法引用显式调用的对象。
例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;;</span>    <span class="c1"># attributes can be set to default values.</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># here self refers to the object, albeit implicitly.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">introduce</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hi, my name&#39;s </span><span class="p">&#34;</span><span class="o">,</span> <span class="nb">self</span><span class="o">.</span><span class="nb">name</span><span class="p">()</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#                     ^^^^^^^^^^^ calling method on self</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># here $person explicitly refers to the object.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">alt-introduce</span><span class="p">(</span> <span class="nv">$person:</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hi, my name&#39;s </span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$person</span><span class="o">.</span><span class="nb">name</span><span class="p">()</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#                     ^^^^^^^^^^^^^^ calling method on $person</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">introduce</span><span class="p">();</span>      <span class="c1"># OUTPUT: Hi, my name&#39;s John!</span>
</span></span><span class="line"><span class="cl"><span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">alt-introduce</span><span class="p">();</span>  <span class="c1"># OUTPUT: Hi, my name&#39;s John!</span>
</span></span></code></pre></div><h2 id="tweak-子方法">TWEAK 子方法</h2>
<p>我们回到 <code>Assignment</code> 类。目前，类的使用者可以在创建 <code>Assignment</code> 对象时传递他们想要的任何东西。出于这个原因，我们可能想检查作业类型和作业编号是否已知。我们可能要做的另一件事是修改 <code>raw</code> 属性和 <code>contrib</code> 属性，它们的值依赖于来自配置文件的数据。同样的情况也适用于 <code> adjusted-score</code> 属性，其值取决于 <code>raw</code> 属性、<code>contrib</code> 属性和 <code>score</code> 属性。</p>
<p>Raku 提供了一种通过 <code>TWEAK</code> 子方法检查对象构造后的内容或修改属性的简单方法。简单地说，子方法是不被子类继承的方法。查看<a href="https://docs.raku.org/language/objects#Object_construction">文档</a>以获得关于 <code>TWEAK</code> 子方法的更多信息。
让我们在 <code>Assignment</code> 类中添加 <code>TWEAK</code> 子方法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Assignment</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same attributes as before.</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="c1"># use submethod keyword, instead of method.</span>
</span></span><span class="line"><span class="cl">    <span class="k">submethod</span> <span class="nb">TWEAK</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># assignment type is either &#39;Homework&#39; or &#39;Exam&#39;.</span>
</span></span><span class="line"><span class="cl">        <span class="k">unless</span> <span class="nv">$!type</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">Homework</span><span class="p">&#39;</span> <span class="o">|</span> <span class="p">&#39;</span><span class="s1">Exam</span><span class="p">&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">unknown assignment type: </span><span class="nv">$!type</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># check if provided assignment type is known.</span>
</span></span><span class="line"><span class="cl">        <span class="k">unless</span> <span class="nv">%!config</span><span class="p">{</span><span class="nv">$!type</span><span class="p">}</span><span class="o">[</span><span class="nv">$!number</span><span class="o">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">unrecognized </span><span class="nv">$!type</span><span class="s2"> number: </span><span class="nv">$!number</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># update raw and contrib value from configuration data.</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="nv">$!raw</span><span class="o">,</span> <span class="nv">$!contrib</span><span class="p">)</span> <span class="o">=</span> <span class="nv">%!config</span><span class="p">{</span><span class="nv">$!type</span><span class="p">}</span><span class="o">[</span><span class="nv">$!number</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># calculate the value of the adjusted score (rounded to two </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># decimal places).</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!adjusted-score</span> <span class="o">=</span> <span class="nb">sprintf</span> <span class="p">&#34;</span><span class="nv">%.2f</span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$!score</span> <span class="o">/</span> <span class="p">(</span><span class="nv">$!raw</span><span class="o">/</span><span class="nv">$!contrib</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># update type with assignment number. This will be useful </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># when printing the report for a specific assignment.</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!type</span> <span class="o">=</span> <span class="nv">$!type</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">Homework</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl">            <span class="o">??</span> <span class="p">&#34;</span><span class="s2">Homework </span><span class="nv">$!number</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="o">!!</span> <span class="p">&#34;</span><span class="s2">Exam </span><span class="nv">$!number</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="完成-assignment-和-student-类">完成 ASSIGNMENT 和 STUDENT 类</h2>
<h2 id="assignment-类">ASSIGNMENT 类</h2>
<p>我们想为特定的作业打印一个报告，因此我们将添加一个 <code>formatted-score</code> 方法，它将返回调整后的分数，并将一个 <code>print-report</code> 方法返回给 <code>Assignment</code> 类。<code>print-report</code> 方法应打印以下格式的作业报告:</p>
<pre tabindex="0"><code>type number: Raw = score/raw : Adjusted = adjusted-score/contrib-final
</code></pre><p>例子:</p>
<pre tabindex="0"><code>Homework 1: Raw = 42/50 : Adjusted = 8.40/10
Exam 1: Raw = 70/75 : Adjusted = 8.40/10
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Assignment</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">formatted-score</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">$!adjusted-score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">print-report</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span> <span class="p">&#34;</span><span class="nv">$!type:</span><span class="s2"> raw = </span><span class="nv">$!score</span><span class="s2">/</span><span class="nv">$!raw</span><span class="s2"> : </span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Adjusted = </span><span class="nv">$!adjusted-score</span><span class="s2">/contrib</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="student-类-1">STUDENT 类</h2>
<p>现在，我们将添加 <code>get-home-works</code> 和 <code>get-exams</code> 方法，这些方法将返回 <code>Assignment</code> 对象列表。我们还将为打印学生报告添加 <code>print-report</code> 方法。此方法应以下列格式打印学生报告:</p>
<pre tabindex="0"><code>student:
    type number: Raw = score/raw : Adjusted = adjusted-score/100 
    ...
    Final Course Grade: final-total/100
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Student</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    <span class="c1"># we use the grep() function to discard possibly empty </span>
</span></span><span class="line"><span class="cl">    <span class="c1"># elements in either array.</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">get-homeworks</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">%!assignments</span><span class="p">&lt;</span><span class="s">Homework</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">..*].</span><span class="nb">grep</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$_</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">get-exams</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">%!assignments</span><span class="p">&lt;</span><span class="s">Exam</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">..*].</span><span class="nb">grep</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$_</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">print-report</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$!name</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">: </span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># print message and return if student&#39;s doesn&#39;t have</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># neither assignment type</span>
</span></span><span class="line"><span class="cl">        <span class="k">unless</span> <span class="nb">self</span><span class="o">.</span><span class="nf">get-homeworks</span><span class="p">()</span> <span class="o">||</span> <span class="nb">self</span><span class="o">.</span><span class="nf">get-exams</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="p">&#34;</span><span class="se">\t</span><span class="s2">No records for this student.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="p">(</span><span class="nv">$final-total</span><span class="o">,</span> <span class="nv">$a_count</span><span class="o">,</span> <span class="nv">$e_count</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Loop over student&#39;s assignments (either Homework or Exam),</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># print assignment&#39;s report and update final total.</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nb">self</span><span class="o">.</span><span class="nf">get-homeworks</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$homework</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span> <span class="p">&#34;</span><span class="se">\t</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$homework</span><span class="o">.</span><span class="nf">print-report</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$final-total</span> <span class="o">+=</span> <span class="nv">$homework</span><span class="o">.</span><span class="nf">formatted-score</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$a_count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nb">self</span><span class="o">.</span><span class="nf">get-exams</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$exam</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span> <span class="p">&#34;</span><span class="se">\t</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$exam</span><span class="o">.</span><span class="nf">print-report</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$final-total</span> <span class="o">+=</span> <span class="nv">$exam</span><span class="o">.</span><span class="nf">formatted-score</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$e_count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># check if number of homeworks and exams in config file</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># matches student&#39;s record of returned homeworks and taken exams.</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nv">%!config</span><span class="p">&lt;</span><span class="s">Homework</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">&lt;</span><span class="s">total</span><span class="p">&gt;</span> <span class="o">==</span> <span class="nv">$a_count</span> <span class="ow">and</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%!config</span><span class="p">&lt;</span><span class="s">Exam</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">&lt;</span><span class="s">total</span><span class="p">&gt;</span>   <span class="o">==</span> <span class="nv">$e_count</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="p">&#34;</span><span class="se">\t</span><span class="s2">Final Course Grade: </span><span class="nv">$final-total</span><span class="s2">/100</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="p">&#34;</span><span class="se">\t</span><span class="s2">* Incomplete Record *</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># print newline after student&#39;s report.</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#34;&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="course-类">Course 类</h1>
<p><code>Course</code> 类有以下属性:</p>
<p><code>course</code>——表示课程名称的字符串。
<code>students</code>——学生和 <code>Students</code> 对象的哈希。
<code>number</code>——这个课程的学生人数。</p>
<p>这是带有其属性的类:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Course</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Str</span> <span class="nv">$.course</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Int</span> <span class="nv">$.number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">%!students</span> <span class="k">of</span> <span class="nc">Student</span><span class="p">;</span> <span class="c1"># specifying the type of the hash&#39;s values.</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>关于方法，我们需要以下几点:</p>
<ul>
<li><code>configure-course</code>——使用当前目录中的 <code>.cfg</code>(配置)和 <code>.std</code> (学生列表)文件来配置课程。</li>
<li><code>student</code>——接受一个学生的名字，并返回一个 <code>Student</code> 对象，前提是它存在。在该类的内部使用所以定义为私有的。</li>
<li><code>get-roster</code>——返回学生名字的排序列表。</li>
<li><code>add-student-record</code>——接受一个学生记录(例如，<code>Bill Jones:1:45</code>)，为那个学生查找 <code>Student</code> 对象并添加一个作业。</li>
<li><code>print-report</code>——打印整个类的报告。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Course</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">configure-course</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># read content of configuration file. We are to assume that </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># it has the same name as the course with &#39;.cfg&#39; extension.</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$course_file</span> <span class="o">=</span> <span class="nv">$!course</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">.cfg</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$course_data</span> <span class="o">=</span> <span class="nv">$course_file</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">slurp</span> <span class="o">||</span> 
</span></span><span class="line"><span class="cl">                          <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">cannot open </span><span class="nv">$course_file</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># extract the data from file and store it into the </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># configuration hash. The structure of the configuration</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># file was discussed in the &#39;The Assignment class&#39; section.</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">%cfg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nv">$course_data</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$datum</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">my</span> <span class="p">(</span><span class="nv">$type</span><span class="o">,</span> <span class="nv">@data</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$datum</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">:</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Example: type = &#39;Homework&#39;, data = (1, 50, 25)</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="nv">%cfg</span><span class="p">{</span><span class="nv">$type</span><span class="p">}</span><span class="o">[</span> <span class="nv">@data</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">]</span> <span class="o">=</span> <span class="nv">@data</span><span class="o">[</span><span class="mi">1</span><span class="o">..*]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%cfg</span><span class="p">{</span><span class="nv">$type</span><span class="p">}</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">&lt;</span><span class="s">total</span><span class="p">&gt;</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># read student list file which has the same name as the course.</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$stud_file</span> <span class="o">=</span> <span class="nv">$!course</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">.std</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$stud_data</span> <span class="o">=</span> <span class="nv">$stud_file</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">slurp</span> <span class="o">||</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">cannot open </span><span class="nv">$stud_file</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl">        <span class="c1"># Loop over the student list and create a Student object for </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># each student and populate the hash of students and Student objects.</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nv">$stud_data</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$student</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%!students</span><span class="p">{</span> <span class="nv">$student</span><span class="o">.</span><span class="nb">trim</span> <span class="p">}</span> <span class="o">=</span> <span class="n">Student</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">                <span class="s">name</span>   <span class="o">=&gt;</span> <span class="nv">$student</span><span class="o">.</span><span class="nb">trim</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="s">config</span> <span class="o">=&gt;</span> <span class="nv">%cfg</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$!number</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># return Student object if it exists.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">!student</span><span class="p">(</span> <span class="kt">Str</span> <span class="nv">$stud-name</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">%!students</span><span class="p">{</span><span class="nv">$stud-name</span><span class="p">}</span> <span class="o">||</span> <span class="kt">Nil</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># order student names by last name and return list.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">get-roster</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">%!students</span><span class="o">.</span><span class="nb">keys</span>                         <span class="c1"># student names list</span>
</span></span><span class="line"><span class="cl">            <span class="o">==&gt;</span> <span class="nb">map</span> <span class="p">({</span> <span class="p">(</span> <span class="nv">$_</span><span class="o">,</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">words</span> <span class="p">)</span><span class="o">.</span><span class="nb">flat</span> <span class="p">})</span> <span class="c1"># (full name, first, last)</span>
</span></span><span class="line"><span class="cl">            <span class="o">==&gt;</span> <span class="nb">sort</span> <span class="p">({</span> <span class="nv">$^a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="ow">cmp</span> <span class="nv">$^b</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="p">})</span>    <span class="c1"># sort list by last names</span>
</span></span><span class="line"><span class="cl">            <span class="o">==&gt;</span> <span class="nb">map</span> <span class="p">({</span> <span class="nv">$_</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="p">})</span>                 <span class="c1"># get name from sorted list</span>
</span></span><span class="line"><span class="cl">            <span class="o">==&gt;</span> <span class="k">my</span> <span class="nv">@list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">@list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># add record to Student object.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">add-student-record</span><span class="p">(</span> <span class="nv">@record</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="p">(</span><span class="nv">$name</span><span class="o">,</span> <span class="nv">@remaining</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@record</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="c1"># get Student object and add assignment to it.</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$student</span> <span class="o">=</span> <span class="nb">self</span><span class="o">.</span><span class="nf">student</span><span class="p">(</span><span class="nv">$name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="p">(</span><span class="nv">$num</span><span class="o">,</span> <span class="nv">$score</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@remaining</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$student</span><span class="o">.</span><span class="nf">add-assignment</span><span class="p">(</span><span class="nv">$num</span><span class="o">,</span> <span class="nv">$score</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># print report for all students in the course.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">print-report</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Class report: course = </span><span class="nv">$!course</span><span class="s2">, students = </span><span class="nv">$!number</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># loop over sorted students list and print each student&#39;s report.</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nb">self</span><span class="o">.</span><span class="nf">get-roster</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$name</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">self</span><span class="o">!</span><span class="nf">student</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span><span class="o">.</span><span class="nf">print-report</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="自定义构造函数">自定义构造函数</h2>
<p>我们希望使用反映所创建内容的构造函数方法，而不是使用 <code>new</code> 构造函数从特定的类创建对象。例如，<code>Course</code> 类的 <code>create-course</code> 构造函数。我们还希望使用位置参数，而不是在 <code>new</code> 构造函数中使用命名参数。在 Raku 中创建构造函数相当容易;只需要创建一个方法并返回 <em>blessed</em> 后的参数:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Course</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">create-course</span><span class="p">(</span> <span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s">course</span> <span class="o">=&gt;</span> <span class="nv">$course</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># In addition to:</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$class01</span> <span class="o">=</span> <span class="n">Course</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">course</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">GEO-102</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># We can also create a Course instance like this now:</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$class02</span> <span class="o">=</span> <span class="n">Course</span><span class="o">.</span><span class="nf">create-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">Math-101</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span></code></pre></div><p>我们不只是写 <code>return self.bless($course)</code>，因为 <code>bless</code> 方法需要一组命名参数来为每个属性提供初始值。正如前面提到的，私有属性实际上是私有的，因此对于用<code>!</code> twigil 定义的属性这还不够。为此，必须使用 <code>BUILD</code> 子方法，<code>bless</code> 方法调用这个全新的对象。有关 <code>BUILD</code> 子方法的更多信息，请参阅<a href="https://docs.raku.org/language/objects#Submethods">子方法</a>和<a href="https://docs.raku.org/language/classtut#Constructors">构造函数</a>。</p>
<h2 id="实例和类属性">实例和类属性</h2>
<p>我们已经讨论了实例属性，只是没有将它们标识为实例属性。<strong>实例属性</strong>是一个类的特定实例所拥有的属性，这意味着同一个类的两个不同的对象实例是不同的。例如，前几节中的实例 <code>$class01</code> 和 <code>$class02</code> 都具有相同的实例属性(<code>course</code>、<code>number</code> 等)，但是值不同。在 Raku 中，任何用关键字 <code>has</code> 声明的属性都是一个实例属性。</p>
<p>另一方面，<strong>类属性</strong>是属于类本身而不是它的对象的属性。与实例属性不同，类属性由类的所有实例共享。</p>
<p>在 Raku 中，类属性是使用关键字 <code>my</code> 或 <code>our</code>(而不是 <code>has</code>)来声明的，这取决于作用域(例如，<code>my $class-var;</code>)。与实例属性类似，用 <code>.</code> twigil 生成一个访问器方法(例如，<code>my $.class-var;</code>)的类属性。有关类属性的更多信息，请参阅<a href="https://docs.raku.org/language/classtut#Static_fields?">文档</a>。</p>
<p>我们还没有看到类属性，但是我们现在要创建一个。例如，我们想知道我们实例化的课程的数量。为此，我们可以在 <code>Course</code> 类中创建一个类属性，它跟踪实例化的 <code>Course</code> 对象的数量。</p>
<p>每当创建新对象时这个类属性必须更新，因此我们必须修改默认的 <code>new</code> 和 <code>create-course</code> 构造函数:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Course</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1"># other attributes.</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="kt">Int</span> <span class="nv">$.course-count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1"># class attribute with read-only accessor</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">create-course</span><span class="p">(</span> <span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$.course-count</span><span class="o">++</span><span class="p">;</span>      <span class="c1"># updating the class attribute.</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s">course</span> <span class="o">=&gt;</span> <span class="nv">$course</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># we still want to pass named parameters to the new </span>
</span></span><span class="line"><span class="cl">    <span class="c1"># hence the &#39;:&#39; before the parameter.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span> <span class="o">:</span><span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$.course-count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s">course</span> <span class="o">=&gt;</span> <span class="nv">$course</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Course</span><span class="o">.</span><span class="nf">create-course</span><span class="p">(&#39;</span><span class="s1">PHYS-110</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Course</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">course</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">BIO-112</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># accessing the class attribute&#39;s value by calling </span>
</span></span><span class="line"><span class="cl"><span class="c1"># its accessor method on the class itself.</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Course</span><span class="o">.</span><span class="nf">course-count</span><span class="p">();</span>  <span class="c1"># OUTPUT: 10</span>
</span></span></code></pre></div><h2 id="实例方法和类方法">实例方法和类方法</h2>
<p><strong>实例方法</strong>需要在其上调用对象实例。它通常以 <code>$object.instance-method()</code> 的形式表示。例如，<code>print-report()</code> 是 <code>Course</code> 类的一个实例方法，需要调用该类的一个实例(例如，<code>$class.print-report()</code>)。</p>
<p>另一方面，<strong>类方法</strong>作为一个整体属于类，因此它不需要类的实例。它通常用 <code>class.class-method()</code> 表示。例如，<code>new</code> 构造函数是直接在类上调用的类方法，而不是类的实例。</p>
<p>前面我们提到，显式调用者可以传递给方法。除了显式地引用对象外，方法签名中提供的调用者还允许通过使用类型约束将方法定义为实例方法或类方法。特殊变量 <code>::?CLASS</code> 可用于在编译时提供类名，并结合 <code>:U</code> (如 <code>::?CLASS:U</code>)用于类方法，或 <code>:D</code>(如 <code>::?CLASS:D</code>)用于实例方法。顺便说一下，在 Raku 行话中，<code>:U</code> 和 <code>:D</code> 被称为 <em>smileys</em>。</p>
<p><code>create-course</code> 方法打算仅作为类方法使用，但是，到目前为止，没有任何东西阻止它在实例中使用。为了避免这种情况，我们可以在 invocant 上使用带有 <code>:U</code> 类型修饰符的特殊变量 <code>?::CLASS</code>，这会导致方法主动拒绝对实例的调用，并且只允许通过type 对象进行调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Course</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># other attributes </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">create-course</span><span class="p">(</span> <span class="vg">::?CLASS:U</span><span class="o">:</span> <span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$.course-count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s">course</span> <span class="o">=&gt;</span> <span class="nv">$course</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span> <span class="vg">::?CLASS:U</span><span class="o">:</span> <span class="o">:</span><span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$.course-count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s">course</span> <span class="o">=&gt;</span> <span class="nv">$course</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Invocations on the Course class works as expected.</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$math</span> <span class="o">=</span> <span class="n">Course</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">MATH-302</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$phys</span> <span class="o">=</span> <span class="n">Course</span><span class="o">.</span><span class="nf">create-course</span><span class="p">(&#39;</span><span class="s1">LING-202</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Invocations on Course instances fail.</span>
</span></span><span class="line"><span class="cl"><span class="nv">$math</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">MATH-302</span><span class="p">&#39;);</span>   <span class="c1"># OUTPUT: Invocant of method &#39;new&#39; must be </span>
</span></span><span class="line"><span class="cl">                                 <span class="c1"># a type object of type &#39;Course&#39;, not an </span>
</span></span><span class="line"><span class="cl">                                 <span class="c1"># object instance of type &#39;Course&#39;.  Did you</span>
</span></span><span class="line"><span class="cl">                                 <span class="c1"># forget a &#39;multi&#39;?</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$phys</span><span class="o">.</span><span class="nf">create-course</span><span class="p">(&#39;</span><span class="s1">LING-202</span><span class="p">&#39;);</span> <span class="c1"># OUTPUT: Type check failed in binding to </span>
</span></span><span class="line"><span class="cl">                                 <span class="c1"># parameter &#39;$course&#39;; expected Course but </span>
</span></span><span class="line"><span class="cl">                                 <span class="c1"># got Str (&#34;Phys-302&#34;)</span>
</span></span></code></pre></div><h2 id="使用-course-类">使用 COURSE 类</h2>
<p>假设我们有 <code>MATH-101.cfg</code>(课程设置)，<code>MATH-101.std</code>(学生名单)和 <code>MATH-101</code>(学生记录)有了问题陈述中提供的信息，我们可以使用 <code>Course</code> 类(与 <code>Student</code> 和 <code>Assignment</code> 在同一个文件中)，如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># For now, we&#39;ll specify the course name manually.</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$class</span> <span class="o">=</span> <span class="n">Course</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">course</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">MATH-101</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="c1"># set up the course. Remember that the script assumes </span>
</span></span><span class="line"><span class="cl"><span class="c1"># &#39;MATH-101.cfg&#39; and &#39;MATH-101.std&#39; are in the current directory.</span>
</span></span><span class="line"><span class="cl"><span class="nv">$class</span><span class="o">.</span><span class="nf">configure-course</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># filename of student record. </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$data</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">MATH-101</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># loop over each line of student record and feed it to</span>
</span></span><span class="line"><span class="cl"><span class="c1"># the corresponding student.</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">$data</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$class</span><span class="o">.</span><span class="nf">add-student-record</span><span class="p">(</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">:</span><span class="p">&#39;)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># print course report.</span>
</span></span><span class="line"><span class="cl"><span class="nv">$class</span><span class="o">.</span><span class="nf">print-report</span><span class="p">();</span>
</span></span></code></pre></div><p>运行该程序之后，它打印出：</p>
<pre tabindex="0"><code>Class report: course = MATH-101, students = 4
Frank Horza: 
	No records for this student.
Bill Jones: 
	Homework 1: Raw = 35/50 : Adjusted = 17.50/25
	Homework 2: Raw = 42/50 : Adjusted = 21.00/25
	Exam 1: Raw = 72/75 : Adjusted = 48.00/50
	Final Course Grade: 86.5/100

Anne Smith: 
	No records for this student.
Sara Tims: 
	Homework 1: Raw = 39/50 : Adjusted = 19.50/25
	Homework 2: Raw = 45/50 : Adjusted = 22.50/25
	* Incomplete Record *
</code></pre><h2 id="完成程序">完成程序</h2>
<p>您可能注意到，在创建 <code>Course</code> 实例之后，我们必须调用 <code>configure-course</code>。每次创建一个 <code>Course</code> 实例后都要这样做，这样我们就可以添加一个 <code>TWEAK</code> 方法来执行这个任务:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Course</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">submethod</span> <span class="nb">TWEAK</span><span class="p">(</span><span class="nv">$course:</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    	<span class="c1"># set up course after object creation</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$course</span><span class="o">.</span><span class="nf">configure-course</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>问题陈述说明程序应该通过命令行接收学生的成绩。Raku 使命令行参数解析非常容易，我们只需要定义一个 <code>MAIN</code> 子例程来获取一个位置参数，即以包含学生成绩的课程命名的文件。要了解关于 <code>MAIN</code> 子例程的更多信息，请阅读<a href="https://uzluisf.gitlab.io/posts/command-line-raku/">本文</a>或<a href="https://docs.raku.org/language/functions#sub_MAIN">参考文档</a>。</p>
<p>让我们创建一个 <code>report.p6</code> 文件，其中也存储了 <code>Assignment</code>, <code>Student</code> 和 <code>Course</code> 类:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># assume the Assignment, Student, and Course class are here.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span> <span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># CLI arguments are stored in @*ARGS. We take the first one. </span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$class</span> <span class="o">=</span> <span class="n">Course</span><span class="o">.</span><span class="nf">create-course</span><span class="p">(</span> <span class="vg">@*ARGS</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nv">$course</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$class</span><span class="o">.</span><span class="nf">add-student-record</span><span class="p">(</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">:</span><span class="p">&#39;)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="c1"># printing the class report.</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$class</span><span class="o">.</span><span class="nf">print-report</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>假设这样:</p>
<pre tabindex="0"><code>$ ls
MATH-101  MATH-101.cfg  MATH-101.std  report.p6
</code></pre><p>然后:</p>
<pre tabindex="0"><code>$ raku report.p6 MATH-101
</code></pre><p>应该打印出报告。</p>
<h1 id="继承">继承</h1>
<p>我们已经完成了问题陈述所提出的任务，但是我们将在这里讨论的主题在OOP范例中非常重要。<code>Student</code> 类有一个属性，用于存储学生已经注册的课程。现在，让我们假设我们想为兼职学生创建一个 <code>PTStudent</code> 类，它限制了一个学生可以注册的课程数量。考虑到兼职学生肯定是学生，我们可能会被诱使将 <code>Student</code> 类中的代码复制到 <code>PTStudent</code> 中，然后添加必要的约束。虽然技术上很好，但是代码的重复被认为是次优的、容易出错的和概念上有缺陷的工作。相反，我们可以使用一种称为<strong>继承</strong>的机制。</p>
<p>简单地说，继承允许从现有类派生一个新类(带有修改)。这意味着您不必创建完整的新类来复制现有类的部分。在这个过程中，继承的类是<strong>父类</strong>的<strong>孩子</strong>(或子类)。</p>
<p>在 Raku 中，<code>is</code> 关键字定义了继承。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Assume Student is defined here.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PTStudent</span> <span class="k">is</span> <span class="nc">Student</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># new attributes particular to PTStudent.</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">@.courses</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$.course-limit</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># new method too.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">add-course</span><span class="p">(</span> <span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">@.courses</span> <span class="o">==</span> <span class="nv">$.course-limit</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Number of courses exceeds limit of </span><span class="nv">$.course-limit</span><span class="s2">.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="nb">push</span> <span class="nv">@.courses</span><span class="o">,</span> <span class="nv">$course</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$student2</span> <span class="o">=</span> <span class="n">PTStudent</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Tim Polaz</span><span class="p">&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">config</span> <span class="o">=&gt;</span> <span class="nv">%</span><span class="p">()</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">BIO-101</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">GEO-101</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">PHY-102</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">courses</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;);</span>       <span class="c1"># OUTPUT: &#39;BIO-101 GEO-101 PHY-102&#39;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">ENG-220</span><span class="p">&#39;</span> <span class="p">);</span> <span class="c1"># (error) OUTPUT: Number of courses exceeds </span>
</span></span><span class="line"><span class="cl">                                   <span class="c1"># limit of 3.</span>
</span></span></code></pre></div><p><code>PTStudent</code> 类继承了其父类 <code>Student</code> 的属性和方法。除此之外，我们还为它添加了两个新属性和一个新方法。</p>
<p>如果我们愿意，我们可以重新定义从 <code>Student</code> 类继承的方法。这个概念被称为<strong>覆盖</strong>，它允许为父类和子类提供每个类的通用方法实现。</p>
<p>除了单继承之外，Raku 中还可以有多重继承(一次从多个类继承)。查看<a href="https://docs.raku.org/language/classtut#Multiple_inheritance">文档</a>以获得关于它的更多信息。</p>
<h1 id="角色">角色</h1>
<p>与类类似，角色携带状态和行为。然而，与类不同，角色是用来描述对象行为的特定组件的。在 Raku 中，角色是用 <code>role</code> 关键字定义的，并使用 <code>does</code> 特质(与用于继承的 <code>is</code> 相反)应用于类或对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Assume Student is defined here</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">course-limitation</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">has</span> <span class="nv">@.courses</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="kt">Int</span> <span class="nv">$.course-limit</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">add-course</span><span class="p">(</span> <span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nv">@.courses</span> <span class="o">==</span> <span class="nv">$.course-limit</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Number of courses exceeds limit of </span><span class="nv">$.course-limit</span><span class="s2">.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nv">@.courses</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span><span class="nv">$course</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># inheriting from the Student class and applying role.</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PTStudent</span> <span class="k">is</span> <span class="nc">Student</span> <span class="k">does</span> <span class="nc">course-limitation</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$student2</span> <span class="o">=</span> <span class="n">PTStudent</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Tim Polaz</span><span class="p">&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">config</span> <span class="o">=&gt;</span> <span class="nv">%</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">MATH-101</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">GEO-101</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">PHY-102</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span><span class="o">.</span><span class="nf">courses</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;);</span>   <span class="c1"># OUTPUT: &#39;MATH-101 GEO-101 PHY-102&#39;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">ENG-220</span><span class="p">&#39;</span> <span class="p">);</span> <span class="c1"># (error) OUTPUT: Number of courses exceeds </span>
</span></span><span class="line"><span class="cl">                                   <span class="c1"># limit of 3.</span>
</span></span></code></pre></div><p>我们已经演示了角色是如何工作的，但这并没有展示它们的完整画面。例如，就像多重继承一样，角色可以在一个类中多次实现(例如，<code>class Name does role1 does role2 does ...</code>)。但是，与多重继承不同的是，如果多个角色的应用程序出现冲突，则会抛出编译时错误。对于多重继承，冲突不会被认为是错误，而是会在运行时解决。</p>
<p>简而言之，角色可以被认为是继承的另一种选择; 程序员不是通过子类化来扩展类层次结构，而是使用为类的行为提供补充行为的角色来组成类。</p>
<h1 id="内省">内省</h1>
<p><strong>内省</strong> 是一个对象能够收集关于自身和其他对象的信息的过程，如类型、方法、属性等。</p>
<p>在 Raku 中，内省可以通过以下结构得到促进:</p>
<ul>
<li><code>.WHAT</code>——返回与对象关联的类型对象。</li>
<li><code>.perl</code>——返回一个字符串，该字符串可以作为 Raku 代码执行。</li>
<li><code>.^name</code>——返回类名。</li>
<li><code>^attributes</code>——返回对象的所有属性。</li>
<li><code>^methods</code>——返回可以在该对象上调用的所有方法。</li>
<li><code>^parents</code>——返回对象的父类。</li>
<li><code>~~</code> 是智能匹配操作符。如果对象是由正在进行比较的类或其任何它的继承类创建的，则计算为 <code>True</code>。</li>
</ul>
<p><code>.^</code> 语法是元方法调用。使用这种语法而不是单个点表示对其元类的方法调用，元类是管理所有类的属性的类。事实上, <code>obj.^meth</code> 相当于<code>obj.HOW.meth(obj)</code>, 其中 <code>meth</code> 是一个特定的方法。</p>
<p>使用上一节中的对象 <code>$student2</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>         <span class="c1"># OUTPUT: (PTStudent)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>         <span class="c1"># OUTPUT: PTStudent.new(name =&gt; &#34;Tim Polaz&#34;, </span>
</span></span><span class="line"><span class="cl">                            <span class="c1">#         config =&gt; {}, courses =&gt; [])</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>        <span class="c1"># OUTPUT: PTStudent</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span><span class="o">.^</span><span class="nb">attributes</span><span class="p">;</span>  <span class="c1"># OUTPUT: (Str $!name Associative %!config Mu </span>
</span></span><span class="line"><span class="cl">                            <span class="c1">#          $!assig-num Associative %!assignments</span>
</span></span><span class="line"><span class="cl">                            <span class="c1">#          Positional @!courses)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span><span class="o">.^</span><span class="nb">methods</span><span class="p">;</span>     <span class="c1"># OUTPUT: (course-limit add-course name </span>
</span></span><span class="line"><span class="cl">                            <span class="c1">#          add-assignment courses config get-exams</span>
</span></span><span class="line"><span class="cl">                            <span class="c1">#          print-report get-homeworks BUILDALL)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span><span class="o">.^</span><span class="nb">parents</span><span class="p">;</span>     <span class="c1"># OUTPUT: ((Student))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span> <span class="o">~~</span> <span class="n">PTStudent</span><span class="p">;</span> <span class="c1"># True</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span> <span class="o">~~</span> <span class="n">Student</span><span class="p">;</span>   <span class="c1"># True</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span> <span class="o">~~</span> <span class="kt">Str</span><span class="p">;</span>       <span class="c1"># False</span>
</span></span></code></pre></div><p>如您所见，通过内省，您可以从类的实例中学到很多东西。</p>
<p>内省并不仅限于程序员定义的类。内省是 Raku 的核心，它是一个非常有用的工具，可以帮助您了解内置类型，并从整体上了解该语言。</p>
<h1 id="结论">结论</h1>
<p>在这篇文章中，我们学习了如何定义类、私有和公共属性以及私有和公共方法。我们还学习了如何创建自定义构造函数，并将其调用限制在类或类的实例中。此外，我们还简要讨论了如何通过继承和 Raku 中的角色来促进代码重用。最后，我们讨论了内省的过程，以及如何以最简单的形式学习对象。</p>
<p>关于 <code>report.p6</code>，我们局限于问题陈述，但是程序的用户可以从额外的功能中获益。例如，可以修改程序，为单个学生提供交互式查询，以便学生从命令行查找。此外，该程序可以读取多个课程，然后查询它们，检索并打印一个特定学生的记录。</p>
<p>下面我链接了我们在这里创建的程序和实现前面提到的额外功能的程序。希望这整个教程是有益的和有用的。</p>
<p>链接:</p>
<ul>
<li>整个 report.p6</li>
<li><code>report.p6</code> 有额外的功能。我还添加了一个简单的函数来给课程名称上色，以便更好地将它们与其他文本区分开来。对于一些课程文件，输出结果如下:</li>
</ul>
<p><img src="https://i.imgur.com/3BVTxB0.jpg" alt="img"></p>
<h1 id="资源">资源</h1>
<ul>
<li>Raku Introduction</li>
<li>Raku Documentation
<ul>
<li>Classes and objects</li>
<li>Object orientation</li>
</ul>
</li>
<li>Raku Advent Calendar
<ul>
<li>The humble type object</li>
<li>Classes, attributes, methods and more</li>
<li>Introspection</li>
</ul>
</li>
<li>Basic OO in Raku (slides)</li>
<li>Let’s build an object</li>
<li>Think Raku</li>
<li>The problem statement was an adaptation from a section titled Grades: an object example in the book Elements of Programming with Perl by Andrew L. Johnson.</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
</feed>
