{"author":{"name":null,"type":"card","url":"http://localhost:1313/"},"content":{"html":"\u003ch1 id=\"数据类型\"\u003e数据类型\u003c/h1\u003e\n\u003cp\u003e由于历史原因，在Flink 1.9之前，Flink的Table \u0026amp; SQL API数据类型与Flink的TypeInformation紧密耦合。TypeInformation在DataStream和DataSet API中使用，足以描述在分布式环境中序列化和反序列化基于JVM的对象所需的所有信息。\u003c/p\u003e\n\u003cp\u003e然而，TypeInformation并不是为了表示独立于实际JVM类的逻辑类型而设计的。在过去，很难将SQL标准类型映射到这个抽象中。此外，有些类型不符合SQL标准，而且在引入时没有考虑到更大的情况。\u003c/p\u003e\n\u003cp\u003e从Flink 1.9开始，Table \u0026amp; SQL API将获得一个新的类型系统，作为API稳定性和标准合规性的长期解决方案。\u003c/p\u003e\n\u003cp\u003e重构类型系统是一项重大的工作，几乎涉及到所有面向用户的界面。因此，它的引入跨越了多个版本，社区的目标是在Flink 1.12之前完成这项工作。\u003c/p\u003e\n\u003cp\u003e由于同时增加了一个新的表程序的规划器（见 \u003ca href=\"https://issues.apache.org/jira/browse/FLINK-11439\"\u003eFLINK-11439\u003c/a\u003e），并不是每一个规划器和数据类型的组合都被支持。此外，规划器可能不支持每个数据类型所需的精度或参数。\u003c/p\u003e\n\u003cp\u003e请注意。在使用数据类型之前，请查看规划器兼容性表和限制部分。\u003c/p\u003e\n\u003ch2 id=\"data-type\"\u003eData Type\u003c/h2\u003e\n\u003cp\u003e数据类型描述了表生态系统中一个值的逻辑类型。它可以用来声明操作的输入和/或输出类型。\u003c/p\u003e\n\u003cp\u003eFlink的数据类型类似于SQL标准的数据类型术语，但也包含了关于值的空性的信息，以便有效处理标量表达式。\u003c/p\u003e\n\u003cp\u003e数据类型的例子有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eINT\u003c/li\u003e\n\u003cli\u003eINT NOT NULL\u003c/li\u003e\n\u003cli\u003eINTERVAL DAY TO SECOND(3)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eROW\u0026lt;myField ARRAY\u0026lt;BOOLEAN\u0026gt;, myOtherField TIMESTAMP(3)\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e所有预定义数据类型的列表可以在下面找到。\u003c/p\u003e\n\u003cp\u003e表API中的数据类型\n基于JVM的API的用户在Table API中或在定义连接器、目录或用户定义的函数时，使用org.apache.flink.table.types.DataType的实例工作。\u003c/p\u003e\n\u003cp\u003eDataType 实例有两个职责。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e声明一个逻辑类型，它并不意味着传输或存储的具体物理表示，而是定义了基于JVM/python语言和表生态系统之间的边界。\u003c/li\u003e\n\u003cli\u003e可选。给予规划者关于数据的物理表示的提示，这在其他API的边缘是有用的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对于基于JVM的语言，所有预定义的数据类型都可以在 \u003ccode\u003eorg.apache.flink.table.api.DataTypes\u003c/code\u003e 中获得。\u003c/p\u003e\n\u003cp\u003e建议在你的表程序中添加一个星形导入，以便拥有一个流畅的API。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003eorg.apache.flink.table.api.DataTypes._\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataType\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eINTERVAL\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eDAY\u003c/span\u003e\u003cspan class=\"o\"\u003e(),\u003c/span\u003e \u003cspan class=\"nc\"\u003eSECOND\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e物理提示\u003c/p\u003e\n\u003cp\u003e在表生态系统的边缘需要物理提示，在这里，基于SQL的类型系统结束了，需要特定的编程数据类型。提示表示一个实现所期望的数据格式。\u003c/p\u003e\n\u003cp\u003e例如，一个数据源可以表示它使用java.sql.Timestamp类而不是使用java.time.LocalDateTime来产生逻辑TIMESTAMPs的值，后者是默认的。有了这些信息，运行时就能够将产生的类转换为其内部的数据格式。作为回报，数据汇可以声明它从运行时消耗的数据格式。\u003c/p\u003e\n\u003cp\u003e下面是一些如何声明桥接转换类的例子。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// tell the runtime to not produce or consume java.time.LocalDateTime instances\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// but java.sql.Timestamp\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataType\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eDataTypes\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eTIMESTAMP\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ebridgedTo\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eclassOf\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003ejava.sql.Timestamp\u003c/span\u003e\u003cspan class=\"o\"\u003e]);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// tell the runtime to not produce or consume boxed integer arrays\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// but primitive int arrays\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataType\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eDataTypes\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eARRAY\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eDataTypes\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eINT\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003enotNull\u003c/span\u003e\u003cspan class=\"o\"\u003e()).\u003c/span\u003e\u003cspan class=\"n\"\u003ebridgedTo\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eclassOf\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eArray\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e]]);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e注意 请注意，通常只有当API被扩展时才需要物理提示。预定义源/汇/函数的用户不需要定义这种提示。表程序中的提示（例如field.cast(TIMESTAMP(3).bridgedTo(Timestamp.class))）会被忽略。\u003c/p\u003e\n\u003cp\u003e规划师兼容性\n如导言中提到的，类型系统的重构将跨越多个版本，对每种数据类型的支持取决于所使用的规划器。本节旨在总结最显著的差异。\u003c/p\u003e\n\u003cp\u003e旧的规划器\nFlink在Flink 1.9之前推出的老式规划器，主要支持类型信息。它对数据类型的支持有限。可以声明可以转化为类型信息的数据类型，这样旧的规划器就可以理解它们。\u003c/p\u003e\n\u003cp\u003e下表总结了数据类型和类型信息的区别。大多数简单类型，以及行类型保持不变。时间类型、数组类型以及十进制类型需要特别注意。其他如上述的提示是不允许的。\u003c/p\u003e\n\u003cp\u003e对于类型信息列，表格省略了前缀org.apache.flink.table.api.Types。\u003c/p\u003e\n\u003cp\u003e对于数据类型表示一栏，表中省略了前缀org.apache.flink.table.api.DataTypes。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e类型信息\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003eJava Expression String\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e数据类型表示\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e数据类型的备注\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eSTRING()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eSTRING\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eSTRING()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eBOOLEAN()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eBOOLEAN\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eBOOLEAN()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eBYTE()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eBYTE\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eTINYINT()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eSHORT()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eSHORT\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eSMALLINT()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eINT()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eINT\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eINT()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eLONG()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eLONG\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eBIGINT()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eFLOAT()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eFLOAT\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eFLOAT()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eDOUBLE()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eDOUBLE\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eDOUBLE()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eROW(\u0026hellip;)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eROW\u0026lt;\u0026hellip;\u0026gt;\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eROW(\u0026hellip;)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eBIG_DEC()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eDECIMAL\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e[DECIMAL()]\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e不是1:1的映射，因为忽略了精度和比例，使用了Java的变量精度和比例。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eSQL_DATE()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eSQL_DATE\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eDATE().bridgedTo(java.sql.Date.class)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eSQL_TIME()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eSQL_TIME\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eTIME(0).bridgedTo(java.sql.Time.class)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eSQL_TIMESTAMP()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eSQL_TIMESTAMP\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eTIMESTAMP(3).bridgedTo(java.sql.Timestamp.class)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eINTERVAL_MONTHS()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eINTERVAL_MONTHS\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eINTERVAL(MONTH()).bridgedTo(Integer.class)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eINTERVAL_MILLIS()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eINTERVAL_MILLIS\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eINTERVAL(DataTypes.SECOND(3)).bridgedTo(Long.class)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003ePRIMITIVE_ARRAY(\u0026hellip;)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003ePRIMITIVE_ARRAY\u0026lt;\u0026hellip;\u0026gt;\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eARRAY(DATATYPE.notNull().bridgedTo(PRIMITIVE.class))\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e适用于除byte以外的所有JVM基元类型。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003ePRIMITIVE_ARRAY(BYTE())\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003ePRIMITIVE_ARRAY\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eBYTES()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eOBJECT_ARRAY(\u0026hellip;)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eOBJECT_ARRAY\u0026lt;\u0026hellip;\u0026gt;\tARRAY(DATATYPE.bridgedTo(OBJECT.class))\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eMULTISET(\u0026hellip;)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eMULTISET(\u0026hellip;)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eMAP(\u0026hellip;, \u0026hellip;)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eMAP\u0026lt;\u0026hellip;,\u0026hellip;\u0026gt;\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eMAP(\u0026hellip;)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eother generic types\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eRAW(\u0026hellip;)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e注意 如果新的类型系统出现问题。用户可以随时回退到 \u003ccode\u003eorg.apache.flink.table.api.Types\u003c/code\u003e 中定义的类型信息。\u003c/p\u003e\n\u003cp\u003e新的 Blink 计划器\n新的Blink计划器支持旧计划器的所有类型。这特别包括列出的Java表达式字符串和类型信息。\u003c/p\u003e\n\u003cp\u003e支持以下数据类型。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003eData Type\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003eRemarks for Data Type\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eSTRING\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e还不支持 CHAR 和 VARCHAR\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eBOOLEAN\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eBYTES\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e还不支持 BINARY 和 VARBINARY\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eDECIMAL\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e支持固定精度和比例。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eTINYINT\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eSMALLINT\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eINTEGER\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eBIGINT\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eFLOAT\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eDOUBLE\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eDATE\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eTIME\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e只支持精度为0。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eTIMESTAMP\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eTIMESTAMP WITH LOCAL TIME ZONE\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eINTERVAL\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e只支持MONTH和SECOND(3)的间隔。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eARRAY\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eMULTISET\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eMAP\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eROW\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eRAW\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003estuctured types\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e目前只在用户定义的函数中暴露。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e局限性\nJava表达式字符串。表API中的Java表达式字符串，如table.select(\u0026ldquo;field.cast(STRING)\u0026quot;)还没有更新到新的类型系统。请使用旧计划器部分中声明的字符串表示法。\u003c/p\u003e\n\u003cp\u003e用户定义的函数。用户定义的集合函数还不能声明数据类型。标量函数和表函数完全支持数据类型。\u003c/p\u003e\n\u003cp\u003e数据类型列表\n本节列出了所有预定义的数据类型。\u003c/p\u003e\n\u003cp\u003e对于基于JVM的Table API，这些类型也可以在org.apache.flink.table.api.DataTypes中找到。\u003c/p\u003e\n\u003cp\u003e字符字符串\nCHAR\u003c/p\u003e\n\u003cp\u003e一个固定长度的字符串的数据类型。\u003c/p\u003e\n\u003cp\u003e声明\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e-- sql\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"nb\"\u003eCHAR\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"nb\"\u003eCHAR\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nc\"\u003eDataTypes\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eCHAR\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e桥接到JVM类型\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003eJava Type\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003eInput\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003eOutput\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003eRemarks\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003ejava.lang.String\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eX\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eX\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eDefault\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003ebyte[]\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eX\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eX\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eAssumes UTF-8 encoding.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eorg.apache.flink.table.data.StringData\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eX\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eX\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eInternal data structure.\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003en的值必须在1和2,147,483,647之间(包括两者)。如果没有指定长度，n等于1。\u003c/p\u003e\n\u003cp\u003eVARCHAR / STRING\u003c/p\u003e\n\u003cp\u003e可变长度的字符串的数据类型。\u003c/p\u003e\n\u003cp\u003e声明\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nc\"\u003eDataTypes\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eVARCHAR\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eDataTypes.STRING()\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.lang.String\tX\tX\tDefault\nbyte[]\tX\tX\tAssumes UTF-8 encoding.\norg.apache.flink.table.data.StringData\tX\tX\tInternal data structure.\nThe type can be declared using VARCHAR(n) where n is the maximum number of code points. n must have a value between 1 and 2,147,483,647 (both inclusive). If no length is specified, n is equal to 1.\u003c/p\u003e\n\u003cp\u003eSTRING is a synonym for VARCHAR(2147483647).\u003c/p\u003e\n\u003cp\u003eBinary Strings\nBINARY\u003c/p\u003e\n\u003cp\u003eData type of a fixed-length binary string (=a sequence of bytes).\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.BINARY(n)\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\nbyte[]\tX\tX\tDefault\nThe type can be declared using BINARY(n) where n is the number of bytes. n must have a value between 1 and 2,147,483,647 (both inclusive). If no length is specified, n is equal to 1.\u003c/p\u003e\n\u003cp\u003eVARBINARY / BYTES\u003c/p\u003e\n\u003cp\u003eData type of a variable-length binary string (=a sequence of bytes).\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.VARBINARY(n)\u003c/p\u003e\n\u003cp\u003eDataTypes.BYTES()\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\nbyte[]\tX\tX\tDefault\nThe type can be declared using VARBINARY(n) where n is the maximum number of bytes. n must have a value between 1 and 2,147,483,647 (both inclusive). If no length is specified, n is equal to 1.\u003c/p\u003e\n\u003cp\u003eBYTES is a synonym for VARBINARY(2147483647).\u003c/p\u003e\n\u003cp\u003eExact Numerics\nDECIMAL\u003c/p\u003e\n\u003cp\u003eData type of a decimal number with fixed precision and scale.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.DECIMAL(p, s)\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.math.BigDecimal\tX\tX\tDefault\norg.apache.flink.table.data.DecimalData\tX\tX\tInternal data structure.\nThe type can be declared using DECIMAL(p, s) where p is the number of digits in a number (precision) and s is the number of digits to the right of the decimal point in a number (scale). p must have a value between 1 and 38 (both inclusive). s must have a value between 0 and p (both inclusive). The default value for p is 10. The default value for s is 0.\u003c/p\u003e\n\u003cp\u003eNUMERIC(p, s) and DEC(p, s) are synonyms for this type.\u003c/p\u003e\n\u003cp\u003eTINYINT\u003c/p\u003e\n\u003cp\u003eData type of a 1-byte signed integer with values from -128 to 127.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.TINYINT()\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.lang.Byte\tX\tX\tDefault\nbyte\tX\t(X)\tOutput only if type is not nullable.\nSMALLINT\u003c/p\u003e\n\u003cp\u003eData type of a 2-byte signed integer with values from -32,768 to 32,767.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.SMALLINT()\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.lang.Short\tX\tX\tDefault\nshort\tX\t(X)\tOutput only if type is not nullable.\nINT\u003c/p\u003e\n\u003cp\u003eData type of a 4-byte signed integer with values from -2,147,483,648 to 2,147,483,647.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.INT()\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.lang.Integer\tX\tX\tDefault\nint\tX\t(X)\tOutput only if type is not nullable.\nINTEGER is a synonym for this type.\u003c/p\u003e\n\u003cp\u003eBIGINT\u003c/p\u003e\n\u003cp\u003eData type of an 8-byte signed integer with values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.BIGINT()\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.lang.Long\tX\tX\tDefault\nlong\tX\t(X)\tOutput only if type is not nullable.\nApproximate Numerics\nFLOAT\u003c/p\u003e\n\u003cp\u003eData type of a 4-byte single precision floating point number.\u003c/p\u003e\n\u003cp\u003eCompared to the SQL standard, the type does not take parameters.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.FLOAT()\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.lang.Float\tX\tX\tDefault\nfloat\tX\t(X)\tOutput only if type is not nullable.\nDOUBLE\u003c/p\u003e\n\u003cp\u003eData type of an 8-byte double precision floating point number.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.DOUBLE()\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.lang.Double\tX\tX\tDefault\ndouble\tX\t(X)\tOutput only if type is not nullable.\nDOUBLE PRECISION is a synonym for this type.\u003c/p\u003e\n\u003cp\u003eDate and Time\nDATE\u003c/p\u003e\n\u003cp\u003eData type of a date consisting of year-month-day with values ranging from 0000-01-01 to 9999-12-31.\u003c/p\u003e\n\u003cp\u003eCompared to the SQL standard, the range starts at year 0000.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.DATE()\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.time.LocalDate\tX\tX\tDefault\njava.sql.Date\tX\tX\t\njava.lang.Integer\tX\tX\tDescribes the number of days since epoch.\nint\tX\t(X)\tDescribes the number of days since epoch.\nOutput only if type is not nullable.\nTIME\u003c/p\u003e\n\u003cp\u003eData type of a time without time zone consisting of hour:minute:second[.fractional] with up to nanosecond precision and values ranging from 00:00:00.000000000 to 23:59:59.999999999.\u003c/p\u003e\n\u003cp\u003eCompared to the SQL standard, leap seconds (23:59:60 and 23:59:61) are not supported as the semantics are closer to java.time.LocalTime. A time with time zone is not provided.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.TIME(p)\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.time.LocalTime\tX\tX\tDefault\njava.sql.Time\tX\tX\t\njava.lang.Integer\tX\tX\tDescribes the number of milliseconds of the day.\nint\tX\t(X)\tDescribes the number of milliseconds of the day.\nOutput only if type is not nullable.\njava.lang.Long\tX\tX\tDescribes the number of nanoseconds of the day.\nlong\tX\t(X)\tDescribes the number of nanoseconds of the day.\nOutput only if type is not nullable.\nThe type can be declared using TIME(p) where p is the number of digits of fractional seconds (precision). p must have a value between 0 and 9 (both inclusive). If no precision is specified, p is equal to 0.\u003c/p\u003e\n\u003cp\u003eTIMESTAMP\u003c/p\u003e\n\u003cp\u003eData type of a timestamp without time zone consisting of year-month-day hour:minute:second[.fractional] with up to nanosecond precision and values ranging from 0000-01-01 00:00:00.000000000 to 9999-12-31 23:59:59.999999999.\u003c/p\u003e\n\u003cp\u003eCompared to the SQL standard, leap seconds (23:59:60 and 23:59:61) are not supported as the semantics are closer to java.time.LocalDateTime.\u003c/p\u003e\n\u003cp\u003eA conversion from and to BIGINT (a JVM long type) is not supported as this would imply a time zone. However, this type is time zone free. For more java.time.Instant-like semantics use TIMESTAMP WITH LOCAL TIME ZONE.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.TIMESTAMP(p)\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.time.LocalDateTime\tX\tX\tDefault\njava.sql.Timestamp\tX\tX\t\norg.apache.flink.table.data.TimestampData\tX\tX\tInternal data structure.\nThe type can be declared using TIMESTAMP(p) where p is the number of digits of fractional seconds (precision). p must have a value between 0 and 9 (both inclusive). If no precision is specified, p is equal to 6.\u003c/p\u003e\n\u003cp\u003eTIMESTAMP(p) WITHOUT TIME ZONE is a synonym for this type.\u003c/p\u003e\n\u003cp\u003eTIMESTAMP WITH TIME ZONE\u003c/p\u003e\n\u003cp\u003eData type of a timestamp with time zone consisting of year-month-day hour:minute:second[.fractional] zone with up to nanosecond precision and values ranging from 0000-01-01 00:00:00.000000000 +14:59 to 9999-12-31 23:59:59.999999999 -14:59.\u003c/p\u003e\n\u003cp\u003eCompared to the SQL standard, leap seconds (23:59:60 and 23:59:61) are not supported as the semantics are closer to java.time.OffsetDateTime.\u003c/p\u003e\n\u003cp\u003eCompared to TIMESTAMP WITH LOCAL TIME ZONE, the time zone offset information is physically stored in every datum. It is used individually for every computation, visualization, or communication to external systems.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.TIMESTAMP_WITH_TIME_ZONE(p)\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.time.OffsetDateTime\tX\tX\tDefault\njava.time.ZonedDateTime\tX\t \tIgnores the zone ID.\nThe type can be declared using TIMESTAMP(p) WITH TIME ZONE where p is the number of digits of fractional seconds (precision). p must have a value between 0 and 9 (both inclusive). If no precision is specified, p is equal to 6.\u003c/p\u003e\n\u003cp\u003eTIMESTAMP WITH LOCAL TIME ZONE\u003c/p\u003e\n\u003cp\u003eData type of a timestamp with local time zone consisting of year-month-day hour:minute:second[.fractional] zone with up to nanosecond precision and values ranging from 0000-01-01 00:00:00.000000000 +14:59 to 9999-12-31 23:59:59.999999999 -14:59.\u003c/p\u003e\n\u003cp\u003eLeap seconds (23:59:60 and 23:59:61) are not supported as the semantics are closer to java.time.OffsetDateTime.\u003c/p\u003e\n\u003cp\u003eCompared to TIMESTAMP WITH TIME ZONE, the time zone offset information is not stored physically in every datum. Instead, the type assumes java.time.Instant semantics in UTC time zone at the edges of the table ecosystem. Every datum is interpreted in the local time zone configured in the current session for computation and visualization.\u003c/p\u003e\n\u003cp\u003eThis type fills the gap between time zone free and time zone mandatory timestamp types by allowing the interpretation of UTC timestamps according to the configured session time zone.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE(p)\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.time.Instant\tX\tX\tDefault\njava.lang.Integer\tX\tX\tDescribes the number of seconds since epoch.\nint\tX\t(X)\tDescribes the number of seconds since epoch.\nOutput only if type is not nullable.\njava.lang.Long\tX\tX\tDescribes the number of milliseconds since epoch.\nlong\tX\t(X)\tDescribes the number of milliseconds since epoch.\nOutput only if type is not nullable.\norg.apache.flink.table.data.TimestampData\tX\tX\tInternal data structure.\nThe type can be declared using TIMESTAMP(p) WITH LOCAL TIME ZONE where p is the number of digits of fractional seconds (precision). p must have a value between 0 and 9 (both inclusive). If no precision is specified, p is equal to 6.\u003c/p\u003e\n\u003cp\u003eINTERVAL YEAR TO MONTH\u003c/p\u003e\n\u003cp\u003eData type for a group of year-month interval types.\u003c/p\u003e\n\u003cp\u003eThe type must be parameterized to one of the following resolutions:\u003c/p\u003e\n\u003cp\u003einterval of years,\ninterval of years to months,\nor interval of months.\nAn interval of year-month consists of +years-months with values ranging from -9999-11 to +9999-11.\u003c/p\u003e\n\u003cp\u003eThe value representation is the same for all types of resolutions. For example, an interval of months of 50 is always represented in an interval-of-years-to-months format (with default year precision): +04-02.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.INTERVAL(DataTypes.YEAR())\nDataTypes.INTERVAL(DataTypes.YEAR(p))\nDataTypes.INTERVAL(DataTypes.YEAR(p), DataTypes.MONTH())\nDataTypes.INTERVAL(DataTypes.MONTH())\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.time.Period\tX\tX\tIgnores the days part. Default\njava.lang.Integer\tX\tX\tDescribes the number of months.\nint\tX\t(X)\tDescribes the number of months.\nOutput only if type is not nullable.\nThe type can be declared using the above combinations where p is the number of digits of years (year precision). p must have a value between 1 and 4 (both inclusive). If no year precision is specified, p is equal to 2.\u003c/p\u003e\n\u003cp\u003eINTERVAL DAY TO SECOND\u003c/p\u003e\n\u003cp\u003eData type for a group of day-time interval types.\u003c/p\u003e\n\u003cp\u003eThe type must be parameterized to one of the following resolutions with up to nanosecond precision:\u003c/p\u003e\n\u003cp\u003einterval of days,\ninterval of days to hours,\ninterval of days to minutes,\ninterval of days to seconds,\ninterval of hours,\ninterval of hours to minutes,\ninterval of hours to seconds,\ninterval of minutes,\ninterval of minutes to seconds,\nor interval of seconds.\nAn interval of day-time consists of +days hours:months:seconds.fractional with values ranging from -999999 23:59:59.999999999 to +999999 23:59:59.999999999. The value representation is the same for all types of resolutions. For example, an interval of seconds of 70 is always represented in an interval-of-days-to-seconds format (with default precisions): +00 00:01:10.000000.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.INTERVAL(DataTypes.DAY())\nDataTypes.INTERVAL(DataTypes.DAY(p1))\nDataTypes.INTERVAL(DataTypes.DAY(p1), DataTypes.HOUR())\nDataTypes.INTERVAL(DataTypes.DAY(p1), DataTypes.MINUTE())\nDataTypes.INTERVAL(DataTypes.DAY(p1), DataTypes.SECOND(p2))\nDataTypes.INTERVAL(DataTypes.HOUR())\nDataTypes.INTERVAL(DataTypes.HOUR(), DataTypes.MINUTE())\nDataTypes.INTERVAL(DataTypes.HOUR(), DataTypes.SECOND(p2))\nDataTypes.INTERVAL(DataTypes.MINUTE())\nDataTypes.INTERVAL(DataTypes.MINUTE(), DataTypes.SECOND(p2))\nDataTypes.INTERVAL(DataTypes.SECOND())\nDataTypes.INTERVAL(DataTypes.SECOND(p2))\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.time.Duration\tX\tX\tDefault\njava.lang.Long\tX\tX\tDescribes the number of milliseconds.\nlong\tX\t(X)\tDescribes the number of milliseconds.\nOutput only if type is not nullable.\nThe type can be declared using the above combinations where p1 is the number of digits of days (day precision) and p2 is the number of digits of fractional seconds (fractional precision). p1 must have a value between 1 and 6 (both inclusive). p2 must have a value between 0 and 9 (both inclusive). If no p1 is specified, it is equal to 2 by default. If no p2 is specified, it is equal to 6 by default.\u003c/p\u003e\n\u003cp\u003eConstructured Data Types\nARRAY\u003c/p\u003e\n\u003cp\u003eData type of an array of elements with same subtype.\u003c/p\u003e\n\u003cp\u003eCompared to the SQL standard, the maximum cardinality of an array cannot be specified but is fixed at 2,147,483,647. Also, any valid type is supported as a subtype.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.ARRAY(t)\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\nt[]\t(X)\t(X)\tDepends on the subtype. Default\norg.apache.flink.table.data.ArrayData\tX\tX\tInternal data structure.\nThe type can be declared using ARRAY\u003c!-- raw HTML omitted --\u003e where t is the data type of the contained elements.\u003c/p\u003e\n\u003cp\u003et ARRAY is a synonym for being closer to the SQL standard. For example, INT ARRAY is equivalent to ARRAY\u003c!-- raw HTML omitted --\u003e.\u003c/p\u003e\n\u003cp\u003eMAP\u003c/p\u003e\n\u003cp\u003eData type of an associative array that maps keys (including NULL) to values (including NULL). A map cannot contain duplicate keys; each key can map to at most one value.\u003c/p\u003e\n\u003cp\u003eThere is no restriction of element types; it is the responsibility of the user to ensure uniqueness.\u003c/p\u003e\n\u003cp\u003eThe map type is an extension to the SQL standard.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.MAP(kt, vt)\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.util.Map\u0026lt;kt, vt\u0026gt;\tX\tX\tDefault\nsubclass of java.util.Map\u0026lt;kt, vt\u0026gt;\tX\t \t\norg.apache.flink.table.data.MapData\tX\tX\tInternal data structure.\nThe type can be declared using MAP\u0026lt;kt, vt\u0026gt; where kt is the data type of the key elements and vt is the data type of the value elements.\u003c/p\u003e\n\u003cp\u003eMULTISET\u003c/p\u003e\n\u003cp\u003eData type of a multiset (=bag). Unlike a set, it allows for multiple instances for each of its elements with a common subtype. Each unique value (including NULL) is mapped to some multiplicity.\u003c/p\u003e\n\u003cp\u003eThere is no restriction of element types; it is the responsibility of the user to ensure uniqueness.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.MULTISET(t)\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.util.Map\u0026lt;t, java.lang.Integer\u0026gt;\tX\tX\tAssigns each value to an integer multiplicity. Default\nsubclass of java.util.Map\u0026lt;t, java.lang.Integer\u0026raquo;\tX\t \t\norg.apache.flink.table.data.MapData\tX\tX\tInternal data structure.\nThe type can be declared using MULTISET\u003c!-- raw HTML omitted --\u003e where t is the data type of the contained elements.\u003c/p\u003e\n\u003cp\u003et MULTISET is a synonym for being closer to the SQL standard. For example, INT MULTISET is equivalent to MULTISET\u003c!-- raw HTML omitted --\u003e.\u003c/p\u003e\n\u003cp\u003eROW\u003c/p\u003e\n\u003cp\u003eData type of a sequence of fields.\u003c/p\u003e\n\u003cp\u003eA field consists of a field name, field type, and an optional description. The most specific type of a row of a table is a row type. In this case, each column of the row corresponds to the field of the row type that has the same ordinal position as the column.\u003c/p\u003e\n\u003cp\u003eCompared to the SQL standard, an optional field description simplifies the handling with complex structures.\u003c/p\u003e\n\u003cp\u003eA row type is similar to the STRUCT type known from other non-standard-compliant frameworks.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.ROW(DataTypes.FIELD(n0, t0), DataTypes.FIELD(n1, t1), \u0026hellip;)\nDataTypes.ROW(DataTypes.FIELD(n0, t0, d0), DataTypes.FIELD(n1, t1, d1), \u0026hellip;)\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\norg.apache.flink.types.Row\tX\tX\tDefault\norg.apache.flink.table.data.RowData\tX\tX\tInternal data structure.\nThe type can be declared using ROW\u0026lt;n0 t0 \u0026lsquo;d0\u0026rsquo;, n1 t1 \u0026lsquo;d1\u0026rsquo;, \u0026hellip;\u0026gt; where n is the unique name of a field, t is the logical type of a field, d is the description of a field.\u003c/p\u003e\n\u003cp\u003eROW(\u0026hellip;) is a synonym for being closer to the SQL standard. For example, ROW(myField INT, myOtherField BOOLEAN) is equivalent to ROW\u0026lt;myField INT, myOtherField BOOLEAN\u0026gt;.\u003c/p\u003e\n\u003cp\u003eUser-Defined Data Types\nAttention User-defined data types are not fully supported yet. They are currently (as of Flink 1.11) only exposed as unregistered structured types in parameters and return types of functions.\u003c/p\u003e\n\u003cp\u003eA structured type is similar to an object in an object-oriented programming language. It contains zero, one or more attributes. Each attribute consists of a name and a type.\u003c/p\u003e\n\u003cp\u003eThere are two kinds of structured types:\u003c/p\u003e\n\u003cp\u003eTypes that are stored in a catalog and are identified by a catalog identifer (like cat.db.MyType). Those are equal to the SQL standard definition of structured types.\u003c/p\u003e\n\u003cp\u003eAnonymously defined, unregistered types (usually reflectively extracted) that are identified by an implementation class (like com.myorg.model.MyType). Those are useful when programmatically defining a table program. They enable reusing existing JVM classes without manually defining the schema of a data type again.\u003c/p\u003e\n\u003cp\u003eRegistered Structured Types\u003c/p\u003e\n\u003cp\u003eCurrently, registered structured types are not supported. Thus, they cannot be stored in a catalog or referenced in a CREATE TABLE DDL.\u003c/p\u003e\n\u003cp\u003eUnregistered Structured Types\u003c/p\u003e\n\u003cp\u003eUnregistered structured types can be created from regular POJOs (Plain Old Java Objects) using automatic reflective extraction.\u003c/p\u003e\n\u003cp\u003eThe implementation class of a structured type must meet the following requirements:\u003c/p\u003e\n\u003cp\u003eThe class must be globally accessible which means it must be declared public, static, and not abstract.\nThe class must offer a default constructor with zero arguments or a full constructor that assigns all fields.\nAll fields of the class must be readable by either public declaration or a getter that follows common coding style such as getField(), isField(), field().\nAll fields of the class must be writable by either public declaration, fully assigning constructor, or a setter that follows common coding style such as setField(\u0026hellip;), field(\u0026hellip;).\nAll fields must be mapped to a data type either implicitly via reflective extraction or explicitly using the @DataTypeHint annotations.\nFields that are declared static or transient are ignored.\nThe reflective extraction supports arbitrary nesting of fields as long as a field type does not (transitively) refer to itself.\u003c/p\u003e\n\u003cp\u003eThe declared field class (e.g. public int age;) must be contained in the list of supported JVM bridging classes defined for every data type in this document (e.g. java.lang.Integer or int for INT).\u003c/p\u003e\n\u003cp\u003eFor some classes an annotation is required in order to map the class to a data type (e.g. @DataTypeHint(\u0026ldquo;DECIMAL(10, 2)\u0026rdquo;) to assign a fixed precision and scale for java.math.BigDecimal).\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eJava\nScala\nPython\ncase class User(\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// extract fields automatically\nage: Int,\nname: String,\n\n// enrich the extraction with precision information\n@DataTypeHint(\u0026quot;DECIMAL(10, 2)\u0026quot;) totalBalance: java.math.BigDecimal,\n\n// enrich the extraction with forcing using a RAW type\n@DataTypeHint(\u0026quot;RAW\u0026quot;) modelClass: Class[_]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e)\u003c/p\u003e\n\u003cp\u003eDataTypes.of(classOf[User])\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\nclass\tX\tX\tOriginating class or subclasses (for input) or\nsuperclasses (for output). Default\norg.apache.flink.types.Row\tX\tX\tRepresent the structured type as a row.\norg.apache.flink.table.data.RowData\tX\tX\tInternal data structure.\nOther Data Types\nBOOLEAN\u003c/p\u003e\n\u003cp\u003eData type of a boolean with a (possibly) three-valued logic of TRUE, FALSE, and UNKNOWN.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.BOOLEAN()\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.lang.Boolean\tX\tX\tDefault\nboolean\tX\t(X)\tOutput only if type is not nullable.\nRAW\u003c/p\u003e\n\u003cp\u003eData type of an arbitrary serialized type. This type is a black box within the table ecosystem and is only deserialized at the edges.\u003c/p\u003e\n\u003cp\u003eThe raw type is an extension to the SQL standard.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.RAW(class, serializer)\u003c/p\u003e\n\u003cp\u003eDataTypes.RAW(class)\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\nclass\tX\tX\tOriginating class or subclasses (for input) or\nsuperclasses (for output). Default\nbyte[]\t \tX\t\norg.apache.flink.table.data.RawValueData\tX\tX\tInternal data structure.\nThe type can be declared using RAW(\u0026lsquo;class\u0026rsquo;, \u0026lsquo;snapshot\u0026rsquo;) where class is the originating class and snapshot is the serialized TypeSerializerSnapshot in Base64 encoding. Usually, the type string is not declared directly but is generated while persisting the type.\u003c/p\u003e\n\u003cp\u003eIn the API, the RAW type can be declared either by directly supplying a Class + TypeSerializer or by passing Class and letting the framework extract Class + TypeSerializer from there.\u003c/p\u003e\n\u003cp\u003eNULL\u003c/p\u003e\n\u003cp\u003eData type for representing untyped NULL values.\u003c/p\u003e\n\u003cp\u003eThe null type is an extension to the SQL standard. A null type has no other value except NULL, thus, it can be cast to any nullable type similar to JVM semantics.\u003c/p\u003e\n\u003cp\u003eThis type helps in representing unknown types in API calls that use a NULL literal as well as bridging to formats such as JSON or Avro that define such a type as well.\u003c/p\u003e\n\u003cp\u003eThis type is not very useful in practice and is just mentioned here for completeness.\u003c/p\u003e\n\u003cp\u003eDeclaration\u003c/p\u003e\n\u003cp\u003eSQL\nJava\nScala\nPython\nDataTypes.NULL()\nBridging to JVM Types\u003c/p\u003e\n\u003cp\u003eJava Type\tInput\tOutput\tRemarks\njava.lang.Object\tX\tX\tDefault\nany class\t \t(X)\tAny non-primitive type.\nData Type Extraction\nAt many locations in the API, Flink tries to automatically extract data type from class information using reflection to avoid repetitive manual schema work. However, extracting a data type reflectively is not always successful because logical information might be missing. Therefore, it might be necessary to add additional information close to a class or field declaration for supporting the extraction logic.\u003c/p\u003e\n\u003cp\u003eThe following table lists classes that can be implicitly mapped to a data type without requiring further information.\u003c/p\u003e\n\u003cp\u003eIf you intend to implement classes in Scala, it is recommended to use boxed types (e.g. java.lang.Integer) instead of Scala’s primitives. Scala’s primitives (e.g. Int or Double) are compiled to JVM primitives (e.g. int/double) and result in NOT NULL semantics as shown in the table below. Furthermore, Scala primitives that are used in generics (e.g. java.lang.Map[Int, Double]) are erased during compilation and lead to class information similar to java.lang.Map[java.lang.Object, java.lang.Object].\u003c/p\u003e\n\u003cp\u003eClass\tData Type\njava.lang.String\tSTRING\njava.lang.Boolean\tBOOLEAN\nboolean\tBOOLEAN NOT NULL\njava.lang.Byte\tTINYINT\nbyte\tTINYINT NOT NULL\njava.lang.Short\tSMALLINT\nshort\tSMALLINT NOT NULL\njava.lang.Integer\tINT\nint\tINT NOT NULL\njava.lang.Long\tBIGINT\nlong\tBIGINT NOT NULL\njava.lang.Float\tFLOAT\nfloat\tFLOAT NOT NULL\njava.lang.Double\tDOUBLE\ndouble\tDOUBLE NOT NULL\njava.sql.Date\tDATE\njava.time.LocalDate\tDATE\njava.sql.Time\tTIME(0)\njava.time.LocalTime\tTIME(9)\njava.sql.Timestamp\tTIMESTAMP(9)\njava.time.LocalDateTime\tTIMESTAMP(9)\njava.time.OffsetDateTime\tTIMESTAMP(9) WITH TIME ZONE\njava.time.Instant\tTIMESTAMP(9) WITH LOCAL TIME ZONE\njava.time.Duration\tINVERVAL SECOND(9)\njava.time.Period\tINTERVAL YEAR(4) TO MONTH\nbyte[]\tBYTES\nT[]\tARRAY\u003c!-- raw HTML omitted --\u003e\njava.lang.Map\u0026lt;K, V\u0026gt;\tMAP\u0026lt;K, V\u0026gt;\nstructured type T\tanonymous structured type T\nOther JVM bridging classes mentioned in this document require a @DataTypeHint annotation.\u003c/p\u003e\n\u003cp\u003eData type hints can parameterize or replace the default extraction logic of individual function parameters and return types, structured classes, or fields of structured classes. An implementer can choose to what extent the default extraction logic should be modified by declaring a @DataTypeHint annotation.\u003c/p\u003e\n\u003cp\u003eThe @DataTypeHint annotation provides a set of optional hint parameters. Some of those parameters are shown in the following example. More information can be found in the documentation of the annotation class.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003eorg.apache.flink.table.annotation.DataTypeHint\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eUser\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// defines an INT data type with a default conversion class `java.lang.Integer`\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"nd\"\u003e@DataTypeHint\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;INT\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003eo\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eAnyRef\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// defines a TIMESTAMP data type of millisecond precision with an explicit conversion class\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"nd\"\u003e@DataTypeHint\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evalue\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;TIMESTAMP(3)\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ebridgedTo\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ejava\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esql\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eTimestamp\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eclass\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003eo\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eAnyRef\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// enrich the extraction with forcing using a RAW type\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"nd\"\u003e@DataTypeHint\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;RAW\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emodelClass\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eClass\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// defines that all occurrences of java.math.BigDecimal (also in nested fields) will be\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// extracted as DECIMAL(12, 2)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"nd\"\u003e@DataTypeHint\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edefaultDecimalPrecision\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e12\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003edefaultDecimalScale\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003estmt\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eAccountStatement\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// defines that whenever a type cannot be mapped to a data type, instead of throwing\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// an exception, always treat it as a RAW type\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"nd\"\u003e@DataTypeHint\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eallowRawGlobally\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eHintFlag\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eTRUE\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emodel\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eComplexModel\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","text":"数据类型 由于历史原因，在Flink 1.9之前，Flink的Table \u0026amp; SQL API数据类型与Flink的TypeInformation紧密耦合。TypeInformation在DataStream和DataSet API中使用，足以描述在分布式环境中序列化和反序列化基于JVM的对象所需的所有信息。\n然而，TypeInformation并不是为了表示独立于实际JVM类的逻辑类型而设计的。在过去，很难将SQL标准类型映射到这个抽象中。此外，有些类型不符合SQL标准，而且在引入时没有考虑到更大的情况。\n从Flink 1.9开始，Table \u0026amp; SQL API将获得一个新的类型系统，作为API稳定性和标准合规性的长期解决方案。\n重构类型系统是一项重大的工作，几乎涉及到所有面向用户的界面。因此，它的引入跨越了多个版本，社区的目标是在Flink 1.12之前完成这项工作。\n由于同时增加了一个新的表程序的规划器（见 FLINK-11439），并不是每一个规划器和数据类型的组合都被支持。此外，规划器可能不支持每个数据类型所需的精度或参数。\n请注意。在使用数据类型之前，请查看规划器兼容性表和限制部分。\nData Type 数据类型描述了表生态系统中一个值的逻辑类型。它可以用来声明操作的输入和/或输出类型。\nFlink的数据类型类似于SQL标准的数据类型术语，但也包含了关于值的空性的信息，以便有效处理标量表达式。\n数据类型的例子有：\nINT INT NOT NULL INTERVAL DAY TO SECOND(3) ROW\u0026lt;myField ARRAY\u0026lt;BOOLEAN\u0026gt;, myOtherField TIMESTAMP(3)\u0026gt; 所有预定义数据类型的列表可以在下面找到。\n表API中的数据类型 基于JVM的API的用户在Table API中或在定义连接器、目录或用户定义的函数时，使用org.apache.flink.table.types.DataType的实例工作。\nDataType 实例有两个职责。\n声明一个逻辑类型，它并不意味着传输或存储的具体物理表示，而是定义了基于JVM/python语言和表生态系统之间的边界。 可选。给予规划者关于数据的物理表示的提示，这在其他API的边缘是有用的。 对于基于JVM的语言，所有预定义的数据类型都可以在 org.apache.flink.table.api.DataTypes 中获得。\n建议在你的表程序中添加一个星形导入，以便拥有一个流畅的API。\nimport org.apache.flink.table.api.DataTypes._ val t: DataType = INTERVAL(DAY(), SECOND(3)); 物理提示\n在表生态系统的边缘需要物理提示，在这里，基于SQL的类型系统结束了，需要特定的编程数据类型。提示表示一个实现所期望的数据格式。\n例如，一个数据源可以表示它使用java.sql.Timestamp类而不是使用java.time.LocalDateTime来产生逻辑TIMESTAMPs的值，后者是默认的。有了这些信息，运行时就能够将产生的类转换为其内部的数据格式。作为回报，数据汇可以声明它从运行时消耗的数据格式。\n下面是一些如何声明桥接转换类的例子。\n// tell the runtime to not produce or consume java.time.LocalDateTime instances // but java.sql.Timestamp val t: DataType = DataTypes.TIMESTAMP(3).bridgedTo(classOf[java.sql.Timestamp]); // tell the runtime to not produce or consume boxed integer arrays // but primitive int arrays val t: DataType = DataTypes.ARRAY(DataTypes.INT().notNull()).bridgedTo(classOf[Array[Int]]); 注意 请注意，通常只有当API被扩展时才需要物理提示。预定义源/汇/函数的用户不需要定义这种提示。表程序中的提示（例如field.cast(TIMESTAMP(3).bridgedTo(Timestamp.class))）会被忽略。\n规划师兼容性 如导言中提到的，类型系统的重构将跨越多个版本，对每种数据类型的支持取决于所使用的规划器。本节旨在总结最显著的差异。\n旧的规划器 Flink在Flink 1.9之前推出的老式规划器，主要支持类型信息。它对数据类型的支持有限。可以声明可以转化为类型信息的数据类型，这样旧的规划器就可以理解它们。\n下表总结了数据类型和类型信息的区别。大多数简单类型，以及行类型保持不变。时间类型、数组类型以及十进制类型需要特别注意。其他如上述的提示是不允许的。\n对于类型信息列，表格省略了前缀org.apache.flink.table.api.Types。\n对于数据类型表示一栏，表中省略了前缀org.apache.flink.table.api.DataTypes。\n类型信息 Java Expression String 数据类型表示 数据类型的备注 STRING() STRING STRING() BOOLEAN() BOOLEAN BOOLEAN() BYTE() BYTE TINYINT() SHORT() SHORT SMALLINT() INT() INT INT() LONG() LONG BIGINT() FLOAT() FLOAT FLOAT() DOUBLE() DOUBLE DOUBLE() ROW(\u0026hellip;) ROW\u0026lt;\u0026hellip;\u0026gt; ROW(\u0026hellip;) BIG_DEC() DECIMAL [DECIMAL()] 不是1:1的映射，因为忽略了精度和比例，使用了Java的变量精度和比例。 SQL_DATE() SQL_DATE DATE().bridgedTo(java.sql.Date.class) SQL_TIME() SQL_TIME TIME(0).bridgedTo(java.sql.Time.class) SQL_TIMESTAMP() SQL_TIMESTAMP TIMESTAMP(3).bridgedTo(java.sql.Timestamp.class) INTERVAL_MONTHS() INTERVAL_MONTHS INTERVAL(MONTH()).bridgedTo(Integer.class) INTERVAL_MILLIS() INTERVAL_MILLIS INTERVAL(DataTypes.SECOND(3)).bridgedTo(Long.class) PRIMITIVE_ARRAY(\u0026hellip;) PRIMITIVE_ARRAY\u0026lt;\u0026hellip;\u0026gt; ARRAY(DATATYPE.notNull().bridgedTo(PRIMITIVE.class)) 适用于除byte以外的所有JVM基元类型。 PRIMITIVE_ARRAY(BYTE()) PRIMITIVE_ARRAY BYTES() OBJECT_ARRAY(\u0026hellip;) OBJECT_ARRAY\u0026lt;\u0026hellip;\u0026gt;\tARRAY(DATATYPE.bridgedTo(OBJECT.class)) MULTISET(\u0026hellip;) MULTISET(\u0026hellip;) MAP(\u0026hellip;, \u0026hellip;) MAP\u0026lt;\u0026hellip;,\u0026hellip;\u0026gt; MAP(\u0026hellip;) other generic types RAW(\u0026hellip;) 注意 如果新的类型系统出现问题。用户可以随时回退到 org.apache.flink.table.api.Types 中定义的类型信息。\n新的 Blink 计划器 新的Blink计划器支持旧计划器的所有类型。这特别包括列出的Java表达式字符串和类型信息。\n支持以下数据类型。\nData Type Remarks for Data Type STRING 还不支持 CHAR 和 VARCHAR BOOLEAN BYTES 还不支持 BINARY 和 VARBINARY DECIMAL 支持固定精度和比例。 TINYINT SMALLINT INTEGER BIGINT FLOAT DOUBLE DATE TIME 只支持精度为0。 TIMESTAMP TIMESTAMP WITH LOCAL TIME ZONE INTERVAL 只支持MONTH和SECOND(3)的间隔。 ARRAY MULTISET MAP ROW RAW stuctured types 目前只在用户定义的函数中暴露。 局限性 Java表达式字符串。表API中的Java表达式字符串，如table.select(\u0026ldquo;field.cast(STRING)\u0026quot;)还没有更新到新的类型系统。请使用旧计划器部分中声明的字符串表示法。\n用户定义的函数。用户定义的集合函数还不能声明数据类型。标量函数和表函数完全支持数据类型。\n数据类型列表 本节列出了所有预定义的数据类型。\n对于基于JVM的Table API，这些类型也可以在org.apache.flink.table.api.DataTypes中找到。\n字符字符串 CHAR\n一个固定长度的字符串的数据类型。\n声明\n-- sql CHAR CHAR(n) DataTypes.CHAR(n) 桥接到JVM类型\nJava Type Input Output Remarks java.lang.String X X Default byte[] X X Assumes UTF-8 encoding. org.apache.flink.table.data.StringData X X Internal data structure. n的值必须在1和2,147,483,647之间(包括两者)。如果没有指定长度，n等于1。\nVARCHAR / STRING\n可变长度的字符串的数据类型。\n声明\nDataTypes.VARCHAR(n) DataTypes.STRING() Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.lang.String\tX\tX\tDefault byte[]\tX\tX\tAssumes UTF-8 encoding. org.apache.flink.table.data.StringData\tX\tX\tInternal data structure. The type can be declared using VARCHAR(n) where n is the maximum number of code points. n must have a value between 1 and 2,147,483,647 (both inclusive). If no length is specified, n is equal to 1.\nSTRING is a synonym for VARCHAR(2147483647).\nBinary Strings BINARY\nData type of a fixed-length binary string (=a sequence of bytes).\nDeclaration\nSQL Java Scala Python DataTypes.BINARY(n) Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks byte[]\tX\tX\tDefault The type can be declared using BINARY(n) where n is the number of bytes. n must have a value between 1 and 2,147,483,647 (both inclusive). If no length is specified, n is equal to 1.\nVARBINARY / BYTES\nData type of a variable-length binary string (=a sequence of bytes).\nDeclaration\nSQL Java Scala Python DataTypes.VARBINARY(n)\nDataTypes.BYTES() Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks byte[]\tX\tX\tDefault The type can be declared using VARBINARY(n) where n is the maximum number of bytes. n must have a value between 1 and 2,147,483,647 (both inclusive). If no length is specified, n is equal to 1.\nBYTES is a synonym for VARBINARY(2147483647).\nExact Numerics DECIMAL\nData type of a decimal number with fixed precision and scale.\nDeclaration\nSQL Java Scala Python DataTypes.DECIMAL(p, s) Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.math.BigDecimal\tX\tX\tDefault org.apache.flink.table.data.DecimalData\tX\tX\tInternal data structure. The type can be declared using DECIMAL(p, s) where p is the number of digits in a number (precision) and s is the number of digits to the right of the decimal point in a number (scale). p must have a value between 1 and 38 (both inclusive). s must have a value between 0 and p (both inclusive). The default value for p is 10. The default value for s is 0.\nNUMERIC(p, s) and DEC(p, s) are synonyms for this type.\nTINYINT\nData type of a 1-byte signed integer with values from -128 to 127.\nDeclaration\nSQL Java Scala Python DataTypes.TINYINT() Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.lang.Byte\tX\tX\tDefault byte\tX\t(X)\tOutput only if type is not nullable. SMALLINT\nData type of a 2-byte signed integer with values from -32,768 to 32,767.\nDeclaration\nSQL Java Scala Python DataTypes.SMALLINT() Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.lang.Short\tX\tX\tDefault short\tX\t(X)\tOutput only if type is not nullable. INT\nData type of a 4-byte signed integer with values from -2,147,483,648 to 2,147,483,647.\nDeclaration\nSQL Java Scala Python DataTypes.INT() Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.lang.Integer\tX\tX\tDefault int\tX\t(X)\tOutput only if type is not nullable. INTEGER is a synonym for this type.\nBIGINT\nData type of an 8-byte signed integer with values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.\nDeclaration\nSQL Java Scala Python DataTypes.BIGINT() Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.lang.Long\tX\tX\tDefault long\tX\t(X)\tOutput only if type is not nullable. Approximate Numerics FLOAT\nData type of a 4-byte single precision floating point number.\nCompared to the SQL standard, the type does not take parameters.\nDeclaration\nSQL Java Scala Python DataTypes.FLOAT() Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.lang.Float\tX\tX\tDefault float\tX\t(X)\tOutput only if type is not nullable. DOUBLE\nData type of an 8-byte double precision floating point number.\nDeclaration\nSQL Java Scala Python DataTypes.DOUBLE() Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.lang.Double\tX\tX\tDefault double\tX\t(X)\tOutput only if type is not nullable. DOUBLE PRECISION is a synonym for this type.\nDate and Time DATE\nData type of a date consisting of year-month-day with values ranging from 0000-01-01 to 9999-12-31.\nCompared to the SQL standard, the range starts at year 0000.\nDeclaration\nSQL Java Scala Python DataTypes.DATE() Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.time.LocalDate\tX\tX\tDefault java.sql.Date\tX\tX\tjava.lang.Integer\tX\tX\tDescribes the number of days since epoch. int\tX\t(X)\tDescribes the number of days since epoch. Output only if type is not nullable. TIME\nData type of a time without time zone consisting of hour:minute:second[.fractional] with up to nanosecond precision and values ranging from 00:00:00.000000000 to 23:59:59.999999999.\nCompared to the SQL standard, leap seconds (23:59:60 and 23:59:61) are not supported as the semantics are closer to java.time.LocalTime. A time with time zone is not provided.\nDeclaration\nSQL Java Scala Python DataTypes.TIME(p) Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.time.LocalTime\tX\tX\tDefault java.sql.Time\tX\tX\tjava.lang.Integer\tX\tX\tDescribes the number of milliseconds of the day. int\tX\t(X)\tDescribes the number of milliseconds of the day. Output only if type is not nullable. java.lang.Long\tX\tX\tDescribes the number of nanoseconds of the day. long\tX\t(X)\tDescribes the number of nanoseconds of the day. Output only if type is not nullable. The type can be declared using TIME(p) where p is the number of digits of fractional seconds (precision). p must have a value between 0 and 9 (both inclusive). If no precision is specified, p is equal to 0.\nTIMESTAMP\nData type of a timestamp without time zone consisting of year-month-day hour:minute:second[.fractional] with up to nanosecond precision and values ranging from 0000-01-01 00:00:00.000000000 to 9999-12-31 23:59:59.999999999.\nCompared to the SQL standard, leap seconds (23:59:60 and 23:59:61) are not supported as the semantics are closer to java.time.LocalDateTime.\nA conversion from and to BIGINT (a JVM long type) is not supported as this would imply a time zone. However, this type is time zone free. For more java.time.Instant-like semantics use TIMESTAMP WITH LOCAL TIME ZONE.\nDeclaration\nSQL Java Scala Python DataTypes.TIMESTAMP(p) Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.time.LocalDateTime\tX\tX\tDefault java.sql.Timestamp\tX\tX\torg.apache.flink.table.data.TimestampData\tX\tX\tInternal data structure. The type can be declared using TIMESTAMP(p) where p is the number of digits of fractional seconds (precision). p must have a value between 0 and 9 (both inclusive). If no precision is specified, p is equal to 6.\nTIMESTAMP(p) WITHOUT TIME ZONE is a synonym for this type.\nTIMESTAMP WITH TIME ZONE\nData type of a timestamp with time zone consisting of year-month-day hour:minute:second[.fractional] zone with up to nanosecond precision and values ranging from 0000-01-01 00:00:00.000000000 +14:59 to 9999-12-31 23:59:59.999999999 -14:59.\nCompared to the SQL standard, leap seconds (23:59:60 and 23:59:61) are not supported as the semantics are closer to java.time.OffsetDateTime.\nCompared to TIMESTAMP WITH LOCAL TIME ZONE, the time zone offset information is physically stored in every datum. It is used individually for every computation, visualization, or communication to external systems.\nDeclaration\nSQL Java Scala Python DataTypes.TIMESTAMP_WITH_TIME_ZONE(p) Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.time.OffsetDateTime\tX\tX\tDefault java.time.ZonedDateTime\tX\tIgnores the zone ID. The type can be declared using TIMESTAMP(p) WITH TIME ZONE where p is the number of digits of fractional seconds (precision). p must have a value between 0 and 9 (both inclusive). If no precision is specified, p is equal to 6.\nTIMESTAMP WITH LOCAL TIME ZONE\nData type of a timestamp with local time zone consisting of year-month-day hour:minute:second[.fractional] zone with up to nanosecond precision and values ranging from 0000-01-01 00:00:00.000000000 +14:59 to 9999-12-31 23:59:59.999999999 -14:59.\nLeap seconds (23:59:60 and 23:59:61) are not supported as the semantics are closer to java.time.OffsetDateTime.\nCompared to TIMESTAMP WITH TIME ZONE, the time zone offset information is not stored physically in every datum. Instead, the type assumes java.time.Instant semantics in UTC time zone at the edges of the table ecosystem. Every datum is interpreted in the local time zone configured in the current session for computation and visualization.\nThis type fills the gap between time zone free and time zone mandatory timestamp types by allowing the interpretation of UTC timestamps according to the configured session time zone.\nDeclaration\nSQL Java Scala Python DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE(p) Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.time.Instant\tX\tX\tDefault java.lang.Integer\tX\tX\tDescribes the number of seconds since epoch. int\tX\t(X)\tDescribes the number of seconds since epoch. Output only if type is not nullable. java.lang.Long\tX\tX\tDescribes the number of milliseconds since epoch. long\tX\t(X)\tDescribes the number of milliseconds since epoch. Output only if type is not nullable. org.apache.flink.table.data.TimestampData\tX\tX\tInternal data structure. The type can be declared using TIMESTAMP(p) WITH LOCAL TIME ZONE where p is the number of digits of fractional seconds (precision). p must have a value between 0 and 9 (both inclusive). If no precision is specified, p is equal to 6.\nINTERVAL YEAR TO MONTH\nData type for a group of year-month interval types.\nThe type must be parameterized to one of the following resolutions:\ninterval of years, interval of years to months, or interval of months. An interval of year-month consists of +years-months with values ranging from -9999-11 to +9999-11.\nThe value representation is the same for all types of resolutions. For example, an interval of months of 50 is always represented in an interval-of-years-to-months format (with default year precision): +04-02.\nDeclaration\nSQL Java Scala Python DataTypes.INTERVAL(DataTypes.YEAR()) DataTypes.INTERVAL(DataTypes.YEAR(p)) DataTypes.INTERVAL(DataTypes.YEAR(p), DataTypes.MONTH()) DataTypes.INTERVAL(DataTypes.MONTH()) Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.time.Period\tX\tX\tIgnores the days part. Default java.lang.Integer\tX\tX\tDescribes the number of months. int\tX\t(X)\tDescribes the number of months. Output only if type is not nullable. The type can be declared using the above combinations where p is the number of digits of years (year precision). p must have a value between 1 and 4 (both inclusive). If no year precision is specified, p is equal to 2.\nINTERVAL DAY TO SECOND\nData type for a group of day-time interval types.\nThe type must be parameterized to one of the following resolutions with up to nanosecond precision:\ninterval of days, interval of days to hours, interval of days to minutes, interval of days to seconds, interval of hours, interval of hours to minutes, interval of hours to seconds, interval of minutes, interval of minutes to seconds, or interval of seconds. An interval of day-time consists of +days hours:months:seconds.fractional with values ranging from -999999 23:59:59.999999999 to +999999 23:59:59.999999999. The value representation is the same for all types of resolutions. For example, an interval of seconds of 70 is always represented in an interval-of-days-to-seconds format (with default precisions): +00 00:01:10.000000.\nDeclaration\nSQL Java Scala Python DataTypes.INTERVAL(DataTypes.DAY()) DataTypes.INTERVAL(DataTypes.DAY(p1)) DataTypes.INTERVAL(DataTypes.DAY(p1), DataTypes.HOUR()) DataTypes.INTERVAL(DataTypes.DAY(p1), DataTypes.MINUTE()) DataTypes.INTERVAL(DataTypes.DAY(p1), DataTypes.SECOND(p2)) DataTypes.INTERVAL(DataTypes.HOUR()) DataTypes.INTERVAL(DataTypes.HOUR(), DataTypes.MINUTE()) DataTypes.INTERVAL(DataTypes.HOUR(), DataTypes.SECOND(p2)) DataTypes.INTERVAL(DataTypes.MINUTE()) DataTypes.INTERVAL(DataTypes.MINUTE(), DataTypes.SECOND(p2)) DataTypes.INTERVAL(DataTypes.SECOND()) DataTypes.INTERVAL(DataTypes.SECOND(p2)) Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.time.Duration\tX\tX\tDefault java.lang.Long\tX\tX\tDescribes the number of milliseconds. long\tX\t(X)\tDescribes the number of milliseconds. Output only if type is not nullable. The type can be declared using the above combinations where p1 is the number of digits of days (day precision) and p2 is the number of digits of fractional seconds (fractional precision). p1 must have a value between 1 and 6 (both inclusive). p2 must have a value between 0 and 9 (both inclusive). If no p1 is specified, it is equal to 2 by default. If no p2 is specified, it is equal to 6 by default.\nConstructured Data Types ARRAY\nData type of an array of elements with same subtype.\nCompared to the SQL standard, the maximum cardinality of an array cannot be specified but is fixed at 2,147,483,647. Also, any valid type is supported as a subtype.\nDeclaration\nSQL Java Scala Python DataTypes.ARRAY(t) Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks t[]\t(X)\t(X)\tDepends on the subtype. Default org.apache.flink.table.data.ArrayData\tX\tX\tInternal data structure. The type can be declared using ARRAY where t is the data type of the contained elements.\nt ARRAY is a synonym for being closer to the SQL standard. For example, INT ARRAY is equivalent to ARRAY.\nMAP\nData type of an associative array that maps keys (including NULL) to values (including NULL). A map cannot contain duplicate keys; each key can map to at most one value.\nThere is no restriction of element types; it is the responsibility of the user to ensure uniqueness.\nThe map type is an extension to the SQL standard.\nDeclaration\nSQL Java Scala Python DataTypes.MAP(kt, vt) Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.util.Map\u0026lt;kt, vt\u0026gt;\tX\tX\tDefault subclass of java.util.Map\u0026lt;kt, vt\u0026gt;\tX\torg.apache.flink.table.data.MapData\tX\tX\tInternal data structure. The type can be declared using MAP\u0026lt;kt, vt\u0026gt; where kt is the data type of the key elements and vt is the data type of the value elements.\nMULTISET\nData type of a multiset (=bag). Unlike a set, it allows for multiple instances for each of its elements with a common subtype. Each unique value (including NULL) is mapped to some multiplicity.\nThere is no restriction of element types; it is the responsibility of the user to ensure uniqueness.\nDeclaration\nSQL Java Scala Python DataTypes.MULTISET(t) Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.util.Map\u0026lt;t, java.lang.Integer\u0026gt;\tX\tX\tAssigns each value to an integer multiplicity. Default subclass of java.util.Map\u0026lt;t, java.lang.Integer\u0026raquo;\tX\torg.apache.flink.table.data.MapData\tX\tX\tInternal data structure. The type can be declared using MULTISET where t is the data type of the contained elements.\nt MULTISET is a synonym for being closer to the SQL standard. For example, INT MULTISET is equivalent to MULTISET.\nROW\nData type of a sequence of fields.\nA field consists of a field name, field type, and an optional description. The most specific type of a row of a table is a row type. In this case, each column of the row corresponds to the field of the row type that has the same ordinal position as the column.\nCompared to the SQL standard, an optional field description simplifies the handling with complex structures.\nA row type is similar to the STRUCT type known from other non-standard-compliant frameworks.\nDeclaration\nSQL Java Scala Python DataTypes.ROW(DataTypes.FIELD(n0, t0), DataTypes.FIELD(n1, t1), \u0026hellip;) DataTypes.ROW(DataTypes.FIELD(n0, t0, d0), DataTypes.FIELD(n1, t1, d1), \u0026hellip;) Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks org.apache.flink.types.Row\tX\tX\tDefault org.apache.flink.table.data.RowData\tX\tX\tInternal data structure. The type can be declared using ROW\u0026lt;n0 t0 \u0026lsquo;d0\u0026rsquo;, n1 t1 \u0026lsquo;d1\u0026rsquo;, \u0026hellip;\u0026gt; where n is the unique name of a field, t is the logical type of a field, d is the description of a field.\nROW(\u0026hellip;) is a synonym for being closer to the SQL standard. For example, ROW(myField INT, myOtherField BOOLEAN) is equivalent to ROW\u0026lt;myField INT, myOtherField BOOLEAN\u0026gt;.\nUser-Defined Data Types Attention User-defined data types are not fully supported yet. They are currently (as of Flink 1.11) only exposed as unregistered structured types in parameters and return types of functions.\nA structured type is similar to an object in an object-oriented programming language. It contains zero, one or more attributes. Each attribute consists of a name and a type.\nThere are two kinds of structured types:\nTypes that are stored in a catalog and are identified by a catalog identifer (like cat.db.MyType). Those are equal to the SQL standard definition of structured types.\nAnonymously defined, unregistered types (usually reflectively extracted) that are identified by an implementation class (like com.myorg.model.MyType). Those are useful when programmatically defining a table program. They enable reusing existing JVM classes without manually defining the schema of a data type again.\nRegistered Structured Types\nCurrently, registered structured types are not supported. Thus, they cannot be stored in a catalog or referenced in a CREATE TABLE DDL.\nUnregistered Structured Types\nUnregistered structured types can be created from regular POJOs (Plain Old Java Objects) using automatic reflective extraction.\nThe implementation class of a structured type must meet the following requirements:\nThe class must be globally accessible which means it must be declared public, static, and not abstract. The class must offer a default constructor with zero arguments or a full constructor that assigns all fields. All fields of the class must be readable by either public declaration or a getter that follows common coding style such as getField(), isField(), field(). All fields of the class must be writable by either public declaration, fully assigning constructor, or a setter that follows common coding style such as setField(\u0026hellip;), field(\u0026hellip;). All fields must be mapped to a data type either implicitly via reflective extraction or explicitly using the @DataTypeHint annotations. Fields that are declared static or transient are ignored. The reflective extraction supports arbitrary nesting of fields as long as a field type does not (transitively) refer to itself.\nThe declared field class (e.g. public int age;) must be contained in the list of supported JVM bridging classes defined for every data type in this document (e.g. java.lang.Integer or int for INT).\nFor some classes an annotation is required in order to map the class to a data type (e.g. @DataTypeHint(\u0026ldquo;DECIMAL(10, 2)\u0026rdquo;) to assign a fixed precision and scale for java.math.BigDecimal).\nDeclaration\nJava Scala Python case class User(\n// extract fields automatically age: Int, name: String, // enrich the extraction with precision information @DataTypeHint(\u0026quot;DECIMAL(10, 2)\u0026quot;) totalBalance: java.math.BigDecimal, // enrich the extraction with forcing using a RAW type @DataTypeHint(\u0026quot;RAW\u0026quot;) modelClass: Class[_] )\nDataTypes.of(classOf[User]) Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks class\tX\tX\tOriginating class or subclasses (for input) or superclasses (for output). Default org.apache.flink.types.Row\tX\tX\tRepresent the structured type as a row. org.apache.flink.table.data.RowData\tX\tX\tInternal data structure. Other Data Types BOOLEAN\nData type of a boolean with a (possibly) three-valued logic of TRUE, FALSE, and UNKNOWN.\nDeclaration\nSQL Java Scala Python DataTypes.BOOLEAN() Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.lang.Boolean\tX\tX\tDefault boolean\tX\t(X)\tOutput only if type is not nullable. RAW\nData type of an arbitrary serialized type. This type is a black box within the table ecosystem and is only deserialized at the edges.\nThe raw type is an extension to the SQL standard.\nDeclaration\nSQL Java Scala Python DataTypes.RAW(class, serializer)\nDataTypes.RAW(class) Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks class\tX\tX\tOriginating class or subclasses (for input) or superclasses (for output). Default byte[]\tX\torg.apache.flink.table.data.RawValueData\tX\tX\tInternal data structure. The type can be declared using RAW(\u0026lsquo;class\u0026rsquo;, \u0026lsquo;snapshot\u0026rsquo;) where class is the originating class and snapshot is the serialized TypeSerializerSnapshot in Base64 encoding. Usually, the type string is not declared directly but is generated while persisting the type.\nIn the API, the RAW type can be declared either by directly supplying a Class + TypeSerializer or by passing Class and letting the framework extract Class + TypeSerializer from there.\nNULL\nData type for representing untyped NULL values.\nThe null type is an extension to the SQL standard. A null type has no other value except NULL, thus, it can be cast to any nullable type similar to JVM semantics.\nThis type helps in representing unknown types in API calls that use a NULL literal as well as bridging to formats such as JSON or Avro that define such a type as well.\nThis type is not very useful in practice and is just mentioned here for completeness.\nDeclaration\nSQL Java Scala Python DataTypes.NULL() Bridging to JVM Types\nJava Type\tInput\tOutput\tRemarks java.lang.Object\tX\tX\tDefault any class\t(X)\tAny non-primitive type. Data Type Extraction At many locations in the API, Flink tries to automatically extract data type from class information using reflection to avoid repetitive manual schema work. However, extracting a data type reflectively is not always successful because logical information might be missing. Therefore, it might be necessary to add additional information close to a class or field declaration for supporting the extraction logic.\nThe following table lists classes that can be implicitly mapped to a data type without requiring further information.\nIf you intend to implement classes in Scala, it is recommended to use boxed types (e.g. java.lang.Integer) instead of Scala’s primitives. Scala’s primitives (e.g. Int or Double) are compiled to JVM primitives (e.g. int/double) and result in NOT NULL semantics as shown in the table below. Furthermore, Scala primitives that are used in generics (e.g. java.lang.Map[Int, Double]) are erased during compilation and lead to class information similar to java.lang.Map[java.lang.Object, java.lang.Object].\nClass\tData Type java.lang.String\tSTRING java.lang.Boolean\tBOOLEAN boolean\tBOOLEAN NOT NULL java.lang.Byte\tTINYINT byte\tTINYINT NOT NULL java.lang.Short\tSMALLINT short\tSMALLINT NOT NULL java.lang.Integer\tINT int\tINT NOT NULL java.lang.Long\tBIGINT long\tBIGINT NOT NULL java.lang.Float\tFLOAT float\tFLOAT NOT NULL java.lang.Double\tDOUBLE double\tDOUBLE NOT NULL java.sql.Date\tDATE java.time.LocalDate\tDATE java.sql.Time\tTIME(0) java.time.LocalTime\tTIME(9) java.sql.Timestamp\tTIMESTAMP(9) java.time.LocalDateTime\tTIMESTAMP(9) java.time.OffsetDateTime\tTIMESTAMP(9) WITH TIME ZONE java.time.Instant\tTIMESTAMP(9) WITH LOCAL TIME ZONE java.time.Duration\tINVERVAL SECOND(9) java.time.Period\tINTERVAL YEAR(4) TO MONTH byte[]\tBYTES T[]\tARRAY java.lang.Map\u0026lt;K, V\u0026gt;\tMAP\u0026lt;K, V\u0026gt; structured type T\tanonymous structured type T Other JVM bridging classes mentioned in this document require a @DataTypeHint annotation.\nData type hints can parameterize or replace the default extraction logic of individual function parameters and return types, structured classes, or fields of structured classes. An implementer can choose to what extent the default extraction logic should be modified by declaring a @DataTypeHint annotation.\nThe @DataTypeHint annotation provides a set of optional hint parameters. Some of those parameters are shown in the following example. More information can be found in the documentation of the annotation class.\nimport org.apache.flink.table.annotation.DataTypeHint class User { // defines an INT data type with a default conversion class `java.lang.Integer` @DataTypeHint(\u0026#34;INT\u0026#34;) var o: AnyRef // defines a TIMESTAMP data type of millisecond precision with an explicit conversion class @DataTypeHint(value = \u0026#34;TIMESTAMP(3)\u0026#34;, bridgedTo = java.sql.Timestamp.class) var o: AnyRef // enrich the extraction with forcing using a RAW type @DataTypeHint(\u0026#34;RAW\u0026#34;) var modelClass: Class[_] // defines that all occurrences of java.math.BigDecimal (also in nested fields) will be // extracted as DECIMAL(12, 2) @DataTypeHint(defaultDecimalPrecision = 12, defaultDecimalScale = 2) var stmt: AccountStatement // defines that whenever a type cannot be mapped to a data type, instead of throwing // an exception, always treat it as a RAW type @DataTypeHint(allowRawGlobally = HintFlag.TRUE) var model: ComplexModel } "},"name":"数据类型","published":"2020-08-22T00:00:00Z","summary":"Data Types","type":"entry","url":"http://localhost:1313/notes/2020-08-22-data-types/"}