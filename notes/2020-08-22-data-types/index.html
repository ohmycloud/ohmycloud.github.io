<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
    
    
    

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    
    <meta name="referrer" content="no-referrer">

    <title>
        
            数据类型 ❚ 焉知非鱼
        
    </title>

    
    


    
    
    
    

    
    
    
    

    
    
    

    
    
    
    <style>
     
     
     :root {
         --theme-color: #ac4142;
         --theme-color-light: rgba(172, 65, 66, 0.2);
     }
     
     html {
         line-height: 1.5;
     }
    </style>

    
    

    
    
    
    
    <link rel="stylesheet" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css">
    
    <link rel="preload" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css" as="style">

    



    
        <style>
         
         /* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }

         
         /* Overrides on top of the theme and Chroma CSS */
/* Chroma-based lines highlighting in code blocks */
.chroma .hl {
    background-color: #e8e8e8;
    /* Extend highlight up to 100 characters (assuming that the code blocks never have more than 100 characters in a line) */
    min-width: 100ch;
}
/* GenericHeading */ .chroma .gh { color: #999999; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa; font-weight: bold }

         
        </style>
    

    

    
    
    

    
    <script src="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js"></script>
    
    <link rel="preload" href="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js" as="script">

    
    
    <script defer src="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js"></script>
    
    <link rel="preload" href="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js" as="script">

    

    

    
    
    

    
    
<!-- rel="me" links for IndieAuth -->







    
 
<meta property="og:title" content="数据类型" />
<meta property="og:description"
      content="Data Types" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/notes/2020-08-22-data-types/" />


    
        <meta property="article:published_time" content="2020-08-22T00:00:00&#43;00:00"/>
    
    
        <meta property="article:modified_time" content="2020-08-22T00:00:00&#43;00:00"/>
    









    




     <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="数据类型"/>
<meta name="twitter:description" content="Data Types"/>


    
    
    <link rel="alternate" type="application/jf2post+json" href="http://localhost:1313/notes/2020-08-22-data-types/jf2post.json" title="Jf2post for 焉知非鱼" />
    
     



    
    
    
        
    


     
        
        <meta name="DC.Creator" content="焉知非鱼"/>
    



    
    
    
    <meta name="hugo-build-date" content="2024-03-01T16:16:06Z"/>
    <meta name="hugo-commit-hash" content="312735366b20d64bd61bff8627f593749f86c964"/>
    <meta name="generator" content="Hugo 0.123.7">
</head>


    
        <body lang="en">
    

        
        <div class="border" id="home"></div>

        <div class="wrapper">   
            
<nav id="nav" class="nav-collapse opened" aria-hidden="false">
    <ul class="navbar">
        <li><a class="" href="/">Home</a></li>
        
            
                <li><a class="" href="http://localhost:1313/posts/">Posts</a></li>
            
        
            
                <li><a class="" href="http://localhost:1313/notes/">Notes</a></li>
            
        
            
                <li><a class="" href="http://localhost:1313/raku/">Raku</a></li>
            
        
        
            <li><a class="" href="http://localhost:1313/search/">Search</a></li>
        
    </ul>
</nav>

            <div class="container">
                <header class="masthead">
                    <div class="masthead-title no-text-decoration">
                        <a href="/">焉知非鱼</a> <span class="blinking-cursor">❚</span>
                    </div>
                    <div class="masthead-tagline">
                        Wait the light to fall
                    </div>
                </header>

                






    <div class="draft right">Draft</div>
    <div class="clear-float"></div>



<article class="post h-entry notes">
    <header>
        <div class="center">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 0 posts categorized in ‘Flink’"
                                
                            >
                                <a class="p-category" href="http://localhost:1313/categories/flink/">Flink</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 0 posts tagged with ‘Flink’"
                                
                            >
                                <a class="p-category" href="http://localhost:1313/tags/flink/">Flink</a>
                            </li>
                        
                    
                        
                        
                        
                    
                        
                        
                        
                    
                </ul>
            
        
    </div>

</div>

        <h1 class="post-title p-name">数据类型</h1>

        
        <data class="u-url" value="http://localhost:1313/notes/2020-08-22-data-types/"></data>

        <div class="date-syndication">
            


    
    
    <div class="post-date">
        
        <time datetime="2020-08-22T00:00:00+0000" class="dt-published">Sat Aug 22, 2020</time>
        
        
    </div>


            




        </div>
         



    
    
    
        
    


    
        
        <span class="hide">
            &mdash; <a href="http://localhost:1313/" class="u-author">焉知非鱼</a>
        </span>
    


    </header>

    <div class="content">
        
    <div class="description p-summary">
        
        
        
        
        
            
            
        
        <p>Data Types</p>
    </div>



        





                       


        <div class="e-content">
            




<h1 id="数据类型">数据类型</h1>
<p>由于历史原因，在Flink 1.9之前，Flink的Table &amp; SQL API数据类型与Flink的TypeInformation紧密耦合。TypeInformation在DataStream和DataSet API中使用，足以描述在分布式环境中序列化和反序列化基于JVM的对象所需的所有信息。</p>
<p>然而，TypeInformation并不是为了表示独立于实际JVM类的逻辑类型而设计的。在过去，很难将SQL标准类型映射到这个抽象中。此外，有些类型不符合SQL标准，而且在引入时没有考虑到更大的情况。</p>
<p>从Flink 1.9开始，Table &amp; SQL API将获得一个新的类型系统，作为API稳定性和标准合规性的长期解决方案。</p>
<p>重构类型系统是一项重大的工作，几乎涉及到所有面向用户的界面。因此，它的引入跨越了多个版本，社区的目标是在Flink 1.12之前完成这项工作。</p>
<p>由于同时增加了一个新的表程序的规划器（见 <a href="https://issues.apache.org/jira/browse/FLINK-11439">FLINK-11439</a>），并不是每一个规划器和数据类型的组合都被支持。此外，规划器可能不支持每个数据类型所需的精度或参数。</p>
<p>请注意。在使用数据类型之前，请查看规划器兼容性表和限制部分。</p>
<h2 id="data-type">Data Type&nbsp;<a class="headline-hash no-text-decoration" href="#data-type">#</a> </h2>
<p>数据类型描述了表生态系统中一个值的逻辑类型。它可以用来声明操作的输入和/或输出类型。</p>
<p>Flink的数据类型类似于SQL标准的数据类型术语，但也包含了关于值的空性的信息，以便有效处理标量表达式。</p>
<p>数据类型的例子有：</p>
<ul>
<li>INT</li>
<li>INT NOT NULL</li>
<li>INTERVAL DAY TO SECOND(3)</li>
<li><code>ROW&lt;myField ARRAY&lt;BOOLEAN&gt;, myOtherField TIMESTAMP(3)&gt;</code></li>
</ul>
<p>所有预定义数据类型的列表可以在下面找到。</p>
<p>表API中的数据类型
基于JVM的API的用户在Table API中或在定义连接器、目录或用户定义的函数时，使用org.apache.flink.table.types.DataType的实例工作。</p>
<p>DataType 实例有两个职责。</p>
<ul>
<li>声明一个逻辑类型，它并不意味着传输或存储的具体物理表示，而是定义了基于JVM/python语言和表生态系统之间的边界。</li>
<li>可选。给予规划者关于数据的物理表示的提示，这在其他API的边缘是有用的。</li>
</ul>
<p>对于基于JVM的语言，所有预定义的数据类型都可以在 <code>org.apache.flink.table.api.DataTypes</code> 中获得。</p>
<p>建议在你的表程序中添加一个星形导入，以便拥有一个流畅的API。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">import</span> <span class="nn">org.apache.flink.table.api.DataTypes._</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">t</span><span class="k">:</span> <span class="kt">DataType</span> <span class="o">=</span> <span class="nc">INTERVAL</span><span class="o">(</span><span class="nc">DAY</span><span class="o">(),</span> <span class="nc">SECOND</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>
</span></span></code></pre></div><p>物理提示</p>
<p>在表生态系统的边缘需要物理提示，在这里，基于SQL的类型系统结束了，需要特定的编程数据类型。提示表示一个实现所期望的数据格式。</p>
<p>例如，一个数据源可以表示它使用java.sql.Timestamp类而不是使用java.time.LocalDateTime来产生逻辑TIMESTAMPs的值，后者是默认的。有了这些信息，运行时就能够将产生的类转换为其内部的数据格式。作为回报，数据汇可以声明它从运行时消耗的数据格式。</p>
<p>下面是一些如何声明桥接转换类的例子。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="c1">// tell the runtime to not produce or consume java.time.LocalDateTime instances
</span></span></span><span class="line"><span class="cl"><span class="c1">// but java.sql.Timestamp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">t</span><span class="k">:</span> <span class="kt">DataType</span> <span class="o">=</span> <span class="nc">DataTypes</span><span class="o">.</span><span class="nc">TIMESTAMP</span><span class="o">(</span><span class="mi">3</span><span class="o">).</span><span class="n">bridgedTo</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">java.sql.Timestamp</span><span class="o">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// tell the runtime to not produce or consume boxed integer arrays
</span></span></span><span class="line"><span class="cl"><span class="c1">// but primitive int arrays
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">t</span><span class="k">:</span> <span class="kt">DataType</span> <span class="o">=</span> <span class="nc">DataTypes</span><span class="o">.</span><span class="nc">ARRAY</span><span class="o">(</span><span class="nc">DataTypes</span><span class="o">.</span><span class="nc">INT</span><span class="o">().</span><span class="n">notNull</span><span class="o">()).</span><span class="n">bridgedTo</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]);</span>
</span></span></code></pre></div><p>注意 请注意，通常只有当API被扩展时才需要物理提示。预定义源/汇/函数的用户不需要定义这种提示。表程序中的提示（例如field.cast(TIMESTAMP(3).bridgedTo(Timestamp.class))）会被忽略。</p>
<p>规划师兼容性
如导言中提到的，类型系统的重构将跨越多个版本，对每种数据类型的支持取决于所使用的规划器。本节旨在总结最显著的差异。</p>
<p>旧的规划器
Flink在Flink 1.9之前推出的老式规划器，主要支持类型信息。它对数据类型的支持有限。可以声明可以转化为类型信息的数据类型，这样旧的规划器就可以理解它们。</p>
<p>下表总结了数据类型和类型信息的区别。大多数简单类型，以及行类型保持不变。时间类型、数组类型以及十进制类型需要特别注意。其他如上述的提示是不允许的。</p>
<p>对于类型信息列，表格省略了前缀org.apache.flink.table.api.Types。</p>
<p>对于数据类型表示一栏，表中省略了前缀org.apache.flink.table.api.DataTypes。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型信息</th>
<th style="text-align:left">Java Expression String</th>
<th style="text-align:left">数据类型表示</th>
<th style="text-align:left">数据类型的备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">STRING()</td>
<td style="text-align:left">STRING</td>
<td style="text-align:left">STRING()</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">BOOLEAN()</td>
<td style="text-align:left">BOOLEAN</td>
<td style="text-align:left">BOOLEAN()</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">BYTE()</td>
<td style="text-align:left">BYTE</td>
<td style="text-align:left">TINYINT()</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">SHORT()</td>
<td style="text-align:left">SHORT</td>
<td style="text-align:left">SMALLINT()</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">INT()</td>
<td style="text-align:left">INT</td>
<td style="text-align:left">INT()</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">LONG()</td>
<td style="text-align:left">LONG</td>
<td style="text-align:left">BIGINT()</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">FLOAT()</td>
<td style="text-align:left">FLOAT</td>
<td style="text-align:left">FLOAT()</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">DOUBLE()</td>
<td style="text-align:left">DOUBLE</td>
<td style="text-align:left">DOUBLE()</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">ROW(&hellip;)</td>
<td style="text-align:left">ROW&lt;&hellip;&gt;</td>
<td style="text-align:left">ROW(&hellip;)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">BIG_DEC()</td>
<td style="text-align:left">DECIMAL</td>
<td style="text-align:left">[DECIMAL()]</td>
<td style="text-align:left">不是1:1的映射，因为忽略了精度和比例，使用了Java的变量精度和比例。</td>
</tr>
<tr>
<td style="text-align:left">SQL_DATE()</td>
<td style="text-align:left">SQL_DATE</td>
<td style="text-align:left">DATE().bridgedTo(java.sql.Date.class)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">SQL_TIME()</td>
<td style="text-align:left">SQL_TIME</td>
<td style="text-align:left">TIME(0).bridgedTo(java.sql.Time.class)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">SQL_TIMESTAMP()</td>
<td style="text-align:left">SQL_TIMESTAMP</td>
<td style="text-align:left">TIMESTAMP(3).bridgedTo(java.sql.Timestamp.class)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">INTERVAL_MONTHS()</td>
<td style="text-align:left">INTERVAL_MONTHS</td>
<td style="text-align:left">INTERVAL(MONTH()).bridgedTo(Integer.class)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">INTERVAL_MILLIS()</td>
<td style="text-align:left">INTERVAL_MILLIS</td>
<td style="text-align:left">INTERVAL(DataTypes.SECOND(3)).bridgedTo(Long.class)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">PRIMITIVE_ARRAY(&hellip;)</td>
<td style="text-align:left">PRIMITIVE_ARRAY&lt;&hellip;&gt;</td>
<td style="text-align:left">ARRAY(DATATYPE.notNull().bridgedTo(PRIMITIVE.class))</td>
<td style="text-align:left">适用于除byte以外的所有JVM基元类型。</td>
</tr>
<tr>
<td style="text-align:left">PRIMITIVE_ARRAY(BYTE())</td>
<td style="text-align:left">PRIMITIVE_ARRAY<!-- raw HTML omitted --></td>
<td style="text-align:left">BYTES()</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">OBJECT_ARRAY(&hellip;)</td>
<td style="text-align:left">OBJECT_ARRAY&lt;&hellip;&gt;	ARRAY(DATATYPE.bridgedTo(OBJECT.class))</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">MULTISET(&hellip;)</td>
<td style="text-align:left"></td>
<td style="text-align:left">MULTISET(&hellip;)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">MAP(&hellip;, &hellip;)</td>
<td style="text-align:left">MAP&lt;&hellip;,&hellip;&gt;</td>
<td style="text-align:left">MAP(&hellip;)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">other generic types</td>
<td style="text-align:left"></td>
<td style="text-align:left">RAW(&hellip;)</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>注意 如果新的类型系统出现问题。用户可以随时回退到 <code>org.apache.flink.table.api.Types</code> 中定义的类型信息。</p>
<p>新的 Blink 计划器
新的Blink计划器支持旧计划器的所有类型。这特别包括列出的Java表达式字符串和类型信息。</p>
<p>支持以下数据类型。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Data Type</th>
<th style="text-align:left">Remarks for Data Type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">STRING</td>
<td style="text-align:left">还不支持 CHAR 和 VARCHAR</td>
</tr>
<tr>
<td style="text-align:left">BOOLEAN</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">BYTES</td>
<td style="text-align:left">还不支持 BINARY 和 VARBINARY</td>
</tr>
<tr>
<td style="text-align:left">DECIMAL</td>
<td style="text-align:left">支持固定精度和比例。</td>
</tr>
<tr>
<td style="text-align:left">TINYINT</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">SMALLINT</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">INTEGER</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">BIGINT</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">FLOAT</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">DOUBLE</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">只支持精度为0。</td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP WITH LOCAL TIME ZONE</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">INTERVAL</td>
<td style="text-align:left">只支持MONTH和SECOND(3)的间隔。</td>
</tr>
<tr>
<td style="text-align:left">ARRAY</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">MULTISET</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">MAP</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">ROW</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">RAW</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">stuctured types</td>
<td style="text-align:left">目前只在用户定义的函数中暴露。</td>
</tr>
</tbody>
</table>
<p>局限性
Java表达式字符串。表API中的Java表达式字符串，如table.select(&ldquo;field.cast(STRING)&quot;)还没有更新到新的类型系统。请使用旧计划器部分中声明的字符串表示法。</p>
<p>用户定义的函数。用户定义的集合函数还不能声明数据类型。标量函数和表函数完全支持数据类型。</p>
<p>数据类型列表
本节列出了所有预定义的数据类型。</p>
<p>对于基于JVM的Table API，这些类型也可以在org.apache.flink.table.api.DataTypes中找到。</p>
<p>字符字符串
CHAR</p>
<p>一个固定长度的字符串的数据类型。</p>
<p>声明</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- sql
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">CHAR</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nb">CHAR</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="nc">DataTypes</span><span class="o">.</span><span class="nc">CHAR</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
</span></span></code></pre></div><p>桥接到JVM类型</p>
<table>
<thead>
<tr>
<th style="text-align:left">Java Type</th>
<th style="text-align:left">Input</th>
<th style="text-align:left">Output</th>
<th style="text-align:left">Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">java.lang.String</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">Default</td>
</tr>
<tr>
<td style="text-align:left">byte[]</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">Assumes UTF-8 encoding.</td>
</tr>
<tr>
<td style="text-align:left">org.apache.flink.table.data.StringData</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">Internal data structure.</td>
</tr>
</tbody>
</table>
<p>n的值必须在1和2,147,483,647之间(包括两者)。如果没有指定长度，n等于1。</p>
<p>VARCHAR / STRING</p>
<p>可变长度的字符串的数据类型。</p>
<p>声明</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="nc">DataTypes</span><span class="o">.</span><span class="nc">VARCHAR</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
</span></span></code></pre></div><p>DataTypes.STRING()
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.lang.String	X	X	Default
byte[]	X	X	Assumes UTF-8 encoding.
org.apache.flink.table.data.StringData	X	X	Internal data structure.
The type can be declared using VARCHAR(n) where n is the maximum number of code points. n must have a value between 1 and 2,147,483,647 (both inclusive). If no length is specified, n is equal to 1.</p>
<p>STRING is a synonym for VARCHAR(2147483647).</p>
<p>Binary Strings
BINARY</p>
<p>Data type of a fixed-length binary string (=a sequence of bytes).</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.BINARY(n)
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
byte[]	X	X	Default
The type can be declared using BINARY(n) where n is the number of bytes. n must have a value between 1 and 2,147,483,647 (both inclusive). If no length is specified, n is equal to 1.</p>
<p>VARBINARY / BYTES</p>
<p>Data type of a variable-length binary string (=a sequence of bytes).</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.VARBINARY(n)</p>
<p>DataTypes.BYTES()
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
byte[]	X	X	Default
The type can be declared using VARBINARY(n) where n is the maximum number of bytes. n must have a value between 1 and 2,147,483,647 (both inclusive). If no length is specified, n is equal to 1.</p>
<p>BYTES is a synonym for VARBINARY(2147483647).</p>
<p>Exact Numerics
DECIMAL</p>
<p>Data type of a decimal number with fixed precision and scale.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.DECIMAL(p, s)
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.math.BigDecimal	X	X	Default
org.apache.flink.table.data.DecimalData	X	X	Internal data structure.
The type can be declared using DECIMAL(p, s) where p is the number of digits in a number (precision) and s is the number of digits to the right of the decimal point in a number (scale). p must have a value between 1 and 38 (both inclusive). s must have a value between 0 and p (both inclusive). The default value for p is 10. The default value for s is 0.</p>
<p>NUMERIC(p, s) and DEC(p, s) are synonyms for this type.</p>
<p>TINYINT</p>
<p>Data type of a 1-byte signed integer with values from -128 to 127.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.TINYINT()
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.lang.Byte	X	X	Default
byte	X	(X)	Output only if type is not nullable.
SMALLINT</p>
<p>Data type of a 2-byte signed integer with values from -32,768 to 32,767.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.SMALLINT()
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.lang.Short	X	X	Default
short	X	(X)	Output only if type is not nullable.
INT</p>
<p>Data type of a 4-byte signed integer with values from -2,147,483,648 to 2,147,483,647.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.INT()
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.lang.Integer	X	X	Default
int	X	(X)	Output only if type is not nullable.
INTEGER is a synonym for this type.</p>
<p>BIGINT</p>
<p>Data type of an 8-byte signed integer with values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.BIGINT()
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.lang.Long	X	X	Default
long	X	(X)	Output only if type is not nullable.
Approximate Numerics
FLOAT</p>
<p>Data type of a 4-byte single precision floating point number.</p>
<p>Compared to the SQL standard, the type does not take parameters.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.FLOAT()
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.lang.Float	X	X	Default
float	X	(X)	Output only if type is not nullable.
DOUBLE</p>
<p>Data type of an 8-byte double precision floating point number.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.DOUBLE()
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.lang.Double	X	X	Default
double	X	(X)	Output only if type is not nullable.
DOUBLE PRECISION is a synonym for this type.</p>
<p>Date and Time
DATE</p>
<p>Data type of a date consisting of year-month-day with values ranging from 0000-01-01 to 9999-12-31.</p>
<p>Compared to the SQL standard, the range starts at year 0000.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.DATE()
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.time.LocalDate	X	X	Default
java.sql.Date	X	X	
java.lang.Integer	X	X	Describes the number of days since epoch.
int	X	(X)	Describes the number of days since epoch.
Output only if type is not nullable.
TIME</p>
<p>Data type of a time without time zone consisting of hour:minute:second[.fractional] with up to nanosecond precision and values ranging from 00:00:00.000000000 to 23:59:59.999999999.</p>
<p>Compared to the SQL standard, leap seconds (23:59:60 and 23:59:61) are not supported as the semantics are closer to java.time.LocalTime. A time with time zone is not provided.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.TIME(p)
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.time.LocalTime	X	X	Default
java.sql.Time	X	X	
java.lang.Integer	X	X	Describes the number of milliseconds of the day.
int	X	(X)	Describes the number of milliseconds of the day.
Output only if type is not nullable.
java.lang.Long	X	X	Describes the number of nanoseconds of the day.
long	X	(X)	Describes the number of nanoseconds of the day.
Output only if type is not nullable.
The type can be declared using TIME(p) where p is the number of digits of fractional seconds (precision). p must have a value between 0 and 9 (both inclusive). If no precision is specified, p is equal to 0.</p>
<p>TIMESTAMP</p>
<p>Data type of a timestamp without time zone consisting of year-month-day hour:minute:second[.fractional] with up to nanosecond precision and values ranging from 0000-01-01 00:00:00.000000000 to 9999-12-31 23:59:59.999999999.</p>
<p>Compared to the SQL standard, leap seconds (23:59:60 and 23:59:61) are not supported as the semantics are closer to java.time.LocalDateTime.</p>
<p>A conversion from and to BIGINT (a JVM long type) is not supported as this would imply a time zone. However, this type is time zone free. For more java.time.Instant-like semantics use TIMESTAMP WITH LOCAL TIME ZONE.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.TIMESTAMP(p)
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.time.LocalDateTime	X	X	Default
java.sql.Timestamp	X	X	
org.apache.flink.table.data.TimestampData	X	X	Internal data structure.
The type can be declared using TIMESTAMP(p) where p is the number of digits of fractional seconds (precision). p must have a value between 0 and 9 (both inclusive). If no precision is specified, p is equal to 6.</p>
<p>TIMESTAMP(p) WITHOUT TIME ZONE is a synonym for this type.</p>
<p>TIMESTAMP WITH TIME ZONE</p>
<p>Data type of a timestamp with time zone consisting of year-month-day hour:minute:second[.fractional] zone with up to nanosecond precision and values ranging from 0000-01-01 00:00:00.000000000 +14:59 to 9999-12-31 23:59:59.999999999 -14:59.</p>
<p>Compared to the SQL standard, leap seconds (23:59:60 and 23:59:61) are not supported as the semantics are closer to java.time.OffsetDateTime.</p>
<p>Compared to TIMESTAMP WITH LOCAL TIME ZONE, the time zone offset information is physically stored in every datum. It is used individually for every computation, visualization, or communication to external systems.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.TIMESTAMP_WITH_TIME_ZONE(p)
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.time.OffsetDateTime	X	X	Default
java.time.ZonedDateTime	X	 	Ignores the zone ID.
The type can be declared using TIMESTAMP(p) WITH TIME ZONE where p is the number of digits of fractional seconds (precision). p must have a value between 0 and 9 (both inclusive). If no precision is specified, p is equal to 6.</p>
<p>TIMESTAMP WITH LOCAL TIME ZONE</p>
<p>Data type of a timestamp with local time zone consisting of year-month-day hour:minute:second[.fractional] zone with up to nanosecond precision and values ranging from 0000-01-01 00:00:00.000000000 +14:59 to 9999-12-31 23:59:59.999999999 -14:59.</p>
<p>Leap seconds (23:59:60 and 23:59:61) are not supported as the semantics are closer to java.time.OffsetDateTime.</p>
<p>Compared to TIMESTAMP WITH TIME ZONE, the time zone offset information is not stored physically in every datum. Instead, the type assumes java.time.Instant semantics in UTC time zone at the edges of the table ecosystem. Every datum is interpreted in the local time zone configured in the current session for computation and visualization.</p>
<p>This type fills the gap between time zone free and time zone mandatory timestamp types by allowing the interpretation of UTC timestamps according to the configured session time zone.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE(p)
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.time.Instant	X	X	Default
java.lang.Integer	X	X	Describes the number of seconds since epoch.
int	X	(X)	Describes the number of seconds since epoch.
Output only if type is not nullable.
java.lang.Long	X	X	Describes the number of milliseconds since epoch.
long	X	(X)	Describes the number of milliseconds since epoch.
Output only if type is not nullable.
org.apache.flink.table.data.TimestampData	X	X	Internal data structure.
The type can be declared using TIMESTAMP(p) WITH LOCAL TIME ZONE where p is the number of digits of fractional seconds (precision). p must have a value between 0 and 9 (both inclusive). If no precision is specified, p is equal to 6.</p>
<p>INTERVAL YEAR TO MONTH</p>
<p>Data type for a group of year-month interval types.</p>
<p>The type must be parameterized to one of the following resolutions:</p>
<p>interval of years,
interval of years to months,
or interval of months.
An interval of year-month consists of +years-months with values ranging from -9999-11 to +9999-11.</p>
<p>The value representation is the same for all types of resolutions. For example, an interval of months of 50 is always represented in an interval-of-years-to-months format (with default year precision): +04-02.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.INTERVAL(DataTypes.YEAR())
DataTypes.INTERVAL(DataTypes.YEAR(p))
DataTypes.INTERVAL(DataTypes.YEAR(p), DataTypes.MONTH())
DataTypes.INTERVAL(DataTypes.MONTH())
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.time.Period	X	X	Ignores the days part. Default
java.lang.Integer	X	X	Describes the number of months.
int	X	(X)	Describes the number of months.
Output only if type is not nullable.
The type can be declared using the above combinations where p is the number of digits of years (year precision). p must have a value between 1 and 4 (both inclusive). If no year precision is specified, p is equal to 2.</p>
<p>INTERVAL DAY TO SECOND</p>
<p>Data type for a group of day-time interval types.</p>
<p>The type must be parameterized to one of the following resolutions with up to nanosecond precision:</p>
<p>interval of days,
interval of days to hours,
interval of days to minutes,
interval of days to seconds,
interval of hours,
interval of hours to minutes,
interval of hours to seconds,
interval of minutes,
interval of minutes to seconds,
or interval of seconds.
An interval of day-time consists of +days hours:months:seconds.fractional with values ranging from -999999 23:59:59.999999999 to +999999 23:59:59.999999999. The value representation is the same for all types of resolutions. For example, an interval of seconds of 70 is always represented in an interval-of-days-to-seconds format (with default precisions): +00 00:01:10.000000.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.INTERVAL(DataTypes.DAY())
DataTypes.INTERVAL(DataTypes.DAY(p1))
DataTypes.INTERVAL(DataTypes.DAY(p1), DataTypes.HOUR())
DataTypes.INTERVAL(DataTypes.DAY(p1), DataTypes.MINUTE())
DataTypes.INTERVAL(DataTypes.DAY(p1), DataTypes.SECOND(p2))
DataTypes.INTERVAL(DataTypes.HOUR())
DataTypes.INTERVAL(DataTypes.HOUR(), DataTypes.MINUTE())
DataTypes.INTERVAL(DataTypes.HOUR(), DataTypes.SECOND(p2))
DataTypes.INTERVAL(DataTypes.MINUTE())
DataTypes.INTERVAL(DataTypes.MINUTE(), DataTypes.SECOND(p2))
DataTypes.INTERVAL(DataTypes.SECOND())
DataTypes.INTERVAL(DataTypes.SECOND(p2))
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.time.Duration	X	X	Default
java.lang.Long	X	X	Describes the number of milliseconds.
long	X	(X)	Describes the number of milliseconds.
Output only if type is not nullable.
The type can be declared using the above combinations where p1 is the number of digits of days (day precision) and p2 is the number of digits of fractional seconds (fractional precision). p1 must have a value between 1 and 6 (both inclusive). p2 must have a value between 0 and 9 (both inclusive). If no p1 is specified, it is equal to 2 by default. If no p2 is specified, it is equal to 6 by default.</p>
<p>Constructured Data Types
ARRAY</p>
<p>Data type of an array of elements with same subtype.</p>
<p>Compared to the SQL standard, the maximum cardinality of an array cannot be specified but is fixed at 2,147,483,647. Also, any valid type is supported as a subtype.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.ARRAY(t)
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
t[]	(X)	(X)	Depends on the subtype. Default
org.apache.flink.table.data.ArrayData	X	X	Internal data structure.
The type can be declared using ARRAY<!-- raw HTML omitted --> where t is the data type of the contained elements.</p>
<p>t ARRAY is a synonym for being closer to the SQL standard. For example, INT ARRAY is equivalent to ARRAY<!-- raw HTML omitted -->.</p>
<p>MAP</p>
<p>Data type of an associative array that maps keys (including NULL) to values (including NULL). A map cannot contain duplicate keys; each key can map to at most one value.</p>
<p>There is no restriction of element types; it is the responsibility of the user to ensure uniqueness.</p>
<p>The map type is an extension to the SQL standard.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.MAP(kt, vt)
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.util.Map&lt;kt, vt&gt;	X	X	Default
subclass of java.util.Map&lt;kt, vt&gt;	X	 	
org.apache.flink.table.data.MapData	X	X	Internal data structure.
The type can be declared using MAP&lt;kt, vt&gt; where kt is the data type of the key elements and vt is the data type of the value elements.</p>
<p>MULTISET</p>
<p>Data type of a multiset (=bag). Unlike a set, it allows for multiple instances for each of its elements with a common subtype. Each unique value (including NULL) is mapped to some multiplicity.</p>
<p>There is no restriction of element types; it is the responsibility of the user to ensure uniqueness.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.MULTISET(t)
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.util.Map&lt;t, java.lang.Integer&gt;	X	X	Assigns each value to an integer multiplicity. Default
subclass of java.util.Map&lt;t, java.lang.Integer&raquo;	X	 	
org.apache.flink.table.data.MapData	X	X	Internal data structure.
The type can be declared using MULTISET<!-- raw HTML omitted --> where t is the data type of the contained elements.</p>
<p>t MULTISET is a synonym for being closer to the SQL standard. For example, INT MULTISET is equivalent to MULTISET<!-- raw HTML omitted -->.</p>
<p>ROW</p>
<p>Data type of a sequence of fields.</p>
<p>A field consists of a field name, field type, and an optional description. The most specific type of a row of a table is a row type. In this case, each column of the row corresponds to the field of the row type that has the same ordinal position as the column.</p>
<p>Compared to the SQL standard, an optional field description simplifies the handling with complex structures.</p>
<p>A row type is similar to the STRUCT type known from other non-standard-compliant frameworks.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.ROW(DataTypes.FIELD(n0, t0), DataTypes.FIELD(n1, t1), &hellip;)
DataTypes.ROW(DataTypes.FIELD(n0, t0, d0), DataTypes.FIELD(n1, t1, d1), &hellip;)
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
org.apache.flink.types.Row	X	X	Default
org.apache.flink.table.data.RowData	X	X	Internal data structure.
The type can be declared using ROW&lt;n0 t0 &lsquo;d0&rsquo;, n1 t1 &lsquo;d1&rsquo;, &hellip;&gt; where n is the unique name of a field, t is the logical type of a field, d is the description of a field.</p>
<p>ROW(&hellip;) is a synonym for being closer to the SQL standard. For example, ROW(myField INT, myOtherField BOOLEAN) is equivalent to ROW&lt;myField INT, myOtherField BOOLEAN&gt;.</p>
<p>User-Defined Data Types
Attention User-defined data types are not fully supported yet. They are currently (as of Flink 1.11) only exposed as unregistered structured types in parameters and return types of functions.</p>
<p>A structured type is similar to an object in an object-oriented programming language. It contains zero, one or more attributes. Each attribute consists of a name and a type.</p>
<p>There are two kinds of structured types:</p>
<p>Types that are stored in a catalog and are identified by a catalog identifer (like cat.db.MyType). Those are equal to the SQL standard definition of structured types.</p>
<p>Anonymously defined, unregistered types (usually reflectively extracted) that are identified by an implementation class (like com.myorg.model.MyType). Those are useful when programmatically defining a table program. They enable reusing existing JVM classes without manually defining the schema of a data type again.</p>
<p>Registered Structured Types</p>
<p>Currently, registered structured types are not supported. Thus, they cannot be stored in a catalog or referenced in a CREATE TABLE DDL.</p>
<p>Unregistered Structured Types</p>
<p>Unregistered structured types can be created from regular POJOs (Plain Old Java Objects) using automatic reflective extraction.</p>
<p>The implementation class of a structured type must meet the following requirements:</p>
<p>The class must be globally accessible which means it must be declared public, static, and not abstract.
The class must offer a default constructor with zero arguments or a full constructor that assigns all fields.
All fields of the class must be readable by either public declaration or a getter that follows common coding style such as getField(), isField(), field().
All fields of the class must be writable by either public declaration, fully assigning constructor, or a setter that follows common coding style such as setField(&hellip;), field(&hellip;).
All fields must be mapped to a data type either implicitly via reflective extraction or explicitly using the @DataTypeHint annotations.
Fields that are declared static or transient are ignored.
The reflective extraction supports arbitrary nesting of fields as long as a field type does not (transitively) refer to itself.</p>
<p>The declared field class (e.g. public int age;) must be contained in the list of supported JVM bridging classes defined for every data type in this document (e.g. java.lang.Integer or int for INT).</p>
<p>For some classes an annotation is required in order to map the class to a data type (e.g. @DataTypeHint(&ldquo;DECIMAL(10, 2)&rdquo;) to assign a fixed precision and scale for java.math.BigDecimal).</p>
<p>Declaration</p>
<p>Java
Scala
Python
case class User(</p>
<pre><code>// extract fields automatically
age: Int,
name: String,

// enrich the extraction with precision information
@DataTypeHint(&quot;DECIMAL(10, 2)&quot;) totalBalance: java.math.BigDecimal,

// enrich the extraction with forcing using a RAW type
@DataTypeHint(&quot;RAW&quot;) modelClass: Class[_]
</code></pre>
<p>)</p>
<p>DataTypes.of(classOf[User])
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
class	X	X	Originating class or subclasses (for input) or
superclasses (for output). Default
org.apache.flink.types.Row	X	X	Represent the structured type as a row.
org.apache.flink.table.data.RowData	X	X	Internal data structure.
Other Data Types
BOOLEAN</p>
<p>Data type of a boolean with a (possibly) three-valued logic of TRUE, FALSE, and UNKNOWN.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.BOOLEAN()
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.lang.Boolean	X	X	Default
boolean	X	(X)	Output only if type is not nullable.
RAW</p>
<p>Data type of an arbitrary serialized type. This type is a black box within the table ecosystem and is only deserialized at the edges.</p>
<p>The raw type is an extension to the SQL standard.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.RAW(class, serializer)</p>
<p>DataTypes.RAW(class)
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
class	X	X	Originating class or subclasses (for input) or
superclasses (for output). Default
byte[]	 	X	
org.apache.flink.table.data.RawValueData	X	X	Internal data structure.
The type can be declared using RAW(&lsquo;class&rsquo;, &lsquo;snapshot&rsquo;) where class is the originating class and snapshot is the serialized TypeSerializerSnapshot in Base64 encoding. Usually, the type string is not declared directly but is generated while persisting the type.</p>
<p>In the API, the RAW type can be declared either by directly supplying a Class + TypeSerializer or by passing Class and letting the framework extract Class + TypeSerializer from there.</p>
<p>NULL</p>
<p>Data type for representing untyped NULL values.</p>
<p>The null type is an extension to the SQL standard. A null type has no other value except NULL, thus, it can be cast to any nullable type similar to JVM semantics.</p>
<p>This type helps in representing unknown types in API calls that use a NULL literal as well as bridging to formats such as JSON or Avro that define such a type as well.</p>
<p>This type is not very useful in practice and is just mentioned here for completeness.</p>
<p>Declaration</p>
<p>SQL
Java
Scala
Python
DataTypes.NULL()
Bridging to JVM Types</p>
<p>Java Type	Input	Output	Remarks
java.lang.Object	X	X	Default
any class	 	(X)	Any non-primitive type.
Data Type Extraction
At many locations in the API, Flink tries to automatically extract data type from class information using reflection to avoid repetitive manual schema work. However, extracting a data type reflectively is not always successful because logical information might be missing. Therefore, it might be necessary to add additional information close to a class or field declaration for supporting the extraction logic.</p>
<p>The following table lists classes that can be implicitly mapped to a data type without requiring further information.</p>
<p>If you intend to implement classes in Scala, it is recommended to use boxed types (e.g. java.lang.Integer) instead of Scala’s primitives. Scala’s primitives (e.g. Int or Double) are compiled to JVM primitives (e.g. int/double) and result in NOT NULL semantics as shown in the table below. Furthermore, Scala primitives that are used in generics (e.g. java.lang.Map[Int, Double]) are erased during compilation and lead to class information similar to java.lang.Map[java.lang.Object, java.lang.Object].</p>
<p>Class	Data Type
java.lang.String	STRING
java.lang.Boolean	BOOLEAN
boolean	BOOLEAN NOT NULL
java.lang.Byte	TINYINT
byte	TINYINT NOT NULL
java.lang.Short	SMALLINT
short	SMALLINT NOT NULL
java.lang.Integer	INT
int	INT NOT NULL
java.lang.Long	BIGINT
long	BIGINT NOT NULL
java.lang.Float	FLOAT
float	FLOAT NOT NULL
java.lang.Double	DOUBLE
double	DOUBLE NOT NULL
java.sql.Date	DATE
java.time.LocalDate	DATE
java.sql.Time	TIME(0)
java.time.LocalTime	TIME(9)
java.sql.Timestamp	TIMESTAMP(9)
java.time.LocalDateTime	TIMESTAMP(9)
java.time.OffsetDateTime	TIMESTAMP(9) WITH TIME ZONE
java.time.Instant	TIMESTAMP(9) WITH LOCAL TIME ZONE
java.time.Duration	INVERVAL SECOND(9)
java.time.Period	INTERVAL YEAR(4) TO MONTH
byte[]	BYTES
T[]	ARRAY<!-- raw HTML omitted -->
java.lang.Map&lt;K, V&gt;	MAP&lt;K, V&gt;
structured type T	anonymous structured type T
Other JVM bridging classes mentioned in this document require a @DataTypeHint annotation.</p>
<p>Data type hints can parameterize or replace the default extraction logic of individual function parameters and return types, structured classes, or fields of structured classes. An implementer can choose to what extent the default extraction logic should be modified by declaring a @DataTypeHint annotation.</p>
<p>The @DataTypeHint annotation provides a set of optional hint parameters. Some of those parameters are shown in the following example. More information can be found in the documentation of the annotation class.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">import</span> <span class="nn">org.apache.flink.table.annotation.DataTypeHint</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">User</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// defines an INT data type with a default conversion class `java.lang.Integer`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nd">@DataTypeHint</span><span class="o">(</span><span class="s">&#34;INT&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">o</span><span class="k">:</span> <span class="kt">AnyRef</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// defines a TIMESTAMP data type of millisecond precision with an explicit conversion class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nd">@DataTypeHint</span><span class="o">(</span><span class="n">value</span> <span class="k">=</span> <span class="s">&#34;TIMESTAMP(3)&#34;</span><span class="o">,</span> <span class="n">bridgedTo</span> <span class="k">=</span> <span class="n">java</span><span class="o">.</span><span class="n">sql</span><span class="o">.</span><span class="nc">Timestamp</span><span class="o">.</span><span class="n">class</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">o</span><span class="k">:</span> <span class="kt">AnyRef</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// enrich the extraction with forcing using a RAW type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nd">@DataTypeHint</span><span class="o">(</span><span class="s">&#34;RAW&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">modelClass</span><span class="k">:</span> <span class="kt">Class</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// defines that all occurrences of java.math.BigDecimal (also in nested fields) will be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// extracted as DECIMAL(12, 2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nd">@DataTypeHint</span><span class="o">(</span><span class="n">defaultDecimalPrecision</span> <span class="k">=</span> <span class="mi">12</span><span class="o">,</span> <span class="n">defaultDecimalScale</span> <span class="k">=</span> <span class="mi">2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">stmt</span><span class="k">:</span> <span class="kt">AccountStatement</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// defines that whenever a type cannot be mapped to a data type, instead of throwing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// an exception, always treat it as a RAW type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nd">@DataTypeHint</span><span class="o">(</span><span class="n">allowRawGlobally</span> <span class="k">=</span> <span class="nc">HintFlag</span><span class="o">.</span><span class="nc">TRUE</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">model</span><span class="k">:</span> <span class="kt">ComplexModel</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div>

        </div>
    </div>
</article>



                <footer>
                    




<div class="no-text-decoration">
    <div class="jump top"><a href="#" title="Top of this page">⮉</a></div>
    <div class="jump bottom"><a href="#bottom" title="Bottom of this page">⮋</a></div>
</div>


 
    
        <div class="hugotoc no-text-decoration">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#data-type">Data Type</a></li>
  </ul>
</nav>
            <a href="#" class="back-to-top">Back to top</a>
        </div>
    
    
<script src="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js"></script>

<link rel="preload" href="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js" as="script">

<script type="application/javascript">(function() {
     var $window = $(window);
     if ($window.width() >= 1400) { 
         var $toc = $('#TableOfContents');
         if ($toc.length > 0) {
             function onScroll(){
                 var currentScroll = $window.scrollTop();
                 var h = $('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .h-feed h2');
                 var id = "";
                 h.each(function (i, e) {
                     e = $(e);
                     if (e.offset().top - 10 <= currentScroll) {
                         id = e.attr('id');
                     }
                 });
                 var current = $toc.find('a.current');
                 if (current.length == 1 && current.eq(0).attr('href') == '#' + id) return true;

                 current.each(function (i, e) {
                     $(e).removeClass('current').siblings('ul').hide();
                 });
                 $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                     $(e).children('a').addClass('current').siblings('ul').show();
                 });
             }
             $window.on('scroll', onScroll);
             $(document).ready(function() {
                 $toc.find('a').parent('li').find('ul').hide();
                 onScroll();
                 document.getElementsByClassName('hugotoc')[0].style.display = '';
             });}}})();</script>








<div class="backtotop center no-text-decoration">
    <a href="#">back to <span class="top">top</span></a>
</div>


<div class="right">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 0 posts categorized in ‘Flink’"
                                
                            >
                                <a class="p-category" href="http://localhost:1313/categories/flink/">Flink</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 0 posts tagged with ‘Flink’"
                                
                            >
                                <a class="p-category" href="http://localhost:1313/tags/flink/">Flink</a>
                            </li>
                        
                    
                        
                        
                        
                    
                        
                        
                        
                    
                </ul>
            
        
    </div>

</div>
<div class="clear-float"></div>



<div class="prev-next-navigator clear-float">
    
        <span class="prev-post left no-text-decoration">
            <a href="http://localhost:1313/notes/2020-08-22-data-sources/" class="nobr">« 数据源</a>
        </span>
    
    
        <span class="next-post right no-text-decoration">
            <a href="http://localhost:1313/notes/2020-08-22-zipping-elements-in-a-dataset/" class="nobr">数据集中的 zipping 元素 »</a>
        </span>
    
</div>


<a id="bottom"></a>









                       







                    <ul class="no-bullets feed right inline">
    
        
        
    
</ul>
<div class="clear-float"></div>

                </footer>
                <hr />
            </div>               

            <footer> 
                

<ul class="social no-text-decoration">
    
</ul>










 
    
    



<p class="generated no-text-decoration">
    Generated using  <a href="https://gitlab.com/kaushalmodi/hugo-theme-refined"><code class="nobr">hugo-theme-refined</code></a> + <span class="nobr">Hugo <a href="https://github.com/gohugoio/hugo/commit/312735366b20d64bd61bff8627f593749f86c964">0.123.7</a></span>
</p>

<p>
    
</p>




<div class="badges no-text-decoration">
    
    

    
</div>




<script type="application/javascript">var nav=responsiveNav("#nav");</script>




<script defer src="/js/libs/fragmentions/wrapper.min.e8c468c89edc4f5dccaa8c720c6b220b3088a16cd7b1e4a1e3345985788260c9.js"></script>









            </footer>
        </div> 
    </body>
</html>
