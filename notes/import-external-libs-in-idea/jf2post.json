{"author":{"name":null,"type":"card","url":"https://ohmycloud.github.io/"},"content":{"html":"\u003cp\u003e有一个解析报文的 Java 程序, 里面封装好了可用的函数, 用来解析车辆上的原始报文, kafka 数据如下所示(\u003cstrong\u003erawData\u003c/strong\u003e 字段为报文)。我们用它提供的 libs 来解析该报文。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e{\u0026#34;keyId\u0026#34;:\u0026#34;XXXXXXXXXXXXX\u0026#34;,\u0026#34;sampleTime\u0026#34;:\u0026#34;1563348447814\u0026#34;,\u0026#34;msgType\u0026#34;:\u0026#34;gbdata\u0026#34;,\u0026#34;dataList\u0026#34;:{\u0026#34;msgType\u0026#34;:\u0026#34;gbdata\u0026#34;,\u0026#34;vehicleModelCode\u0026#34;:\u0026#34;1xd9\u0026#34;,\u0026#34;vehicleSeries\u0026#34;:\u0026#34;A76\u0026#34;,\u0026#34;vin\u0026#34;:\u0026#34;LLLLLLLLLLLLLL\u0026#34;,\u0026#34;rawData\u0026#34;:\u0026#34;131302fe4c4e414132414131354b355331303236330101271307110f1b190102010100000000546d0eae26c063010f03e80000050006c3a1fd015f5e080601431018010c100801184a010344070000000000000000000801010eae26c0005c00015c100f101310111010101110101014100b10121010100f1008100e100c100c1010101210111013100e100c1010101310101015101310131015101410141013100e100c100e100d1010100f10131013101410131015100c100d100d100f100e100e101210161015101510431016101710131016101510151016100f101310131016101210101018101010151014101710141014101310131017100e10101013100e100f10111013101410141017101410181016101510161017090101002048474445454545454546444545454545454645464545494a4949464849484849bb\u0026#34;,\u0026#34;sampleTime\u0026#34;:\u0026#34;1563348447814\u0026#34;}}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e要在新的项目中使用它们的库, 需要做的是:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在 \u003ccode\u003esrc\u003c/code\u003e 同级目录下, 创建一个 libs 目录, 把 xx.jar 复制到 libs 目录里面\u003c/li\u003e\n\u003cli\u003e在 \u003ccode\u003esrc\u003c/code\u003e 同级目录下, 创建一个 out 目录, 用于 build Artifact 时存放最后的 jar 包文件\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFile\u003c/code\u003e -\u0026gt; \u003ccode\u003eProject Structure\u003c/code\u003e -\u0026gt; \u003ccode\u003eArtifacts\u003c/code\u003e -\u0026gt; \u003ccode\u003e+\u003c/code\u003e -\u0026gt; \u003ccode\u003eExtracted Directory\u003c/code\u003e -\u0026gt; 选择外部库.jar\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFile\u003c/code\u003e -\u0026gt; \u003ccode\u003eProject Structure\u003c/code\u003e -\u0026gt; \u003ccode\u003eArtifacts\u003c/code\u003e -\u0026gt; 勾选 include in projects.  (重要)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFile\u003c/code\u003e -\u0026gt; \u003ccode\u003eProject Structure\u003c/code\u003e -\u0026gt; \u003ccode\u003eLibraries\u003c/code\u003e -\u0026gt; \u003ccode\u003e+\u003c/code\u003e -\u0026gt; 选择 \u003ccode\u003elibs\u003c/code\u003e 目录和外部库.jar\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFile\u003c/code\u003e -\u0026gt; \u003ccode\u003eProject Structure\u003c/code\u003e -\u0026gt; \u003ccode\u003eModules\u003c/code\u003e -\u0026gt; \u003ccode\u003eDependencies\u003c/code\u003e -\u0026gt;  选择 \u003ccode\u003elibs\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e然后 \u003ccode\u003eBuild\u003c/code\u003e -\u0026gt; \u003ccode\u003eBuild Artifacts\u003c/code\u003e -\u0026gt; \u003ccode\u003eclean\u003c/code\u003e -\u0026gt; \u003ccode\u003ebuild\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e打开最后的 jar 包, 查看下里面是不是把外部库添加进来了。运行之前, 还要删除一下 \u003cstrong\u003eMETA-INF\u003c/strong\u003e 里面的一些东西:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ezip -d ./result.jar \u003cspan class=\"s1\"\u003e\u0026#39;META-INF/.SF\u0026#39;\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;META-INF/.RSA\u0026#39;\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;META-INF/*SF\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果打包后发现 jar 包你面没有找到你的主类, build clean 然后再 \u003ccode\u003ebuild\u003c/code\u003e。如果出现 StackOverFlowErr 则可能会导致打包后的 jar 包中找不到主类：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eError:scalac: Error: java.lang.StackOverflowError\njava.lang.StackOverflowError\n\tat scala.tools.nsc.typechecker.Typers$Typer.typedApply$1(Typers.scala:4580)\n\tat scala.tools.nsc.typechecker.Typers$Typer.typedInAnyMode$1(Typers.scala:5343)\n\tat scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5360)\n\tat scala.tools.nsc.typechecker.Typers$Typer.runTyper$1(Typers.scala:5396)\n\tat scala.tools.nsc.typechecker.Typers$Typer.scala$tools$nsc$typechecker$Typers$Typer$$typedInternal(Typers.scala:5423)\n\tat scala.tools.nsc.typechecker.Typers$Typer.body$2(Typers.scala:5370)\n\tat scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5374)\n\tat scala.tools.nsc.typechecker.Typers$Typer.typedQualifier(Typers.scala:5472)\n\tat scala.tools.nsc.typechecker.Typers$Typer.typedQualifier(Typers.scala:5478)\n\tat scala.tools.nsc.typechecker.Typers$Typer.typedSelectOrSuperCall$1(Typers.scala:4812)\n\tat scala.tools.nsc.typechecker.Typers$Typer.typedInAnyMode$1(Typers.scala:5344)\n\tat scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5360)\n\tat scala.tools.nsc.typechecker.Typers$Typer.runTyper$1(Typers.scala:5396)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ebuild clean, 再重新打包。可能是程序里用的 case class 太多字段了。报这个错，最后的 jar 包里就找不到主类。等于你的程序编译的输出里，没有主类。\u003c/p\u003e\n\u003cp\u003e在 build 下的配置里：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"nt\"\u003e\u0026lt;configuration\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                            \u003cspan class=\"nt\"\u003e\u0026lt;args\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"nt\"\u003e\u0026lt;arg\u0026gt;\u003c/span\u003e-dependencyfile\u003cspan class=\"nt\"\u003e\u0026lt;/arg\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"nt\"\u003e\u0026lt;arg\u0026gt;\u003c/span\u003e${project.build.directory}/.scala_dependencies\u003cspan class=\"nt\"\u003e\u0026lt;/arg\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                            \u003cspan class=\"nt\"\u003e\u0026lt;/args\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                            \u003cspan class=\"nt\"\u003e\u0026lt;jvmArgs\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"nt\"\u003e\u0026lt;jvmArg\u0026gt;\u003c/span\u003e-Xss6144m\u003cspan class=\"nt\"\u003e\u0026lt;/jvmArg\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                            \u003cspan class=\"nt\"\u003e\u0026lt;/jvmArgs\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"nt\"\u003e\u0026lt;/configuration\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这样偶尔可行。\u003c/p\u003e\n","text":"有一个解析报文的 Java 程序, 里面封装好了可用的函数, 用来解析车辆上的原始报文, kafka 数据如下所示(rawData 字段为报文)。我们用它提供的 libs 来解析该报文。\n{\u0026#34;keyId\u0026#34;:\u0026#34;XXXXXXXXXXXXX\u0026#34;,\u0026#34;sampleTime\u0026#34;:\u0026#34;1563348447814\u0026#34;,\u0026#34;msgType\u0026#34;:\u0026#34;gbdata\u0026#34;,\u0026#34;dataList\u0026#34;:{\u0026#34;msgType\u0026#34;:\u0026#34;gbdata\u0026#34;,\u0026#34;vehicleModelCode\u0026#34;:\u0026#34;1xd9\u0026#34;,\u0026#34;vehicleSeries\u0026#34;:\u0026#34;A76\u0026#34;,\u0026#34;vin\u0026#34;:\u0026#34;LLLLLLLLLLLLLL\u0026#34;,\u0026#34;rawData\u0026#34;:\u0026#34;131302fe4c4e414132414131354b355331303236330101271307110f1b190102010100000000546d0eae26c063010f03e80000050006c3a1fd015f5e080601431018010c100801184a010344070000000000000000000801010eae26c0005c00015c100f101310111010101110101014100b10121010100f1008100e100c100c1010101210111013100e100c1010101310101015101310131015101410141013100e100c100e100d1010100f10131013101410131015100c100d100d100f100e100e101210161015101510431016101710131016101510151016100f101310131016101210101018101010151014101710141014101310131017100e10101013100e100f10111013101410141017101410181016101510161017090101002048474445454545454546444545454545454645464545494a4949464849484849bb\u0026#34;,\u0026#34;sampleTime\u0026#34;:\u0026#34;1563348447814\u0026#34;}} 要在新的项目中使用它们的库, 需要做的是:\n在 src 同级目录下, 创建一个 libs 目录, 把 xx.jar 复制到 libs 目录里面 在 src 同级目录下, 创建一个 out 目录, 用于 build Artifact 时存放最后的 jar 包文件 File -\u0026gt; Project Structure -\u0026gt; Artifacts -\u0026gt; + -\u0026gt; Extracted Directory -\u0026gt; 选择外部库.jar File -\u0026gt; Project Structure -\u0026gt; Artifacts -\u0026gt; 勾选 include in projects. (重要) File -\u0026gt; Project Structure -\u0026gt; Libraries -\u0026gt; + -\u0026gt; 选择 libs 目录和外部库.jar File -\u0026gt; Project Structure -\u0026gt; Modules -\u0026gt; Dependencies -\u0026gt; 选择 libs 然后 Build -\u0026gt; Build Artifacts -\u0026gt; clean -\u0026gt; build。\n打开最后的 jar 包, 查看下里面是不是把外部库添加进来了。运行之前, 还要删除一下 META-INF 里面的一些东西:\nzip -d ./result.jar \u0026#39;META-INF/.SF\u0026#39; \u0026#39;META-INF/.RSA\u0026#39; \u0026#39;META-INF/*SF\u0026#39; 如果打包后发现 jar 包你面没有找到你的主类, build clean 然后再 build。如果出现 StackOverFlowErr 则可能会导致打包后的 jar 包中找不到主类：\nError:scalac: Error: java.lang.StackOverflowError java.lang.StackOverflowError at scala.tools.nsc.typechecker.Typers$Typer.typedApply$1(Typers.scala:4580) at scala.tools.nsc.typechecker.Typers$Typer.typedInAnyMode$1(Typers.scala:5343) at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5360) at scala.tools.nsc.typechecker.Typers$Typer.runTyper$1(Typers.scala:5396) at scala.tools.nsc.typechecker.Typers$Typer.scala$tools$nsc$typechecker$Typers$Typer$$typedInternal(Typers.scala:5423) at scala.tools.nsc.typechecker.Typers$Typer.body$2(Typers.scala:5370) at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5374) at scala.tools.nsc.typechecker.Typers$Typer.typedQualifier(Typers.scala:5472) at scala.tools.nsc.typechecker.Typers$Typer.typedQualifier(Typers.scala:5478) at scala.tools.nsc.typechecker.Typers$Typer.typedSelectOrSuperCall$1(Typers.scala:4812) at scala.tools.nsc.typechecker.Typers$Typer.typedInAnyMode$1(Typers.scala:5344) at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5360) at scala.tools.nsc.typechecker.Typers$Typer.runTyper$1(Typers.scala:5396) build clean, 再重新打包。可能是程序里用的 case class 太多字段了。报这个错，最后的 jar 包里就找不到主类。等于你的程序编译的输出里，没有主类。\n在 build 下的配置里：\n\u0026lt;configuration\u0026gt; \u0026lt;args\u0026gt; \u0026lt;arg\u0026gt;-dependencyfile\u0026lt;/arg\u0026gt; \u0026lt;arg\u0026gt;${project.build.directory}/.scala_dependencies\u0026lt;/arg\u0026gt; \u0026lt;/args\u0026gt; \u0026lt;jvmArgs\u0026gt; \u0026lt;jvmArg\u0026gt;-Xss6144m\u0026lt;/jvmArg\u0026gt; \u0026lt;/jvmArgs\u0026gt; \u0026lt;/configuration\u0026gt; 这样偶尔可行。\n"},"name":"在 IDEA 中导入外部库","published":"2019-07-26T13:50:59Z","summary":"有一个解析报文的 Java 程序, 里面封装好了可用的函数, 用来解析车辆上的原始报文, kafka 数据如下所示(rawData 字段为报文)。我们用它提供的 libs 来解析该报文。\n{\u0026#34;keyId\u0026#34;:\u0026#34;XXXXXXXXXXXXX\u0026#34;,\u0026#34;sampleTime\u0026#34;:\u0026#34;1563348447814\u0026#34;,\u0026#34;msgType\u0026#34;:\u0026#34;gbdata\u0026#34;,\u0026#34;dataList\u0026#34;:{\u0026#34;msgType\u0026#34;:\u0026#34;gbdata\u0026#34;,\u0026#34;vehicleModelCode\u0026#34;:\u0026#34;1xd9\u0026#34;,\u0026#34;vehicleSeries\u0026#34;:\u0026#34;A76\u0026#34;,\u0026#34;vin\u0026#34;:\u0026#34;LLLLLLLLLLLLLL\u0026#34;,\u0026#34;rawData\u0026#34;:\u0026#34;131302fe4c4e414132414131354b355331303236330101271307110f1b190102010100000000546d0eae26c063010f03e80000050006c3a1fd015f5e080601431018010c100801184a010344070000000000000000000801010eae26c0005c00015c100f101310111010101110101014100b10121010100f1008100e100c100c1010101210111013100e100c1010101310101015101310131015101410141013100e100c100e100d1010100f10131013101410131015100c100d100d100f100e100e101210161015101510431016101710131016101510151016100f101310131016101210101018101010151014101710141014101310131017100e10101013100e100f10111013101410141017101410181016101510161017090101002048474445454545454546444545454545454645464545494a4949464849484849bb\u0026#34;,\u0026#34;sampleTime\u0026#34;:\u0026#34;1563348447814\u0026#34;}} 要在新的项目中使用它们的库, 需要做的是:\n在 src 同级目录下, 创建一个 libs 目录, 把 xx.jar 复制到 libs 目录里面 在 src 同级目录下, 创建一个 out 目录, 用于 build Artifact 时存放最后的 jar 包文件 File -\u0026gt; Project Structure -\u0026gt; Artifacts -\u0026gt; + -\u0026gt; Extracted Directory -\u0026gt; 选择外部库.jar File -\u0026gt; Project Structure -\u0026gt; Artifacts -\u0026gt; 勾选 include in projects. (重要) File -\u0026gt; Project Structure -\u0026gt; Libraries -\u0026gt; + -\u0026gt; 选择 libs 目录和外部库.","type":"entry","url":"https://ohmycloud.github.io/notes/import-external-libs-in-idea/"}