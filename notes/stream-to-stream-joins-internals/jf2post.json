{"author":{"name":null,"type":"card","url":"http://localhost:1313/"},"content":{"html":"\u003cp\u003e在最近关于Apache Spark结构化流的3篇文章中，我们发现了流连接：内部连接，外部连接和状态管理策略。发现所有这些操作背后发生的事情是总结该系列的一个好方法。\n这篇文章首先介绍了流连接过程中涉及的类。接下来是专注于与联接有关的状态管理内部的部分。文章以关于连接机制的一小段结尾。\u003c/p\u003e\n\u003ch2 id=\"所涉及的类\"\u003e所涉及的类\u003c/h2\u003e\n\u003cp\u003e在流连接所涉及的类中，我们可以区分3个非常重要的类：SymmetricHashJoinStateManager，StreamingSymmetricHashJoinExec 和 StreamingJoinHelper。所有这些都用于流查询执行的不同阶段。\u003c/p\u003e\n\u003cp\u003e首先，查询的流式表示形式 IncrementalExecution 实例存储对该状态的引用。如果查询具有某些流间连接，则此状态在每次执行时都表示为 StreamingSymmetricHashJoinExec 的实例。该实例在每次执行中都不同，不同点是偏移量统计信息和状态水位谓词。谓词的计算公式为：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003egetStateWatermarkPredicates\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eleftAttributes\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eSeq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eAttribute\u003c/span\u003e\u003cspan class=\"o\"\u003e],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003erightAttributes\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eSeq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eAttribute\u003c/span\u003e\u003cspan class=\"o\"\u003e],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eleftKeys\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eSeq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eExpression\u003c/span\u003e\u003cspan class=\"o\"\u003e],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003erightKeys\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eSeq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eExpression\u003c/span\u003e\u003cspan class=\"o\"\u003e],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003econdition\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eOption\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eExpression\u003c/span\u003e\u003cspan class=\"o\"\u003e],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eeventTimeWatermark\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eOption\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eJoinStateWatermarkPredicates\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e此方法通过应用不同的规则来计算用于从状态存储中丢弃太晚的行的状态水位谓词。 它首先检查查询的相等性 JOIN 中涉及的所有列中是否至少有一个用水位注释标记的列。 如果是，它将自动认为必须将状态键水位策略应用于迟到的行（您可以在 \u003ca href=\"https://www.waitingforcode.com/apache-spark-structured-streaming/outer-joins-apache-spark-structured-streaming/read\"\u003eApache Spark 结构化流的外连接\u003c/a\u003e中了解它们）。 如果不是，则检查一个连接侧是否定义了水位列。 如果满足上述条件之一，并且优先选择前者，则使用常规的 org.apache.spark.sql.execution.streaming.WatermarkSupport＃watermarkExpression(optionalWatermarkExpression: Option[Expression], optionalWatermarkMs: Option[Long]) 方法。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJOIN 子句中的相等重要性\n流到流连接的实际实现仅接受相等关系作为连接键。 这意味着如果我们有2个流：stream#1(field1[int], field2[timestamp]), stream#2(field10[int], field20[timestamp]), ，则只有 field1 和 field10 之间的相等关系以及 field2 和 field20 将被视为连接键。 如果在 JOIN 的 ON 部分中表示不等式，则会将其转换为 WHERE 条件。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e例如，以下查询：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003emainEventsDataset\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emainEventsStream\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etoDS\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eselect\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e$\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;mainKey\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003e$\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;mainEventTime\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003e$\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;mainEventTimeWatermark\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ewindow\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e$\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;mainEventTimeWatermark\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;3 seconds\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eas\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;mainWatermarkWindow\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)).\u003c/span\u003e\u003cspan class=\"n\"\u003ewithWatermark\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;mainWatermarkWindow\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;3 seconds\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ejoinedEventsDataset\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ejoinedEventsStream\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etoDS\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eselect\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e$\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;joinedKey\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003e$\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;joinedEventTime\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003e$\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;joinedEventTimeWatermark\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ewindow\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e$\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;joinedEventTimeWatermark\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;3 seconds\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eas\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;joinedWatermarkWindow\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)).\u003c/span\u003e\u003cspan class=\"n\"\u003ewithWatermark\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;joinedWatermarkWindow\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;3 seconds\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003estream\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emainEventsDataset\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ejoin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ejoinedEventsDataset\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003emainEventsDataset\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;mainKey\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e===\u003c/span\u003e \u003cspan class=\"n\"\u003ejoinedEventsDataset\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;joinedKey\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eexpr\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;joinedWatermarkWindow \u0026gt; mainWatermarkWindow\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003equery\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estream\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewriteStream\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etrigger\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eTrigger\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eProcessingTime\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e5000L\u003c/span\u003e\u003cspan class=\"o\"\u003e)).\u003c/span\u003e\u003cspan class=\"n\"\u003eforeach\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eRowProcessor\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e会被转换为：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e+- Exchange hashpartitioning(joinedKey#966, 200)\n   +- EventTimeWatermark joinedWatermarkWindow#23: struct, interval 3 seconds\n      +- Union\n         :- *(7) Project [joinedKey#966, joinedEventTime#967L, joinedEventTimeWatermark#968, named_struct(start, precisetimestampconversion(((((CASE WHEN \n         // ...\n         :  +- *(7) Filter (isnotnull(joinedEventTimeWatermark#968) \u0026amp;\u0026amp; isnotnull(joinedKey#966))\n         :     +- LocalTableScan [joinedKey#966, joinedEventTime#967L, joinedEventTimeWatermark#968]\n// ...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e虽然类似的查询，但在JOIN子句中具有相等条件，但将在数据混洗级别进行：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003estream\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emainEventsDataset\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ejoin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ejoinedEventsDataset\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003emainEventsDataset\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;mainKey\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e===\u003c/span\u003e \u003cspan class=\"n\"\u003ejoinedEventsDataset\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;joinedKey\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003emainEventsDataset\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;mainEventTimeWatermark\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e===\u003c/span\u003e \u003cspan class=\"n\"\u003ejoinedEventsDataset\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;joinedEventTimeWatermark\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e并且物理执行计划为：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e== Physical Plan ==\nStreamingSymmetricHashJoin [mainKey#1447, mainEventTimeWatermark#1449-T2000ms], [joinedKey#1451, joinedEventTimeWatermark#1453], Inner, condition = [ leftOnly = null, rightOnly = null, both = null, full = null ], state info [ checkpoint = file:/tmp/temporary-4bd3025b-1e05-4410-9ee4-04dd4191c63b/state, runId = b85412cd-94b1-4112-8d81-1e5c2e94a0f9, opId = 0, ver = 2, numPartitions = 200], 8000, state cleanup [ left key predicate: (input[1, timestamp, true] \u0026lt;= 8000000), right key predicate: (input[1, timestamp, true] \u0026lt;= 8000000) ]\n:- Exchange hashpartitioning(mainKey#1447, mainEventTimeWatermark#1449-T2000ms, 200)\n:  +- *(5) Filter isnotnull(mainEventTimeWatermark#1449-T2000ms)\n:     +- EventTimeWatermark mainEventTimeWatermark#1449: timestamp, interval 2 seconds\n:        +- Union\n// ...\n:              +- LocalTableScan [mainKey#2479, mainEventTime#2480L, mainEventTimeWatermark#2481]\n+- Exchange hashpartitioning(joinedKey#1451, joinedEventTimeWatermark#1453, 200)\n   +- Union\n      :- *(6) Filter (isnotnull(joinedEventTimeWatermark#1453) \u0026amp;\u0026amp; isnotnull(joinedKey#1451))\n      :  +- LocalTableScan [joinedKey#1451, joinedEventTime#1452L, joinedEventTimeWatermark#1453]\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"旧状态清理\"\u003e旧状态清理\u003c/h2\u003e\n\u003cp\u003e定义水位表达式后，引擎将其转换为状态键水位的实例 (JoinStateKeyWatermarkPredicate(expr: Expression))  或状态值水位 (JoinStateValueWatermarkPredicate(expr: Expression))。需要强调的是，每个查询方都有自己的谓词，因为每个流可以具有不同的延迟特性。\u003c/p\u003e\n\u003cp\u003e这种构建的谓词稍后用于 org.apache.spark.sql.execution.streaming.StreamingSymmetricHashJoinExec。OneSideHashJoiner 实例由 StreamingSymmetricHashJoinExec 引用。在删除过程中，引擎将调用适当的 \u003ccode\u003eSymmetricHashJoinStateManager\u003c/code\u003e 的方法：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eremoveByKeyCondition(removalCondition: UnsafeRow =\u0026gt; Boolean) 用于键水位\u003c/li\u003e\n\u003cli\u003eremoveByValueCondition(removalCondition: UnsafeRow =\u0026gt; Boolean) 用于值水位\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e两种方法的参数都是从基础水位类型构建的谓词。 对于值一，它可以表示为(joinedWatermarkWindow＃23-T3000ms\u0026gt; mainWatermarkWindow＃14-T3000ms)。 内部将状态存储为 multi-map，即一个具有零个或多个值的键。 这样引擎就只能删除一部分存储状态。\u003c/p\u003e\n\u003ch3 id=\"连接\"\u003e连接\u003c/h3\u003e\n\u003cp\u003e到目前为止，我们已经了解了状态管理，但是如何连接自己呢？在信息块的第一部分中，简要介绍了它们的执行情况。正如我们在此处看到的那样，不可避免地要通过哈希交换（即混洗）进行连接。具有给定连接键的所有行都移到同一分区，这就是魔术发生的地方。物理执行是通过 \u003ccode\u003eprocessPartitions(leftInputIter: Iterator[InternalRow], rightInputIter: Iterator[InternalRow])\u003c/code\u003e 方法进行的。它由2个 OneSideHashJoiner 实例提供帮助，每个实例代表联接的每一侧。\u003c/p\u003e\n\u003cp\u003e连接的结果是一行 \u003ccode\u003eorg.apache.spark.sql.catalyst.expressions.JoinedRow\u003c/code\u003e 类型，该类型使用 \u003ccode\u003ewithLeft(InternalRow)\u003c/code\u003e 和 \u003ccode\u003ewithRight(InternalRow)\u003c/code\u003e 方法构造。但是在发生之前，OneSideHashJoiner 首先检索所有非迟到的行，并为它们中的每一个检索，并检查是否满足过滤条件。这些条件是连接前过滤器（仅适用于已处理连接侧的过滤器）和连接后过滤器（整体连接条件）。稍后，连接器尝试通过执行以下操作为每条有效行在另一侧找到匹配的行：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ekey\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekeyGenerator\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ethisRow\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eoutputIter\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eotherSideJoiner\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ejoinStateManager\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eget\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003ethatRow\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003egenerateJoinedRow\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ethisRow\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ethatRow\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e}.\u003c/span\u003e\u003cspan class=\"n\"\u003efilter\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epostJoinFilter\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果实际匹配的行（原始版本，未连接）可以保留在状态存储中，则连接器稍后进行验证。 仅当2个水位谓词（键和值，已在文章中提到）有效（即行本身未过期）时，该参数才会保留在该位置。 这就是内连接的全部内容。 对于外连接，将启动特殊处理。 匹配的行由不匹配完成，发生在这里：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eoutputIter\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eIterator\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eInternalRow\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ejoinType\u003c/span\u003e \u003cspan class=\"k\"\u003ematch\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"nc\"\u003eInner\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003einnerOutputIter\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"nc\"\u003eLeftOuter\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003ematchesWithRightSideState\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eleftKeyValue\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eUnsafeRowPair\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"n\"\u003erightSideJoiner\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eget\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eleftKeyValue\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eexists\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003erightValue\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003epostJoinFilter\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ejoinedRow\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewithLeft\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eleftKeyValue\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewithRight\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erightValue\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// BK: removeOldState returns an iterator with expired rows \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"c1\"\u003e//     It clearly shows that without watermark it wouldn\u0026#39;t be possible\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"c1\"\u003e//     to emit not matched ones in the case of outer join.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eremovedRowIter\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eleftSideJoiner\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eremoveOldState\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eouterOutputIter\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eremovedRowIter\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efilterNot\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epair\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ematchesWithRightSideState\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epair\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epair\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ejoinedRow\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewithLeft\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epair\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewithRight\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enullRight\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003einnerOutputIter\u003c/span\u003e \u003cspan class=\"o\"\u003e++\u003c/span\u003e \u003cspan class=\"n\"\u003eouterOutputIter\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"nc\"\u003eRightOuter\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// BK: does the same as LeftOuter but by switching sides\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e  \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"k\"\u003e_\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ethrowBadJoinTypeException\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e使用完所有连接的行后，将执行回调以从状态存储中删除旧状态：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ecleanupIter\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ejoinType\u003c/span\u003e \u003cspan class=\"k\"\u003ematch\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"nc\"\u003eInner\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eleftSideJoiner\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eremoveOldState\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e++\u003c/span\u003e \u003cspan class=\"n\"\u003erightSideJoiner\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eremoveOldState\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"c1\"\u003e// BK: for outer only joined rows are removed - the removal of outer side\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e  \u003cspan class=\"c1\"\u003e//     was made before, at generating not fully matched rows\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e  \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"nc\"\u003eLeftOuter\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003erightSideJoiner\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eremoveOldState\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"nc\"\u003eRightOuter\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eleftSideJoiner\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eremoveOldState\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"k\"\u003e_\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ethrowBadJoinTypeException\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e}\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e无限数据源中的状态管理非常重要。 通过计算水位谓词，它有助于减少存储的行数。 但是，如本文第一部分所示，它不是流连接功能中涉及的单个部分。 另一个在寻找匹配。 在第3部分中介绍，它描述了StreamingSymmetricHashJoinExec 的 processPartitions 方法中实现的连接逻辑。 如我们所知，该操作首先检索有效行（过滤器+允许的延迟），然后只有主行在另一侧查找匹配的行。 完成此操作后，将返回一个包含所有连接行的迭代器，并且在迭代结束时将调用清理旧行的函数。\u003c/p\u003e\n","text":"在最近关于Apache Spark结构化流的3篇文章中，我们发现了流连接：内部连接，外部连接和状态管理策略。发现所有这些操作背后发生的事情是总结该系列的一个好方法。 这篇文章首先介绍了流连接过程中涉及的类。接下来是专注于与联接有关的状态管理内部的部分。文章以关于连接机制的一小段结尾。\n所涉及的类 在流连接所涉及的类中，我们可以区分3个非常重要的类：SymmetricHashJoinStateManager，StreamingSymmetricHashJoinExec 和 StreamingJoinHelper。所有这些都用于流查询执行的不同阶段。\n首先，查询的流式表示形式 IncrementalExecution 实例存储对该状态的引用。如果查询具有某些流间连接，则此状态在每次执行时都表示为 StreamingSymmetricHashJoinExec 的实例。该实例在每次执行中都不同，不同点是偏移量统计信息和状态水位谓词。谓词的计算公式为：\ndef getStateWatermarkPredicates( leftAttributes: Seq[Attribute], rightAttributes: Seq[Attribute], leftKeys: Seq[Expression], rightKeys: Seq[Expression], condition: Option[Expression], eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates 此方法通过应用不同的规则来计算用于从状态存储中丢弃太晚的行的状态水位谓词。 它首先检查查询的相等性 JOIN 中涉及的所有列中是否至少有一个用水位注释标记的列。 如果是，它将自动认为必须将状态键水位策略应用于迟到的行（您可以在 Apache Spark 结构化流的外连接中了解它们）。 如果不是，则检查一个连接侧是否定义了水位列。 如果满足上述条件之一，并且优先选择前者，则使用常规的 org.apache.spark.sql.execution.streaming.WatermarkSupport＃watermarkExpression(optionalWatermarkExpression: Option[Expression], optionalWatermarkMs: Option[Long]) 方法。\nJOIN 子句中的相等重要性 流到流连接的实际实现仅接受相等关系作为连接键。 这意味着如果我们有2个流：stream#1(field1[int], field2[timestamp]), stream#2(field10[int], field20[timestamp]), ，则只有 field1 和 field10 之间的相等关系以及 field2 和 field20 将被视为连接键。 如果在 JOIN 的 ON 部分中表示不等式，则会将其转换为 WHERE 条件。\n例如，以下查询：\nval mainEventsDataset = mainEventsStream.toDS().select($\u0026#34;mainKey\u0026#34;, $\u0026#34;mainEventTime\u0026#34;, $\u0026#34;mainEventTimeWatermark\u0026#34;, window($\u0026#34;mainEventTimeWatermark\u0026#34;, \u0026#34;3 seconds\u0026#34;).as(\u0026#34;mainWatermarkWindow\u0026#34;)).withWatermark(\u0026#34;mainWatermarkWindow\u0026#34;, \u0026#34;3 seconds\u0026#34;) val joinedEventsDataset = joinedEventsStream.toDS().select($\u0026#34;joinedKey\u0026#34;, $\u0026#34;joinedEventTime\u0026#34;, $\u0026#34;joinedEventTimeWatermark\u0026#34;, window($\u0026#34;joinedEventTimeWatermark\u0026#34;, \u0026#34;3 seconds\u0026#34;).as(\u0026#34;joinedWatermarkWindow\u0026#34;)).withWatermark(\u0026#34;joinedWatermarkWindow\u0026#34;, \u0026#34;3 seconds\u0026#34;) val stream = mainEventsDataset.join(joinedEventsDataset, mainEventsDataset(\u0026#34;mainKey\u0026#34;) === joinedEventsDataset(\u0026#34;joinedKey\u0026#34;) \u0026amp;\u0026amp; expr(\u0026#34;joinedWatermarkWindow \u0026gt; mainWatermarkWindow\u0026#34;)) val query = stream.writeStream.trigger(Trigger.ProcessingTime(5000L)).foreach(RowProcessor).start() 会被转换为：\n+- Exchange hashpartitioning(joinedKey#966, 200) +- EventTimeWatermark joinedWatermarkWindow#23: struct, interval 3 seconds +- Union :- *(7) Project [joinedKey#966, joinedEventTime#967L, joinedEventTimeWatermark#968, named_struct(start, precisetimestampconversion(((((CASE WHEN // ... : +- *(7) Filter (isnotnull(joinedEventTimeWatermark#968) \u0026amp;\u0026amp; isnotnull(joinedKey#966)) : +- LocalTableScan [joinedKey#966, joinedEventTime#967L, joinedEventTimeWatermark#968] // ... 虽然类似的查询，但在JOIN子句中具有相等条件，但将在数据混洗级别进行：\nval stream = mainEventsDataset.join(joinedEventsDataset, mainEventsDataset(\u0026#34;mainKey\u0026#34;) === joinedEventsDataset(\u0026#34;joinedKey\u0026#34;) \u0026amp;\u0026amp; mainEventsDataset(\u0026#34;mainEventTimeWatermark\u0026#34;) === joinedEventsDataset(\u0026#34;joinedEventTimeWatermark\u0026#34;)) 并且物理执行计划为：\n== Physical Plan == StreamingSymmetricHashJoin [mainKey#1447, mainEventTimeWatermark#1449-T2000ms], [joinedKey#1451, joinedEventTimeWatermark#1453], Inner, condition = [ leftOnly = null, rightOnly = null, both = null, full = null ], state info [ checkpoint = file:/tmp/temporary-4bd3025b-1e05-4410-9ee4-04dd4191c63b/state, runId = b85412cd-94b1-4112-8d81-1e5c2e94a0f9, opId = 0, ver = 2, numPartitions = 200], 8000, state cleanup [ left key predicate: (input[1, timestamp, true] \u0026lt;= 8000000), right key predicate: (input[1, timestamp, true] \u0026lt;= 8000000) ] :- Exchange hashpartitioning(mainKey#1447, mainEventTimeWatermark#1449-T2000ms, 200) : +- *(5) Filter isnotnull(mainEventTimeWatermark#1449-T2000ms) : +- EventTimeWatermark mainEventTimeWatermark#1449: timestamp, interval 2 seconds : +- Union // ... : +- LocalTableScan [mainKey#2479, mainEventTime#2480L, mainEventTimeWatermark#2481] +- Exchange hashpartitioning(joinedKey#1451, joinedEventTimeWatermark#1453, 200) +- Union :- *(6) Filter (isnotnull(joinedEventTimeWatermark#1453) \u0026amp;\u0026amp; isnotnull(joinedKey#1451)) : +- LocalTableScan [joinedKey#1451, joinedEventTime#1452L, joinedEventTimeWatermark#1453] 旧状态清理 定义水位表达式后，引擎将其转换为状态键水位的实例 (JoinStateKeyWatermarkPredicate(expr: Expression)) 或状态值水位 (JoinStateValueWatermarkPredicate(expr: Expression))。需要强调的是，每个查询方都有自己的谓词，因为每个流可以具有不同的延迟特性。\n这种构建的谓词稍后用于 org.apache.spark.sql.execution.streaming.StreamingSymmetricHashJoinExec。OneSideHashJoiner 实例由 StreamingSymmetricHashJoinExec 引用。在删除过程中，引擎将调用适当的 SymmetricHashJoinStateManager 的方法：\nremoveByKeyCondition(removalCondition: UnsafeRow =\u0026gt; Boolean) 用于键水位 removeByValueCondition(removalCondition: UnsafeRow =\u0026gt; Boolean) 用于值水位 两种方法的参数都是从基础水位类型构建的谓词。 对于值一，它可以表示为(joinedWatermarkWindow＃23-T3000ms\u0026gt; mainWatermarkWindow＃14-T3000ms)。 内部将状态存储为 multi-map，即一个具有零个或多个值的键。 这样引擎就只能删除一部分存储状态。\n连接 到目前为止，我们已经了解了状态管理，但是如何连接自己呢？在信息块的第一部分中，简要介绍了它们的执行情况。正如我们在此处看到的那样，不可避免地要通过哈希交换（即混洗）进行连接。具有给定连接键的所有行都移到同一分区，这就是魔术发生的地方。物理执行是通过 processPartitions(leftInputIter: Iterator[InternalRow], rightInputIter: Iterator[InternalRow]) 方法进行的。它由2个 OneSideHashJoiner 实例提供帮助，每个实例代表联接的每一侧。\n连接的结果是一行 org.apache.spark.sql.catalyst.expressions.JoinedRow 类型，该类型使用 withLeft(InternalRow) 和 withRight(InternalRow) 方法构造。但是在发生之前，OneSideHashJoiner 首先检索所有非迟到的行，并为它们中的每一个检索，并检查是否满足过滤条件。这些条件是连接前过滤器（仅适用于已处理连接侧的过滤器）和连接后过滤器（整体连接条件）。稍后，连接器尝试通过执行以下操作为每条有效行在另一侧找到匹配的行：\nval key = keyGenerator(thisRow) val outputIter = otherSideJoiner.joinStateManager.get(key).map { thatRow =\u0026gt; generateJoinedRow(thisRow, thatRow) }.filter(postJoinFilter) 如果实际匹配的行（原始版本，未连接）可以保留在状态存储中，则连接器稍后进行验证。 仅当2个水位谓词（键和值，已在文章中提到）有效（即行本身未过期）时，该参数才会保留在该位置。 这就是内连接的全部内容。 对于外连接，将启动特殊处理。 匹配的行由不匹配完成，发生在这里：\nval outputIter: Iterator[InternalRow] = joinType match { case Inner =\u0026gt; innerOutputIter case LeftOuter =\u0026gt; def matchesWithRightSideState(leftKeyValue: UnsafeRowPair) = { rightSideJoiner.get(leftKeyValue.key).exists { rightValue =\u0026gt; postJoinFilter(joinedRow.withLeft(leftKeyValue.value).withRight(rightValue)) } } // BK: removeOldState returns an iterator with expired rows // It clearly shows that without watermark it wouldn\u0026#39;t be possible // to emit not matched ones in the case of outer join. val removedRowIter = leftSideJoiner.removeOldState() val outerOutputIter = removedRowIter .filterNot(pair =\u0026gt; matchesWithRightSideState(pair)) .map(pair =\u0026gt; joinedRow.withLeft(pair.value).withRight(nullRight)) innerOutputIter ++ outerOutputIter case RightOuter =\u0026gt; // BK: does the same as LeftOuter but by switching sides case _ =\u0026gt; throwBadJoinTypeException() } 使用完所有连接的行后，将执行回调以从状态存储中删除旧状态：\nval cleanupIter = joinType match { case Inner =\u0026gt; leftSideJoiner.removeOldState() ++ rightSideJoiner.removeOldState() // BK: for outer only joined rows are removed - the removal of outer side // was made before, at generating not fully matched rows case LeftOuter =\u0026gt; rightSideJoiner.removeOldState() case RightOuter =\u0026gt; leftSideJoiner.removeOldState() case _ =\u0026gt; throwBadJoinTypeException() } 无限数据源中的状态管理非常重要。 通过计算水位谓词，它有助于减少存储的行数。 但是，如本文第一部分所示，它不是流连接功能中涉及的单个部分。 另一个在寻找匹配。 在第3部分中介绍，它描述了StreamingSymmetricHashJoinExec 的 processPartitions 方法中实现的连接逻辑。 如我们所知，该操作首先检索有效行（过滤器+允许的延迟），然后只有主行在另一侧查找匹配的行。 完成此操作后，将返回一个包含所有连接行的迭代器，并且在迭代结束时将调用清理旧行的函数。\n"},"name":"流和流之间的连接内部研讨","published":"2019-10-03T17:36:48Z","summary":"在最近关于Apache Spark结构化流的3篇文章中，我们发现了流连接：内部连接，外部连接和状态管理策略。发现所有这些操作背后发生的事情是总结该系列的一个好方法。 这篇文章首先介绍了流连接过程中涉及的类。接下来是专注于与联接有关的状态管理内部的部分。文章以关于连接机制的一小段结尾。\n所涉及的类 在流连接所涉及的类中，我们可以区分3个非常重要的类：SymmetricHashJoinStateManager，StreamingSymmetricHashJoinExec 和 StreamingJoinHelper。所有这些都用于流查询执行的不同阶段。\n首先，查询的流式表示形式 IncrementalExecution 实例存储对该状态的引用。如果查询具有某些流间连接，则此状态在每次执行时都表示为 StreamingSymmetricHashJoinExec 的实例。该实例在每次执行中都不同，不同点是偏移量统计信息和状态水位谓词。谓词的计算公式为：\ndef getStateWatermarkPredicates( leftAttributes: Seq[Attribute], rightAttributes: Seq[Attribute], leftKeys: Seq[Expression], rightKeys: Seq[Expression], condition: Option[Expression], eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates 此方法通过应用不同的规则来计算用于从状态存储中丢弃太晚的行的状态水位谓词。 它首先检查查询的相等性 JOIN 中涉及的所有列中是否至少有一个用水位注释标记的列。 如果是，它将自动认为必须将状态键水位策略应用于迟到的行（您可以在 Apache Spark 结构化流的外连接中了解它们）。 如果不是，则检查一个连接侧是否定义了水位列。 如果满足上述条件之一，并且优先选择前者，则使用常规的 org.apache.spark.sql.execution.streaming.WatermarkSupport＃watermarkExpression(optionalWatermarkExpression: Option[Expression], optionalWatermarkMs: Option[Long]) 方法。\nJOIN 子句中的相等重要性 流到流连接的实际实现仅接受相等关系作为连接键。 这意味着如果我们有2个流：stream#1(field1[int], field2[timestamp]), stream#2(field10[int], field20[timestamp]), ，则只有 field1 和 field10 之间的相等关系以及 field2 和 field20 将被视为连接键。 如果在 JOIN 的 ON 部分中表示不等式，则会将其转换为 WHERE 条件。\n例如，以下查询：\nval mainEventsDataset = mainEventsStream.toDS().select($\u0026#34;mainKey\u0026#34;, $\u0026#34;mainEventTime\u0026#34;, $\u0026#34;mainEventTimeWatermark\u0026#34;, window($\u0026#34;mainEventTimeWatermark\u0026#34;, \u0026#34;3 seconds\u0026#34;).","type":"entry","url":"http://localhost:1313/notes/stream-to-stream-joins-internals/"}