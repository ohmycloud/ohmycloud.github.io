<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
    
    
    

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    
    <meta name="referrer" content="no-referrer">

    <title>
        
            窗口 ❚ 焉知非鱼
        
    </title>

    
    


    
    
    
    

    
    
    
    

    
    
    

    
    
    
    <style>
     
     
     :root {
         --theme-color: #ac4142;
         --theme-color-light: rgba(172, 65, 66, 0.2);
     }
     
     html {
         line-height: 1.5;
     }
    </style>

    
    

    
    
    
    
    <link rel="stylesheet" href="/css/refined.min.61b1de55623520dab99b70e9e2298001fb97241583a47396e2f10feb789e300d.css">
    
    <link rel="preload" href="/css/refined.min.61b1de55623520dab99b70e9e2298001fb97241583a47396e2f10feb789e300d.css" as="style">

    



    
        <style>
         
         /* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }

         
         /* Overrides on top of the theme and Chroma CSS */
/* Chroma-based lines highlighting in code blocks */
.chroma .hl {
    background-color: #e8e8e8;
    /* Extend highlight up to 100 characters (assuming that the code blocks never have more than 100 characters in a line) */
    min-width: 100ch;
}
/* GenericHeading */ .chroma .gh { color: #999999; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa; font-weight: bold }

         
        </style>
    

    

    
    
    

    
    <script src="/js/responsive-nav-orig.min.355eebd835ac8071d56b337f68ffbbddc0f6487625599895e3e0b0461e791ebb.js"></script>
    
    <link rel="preload" href="/js/responsive-nav-orig.min.355eebd835ac8071d56b337f68ffbbddc0f6487625599895e3e0b0461e791ebb.js" as="script">

    
    
    <script defer src="/js/libs/fa/fontawesome-all.min.78bd3583027f40ce4330d39e1f1df56bda5f4af819aac2d0214ba529918c9e95.js"></script>
    
    <link rel="preload" href="/js/libs/fa/fontawesome-all.min.78bd3583027f40ce4330d39e1f1df56bda5f4af819aac2d0214ba529918c9e95.js" as="script">

    

    

    
    
    

    
    
<!-- rel="me" links for IndieAuth -->







    
 
<meta property="og:title" content="窗口" />
<meta property="og:description"
      content="Windows" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ohmyweekly.github.io/notes/2020-08-22-windows/" />


    
        <meta property="article:published_time" content="2020-08-22T00:00:00&#43;08:00"/>
    
    
        <meta property="article:modified_time" content="2020-08-22T00:00:00&#43;08:00"/>
    









    




     <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="窗口"/>
<meta name="twitter:description" content="Windows"/>


    
    
    <link rel="alternate" type="application/jf2post+json" href="https://ohmyweekly.github.io/notes/2020-08-22-windows/jf2post.json" title="Jf2post for 焉知非鱼" />
    
     



    
    
    
        
    


     
        
        <meta name="DC.Creator" content="焉知非鱼"/>
    



    
    
    
    <meta name="hugo-build-date" content=""/>
    <meta name="hugo-commit-hash" content=""/>
    <meta name="generator" content="Hugo 0.63.2" />
</head>


    
        <body lang="en">
    

        
        <div class="border" id="home"></div>

        <div class="wrapper">   
            
<nav id="nav" class="nav-collapse opened" aria-hidden="false">
    <ul class="navbar">
        <li><a class="" href="/">Home</a></li>
        
            
                <li><a class="" href="https://ohmyweekly.github.io/posts/">Posts</a></li>
            
        
            
                <li><a class="" href="https://ohmyweekly.github.io/notes/">Notes</a></li>
            
        
        
            <li><a class="" href="https://ohmyweekly.github.io/search/">Search</a></li>
        
    </ul>
</nav>

            <div class="container">
                <header class="masthead">
                    <div class="masthead-title no-text-decoration">
                        <a href="/">焉知非鱼</a> <span class="blinking-cursor">❚</span>
                    </div>
                    <div class="masthead-tagline">
                        rakulang, dartlang, nimlang, golang, rustlang, lang lang no see
                    </div>
                </header>

                








<article class="post h-entry notes">
    <header>
        <div class="center">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 55 posts categorized in ‘Flink’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/categories/flink/">Flink</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 74 posts tagged with ‘Flink’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/flink/">Flink</a>
                            </li>
                        
                    
                        
                        
                        
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__datastream-api__"
                                
                                
                                title="See all 24 posts tagged with ‘DataStream API’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/datastream-api/">DataStream API</a>
                            </li>
                        
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__operators__"
                                
                                
                                title="See all 3 posts tagged with ‘Operators’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/operators/">Operators</a>
                            </li>
                        
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__windows__"
                                
                                
                                title="This is the only post tagged with ‘Windows’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/windows/">Windows</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>

        <h1 class="post-title p-name">窗口</h1>

        
        <data class="u-url" value="https://ohmyweekly.github.io/notes/2020-08-22-windows/"></data>

        <div class="date-syndication">
            


    
    
    <div class="post-date">
        
        <time datetime="2020-08-22T00:00:00+0800" class="dt-published">Sat Aug 22, 2020</time>
        
        
    </div>


            




        </div>
         



    
    
    
        
    


    
        
        <span class="hide">
            &mdash; <a href="https://ohmyweekly.github.io" class="u-author">焉知非鱼</a>
        </span>
    


    </header>

    <div class="content">
        
    <div class="description p-summary">
        
        
        
        
        
            
            
        
        <p>Windows</p>
    </div>



        





                       


        <div class="e-content">
            




<h1 id="窗口">窗口</h1>
<p>窗口是处理无限流的核心。窗口将流分割成有限大小的&quot;桶&rdquo;，我们可以对其应用计算。本文档主要介绍 Flink 中如何进行窗口化，以及程序员如何从其提供的功能中最大限度地受益。</p>
<p>下面介绍了一个窗口化 Flink 程序的一般结构。第一个片段指的是 keyed 流，而第二个片段指的是 non-keyed 流。正如人们所看到的那样，唯一的区别是 keyed 流的 <code>keyBy(...)</code> 调用和 non-keyed 流的 <code>window(...)</code> 变成了 <code>windowAll(...)</code>。这也将作为本页面其他内容的路线图。</p>
<p><strong>Keyed 窗口</strong></p>
<pre><code>stream
       .keyBy(...)               &lt;-  keyed 与 non-keyed 窗口的对比
       .window(...)              &lt;-  必须的: &quot;assigner&quot;
      [.trigger(...)]            &lt;-  可选的: &quot;trigger&quot; (否则使用默认的 trigger)
      [.evictor(...)]            &lt;-  可选的: &quot;evictor&quot; (否则没有 evictor)
      [.allowedLateness(...)]    &lt;-  可选的: &quot;lateness&quot; (否则为零)
      [.sideOutputLateData(...)] &lt;-  可选的: &quot;output tag&quot; (否则迟到数据无侧输出)
       .reduce/aggregate/fold/apply()      &lt;-  必须的: &quot;function&quot;
      [.getSideOutput(...)]      &lt;-  可选的: &quot;output tag&quot;
</code></pre><p><strong>Non-Keyed 窗口</strong></p>
<pre><code>stream
       .windowAll(...)           &lt;-  必须的: &quot;assigner&quot;
      [.trigger(...)]            &lt;-  可选的: &quot;trigger&quot; (否则使用默认的 trigger)
      [.evictor(...)]            &lt;-  可选的: &quot;evictor&quot; (否则没有 evictor)
      [.allowedLateness(...)]    &lt;-  可选的: &quot;lateness&quot; (否则为零)
      [.sideOutputLateData(...)] &lt;-  可选的: &quot;output tag&quot; (否则迟到数据无侧输出)
       .reduce/aggregate/fold/apply()      &lt;-  必须的: &quot;function&quot;
      [.getSideOutput(...)]      &lt;-  可选的: &quot;output tag&quot;
</code></pre><p>在上面，方括号中的命令(<code>[...]</code>)是可选的。这表明 Flink 允许你以多种不同的方式定制你的窗口逻辑，以便它最适合你的需求。</p>
<h2 id="窗口生命周期">窗口生命周期&nbsp;<a class="headline-hash no-text-decoration" href="#窗口生命周期">#</a> </h2>
<p>简而言之，当第一个应该属于这个窗口的元素到达时，就会创建一个窗口，当时间（事件时间或处理时间）经过(passes)它的结束时间戳加上用户指定的允许延迟时，这个窗口就会被完全移除（见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#allowed-lateness">允许延迟</a>）。Flink 只保证对基于时间的窗口进行移除，而不保证对其他类型的窗口，如全局窗口进行移除（见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#window-assigners">窗口分配器</a>）。例如，基于事件-时间的窗口策略每5分钟创建一个非重叠（或翻滚）的窗口，并且允许的延迟为1分钟，当第一个具有时间戳的元素落入这个区间时，Flink 将为 12:00 和 12:05 之间的区间创建一个新的窗口，当水印通过 12:06 的时间戳时，它将删除它。</p>
<p>此外，每个窗口将有一个触发器(见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#triggers">触发器</a>)和一个函数(ProcessWindowFunction、ReduceFunction、AggregateFunction或FoldFunction)(见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#window-functions">窗口函数</a>)。函数将包含要应用于窗口内容的计算，而触发器则指定了窗口被认为可以应用函数的条件。触发策略可能是&quot;当窗口中的元素数量超过4时&rdquo;，或者&quot;当水印经过窗口的末端时&rdquo;。触发器还可以决定在创建和删除窗口之间的任何时间(any time between its creation and removal)清除窗口的内容。在这种情况下，清除只指窗口中的元素，而不是窗口元数据。这意味着新的数据仍然可以被添加到该窗口中。</p>
<p>除上述之外，您还可以指定一个 Evictor(见 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#evictors">Evictors</a>)，它将能够在触发器触发后以及在函数应用之前和/或之后从窗口中删除元素。</p>
<p>在下文中，我们将对上述每个组件进行更详细的介绍。我们先从上述代码段中必须的部分开始(参见 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#keyed-vs-non-keyed-windows">Keyed vs Non-Keyed 窗口</a>、<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#window-assigner">窗口分配器</a>和<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#window-function">窗口函数</a>)，然后再转向可选部分。</p>
<h2 id="keyed-与-non-keyed-窗口的对比">Keyed 与 Non-Keyed 窗口的对比&nbsp;<a class="headline-hash no-text-decoration" href="#keyed-与-non-keyed-窗口的对比">#</a> </h2>
<p>首先要指定的是您的流是否应该是 keyed 的。这必须在定义窗口之前完成。使用 <code>keyBy(...)</code> 将把您的无限流分割成逻辑 keyed 流。如果没有调用 <code>keyBy(...)</code>，那么您的流就不是 keyed 流。</p>
<p>在 keyed 流的情况下，传入事件的任何属性都可以被用作键（更多细节在<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html#keyed-datastream">这里</a>）。拥有一个 keyed 流将允许你的窗口计算由多个任务并行执行，因为每个逻辑 keyed 流可以独立于其他流进行处理。所有指向同一键的元素将被发送到同一个并行任务(task)。</p>
<p>在 non-keyed 流的情况下，您的原始流不会被分割成多个逻辑流，所有的窗口化逻辑将由一个任务(task)来执行，即并行度为1。</p>
<h2 id="窗口分配器">窗口分配器&nbsp;<a class="headline-hash no-text-decoration" href="#窗口分配器">#</a> </h2>
<p>在指定流是否是 keyed 流之后，下一步是定义窗口分配器。窗口分配器定义了如何将元素分配给窗口。这是通过在 <code>window(...)</code>（对于 keyed 流）或 <code>windowAll()</code>（对于 non-keyed 流）调用中指定您所选择的 <code>WindowAssigner</code> 来实现的。</p>
<p><code>WindowAssigner</code> 负责将每个传入的元素分配给一个或多个窗口。Flink 为最常见的用例提供了预定义的窗口分配器，即滚动窗口、滑动窗口、会话窗口和全局窗口。您也可以通过扩展 <code>WindowAssigner</code> 类来实现自定义窗口分配器。所有内置的窗口分配器（除了全局窗口）都是基于时间将元素分配给窗口，时间可以是处理时间，也可以是事件时间。请查看我们关于<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_time.html">事件时间</a>的部分，了解处理时间和事件时间之间的区别，以及时间戳和水印是如何生成的。</p>
<p>基于时间的窗口有一个开始时间戳（包括）和结束时间戳（不包括），共同描述窗口的大小。在代码中，Flink 在处理基于时间的窗口时使用了 <code>TimeWindow</code>，它有查询开始和结束时间戳的方法，还有一个额外的方法 <code>maxTimestamp()</code>，可以返回给定窗口的最大允许时间戳。</p>
<p>在下文中，我们将展示 Flink 的预定义窗口分配器是如何工作的，以及如何在 DataStream 程序中使用它们。下图直观地展示了每个分配器的工作情况。紫色的圆圈代表流的元素，这些元素被某个键（在本例中是用户1、用户2和用户3）分割。x轴显示的是时间的进度。</p>
<h2 id="滚动窗口">滚动窗口&nbsp;<a class="headline-hash no-text-decoration" href="#滚动窗口">#</a> </h2>
<p>滚动窗口分配器将每个元素分配到一个指定窗口大小的窗口。滚动窗口有一个固定的大小，并且不重叠。例如，如果你指定了一个大小为5分钟的滚动窗口，那么当前的窗口将被评估，并且每隔5分钟就会启动一个新的窗口，如下图所示。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/tumbling-windows.svg" alt="img"></p>
<p>以下代码片段展示了如何使用滚动窗口。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="c1">// tumbling event-time windows
</span><span class="c1"></span><span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="o">&lt;</span><span class="n">windowed</span> <span class="n">transformation</span><span class="o">&gt;</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>

<span class="c1">// tumbling processing-time windows
</span><span class="c1"></span><span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">TumblingProcessingTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="o">&lt;</span><span class="n">windowed</span> <span class="n">transformation</span><span class="o">&gt;</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>

<span class="c1">// daily tumbling event-time windows offset by -8 hours.
</span><span class="c1"></span><span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">days</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="o">,</span> <span class="nc">Time</span><span class="o">.</span><span class="n">hours</span><span class="o">(</span><span class="o">-</span><span class="mi">8</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="o">&lt;</span><span class="n">windowed</span> <span class="n">transformation</span><span class="o">&gt;</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>
</code></pre></div><p>时间间隔可以使用 <code>Time.milliseconds(x)</code>, <code>Time.seconds(x)</code>, <code>Time.minutes(x)</code> 等中的一种来指定。</p>
<p>如最后一个例子所示，滚动窗口分配器还可以采用一个可选的偏移量(<code>offset</code>)参数，用于改变窗口的对齐方式。例如，在没有偏移量的情况下，每小时的滚动窗口与纪元对齐，也就是说，你会得到诸如 <code>1:00:00.000 - 1:59:59.999</code>，<code>2:00:00.000 - 2:59:59.999</code> 等窗口。如果你想改变这一点，你可以给出一个偏移量。例如，如果偏移量为15分钟，您将得到 <code>1:15:00.000 - 2:14:59.999</code>，<code>2:15:00.000 - 3:14:59.999</code> 等。偏移量的一个重要用途是调整窗口到 UTC-0 以外的时区。例如，在中国，你必须指定一个 <code>Time.hours(-8)</code> 的偏移量。</p>
<h2 id="滑动窗口">滑动窗口&nbsp;<a class="headline-hash no-text-decoration" href="#滑动窗口">#</a> </h2>
<p>滑动窗口分配器将元素分配给固定长度的窗口。与滚动窗口分配器类似，窗口的大小由窗口大小(window size)参数配置。一个额外的窗口滑动(window slide)参数控制滑动窗口的启动频率。因此，如果滑动窗口的滑块小于窗口大小，滑动窗口可以重叠。在这种情况下，元素被分配到多个窗口。</p>
<p>例如，你可以有10分钟大小的窗口，滑动5分钟。这样，每隔5分钟就会有一个窗口，包含过去10分钟内到达的事件，如下图所示。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/sliding-windows.svg" alt="img"></p>
<p>以下代码片段展示了如何使用滑动窗口。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="c1">// sliding event-time windows
</span><span class="c1"></span><span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">SlidingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span><span class="o">,</span> <span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="o">&lt;</span><span class="n">windowed</span> <span class="n">transformation</span><span class="o">&gt;</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>

<span class="c1">// sliding processing-time windows
</span><span class="c1"></span><span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">SlidingProcessingTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span><span class="o">,</span> <span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="o">&lt;</span><span class="n">windowed</span> <span class="n">transformation</span><span class="o">&gt;</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>

<span class="c1">// sliding processing-time windows offset by -8 hours
</span><span class="c1"></span><span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">SlidingProcessingTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">hours</span><span class="o">(</span><span class="mi">12</span><span class="o">)</span><span class="o">,</span> <span class="nc">Time</span><span class="o">.</span><span class="n">hours</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="o">,</span> <span class="nc">Time</span><span class="o">.</span><span class="n">hours</span><span class="o">(</span><span class="o">-</span><span class="mi">8</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="o">&lt;</span><span class="n">windowed</span> <span class="n">transformation</span><span class="o">&gt;</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>
</code></pre></div><p>时间间隔可以通过使用 <code>Time.milliseconds(x)</code>, <code>Time.seconds(x)</code>, <code>Time.minutes(x)</code> 等中的一个来指定。</p>
<p>如上一个例子所示，滑动窗口分配器还可以采取一个可选的偏移量(<code>offset</code>)参数，用于改变窗口的对齐方式。例如，在没有偏移量的情况下，每小时滑动30分钟的窗口与纪元对齐，也就是说，你将得到 <code>1:00:00.000 - 1:59:59.999</code>，<code>1:30:00.000 - 2:29:59.999</code> 等窗口。如果你想改变这一点，你可以给出一个偏移量。例如，如果偏移量为15分钟，您将得到 <code>1:15:00.000 - 2:14:59.999</code>，<code>1:45:00.000 - 2:44:59.999</code> 等。偏移量的一个重要用途是调整窗口到 UTC-0 以外的时区。例如，在中国，你必须指定一个 <code>Time.hours(-8)</code> 的偏移。</p>
<h2 id="会话窗口">会话窗口&nbsp;<a class="headline-hash no-text-decoration" href="#会话窗口">#</a> </h2>
<p>会话窗口分配器按活动的会话对元素进行分组。与滚动窗口和滑动窗口不同，会话窗口不重叠，也没有固定的开始和结束时间。相反，当会话窗口在一定时间内没有接收到元素时，也就是在不活动的间隙发生时，会话窗口就会关闭。会话窗口分配器可以配置一个静态的会话间隙(session gap)，也可以配置一个会话间隙提取函数，该函数定义了多长时间的不活动期。当这个时间段(period)到期(expires)时，当前会话关闭，后续元素被分配到一个新的会话窗口。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/session-windows.svg" alt="img"></p>
<p>以下代码片段展示了如何使用会话窗口。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="c1">// event-time session windows with static gap
</span><span class="c1"></span><span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">EventTimeSessionWindows</span><span class="o">.</span><span class="n">withGap</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">minutes</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="o">&lt;</span><span class="n">windowed</span> <span class="n">transformation</span><span class="o">&gt;</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>

<span class="c1">// event-time session windows with dynamic gap
</span><span class="c1"></span><span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">EventTimeSessionWindows</span><span class="o">.</span><span class="n">withDynamicGap</span><span class="o">(</span><span class="k">new</span> <span class="nc">SessionWindowTimeGapExtractor</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">extract</span><span class="o">(</span><span class="n">element</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="o">{</span>
        <span class="c1">// determine and return session gap
</span><span class="c1"></span>      <span class="o">}</span>
    <span class="o">}</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="o">&lt;</span><span class="n">windowed</span> <span class="n">transformation</span><span class="o">&gt;</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>

<span class="c1">// processing-time session windows with static gap
</span><span class="c1"></span><span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">ProcessingTimeSessionWindows</span><span class="o">.</span><span class="n">withGap</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">minutes</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="o">&lt;</span><span class="n">windowed</span> <span class="n">transformation</span><span class="o">&gt;</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>


<span class="c1">// processing-time session windows with dynamic gap
</span><span class="c1"></span><span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">DynamicProcessingTimeSessionWindows</span><span class="o">.</span><span class="n">withDynamicGap</span><span class="o">(</span><span class="k">new</span> <span class="nc">SessionWindowTimeGapExtractor</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">extract</span><span class="o">(</span><span class="n">element</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="o">{</span>
        <span class="c1">// determine and return session gap
</span><span class="c1"></span>      <span class="o">}</span>
    <span class="o">}</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="o">&lt;</span><span class="n">windowed</span> <span class="n">transformation</span><span class="o">&gt;</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>
</code></pre></div><p>静态间隙可以通过使用 <code>Time.milliseconds(x)</code>, <code>Time.seconds(x)</code>, <code>Time.minutes(x)</code> 等之一来指定。</p>
<p>动态间隙可以通过实现 <code>SessionWindowTimeGapExtractor</code> 接口来指定。</p>
<p>注意: 由于会话窗口没有固定的开始和结束，所以它们的评估方式与滚动和滑动窗口不同。在内部，会话窗口操作符为每个到达的记录创建一个新的窗口，如果它们彼此之间的距离比定义的间隙更近，就会将窗口合并在一起。为了能够合并，会话窗口操作符需要一个合并<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#triggers">触发器</a>和一个合并<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#window-functions">窗口函数</a>，如 ReduceFunction、AggregateFunction 或 ProcessWindowFunction(FoldFunction 不能合并)。</p>
<h2 id="全局窗口">全局窗口&nbsp;<a class="headline-hash no-text-decoration" href="#全局窗口">#</a> </h2>
<p>全局窗口分配器将具有相同键的所有元素分配到同一个全局窗口。只有当你还指定了一个自定义<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#triggers">触发器</a>时，这种窗口方案才有用。否则，任何计算都不会被执行，因为全局窗口没有一个自然的终点，我们可以在那里处理聚集的元素。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/non-windowed.svg" alt="img"></p>
<p>下面的代码片段展示了如何使用全局窗口。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">GlobalWindows</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="o">&lt;</span><span class="n">windowed</span> <span class="n">transformation</span><span class="o">&gt;</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>
</code></pre></div><h2 id="窗口函数">窗口函数&nbsp;<a class="headline-hash no-text-decoration" href="#窗口函数">#</a> </h2>
<p>在定义了窗口分配器之后，我们需要指定我们要对这些窗口中的每一个窗口进行的计算。这是窗口函数的责任，一旦系统确定一个窗口准备好进行处理，它就会用来处理每个（可能是 keyed 的）窗口的元素（关于 Flink 如何确定窗口准备好，请参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#triggers">触发器</a>）。</p>
<p>窗口函数可以是 <code>ReduceFunction</code>、<code>AggregateFunction</code>、<code>FoldFunction</code> 或 <code>ProcessWindowFunction</code> 中的一种。前两个可以更有效地执行（见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#state%20size">状态大小</a>部分），因为 Flink 可以在每个窗口到达时增量地聚合元素。<code>ProcessWindowFunction</code> 可以为一个窗口中包含的所有元素获取一个 <code>Iterable</code>，以及关于元素所属窗口的附加元信息。</p>
<p>带有 <code>ProcessWindowFunction</code> 的窗口化转换不能像其他情况一样高效执行，因为 Flink 在调用函数之前必须在内部缓冲一个窗口的所有元素。通过将 <code>ProcessWindowFunction</code> 与 <code>ReduceFunction</code>、<code>AggregateFunction</code> 或 <code>FoldFunction</code> 结合起来，既可以得到窗口元素的增量聚合，也可以得到 <code>ProcessWindowFunction</code> 接收到的额外的窗口元数据，从而缓解这种情况。我们将查看这些变体的每个例子。</p>
<h3 id="reducefunction">ReduceFunction&nbsp;<a class="headline-hash no-text-decoration" href="#reducefunction">#</a> </h3>
<p><code>ReduceFunction</code> 指定了如何将输入的两个元素组合起来以产生相同类型的输出元素。Flink 使用 <code>ReduceFunction</code> 来增量聚合一个窗口的元素。</p>
<p><code>ReduceFunction</code> 可以这样定义和使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Long</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">assigner</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">reduce</span> <span class="o">{</span> <span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">v1</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">v1</span><span class="o">.</span><span class="n">_2</span> <span class="o">+</span> <span class="n">v2</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div><p>上面的例子把一个窗口中所有元素的元组的第二个字段相加起来。</p>
<h3 id="aggregatefunction">AggregateFunction&nbsp;<a class="headline-hash no-text-decoration" href="#aggregatefunction">#</a> </h3>
<p><code>AggregateFunction</code> 是 <code>ReduceFunction</code> 的通用版本，它有三种类型：输入类型（IN）、累加器类型（ACC）和输出类型（OUT）。输入类型是输入流中元素的类型，AggregateFunction 有一个方法用于将一个输入元素添加到累加器中。该接口还有创建一个初始累加器、将两个累加器合并成一个累加器以及从一个累加器中提取一个输出（类型为 OUT）的方法。我们将在下面的例子中看到这些方法是如何工作的。</p>
<p>和 ReduceFunction 一样，Flink 会在窗口的输入元素到达时，对它们进行增量聚合。</p>
<p>AggregateFunction 可以这样定义和使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="cm">/*</span><span class="cm">*</span><span class="cm">
</span><span class="cm"> </span><span class="cm">*</span><span class="cm"> The accumulator is used to keep a running sum and a count. The [getResult] method
</span><span class="cm"> </span><span class="cm">*</span><span class="cm"> computes the average.
</span><span class="cm"> </span><span class="cm">*/</span>
<span class="k">class</span> <span class="nc">AverageAggregate</span> <span class="k">extends</span> <span class="nc">AggregateFunction</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Long</span><span class="o">)</span>, <span class="o">(</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">)</span>, <span class="kt">Double</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">createAccumulator</span><span class="o">(</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0L</span><span class="o">,</span> <span class="mi">0L</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Long</span><span class="o">)</span><span class="o">,</span> <span class="n">accumulator</span><span class="k">:</span> <span class="o">(</span><span class="kt">Long</span><span class="o">,</span> <span class="kt">Long</span><span class="o">)</span><span class="o">)</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">accumulator</span><span class="o">.</span><span class="n">_1</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="n">_2</span><span class="o">,</span> <span class="n">accumulator</span><span class="o">.</span><span class="n">_2</span> <span class="o">+</span> <span class="mi">1L</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">getResult</span><span class="o">(</span><span class="n">accumulator</span><span class="k">:</span> <span class="o">(</span><span class="kt">Long</span><span class="o">,</span> <span class="kt">Long</span><span class="o">)</span><span class="o">)</span> <span class="k">=</span> <span class="n">accumulator</span><span class="o">.</span><span class="n">_1</span> <span class="o">/</span> <span class="n">accumulator</span><span class="o">.</span><span class="n">_2</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="o">(</span><span class="kt">Long</span><span class="o">,</span> <span class="kt">Long</span><span class="o">)</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="o">(</span><span class="kt">Long</span><span class="o">,</span> <span class="kt">Long</span><span class="o">)</span><span class="o">)</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">_1</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_2</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Long</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">assigner</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">aggregate</span><span class="o">(</span><span class="k">new</span> <span class="nc">AverageAggregate</span><span class="o">)</span>
</code></pre></div><p>上面的例子是计算窗口中元素的第二个字段的平均值。</p>
<h3 id="foldfunction">FoldFunction&nbsp;<a class="headline-hash no-text-decoration" href="#foldfunction">#</a> </h3>
<p>FoldFunction 指定了窗口的输入元素如何与输出类型的元素相结合。对于添加到窗口的每个元素和当前的输出值，都会递增地调用 FoldFunction。第一个元素与输出类型的预定义初始值相结合。</p>
<p>可以这样定义和使用 FoldFunction。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Long</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">assigner</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="s">&#34;&#34;</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">_2</span> <span class="o">}</span>
</code></pre></div><p>上面的例子将所有输入的 Long 值追加到一个初始的空字符串中。</p>
<p>注意 <code>fold()</code> 不能用于会话窗口或其他可合并窗口。</p>
<h3 id="processwindowfunction">ProcessWindowFunction&nbsp;<a class="headline-hash no-text-decoration" href="#processwindowfunction">#</a> </h3>
<p>ProcessWindowFunction 得到一个包含窗口所有元素的 Iterable，以及一个可以访问时间和状态信息的 Context 对象，这使得它能够提供比其他窗口函数更多的灵活性。这是以性能和资源消耗为代价的，因为元素不能增量聚合，而是需要在内部缓冲，直到窗口被认为可以处理为止。</p>
<p>ProcessWindowFunction 的签名如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">ProcessWindowFunction</span><span class="o">[</span><span class="kt">IN</span>, <span class="kt">OUT</span>, <span class="kt">KEY</span>, <span class="kt">W</span> <span class="k">&lt;:</span> <span class="kt">Window</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Function</span> <span class="o">{</span>

  <span class="cm">/*</span><span class="cm">*</span><span class="cm">
</span><span class="cm">    </span><span class="cm">*</span><span class="cm"> Evaluates the window and outputs none or several elements.
</span><span class="cm">    </span><span class="cm">*</span><span class="cm">
</span><span class="cm">    </span><span class="cm">*</span><span class="cm"> @param key      The key for which this window is evaluated.
</span><span class="cm">    </span><span class="cm">*</span><span class="cm"> @param context  The context in which the window is being evaluated.
</span><span class="cm">    </span><span class="cm">*</span><span class="cm"> @param elements The elements in the window being evaluated.
</span><span class="cm">    </span><span class="cm">*</span><span class="cm"> @param out      A collector for emitting elements.
</span><span class="cm">    </span><span class="cm">*</span><span class="cm"> @throws Exception The function may throw exceptions to fail the program and trigger recovery.
</span><span class="cm">    </span><span class="cm">*/</span>
  <span class="k">def</span> <span class="n">process</span><span class="o">(</span>
      <span class="n">key</span><span class="k">:</span> <span class="kt">KEY</span><span class="o">,</span>
      <span class="n">context</span><span class="k">:</span> <span class="kt">Context</span><span class="o">,</span>
      <span class="n">elements</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">IN</span><span class="o">]</span><span class="o">,</span>
      <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[</span><span class="kt">OUT</span><span class="o">]</span><span class="o">)</span>

  <span class="cm">/*</span><span class="cm">*</span><span class="cm">
</span><span class="cm">    </span><span class="cm">*</span><span class="cm"> The context holding window metadata
</span><span class="cm">    </span><span class="cm">*/</span>
  <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Context</span> <span class="o">{</span>
    <span class="cm">/*</span><span class="cm">*</span><span class="cm">
</span><span class="cm">      </span><span class="cm">*</span><span class="cm"> Returns the window that is being evaluated.
</span><span class="cm">      </span><span class="cm">*/</span>
    <span class="k">def</span> <span class="n">window</span><span class="k">:</span> <span class="kt">W</span>

    <span class="cm">/*</span><span class="cm">*</span><span class="cm">
</span><span class="cm">      </span><span class="cm">*</span><span class="cm"> Returns the current processing time.
</span><span class="cm">      </span><span class="cm">*/</span>
    <span class="k">def</span> <span class="n">currentProcessingTime</span><span class="k">:</span> <span class="kt">Long</span>

    <span class="cm">/*</span><span class="cm">*</span><span class="cm">
</span><span class="cm">      </span><span class="cm">*</span><span class="cm"> Returns the current event-time watermark.
</span><span class="cm">      </span><span class="cm">*/</span>
    <span class="k">def</span> <span class="n">currentWatermark</span><span class="k">:</span> <span class="kt">Long</span>

    <span class="cm">/*</span><span class="cm">*</span><span class="cm">
</span><span class="cm">      </span><span class="cm">*</span><span class="cm"> State accessor for per-key and per-window state.
</span><span class="cm">      </span><span class="cm">*/</span>
    <span class="k">def</span> <span class="n">windowState</span><span class="k">:</span> <span class="kt">KeyedStateStore</span>

    <span class="cm">/*</span><span class="cm">*</span><span class="cm">
</span><span class="cm">      </span><span class="cm">*</span><span class="cm"> State accessor for per-key global state.
</span><span class="cm">      </span><span class="cm">*/</span>
    <span class="k">def</span> <span class="n">globalState</span><span class="k">:</span> <span class="kt">KeyedStateStore</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><p>注意 <code>key</code> 参数是通过为 <code>keyBy()</code> 调用指定的 <code>KeySelector</code> 提取的键。如果是元组索引键或字符串字段引用，这个键的类型总是 Tuple，你必须手动将其转换为一个正确大小的元组来提取键字段。</p>
<p><code>ProcessWindowFunction</code> 可以这样定义和使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Long</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">input</span>
  <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
  <span class="o">.</span><span class="n">timeWindow</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">minutes</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span><span class="o">)</span>
  <span class="o">.</span><span class="n">process</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyProcessWindowFunction</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>

<span class="cm">/*</span><span class="cm"> ... </span><span class="cm">*/</span>

<span class="k">class</span> <span class="nc">MyProcessWindowFunction</span> <span class="k">extends</span> <span class="nc">ProcessWindowFunction</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Long</span><span class="o">)</span>, <span class="kt">String</span>, <span class="kt">String</span>, <span class="kt">TimeWindow</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">process</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">context</span><span class="k">:</span> <span class="kt">Context</span><span class="o">,</span> <span class="n">input</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Long</span><span class="o">)</span><span class="o">]</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">count</span> <span class="k">=</span> <span class="mi">0L</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">in</span> <span class="k">&lt;-</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">count</span> <span class="k">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="o">}</span>
    <span class="n">out</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="s">s&#34;</span><span class="s">Window </span><span class="si">${</span><span class="n">context</span><span class="o">.</span><span class="n">window</span><span class="si">}</span><span class="s"> count: </span><span class="si">$count</span><span class="s">&#34;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>这个例子显示了一个 <code>ProcessWindowFunction</code>，它可以计算一个窗口中的元素。此外，窗口函数还将窗口的信息添加到输出中。</p>
<p>注意，使用 ProcessWindowFunction 进行简单的聚合，如 <code>count</code>，效率相当低。下一节将展示如何将 <code>ReduceFunction</code> 或 <code>AggregateFunction</code> 与 <code>ProcessWindowFunction</code> 结合起来，以获得增量聚合和 <code>ProcessWindowFunction</code> 的附加信息。</p>
<h3 id="具有增量聚合功能的-processwindowfunction">具有增量聚合功能的 ProcessWindowFunction&nbsp;<a class="headline-hash no-text-decoration" href="#具有增量聚合功能的-processwindowfunction">#</a> </h3>
<p><code>ProcessWindowFunction</code> 可以与 <code>ReduceFunction</code>、<code>AggregateFunction</code> 或 <code>FoldFunction</code> 相结合，以在元素到达窗口时进行增量聚合。当窗口关闭时，<code>ProcessWindowFunction</code> 将被提供聚合的结果。这使得它可以增量计算窗口，同时可以访问 <code>ProcessWindowFunction</code> 的附加窗口元信息。</p>
<p>注意 您也可以使用 legacy WindowFunction 代替 ProcessWindowFunction 进行增量窗口聚合。</p>
<h4 id="使用-reducefunction-进行增量窗口聚合">使用 ReduceFunction 进行增量窗口聚合&nbsp;<a class="headline-hash no-text-decoration" href="#使用-reducefunction-进行增量窗口聚合">#</a> </h4>
<p>下面的例子展示了如何将增量 ReduceFunction 与 ProcessWindowFunction 相结合，以返回窗口中最小的事件以及窗口的开始时间。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">SensorReading</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">input</span>
  <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">timeWindow</span><span class="o">(</span><span class="o">&lt;</span><span class="n">duration</span><span class="o">&gt;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">reduce</span><span class="o">(</span>
    <span class="o">(</span><span class="n">r1</span><span class="k">:</span> <span class="kt">SensorReading</span><span class="o">,</span> <span class="n">r2</span><span class="k">:</span> <span class="kt">SensorReading</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="k">if</span> <span class="o">(</span><span class="n">r1</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">r2</span><span class="o">.</span><span class="n">value</span><span class="o">)</span> <span class="n">r2</span> <span class="k">else</span> <span class="n">r1</span> <span class="o">}</span><span class="o">,</span>
    <span class="o">(</span> <span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
      <span class="n">context</span><span class="k">:</span> <span class="kt">ProcessWindowFunction</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span>, <span class="k">_</span>, <span class="kt">TimeWindow</span><span class="o">]</span><span class="k">#</span><span class="nc">Context</span><span class="o">,</span>
      <span class="n">minReadings</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">SensorReading</span><span class="o">]</span><span class="o">,</span>
      <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[</span><span class="o">(</span><span class="kt">Long</span>, <span class="kt">SensorReading</span><span class="o">)</span><span class="o">]</span> <span class="o">)</span> <span class="k">=&gt;</span>
      <span class="o">{</span>
        <span class="k">val</span> <span class="n">min</span> <span class="k">=</span> <span class="n">minReadings</span><span class="o">.</span><span class="n">iterator</span><span class="o">.</span><span class="n">next</span><span class="o">(</span><span class="o">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="n">getStart</span><span class="o">,</span> <span class="n">min</span><span class="o">)</span><span class="o">)</span>
      <span class="o">}</span>
  <span class="o">)</span>
</code></pre></div><h4 id="用-aggregatefunction-进行增量窗口聚合">用 AggregateFunction 进行增量窗口聚合&nbsp;<a class="headline-hash no-text-decoration" href="#用-aggregatefunction-进行增量窗口聚合">#</a> </h4>
<p>下面的例子展示了如何将增量的 AggregateFunction 与 ProcessWindowFunction 结合起来，计算平均值，同时将键和窗口与平均值一起发出。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Long</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">input</span>
  <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">timeWindow</span><span class="o">(</span><span class="o">&lt;</span><span class="n">duration</span><span class="o">&gt;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">aggregate</span><span class="o">(</span><span class="k">new</span> <span class="nc">AverageAggregate</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="k">new</span> <span class="nc">MyProcessWindowFunction</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>

<span class="c1">// Function definitions
</span><span class="c1"></span>
<span class="cm">/*</span><span class="cm">*</span><span class="cm">
</span><span class="cm"> </span><span class="cm">*</span><span class="cm"> The accumulator is used to keep a running sum and a count. The [getResult] method
</span><span class="cm"> </span><span class="cm">*</span><span class="cm"> computes the average.
</span><span class="cm"> </span><span class="cm">*/</span>
<span class="k">class</span> <span class="nc">AverageAggregate</span> <span class="k">extends</span> <span class="nc">AggregateFunction</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Long</span><span class="o">)</span>, <span class="o">(</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">)</span>, <span class="kt">Double</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">createAccumulator</span><span class="o">(</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0L</span><span class="o">,</span> <span class="mi">0L</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Long</span><span class="o">)</span><span class="o">,</span> <span class="n">accumulator</span><span class="k">:</span> <span class="o">(</span><span class="kt">Long</span><span class="o">,</span> <span class="kt">Long</span><span class="o">)</span><span class="o">)</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">accumulator</span><span class="o">.</span><span class="n">_1</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="n">_2</span><span class="o">,</span> <span class="n">accumulator</span><span class="o">.</span><span class="n">_2</span> <span class="o">+</span> <span class="mi">1L</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">getResult</span><span class="o">(</span><span class="n">accumulator</span><span class="k">:</span> <span class="o">(</span><span class="kt">Long</span><span class="o">,</span> <span class="kt">Long</span><span class="o">)</span><span class="o">)</span> <span class="k">=</span> <span class="n">accumulator</span><span class="o">.</span><span class="n">_1</span> <span class="o">/</span> <span class="n">accumulator</span><span class="o">.</span><span class="n">_2</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="o">(</span><span class="kt">Long</span><span class="o">,</span> <span class="kt">Long</span><span class="o">)</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="o">(</span><span class="kt">Long</span><span class="o">,</span> <span class="kt">Long</span><span class="o">)</span><span class="o">)</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">_1</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_2</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">MyProcessWindowFunction</span> <span class="k">extends</span> <span class="nc">ProcessWindowFunction</span><span class="o">[</span><span class="kt">Double</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">Double</span><span class="o">)</span>, <span class="kt">String</span>, <span class="kt">TimeWindow</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">process</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">context</span><span class="k">:</span> <span class="kt">Context</span><span class="o">,</span> <span class="n">averages</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Double</span><span class="o">)</span><span class="o">]</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">average</span> <span class="k">=</span> <span class="n">averages</span><span class="o">.</span><span class="n">iterator</span><span class="o">.</span><span class="n">next</span><span class="o">(</span><span class="o">)</span>
    <span class="n">out</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">average</span><span class="o">)</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h4 id="用-foldfunction-进行增量窗口聚合">用 FoldFunction 进行增量窗口聚合&nbsp;<a class="headline-hash no-text-decoration" href="#用-foldfunction-进行增量窗口聚合">#</a> </h4>
<p>下面的例子展示了如何将增量式 FoldFunction 与 ProcessWindowFunction 相结合，以提取窗口中的事件数量，并返回窗口的键和结束时间。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">SensorReading</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">input</span>
 <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
 <span class="o">.</span><span class="n">timeWindow</span><span class="o">(</span><span class="o">&lt;</span><span class="n">duration</span><span class="o">&gt;</span><span class="o">)</span>
 <span class="o">.</span><span class="n">fold</span> <span class="o">(</span>
    <span class="o">(</span><span class="s">&#34;&#34;</span><span class="o">,</span> <span class="mi">0L</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span><span class="o">,</span>
    <span class="o">(</span><span class="n">acc</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Long</span><span class="o">,</span> <span class="nc">Int</span><span class="o">)</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">SensorReading</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="o">(</span><span class="s">&#34;&#34;</span><span class="o">,</span> <span class="mi">0L</span><span class="o">,</span> <span class="n">acc</span><span class="o">.</span><span class="n">_3</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">}</span><span class="o">,</span>
    <span class="o">(</span> <span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
      <span class="n">window</span><span class="k">:</span> <span class="kt">TimeWindow</span><span class="o">,</span>
      <span class="n">counts</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Long</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span><span class="o">,</span>
      <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Long</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span> <span class="o">)</span> <span class="k">=&gt;</span>
      <span class="o">{</span>
        <span class="k">val</span> <span class="n">count</span> <span class="k">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">iterator</span><span class="o">.</span><span class="n">next</span><span class="o">(</span><span class="o">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">window</span><span class="o">.</span><span class="n">getEnd</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="n">_3</span><span class="o">)</span><span class="o">)</span>
      <span class="o">}</span>
  <span class="o">)</span>
</code></pre></div><h4 id="在-processwindowfunction-中使用-per-窗口状态">在 ProcessWindowFunction 中使用 per-窗口状态&nbsp;<a class="headline-hash no-text-decoration" href="#在-processwindowfunction-中使用-per-窗口状态">#</a> </h4>
<p>除了访问 keyed 状态（任何富函数都可以），ProcessWindowFunction 还可以使用 keyed 状态，该状态的作用域是函数当前正在处理的窗口。在这种情况下，理解每个窗口状态所指的窗口是什么很重要。这里涉及到不同的&quot;窗口&rdquo;。</p>
<ul>
<li>窗口是在指定窗口操作时定义的。这可能是1小时的滚动窗口或者2小时的滑动窗口，滑动1小时。</li>
<li>一个给定的键的定义窗口的实际实例。这可能是 12: 00 到 13: 00 的时间窗口，用户 ID xyz. 这是基于窗口定义的，会有很多窗口，基于作业当前正在处理的键的数量，基于事件属于什么时间段。</li>
</ul>
<p>每个窗口的状态与这两者中的后一种挂钩。意思是说，如果我们处理了1000个不同键的事件，并且所有键的事件当前都属于 <code>[12:00，13:00)</code> 时间窗口，那么将有1000个窗口实例，每个窗口都有自己的键的per-窗口状态。</p>
<p><code>process()</code> 调用接收到的 Context 对象上有两个方法允许访问这两种类型的状态。</p>
<ul>
<li><code>globalState()</code>，允许访问不在窗口范围内的 keyed 状态。</li>
<li><code>windowState()</code>，它允许访问同样作用于窗口的 keyed 状态。</li>
</ul>
<p>如果你预计同一窗口会有多次发射，那么这个功能是很有帮助的，因为当你对晚到的数据有晚发射的情况，或者当你有一个自定义的触发器，做投机性的早期发射时，可能会发生这种情况。在这种情况下，你会在每个窗口状态下存储之前的发射信息或发射次数。</p>
<p>当使用窗口状态时，重要的是当窗口被清除时也要清理该状态。这应该发生在 <code>clear()</code> 方法中。</p>
<h3 id="windowfunctionlegacy">WindowFunction(Legacy)&nbsp;<a class="headline-hash no-text-decoration" href="#windowfunctionlegacy">#</a> </h3>
<p>在一些可以使用 <code>ProcessWindowFunction</code> 的地方，你也可以使用 <code>WindowFunction</code>。这是 <code>ProcessWindowFunction</code> 的旧版本，它提供的上下文信息较少，而且没有一些先进的功能，比如每个窗口的 keyed 状态。这个接口在某些时候会被废弃。</p>
<p>WindowFunction 的签名如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">WindowFunction</span><span class="o">[</span><span class="kt">IN</span>, <span class="kt">OUT</span>, <span class="kt">KEY</span>, <span class="kt">W</span> <span class="k">&lt;:</span> <span class="kt">Window</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Function</span> <span class="k">with</span> <span class="nc">Serializable</span> <span class="o">{</span>

  <span class="cm">/*</span><span class="cm">*</span><span class="cm">
</span><span class="cm">    </span><span class="cm">*</span><span class="cm"> Evaluates the window and outputs none or several elements.
</span><span class="cm">    </span><span class="cm">*</span><span class="cm">
</span><span class="cm">    </span><span class="cm">*</span><span class="cm"> @param key    The key for which this window is evaluated.
</span><span class="cm">    </span><span class="cm">*</span><span class="cm"> @param window The window that is being evaluated.
</span><span class="cm">    </span><span class="cm">*</span><span class="cm"> @param input  The elements in the window being evaluated.
</span><span class="cm">    </span><span class="cm">*</span><span class="cm"> @param out    A collector for emitting elements.
</span><span class="cm">    </span><span class="cm">*</span><span class="cm"> @throws Exception The function may throw exceptions to fail the program and trigger recovery.
</span><span class="cm">    </span><span class="cm">*/</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">KEY</span><span class="o">,</span> <span class="n">window</span><span class="k">:</span> <span class="kt">W</span><span class="o">,</span> <span class="n">input</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">IN</span><span class="o">]</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[</span><span class="kt">OUT</span><span class="o">]</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div><p>可以这样使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Long</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">assigner</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyWindowFunction</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
</code></pre></div><h3 id="触发器">触发器&nbsp;<a class="headline-hash no-text-decoration" href="#触发器">#</a> </h3>
<p>触发器决定一个窗口（由窗口分配器形成）何时可以被窗口函数处理。每个 <code>WindowAssigner</code> 都有一个默认的触发器。如果默认的触发器不符合你的需求，你可以使用 <code>trigger(...)</code> 指定一个自定义的触发器。</p>
<p>触发器接口有五个方法，允许 Trigger 对不同的事件做出反应。</p>
<ul>
<li><code>onElement()</code> 方法对每个添加到窗口的元素都会被调用。</li>
<li><code>onEventTime()</code> 方法在注册的事件时间定时器启动时被调用。</li>
<li><code>onProcessingTime()</code> 方法在注册的处理时间计时器启动时被调用。</li>
<li><code>onMerge()</code> 方法与有状态的触发器相关，当两个触发器的对应窗口合并时，例如使用会话窗口时，就会合并两个触发器的状态。</li>
<li>最后 <code>clear()</code> 方法在删除相应窗口时执行任何需要的操作。</li>
</ul>
<p>关于以上方法有两点需要注意。</p>
<p>1）前三个方法通过返回一个 <code>TriggerResult</code> 来决定如何对其调用事件采取行动。动作可以是以下之一。</p>
<ul>
<li>CONTINUE：什么也不做。</li>
<li>FIRE：触发计算。</li>
<li>PURGE：清除窗口中的元素，以及</li>
<li>FIRE_AND_PURGE：触发计算，之后清除窗口中的元素。</li>
</ul>
<ol start="2">
<li>这些方法中的任何一种都可以用来注册处理时间或事件时间的定时器，以备将来的操作。</li>
</ol>
<h3 id="fire-和-purge">Fire 和 Purge&nbsp;<a class="headline-hash no-text-decoration" href="#fire-和-purge">#</a> </h3>
<p>一旦触发器确定一个窗口可以处理，它就会发射，即返回 FIRE 或 FIRE_AND_PURGE。这是窗口操作者发出当前窗口结果的信号。给定一个带有 ProcessWindowFunction 的窗口，所有的元素都会被传递给 ProcessWindowFunction（可能是在将它们传递给 evictor 之后）。带有 ReduceFunction、AggregateFunction 或 FoldFunction 的窗口只是简单地发出它们急切的聚合结果。</p>
<p>当一个触发器发射时，它可以是 FIRE 或 FIRE_AND_PURGE。FIRE 保留窗口的内容，而 FIRE_AND_PURGE 则删除其内容。默认情况下，预先实现的触发器只是 FIRE 而不清除窗口状态。</p>
<p>注意 Purging 将简单地删除窗口的内容，并将完整地保留任何关于窗口和任何触发状态的潜在元信息。</p>
<h3 id="窗口分配器的默认触发器">窗口分配器的默认触发器&nbsp;<a class="headline-hash no-text-decoration" href="#窗口分配器的默认触发器">#</a> </h3>
<p>WindowAssigner 的默认触发器适合于许多用例。例如，所有的事件时间窗口分配器都有一个 EventTimeTrigger 作为默认触发器。这个触发器仅仅是在水印通过窗口结束后就会触发。</p>
<p>注意：GlobalWindow 的默认触发器是 NeverTrigger，它永远不会触发。因此，在使用 GlobalWindow 时，您必须定义一个自定义的触发器。</p>
<p>注意：通过使用 trigger() 指定一个触发器，您将覆盖一个 WindowAssigner 的默认触发器。例如，如果你为 TumblingEventTimeWindows 指定了一个 CountTrigger，你将不再获得基于时间进度的窗口启动，而只能通过计数来获得。现在，如果你想同时基于时间和计数做出反应，你必须编写自己的自定义触发器。</p>
<h3 id="内置和自定义触发器">内置和自定义触发器&nbsp;<a class="headline-hash no-text-decoration" href="#内置和自定义触发器">#</a> </h3>
<p>Flink 内置了一些触发器。</p>
<ul>
<li>前面已经提到过的, EventTimeTrigger 会根据水印测量的事件时间的进展而触发。</li>
<li>处理时间触发器（ProcessingTimeTrigger）基于处理时间而触发。</li>
<li>CountTrigger 在一个窗口中的元素数量超过给定的限制时触发。</li>
<li>PurgingTrigger 将另一个触发器作为参数，并将其转换为一个清洗触发器。</li>
</ul>
<p>如果你需要实现一个自定义的触发器，你应该查看抽象的 <a href="https://github.com/apache/flink/blob/master//flink-streaming-java/src/main/java/org/apache/flink/streaming/api/windowing/triggers/Trigger.java">Trigger</a> 类。请注意，API 仍在不断发展，可能会在 Flink 的未来版本中改变。</p>
<h3 id="evictors">Evictors&nbsp;<a class="headline-hash no-text-decoration" href="#evictors">#</a> </h3>
<p>Flink 的窗口模型允许在 WindowAssigner 和 Trigger 之外指定一个可选的 Evictor。这可以通过 <code>evictor(...)</code> 方法来完成（如本文开头所示）。Evictor 能够在触发器触发后和应用窗口函数之前和/或之后从窗口中移除元素。要做到这一点，Evictor 接口有两个方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * Optionally evicts elements. Called before windowing function.
</span><span class="cm"> *
</span><span class="cm"> * @param elements The elements currently in the pane.
</span><span class="cm"> * @param size The current number of elements in the pane.
</span><span class="cm"> * @param window The {@link Window}
</span><span class="cm"> * @param evictorContext The context for the Evictor
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">evictBefore</span><span class="o">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">TimestampedValue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">elements</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">,</span> <span class="n">W</span> <span class="n">window</span><span class="o">,</span> <span class="n">EvictorContext</span> <span class="n">evictorContext</span><span class="o">)</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * Optionally evicts elements. Called after windowing function.
</span><span class="cm"> *
</span><span class="cm"> * @param elements The elements currently in the pane.
</span><span class="cm"> * @param size The current number of elements in the pane.
</span><span class="cm"> * @param window The {@link Window}
</span><span class="cm"> * @param evictorContext The context for the Evictor
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">evictAfter</span><span class="o">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">TimestampedValue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">elements</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">,</span> <span class="n">W</span> <span class="n">window</span><span class="o">,</span> <span class="n">EvictorContext</span> <span class="n">evictorContext</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p><code>evictBefore()</code> 包含在窗口函数之前应用的驱逐逻辑，而 <code>evictAfter()</code> 包含在窗口函数之后应用的逻辑。在应用窗口函数之前被驱逐的元素将不会被它处理。</p>
<p>Flink 自带了三个预先实现的驱逐器。这三个是:</p>
<ul>
<li>CountEvictor：从窗口中保留最多用户指定数量的元素，并从窗口缓冲区开始丢弃剩余的元素。</li>
<li>DeltaEvictor：取 DeltaFunction 和阈值，计算窗口缓冲区中最后一个元素和剩余元素之间的 delta，并删除 delta 大于或等于阈值的元素。</li>
<li>TimeEvictor：以毫秒为单位的时间间隔作为参数，对于一个给定的窗口，它在其元素中找到最大的时间戳 max_ts，并删除所有时间戳小于 max_ts - interval 的元素。</li>
</ul>
<p>默认情况下，所有预先实现的 evictor 都会在 window 函数之前应用其逻辑。</p>
<p>注意: 指定一个 evictor 可以防止任何预聚集，因为一个窗口的所有元素都必须在应用计算之前传递给 evictor。</p>
<p>注意 Flink 不保证窗口内元素的顺序。这意味着，虽然 evictor 可以从窗口的开头移除元素，但这些元素不一定是最先或最后到达的。</p>
<h2 id="允许的延迟">允许的延迟&nbsp;<a class="headline-hash no-text-decoration" href="#允许的延迟">#</a> </h2>
<p>当使用事件时间窗口时，可能会发生元素迟到的情况，也就是说，Flink 用来跟踪事件时间进度的水印已经超过了元素所属窗口的结束时间戳。关于 Flink 如何处理事件时间，请参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_time.html">事件时间</a>，尤其是<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_time.html#late-elements">迟到元素</a>。</p>
<p>默认情况下，当水印超过窗口的结束时间时，晚期元素就会被删除。然而，Flink 允许为窗口操作者指定一个最大允许延迟。允许延迟指定了元素在被丢弃之前可以迟到多少时间，其默认值为0。 在水印通过窗口结束后但在其通过窗口结束前加上允许延迟之前到达的元素，仍然会被添加到窗口中。根据所使用的触发器，一个迟到但未被丢弃的元素可能会导致窗口再次启动。EventTimeTrigger 就属于这种情况。</p>
<p>为了使这个工作，Flink 会保持窗口的状态，直到它们的允许延迟过期。一旦发生这种情况，Flink 就会删除窗口并删除其状态，这一点在<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#window-lifecycle">窗口生命周期</a>部分也有描述。</p>
<p>默认情况下，允许的延迟被设置为0，也就是说，到达水印后面的元素将被丢弃。</p>
<p>您可以像这样指定允许的延迟。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">assigner</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">allowedLateness</span><span class="o">(</span><span class="o">&lt;</span><span class="n">time</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="o">&lt;</span><span class="n">windowed</span> <span class="n">transformation</span><span class="o">&gt;</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>
</code></pre></div><p>注意 当使用 GlobalWindows 窗口分配器时，由于全局窗口的结束时间戳是 Long.MAX_VALUE，因此没有数据被认为是迟到数据。</p>
<h3 id="作为侧输出获取迟到数据">作为侧输出获取迟到数据&nbsp;<a class="headline-hash no-text-decoration" href="#作为侧输出获取迟到数据">#</a> </h3>
<p>使用 Flink 的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/side_output.html">侧输出</a>功能，你可以得到一个被丢弃的迟到数据流。</p>
<p>首先，你需要在窗口化的数据流上使用 <code>sideOutputLateData(OutputTag)</code> 来指定你要获取迟到的数据。然后，你就可以在窗口化操作的结果上得到侧输出流。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">lateOutputTag</span> <span class="k">=</span> <span class="nc">OutputTag</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="o">(</span><span class="s">&#34;late-data&#34;</span><span class="o">)</span>

<span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">assigner</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">allowedLateness</span><span class="o">(</span><span class="o">&lt;</span><span class="n">time</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">sideOutputLateData</span><span class="o">(</span><span class="n">lateOutputTag</span><span class="o">)</span>
    <span class="o">.</span><span class="o">&lt;</span><span class="n">windowed</span> <span class="n">transformation</span><span class="o">&gt;</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>

<span class="k">val</span> <span class="n">lateStream</span> <span class="k">=</span> <span class="n">result</span><span class="o">.</span><span class="n">getSideOutput</span><span class="o">(</span><span class="n">lateOutputTag</span><span class="o">)</span>
</code></pre></div><h4 id="迟到元素的考虑">迟到元素的考虑&nbsp;<a class="headline-hash no-text-decoration" href="#迟到元素的考虑">#</a> </h4>
<p>当指定允许的延迟大于0时，在水印通过窗口结束后，窗口及其内容将被保留。在这些情况下，当一个迟到但未被丢弃的元素到达时，它可能会触发窗口的另一次发射。这些发射被称为晚期发射，因为它们是由晚期事件触发的，与主发射相反，主发射是窗口的第一次发射。在会话窗口的情况下，迟发可能会进一步导致窗口的合并，因为它们可能会&quot;弥合&quot;两个已经存在的、未合并的窗口之间的差距。</p>
<p>注意：你应该意识到，晚点发射的元素应该被视为之前计算的更新结果，也就是说，你的数据流将包含同一计算的多个结果。根据你的应用，你需要考虑到这些重复的结果，或者对它们进行重复复制。</p>
<h3 id="处理窗口结果">处理窗口结果&nbsp;<a class="headline-hash no-text-decoration" href="#处理窗口结果">#</a> </h3>
<p>窗口化操作的结果又是一个 DataStream，在结果元素中没有保留任何关于窗口化操作的信息，所以如果你想保留窗口的元信息，你必须在你的 <code>ProcessWindowFunction</code> 的结果元素中手动编码这些信息。在结果元素上设置的唯一相关信息是元素的时间戳。这被设置为处理过的窗口的最大允许时间戳，也就是结束时间戳-1，因为窗口结束时间戳是独占的。注意，这对事件时间窗口和处理时间窗口都是如此，即在窗口化操作后元素总是有一个时间戳，但这个时间戳可以是事件时间时间戳，也可以是处理时间时间戳。对于处理时间窗口来说，这没有特别的影响，但是对于事件时间窗口来说，加上水印与窗口的交互方式，使得<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#consecutive-windowed-operations">连续的窗口化操作</a>具有相同的窗口大小。我们将在看完水印如何与窗口交互后再谈这个问题。</p>
<h4 id="水印和窗口的交互">水印和窗口的交互&nbsp;<a class="headline-hash no-text-decoration" href="#水印和窗口的交互">#</a> </h4>
<p>在继续本节之前，你可能想看看我们关于<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_time.html">事件时间和水印</a>的章节。</p>
<p>当水印到达窗口操作符时，会触发两件事。</p>
<ul>
<li>水印会触发计算所有窗口的最大时间戳（就是结束时间戳-1）小于新水印的窗口。</li>
<li>水印被转发到下游的操作中</li>
</ul>
<p>直观地说，水印会&quot;冲掉&quot;任何在下游操作中被认为是晚期的窗口，一旦它们收到该水印。</p>
<h4 id="连续的窗口操作">连续的窗口操作&nbsp;<a class="headline-hash no-text-decoration" href="#连续的窗口操作">#</a> </h4>
<p>如前所述，计算窗口化结果的时间戳的方式以及水印与窗口的交互方式允许将连续的窗口化操作串在一起。当你想进行两个连续的窗口化操作时，如果你想使用不同的键，但仍然希望来自同一个上游窗口的元素最终出现在同一个下游窗口中，这就很有用。考虑这个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="k">val</span> <span class="n">resultsPerKey</span> <span class="k">=</span> <span class="n">input</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="k">new</span> <span class="nc">Summer</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>

<span class="k">val</span> <span class="n">globalResults</span> <span class="k">=</span> <span class="n">resultsPerKey</span>
    <span class="o">.</span><span class="n">windowAll</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">process</span><span class="o">(</span><span class="k">new</span> <span class="nc">TopKWindowFunction</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
</code></pre></div><p>在这个例子中，第一次操作的时间窗口 <code>[0，5)</code> 的结果也会在随后的窗口操作中最终出现在时间窗口 <code>[0，5)</code>。这样就可以计算每个键的和，然后在第二个操作中计算同一窗口内的 top-k 元素。</p>
<h3 id="有用的状态大小考虑">有用的状态大小考虑&nbsp;<a class="headline-hash no-text-decoration" href="#有用的状态大小考虑">#</a> </h3>
<p>窗口可以在很长一段时间内（如几天、几周或几个月）被定义，因此会积累非常大的状态。在估算窗口计算的存储需求时，有几个规则需要牢记。</p>
<ol>
<li>
<p>Flink 为每个元素所属的窗口创建一个副本。鉴于此，翻滚窗口为每个元素保留一个副本（一个元素正好属于一个窗口，除非它被后期丢弃）。相比之下，滑动窗口会给每个元素创建若干个，这一点在<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#window-assigners">窗口分配器</a>部分有解释。因此，大小为1天，滑动1秒的滑动窗口可能不是一个好主意。</p>
</li>
<li>
<p>ReduceFunction、AggregateFunction 和 FoldFunction 可以显著降低存储要求，因为它们热衷于聚合元素，每个窗口只存储一个值。相比之下，仅仅使用 ProcessWindowFunction 就需要累积所有元素。</p>
</li>
<li>
<p>使用 Evictor 可以防止任何预聚集，因为一个窗口的所有元素都必须在应用计算之前通过 evictor（见 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#evictors">Evictor</a>）。</p>
</li>
</ol>
<p>原文链接: <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html">https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html</a></p>


        </div>
    </div>
</article>



                <footer>
                    




<div class="no-text-decoration">
    <div class="jump top"><a href="#" title="Top of this page">⮉</a></div>
    <div class="jump bottom"><a href="#bottom" title="Bottom of this page">⮋</a></div>
</div>


 
    
        <div class="hugotoc no-text-decoration">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#窗口生命周期">窗口生命周期</a></li>
    <li><a href="#keyed-与-non-keyed-窗口的对比">Keyed 与 Non-Keyed 窗口的对比</a></li>
    <li><a href="#窗口分配器">窗口分配器</a></li>
    <li><a href="#滚动窗口">滚动窗口</a></li>
    <li><a href="#滑动窗口">滑动窗口</a></li>
    <li><a href="#会话窗口">会话窗口</a></li>
    <li><a href="#全局窗口">全局窗口</a></li>
    <li><a href="#窗口函数">窗口函数</a>
      <ul>
        <li><a href="#reducefunction">ReduceFunction</a></li>
        <li><a href="#aggregatefunction">AggregateFunction</a></li>
        <li><a href="#foldfunction">FoldFunction</a></li>
        <li><a href="#processwindowfunction">ProcessWindowFunction</a></li>
        <li><a href="#具有增量聚合功能的-processwindowfunction">具有增量聚合功能的 ProcessWindowFunction</a></li>
        <li><a href="#windowfunctionlegacy">WindowFunction(Legacy)</a></li>
        <li><a href="#触发器">触发器</a></li>
        <li><a href="#fire-和-purge">Fire 和 Purge</a></li>
        <li><a href="#窗口分配器的默认触发器">窗口分配器的默认触发器</a></li>
        <li><a href="#内置和自定义触发器">内置和自定义触发器</a></li>
        <li><a href="#evictors">Evictors</a></li>
      </ul>
    </li>
    <li><a href="#允许的延迟">允许的延迟</a>
      <ul>
        <li><a href="#作为侧输出获取迟到数据">作为侧输出获取迟到数据</a></li>
        <li><a href="#处理窗口结果">处理窗口结果</a></li>
        <li><a href="#有用的状态大小考虑">有用的状态大小考虑</a></li>
      </ul>
    </li>
  </ul>
</nav>
            <a href="#" class="back-to-top">Back to top</a>
        </div>
    
    
<script src="/js/libs/jquery/3.3.1/jquery.slim.min.min.528a9ce56371729e50605653bf72b1e933574cdb97519529bf8fab01b63f9703.js"></script>

<link rel="preload" href="/js/libs/jquery/3.3.1/jquery.slim.min.min.528a9ce56371729e50605653bf72b1e933574cdb97519529bf8fab01b63f9703.js" as="script">

<script type="application/javascript">(function() {
     var $window = $(window);
     if ($window.width() >= 1400) { 
         var $toc = $('#TableOfContents');
         if ($toc.length > 0) {
             function onScroll(){
                 var currentScroll = $window.scrollTop();
                 var h = $('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .h-feed h2');
                 var id = "";
                 h.each(function (i, e) {
                     e = $(e);
                     if (e.offset().top - 10 <= currentScroll) {
                         id = e.attr('id');
                     }
                 });
                 var current = $toc.find('a.current');
                 if (current.length == 1 && current.eq(0).attr('href') == '#' + id) return true;

                 current.each(function (i, e) {
                     $(e).removeClass('current').siblings('ul').hide();
                 });
                 $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                     $(e).children('a').addClass('current').siblings('ul').show();
                 });
             }
             $window.on('scroll', onScroll);
             $(document).ready(function() {
                 $toc.find('a').parent('li').find('ul').hide();
                 onScroll();
                 document.getElementsByClassName('hugotoc')[0].style.display = '';
             });}}})();</script>








<div class="backtotop center no-text-decoration">
    <a href="#">back to <span class="top">top</span></a>
</div>


<div class="right">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 55 posts categorized in ‘Flink’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/categories/flink/">Flink</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 74 posts tagged with ‘Flink’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/flink/">Flink</a>
                            </li>
                        
                    
                        
                        
                        
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__datastream-api__"
                                
                                
                                title="See all 24 posts tagged with ‘DataStream API’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/datastream-api/">DataStream API</a>
                            </li>
                        
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__operators__"
                                
                                
                                title="See all 3 posts tagged with ‘Operators’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/operators/">Operators</a>
                            </li>
                        
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__windows__"
                                
                                
                                title="This is the only post tagged with ‘Windows’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/windows/">Windows</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>
<div class="clear-float"></div>



<div class="prev-next-navigator clear-float">
    
        <span class="prev-post left no-text-decoration">
            <a href="https://ohmyweekly.github.io/notes/2020-08-22-user-defined-functions/" class="nobr">« 用户定义函数</a>
        </span>
    
    
        <span class="next-post right no-text-decoration">
            <a href="https://ohmyweekly.github.io/notes/2020-08-22-custom-serialization-for-managed-state/" class="nobr">自定义序列化管理状态 »</a>
        </span>
    
</div>


<a id="bottom"></a>









                       







                    <ul class="no-bullets feed right inline">
    
        
        
    
</ul>
<div class="clear-float"></div>

                </footer>
                <hr />
            </div>               

            <footer> 
                

<ul class="social no-text-decoration">
    
</ul>













<p class="generated no-text-decoration">
    Generated using  <a href="https://gitlab.com/kaushalmodi/hugo-theme-refined"><code class="nobr">hugo-theme-refined</code></a> + <span class="nobr">Hugo 0.63.2</span>
</p>

<p>
    
</p>




<div class="badges no-text-decoration">
    
    

    
</div>




<script type="application/javascript">var nav=responsiveNav("#nav");</script>




<script defer src="/js/libs/fragmentions/wrapper.min.4c511209cd3786314b251d891c8da528b47a972669aa4eea416b64d4be01eee2.js"></script>









            </footer>
        </div> 
    </body>
</html>
