{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"content":{"html":"\u003cp\u003e检测表格中的模式\n搜索一组事件模式是一个常见的用例，特别是在数据流的情况下。Flink 自带复杂事件处理（CEP）库，可以在事件流中进行模式检测。此外，Flink 的 SQL API 提供了一种关系型的查询表达方式，有大量的内置函数和基于规则的优化，可以开箱即用。\u003c/p\u003e\n\u003cp\u003e2016 年 12 月，国际标准化组织（ISO）发布了新版本的 SQL 标准，其中包括 SQL 中的行模式识别（ISO/IEC TR 19075-5:2016）。它允许 Flink 使用 MATCH_RECOGNIZE 子句整合 CEP 和 SQL API，用于 SQL 中的复杂事件处理。\u003c/p\u003e\n\u003cp\u003eMATCH_RECOGNIZE 子句可以实现以下任务。\u003c/p\u003e\n\u003cp\u003e对使用 partition by 和 order by 子句的数据进行逻辑分区和排序。\n使用 PATTERN 子句定义要寻找的行的模式。这些模式使用类似于正则表达式的语法。\n行模式变量的逻辑成分在 DEFINE 子句中指定。\n在 MEASURES 子句中定义措施，这些措施是在 SQL 查询的其他部分中可用的表达式。\n下面的例子说明了基本模式识别的语法。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"n\"\u003eT\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eaid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eT\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eT\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecid\u003c/span\u003e\n\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e \u003cspan class=\"n\"\u003eMyTable\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eMATCH_RECOGNIZE\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\n      \u003cspan class=\"n\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"k\"\u003eBY\u003c/span\u003e \u003cspan class=\"n\"\u003euserid\u003c/span\u003e\n      \u003cspan class=\"k\"\u003eORDER\u003c/span\u003e \u003cspan class=\"k\"\u003eBY\u003c/span\u003e \u003cspan class=\"n\"\u003eproctime\u003c/span\u003e\n      \u003cspan class=\"n\"\u003eMEASURES\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eid\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003eaid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eid\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003ebid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eid\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003ecid\u003c/span\u003e\n      \u003cspan class=\"n\"\u003ePATTERN\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e \u003cspan class=\"k\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n      \u003cspan class=\"n\"\u003eDEFINE\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eA\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003ename\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003ea\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eB\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003ename\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003eb\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eC\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003ename\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003ec\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003eT\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e本页将更详细地解释每个关键字，并将说明更复杂的例子。\u003c/p\u003e\n\u003cp\u003e注意 Flink 对 MATCH_RECOGNIZE 子句的实现是完整标准的一个子集。只有那些在下面的章节中记录的功能得到了支持。根据社区反馈，可能会支持更多的功能，也请看一下已知的限制。\u003c/p\u003e\n\u003cp\u003e介绍和示例\n安装指南\n模式识别功能内部使用了 Apache Flink 的 CEP 库。为了能够使用 MATCH_RECOGNIZE 子句，需要将该库作为一个依赖项添加到你的 Maven 项目中。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;dependency\u003c/span\u003e\u003cspan class=\"nt\"\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"nt\"\u003e\u0026lt;groupId\u003c/span\u003e\u003cspan class=\"nt\"\u003e\u0026gt;\u003c/span\u003eorg.apache.flink\u003cspan class=\"nt\"\u003e\u0026lt;/groupId\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"nt\"\u003e\u0026lt;artifactId\u003c/span\u003e\u003cspan class=\"nt\"\u003e\u0026gt;\u003c/span\u003eflink-cep_2.11\u003cspan class=\"nt\"\u003e\u0026lt;/artifactId\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"nt\"\u003e\u0026lt;version\u003c/span\u003e\u003cspan class=\"nt\"\u003e\u0026gt;\u003c/span\u003e1.11.0\u003cspan class=\"nt\"\u003e\u0026lt;/version\u0026gt;\u003c/span\u003e\n\u003cspan class=\"nt\"\u003e\u0026lt;/dependency\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e另外，你也可以将依赖关系添加到集群 classpath 中（更多信息请参见依赖关系部分）。\u003c/p\u003e\n\u003cp\u003e如果你想在 SQL 客户端中使用 MATCH_RECOGNIZE 子句，你不需要做任何事情，因为所有的依赖关系都是默认的。\u003c/p\u003e\n\u003cp\u003eSQL 语义\n每个 MATCH_RECOGNIZE 查询都由以下子句组成。\u003c/p\u003e\n\u003cp\u003ePARTITION BY - 定义表的逻辑分区；类似于 GROUP BY 操作。\u003c/p\u003e\n\u003cp\u003eMEASURES - 定义子句的输出；类似于 SELECT 子句。\nONE ROW PER MATCH - 输出模式，定义每次匹配应该产生多少行。\nAFTER MATCH SKIP\u0026ndash;指定下一个匹配应该从哪里开始；这也是控制一个事件可以属于多少个不同匹配的方法。\nPATTERN - 允许使用类似于正则表达式的语法来构建搜索的模式。\nDEFINE - 这一部分定义了模式变量必须满足的条件。\n注意 目前，MATCH_RECOGNIZE 子句只能应用于追加表。此外，它也总是产生一个追加表。\u003c/p\u003e\n\u003cp\u003e例子\n在我们的例子中，我们假设已经注册了一个 Ticker 表。该表包含股票在某一特定时间点的价格。\u003c/p\u003e\n\u003cp\u003e该表的模式如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eTicker\n     |-- symbol: String                           # symbol of the stock\n     |-- price: Long                              # price of the stock\n     |-- tax: Long                                # tax liability of the stock\n     |-- rowtime: TimeIndicatorTypeInfo(rowtime)  # point in time when the change to those values happened\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e为了简化，我们只考虑单只股票 ACME 的传入数据。一个行情可以类似于下表，其中行是连续追加的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esymbol         rowtime         price    tax\n======  ====================  ======= =======\n'ACME'  '01-Apr-11 10:00:00'   12      1\n'ACME'  '01-Apr-11 10:00:01'   17      2\n'ACME'  '01-Apr-11 10:00:02'   19      1\n'ACME'  '01-Apr-11 10:00:03'   21      3\n'ACME'  '01-Apr-11 10:00:04'   25      2\n'ACME'  '01-Apr-11 10:00:05'   18      1\n'ACME'  '01-Apr-11 10:00:06'   15      1\n'ACME'  '01-Apr-11 10:00:07'   14      2\n'ACME'  '01-Apr-11 10:00:08'   24      2\n'ACME'  '01-Apr-11 10:00:09'   25      2\n'ACME'  '01-Apr-11 10:00:10'   19      1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在的任务是寻找单一行情的价格不断下降的时期。为此，可以写一个类似的查询。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e \u003cspan class=\"n\"\u003eTicker\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eMATCH_RECOGNIZE\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"k\"\u003eBY\u003c/span\u003e \u003cspan class=\"n\"\u003esymbol\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eORDER\u003c/span\u003e \u003cspan class=\"k\"\u003eBY\u003c/span\u003e \u003cspan class=\"n\"\u003erowtime\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eMEASURES\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eSTART_ROW\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erowtime\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003estart_tstamp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePRICE_DOWN\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erowtime\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003ebottom_tstamp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePRICE_UP\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erowtime\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003eend_tstamp\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eONE\u003c/span\u003e \u003cspan class=\"k\"\u003eROW\u003c/span\u003e \u003cspan class=\"n\"\u003ePER\u003c/span\u003e \u003cspan class=\"k\"\u003eMATCH\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eAFTER\u003c/span\u003e \u003cspan class=\"k\"\u003eMATCH\u003c/span\u003e \u003cspan class=\"n\"\u003eSKIP\u003c/span\u003e \u003cspan class=\"k\"\u003eTO\u003c/span\u003e \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e \u003cspan class=\"n\"\u003ePRICE_UP\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ePATTERN\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eSTART_ROW\u003c/span\u003e \u003cspan class=\"n\"\u003ePRICE_DOWN\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ePRICE_UP\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eDEFINE\u003c/span\u003e\n            \u003cspan class=\"n\"\u003ePRICE_DOWN\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e\n                \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003eLAST\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePRICE_DOWN\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eIS\u003c/span\u003e \u003cspan class=\"k\"\u003eNULL\u003c/span\u003e \u003cspan class=\"k\"\u003eAND\u003c/span\u003e \u003cspan class=\"n\"\u003ePRICE_DOWN\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eSTART_ROW\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eOR\u003c/span\u003e\n                    \u003cspan class=\"n\"\u003ePRICE_DOWN\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePRICE_DOWN\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"n\"\u003ePRICE_UP\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e\n                \u003cspan class=\"n\"\u003ePRICE_UP\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePRICE_DOWN\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eMR\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e该查询按符号列对 Ticker 表进行分区，并按行时间属性进行排序。\u003c/p\u003e\n\u003cp\u003ePATTERN 子句指定我们感兴趣的模式是以 START_ROW 事件为起点，然后是一个或多个 PRICE_DOWN 事件，最后是 PRICE_UP 事件。如果能找到这样的模式，下一个模式匹配将在最后一个 PRICE_UP 事件中寻找，如 AFTER MATCH SKIP TO LAST 子句所示。\u003c/p\u003e\n\u003cp\u003eDEFINE 子句指定了 PRICE_DOWN 和 PRICE_UP 事件需要满足的条件。虽然 START_ROW 模式变量并不存在，但它有一个隐含的条件，这个条件总是被评估为 TRUE。\u003c/p\u003e\n\u003cp\u003e模式变量 PRICE_DOWN 被定义为价格小于满足 PRICE_DOWN 条件的最后一行的价格。对于初始情况或者没有满足 PRICE_DOWN 条件的最后一行，这一行的价格应该小于模式中前一行的价格（由 START_ROW 引用）。\u003c/p\u003e\n\u003cp\u003e模式变量 PRICE_UP 被定义为价格大于满足 PRICE_DOWN 条件的最后一行的价格的行。\u003c/p\u003e\n\u003cp\u003e该查询为股票价格连续下跌的每个时期产生一条汇总行。\u003c/p\u003e\n\u003cp\u003e输出行的具体表示方法在查询的 MEASURES 部分定义。输出行的数量由 ONE ROW PER MATCH 输出模式定义。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e symbol       start_tstamp       bottom_tstamp         end_tstamp\n=========  ==================  ==================  ==================\nACME       01-APR-11 10:00:04  01-APR-11 10:00:07  01-APR-11 10:00:08\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e结果一行描述了从 01-APR-11 10:00:04 开始的价格下降期，在 01-APR-11 10:00:07 达到最低价，在 01-APR-11 10:00:08 再次上涨。\u003c/p\u003e\n\u003cp\u003e分割\n可以在分区数据中寻找模式，例如，单个股票或特定用户的趋势。这可以使用 partition by 子句来表达。该子句类似于使用 GROUP BY 进行聚合。\u003c/p\u003e\n\u003cp\u003e注意 强烈建议对输入的数据进行分区，否则 MATCH_RECOGNIZE 子句将被翻译成一个非平行操作符，以确保全局排序。\u003c/p\u003e\n\u003cp\u003e事件的顺序\nApache Flink 允许根据时间来搜索模式；无论是处理时间还是事件时间。\u003c/p\u003e\n\u003cp\u003e在事件时间的情况下，事件在被传递到内部模式状态机之前会被排序。因此，产生的输出将是正确的，不管行被附加到表中的顺序如何。相反，模式是按照每行包含的时间所指定的顺序来评估的。\u003c/p\u003e\n\u003cp\u003eMATCH_RECOGNIZE 子句假设时间属性以升序作为 ORDER BY 子句的第一个参数。\u003c/p\u003e\n\u003cp\u003e对于 Ticker 表的例子，像 ORDER BY rowtime ASC, price DESC 这样的定义是有效的，但是 ORDER BY price, rowtime 或者 ORDER BY rowtime DESC, price ASC 是无效的。\u003c/p\u003e\n\u003cp\u003e定义和测量\nDEFINE 和 MEASURES 关键字的含义类似于简单 SQL 查询中的 WHERE 和 SELECT 子句。\u003c/p\u003e\n\u003cp\u003eMEASURES 子句定义了匹配模式的输出中会包含哪些内容。它可以投射列和定义评估的表达式。产生的行数取决于输出模式的设置。\u003c/p\u003e\n\u003cp\u003eDEFINE 子句指定了行必须满足的条件，以便将其分类到相应的模式变量。如果没有为模式变量定义条件，那么将使用一个默认条件，该条件对每条记录的评价为真。\u003c/p\u003e\n\u003cp\u003e关于这些子句中可以使用的表达式的更详细解释，请看事件流导航部分。\u003c/p\u003e\n\u003cp\u003e聚合\n聚合可以在 DEFINE 和 MEASURES 子句中使用。同时支持内置和自定义的用户定义函数。\u003c/p\u003e\n\u003cp\u003e聚合函数被应用于映射到匹配的行的每个子集。为了了解这些子集是如何被评估的，请看一下事件流导航部分。\u003c/p\u003e\n\u003cp\u003e下面这个例子的任务是找到一个股票平均价格不低于某个阈值的最长时间段。它显示了 MATCH_RECOGNIZE 可以如何通过聚合来表达。这个任务可以用下面的查询来执行。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e \u003cspan class=\"n\"\u003eTicker\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eMATCH_RECOGNIZE\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"k\"\u003eBY\u003c/span\u003e \u003cspan class=\"n\"\u003esymbol\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eORDER\u003c/span\u003e \u003cspan class=\"k\"\u003eBY\u003c/span\u003e \u003cspan class=\"n\"\u003erowtime\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eMEASURES\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eFIRST\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erowtime\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003estart_tstamp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erowtime\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003eend_tstamp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eAVG\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003eavgPrice\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eONE\u003c/span\u003e \u003cspan class=\"k\"\u003eROW\u003c/span\u003e \u003cspan class=\"n\"\u003ePER\u003c/span\u003e \u003cspan class=\"k\"\u003eMATCH\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eAFTER\u003c/span\u003e \u003cspan class=\"k\"\u003eMATCH\u003c/span\u003e \u003cspan class=\"n\"\u003eSKIP\u003c/span\u003e \u003cspan class=\"n\"\u003ePAST\u003c/span\u003e \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e \u003cspan class=\"k\"\u003eROW\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ePATTERN\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eDEFINE\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eA\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"k\"\u003eAVG\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e15\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eMR\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e给定这个查询和以下输入值：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esymbol         rowtime         price    tax\n======  ====================  ======= =======\n'ACME'  '01-Apr-11 10:00:00'   12      1\n'ACME'  '01-Apr-11 10:00:01'   17      2\n'ACME'  '01-Apr-11 10:00:02'   13      1\n'ACME'  '01-Apr-11 10:00:03'   16      3\n'ACME'  '01-Apr-11 10:00:04'   25      2\n'ACME'  '01-Apr-11 10:00:05'   2       1\n'ACME'  '01-Apr-11 10:00:06'   4       1\n'ACME'  '01-Apr-11 10:00:07'   10      2\n'ACME'  '01-Apr-11 10:00:08'   15      2\n'ACME'  '01-Apr-11 10:00:09'   25      2\n'ACME'  '01-Apr-11 10:00:10'   25      1\n'ACME'  '01-Apr-11 10:00:11'   30      1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e只要事件的平均价格不超过 15，查询就会将事件累积为模式变量 A 的一部分。例如，这样的超限事件发生在 01-4-11 10:00:04。接下来的时期在 01-4-11 10:00:11 再次超过 15 的平均价格。因此，所述查询的结果将是：。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e symbol       start_tstamp       end_tstamp          avgPrice\n=========  ==================  ==================  ============\nACME       01-APR-11 10:00:00  01-APR-11 10:00:03     14.5\nACME       01-APR-11 10:00:05  01-APR-11 10:00:10     13.5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e注意 聚合可以应用于表达式，但只有当它们引用一个单一的模式变量时才可以。因此 SUM(A.price * A.tax)是有效的，但是 AVG(A.price * B.tax)不是。\u003c/p\u003e\n\u003cp\u003e注意不支持 DISTINCT 聚合。\u003c/p\u003e\n\u003cp\u003e定义一个模式\nMATCH_RECOGNIZE 子句允许用户在事件流中搜索模式，使用一种强大的、富有表现力的语法，这种语法与广泛使用的正则表达式语法有些相似。\u003c/p\u003e\n\u003cp\u003e每个模式都是由基本的构件构成的，称为模式变量，可以对其应用运算符（量化符和其他修饰符）。整个模式必须用括号括起来。\u003c/p\u003e\n\u003cp\u003e一个模式的例子可以是这样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePATTERN (A B+ C* D)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们可以使用以下操作符。\u003c/p\u003e\n\u003cp\u003e并集 \u0026ndash; 像(A B)这样的模式意味着 A 和 B 之间的相邻性是严格的，因此，中间不能有没有映射到 A 或 B 的行。\n定量符\u0026ndash;修改可以映射到模式变量的行数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e* — 0 or more rows\n+ — 1 or more rows\n? — 0 or 1 rows\n{ n } — exactly n rows (n \u0026gt; 0)\n{ n, } — n or more rows (n ≥ 0)\n{ n, m } — between n and m (inclusive) rows (0 ≤ n ≤ m, 0 \u0026lt; m)\n{ , m } — between 0 and m (inclusive) rows (m \u0026gt; 0)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e注意 不支持可能产生空匹配的模式。这类模式的例子有 PATTERN (A*)、PATTERN (A?B*)、PATTERN (A{0,} B{0,} C*)等。\u003c/p\u003e\n\u003cp\u003e贪婪和不情愿的量化器\n每个量化器可以是贪婪的（默认行为）或勉强的。贪婪的量化器试图匹配尽可能多的记录，而不情愿的量化器试图匹配尽可能少的记录。\u003c/p\u003e\n\u003cp\u003e为了说明两者的区别，我们可以查看下面的示例，在这个示例中，一个贪婪的量化器被应用于 B 变量。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e \u003cspan class=\"n\"\u003eTicker\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eMATCH_RECOGNIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"k\"\u003eBY\u003c/span\u003e \u003cspan class=\"n\"\u003esymbol\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eORDER\u003c/span\u003e \u003cspan class=\"k\"\u003eBY\u003c/span\u003e \u003cspan class=\"n\"\u003erowtime\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eMEASURES\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003elastPrice\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eONE\u003c/span\u003e \u003cspan class=\"k\"\u003eROW\u003c/span\u003e \u003cspan class=\"n\"\u003ePER\u003c/span\u003e \u003cspan class=\"k\"\u003eMATCH\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eAFTER\u003c/span\u003e \u003cspan class=\"k\"\u003eMATCH\u003c/span\u003e \u003cspan class=\"n\"\u003eSKIP\u003c/span\u003e \u003cspan class=\"n\"\u003ePAST\u003c/span\u003e \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e \u003cspan class=\"k\"\u003eROW\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ePATTERN\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"k\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eDEFINE\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eA\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eB\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e15\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eC\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"k\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e12\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e鉴于我们有以下输入。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e symbol  tax   price          rowtime\n======= ===== ======== =====================\n XYZ     1     10       2018-09-17 10:00:02\n XYZ     2     11       2018-09-17 10:00:03\n XYZ     1     12       2018-09-17 10:00:04\n XYZ     2     13       2018-09-17 10:00:05\n XYZ     1     14       2018-09-17 10:00:06\n XYZ     2     16       2018-09-17 10:00:07\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述模式将产生以下输出。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e symbol   lastPrice\n======== ===========\n XYZ      16\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e同样的查询，将 \u003ccode\u003eB*\u003c/code\u003e 修改为 \u003ccode\u003eB*\u003c/code\u003e 吗，即 B*应该是不愿意的，会产生。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e symbol   lastPrice\n======== ===========\n XYZ      13\n XYZ      16\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e模式变量 B 只匹配到价格为 12 的行，而不是吞掉价格为 12、13、14 的行。\u003c/p\u003e\n\u003cp\u003e注意 对于一个模式的最后一个变量，不可能使用贪婪的量化符。因此，像（A B*）这样的模式是不允许的。这可以通过引入一个人为的状态（如 C）来轻松解决，这个状态具有 B 的否定条件，所以你可以使用这样的查询。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePATTERN (A B* C)\nDEFINE\n    A AS condA(),\n    B AS condB(),\n    C AS NOT condB()\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e注意 目前不支持可选的勉强量化符(A??或 A{0,1}?)。\u003c/p\u003e\n\u003cp\u003e时间限制\n特别是对于流式使用案例，通常要求一个模式在给定的时间内完成。这允许限制 Flink 必须在内部维护的整体状态大小，即使在贪婪的量化器的情况下。\u003c/p\u003e\n\u003cp\u003e因此，Flink SQL 支持额外的（非标准 SQL）WITHIN 子句来定义模式的时间约束。该子句可以定义在 PATTERN 子句之后，并以毫秒为间隔进行解析。\u003c/p\u003e\n\u003cp\u003e如果一个潜在匹配的第一个事件和最后一个事件之间的时间长于给定的值，这样的匹配将不会被追加到结果表中。\u003c/p\u003e\n\u003cp\u003e注意 一般鼓励使用 within 子句，因为它有助于 Flink 进行有效的内存管理。一旦达到阈值，底层状态可以被修剪。\u003c/p\u003e\n\u003cp\u003e注意 然而，WITHIN 子句不是 SQL 标准的一部分。推荐的处理时间限制的方式可能会在未来发生变化。\u003c/p\u003e\n\u003cp\u003e在下面的查询示例中说明了 WITHIN 子句的使用。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e \u003cspan class=\"n\"\u003eTicker\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eMATCH_RECOGNIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"k\"\u003eBY\u003c/span\u003e \u003cspan class=\"n\"\u003esymbol\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eORDER\u003c/span\u003e \u003cspan class=\"k\"\u003eBY\u003c/span\u003e \u003cspan class=\"n\"\u003erowtime\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eMEASURES\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erowtime\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003edropTime\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"k\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003edropDiff\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eONE\u003c/span\u003e \u003cspan class=\"k\"\u003eROW\u003c/span\u003e \u003cspan class=\"n\"\u003ePER\u003c/span\u003e \u003cspan class=\"k\"\u003eMATCH\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eAFTER\u003c/span\u003e \u003cspan class=\"k\"\u003eMATCH\u003c/span\u003e \u003cspan class=\"n\"\u003eSKIP\u003c/span\u003e \u003cspan class=\"n\"\u003ePAST\u003c/span\u003e \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e \u003cspan class=\"k\"\u003eROW\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ePATTERN\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"k\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eWITHIN\u003c/span\u003e \u003cspan class=\"nb\"\u003eINTERVAL\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e1\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e \u003cspan class=\"n\"\u003eHOUR\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eDEFINE\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eB\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eC\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"k\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e查询检测到在 1 小时的时间间隔内发生的价格下跌 10。\u003c/p\u003e\n\u003cp\u003e假设该查询用于分析以下行情数据。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esymbol         rowtime         price    tax\n======  ====================  ======= =======\n'ACME'  '01-Apr-11 10:00:00'   20      1\n'ACME'  '01-Apr-11 10:20:00'   17      2\n'ACME'  '01-Apr-11 10:40:00'   18      1\n'ACME'  '01-Apr-11 11:00:00'   11      3\n'ACME'  '01-Apr-11 11:20:00'   14      2\n'ACME'  '01-Apr-11 11:40:00'   9       1\n'ACME'  '01-Apr-11 12:00:00'   15      1\n'ACME'  '01-Apr-11 12:20:00'   14      2\n'ACME'  '01-Apr-11 12:40:00'   24      2\n'ACME'  '01-Apr-11 13:00:00'   1       2\n'ACME'  '01-Apr-11 13:20:00'   19      1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e查询将产生以下结果。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esymbol         dropTime         dropDiff\n======  ====================  =============\n'ACME'  '01-Apr-11 13:00:00'      14\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e结果行表示价格从 15（在 4 月 1 日 12:00:00）下降到 1（在 4 月 1 日 13:00:00）。dropDiff 列包含了价格差。\u003c/p\u003e\n\u003cp\u003e请注意，即使价格也以更高的数值下降，例如，下降 11（在 01-Apr-11 10:00:00 和 01-Apr-11 11:40:00 之间），这两个事件之间的时间差大于 1 小时。因此，它们不会产生匹配。\u003c/p\u003e\n\u003cp\u003e输出模式\n输出模式描述了每找到一个匹配的记录应该发出多少行。SQL 标准描述了两种模式。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eALL ROWS PER MATCH\nONE ROW PER MATCH.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e目前，唯一支持的输出模式是 ONE ROW PER MATCH，对于每一个找到的匹配项，总会产生一个输出汇总行。\u003c/p\u003e\n\u003cp\u003e输出行的模式将是[分区列]+[措施列]按该特定顺序的连接。\u003c/p\u003e\n\u003cp\u003e下面的例子显示了一个定义为查询的输出。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e \u003cspan class=\"n\"\u003eTicker\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eMATCH_RECOGNIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"k\"\u003eBY\u003c/span\u003e \u003cspan class=\"n\"\u003esymbol\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eORDER\u003c/span\u003e \u003cspan class=\"k\"\u003eBY\u003c/span\u003e \u003cspan class=\"n\"\u003erowtime\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eMEASURES\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eFIRST\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003estartPrice\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003etopPrice\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003elastPrice\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eONE\u003c/span\u003e \u003cspan class=\"k\"\u003eROW\u003c/span\u003e \u003cspan class=\"n\"\u003ePER\u003c/span\u003e \u003cspan class=\"k\"\u003eMATCH\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ePATTERN\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eDEFINE\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eA\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eIS\u003c/span\u003e \u003cspan class=\"k\"\u003eNULL\u003c/span\u003e \u003cspan class=\"k\"\u003eOR\u003c/span\u003e \u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eB\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e对于以下输入行：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e symbol   tax   price          rowtime\n======== ===== ======== =====================\n XYZ      1     10       2018-09-17 10:00:02\n XYZ      2     12       2018-09-17 10:00:03\n XYZ      1     13       2018-09-17 10:00:04\n XYZ      2     11       2018-09-17 10:00:05\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e查询将产生以下输出。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e symbol   startPrice   topPrice   lastPrice\n======== ============ ========== ===========\n XYZ      10           13         11\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e模式识别是按符号列进行分区的。尽管在 MEASURES 子句中没有明确提到，但在结果的开头会添加分区列。\u003c/p\u003e\n\u003cp\u003e模式导航\nDEFINE 和 MEASURES 子句允许在（可能）匹配模式的行列表中进行导航。\u003c/p\u003e\n\u003cp\u003e本节将讨论这种用于声明条件或产生输出结果的导航。\u003c/p\u003e\n\u003cp\u003e模式变量引用\n模式变量引用允许引用映射到 DEFINE 或 MEASURES 子句中特定模式变量的一组行。\u003c/p\u003e\n\u003cp\u003e例如，表达式 A.price 描述了迄今为止映射到 A 的一组行，再加上当前行，如果我们尝试将当前行与 A 进行匹配。如果 DEFINE/MEASURES 子句中的表达式需要单行（例如 A.price 或 A.price\u0026gt;10），则选择属于相应集合的最后一个值。\u003c/p\u003e\n\u003cp\u003e如果没有指定模式变量（例如 SUM(price)），表达式会引用默认的模式变量*，它引用模式中的所有变量。换句话说，它创建了一个迄今为止映射到任何变量的所有行加上当前行的列表。\u003c/p\u003e\n\u003cp\u003e例子\u003c/p\u003e\n\u003cp\u003e要想了解更透彻的例子，可以看看下面的模式和相应的条件。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePATTERN (A B+)\nDEFINE\n  A AS A.price \u0026gt; 10,\n  B AS B.price \u0026gt; A.price AND SUM(price) \u0026lt; 100 AND SUM(B.price) \u0026lt; 80\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e下表描述了如何评估每个传入事件的这些条件。\u003c/p\u003e\n\u003cp\u003e该表由以下几栏组成：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# - the row identifier that uniquely identifies an incoming row in the lists [A.price]/[B.price]/[price].\nprice - the price of the incoming row.\n[A.price]/[B.price]/[price] - describe lists of rows which are used in the DEFINE clause to evaluate conditions.\nClassifier - the classifier of the current row which indicates the pattern variable the row is mapped to.\nA.price/B.price/SUM(price)/SUM(B.price) - describes the result after those expressions have been evaluated.\n#\tprice\tClassifier\t[A.price]\t[B.price]\t[price]\tA.price\tB.price\tSUM(price)\tSUM(B.price)\n#1\t10\t-\u0026gt; A\t#1\t-\t-\t10\t-\t-\t-\n#2\t15\t-\u0026gt; B\t#1\t#2\t#1, #2\t10\t15\t25\t15\n#3\t20\t-\u0026gt; B\t#1\t#2, #3\t#1, #2, #3\t10\t20\t45\t35\n#4\t31\t-\u0026gt; B\t#1\t#2, #3, #4\t#1, #2, #3, #4\t10\t31\t76\t66\n#5\t35\t\t#1\t#2, #3, #4, #5\t#1, #2, #3, #4, #5\t10\t35\t111\t101\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e从表中可以看出，第一行被映射到模式变量 A，随后的行被映射到模式变量 B，但是最后一行不满足 B 的条件，因为所有映射行的 SUM(价格)和 B 中所有行的总和超过了指定的阈值。\u003c/p\u003e\n\u003cp\u003e逻辑偏移\n逻辑偏移可以在映射到特定模式变量的事件中进行导航。这可以用两个相应的函数来表示。\u003c/p\u003e\n\u003cp\u003e偏移函数 描述\nLAST(variable.field, n)\n返回事件中被映射到变量第 n 个最后元素的字段的值。从映射到的最后一个元素开始计算。\u003c/p\u003e\n\u003cp\u003eFIRST(variable.field, n)\n返回事件中被映射到变量第 n 个元素的字段值。从映射到的第一个元素开始计算。\u003c/p\u003e\n\u003cp\u003e示例\u003c/p\u003e\n\u003cp\u003e为了更透彻的举例，可以看看下面的模式和相应的条件。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePATTERN (A B+)\nDEFINE\n  A AS A.price \u0026gt; 10,\n  B AS (LAST(B.price, 1) IS NULL OR B.price \u0026gt; LAST(B.price, 1)) AND\n       (LAST(B.price, 2) IS NULL OR B.price \u0026gt; 2 * LAST(B.price, 2))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e下表描述了如何评估每个传入事件的这些条件。\u003c/p\u003e\n\u003cp\u003e该表由以下几栏组成：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprice - the price of the incoming row.\nClassifier - the classifier of the current row which indicates the pattern variable the row is mapped to.\nLAST(B.price, 1)/LAST(B.price, 2) - describes the result after those expressions have been evaluated.\nprice\tClassifier\tLAST(B.price, 1)\tLAST(B.price, 2)\tComment\n10\t-\u0026gt; A\t\t\t\n15\t-\u0026gt; B\tnull\tnull\tNotice that LAST(A.price, 1) is null because there is still nothing mapped to B.\n20\t-\u0026gt; B\t15\tnull\t\n31\t-\u0026gt; B\t20\t15\t\n35\t\t31\t20\tNot mapped because 35 \u0026lt; 2 * 20.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e使用默认的模式变量与逻辑偏移量也可能是有意义的。\u003c/p\u003e\n\u003cp\u003e在这种情况下，偏移量会考虑到目前为止映射的所有行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePATTERN (A B? C)\nDEFINE\n  B AS B.price \u0026lt; 20,\n  C AS LAST(price, 1) \u0026lt; C.price\nprice\tClassifier\tLAST(price, 1)\tComment\n10\t-\u0026gt; A\t\t\n15\t-\u0026gt; B\t\t\n20\t-\u0026gt; C\t15\tLAST(price, 1) is evaluated as the price of the row mapped to the B variable.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果第二行没有映射到 B 变量，我们会有以下结果。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprice\tClassifier\tLAST(price, 1)\tComment\n10\t-\u0026gt; A\t\t\n20\t-\u0026gt; C\t10\tLAST(price, 1) is evaluated as the price of the row mapped to the A variable.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e也可以在 first/last 函数的第一个参数中使用多个模式变量引用。这样，就可以写一个访问多列的表达式。但是，所有这些表达式必须使用同一个模式变量。换句话说，LAST/FIRST 函数的值必须在单行中计算。\u003c/p\u003e\n\u003cp\u003e因此，可以使用 LAST(A.price * A.tax)，但不允许使用 LAST(A.price * B.tax)这样的表达式。\u003c/p\u003e\n\u003cp\u003e匹配后策略\nAFTER MATCH SKIP 子句指定了在找到完整匹配后，在哪里开始一个新的匹配过程。\u003c/p\u003e\n\u003cp\u003e有四种不同的策略。\u003c/p\u003e\n\u003cp\u003eSKIP PAST LAST ROW - 在当前匹配的最后一行之后的下一行恢复模式匹配。\nSKIP TO NEXT ROW - 从匹配起始行后的下一行开始继续搜索新的匹配。\nSKIP TO LAST 变量\u0026ndash;在映射到指定模式变量的最后一行恢复模式匹配。\nSKIP TO FIRST 变量\u0026ndash;在被映射到指定模式变量的第一行恢复模式匹配。\n这也是一种指定一个事件可以属于多少个匹配的方式。例如，使用 SKIP PAST LAST ROW 策略，每个事件最多只能属于一个匹配。\u003c/p\u003e\n\u003cp\u003e例子\u003c/p\u003e\n\u003cp\u003e为了更好地理解这些策略之间的差异，可以看一下下面的例子。\u003c/p\u003e\n\u003cp\u003e对于以下输入行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e symbol   tax   price         rowtime\n======== ===== ======= =====================\n XYZ      1     7       2018-09-17 10:00:01\n XYZ      2     9       2018-09-17 10:00:02\n XYZ      1     10      2018-09-17 10:00:03\n XYZ      2     5       2018-09-17 10:00:04\n XYZ      2     17      2018-09-17 10:00:05\n XYZ      2     14      2018-09-17 10:00:06\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们用不同的策略评估以下查询。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e \u003cspan class=\"n\"\u003eTicker\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eMATCH_RECOGNIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"k\"\u003eBY\u003c/span\u003e \u003cspan class=\"n\"\u003esymbol\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eORDER\u003c/span\u003e \u003cspan class=\"k\"\u003eBY\u003c/span\u003e \u003cspan class=\"n\"\u003erowtime\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eMEASURES\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eSUM\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003esumPrice\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eFIRST\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erowtime\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003estartTime\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eLAST\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erowtime\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"n\"\u003eendTime\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eONE\u003c/span\u003e \u003cspan class=\"k\"\u003eROW\u003c/span\u003e \u003cspan class=\"n\"\u003ePER\u003c/span\u003e \u003cspan class=\"k\"\u003eMATCH\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"k\"\u003eAFTER\u003c/span\u003e \u003cspan class=\"k\"\u003eMATCH\u003c/span\u003e \u003cspan class=\"n\"\u003eSTRATEGY\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ePATTERN\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"k\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eDEFINE\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eA\u003c/span\u003e \u003cspan class=\"k\"\u003eAS\u003c/span\u003e \u003cspan class=\"k\"\u003eSUM\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprice\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e30\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e查询返回映射到 A 的所有行的价格总和，以及整体匹配的第一个和最后一个时间戳。\u003c/p\u003e\n\u003cp\u003e根据使用的 AFTER MATCH 策略，查询会产生不同的结果。\u003c/p\u003e\n\u003cp\u003eAFTER MATCH SKIP PAST ROW(跳过最后一行)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e symbol   sumPrice        startTime              endTime\n======== ========== ===================== =====================\n XYZ      26         2018-09-17 10:00:01   2018-09-17 10:00:04\n XYZ      17         2018-09-17 10:00:05   2018-09-17 10:00:06\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e第一个结果与 1 号，2 号，3 号，4 号行相匹配。\u003c/p\u003e\n\u003cp\u003e第二个结果与#5, #6 行相匹配。\u003c/p\u003e\n\u003cp\u003e匹配后跳转到下一行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e symbol   sumPrice        startTime              endTime\n======== ========== ===================== =====================\n XYZ      26         2018-09-17 10:00:01   2018-09-17 10:00:04\n XYZ      24         2018-09-17 10:00:02   2018-09-17 10:00:05\n XYZ      15         2018-09-17 10:00:03   2018-09-17 10:00:05\n XYZ      22         2018-09-17 10:00:04   2018-09-17 10:00:06\n XYZ      17         2018-09-17 10:00:05   2018-09-17 10:00:06\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e同样，第一个结果对 1 号、2 号、3 号、4 号行进行匹配。\u003c/p\u003e\n\u003cp\u003e与之前的策略相比，接下来的匹配中又包含了 2 号行的匹配。因此，第二个结果与行#2，#3，#4，#5 相匹配。\u003c/p\u003e\n\u003cp\u003e第三个结果与 3 号，4 号，5 号行相匹配。\u003c/p\u003e\n\u003cp\u003e第四个结果与行#4，#5，#6 相匹配。\u003c/p\u003e\n\u003cp\u003e最后一个结果与行#5，#6 匹配。\u003c/p\u003e\n\u003cp\u003e匹配后跳转到最后一行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e symbol   sumPrice        startTime              endTime\n======== ========== ===================== =====================\n XYZ      26         2018-09-17 10:00:01   2018-09-17 10:00:04\n XYZ      15         2018-09-17 10:00:03   2018-09-17 10:00:05\n XYZ      22         2018-09-17 10:00:04   2018-09-17 10:00:06\n XYZ      17         2018-09-17 10:00:05   2018-09-17 10:00:06\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e同样，第一个结果针对 1 号、2 号、3 号、4 号行进行匹配。\u003c/p\u003e\n\u003cp\u003e与之前的策略相比，接下来的匹配只包括 3 号行（映射到 A 行），再次进行匹配。因此，第二个结果与行#3，#4，#5 相匹配。\u003c/p\u003e\n\u003cp\u003e第三个结果与#4，#5，#6 行相匹配。\u003c/p\u003e\n\u003cp\u003e最后一个结果与行#5,#6 匹配，因此第三个结果与行#4,#5,#6 匹配。\u003c/p\u003e\n\u003cp\u003e匹配后跳转到第一行 A。\u003c/p\u003e\n\u003cp\u003e这个组合会产生一个运行时异常，因为我们总是试图在上一个比赛开始的地方开始一个新的比赛。这将产生一个无限循环，因此是被禁止的。\u003c/p\u003e\n\u003cp\u003e我们必须记住，在使用 SKIP TO FIRST/LAST 变量策略的情况下，有可能没有记录映射到该变量上（例如模式 A*）。在这种情况下，将抛出一个运行时异常，因为标准要求有一条有效的记录来继续匹配。\u003c/p\u003e\n\u003cp\u003e时间属性\n为了在 MATCH_RECOGNIZE 之上应用一些后续的查询，可能需要使用时间属性。为了选择这些属性，有两个函数可用。\u003c/p\u003e\n\u003cp\u003e功能描述\nMATCH_ROWTIME()\n返回被映射到给定模式的最后一行的时间戳。\u003c/p\u003e\n\u003cp\u003e所得到的属性是一个 rowtime 属性，它可以被用于后续的基于时间的操作，如区间连接和组窗口或窗口聚合。\u003c/p\u003e\n\u003cp\u003eMATCH_PROCTIME()\n返回一个 proctime 属性，该属性可用于后续基于时间的操作，如区间连接和组窗口或窗口聚合。\u003c/p\u003e\n\u003cp\u003e控制内存消耗\n在编写 MATCH_RECOGNIZE 查询时，内存消耗是一个重要的考虑因素，因为潜在的匹配空间是以类似广度优先的方式建立的。考虑到这一点，必须确保模式能够完成。最好是有合理数量的行映射到匹配中，因为它们必须适应内存。\u003c/p\u003e\n\u003cp\u003e例如，模式不能有一个没有上限的量化器，接受每一行。这样的模式可以是这样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePATTERN (A B+ C)\nDEFINE\n  A as A.price \u0026gt; 10,\n  C as C.price \u0026gt; 20\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e该查询将把每一条进入的记录映射到 B 变量上，因此永远不会结束。这个查询可以通过否定 C 的条件来解决。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePATTERN (A B+ C)\nDEFINE\n  A as A.price \u0026gt; 10,\n  B as B.price \u0026lt;= 20,\n  C as C.price \u0026gt; 20\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e或者通过使用勉强的定量器。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePATTERN (A B+? C)\nDEFINE\n  A as A.price \u0026gt; 10,\n  C as C.price \u0026gt; 20\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e注意 请注意，MATCH_RECOGNIZE 子句不使用配置的状态保留时间。人们可能希望使用 WITHIN 子句来达到这个目的。\u003c/p\u003e\n\u003cp\u003e已知限制\nFlink 对 MATCH_RECOGNIZE 子句的实现是一项持续的努力，目前还不支持 SQL 标准的一些功能。\u003c/p\u003e\n\u003cp\u003e不支持的功能包括\u003c/p\u003e\n\u003cp\u003e模式表达式。\n模式组\u0026ndash;这意味着，例如量化符不能应用于模式的子序列。因此，（A (B C)+）不是有效的模式。\n改变\u0026ndash;像 PATTERN((A B | C D) E)这样的模式，这意味着在寻找 E 行之前必须先找到一个子序列 A B 或 C D。\nPERMUTE 运算符\u0026ndash;相当于它所应用的所有变量的排列组合，例如 PATTERN(PERMUTE (A, B, C))=PATTERN(A B C | A C B | B A C | B A C | C B A | C B A)。\n锚 - ^, $，表示一个分区的开始/结束，这些在流媒体环境中没有意义，将不被支持。\n排除 - PATTERN ({- A -} B) 意味着 A 将被查找，但不会参与输出。这只对 ALL ROWS PER MATCH 模式有效。\n不情愿的可选量化符\u0026ndash;PATTERN A?? 只支持贪婪的可选量化符。\nALL ROWS PER MATCH 输出模式\u0026ndash;它为每一条参与创建发现匹配的记录产生一条输出行。这也意味着。\nMEASURES 子句唯一支持的语义是 FINAL。\nCLASSIFIER 函数，该函数返回某行被映射到的模式变量，目前还不支持。\nSUBSET - 允许创建模式变量的逻辑组，并在 DEFINE 和 MEASURES 子句中使用这些组。\n物理偏移\u0026ndash;PREV/NEXT，它索引所有看到的事件，而不是只索引那些被映射到模式变量的事件（如逻辑偏移情况）。\n提取时间属性\u0026ndash;目前没有可能为后续基于时间的操作获取时间属性。\nMATCH_RECOGNIZE 只支持 SQL。在 Table API 中没有等价物。\n聚合。\n不支持不同的聚合。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/streaming/match_recognize.html\"\u003ehttps://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/streaming/match_recognize.html\u003c/a\u003e\u003c/p\u003e\n","text":"检测表格中的模式 搜索一组事件模式是一个常见的用例，特别是在数据流的情况下。Flink 自带复杂事件处理（CEP）库，可以在事件流中进行模式检测。此外，Flink 的 SQL API 提供了一种关系型的查询表达方式，有大量的内置函数和基于规则的优化，可以开箱即用。\n2016 年 12 月，国际标准化组织（ISO）发布了新版本的 SQL 标准，其中包括 SQL 中的行模式识别（ISO/IEC TR 19075-5:2016）。它允许 Flink 使用 MATCH_RECOGNIZE 子句整合 CEP 和 SQL API，用于 SQL 中的复杂事件处理。\nMATCH_RECOGNIZE 子句可以实现以下任务。\n对使用 partition by 和 order by 子句的数据进行逻辑分区和排序。 使用 PATTERN 子句定义要寻找的行的模式。这些模式使用类似于正则表达式的语法。 行模式变量的逻辑成分在 DEFINE 子句中指定。 在 MEASURES 子句中定义措施，这些措施是在 SQL 查询的其他部分中可用的表达式。 下面的例子说明了基本模式识别的语法。\nSELECT T.aid, T.bid, T.cid FROM MyTable MATCH_RECOGNIZE ( PARTITION BY userid ORDER BY proctime MEASURES A.id AS aid, B.id AS bid, C.id AS cid PATTERN (A B C) DEFINE A AS name = \u0026#39;a\u0026#39;, B AS name = \u0026#39;b\u0026#39;, C AS name = \u0026#39;c\u0026#39; ) AS T 本页将更详细地解释每个关键字，并将说明更复杂的例子。\n注意 Flink 对 MATCH_RECOGNIZE 子句的实现是完整标准的一个子集。只有那些在下面的章节中记录的功能得到了支持。根据社区反馈，可能会支持更多的功能，也请看一下已知的限制。\n介绍和示例 安装指南 模式识别功能内部使用了 Apache Flink 的 CEP 库。为了能够使用 MATCH_RECOGNIZE 子句，需要将该库作为一个依赖项添加到你的 Maven 项目中。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.flink\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;flink-cep_2.11\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.11.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 另外，你也可以将依赖关系添加到集群 classpath 中（更多信息请参见依赖关系部分）。\n如果你想在 SQL 客户端中使用 MATCH_RECOGNIZE 子句，你不需要做任何事情，因为所有的依赖关系都是默认的。\nSQL 语义 每个 MATCH_RECOGNIZE 查询都由以下子句组成。\nPARTITION BY - 定义表的逻辑分区；类似于 GROUP BY 操作。\nMEASURES - 定义子句的输出；类似于 SELECT 子句。 ONE ROW PER MATCH - 输出模式，定义每次匹配应该产生多少行。 AFTER MATCH SKIP\u0026ndash;指定下一个匹配应该从哪里开始；这也是控制一个事件可以属于多少个不同匹配的方法。 PATTERN - 允许使用类似于正则表达式的语法来构建搜索的模式。 DEFINE - 这一部分定义了模式变量必须满足的条件。 注意 目前，MATCH_RECOGNIZE 子句只能应用于追加表。此外，它也总是产生一个追加表。\n例子 在我们的例子中，我们假设已经注册了一个 Ticker 表。该表包含股票在某一特定时间点的价格。\n该表的模式如下：\nTicker |-- symbol: String # symbol of the stock |-- price: Long # price of the stock |-- tax: Long # tax liability of the stock |-- rowtime: TimeIndicatorTypeInfo(rowtime) # point in time when the change to those values happened 为了简化，我们只考虑单只股票 ACME 的传入数据。一个行情可以类似于下表，其中行是连续追加的。\nsymbol rowtime price tax ====== ==================== ======= ======= 'ACME' '01-Apr-11 10:00:00' 12 1 'ACME' '01-Apr-11 10:00:01' 17 2 'ACME' '01-Apr-11 10:00:02' 19 1 'ACME' '01-Apr-11 10:00:03' 21 3 'ACME' '01-Apr-11 10:00:04' 25 2 'ACME' '01-Apr-11 10:00:05' 18 1 'ACME' '01-Apr-11 10:00:06' 15 1 'ACME' '01-Apr-11 10:00:07' 14 2 'ACME' '01-Apr-11 10:00:08' 24 2 'ACME' '01-Apr-11 10:00:09' 25 2 'ACME' '01-Apr-11 10:00:10' 19 1 现在的任务是寻找单一行情的价格不断下降的时期。为此，可以写一个类似的查询。\nSELECT * FROM Ticker MATCH_RECOGNIZE ( PARTITION BY symbol ORDER BY rowtime MEASURES START_ROW.rowtime AS start_tstamp, LAST(PRICE_DOWN.rowtime) AS bottom_tstamp, LAST(PRICE_UP.rowtime) AS end_tstamp ONE ROW PER MATCH AFTER MATCH SKIP TO LAST PRICE_UP PATTERN (START_ROW PRICE_DOWN+ PRICE_UP) DEFINE PRICE_DOWN AS (LAST(PRICE_DOWN.price, 1) IS NULL AND PRICE_DOWN.price \u0026lt; START_ROW.price) OR PRICE_DOWN.price \u0026lt; LAST(PRICE_DOWN.price, 1), PRICE_UP AS PRICE_UP.price \u0026gt; LAST(PRICE_DOWN.price, 1) ) MR; 该查询按符号列对 Ticker 表进行分区，并按行时间属性进行排序。\nPATTERN 子句指定我们感兴趣的模式是以 START_ROW 事件为起点，然后是一个或多个 PRICE_DOWN 事件，最后是 PRICE_UP 事件。如果能找到这样的模式，下一个模式匹配将在最后一个 PRICE_UP 事件中寻找，如 AFTER MATCH SKIP TO LAST 子句所示。\nDEFINE 子句指定了 PRICE_DOWN 和 PRICE_UP 事件需要满足的条件。虽然 START_ROW 模式变量并不存在，但它有一个隐含的条件，这个条件总是被评估为 TRUE。\n模式变量 PRICE_DOWN 被定义为价格小于满足 PRICE_DOWN 条件的最后一行的价格。对于初始情况或者没有满足 PRICE_DOWN 条件的最后一行，这一行的价格应该小于模式中前一行的价格（由 START_ROW 引用）。\n模式变量 PRICE_UP 被定义为价格大于满足 PRICE_DOWN 条件的最后一行的价格的行。\n该查询为股票价格连续下跌的每个时期产生一条汇总行。\n输出行的具体表示方法在查询的 MEASURES 部分定义。输出行的数量由 ONE ROW PER MATCH 输出模式定义。\n symbol start_tstamp bottom_tstamp end_tstamp ========= ================== ================== ================== ACME 01-APR-11 10:00:04 01-APR-11 10:00:07 01-APR-11 10:00:08 结果一行描述了从 01-APR-11 10:00:04 开始的价格下降期，在 01-APR-11 10:00:07 达到最低价，在 01-APR-11 10:00:08 再次上涨。\n分割 可以在分区数据中寻找模式，例如，单个股票或特定用户的趋势。这可以使用 partition by 子句来表达。该子句类似于使用 GROUP BY 进行聚合。\n注意 强烈建议对输入的数据进行分区，否则 MATCH_RECOGNIZE 子句将被翻译成一个非平行操作符，以确保全局排序。\n事件的顺序 Apache Flink 允许根据时间来搜索模式；无论是处理时间还是事件时间。\n在事件时间的情况下，事件在被传递到内部模式状态机之前会被排序。因此，产生的输出将是正确的，不管行被附加到表中的顺序如何。相反，模式是按照每行包含的时间所指定的顺序来评估的。\nMATCH_RECOGNIZE 子句假设时间属性以升序作为 ORDER BY 子句的第一个参数。\n对于 Ticker 表的例子，像 ORDER BY rowtime ASC, price DESC 这样的定义是有效的，但是 ORDER BY price, rowtime 或者 ORDER BY rowtime DESC, price ASC 是无效的。\n定义和测量 DEFINE 和 MEASURES 关键字的含义类似于简单 SQL 查询中的 WHERE 和 SELECT 子句。\nMEASURES 子句定义了匹配模式的输出中会包含哪些内容。它可以投射列和定义评估的表达式。产生的行数取决于输出模式的设置。\nDEFINE 子句指定了行必须满足的条件，以便将其分类到相应的模式变量。如果没有为模式变量定义条件，那么将使用一个默认条件，该条件对每条记录的评价为真。\n关于这些子句中可以使用的表达式的更详细解释，请看事件流导航部分。\n聚合 聚合可以在 DEFINE 和 MEASURES 子句中使用。同时支持内置和自定义的用户定义函数。\n聚合函数被应用于映射到匹配的行的每个子集。为了了解这些子集是如何被评估的，请看一下事件流导航部分。\n下面这个例子的任务是找到一个股票平均价格不低于某个阈值的最长时间段。它显示了 MATCH_RECOGNIZE 可以如何通过聚合来表达。这个任务可以用下面的查询来执行。\nSELECT * FROM Ticker MATCH_RECOGNIZE ( PARTITION BY symbol ORDER BY rowtime MEASURES FIRST(A.rowtime) AS start_tstamp, LAST(A.rowtime) AS end_tstamp, AVG(A.price) AS avgPrice ONE ROW PER MATCH AFTER MATCH SKIP PAST LAST ROW PATTERN (A+ B) DEFINE A AS AVG(A.price) \u0026lt; 15 ) MR; 给定这个查询和以下输入值：\nsymbol rowtime price tax ====== ==================== ======= ======= 'ACME' '01-Apr-11 10:00:00' 12 1 'ACME' '01-Apr-11 10:00:01' 17 2 'ACME' '01-Apr-11 10:00:02' 13 1 'ACME' '01-Apr-11 10:00:03' 16 3 'ACME' '01-Apr-11 10:00:04' 25 2 'ACME' '01-Apr-11 10:00:05' 2 1 'ACME' '01-Apr-11 10:00:06' 4 1 'ACME' '01-Apr-11 10:00:07' 10 2 'ACME' '01-Apr-11 10:00:08' 15 2 'ACME' '01-Apr-11 10:00:09' 25 2 'ACME' '01-Apr-11 10:00:10' 25 1 'ACME' '01-Apr-11 10:00:11' 30 1 只要事件的平均价格不超过 15，查询就会将事件累积为模式变量 A 的一部分。例如，这样的超限事件发生在 01-4-11 10:00:04。接下来的时期在 01-4-11 10:00:11 再次超过 15 的平均价格。因此，所述查询的结果将是：。\n symbol start_tstamp end_tstamp avgPrice ========= ================== ================== ============ ACME 01-APR-11 10:00:00 01-APR-11 10:00:03 14.5 ACME 01-APR-11 10:00:05 01-APR-11 10:00:10 13.5 注意 聚合可以应用于表达式，但只有当它们引用一个单一的模式变量时才可以。因此 SUM(A.price * A.tax)是有效的，但是 AVG(A.price * B.tax)不是。\n注意不支持 DISTINCT 聚合。\n定义一个模式 MATCH_RECOGNIZE 子句允许用户在事件流中搜索模式，使用一种强大的、富有表现力的语法，这种语法与广泛使用的正则表达式语法有些相似。\n每个模式都是由基本的构件构成的，称为模式变量，可以对其应用运算符（量化符和其他修饰符）。整个模式必须用括号括起来。\n一个模式的例子可以是这样的。\nPATTERN (A B+ C* D) 我们可以使用以下操作符。\n并集 \u0026ndash; 像(A B)这样的模式意味着 A 和 B 之间的相邻性是严格的，因此，中间不能有没有映射到 A 或 B 的行。 定量符\u0026ndash;修改可以映射到模式变量的行数。\n* — 0 or more rows + — 1 or more rows ? — 0 or 1 rows { n } — exactly n rows (n \u0026gt; 0) { n, } — n or more rows (n ≥ 0) { n, m } — between n and m (inclusive) rows (0 ≤ n ≤ m, 0 \u0026lt; m) { , m } — between 0 and m (inclusive) rows (m \u0026gt; 0) 注意 不支持可能产生空匹配的模式。这类模式的例子有 PATTERN (A*)、PATTERN (A?B*)、PATTERN (A{0,} B{0,} C*)等。\n贪婪和不情愿的量化器 每个量化器可以是贪婪的（默认行为）或勉强的。贪婪的量化器试图匹配尽可能多的记录，而不情愿的量化器试图匹配尽可能少的记录。\n为了说明两者的区别，我们可以查看下面的示例，在这个示例中，一个贪婪的量化器被应用于 B 变量。\nSELECT * FROM Ticker MATCH_RECOGNIZE( PARTITION BY symbol ORDER BY rowtime MEASURES C.price AS lastPrice ONE ROW PER MATCH AFTER MATCH SKIP PAST LAST ROW PATTERN (A B* C) DEFINE A AS A.price \u0026gt; 10, B AS B.price \u0026lt; 15, C AS C.price \u0026gt; 12 ) 鉴于我们有以下输入。\n symbol tax price rowtime ======= ===== ======== ===================== XYZ 1 10 2018-09-17 10:00:02 XYZ 2 11 2018-09-17 10:00:03 XYZ 1 12 2018-09-17 10:00:04 XYZ 2 13 2018-09-17 10:00:05 XYZ 1 14 2018-09-17 10:00:06 XYZ 2 16 2018-09-17 10:00:07 上述模式将产生以下输出。\n symbol lastPrice ======== =========== XYZ 16 同样的查询，将 B* 修改为 B* 吗，即 B*应该是不愿意的，会产生。\n symbol lastPrice ======== =========== XYZ 13 XYZ 16 模式变量 B 只匹配到价格为 12 的行，而不是吞掉价格为 12、13、14 的行。\n注意 对于一个模式的最后一个变量，不可能使用贪婪的量化符。因此，像（A B*）这样的模式是不允许的。这可以通过引入一个人为的状态（如 C）来轻松解决，这个状态具有 B 的否定条件，所以你可以使用这样的查询。\nPATTERN (A B* C) DEFINE A AS condA(), B AS condB(), C AS NOT condB() 注意 目前不支持可选的勉强量化符(A??或 A{0,1}?)。\n时间限制 特别是对于流式使用案例，通常要求一个模式在给定的时间内完成。这允许限制 Flink 必须在内部维护的整体状态大小，即使在贪婪的量化器的情况下。\n因此，Flink SQL 支持额外的（非标准 SQL）WITHIN 子句来定义模式的时间约束。该子句可以定义在 PATTERN 子句之后，并以毫秒为间隔进行解析。\n如果一个潜在匹配的第一个事件和最后一个事件之间的时间长于给定的值，这样的匹配将不会被追加到结果表中。\n注意 一般鼓励使用 within 子句，因为它有助于 Flink 进行有效的内存管理。一旦达到阈值，底层状态可以被修剪。\n注意 然而，WITHIN 子句不是 SQL 标准的一部分。推荐的处理时间限制的方式可能会在未来发生变化。\n在下面的查询示例中说明了 WITHIN 子句的使用。\nSELECT * FROM Ticker MATCH_RECOGNIZE( PARTITION BY symbol ORDER BY rowtime MEASURES C.rowtime AS dropTime, A.price - C.price AS dropDiff ONE ROW PER MATCH AFTER MATCH SKIP PAST LAST ROW PATTERN (A B* C) WITHIN INTERVAL \u0026#39;1\u0026#39; HOUR DEFINE B AS B.price \u0026gt; A.price - 10 C AS C.price \u0026lt; A.price - 10 ) 查询检测到在 1 小时的时间间隔内发生的价格下跌 10。\n假设该查询用于分析以下行情数据。\nsymbol rowtime price tax ====== ==================== ======= ======= 'ACME' '01-Apr-11 10:00:00' 20 1 'ACME' '01-Apr-11 10:20:00' 17 2 'ACME' '01-Apr-11 10:40:00' 18 1 'ACME' '01-Apr-11 11:00:00' 11 3 'ACME' '01-Apr-11 11:20:00' 14 2 'ACME' '01-Apr-11 11:40:00' 9 1 'ACME' '01-Apr-11 12:00:00' 15 1 'ACME' '01-Apr-11 12:20:00' 14 2 'ACME' '01-Apr-11 12:40:00' 24 2 'ACME' '01-Apr-11 13:00:00' 1 2 'ACME' '01-Apr-11 13:20:00' 19 1 查询将产生以下结果。\nsymbol dropTime dropDiff ====== ==================== ============= 'ACME' '01-Apr-11 13:00:00' 14 结果行表示价格从 15（在 4 月 1 日 12:00:00）下降到 1（在 4 月 1 日 13:00:00）。dropDiff 列包含了价格差。\n请注意，即使价格也以更高的数值下降，例如，下降 11（在 01-Apr-11 10:00:00 和 01-Apr-11 11:40:00 之间），这两个事件之间的时间差大于 1 小时。因此，它们不会产生匹配。\n输出模式 输出模式描述了每找到一个匹配的记录应该发出多少行。SQL 标准描述了两种模式。\nALL ROWS PER MATCH ONE ROW PER MATCH. 目前，唯一支持的输出模式是 ONE ROW PER MATCH，对于每一个找到的匹配项，总会产生一个输出汇总行。\n输出行的模式将是[分区列]+[措施列]按该特定顺序的连接。\n下面的例子显示了一个定义为查询的输出。\nSELECT * FROM Ticker MATCH_RECOGNIZE( PARTITION BY symbol ORDER BY rowtime MEASURES FIRST(A.price) AS startPrice, LAST(A.price) AS topPrice, B.price AS lastPrice ONE ROW PER MATCH PATTERN (A+ B) DEFINE A AS LAST(A.price, 1) IS NULL OR A.price \u0026gt; LAST(A.price, 1), B AS B.price \u0026lt; LAST(A.price) ) 对于以下输入行：\n symbol tax price rowtime ======== ===== ======== ===================== XYZ 1 10 2018-09-17 10:00:02 XYZ 2 12 2018-09-17 10:00:03 XYZ 1 13 2018-09-17 10:00:04 XYZ 2 11 2018-09-17 10:00:05 查询将产生以下输出。\n symbol startPrice topPrice lastPrice ======== ============ ========== =========== XYZ 10 13 11 模式识别是按符号列进行分区的。尽管在 MEASURES 子句中没有明确提到，但在结果的开头会添加分区列。\n模式导航 DEFINE 和 MEASURES 子句允许在（可能）匹配模式的行列表中进行导航。\n本节将讨论这种用于声明条件或产生输出结果的导航。\n模式变量引用 模式变量引用允许引用映射到 DEFINE 或 MEASURES 子句中特定模式变量的一组行。\n例如，表达式 A.price 描述了迄今为止映射到 A 的一组行，再加上当前行，如果我们尝试将当前行与 A 进行匹配。如果 DEFINE/MEASURES 子句中的表达式需要单行（例如 A.price 或 A.price\u0026gt;10），则选择属于相应集合的最后一个值。\n如果没有指定模式变量（例如 SUM(price)），表达式会引用默认的模式变量*，它引用模式中的所有变量。换句话说，它创建了一个迄今为止映射到任何变量的所有行加上当前行的列表。\n例子\n要想了解更透彻的例子，可以看看下面的模式和相应的条件。\nPATTERN (A B+) DEFINE A AS A.price \u0026gt; 10, B AS B.price \u0026gt; A.price AND SUM(price) \u0026lt; 100 AND SUM(B.price) \u0026lt; 80 下表描述了如何评估每个传入事件的这些条件。\n该表由以下几栏组成：\n# - the row identifier that uniquely identifies an incoming row in the lists [A.price]/[B.price]/[price]. price - the price of the incoming row. [A.price]/[B.price]/[price] - describe lists of rows which are used in the DEFINE clause to evaluate conditions. Classifier - the classifier of the current row which indicates the pattern variable the row is mapped to. A.price/B.price/SUM(price)/SUM(B.price) - describes the result after those expressions have been evaluated. #\tprice\tClassifier\t[A.price]\t[B.price]\t[price]\tA.price\tB.price\tSUM(price)\tSUM(B.price) #1\t10\t-\u0026gt; A\t#1\t-\t-\t10\t-\t-\t- #2\t15\t-\u0026gt; B\t#1\t#2\t#1, #2\t10\t15\t25\t15 #3\t20\t-\u0026gt; B\t#1\t#2, #3\t#1, #2, #3\t10\t20\t45\t35 #4\t31\t-\u0026gt; B\t#1\t#2, #3, #4\t#1, #2, #3, #4\t10\t31\t76\t66 #5\t35\t#1\t#2, #3, #4, #5\t#1, #2, #3, #4, #5\t10\t35\t111\t101 从表中可以看出，第一行被映射到模式变量 A，随后的行被映射到模式变量 B，但是最后一行不满足 B 的条件，因为所有映射行的 SUM(价格)和 B 中所有行的总和超过了指定的阈值。\n逻辑偏移 逻辑偏移可以在映射到特定模式变量的事件中进行导航。这可以用两个相应的函数来表示。\n偏移函数 描述 LAST(variable.field, n) 返回事件中被映射到变量第 n 个最后元素的字段的值。从映射到的最后一个元素开始计算。\nFIRST(variable.field, n) 返回事件中被映射到变量第 n 个元素的字段值。从映射到的第一个元素开始计算。\n示例\n为了更透彻的举例，可以看看下面的模式和相应的条件。\nPATTERN (A B+) DEFINE A AS A.price \u0026gt; 10, B AS (LAST(B.price, 1) IS NULL OR B.price \u0026gt; LAST(B.price, 1)) AND (LAST(B.price, 2) IS NULL OR B.price \u0026gt; 2 * LAST(B.price, 2)) 下表描述了如何评估每个传入事件的这些条件。\n该表由以下几栏组成：\nprice - the price of the incoming row. Classifier - the classifier of the current row which indicates the pattern variable the row is mapped to. LAST(B.price, 1)/LAST(B.price, 2) - describes the result after those expressions have been evaluated. price\tClassifier\tLAST(B.price, 1)\tLAST(B.price, 2)\tComment 10\t-\u0026gt; A\t15\t-\u0026gt; B\tnull\tnull\tNotice that LAST(A.price, 1) is null because there is still nothing mapped to B. 20\t-\u0026gt; B\t15\tnull\t31\t-\u0026gt; B\t20\t15\t35\t31\t20\tNot mapped because 35 \u0026lt; 2 * 20. 使用默认的模式变量与逻辑偏移量也可能是有意义的。\n在这种情况下，偏移量会考虑到目前为止映射的所有行。\nPATTERN (A B? C) DEFINE B AS B.price \u0026lt; 20, C AS LAST(price, 1) \u0026lt; C.price price\tClassifier\tLAST(price, 1)\tComment 10\t-\u0026gt; A\t15\t-\u0026gt; B\t20\t-\u0026gt; C\t15\tLAST(price, 1) is evaluated as the price of the row mapped to the B variable. 如果第二行没有映射到 B 变量，我们会有以下结果。\nprice\tClassifier\tLAST(price, 1)\tComment 10\t-\u0026gt; A\t20\t-\u0026gt; C\t10\tLAST(price, 1) is evaluated as the price of the row mapped to the A variable. 也可以在 first/last 函数的第一个参数中使用多个模式变量引用。这样，就可以写一个访问多列的表达式。但是，所有这些表达式必须使用同一个模式变量。换句话说，LAST/FIRST 函数的值必须在单行中计算。\n因此，可以使用 LAST(A.price * A.tax)，但不允许使用 LAST(A.price * B.tax)这样的表达式。\n匹配后策略 AFTER MATCH SKIP 子句指定了在找到完整匹配后，在哪里开始一个新的匹配过程。\n有四种不同的策略。\nSKIP PAST LAST ROW - 在当前匹配的最后一行之后的下一行恢复模式匹配。 SKIP TO NEXT ROW - 从匹配起始行后的下一行开始继续搜索新的匹配。 SKIP TO LAST 变量\u0026ndash;在映射到指定模式变量的最后一行恢复模式匹配。 SKIP TO FIRST 变量\u0026ndash;在被映射到指定模式变量的第一行恢复模式匹配。 这也是一种指定一个事件可以属于多少个匹配的方式。例如，使用 SKIP PAST LAST ROW 策略，每个事件最多只能属于一个匹配。\n例子\n为了更好地理解这些策略之间的差异，可以看一下下面的例子。\n对于以下输入行。\n symbol tax price rowtime ======== ===== ======= ===================== XYZ 1 7 2018-09-17 10:00:01 XYZ 2 9 2018-09-17 10:00:02 XYZ 1 10 2018-09-17 10:00:03 XYZ 2 5 2018-09-17 10:00:04 XYZ 2 17 2018-09-17 10:00:05 XYZ 2 14 2018-09-17 10:00:06 我们用不同的策略评估以下查询。\nSELECT * FROM Ticker MATCH_RECOGNIZE( PARTITION BY symbol ORDER BY rowtime MEASURES SUM(A.price) AS sumPrice, FIRST(rowtime) AS startTime, LAST(rowtime) AS endTime ONE ROW PER MATCH [AFTER MATCH STRATEGY] PATTERN (A+ C) DEFINE A AS SUM(A.price) \u0026lt; 30 ) 查询返回映射到 A 的所有行的价格总和，以及整体匹配的第一个和最后一个时间戳。\n根据使用的 AFTER MATCH 策略，查询会产生不同的结果。\nAFTER MATCH SKIP PAST ROW(跳过最后一行)\n symbol sumPrice startTime endTime ======== ========== ===================== ===================== XYZ 26 2018-09-17 10:00:01 2018-09-17 10:00:04 XYZ 17 2018-09-17 10:00:05 2018-09-17 10:00:06 第一个结果与 1 号，2 号，3 号，4 号行相匹配。\n第二个结果与#5, #6 行相匹配。\n匹配后跳转到下一行。\n symbol sumPrice startTime endTime ======== ========== ===================== ===================== XYZ 26 2018-09-17 10:00:01 2018-09-17 10:00:04 XYZ 24 2018-09-17 10:00:02 2018-09-17 10:00:05 XYZ 15 2018-09-17 10:00:03 2018-09-17 10:00:05 XYZ 22 2018-09-17 10:00:04 2018-09-17 10:00:06 XYZ 17 2018-09-17 10:00:05 2018-09-17 10:00:06 同样，第一个结果对 1 号、2 号、3 号、4 号行进行匹配。\n与之前的策略相比，接下来的匹配中又包含了 2 号行的匹配。因此，第二个结果与行#2，#3，#4，#5 相匹配。\n第三个结果与 3 号，4 号，5 号行相匹配。\n第四个结果与行#4，#5，#6 相匹配。\n最后一个结果与行#5，#6 匹配。\n匹配后跳转到最后一行。\n symbol sumPrice startTime endTime ======== ========== ===================== ===================== XYZ 26 2018-09-17 10:00:01 2018-09-17 10:00:04 XYZ 15 2018-09-17 10:00:03 2018-09-17 10:00:05 XYZ 22 2018-09-17 10:00:04 2018-09-17 10:00:06 XYZ 17 2018-09-17 10:00:05 2018-09-17 10:00:06 同样，第一个结果针对 1 号、2 号、3 号、4 号行进行匹配。\n与之前的策略相比，接下来的匹配只包括 3 号行（映射到 A 行），再次进行匹配。因此，第二个结果与行#3，#4，#5 相匹配。\n第三个结果与#4，#5，#6 行相匹配。\n最后一个结果与行#5,#6 匹配，因此第三个结果与行#4,#5,#6 匹配。\n匹配后跳转到第一行 A。\n这个组合会产生一个运行时异常，因为我们总是试图在上一个比赛开始的地方开始一个新的比赛。这将产生一个无限循环，因此是被禁止的。\n我们必须记住，在使用 SKIP TO FIRST/LAST 变量策略的情况下，有可能没有记录映射到该变量上（例如模式 A*）。在这种情况下，将抛出一个运行时异常，因为标准要求有一条有效的记录来继续匹配。\n时间属性 为了在 MATCH_RECOGNIZE 之上应用一些后续的查询，可能需要使用时间属性。为了选择这些属性，有两个函数可用。\n功能描述 MATCH_ROWTIME() 返回被映射到给定模式的最后一行的时间戳。\n所得到的属性是一个 rowtime 属性，它可以被用于后续的基于时间的操作，如区间连接和组窗口或窗口聚合。\nMATCH_PROCTIME() 返回一个 proctime 属性，该属性可用于后续基于时间的操作，如区间连接和组窗口或窗口聚合。\n控制内存消耗 在编写 MATCH_RECOGNIZE 查询时，内存消耗是一个重要的考虑因素，因为潜在的匹配空间是以类似广度优先的方式建立的。考虑到这一点，必须确保模式能够完成。最好是有合理数量的行映射到匹配中，因为它们必须适应内存。\n例如，模式不能有一个没有上限的量化器，接受每一行。这样的模式可以是这样的。\nPATTERN (A B+ C) DEFINE A as A.price \u0026gt; 10, C as C.price \u0026gt; 20 该查询将把每一条进入的记录映射到 B 变量上，因此永远不会结束。这个查询可以通过否定 C 的条件来解决。\nPATTERN (A B+ C) DEFINE A as A.price \u0026gt; 10, B as B.price \u0026lt;= 20, C as C.price \u0026gt; 20 或者通过使用勉强的定量器。\nPATTERN (A B+? C) DEFINE A as A.price \u0026gt; 10, C as C.price \u0026gt; 20 注意 请注意，MATCH_RECOGNIZE 子句不使用配置的状态保留时间。人们可能希望使用 WITHIN 子句来达到这个目的。\n已知限制 Flink 对 MATCH_RECOGNIZE 子句的实现是一项持续的努力，目前还不支持 SQL 标准的一些功能。\n不支持的功能包括\n模式表达式。 模式组\u0026ndash;这意味着，例如量化符不能应用于模式的子序列。因此，（A (B C)+）不是有效的模式。 改变\u0026ndash;像 PATTERN((A B | C D) E)这样的模式，这意味着在寻找 E 行之前必须先找到一个子序列 A B 或 C D。 PERMUTE 运算符\u0026ndash;相当于它所应用的所有变量的排列组合，例如 PATTERN(PERMUTE (A, B, C))=PATTERN(A B C | A C B | B A C | B A C | C B A | C B A)。 锚 - ^, $，表示一个分区的开始/结束，这些在流媒体环境中没有意义，将不被支持。 排除 - PATTERN ({- A -} B) 意味着 A 将被查找，但不会参与输出。这只对 ALL ROWS PER MATCH 模式有效。 不情愿的可选量化符\u0026ndash;PATTERN A?? 只支持贪婪的可选量化符。 ALL ROWS PER MATCH 输出模式\u0026ndash;它为每一条参与创建发现匹配的记录产生一条输出行。这也意味着。 MEASURES 子句唯一支持的语义是 FINAL。 CLASSIFIER 函数，该函数返回某行被映射到的模式变量，目前还不支持。 SUBSET - 允许创建模式变量的逻辑组，并在 DEFINE 和 MEASURES 子句中使用这些组。 物理偏移\u0026ndash;PREV/NEXT，它索引所有看到的事件，而不是只索引那些被映射到模式变量的事件（如逻辑偏移情况）。 提取时间属性\u0026ndash;目前没有可能为后续基于时间的操作获取时间属性。 MATCH_RECOGNIZE 只支持 SQL。在 Table API 中没有等价物。 聚合。 不支持不同的聚合。\n原文链接: https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/streaming/match_recognize.html\n"},"name":"检测表中的模式","published":"2020-08-22T00:00:00+08:00","summary":"Detecting Patterns in Tables","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-08-22-detecting-patterns-in-tables/"}