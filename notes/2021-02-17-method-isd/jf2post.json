{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"content":{"html":"\u003cp\u003e在我的上一篇文章中，我又一次为从 CORE 中增强类的方法而苦恼。这种挣扎完全没有必要，因为我并没有用增加的方法改变对象的状态。对于做更高级的东西，我可能不得不这样做。把手伸进 Raku 的内部这么深，我可能会把自己烫伤。既然我想做的是把我的代码绑在编译器的变化上，反正我可能会全身心地投入到 nqp-land 中去。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \\j = 1 | 2 | 3;\ndd j;\nuse nqp;\n.say for nqp::getattr(j, Junction, '$!eigenstates');\n# OUTPUT: any(1, 2, 3)\n          1\n          2\n          3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们可以使用 nqp 来获取私有属性，而不需要添加任何方法。这就有点儿不伦不类了。所以，让我们用一个伪方法来做一些 deboilerplating。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub pry(Mu $the-object is raw) {\n    use InterceptAllMethods;\n\n    class Interceptor {\n        has Mu $!the-object;\n        method ^find_method(Mu \\type, Str $name) {\n            my method (Mu \\SELF:) is raw {\n                use nqp;\n                my $the-object := nqp::getattr(SELF, Interceptor, '$!the-object');\n                nqp::getattr($the-object, $the-object.WHAT, '$!' ~ $name)\n            }\n        }\n    }\n\n    use nqp;\n    nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object);\n}\n\n.say for j.\u0026amp;pry.eigenstates;\n# OUTPUT: 1\n          2\n          3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通过 InterceptAllMethods，lizmat 改变了类关键字的行为，允许我们提供一个 FALLBACK-method 来捕获任何方法，包括从 Mu 继承的方法。这反过来又允许 pry 返回的对象将任何方法调用转移到一个自定义的方法。在这个方法中，我们可以对 \u003ccode\u003e.\u0026amp;pry\u003c/code\u003e 被调用的对象做任何我们想做的事情。\u003c/p\u003e\n\u003cp\u003e由于我们的特殊对象会拦截任何调用，甚至是 Mu 的调用，我们需要找到另一种方法来调用 \u003ccode\u003e.new\u003c/code\u003e。由于 \u003ccode\u003e.^\u003c/code\u003e 不是 \u003ccode\u003e.\u003c/code\u003e 的特殊形式，我们可以用它来获得对类方法的访问。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub interceptor(Method $the-method){\n    use InterceptAllMethods;\n    use nqp;\n\n    sub (Mu $the-object is raw) {\n        my class Interceptor {\n            has Mu $!the-object;\n            has Code $!the-method;\n\n            method ^find_method(Mu \\type, Mu:D $name) {\n                my method (Mu \\SELF: |c) is raw {\n                    $!the-method.($!the-object, $name, |c)\n                }\n            }\n            method ^introspect(Mu \\type, Mu \\obj) {\n                my method call-it() is raw {\n                    $!the-object\n                }\n                obj.\u0026amp;call-it;\n            }\n            method ^new(Mu \\type, $the-object!, $the-method) {\n                nqp::p6bindattrinvres(\n                        nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object),\n                        Interceptor, '$!the-method', $the-method)\n            }\n        }\n\n            # nqp::p6bindattrinvres(\n                #     nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object),\n                #   Interceptor, '$!the-method', $the-method);\n        Interceptor.^new($the-object, $the-method)\n    }\n}\n\nmy \u0026amp;first-defined = interceptor(\n    my method (Positional \\SELF: $name) {\n        for SELF.flat -\u0026gt; $e {\n            with $e.\u0026quot;$name\u0026quot;(|%_) {\n                .return\n            }\n        }\n        Nil\n    }\n);\n\nmy $file = \u0026lt;file1.txt file2.txt file3.txt nohup.out\u0026gt;».IO.\u0026amp;first-defined.open(:r);\ndd $file;\n# OUTPUT: Handle $file = IO::Handle.new(path =\u0026gt; IO::Path.new(\u0026quot;nohup.out\u0026quot;, :SPEC(IO::Spec::Unix), :CWD(\u0026quot;/home/dex/projects/raku/tmp\u0026quot;)), chomp =\u0026gt; Bool::True, nl-in =\u0026gt; $[\u0026quot;\\n\u0026quot;, \u0026quot;\\r\\n\u0026quot;], nl-out =\u0026gt; \u0026quot;\\n\u0026quot;, encoding =\u0026gt; \u0026quot;utf8\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003esub \u003ccode\u003einterceptor\u003c/code\u003e 接受一个方法并返回一个 sub。如果这个 sub 像方法一样被调用，它将把要被调用的方法的名称和调用者转发给一个自定义方法。当 \u003ccode\u003e.\u0026amp;first-defined\u003c/code\u003e 被调用时，会返回一个特殊的对象。让我们来看看它是什么。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \\uhhh-special = \u0026lt;a b c\u0026gt;.\u0026amp;first-defined;\ndd uhhh-special.^introspect(uhhh-special);\n# OUTPUT: ($(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;), method \u0026lt;anon\u0026gt; (Positional \\SELF: $name, *%_) { #`(Method|93927752146784) ... })\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们必须给 \u003ccode\u003e.^introspect\u003c/code\u003e 一个我们想看的对象，因为它的调用者是类 Interceptor 的类型对象。\u003c/p\u003e\n\u003cp\u003e目前，我还不知道有什么办法（毕竟，我知道的只是足够多的东西，真的很危险。这是不幸的，因为 lizmat 决定重载关键字 \u003ccode\u003eclass\u003c/code\u003e，而不是用不同的名字导出特殊的 \u003ccode\u003eMetamodel::ClassHOW\u003c/code\u003e。如果我们不想或不能有外部依赖，我们可以使用 MOP 来创建我们的类型对象。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eclass InterceptHOW is Metamodel::ClassHOW {\n    method publish_method_cache(|) { }\n}\n\nsub ipry(Mu $the-object is raw) {\n    my \\Interceptor = InterceptHOW.new_type(:name\u0026lt;Interceptor\u0026gt;);\n    Interceptor.^add_attribute(Attribute.new(:name\u0026lt;$!the-object\u0026gt;, :type(Mu), :package(Interceptor)));\n    Interceptor.^add_meta_method('find_method',\n        my method find_method(Mu \\type, Str $name) {\n            # say „looking for $name“;\n            my method (Mu \\SELF:) is raw {\n                use nqp;\n                my $the-object := nqp::getattr(SELF, Interceptor, '$!the-object');\n                nqp::getattr($the-object, $the-object.WHAT, '$!' ~ $name)\n            }\n    });\n    Interceptor.^compose;\n\n    use nqp;\n    nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e当我写这篇文章的时候，我发现 \u003ccode\u003e.^add_meta_method\u003c/code\u003e 只有在提供给它的方法的第一个参数的名字和 \u003ccode\u003eStr\u003c/code\u003e 相同的时候才会工作。起初，我尝试了一个匿名方法，它最终出现在 \u003ccode\u003e.^meta_method_table\u003c/code\u003e 中，但从未被调用。我想这个 bug 其实并不重要，因为这个元方法根本没有被记录下来。如果我玩火，我没有权利抱怨烧伤。你会在野外的 \u003ccode\u003eActions.nqp\u003c/code\u003e 中发现这个方法。Class 关键字并没有什么神奇的作用。Rakudo 只是使用 MOP 来构造类型对象。\u003c/p\u003e\n\u003cp\u003e我们不能在 Raku 中重载赋值操作符。这其实并不需要，因为赋值是通过调用一个名为 STORE 的方法来实现的。由于我们得到了对 dispatch 的完全控制，我们可以拦截任何方法调用，包括一连串的方法调用。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emulti sub methodify(%h, :$deeply!) {\n    sub interceptor(%h, $parent = Nil){\n        use InterceptAllMethods;\n        use nqp;\n\n        class Interceptor is Callable {\n            has Mu $!the-object;\n            has Mu @!stack;\n\n            method ^find_method(Mu \\type, Mu:D $name) {\n                my method (Mu \\SELF: |c) is raw {\n                    my @new-stack = @!stack;\n                    my $the-object = $!the-object;\n\n                    if $name eq 'STORE' {\n                        # workaround for rakudobug#4203\n                        $the-object{||@new-stack.head(*-1)}:delete if $the-object{||@new-stack.head(*-1)}:exists;\n\n                        $the-object{||@new-stack} = c;\n                        return-rw c\n                    } else {\n                        @new-stack.push: $name;\n                        my \\nextlevel = SELF.^new($!the-object, @new-stack, $name);\n                        nextlevel\n                    }\n                }\n            }\n            method ^introspect(Mu \\type, Mu \\obj) {\n                my method call-it() is raw {\n                    $!the-object, @!stack\n                }\n                obj.\u0026amp;call-it;\n            }\n            method ^new(Mu \\type, $the-object!, @new-stack?, $name?) {\n                $name\n                    ?? nqp::p6bindattrinvres(\n                        nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object),\n                        Interceptor, '@!stack', @new-stack)\n                    !! nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object)\n                }\n        }\n\n        Interceptor.^new(%h)\n    }\n\n    interceptor(%h)\n}\n\nmy %h2;\nmy $o2 = methodify(%h2, :deeply);\n$o2.a.b = 42;\ndd %h2;\n$o2.a.b.c = \u0026lt;answer\u0026gt;;\ndd %h2;\nsay $o2.a.b.c;\n# OUTPUT: Hash %h2 = {:a(${:b(\\(42))})}\n          Hash %h2 = {:a(${:b(${:c(\\(\u0026quot;answer\u0026quot;))})})}\n          This type cannot unbox to a native string: P6opaque, Interceptor\n            in block \u0026lt;unit\u0026gt; at /home/dex/projects/raku/any-chain.raku line 310\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e每当我们调用一个方法时，都会创建一个新的 Interceptor 实例，它存储了前一个方法的名称。这样我们就可以沿着方法调用链移动。由于赋值调用 STORE，我们可以将赋值转移到我们用作实际数据结构的 Hash 中。唉，检索值就不一样了，因为 Raku 不区分方法调用和 FETCH。在这里，龙比我强。我还是包含了这个一半失败的尝试，因为我对 slippy 半列表有很好的利用。这需要使用 \u003ccode\u003ev6.e.preview\u003c/code\u003e，让我踩到了一个 bug。可能还有更多这样的情况。所以请使用同样的，这样我们就可以在 \u003ccode\u003e.e\u003c/code\u003e 发布到野外之前，把所有的野兽都杀掉。\u003c/p\u003e\n\u003cp\u003e能够完全控制方法调用链将是一件好事。也许我们可以用 RakuAST 来做到这一点。\u003c/p\u003e\n\u003cp\u003e有了这些已经可以工作的东西，我们可以做一些有趣的事情。那些烦人的异常总是在拖我们的后腿。我们可以用 \u003ccode\u003etry\u003c/code\u003e 来化解它们，但那会破坏一个方法调用链。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003econstant no-argument-given = Mu.new;\nsub try(Mu $obj is raw, Mu $alternate-value = no-argument-given) {\n    interceptor(my method (Mu \\SELF: $name, |c) {\n        my $o = SELF;\n        my \\m = $o.^lookup($name) orelse {\n            my $bt = Backtrace.new;\n            my $idx = $bt.next-interesting-index($bt.next-interesting-index + 1);\n            (X::Method::NotFound.new(:method($name), :typename($o.^name)) but role :: { method vault-backtrace { False }}).throw(Backtrace.new($idx + 1));\n        }\n\n        try {\n            $o = $o.\u0026quot;$name\u0026quot;(|c);\n        }\n \n        $! ~~ Exception\n            ?? $alternate-value.WHICH eqv no-argument-given.WHICH\n                ?? $o\n                !! $alternate-value\n            !! $o\n    }).($obj)\n}\n\nclass C {\n    has $.greeting;\n    method might-throw { die \u0026quot;Not today love!\u0026quot; }\n    method greet { say $.greeting }\n}\n\nC.new(greeting =\u0026gt; ‚Let's make love!‘).\u0026amp;try.might-throw.greet;\n# OUTPUT: Let's make love!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e伪方法 try 将会化解任何异常，并允许继续调用 C 语言的方法。我必须用一个特殊的值来标记没有可选的参数 \u003ccode\u003e$alternate-value\u003c/code\u003e，因为它实际上可能会把异常对象变成 \u003ccode\u003eNil\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e我很肯定还有很多这样的小帮手在等着我们去发现。未来可能会有一个模块，希望能帮助 Raku 成为一个好的\u003ca href=\"https://ftp.fau.de/fosdem/2021/D.perl/programming_lang_for_free_software.webm\"\u003e编程语言\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://gfldex.wordpress.com/2021/02/17/method-ish/\"\u003ehttps://gfldex.wordpress.com/2021/02/17/method-ish/\u003c/a\u003e\u003c/p\u003e\n","text":"在我的上一篇文章中，我又一次为从 CORE 中增强类的方法而苦恼。这种挣扎完全没有必要，因为我并没有用增加的方法改变对象的状态。对于做更高级的东西，我可能不得不这样做。把手伸进 Raku 的内部这么深，我可能会把自己烫伤。既然我想做的是把我的代码绑在编译器的变化上，反正我可能会全身心地投入到 nqp-land 中去。\nmy \\j = 1 | 2 | 3; dd j; use nqp; .say for nqp::getattr(j, Junction, '$!eigenstates'); # OUTPUT: any(1, 2, 3) 1 2 3 我们可以使用 nqp 来获取私有属性，而不需要添加任何方法。这就有点儿不伦不类了。所以，让我们用一个伪方法来做一些 deboilerplating。\nsub pry(Mu $the-object is raw) { use InterceptAllMethods; class Interceptor { has Mu $!the-object; method ^find_method(Mu \\type, Str $name) { my method (Mu \\SELF:) is raw { use nqp; my $the-object := nqp::getattr(SELF, Interceptor, '$!the-object'); nqp::getattr($the-object, $the-object.WHAT, '$!' ~ $name) } } } use nqp; nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object); } .say for j.\u0026amp;pry.eigenstates; # OUTPUT: 1 2 3 通过 InterceptAllMethods，lizmat 改变了类关键字的行为，允许我们提供一个 FALLBACK-method 来捕获任何方法，包括从 Mu 继承的方法。这反过来又允许 pry 返回的对象将任何方法调用转移到一个自定义的方法。在这个方法中，我们可以对 .\u0026amp;pry 被调用的对象做任何我们想做的事情。\n由于我们的特殊对象会拦截任何调用，甚至是 Mu 的调用，我们需要找到另一种方法来调用 .new。由于 .^ 不是 . 的特殊形式，我们可以用它来获得对类方法的访问。\nsub interceptor(Method $the-method){ use InterceptAllMethods; use nqp; sub (Mu $the-object is raw) { my class Interceptor { has Mu $!the-object; has Code $!the-method; method ^find_method(Mu \\type, Mu:D $name) { my method (Mu \\SELF: |c) is raw { $!the-method.($!the-object, $name, |c) } } method ^introspect(Mu \\type, Mu \\obj) { my method call-it() is raw { $!the-object } obj.\u0026amp;call-it; } method ^new(Mu \\type, $the-object!, $the-method) { nqp::p6bindattrinvres( nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object), Interceptor, '$!the-method', $the-method) } } # nqp::p6bindattrinvres( # nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object), # Interceptor, '$!the-method', $the-method); Interceptor.^new($the-object, $the-method) } } my \u0026amp;first-defined = interceptor( my method (Positional \\SELF: $name) { for SELF.flat -\u0026gt; $e { with $e.\u0026quot;$name\u0026quot;(|%_) { .return } } Nil } ); my $file = \u0026lt;file1.txt file2.txt file3.txt nohup.out\u0026gt;».IO.\u0026amp;first-defined.open(:r); dd $file; # OUTPUT: Handle $file = IO::Handle.new(path =\u0026gt; IO::Path.new(\u0026quot;nohup.out\u0026quot;, :SPEC(IO::Spec::Unix), :CWD(\u0026quot;/home/dex/projects/raku/tmp\u0026quot;)), chomp =\u0026gt; Bool::True, nl-in =\u0026gt; $[\u0026quot;\\n\u0026quot;, \u0026quot;\\r\\n\u0026quot;], nl-out =\u0026gt; \u0026quot;\\n\u0026quot;, encoding =\u0026gt; \u0026quot;utf8\u0026quot;) sub interceptor 接受一个方法并返回一个 sub。如果这个 sub 像方法一样被调用，它将把要被调用的方法的名称和调用者转发给一个自定义方法。当 .\u0026amp;first-defined 被调用时，会返回一个特殊的对象。让我们来看看它是什么。\nmy \\uhhh-special = \u0026lt;a b c\u0026gt;.\u0026amp;first-defined; dd uhhh-special.^introspect(uhhh-special); # OUTPUT: ($(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;), method \u0026lt;anon\u0026gt; (Positional \\SELF: $name, *%_) { #`(Method|93927752146784) ... }) 我们必须给 .^introspect 一个我们想看的对象，因为它的调用者是类 Interceptor 的类型对象。\n目前，我还不知道有什么办法（毕竟，我知道的只是足够多的东西，真的很危险。这是不幸的，因为 lizmat 决定重载关键字 class，而不是用不同的名字导出特殊的 Metamodel::ClassHOW。如果我们不想或不能有外部依赖，我们可以使用 MOP 来创建我们的类型对象。\nclass InterceptHOW is Metamodel::ClassHOW { method publish_method_cache(|) { } } sub ipry(Mu $the-object is raw) { my \\Interceptor = InterceptHOW.new_type(:name\u0026lt;Interceptor\u0026gt;); Interceptor.^add_attribute(Attribute.new(:name\u0026lt;$!the-object\u0026gt;, :type(Mu), :package(Interceptor))); Interceptor.^add_meta_method('find_method', my method find_method(Mu \\type, Str $name) { # say „looking for $name“; my method (Mu \\SELF:) is raw { use nqp; my $the-object := nqp::getattr(SELF, Interceptor, '$!the-object'); nqp::getattr($the-object, $the-object.WHAT, '$!' ~ $name) } }); Interceptor.^compose; use nqp; nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object); } 当我写这篇文章的时候，我发现 .^add_meta_method 只有在提供给它的方法的第一个参数的名字和 Str 相同的时候才会工作。起初，我尝试了一个匿名方法，它最终出现在 .^meta_method_table 中，但从未被调用。我想这个 bug 其实并不重要，因为这个元方法根本没有被记录下来。如果我玩火，我没有权利抱怨烧伤。你会在野外的 Actions.nqp 中发现这个方法。Class 关键字并没有什么神奇的作用。Rakudo 只是使用 MOP 来构造类型对象。\n我们不能在 Raku 中重载赋值操作符。这其实并不需要，因为赋值是通过调用一个名为 STORE 的方法来实现的。由于我们得到了对 dispatch 的完全控制，我们可以拦截任何方法调用，包括一连串的方法调用。\nmulti sub methodify(%h, :$deeply!) { sub interceptor(%h, $parent = Nil){ use InterceptAllMethods; use nqp; class Interceptor is Callable { has Mu $!the-object; has Mu @!stack; method ^find_method(Mu \\type, Mu:D $name) { my method (Mu \\SELF: |c) is raw { my @new-stack = @!stack; my $the-object = $!the-object; if $name eq 'STORE' { # workaround for rakudobug#4203 $the-object{||@new-stack.head(*-1)}:delete if $the-object{||@new-stack.head(*-1)}:exists; $the-object{||@new-stack} = c; return-rw c } else { @new-stack.push: $name; my \\nextlevel = SELF.^new($!the-object, @new-stack, $name); nextlevel } } } method ^introspect(Mu \\type, Mu \\obj) { my method call-it() is raw { $!the-object, @!stack } obj.\u0026amp;call-it; } method ^new(Mu \\type, $the-object!, @new-stack?, $name?) { $name ?? nqp::p6bindattrinvres( nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object), Interceptor, '@!stack', @new-stack) !! nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object) } } Interceptor.^new(%h) } interceptor(%h) } my %h2; my $o2 = methodify(%h2, :deeply); $o2.a.b = 42; dd %h2; $o2.a.b.c = \u0026lt;answer\u0026gt;; dd %h2; say $o2.a.b.c; # OUTPUT: Hash %h2 = {:a(${:b(\\(42))})} Hash %h2 = {:a(${:b(${:c(\\(\u0026quot;answer\u0026quot;))})})} This type cannot unbox to a native string: P6opaque, Interceptor in block \u0026lt;unit\u0026gt; at /home/dex/projects/raku/any-chain.raku line 310 每当我们调用一个方法时，都会创建一个新的 Interceptor 实例，它存储了前一个方法的名称。这样我们就可以沿着方法调用链移动。由于赋值调用 STORE，我们可以将赋值转移到我们用作实际数据结构的 Hash 中。唉，检索值就不一样了，因为 Raku 不区分方法调用和 FETCH。在这里，龙比我强。我还是包含了这个一半失败的尝试，因为我对 slippy 半列表有很好的利用。这需要使用 v6.e.preview，让我踩到了一个 bug。可能还有更多这样的情况。所以请使用同样的，这样我们就可以在 .e 发布到野外之前，把所有的野兽都杀掉。\n能够完全控制方法调用链将是一件好事。也许我们可以用 RakuAST 来做到这一点。\n有了这些已经可以工作的东西，我们可以做一些有趣的事情。那些烦人的异常总是在拖我们的后腿。我们可以用 try 来化解它们，但那会破坏一个方法调用链。\nconstant no-argument-given = Mu.new; sub try(Mu $obj is raw, Mu $alternate-value = no-argument-given) { interceptor(my method (Mu \\SELF: $name, |c) { my $o = SELF; my \\m = $o.^lookup($name) orelse { my $bt = Backtrace.new; my $idx = $bt.next-interesting-index($bt.next-interesting-index + 1); (X::Method::NotFound.new(:method($name), :typename($o.^name)) but role :: { method vault-backtrace { False }}).throw(Backtrace.new($idx + 1)); } try { $o = $o.\u0026quot;$name\u0026quot;(|c); } $! ~~ Exception ?? $alternate-value.WHICH eqv no-argument-given.WHICH ?? $o !! $alternate-value !! $o }).($obj) } class C { has $.greeting; method might-throw { die \u0026quot;Not today love!\u0026quot; } method greet { say $.greeting } } C.new(greeting =\u0026gt; ‚Let's make love!‘).\u0026amp;try.might-throw.greet; # OUTPUT: Let's make love! 伪方法 try 将会化解任何异常，并允许继续调用 C 语言的方法。我必须用一个特殊的值来标记没有可选的参数 $alternate-value，因为它实际上可能会把异常对象变成 Nil。\n我很肯定还有很多这样的小帮手在等着我们去发现。未来可能会有一个模块，希望能帮助 Raku 成为一个好的编程语言。\n原文链接: https://gfldex.wordpress.com/2021/02/17/method-ish/\n"},"name":"Method-ish","published":"2021-02-28T00:00:00+08:00","summary":"Method-ish","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-02-17-method-isd/"}