{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"content":{"html":"\u003cp\u003e## A Mutable Grammar For Raku\u003c/p\u003e\n\u003ch3 id=\"rules\"\u003eRules\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eRules\u003c/code\u003e 就像 perl5的 \u003ccode\u003eregexes\u003c/code\u003e, 并且更好。它们像子例程和方法那样申明, 并且还能调用其它 rules\u003c/p\u003e\n\u003cp\u003e下面是一个解析 Raku 基本变量名的例子：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003egrammar\u003c/span\u003e \u003cspan class=\"nb\"\u003eRaku\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e  \n    \u003cspan class=\"c1\"\u003e# token alpha 是一个预定义好的 rule\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003etoken\u003c/span\u003e identifier \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e           \n\u003c/span\u003e\u003cspan class=\"sr\"\u003e       \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nb\"\u003ealpha\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"se\"\u003e\\w\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"sr\"\u003e     \n\u003c/span\u003e\u003cspan class=\"sr\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e    \n    \n   \u003cspan class=\"c1\"\u003e# 匹配一个全限定名标识符\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e# [ ... ]  是非捕获组\u003c/span\u003e\n    \u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003ename\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e        \n\u003c/span\u003e\u003cspan class=\"sr\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003eidentifier\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e         \n\u003c/span\u003e\u003cspan class=\"sr\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e::\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003eidentifier\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"sr\"\u003e     \n\u003c/span\u003e\u003cspan class=\"sr\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n     \u003cspan class=\"c1\"\u003e# .. | .. 是分支. 最长匹配胜出.\u003c/span\u003e\n    \u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003esigil\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e        \n\u003c/span\u003e\u003cspan class=\"sr\"\u003e       \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e$\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e@\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e%\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e::\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e    \n\u003c/span\u003e\u003cspan class=\"sr\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e    \n    \u003cspan class=\"c1\"\u003e# \u0026lt;rule\u0026gt; 调用命名 rule, 隐式地锚定在当前位置\u003c/span\u003e\n    \u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003evariable\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e      \n\u003c/span\u003e\u003cspan class=\"sr\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003esigil\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e  \n\u003c/span\u003e\u003cspan class=\"sr\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e \n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"grammars\"\u003eGrammars\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eGrammar\u003c/code\u003e 跟类很像, 含有 \u003ccode\u003erules\u003c/code\u003e 而不是 methods。Grammars 是 \u003ccode\u003erules\u003c/code\u003e 的集合并支持\u003ccode\u003e继承\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e如果要求 Raku 中变量的名字必须大写：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"c1\"\u003e# 我们继承原来那个 grammar\u003c/span\u003e\n\u003cspan class=\"k\"\u003egrammar\u003c/span\u003e \u003cspan class=\"nc\"\u003ePERL6\u003c/span\u003e \u003cspan class=\"k\"\u003eis\u003c/span\u003e \u003cspan class=\"nb\"\u003eRaku\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e    \n    \u003cspan class=\"c1\"\u003e# ... 重写我们想改变的解析规则\u003c/span\u003e\n    \u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003eidentifier\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e        \n\u003c/span\u003e\u003cspan class=\"sr\"\u003e   \u003c/span\u003e\u003cspan class=\"c1\"\u003e# Raku 中的字符类现在写作 \u0026lt;[ ... ]\u0026gt;         \n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"sr\"\u003e       \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;[\u003c/span\u003e\u003cspan class=\"sr\"\u003eA\u003c/span\u003e\u003cspan class=\"o\"\u003e..\u003c/span\u003e\u003cspan class=\"sr\"\u003eZ\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;[\u003c/span\u003e\u003cspan class=\"sr\"\u003eA\u003c/span\u003e\u003cspan class=\"o\"\u003e..\u003c/span\u003e\u003cspan class=\"sr\"\u003eZ\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e..\u003c/span\u003e\u003cspan class=\"mi\"\u003e9\u003c/span\u003e\u003cspan class=\"sr\"\u003e_\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u0026gt;\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"sr\"\u003e   \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e现在我们只需告诉编译器使用 \u003ccode\u003ePERL6\u003c/code\u003e 这个 grammar 而非默认 grammar 。还记得类中的方法调用顺序吗？ 先从本类开始, 沿着继承树从下而上到父类。Grammar 与之类似。\u003c/p\u003e\n\u003cp\u003e然而有一个缺陷。假设你想更改一个符号, 例如把 \u003ccode\u003e$\u003c/code\u003e 更改 为 \u003ccode\u003e¢\u003c/code\u003e（因为你没有足够的 \u003ccode\u003e$$$\u003c/code\u003e 来买下所有的变量, 不是吗？）看起来很简单：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003egrammar\u003c/span\u003e \u003cspan class=\"nc\"\u003eLowBudgetRaku\u003c/span\u003e \u003cspan class=\"k\"\u003eis\u003c/span\u003e \u003cspan class=\"nb\"\u003eRaku\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e# token 就像类中的方法一样, 继承后可以修改\u003c/span\u003e\n    \u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003esigil\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e¢\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e@\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e%\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e::\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e新的 grammar 解析工作的很好,  但是那之后的所有东西肯定会失败。当编译器在解析树里看见 \u003ccode\u003esigil\u003c/code\u003e 匹配时, 它得找出到底是哪一个 - 这意味着它必须要检查匹配文本的字面值,  而它并不知道怎么处理 \u003ccode\u003e¢\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e所以, 我们需要更多的技能\u0026hellip;\u003c/p\u003e\n\u003ch2 id=\"proto-regexes\"\u003eProto Regexes\u003c/h2\u003e\n\u003cp\u003e \u003ccode\u003eproto regex\u003c/code\u003e 是一套有着相同名字的 regexes/rules, 当前的 \u003ca href=\"http://svn.pugscode.org/pugs/src/raku/STD.pm\"\u003eRaku grammar\u003c/a\u003e 使用这个结构：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003eproto\u003c/span\u003e \u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003esigil\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e# ...\u003c/span\u003e\n\u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003esigil:sym\u003c/span\u003e\u0026lt;$\u0026gt;  \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003esym\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003esigil:sym\u003c/span\u003e\u0026lt;@\u0026gt;  \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003esym\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003esigil:sym\u003c/span\u003e\u0026lt;%\u0026gt;  \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003esym\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003esigil:sym\u003c/span\u003e\u0026lt;\u0026amp;\u0026gt;  \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003esym\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003esigil:sym\u003c/span\u003e\u0026lt;::\u0026gt; \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003esym\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这创建了一个叫做 \u003ccode\u003esigil\u003c/code\u003e 的组(\u003ccode\u003eproto\u003c/code\u003e), 组里面有使用 \u003ccode\u003esym\u003c/code\u003e 标识符参数化的 5 个规则(rules)（它们属于这个组因为它们跟组的名字相同）。 第一个把 \u003ccode\u003esym\u003c/code\u003e 设置为 \u003ccode\u003e$\u003c/code\u003e 然后匹配这个符号(使用\u003ccode\u003e\u0026lt;sym\u0026gt;\u003c/code\u003e). 第二个匹配 \u003ccode\u003e@\u003c/code\u003e 等等。现在如果调用规则 \u003ccode\u003e\u0026lt;sigil\u0026gt;\u003c/code\u003e, 你会得到一个含有上述所有 5 个规则的列表, 列表元素之间是或的关系。所以它依然跟正则 \u003ccode\u003e'$' | '@' | '%' | '\u0026amp;' | '::'\u003c/code\u003e 匹配相同的东西, 但是更容易扩展。\u003c/p\u003e\n\u003cp\u003e如果你想添加一个新的符号, Grammar 中唯一要修改的就是添加另外一个 \u003ccode\u003esigil\u003c/code\u003e 规则： \u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003egrammar\u003c/span\u003e \u003cspan class=\"nc\"\u003eSigilRichP6\u003c/span\u003e \u003cspan class=\"k\"\u003eis\u003c/span\u003e \u003cspan class=\"nb\"\u003eRaku\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003esigil:sym\u003c/span\u003e\u0026lt;ħ\u0026gt; \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003esym\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e# 物理学家会很爱你\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e回到原来那个例子,  你可以重写已存在的规则：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003egrammar\u003c/span\u003e \u003cspan class=\"nc\"\u003eLowBudgetRaku\u003c/span\u003e \u003cspan class=\"k\"\u003eis\u003c/span\u003e \u003cspan class=\"nb\"\u003eRaku\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003esigil:sym\u003c/span\u003e\u0026lt;$\u0026gt; \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e¢\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e现在这个 grammar 为标量使用了一个不同的符号,  但是它和原来的 grammar 有着相同的规则和相同的参数(\u003ccode\u003esigil:sym\u0026lt;$\u0026gt;\u003c/code\u003e), 编译器仍然知道怎么处理它。\u003c/p\u003e\n","text":"## A Mutable Grammar For Raku\nRules Rules 就像 perl5的 regexes, 并且更好。它们像子例程和方法那样申明, 并且还能调用其它 rules\n下面是一个解析 Raku 基本变量名的例子：\ngrammar Raku { # token alpha 是一个预定义好的 rule token identifier {\u0026lt;alpha\u0026gt;\\w+} # 匹配一个全限定名标识符 # [ ... ] 是非捕获组 token name {\u0026lt;identifier\u0026gt;[\u0026#39;::\u0026#39;\u0026lt;identifier\u0026gt;]*} # .. | .. 是分支. 最长匹配胜出. token sigil {\u0026#39;$\u0026#39;|\u0026#39;@\u0026#39;|\u0026#39;\u0026amp;\u0026#39;|\u0026#39;%\u0026#39;|\u0026#39;::\u0026#39;} # \u0026lt;rule\u0026gt; 调用命名 rule, 隐式地锚定在当前位置 token variable {\u0026lt;sigil\u0026gt;\u0026lt;name\u0026gt;} } Grammars Grammar 跟类很像, 含有 rules 而不是 methods。Grammars 是 rules 的集合并支持继承。\n如果要求 Raku 中变量的名字必须大写：\n# 我们继承原来那个 grammar grammar PERL6 is Raku { # ... 重写我们想改变的解析规则 token identifier {# Raku 中的字符类现在写作 \u0026lt;[ ... ]\u0026gt; \u0026lt;[A..Z]\u0026gt;\u0026lt;[A..Z0..9_]\u0026gt;*} } 现在我们只需告诉编译器使用 PERL6 这个 grammar 而非默认 grammar 。还记得类中的方法调用顺序吗？ 先从本类开始, 沿着继承树从下而上到父类。Grammar 与之类似。\n然而有一个缺陷。假设你想更改一个符号, 例如把 $ 更改 为 ¢（因为你没有足够的 $$$ 来买下所有的变量, 不是吗？）看起来很简单：\ngrammar LowBudgetRaku is Raku { # token 就像类中的方法一样, 继承后可以修改 token sigil {\u0026#39;¢\u0026#39;|\u0026#39;@\u0026#39;|\u0026#39;\u0026amp;\u0026#39;|\u0026#39;%\u0026#39;|\u0026#39;::\u0026#39;} } 新的 grammar 解析工作的很好, 但是那之后的所有东西肯定会失败。当编译器在解析树里看见 sigil 匹配时, 它得找出到底是哪一个 - 这意味着它必须要检查匹配文本的字面值, 而它并不知道怎么处理 ¢。\n所以, 我们需要更多的技能\u0026hellip;\nProto Regexes  proto regex 是一套有着相同名字的 regexes/rules, 当前的 Raku grammar 使用这个结构：\nproto token sigil {*} # ... token sigil:sym\u0026lt;$\u0026gt; {\u0026lt;sym\u0026gt;} token sigil:sym\u0026lt;@\u0026gt; {\u0026lt;sym\u0026gt;} token sigil:sym\u0026lt;%\u0026gt; {\u0026lt;sym\u0026gt;} token sigil:sym\u0026lt;\u0026amp;\u0026gt; {\u0026lt;sym\u0026gt;} token sigil:sym\u0026lt;::\u0026gt; {\u0026lt;sym\u0026gt;} 这创建了一个叫做 sigil 的组(proto), 组里面有使用 sym 标识符参数化的 5 个规则(rules)（它们属于这个组因为它们跟组的名字相同）。 第一个把 sym 设置为 $ 然后匹配这个符号(使用\u0026lt;sym\u0026gt;). 第二个匹配 @ 等等。现在如果调用规则 \u0026lt;sigil\u0026gt;, 你会得到一个含有上述所有 5 个规则的列表, 列表元素之间是或的关系。所以它依然跟正则 '$' | '@' | '%' | '\u0026amp;' | '::' 匹配相同的东西, 但是更容易扩展。\n如果你想添加一个新的符号, Grammar 中唯一要修改的就是添加另外一个 sigil 规则： grammar SigilRichP6 is Raku { token sigil:sym\u0026lt;ħ\u0026gt; {\u0026lt;sym\u0026gt;} # 物理学家会很爱你 } 回到原来那个例子, 你可以重写已存在的规则：\ngrammar LowBudgetRaku is Raku { token sigil:sym\u0026lt;$\u0026gt; {\u0026#39;¢\u0026#39;} } 现在这个 grammar 为标量使用了一个不同的符号, 但是它和原来的 grammar 有着相同的规则和相同的参数(sigil:sym\u0026lt;$\u0026gt;), 编译器仍然知道怎么处理它。\n"},"name":"A Mutable Grammar for Raku","published":"2021-07-11T00:00:00+08:00","summary":"A Mutable Grammar for Raku","type":"entry","url":"https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/"}