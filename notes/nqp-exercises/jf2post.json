{"author":{"name":null,"type":"card","url":"http://localhost:1313/"},"content":{"html":"\u003ch1 id=\"练习-1\"\u003e练习 1\u003c/h1\u003e\n\u003cp\u003e本练习将让您在 NQP 中执行一些简单的任务，以熟悉基本语法。\u003c/p\u003e\n\u003ch2 id=\"hello-world\"\u003eHello, world\u003c/h2\u003e\n\u003cp\u003e最简单的事情:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esay('Hello, world');\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在把它弄错:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esay 'Hello, world';\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e请注意你将如何大声地抱怨。\u003c/p\u003e\n\u003ch2 id=\"变量\"\u003e变量\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e将值绑定到标量。\u003c/li\u003e\n\u003cli\u003e使用 \u003ccode\u003esay\u003c/code\u003e 来输出它.\u003c/li\u003e\n\u003cli\u003e尝试使用赋值代替绑定。 观察它的失败。\u003c/li\u003e\n\u003cli\u003e声明一个数组。 使用索引, 例如 \u003ccode\u003e@a[0]\u003c/code\u003e, 去绑定并访问元素。\n注意在 Raku 中, 符号是不变的; 使用 \u003ccode\u003e$a[0]\u003c/code\u003e 则会抱怨未声明的 \u003ccode\u003e$a\u003c/code\u003e!\u003c/li\u003e\n\u003cli\u003e尝试绑定一个数组字面量, 例如 \u003ccode\u003e[1,2,3]\u003c/code\u003e 到一个 \u003ccode\u003e@arr\u003c/code\u003e 变量上。现在把该数组字面量绑定到一个 \u003ccode\u003e$scalar\u003c/code\u003e 变量上。注意观察索引是怎样在这两种结构上都工作良好的。\u003c/li\u003e\n\u003cli\u003e声明一个哈希变量, \u003ccode\u003e%h\u003c/code\u003e. 尝试使用字面值语法索引 (\u003ccode\u003e%h\u0026lt;key\u0026gt;\u003c/code\u003e) 和花括号语法索引 (\u003ccode\u003e%h{'key'}\u003c/code\u003e)。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"循环\"\u003e循环\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e使用 \u003ccode\u003efor\u003c/code\u003e 来迭代数组, 一次迭代一个元素, 先使用 \u003ccode\u003e$_\u003c/code\u003e 迭代, 然后使用 pointy block (\u003ccode\u003efor @a -\u0026gt; $val { ... }\u003c/code\u003e) 迭代。\u003c/li\u003e\n\u003cli\u003e你可以一次迭代两个元素吗？ 试试看！\u003c/li\u003e\n\u003cli\u003e迭代散列变量, 打印出该散列每个 pair 对儿的 \u003ccode\u003e.key\u003c/code\u003e 和 \u003ccode\u003e.value\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"子例程\"\u003e子例程\u003c/h2\u003e\n\u003cp\u003e实现一个递归的阶乘子例程, \u003ccode\u003esub fac\u003c/code\u003e。 如果你做对了 , \u003ccode\u003efac(10)\u003c/code\u003e 会返回 3628800。\u003c/p\u003e\n\u003ch2 id=\"类\"\u003e类\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e声明一个 \u003ccode\u003eBarTab\u003c/code\u003e 类。为它提供表号的标量属性和项的数组属性。\u003c/li\u003e\n\u003cli\u003e写一个返回表号的 \u003ccode\u003etable\u003c/code\u003e方法。\u003c/li\u003e\n\u003cli\u003e写一个接收项名和价格的 \u003ccode\u003eadd_order\u003c/code\u003e 方法。在项属性上放上一个带有键 \u003ccode\u003ename\u003c/code\u003e 和键 \u003ccode\u003eprice\u003c/code\u003e 的散列。\u003c/li\u003e\n\u003cli\u003e写一个能产生字符串的 \u003ccode\u003erender_tab\u003c/code\u003e 方法, 它描述 tab 上有什么(items, price for each item, total)\u003c/li\u003e\n\u003cli\u003e创建一个 tab (\u003ccode\u003eBarTab.new(table =\u0026gt; 42)\u003c/code\u003e)。 检查 \u003ccode\u003etable\u003c/code\u003e 方法是否返回 42。添加一些项并确保工作正常。你甚至想使用 NQP 的内置函数 \u003ccode\u003eplan(...)\u003c/code\u003e 和 \u003ccode\u003eok(...)\u003c/code\u003e - 来测试!\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"multi-methods\"\u003eMulti-methods\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e给 \u003ccode\u003eadd_order\u003c/code\u003e 添加一个方法。然后把当前的 \u003ccode\u003eadd_order\u003c/code\u003e 方法变成一个 multi 方法 (只须在它前面加上关键字 \u003ccode\u003emulti\u003c/code\u003e)。确保所有的都正常工作。\u003c/li\u003e\n\u003cli\u003e给 \u003ccode\u003eadd_order\u003c/code\u003e 添加另一个接收 3 个参数的 multi 候选者, 第三个参数是数量。对于此候选者，将指定次数的项散列添加到数组中。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"如果时间允许\"\u003e如果时间允许\u0026hellip;\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e写一个词法类 \u003ccode\u003eItem\u003c/code\u003e (在你的 \u003ccode\u003eBarTab\u003c/code\u003e 类中用 \u003ccode\u003emy\u003c/code\u003e 声明的类). 给它加上 \u003ccode\u003ename\u003c/code\u003e 和 \u003ccode\u003eprice\u003c/code\u003e 属性, 和访问这些属性的方法。\u003c/li\u003e\n\u003cli\u003e重构你的代码以使用该内部类, 所以你拥有一个 \u003ccode\u003eItem\u003c/code\u003e 的数组, 而不是一个散列的数组。\u003c/li\u003e\n\u003cli\u003e重构你的代码，以便代替项目列表中显示的项目, 如果被订购多次，则每个项都有一个数量。 （您可能希望在 \u003ccode\u003eBarTab\u003c/code\u003e 中切换到使用散列而不是数组，因此您可以按名称查找项，只更新已订购的项的数量。）\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"练习-2\"\u003e练习 2\u003c/h1\u003e\n\u003ch2 id=\"grammar\"\u003eGrammar\u003c/h2\u003e\n\u003cp\u003e以纯文本格式，来自 Raku irc 频道的日志如下所示:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e14:30 colomon     r: say 2**100\n14:30 camelia     rakudo 624ff7: OUTPUT«1267650600228229401496703205376␤»\n14:30 colomon     sweet!!!!!\n14:30 TimToady    bet that took a lot of electrons...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e也就是说，时间，昵称和一些文本。首先写一个解析任意行数的 grammar，捕获时间，昵称和文本。遍历匹配对象并检查它是否具有正确的输出。\u003c/p\u003e\n\u003ch2 id=\"actions\"\u003eActions\u003c/h2\u003e\n\u003cp\u003e声明一个 \u003ccode\u003eUtterance\u003c/code\u003e 类来表示一行聊天。它应该有三个属性：time，nick 和 text，以及访问它们的方法。您可以依赖默认构造函数来设置它们。\u003c/p\u003e\n\u003cp\u003e现在编写一个 actions 类，为每行文本构建此类的实例。最后，添加一个生成数组的 \u003ccode\u003eTOP\u003c/code\u003e action 方法。\u003c/p\u003e\n\u003ch2 id=\"额外任务-actions\"\u003e额外任务: Actions\u003c/h2\u003e\n\u003cp\u003e除了正常的聊天行外，还有一些 action 行，它们在昵称前有一个 \u003ccode\u003e*\u003c/code\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    07:26 moritz      r: say (1, 2, 3).map({()}).flat.perl\n    07:26 camelia     rakudo 099f0b: OUTPUT«().list␤»\n    07:26 * moritz    wonders if .grep itself flattens\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e添加对解析此内容的支持，并将其作为额外属性记录在 \u003ccode\u003eUtterance\u003c/code\u003e 中。\u003c/p\u003e\n\u003ch2 id=\"额外任务-collect-lines\"\u003e额外任务: Collect lines\u003c/h2\u003e\n\u003cp\u003e用一个数组替换 \u003ccode\u003eUtterance\u003c/code\u003e 中的 text 属性。然后，如果单个昵称说出多个连续的文本行，则将它们放入单个数组中并为它们创建单个 \u003ccode\u003eUtterance\u003c/code\u003e 实例。\u003c/p\u003e\n\u003ch1 id=\"练习-3\"\u003e练习 3\u003c/h1\u003e\n\u003ch2 id=\"熟悉\"\u003e熟悉\u003c/h2\u003e\n\u003cp\u003e采用 SlowDB 实现。查看我们目前看到的代码，并运行一些简单的 \u003ccode\u003eINSERT\u003c/code\u003e 和 \u003ccode\u003eSELECT\u003c/code\u003e 查询。\u003c/p\u003e\n\u003ch2 id=\"delete\"\u003eDELETE\u003c/h2\u003e\n\u003cp\u003e实现删除行的功能。 \u003ccode\u003eDELETE\u003c/code\u003e 查询的示例如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDELETE WHERE name = 'jnthn'\nDELETE WHERE name = 'jnthn', is_action = 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e也就是说，可以存在一个条件或由逗号分隔的条件的组合。\u003c/p\u003e\n\u003ch2 id=\"update\"\u003eUPDATE\u003c/h2\u003e\n\u003cp\u003e实现更新现有行的功能。 \u003ccode\u003eUPDATE\u003c/code\u003e 查询的示例如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eUPDATE WHERE type = 'stout' SET tasty = 1\nUPDATE WHERE type = 'stout' SET tasty = 1, dark = 1\nUPDATE WHERE type = 'stotu' SET type = 'stout'\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"refactor\"\u003eRefactor\u003c/h2\u003e\n\u003cp\u003e现在有三件事支持 \u003ccode\u003eWHERE\u003c/code\u003e 子句：\u003ccode\u003eSELECT\u003c/code\u003e，\u003ccode\u003eDELETE\u003c/code\u003e 和 \u003ccode\u003eUPDATE\u003c/code\u003e。你能想出来吗？\u003c/p\u003e\n\u003ch2 id=\"如果你是-10x-工程师\"\u003e如果你是 10x 工程师\u0026hellip;\u003c/h2\u003e\n\u003cp\u003e扩展 \u003ccode\u003eWHERE\u003c/code\u003e 子句中可用的运算符范围以包括 \u003ccode\u003e!=\u003c/code\u003e，\u003ccode\u003e\u0026lt;\u003c/code\u003e，\u003ccode\u003e\u0026lt;=\u003c/code\u003e，\u003ccode\u003e\u0026gt;\u003c/code\u003e 和 \u003ccode\u003e\u0026gt;=\u003c/code\u003e。\u003c/p\u003e\n\u003ch1 id=\"练习-4\"\u003e练习 4\u003c/h1\u003e\n\u003cp\u003e创建一个只支持 \u003ccode\u003eecho\u003c/code\u003e 语句的最小 php 编译器：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eecho \u0026quot;\u0026lt;h2\u0026gt;PHP is fun!\u0026lt;/h2\u0026gt;\u0026quot;;\necho \u0026quot;\u0026lt;blink\u0026gt;So 1990s!\u0026lt;/blink\u0026gt;\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"基础\"\u003e基础\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e创建一个新的 NQP 源文件, 然后 \u003ccode\u003euse NQPHLL\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e创建 \u003ccode\u003eHLL::Grammar\u003c/code\u003e, \u003ccode\u003eHLL::Actions\u003c/code\u003e 和 \u003ccode\u003eHLL::Compiler\u003c/code\u003e 的子类。\u003c/li\u003e\n\u003cli\u003e写一个 \u003ccode\u003eMAIN\u003c/code\u003e 子例程, 就像那个 Rubyish 那样, 设立编译器对象并调用 \u003ccode\u003ecommand_line\u003c/code\u003e。验证运行没有参数的程序现在进入 REPL，但尝试运行任何代码失败，因为语法没有 \u003ccode\u003eTOP\u003c/code\u003e 规则。\u003c/li\u003e\n\u003cli\u003e只需要足够的语法就可以解析一个 \u003ccode\u003eecho\u003c/code\u003e 状态列表。最后一个不需要后跟分号。再次运行 REPL 并确保您的语法解析，并且您得到的错误是因为没有构建 AST。\u003c/li\u003e\n\u003cli\u003e写一个 action 方法来制作 \u003ccode\u003eQAST\u003c/code\u003e。确保您的程序现在运行。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"走得更远\"\u003e走得更远\u003c/h2\u003e\n\u003cp\u003e是时候变得更 PHP-ish 了!\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eecho\u003c/code\u003e 语句不会自动在输出的末尾添加新行，因此请使用 \u003ccode\u003eprint\u003c/code\u003e op 而不是 \u003ccode\u003esay\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e在你的引用解析器中打开反斜杠序列的解析。这是通过 \u003ccode\u003e\u0026lt;quote_EXPR: ':q', ':b'\u0026gt;\u003c/code\u003e (注意 \u003ccode\u003e:b\u003c/code\u003e) 来完成的。 确保现在你可以在 \u003ccode\u003eecho \u0026quot;stuff\\n\u0026quot;\u003c/code\u003e 时是否带有换行。\u003c/li\u003e\n\u003cli\u003e还可以使用 \u003ccode\u003eecho(\u0026quot;with parentheses\u0026quot;)\u003c/code\u003e。请实现它。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"练习-5\"\u003e练习 5\u003c/h1\u003e\n\u003cp\u003e在本练习中，您将为 PHPish 添加一些功能，以便探索我们一直在研究的 QAST 节点。到最后，您应该能够运行以下程序：\u003c/p\u003e\n\u003ch2 id=\"values\"\u003eValues\u003c/h2\u003e\n\u003cp\u003e到目前为止，\u003ccode\u003eecho\u003c/code\u003e 只能处理字符串参数。是时候改变它了！添加一个 \u003ccode\u003evalue\u003c/code\u003e protoregex，以及解析整数，浮点数和字符串的候选者。确保您的 string token 如下所示：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etoken value:sym\u0026lt;string\u0026gt; { \u0026lt;?[\u0026quot;]\u0026gt; \u0026lt;quote_EXPR: ':q', ':b'\u0026gt; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样你就能够处理 \u003ccode\u003e\\n\u003c/code\u003e。 添加适当的 action 方法（记住 protoregex 本身不需要一个 action 方法）。 更新 \u003ccode\u003eecho\u003c/code\u003e 规则和 action 方法以接收 \u003ccode\u003evalue\u003c/code\u003e，而不仅仅是字符串。 确保您可以像以前一样运行相同的操作，并且：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eecho 42;\necho 1.5;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"operators\"\u003eOperators\u003c/h2\u003e\n\u003cp\u003e研究运算符优先级解析材料。 设置两个优先级，一个用于加法，一个用于乘法运算符。 像 Rubyish 一样添加四个常用的算术运算（\u003ccode\u003e+\u003c/code\u003e， \u003ccode\u003e-\u003c/code\u003e ，\u003ccode\u003e*\u003c/code\u003e，\u003ccode\u003e/\u003c/code\u003e）。 再添加 \u003ccode\u003e.\u003c/code\u003e 用于字符串连接（NQP 用于连接操作的叫 \u003ccode\u003econcat\u003c/code\u003e）。\u003c/p\u003e\n\u003cp\u003e接下来，为\u003ccode\u003e术语\u003c/code\u003e protoregex 添加一个候选项，该术语应该调用 \u003ccode\u003evalue\u003c/code\u003e 来解析一个值。 这需要匹配的 action 方法。\u003c/p\u003e\n\u003cp\u003e最后，更新 \u003ccode\u003eecho\u003c/code\u003e 以解析 \u003ccode\u003eEXPR\u003c/code\u003e 而不是 \u003ccode\u003evalue\u003c/code\u003e。 你现在应该能够运行：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eecho 2 * 5 . \u0026quot;\\n\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"variables\"\u003eVariables\u003c/h2\u003e\n\u003cp\u003e奇怪的是，PHP 局部变量对 Ruby 有类似的声明语义：首先赋值声明。 围绕全局变量有一些更有趣的规则，但我们暂时将它们放在一边。\u003c/p\u003e\n\u003cp\u003e首先，为赋值添加优先级，并且赋值运算符被映射到 \u003ccode\u003ebind\u003c/code\u003e op。 此外，添加 grammar 规则和 action 方法，以便表达式可以用作语句。 在此之后，您应该能够解析：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1 = 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是，这是无稽之谈，所以它会在代码生成过程中出错。\u003c/p\u003e\n\u003cp\u003e我们现在需要更多地关注块结构。 更新您的 \u003ccode\u003eTOP\u003c/code\u003e grammar 规则以声明 \u003ccode\u003e$*CUR_BLOCK\u003c/code\u003e，就像我们在 Rubyish 中所做的那样，并对 action 方法进行匹配更新。\u003c/p\u003e\n\u003cp\u003e接下来，实现变量解析。 再一次，您可以从我们在 Rubyish 中所做的工作中获得灵感，但变量命名规则如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e变量以 \u003ccode\u003e$\u003c/code\u003e 符号开头，后跟变量名。\u003c/li\u003e\n\u003cli\u003e变量名必须以字母或下划线字符开头（不是数字）\u003c/li\u003e\n\u003cli\u003e变量名只能包含字母数字字符和下划线（A..Z，a..z，0..9，和 \u003ccode\u003e_\u003c/code\u003e）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e还要记住 PHP 不是面向行的。 完成后，您应该能够执行以下程序:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$emotion = \u0026quot;awesome\u0026quot;;\necho \u0026quot;PHP is \u0026quot; . $emotion . \u0026quot;\\n\u0026quot;;\n$emotion = $emotion . \u0026quot;st\u0026quot;;\necho \u0026quot;Raku is \u0026quot; . $emotion . \u0026quot;\\n\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"额外任务-functions\"\u003e额外任务: functions\u003c/h2\u003e\n\u003cp\u003e实现带参数和参数传递的函数！ 完成后，您应该能够运行：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction greet($name) {\n    echo \u0026quot;Good day, \u0026quot; . $name . \u0026quot;\\n\u0026quot;;\n}\ngreet(\u0026quot;Lena\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e你可以从 Rubyish 的例子中汲取灵感。 但是，您还需要注意确保函数声明后面不需要分号。\u003c/p\u003e\n\u003ch1 id=\"练习-6\"\u003e练习 6\u003c/h1\u003e\n\u003cp\u003e这个练习是为了在第一天结束时填补时间，如果我们以某种方式通关了！ 以下是您可以做的一些想法。\u003c/p\u003e\n\u003ch2 id=\"基本的数字关系运算符\"\u003e基本的数字关系运算符\u003c/h2\u003e\n\u003cp\u003e现在，我们将忽略 PHP 的关系运算符所做的类型杂耍，以处理字符串和数字，并处理数字情况。 PHP 有两个比较运算符的优先级：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eTighter level:    \u0026lt; \u0026lt;= \u0026gt; \u0026gt;=\nLooser level:     == !=\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e它们同时比加法操作更宽松，比赋值操作更紧凑。 不需要任何 action 方法，因为： \b\u003ccode\u003e:op\u0026lt;...\u0026gt;\u003c/code\u003e 可以在 \u003ccode\u003e\u0026lt;O(...)\u0026gt;\u003c/code\u003e 中使用。\u003c/p\u003e\n\u003ch2 id=\"ifelse-ifelse\"\u003eif/else if/else\u003c/h2\u003e\n\u003cp\u003e既然我们有关系运算符，那么实现 \u003ccode\u003eif\u003c/code\u003e 语句是有意义的。 从简单开始：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif ($a \u0026gt; $b) {\n  echo \u0026quot;a is bigger than b\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然后添加 \u003ccode\u003eelse\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif ($a == $b) {\n  echo \u0026quot;a is the same as b\u0026quot;;\n}\nelse {\n    echo \u0026quot;a and b differ\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最后添加上 \u003ccode\u003eelseif\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif ($a \u0026gt; $b) {\n    echo \u0026quot;a is bigger than b\u0026quot;;\n} elseif ($a == $b) {\n    echo \u0026quot;a is equal to b\u0026quot;;\n} else {\n    echo \u0026quot;a is smaller than b\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e要更好地理解如何处理 \u003ccode\u003eelseif\u003c/code\u003e，请阅读 NQP 的 grammar 和 action 中的适用代码。 在 grammar 和 action 中搜索 \u003ccode\u003estatement_control:sym\u0026lt;if\u0026gt;\u003c/code\u003e 。\u003c/p\u003e\n\u003cp\u003e最后但并非最不重要的，您甚至可能想尝试实现悬空形式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif ($a \u0026gt; $b)\n  echo \u0026quot;a is bigger than b\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e似乎在 \u003ccode\u003eelseif\u003c/code\u003e 和 \u003ccode\u003eelse\u003c/code\u003e 形式中还有其他奇妙的违规行为，其中也涉及冒号，谁知道它是什么。 但如果你这样做，最好去喝点酒。 或者，我也不知道。\u003c/p\u003e\n\u003ch2 id=\"while-循环\"\u003ewhile 循环\u003c/h2\u003e\n\u003cp\u003e解析并实现 while 循环:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$i = 1;\nwhile ($i \u0026lt;= 10) {\n    $i = $i + 1;\n    echo $i;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e恭喜。你的 PHP 实现现在是图灵完备的了，现在一切就绪了！\n\u003cem\u003e(旁白：实际上图灵完成的时间早一些，因为递归函数和 while 循环是等价的。)\u003c/em\u003e\u003c/p\u003e\n\u003ch1 id=\"练习-7\"\u003e练习 7\u003c/h1\u003e\n\u003cp\u003e在本练习中，您将为类，方法，对 PHPish 的 \u003ccode\u003enew\u003c/code\u003e 运算符和方法调用添加基本支持。当你完成后，你应该能够运行：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass Greeter {\n    function greet($who) {\n        echo \u0026quot;Greetings, \u0026quot; . $who . \u0026quot;\\n\u0026quot;;\n    }\n}\n$g = new Greeter();\n$g-\u0026gt;greet(\u0026quot;Anna\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"首先-元对象\"\u003e首先, 元对象\u003c/h2\u003e\n\u003cp\u003e创建一个简单的元对象，就像 Rubyish 一样，可以支持添加和查找方法。\u003c/p\u003e\n\u003ch2 id=\"接下来解析类并为它们生成代码\"\u003e接下来，解析类并为它们生成代码\u003c/h2\u003e\n\u003cp\u003e基础知识类似于 Rubyish：类中的函数成为类的方法。因此，您可以窃取该方法，确保使用 PHP 语法。\u003c/p\u003e\n\u003ch2 id=\"添加新项\"\u003e添加新项\u003c/h2\u003e\n\u003cp\u003e这非常相似，你几乎可以直接从 Rubyish 窃取它。请注意不同的空格规则（换行符并不重要）。\u003c/p\u003e\n\u003ch2 id=\"添加方法调用\"\u003e添加方法调用\u003c/h2\u003e\n\u003cp\u003e再次，类似的方法工作，模数语法：方法调用运算符是 \u003ccode\u003e-\u0026gt;\u003c/code\u003e。添加之后，您应该能够运行本节开头的程序 - 但它仍然会失败。问题是我们没有让方法接受调用者（它们所调用的对象）。\u003c/p\u003e\n\u003ch2 id=\"支持-this\"\u003e支持 $this\u003c/h2\u003e\n\u003cp\u003e方法的第一个参数是调用它的对象。在 PHP 中，这被分配给 \u003ccode\u003e$this\u003c/code\u003e。因此，在类中时，请确保函数始终使用 \u003ccode\u003e$this\u003c/code\u003e 作为\u003cem\u003e第一个\u003c/em\u003e参数。\u003c/p\u003e\n\u003ch2 id=\"好吧这是很多复制粘贴\"\u003e好吧，这是很多复制粘贴\u0026hellip;\u003c/h2\u003e\n\u003cp\u003e对。大多数基于类的对象系统在这个级别上相对类似。尽管如此，你自己有希望能把它们整合到一块儿会让整个事情变得不那么神奇！\u003c/p\u003e\n\u003cp\u003e顺便说一下，现在你支持 \u003ccode\u003e$this\u003c/code\u003e，这也应该有效：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass Greeter {\n    function greet($who) {\n        $this-\u0026gt;greet_custom(\u0026quot;Hej\u0026quot;, $who);\n    }\n    function greet_custom($greeting, $who) {\n        echo $greeting . \u0026quot;, \u0026quot; . $who . \u0026quot;\\n\u0026quot;;\n    }\n}\n$g = new Greeter();\n$g-\u0026gt;greet(\u0026quot;masak\u0026quot;);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"练习-8\"\u003e练习 8\u003c/h1\u003e\n\u003cp\u003e在本练习中，您将稍微扩展 PHPish 对象系统。。。或许很多。\u003c/p\u003e\n\u003ch2 id=\"method-缓存\"\u003eMethod 缓存\u003c/h2\u003e\n\u003cp\u003e首先，使用方法在 NQP 中手动创建一个新的 PHP 类。它看起来像这样：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emy $c := PHPClassHOW.new_type(:name('Foo'));\n$c.HOW.add_method($c, 'bar', -\u0026gt; $obj { 1 });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e计算 100,000 次方法调用的时间。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emy $start := nqp::time_n();\nmy int $i := 0;\nwhile $i \u0026lt; 100000 {\n    $obj.bar();\n    $i++;\n}\nsay(nqp::time_n() - $start);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在您的 \u003ccode\u003ePHPClassHOW\u003c/code\u003e 中添加一个 \u003ccode\u003ecompose\u003c/code\u003e 方法。在其中，使用 \u003ccode\u003esetmethcache\u003c/code\u003e 指令。您现在可以使用 \u003ccode\u003e%!methods\u003c/code\u003e 作为方法缓存散列。添加对您的 \u003ccode\u003ecompose\u003c/code\u003e 方法的调用。重复计时。缓存应该更快（在练习题作者的机器上，没有缓存是 0.194s, 有缓存是 0.066s）。\n现在，更新 \u003ccode\u003estatement:sym\u0026lt;class\u0026gt;\u003c/code\u003e action 方法中的代码, 以便在添加所有方法后调用 \u003ccode\u003ecompose\u003c/code\u003e 方法。\u003c/p\u003e\n\u003ch2 id=\"继承\"\u003e继承\u003c/h2\u003e\n\u003cp\u003e这是我们想要让其能够工作的例子：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass Dog {\n    function bark()  { echo \u0026quot;woof!\\n\u0026quot;; }\n    function smell() { echo \u0026quot;terrible\\n\u0026quot;; }\n}\nclass Puppy extends Dog {\n    function bark()  { echo \u0026quot;yap!\\n\u0026quot;; }\n}\n$d = new Dog();\n$d-\u0026gt;bark();\n$d-\u0026gt;smell();\n$p = new Puppy();\n$p-\u0026gt;bark();\n$p-\u0026gt;smell();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e首先，从解析开始。它是解析类声明的一个非常小的补充，可选择接受 \u003ccode\u003eextends\u003c/code\u003e 关键字。一旦它解析，你应该能够运行程序，但它将无法进行最后的 \u003ccode\u003esmell\u003c/code\u003e 调用，因为它是继承的，我们还没有继承。\u003c/p\u003e\n\u003cp\u003e接下来，更新类的 action 方法。在添加方法的代码之前，如果有 \u003ccode\u003eextends\u003c/code\u003e，请在元对象上添加一个对 \u003ccode\u003eadd_parent\u003c/code\u003e 的调用（稍后会写入）。要查找父级，请使用作用域设置为 \u003ccode\u003elexical\u003c/code\u003e 的 \u003ccode\u003eQAST::Var\u003c/code\u003e 节点。\u003c/p\u003e\n\u003cp\u003e您现在应该收到一条错误消息，指出 \u003ccode\u003eadd_parent\u003c/code\u003e 尚未被实现。从这里开始，所有工作都将在 \u003ccode\u003ePHPClassHOW\u003c/code\u003e 中进行。\u003c/p\u003e\n\u003cp\u003e添加属性 \u003ccode\u003e@!parents\u003c/code\u003e。实现将添加到此数组的 \u003ccode\u003eadd_parent\u003c/code\u003e，但仅限于还没有存在父级。如果有，那么 \u003ccode\u003enqp::die\u003c/code\u003e 就可以了。这应该清除错误，但同样，最后的\u003ccode\u003essnell\u003c/code\u003e 调用还不起作用。\u003c/p\u003e\n\u003cp\u003e接下来，更新 \u003ccode\u003efind_method\u003c/code\u003e 方法。如果要搜索的方法不在 \u003ccode\u003e%!methods\u003c/code\u003e 中，则应该查看所有父项的方法表。为此，您需要实现方法 \u003ccode\u003eparent\u003c/code\u003e 和 \u003ccode\u003emethod_table\u003c/code\u003e，以便从基类获取所需的信息。\u003c/p\u003e\n\u003cp\u003e到目前为止，事情应该能工作 - 但效率不高！为此，您现在还应该更新方法缓存。您可以通过在 \u003ccode\u003efind_method\u003c/code\u003e 中添加调试语句来确保正确执行此操作，如果缓存正在运行，则不应调用该语句。\u003c/p\u003e\n\u003ch2 id=\"如果时间允许-interfaces\"\u003e如果时间允许: interfaces\u003c/h2\u003e\n\u003cp\u003e在 PHP 中，接口表示要求某个方法列表由声明它实现它的任何类提供。例如，给定：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003einterface iBarkable {\n    function bark();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e那么这个类就是好的:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass Dog implements iBarkable {\n    function bark()  { echo \u0026quot;woof!\\n\u0026quot;; }\n    function smell() { echo \u0026quot;terrible\\n\u0026quot;; }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e而这个类应该导致错误:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass BadDog implements iBarkable {\n    function smell() { echo \u0026quot;terrible\\n\u0026quot;; }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e因为它缺少 \u003ccode\u003ebark\u003c/code\u003e 方法。 您的目标是实现此功能。 这里有一些提示。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e首先在其中添加对接口和方法需求的解析。\u003c/li\u003e\n\u003cli\u003e一旦有效，编写一个 \u003ccode\u003ePHPInterfaceHOW\u003c/code\u003e，可用于保存所需方法的列表。 因为你应该使用 \u003ccode\u003eUninstantiable\u003c/code\u003e REPR, 因为不允许创建接口的实例。\u003c/li\u003e\n\u003cli\u003e将 \u003ccode\u003eimplements\u003c/code\u003e 关键字解析添加到 \u003ccode\u003eclass\u003c/code\u003e 声明中。 设置在 \u003ccode\u003ePHPClassHOW\u003c/code\u003e 上调用 \u003ccode\u003eadd_interface\u003c/code\u003e 方法的 action 方法，应该将接口添加到  \u003ccode\u003e@!interfaces\u003c/code\u003e 属性。\u003c/li\u003e\n\u003cli\u003e你现在应该发现上面的例子都编译了，但第二个例子没有被拒绝。 为了实现这一点，在 \u003ccode\u003ePHPClassHOW\u003c/code\u003e 的 \u003ccode\u003ecompose\u003c/code\u003e 方法中，编写代码，获取每个接口需求方法的列表。并检查类是否提供它们。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"练习-9\"\u003e练习 9\u003c/h1\u003e\n\u003cp\u003e本练习将带您进行正则表达式实现的简短介绍。\u003c/p\u003e\n\u003ch2 id=\"解析和-actions\"\u003e解析和 actions\u003c/h2\u003e\n\u003cp\u003e运行以下代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enqp --rxtrace -e \u0026quot;/a+/\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在，让我们试着理解它。\u003c/p\u003e\n\u003cp\u003e在 NQP 仓库中, 打开 \u003ccode\u003esrc/NQP/Gramamr.nqp\u003c/code\u003e 并定位到 \u003ccode\u003equote:sym\u0026lt;/ /\u0026gt;\u003c/code\u003e。\n观察到它调用了 \u003ccode\u003eLANG\u003c/code\u003e, 那是做语言切换. 这可以在 \u003ccode\u003esrc/HLL/Grammar.nqp\u003c/code\u003e 中找到。 注意它如何使用编织，还有切换操作以及语言类型。\u003c/p\u003e\n\u003cp\u003e下面, 打开 \u003ccode\u003esrc/QRegex/P6Regex/Grammar.nqp\u003c/code\u003e 并定位到 \u003ccode\u003enibbler\u003c/code\u003e。尝试挑出对 \u003ccode\u003etermaltseq\u003c/code\u003e 的调用. 看看 \u003ccode\u003etermaltseq\u003c/code\u003e 自身, 然后该 action 方法所在的 Action 文件。 往下找, 找到 \u003ccode\u003etermish\u003c/code\u003e, 并尝试理解它在那儿做什么: 处理不同的备选分支和连词的相对优先级。\u003c/p\u003e\n\u003cp\u003e再往下, 看看下面的 \u003ccode\u003eatom\u003c/code\u003e。 注意这里我们的正则表达式中的 \u003ccode\u003ea\u003c/code\u003e 是怎样被解析的。然后回头查看 \u003ccode\u003equantified_atom\u003c/code\u003e。 阅读 action 方法，看看原子如何放入量词节点。\u003c/p\u003e\n\u003cp\u003e您可能希望探索如何处理其他一些结构。\u003c/p\u003e\n\u003ch2 id=\"探索嵌入式代码块\"\u003e探索嵌入式代码块\u003c/h2\u003e\n\u003cp\u003e在 NQP grammar 中, 查看 \u003ccode\u003eNQP::Regex\u003c/code\u003e。 注意它是你正在看的基本 \u003ccode\u003eQRegex::P6Regex::Grammar\u003c/code\u003e  的一个子类。这是 grammar 真正成为类的力量的一部分：我们可以将它们子类化以专门化它们。\u003c/p\u003e\n\u003cp\u003e让我们来看一下 \u003ccode\u003e/[a { say('here') }]+/\u003c/code\u003e 是怎样被处理的. 这很有趣, 因为我们从 NQP 开始, 然后解析正则表达式语法, 然后以在块中再次解析 NQP 代码结束。定位到 \u003ccode\u003eassertion:sym\u0026lt;{ }\u0026gt;\u003c/code\u003e, 然后查看 \u003ccode\u003ecodeblock\u003c/code\u003e。 享受相对简单的事情!\u003c/p\u003e\n\u003cp\u003e看一下 \u003ccode\u003eNQP::RegexActions\u003c/code\u003e 里面的 \u003ccode\u003ecodeblock\u003c/code\u003e action 方法。 你能弄清楚发生了什么吗？ 如果没有，请问你的老师或你周围的人！\u003c/p\u003e\n\u003ch2 id=\"探索-nfas\"\u003e探索 NFAs\u003c/h2\u003e\n\u003cp\u003e保存的 NFA 形式存储在规则的代码对象中。 因此，我们可以获得它并返回到一个对象，如下所示：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egrammar Example {\n    token t { 'foo' }\n}\n\nmy $t   := nqp::findmethod(Example, 't');\nmy $nfa := QRegex::NFA.from_saved($t.NFA());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是怎么办呢？ 接下来，打开 \u003ccode\u003esrc/QRegex/NFA.nqp\u003c/code\u003e。 查看顶部附近的边缘类型常量列表。 NFA 的整体结构是列表。 外部列表表示状态 - 图中的节点。 每个节点由其出局边缘列表组成，由 3 个值表示：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一个 action，它是 NFA.nqp 顶部的边缘类型常量之一\u003c/li\u003e\n\u003cli\u003eaction 的参数\u003c/li\u003e\n\u003cli\u003e如果我们匹配，将转到下一个状态的索引\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们可以写一些代码来转储这个：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emy $i := 0;\nfor $nfa.states -\u0026gt; @edges {\n    say(\u0026quot;State $i\u0026quot;);\n    for @edges -\u0026gt; $act, $arg, $to {\n        say(\u0026quot;    $act ($arg) ==\u0026gt; $to\u0026quot;);\n    }\n    $i++;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于我们的简单示例，我们得到:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eState 0\nState 1\n    2 (102) ==\u0026gt; 2\nState 2\n    2 (111) ==\u0026gt; 3\nState 3\n    2 (111) ==\u0026gt; 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e边缘类型 2 表示代码点，这里的参数是我们应该匹配的字符代码，如果我们要进入下一个状态。 看看我们如何从状态 1 开始，到达状态 0 是成功的。\n在 token 中尝试一些不同的东西，看看 NFA 是什么样的。 这是一些想法。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ea+\n\u0026lt;[abc]\u0026gt;\n\u0026lt;[abc]\u0026gt;*\n\u0026lt;foo\u0026gt;?\n\\w*\n:i abc\n:i a+\n\u003c/code\u003e\u003c/pre\u003e\n","text":"练习 1 本练习将让您在 NQP 中执行一些简单的任务，以熟悉基本语法。\nHello, world 最简单的事情:\nsay('Hello, world'); 现在把它弄错:\nsay 'Hello, world'; 请注意你将如何大声地抱怨。\n变量 将值绑定到标量。 使用 say 来输出它. 尝试使用赋值代替绑定。 观察它的失败。 声明一个数组。 使用索引, 例如 @a[0], 去绑定并访问元素。 注意在 Raku 中, 符号是不变的; 使用 $a[0] 则会抱怨未声明的 $a! 尝试绑定一个数组字面量, 例如 [1,2,3] 到一个 @arr 变量上。现在把该数组字面量绑定到一个 $scalar 变量上。注意观察索引是怎样在这两种结构上都工作良好的。 声明一个哈希变量, %h. 尝试使用字面值语法索引 (%h\u0026lt;key\u0026gt;) 和花括号语法索引 (%h{'key'})。 循环 使用 for 来迭代数组, 一次迭代一个元素, 先使用 $_ 迭代, 然后使用 pointy block (for @a -\u0026gt; $val { ... }) 迭代。 你可以一次迭代两个元素吗？ 试试看！ 迭代散列变量, 打印出该散列每个 pair 对儿的 .key 和 .value。 子例程 实现一个递归的阶乘子例程, sub fac。 如果你做对了 , fac(10) 会返回 3628800。\n类 声明一个 BarTab 类。为它提供表号的标量属性和项的数组属性。 写一个返回表号的 table方法。 写一个接收项名和价格的 add_order 方法。在项属性上放上一个带有键 name 和键 price 的散列。 写一个能产生字符串的 render_tab 方法, 它描述 tab 上有什么(items, price for each item, total) 创建一个 tab (BarTab.new(table =\u0026gt; 42))。 检查 table 方法是否返回 42。添加一些项并确保工作正常。你甚至想使用 NQP 的内置函数 plan(...) 和 ok(...) - 来测试! Multi-methods 给 add_order 添加一个方法。然后把当前的 add_order 方法变成一个 multi 方法 (只须在它前面加上关键字 multi)。确保所有的都正常工作。 给 add_order 添加另一个接收 3 个参数的 multi 候选者, 第三个参数是数量。对于此候选者，将指定次数的项散列添加到数组中。 如果时间允许\u0026hellip; 写一个词法类 Item (在你的 BarTab 类中用 my 声明的类). 给它加上 name 和 price 属性, 和访问这些属性的方法。 重构你的代码以使用该内部类, 所以你拥有一个 Item 的数组, 而不是一个散列的数组。 重构你的代码，以便代替项目列表中显示的项目, 如果被订购多次，则每个项都有一个数量。 （您可能希望在 BarTab 中切换到使用散列而不是数组，因此您可以按名称查找项，只更新已订购的项的数量。） 练习 2 Grammar 以纯文本格式，来自 Raku irc 频道的日志如下所示:\n14:30 colomon r: say 2**100 14:30 camelia rakudo 624ff7: OUTPUT«1267650600228229401496703205376␤» 14:30 colomon sweet!!!!! 14:30 TimToady bet that took a lot of electrons... 也就是说，时间，昵称和一些文本。首先写一个解析任意行数的 grammar，捕获时间，昵称和文本。遍历匹配对象并检查它是否具有正确的输出。\nActions 声明一个 Utterance 类来表示一行聊天。它应该有三个属性：time，nick 和 text，以及访问它们的方法。您可以依赖默认构造函数来设置它们。\n现在编写一个 actions 类，为每行文本构建此类的实例。最后，添加一个生成数组的 TOP action 方法。\n额外任务: Actions 除了正常的聊天行外，还有一些 action 行，它们在昵称前有一个 *：\n07:26 moritz r: say (1, 2, 3).map({()}).flat.perl 07:26 camelia rakudo 099f0b: OUTPUT«().list␤» 07:26 * moritz wonders if .grep itself flattens 添加对解析此内容的支持，并将其作为额外属性记录在 Utterance 中。\n额外任务: Collect lines 用一个数组替换 Utterance 中的 text 属性。然后，如果单个昵称说出多个连续的文本行，则将它们放入单个数组中并为它们创建单个 Utterance 实例。\n练习 3 熟悉 采用 SlowDB 实现。查看我们目前看到的代码，并运行一些简单的 INSERT 和 SELECT 查询。\nDELETE 实现删除行的功能。 DELETE 查询的示例如下：\nDELETE WHERE name = 'jnthn' DELETE WHERE name = 'jnthn', is_action = 1 也就是说，可以存在一个条件或由逗号分隔的条件的组合。\nUPDATE 实现更新现有行的功能。 UPDATE 查询的示例如下：\nUPDATE WHERE type = 'stout' SET tasty = 1 UPDATE WHERE type = 'stout' SET tasty = 1, dark = 1 UPDATE WHERE type = 'stotu' SET type = 'stout' Refactor 现在有三件事支持 WHERE 子句：SELECT，DELETE 和 UPDATE。你能想出来吗？\n如果你是 10x 工程师\u0026hellip; 扩展 WHERE 子句中可用的运算符范围以包括 !=，\u0026lt;，\u0026lt;=，\u0026gt; 和 \u0026gt;=。\n练习 4 创建一个只支持 echo 语句的最小 php 编译器：\necho \u0026quot;\u0026lt;h2\u0026gt;PHP is fun!\u0026lt;/h2\u0026gt;\u0026quot;; echo \u0026quot;\u0026lt;blink\u0026gt;So 1990s!\u0026lt;/blink\u0026gt;\u0026quot;; 基础 创建一个新的 NQP 源文件, 然后 use NQPHLL。 创建 HLL::Grammar, HLL::Actions 和 HLL::Compiler 的子类。 写一个 MAIN 子例程, 就像那个 Rubyish 那样, 设立编译器对象并调用 command_line。验证运行没有参数的程序现在进入 REPL，但尝试运行任何代码失败，因为语法没有 TOP 规则。 只需要足够的语法就可以解析一个 echo 状态列表。最后一个不需要后跟分号。再次运行 REPL 并确保您的语法解析，并且您得到的错误是因为没有构建 AST。 写一个 action 方法来制作 QAST。确保您的程序现在运行。 走得更远 是时候变得更 PHP-ish 了!\necho 语句不会自动在输出的末尾添加新行，因此请使用 print op 而不是 say。 在你的引用解析器中打开反斜杠序列的解析。这是通过 \u0026lt;quote_EXPR: ':q', ':b'\u0026gt; (注意 :b) 来完成的。 确保现在你可以在 echo \u0026quot;stuff\\n\u0026quot; 时是否带有换行。 还可以使用 echo(\u0026quot;with parentheses\u0026quot;)。请实现它。 练习 5 在本练习中，您将为 PHPish 添加一些功能，以便探索我们一直在研究的 QAST 节点。到最后，您应该能够运行以下程序：\nValues 到目前为止，echo 只能处理字符串参数。是时候改变它了！添加一个 value protoregex，以及解析整数，浮点数和字符串的候选者。确保您的 string token 如下所示：\ntoken value:sym\u0026lt;string\u0026gt; { \u0026lt;?[\u0026quot;]\u0026gt; \u0026lt;quote_EXPR: ':q', ':b'\u0026gt; } 这样你就能够处理 \\n。 添加适当的 action 方法（记住 protoregex 本身不需要一个 action 方法）。 更新 echo 规则和 action 方法以接收 value，而不仅仅是字符串。 确保您可以像以前一样运行相同的操作，并且：\necho 42; echo 1.5; Operators 研究运算符优先级解析材料。 设置两个优先级，一个用于加法，一个用于乘法运算符。 像 Rubyish 一样添加四个常用的算术运算（+， - ，*，/）。 再添加 . 用于字符串连接（NQP 用于连接操作的叫 concat）。\n接下来，为术语 protoregex 添加一个候选项，该术语应该调用 value 来解析一个值。 这需要匹配的 action 方法。\n最后，更新 echo 以解析 EXPR 而不是 value。 你现在应该能够运行：\necho 2 * 5 . \u0026quot;\\n\u0026quot;; Variables 奇怪的是，PHP 局部变量对 Ruby 有类似的声明语义：首先赋值声明。 围绕全局变量有一些更有趣的规则，但我们暂时将它们放在一边。\n首先，为赋值添加优先级，并且赋值运算符被映射到 bind op。 此外，添加 grammar 规则和 action 方法，以便表达式可以用作语句。 在此之后，您应该能够解析：\n1 = 1 但是，这是无稽之谈，所以它会在代码生成过程中出错。\n我们现在需要更多地关注块结构。 更新您的 TOP grammar 规则以声明 $*CUR_BLOCK，就像我们在 Rubyish 中所做的那样，并对 action 方法进行匹配更新。\n接下来，实现变量解析。 再一次，您可以从我们在 Rubyish 中所做的工作中获得灵感，但变量命名规则如下：\n变量以 $ 符号开头，后跟变量名。 变量名必须以字母或下划线字符开头（不是数字） 变量名只能包含字母数字字符和下划线（A..Z，a..z，0..9，和 _） 还要记住 PHP 不是面向行的。 完成后，您应该能够执行以下程序:\n$emotion = \u0026quot;awesome\u0026quot;; echo \u0026quot;PHP is \u0026quot; . $emotion . \u0026quot;\\n\u0026quot;; $emotion = $emotion . \u0026quot;st\u0026quot;; echo \u0026quot;Raku is \u0026quot; . $emotion . \u0026quot;\\n\u0026quot;; 额外任务: functions 实现带参数和参数传递的函数！ 完成后，您应该能够运行：\nfunction greet($name) { echo \u0026quot;Good day, \u0026quot; . $name . \u0026quot;\\n\u0026quot;; } greet(\u0026quot;Lena\u0026quot;); 你可以从 Rubyish 的例子中汲取灵感。 但是，您还需要注意确保函数声明后面不需要分号。\n练习 6 这个练习是为了在第一天结束时填补时间，如果我们以某种方式通关了！ 以下是您可以做的一些想法。\n基本的数字关系运算符 现在，我们将忽略 PHP 的关系运算符所做的类型杂耍，以处理字符串和数字，并处理数字情况。 PHP 有两个比较运算符的优先级：\nTighter level: \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= Looser level: == != 它们同时比加法操作更宽松，比赋值操作更紧凑。 不需要任何 action 方法，因为： \b:op\u0026lt;...\u0026gt; 可以在 \u0026lt;O(...)\u0026gt; 中使用。\nif/else if/else 既然我们有关系运算符，那么实现 if 语句是有意义的。 从简单开始：\nif ($a \u0026gt; $b) { echo \u0026quot;a is bigger than b\u0026quot;; } 然后添加 else:\nif ($a == $b) { echo \u0026quot;a is the same as b\u0026quot;; } else { echo \u0026quot;a and b differ\u0026quot;; } 最后添加上 elseif:\nif ($a \u0026gt; $b) { echo \u0026quot;a is bigger than b\u0026quot;; } elseif ($a == $b) { echo \u0026quot;a is equal to b\u0026quot;; } else { echo \u0026quot;a is smaller than b\u0026quot;; } 要更好地理解如何处理 elseif，请阅读 NQP 的 grammar 和 action 中的适用代码。 在 grammar 和 action 中搜索 statement_control:sym\u0026lt;if\u0026gt; 。\n最后但并非最不重要的，您甚至可能想尝试实现悬空形式：\nif ($a \u0026gt; $b) echo \u0026quot;a is bigger than b\u0026quot;; 似乎在 elseif 和 else 形式中还有其他奇妙的违规行为，其中也涉及冒号，谁知道它是什么。 但如果你这样做，最好去喝点酒。 或者，我也不知道。\nwhile 循环 解析并实现 while 循环:\n$i = 1; while ($i \u0026lt;= 10) { $i = $i + 1; echo $i; } 恭喜。你的 PHP 实现现在是图灵完备的了，现在一切就绪了！ (旁白：实际上图灵完成的时间早一些，因为递归函数和 while 循环是等价的。)\n练习 7 在本练习中，您将为类，方法，对 PHPish 的 new 运算符和方法调用添加基本支持。当你完成后，你应该能够运行：\nclass Greeter { function greet($who) { echo \u0026quot;Greetings, \u0026quot; . $who . \u0026quot;\\n\u0026quot;; } } $g = new Greeter(); $g-\u0026gt;greet(\u0026quot;Anna\u0026quot;); 首先, 元对象 创建一个简单的元对象，就像 Rubyish 一样，可以支持添加和查找方法。\n接下来，解析类并为它们生成代码 基础知识类似于 Rubyish：类中的函数成为类的方法。因此，您可以窃取该方法，确保使用 PHP 语法。\n添加新项 这非常相似，你几乎可以直接从 Rubyish 窃取它。请注意不同的空格规则（换行符并不重要）。\n添加方法调用 再次，类似的方法工作，模数语法：方法调用运算符是 -\u0026gt;。添加之后，您应该能够运行本节开头的程序 - 但它仍然会失败。问题是我们没有让方法接受调用者（它们所调用的对象）。\n支持 $this 方法的第一个参数是调用它的对象。在 PHP 中，这被分配给 $this。因此，在类中时，请确保函数始终使用 $this 作为第一个参数。\n好吧，这是很多复制粘贴\u0026hellip; 对。大多数基于类的对象系统在这个级别上相对类似。尽管如此，你自己有希望能把它们整合到一块儿会让整个事情变得不那么神奇！\n顺便说一下，现在你支持 $this，这也应该有效：\nclass Greeter { function greet($who) { $this-\u0026gt;greet_custom(\u0026quot;Hej\u0026quot;, $who); } function greet_custom($greeting, $who) { echo $greeting . \u0026quot;, \u0026quot; . $who . \u0026quot;\\n\u0026quot;; } } $g = new Greeter(); $g-\u0026gt;greet(\u0026quot;masak\u0026quot;); 练习 8 在本练习中，您将稍微扩展 PHPish 对象系统。。。或许很多。\nMethod 缓存 首先，使用方法在 NQP 中手动创建一个新的 PHP 类。它看起来像这样：\nmy $c := PHPClassHOW.new_type(:name('Foo')); $c.HOW.add_method($c, 'bar', -\u0026gt; $obj { 1 }); 计算 100,000 次方法调用的时间。\nmy $start := nqp::time_n(); my int $i := 0; while $i \u0026lt; 100000 { $obj.bar(); $i++; } say(nqp::time_n() - $start); 在您的 PHPClassHOW 中添加一个 compose 方法。在其中，使用 setmethcache 指令。您现在可以使用 %!methods 作为方法缓存散列。添加对您的 compose 方法的调用。重复计时。缓存应该更快（在练习题作者的机器上，没有缓存是 0.194s, 有缓存是 0.066s）。 现在，更新 statement:sym\u0026lt;class\u0026gt; action 方法中的代码, 以便在添加所有方法后调用 compose 方法。\n继承 这是我们想要让其能够工作的例子：\nclass Dog { function bark() { echo \u0026quot;woof!\\n\u0026quot;; } function smell() { echo \u0026quot;terrible\\n\u0026quot;; } } class Puppy extends Dog { function bark() { echo \u0026quot;yap!\\n\u0026quot;; } } $d = new Dog(); $d-\u0026gt;bark(); $d-\u0026gt;smell(); $p = new Puppy(); $p-\u0026gt;bark(); $p-\u0026gt;smell(); 首先，从解析开始。它是解析类声明的一个非常小的补充，可选择接受 extends 关键字。一旦它解析，你应该能够运行程序，但它将无法进行最后的 smell 调用，因为它是继承的，我们还没有继承。\n接下来，更新类的 action 方法。在添加方法的代码之前，如果有 extends，请在元对象上添加一个对 add_parent 的调用（稍后会写入）。要查找父级，请使用作用域设置为 lexical 的 QAST::Var 节点。\n您现在应该收到一条错误消息，指出 add_parent 尚未被实现。从这里开始，所有工作都将在 PHPClassHOW 中进行。\n添加属性 @!parents。实现将添加到此数组的 add_parent，但仅限于还没有存在父级。如果有，那么 nqp::die 就可以了。这应该清除错误，但同样，最后的ssnell 调用还不起作用。\n接下来，更新 find_method 方法。如果要搜索的方法不在 %!methods 中，则应该查看所有父项的方法表。为此，您需要实现方法 parent 和 method_table，以便从基类获取所需的信息。\n到目前为止，事情应该能工作 - 但效率不高！为此，您现在还应该更新方法缓存。您可以通过在 find_method 中添加调试语句来确保正确执行此操作，如果缓存正在运行，则不应调用该语句。\n如果时间允许: interfaces 在 PHP 中，接口表示要求某个方法列表由声明它实现它的任何类提供。例如，给定：\ninterface iBarkable { function bark(); } 那么这个类就是好的:\nclass Dog implements iBarkable { function bark() { echo \u0026quot;woof!\\n\u0026quot;; } function smell() { echo \u0026quot;terrible\\n\u0026quot;; } } 而这个类应该导致错误:\nclass BadDog implements iBarkable { function smell() { echo \u0026quot;terrible\\n\u0026quot;; } } 因为它缺少 bark 方法。 您的目标是实现此功能。 这里有一些提示。\n首先在其中添加对接口和方法需求的解析。 一旦有效，编写一个 PHPInterfaceHOW，可用于保存所需方法的列表。 因为你应该使用 Uninstantiable REPR, 因为不允许创建接口的实例。 将 implements 关键字解析添加到 class 声明中。 设置在 PHPClassHOW 上调用 add_interface 方法的 action 方法，应该将接口添加到 @!interfaces 属性。 你现在应该发现上面的例子都编译了，但第二个例子没有被拒绝。 为了实现这一点，在 PHPClassHOW 的 compose 方法中，编写代码，获取每个接口需求方法的列表。并检查类是否提供它们。 练习 9 本练习将带您进行正则表达式实现的简短介绍。\n解析和 actions 运行以下代码:\nnqp --rxtrace -e \u0026quot;/a+/\u0026quot; 现在，让我们试着理解它。\n在 NQP 仓库中, 打开 src/NQP/Gramamr.nqp 并定位到 quote:sym\u0026lt;/ /\u0026gt;。 观察到它调用了 LANG, 那是做语言切换. 这可以在 src/HLL/Grammar.nqp 中找到。 注意它如何使用编织，还有切换操作以及语言类型。\n下面, 打开 src/QRegex/P6Regex/Grammar.nqp 并定位到 nibbler。尝试挑出对 termaltseq 的调用. 看看 termaltseq 自身, 然后该 action 方法所在的 Action 文件。 往下找, 找到 termish, 并尝试理解它在那儿做什么: 处理不同的备选分支和连词的相对优先级。\n再往下, 看看下面的 atom。 注意这里我们的正则表达式中的 a 是怎样被解析的。然后回头查看 quantified_atom。 阅读 action 方法，看看原子如何放入量词节点。\n您可能希望探索如何处理其他一些结构。\n探索嵌入式代码块 在 NQP grammar 中, 查看 NQP::Regex。 注意它是你正在看的基本 QRegex::P6Regex::Grammar 的一个子类。这是 grammar 真正成为类的力量的一部分：我们可以将它们子类化以专门化它们。\n让我们来看一下 /[a { say('here') }]+/ 是怎样被处理的. 这很有趣, 因为我们从 NQP 开始, 然后解析正则表达式语法, 然后以在块中再次解析 NQP 代码结束。定位到 assertion:sym\u0026lt;{ }\u0026gt;, 然后查看 codeblock。 享受相对简单的事情!\n看一下 NQP::RegexActions 里面的 codeblock action 方法。 你能弄清楚发生了什么吗？ 如果没有，请问你的老师或你周围的人！\n探索 NFAs 保存的 NFA 形式存储在规则的代码对象中。 因此，我们可以获得它并返回到一个对象，如下所示：\ngrammar Example { token t { 'foo' } } my $t := nqp::findmethod(Example, 't'); my $nfa := QRegex::NFA.from_saved($t.NFA()); 但是怎么办呢？ 接下来，打开 src/QRegex/NFA.nqp。 查看顶部附近的边缘类型常量列表。 NFA 的整体结构是列表。 外部列表表示状态 - 图中的节点。 每个节点由其出局边缘列表组成，由 3 个值表示：\n一个 action，它是 NFA.nqp 顶部的边缘类型常量之一 action 的参数 如果我们匹配，将转到下一个状态的索引 我们可以写一些代码来转储这个：\nmy $i := 0; for $nfa.states -\u0026gt; @edges { say(\u0026quot;State $i\u0026quot;); for @edges -\u0026gt; $act, $arg, $to { say(\u0026quot; $act ($arg) ==\u0026gt; $to\u0026quot;); } $i++; } 对于我们的简单示例，我们得到:\nState 0 State 1 2 (102) ==\u0026gt; 2 State 2 2 (111) ==\u0026gt; 3 State 3 2 (111) ==\u0026gt; 0 边缘类型 2 表示代码点，这里的参数是我们应该匹配的字符代码，如果我们要进入下一个状态。 看看我们如何从状态 1 开始，到达状态 0 是成功的。 在 token 中尝试一些不同的东西，看看 NFA 是什么样的。 这是一些想法。\na+ \u0026lt;[abc]\u0026gt; \u0026lt;[abc]\u0026gt;* \u0026lt;foo\u0026gt;? \\w* :i abc :i a+ "},"name":"NQP 练习题","published":"2019-07-20T11:05:26+08:00","summary":"练习 1 本练习将让您在 NQP 中执行一些简单的任务，以熟悉基本语法。\nHello, world 最简单的事情:\nsay('Hello, world'); 现在把它弄错:\nsay 'Hello, world'; 请注意你将如何大声地抱怨。\n变量 将值绑定到标量。 使用 say 来输出它. 尝试使用赋值代替绑定。 观察它的失败。 声明一个数组。 使用索引, 例如 @a[0], 去绑定并访问元素。 注意在 Raku 中, 符号是不变的; 使用 $a[0] 则会抱怨未声明的 $a! 尝试绑定一个数组字面量, 例如 [1,2,3] 到一个 @arr 变量上。现在把该数组字面量绑定到一个 $scalar 变量上。注意观察索引是怎样在这两种结构上都工作良好的。 声明一个哈希变量, %h. 尝试使用字面值语法索引 (%h\u0026lt;key\u0026gt;) 和花括号语法索引 (%h{'key'})。 循环 使用 for 来迭代数组, 一次迭代一个元素, 先使用 $_ 迭代, 然后使用 pointy block (for @a -\u0026gt; $val { ... }) 迭代。 你可以一次迭代两个元素吗？ 试试看！ 迭代散列变量, 打印出该散列每个 pair 对儿的 .","type":"entry","url":"http://localhost:1313/notes/nqp-exercises/"}