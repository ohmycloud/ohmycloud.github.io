<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
    
    
    

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    
    <meta name="referrer" content="no-referrer">

    <title>
        
            beauty-is-best ❚ 焉知非鱼
        
    </title>

    
    


    
    
    
    

    
    
    
    

    
    
    

    
    
    
    <style>
     
     
     :root {
         --theme-color: #ac4142;
         --theme-color-light: rgba(172, 65, 66, 0.2);
     }
     
     html {
         line-height: 1.5;
     }
    </style>

    
    

    
    
    
    
    <link rel="stylesheet" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css">
    
    <link rel="preload" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css" as="style">

    



    
        <style>
         
         /* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }

         
         /* Overrides on top of the theme and Chroma CSS */
/* Chroma-based lines highlighting in code blocks */
.chroma .hl {
    background-color: #e8e8e8;
    /* Extend highlight up to 100 characters (assuming that the code blocks never have more than 100 characters in a line) */
    min-width: 100ch;
}
/* GenericHeading */ .chroma .gh { color: #999999; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa; font-weight: bold }

         
        </style>
    

    

    
    
    

    
    <script src="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js"></script>
    
    <link rel="preload" href="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js" as="script">

    
    
    <script defer src="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js"></script>
    
    <link rel="preload" href="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js" as="script">

    

    

    
    
    

    
    
<!-- rel="me" links for IndieAuth -->







    
 
<meta property="og:title" content="beauty-is-best" />
<meta property="og:description"
      content=" " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ohmyweekly.github.io/notes/beauty-is-best/" />


    
        <meta property="article:published_time" content="2019-09-18T23:20:11&#43;00:00"/>
    
    
        <meta property="article:modified_time" content="2019-09-18T23:20:11&#43;00:00"/>
    









    




     <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="beauty-is-best"/>
<meta name="twitter:description" content=" "/>


    
    
    <link rel="alternate" type="application/jf2post+json" href="https://ohmyweekly.github.io/notes/beauty-is-best/jf2post.json" title="Jf2post for 焉知非鱼" />
    
     



    
    
    
        
    


     
        
        <meta name="DC.Creator" content="焉知非鱼"/>
    



    
    
    
    <meta name="hugo-build-date" content="2024-03-01T16:16:06Z"/>
    <meta name="hugo-commit-hash" content="312735366b20d64bd61bff8627f593749f86c964"/>
    <meta name="generator" content="Hugo 0.123.7">
</head>


    
        <body lang="en">
    

        
        <div class="border" id="home"></div>

        <div class="wrapper">   
            
<nav id="nav" class="nav-collapse opened" aria-hidden="false">
    <ul class="navbar">
        <li><a class="" href="/">Home</a></li>
        
            
                <li><a class="" href="https://ohmyweekly.github.io/posts/">Posts</a></li>
            
        
            
                <li><a class="" href="https://ohmyweekly.github.io/notes/">Notes</a></li>
            
        
        
            <li><a class="" href="https://ohmyweekly.github.io/search/">Search</a></li>
        
    </ul>
</nav>

            <div class="container">
                <header class="masthead">
                    <div class="masthead-title no-text-decoration">
                        <a href="/">焉知非鱼</a> <span class="blinking-cursor">❚</span>
                    </div>
                    <div class="masthead-tagline">
                        Wait the light to fall
                    </div>
                </header>

                








<article class="post h-entry notes">
    <header>
        <div class="center">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>

        <h1 class="post-title p-name">beauty-is-best</h1>

        
        <data class="u-url" value="https://ohmyweekly.github.io/notes/beauty-is-best/"></data>

        <div class="date-syndication">
            


    
    
    <div class="post-date">
        
        <time datetime="2019-09-18T23:20:11+0000" class="dt-published">Wed Sep 18, 2019</time>
        
        
    </div>


            




        </div>
         



    
    
    
        
    


    
        
        <span class="hide">
            &mdash; <a href="https://ohmyweekly.github.io/" class="u-author">焉知非鱼</a>
        </span>
    


    </header>

    <div class="content">
        


        





                       


        <div class="e-content">
            




<blockquote>
<p>狂热的，贪婪的本性是太少</p>
</blockquote>
<p>20 年前，我首次涉足 Perl 编程的工作之一是使用一种纯文本工具，分析其结构并为给定的线宽整齐地设置其格式的工具。 这是一个中等复杂的换行应用程序，我每天都使用它来整理电子邮件通信，软件文档和博客条目。</p>
<p>因此，第 19 届 Perl 每周挑战赛的第二项任务-实现&quot;贪婪的&quot;换行算法-在许多方面对我来说是一个老朋友。</p>
<p>贪婪的换行只是将输入文本中的每个单词都添加到输出的当前行中，除非这样做会导致输出行超出所需的最大行宽，在这种情况下，它会在该点断开行并继续填充第二行，等等。 因此，一个 45 列的贪婪包装的段落如下所示：</p>
<pre><code>  It is a truth universally acknowledged, that
  a single man in possession of a good fortune
  must be in want of a wife. However little
  known the feelings or views of such a man may
  be on his first entering a neighbourhood,
  this truth is so well fixed in the minds of
  the surrounding families, that he is
  considered the rightful property of some one
  or other of their daughters.
</code></pre>
<p>生成的文本有些不平衡，并且在右边距处进行了粗糙处理，但在要求的宽度内，并且可读性强。 而且该算法非常简单，可以在一个 Raku 语句中实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="o">:</span><span class="nv">$width</span> <span class="o">=</span> <span class="mi">80</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="vg">$*IN</span><span class="o">.</span><span class="nb">slurp</span><span class="o">.</span><span class="nb">words</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nv">$width</span><span class="p">}</span><span class="sr">  </span><span class="o">)&gt;</span><span class="sr">  </span><span class="p">[&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="ni">$</span><span class="p">]</span><span class="sr"> </span><span class="p">/)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="se">\n</span><span class="p">&#34;)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="nb">say</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们采用 STDIN 输入流(<code>$*IN</code>)，对整个输入进行混搭(<code>.slurp</code>)，将其分解为单词(<code>.words</code>)。 我们用每个(<code>.join(' ')</code>)之间的单个空格重新连接这些单词，并将文本分成不超过宽度字符(<code>.comb(/.** {1 .. $width}</code>) 的行，假设每一行也以前面是空格或字符串结尾(<code>)&gt; [' '| $]</code>）的单词边界。 最后，我们用换行符(<code>.join(&quot;\n&quot;)</code>)将这些行重新连接起来并打印它们(<code>.say</code>)。</p>
<p>这是解决特定挑战的合理单行方案，但我们可以做得更好。</p>
<p>首先，存在一个我们尚未处理的隐患。 也就是说，如果您是一位健康状况堪忧的威尔士前矿工，该怎么办呢？</p>
<pre><code>  Look you, I shall have to be terminating my interdisciplinary
  investigation of consanguineous antidisestablishmentarianism
  in Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch.
  For I've just been electrophotomicrographically diagnosed with
  pseudopneumonoultramicroscopicsilicovolcanoconiosis, isn't it?
</code></pre>
<p>重新格式化此输入格式时，我们的单行语句解决方案惨遭失败，因为它无法正确分开城镇或疾病的过长名称。 由于每个字符都有 45 个以上的字符，因此正则表达式必须跳过很长的单词，并根据需要省略尽可能多的前导字符，直到再次找到 45 个结尾字符后跟一个空格。 这样我们得到：</p>
<pre><code>  Look you, I shall have to be terminating my
  interdisciplinary investigation of
  consanguineous antidisestablishmentarianism
  in
  yngyllgogerychwyrndrobwllllantysiliogogogoch.
  For I've just been
  electrophotomicrographically diagnosed with
  neumonoultramicroscopicsilicovolcanoconiosis,
  isn't it?
</code></pre>
<p>除了被斩首的单词之外，当算法被迫将诸如 &ldquo;consanguineous&rdquo; 和 &ldquo;electrophotomicrographically&rdquo; 之类的下划线转移到下一行时，我们还得到了一个荒谬的不平衡右边界。</p>
<p>当然，解决这两个问题并不难。 我们只是给正则表达式一个后备选项：如果由于单词太长而不能在单词边界处断行，我们允许它在内部使该单词断开，前提是该断开距离两端都不太近的单词（例如，$minbreak 中的至少五个字符）。</p>
<p>我们还限制它以不小于指定宽度（即 $minwidth）的 80% 的形式折断常规行，以避免在右边距处出现那些文本裂缝：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="o">:</span><span class="nv">$width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nf">greedy-wrap</span><span class="p">(</span> <span class="vg">$*IN</span><span class="o">.</span><span class="nb">slurp</span><span class="o">,</span> <span class="o">:</span><span class="nv">$width</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">greedy-wrap</span><span class="p">(</span> <span class="nv">$text</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="o">:</span><span class="nv">$width</span>    <span class="o">=</span> <span class="mi">80</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="o">:</span><span class="nv">$minwidth</span> <span class="o">=</span> <span class="nb">floor</span><span class="p">(</span><span class="mf">0.8</span> <span class="o">*</span> <span class="nv">$width</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="o">:</span><span class="nv">$minbreak</span> <span class="o">=</span> <span class="mi">5</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$text</span><span class="o">.</span><span class="nb">words</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;)</span>
</span></span><span class="line"><span class="cl">         <span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nv">$width</span><span class="p">}</span><span class="sr">  </span><span class="ni">$</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">               </span><span class="o">|</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="nv">$minwidth</span><span class="o">..</span><span class="nv">$width</span><span class="p">}</span><span class="sr">  </span><span class="o">)&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">               </span><span class="o">|</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="nv">$minbreak</span><span class="o">..</span><span class="nv">$width</span><span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">                      </span><span class="p">&lt;</span><span class="nf">before</span><span class="sr"> </span><span class="se">\S</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="nv">$minbreak</span><span class="p">}&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">               </span><span class="p">/)</span>
</span></span><span class="line"><span class="cl">         <span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="se">\n</span><span class="p">&#34;)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这个版本中，<code>.comb</code> 正则表达式规定，除了最后一行(<code>. ** {$minwidth..$width}</code>)之外，我们必须用文字填充至少80%的要求宽度(<code>. ** {1. $width}$</code>)，除此之外，我们可以取任何数量的字符，只要我们至少取5个字符（<code>. ** {$minbreak..$width}</code>），并且在下一行的开始处也留下至少5个可见字符（<code>&lt;before \S ** {$minbreak}&gt;</code>）。</p>
<p>这个版本会产生一个更统一的包装:</p>
<pre><code>  Look you, I shall have to be terminating my
  interdisciplinary investigation of consangui
  neous antidisestablishmentarianism in
  Llanfairpwllgwyngyllgogerychwyrndrobwllllanty
  siliogogogoch. For I've just been electrophot
  omicrographically diagnosed with pseudopneumo
  noultramicroscopicsilicovolcanoconiosis,
  isn't it?
</code></pre>
<p>除了较长的词现在被毫不客气地砍掉了，甚至连插值的共轭词的礼貌都没有。所以，我们需要在管道中多加一个步骤，在需要的地方加上连字符:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">greedy-wrap</span><span class="p">(</span> <span class="nv">$text</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="o">:</span><span class="nv">$width</span>    <span class="o">=</span> <span class="mi">80</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="o">:</span><span class="nv">$minwidth</span> <span class="o">=</span> <span class="nb">floor</span><span class="p">(</span><span class="mf">0.8</span> <span class="o">*</span> <span class="nv">$width</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="o">:</span><span class="nv">$minbreak</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$text</span><span class="o">.</span><span class="nb">words</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;)</span>
</span></span><span class="line"><span class="cl">         <span class="o">.</span><span class="nb">match</span><span class="p">(/</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="mi">1</span><span class="o">..</span><span class="nv">$width</span><span class="p">}</span><span class="sr">  </span><span class="ni">$</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">                </span><span class="o">|</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="nv">$minwidth</span><span class="o">..</span><span class="nv">$width</span><span class="p">}</span><span class="sr">  </span><span class="o">)&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">                </span><span class="o">|</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="nv">$minbreak</span><span class="o">..</span><span class="nv">$width-1</span><span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">                       </span><span class="p">&lt;</span><span class="nv">broken</span><span class="o">=</span><span class="sr">before</span> <span class="sr">\S</span> <span class="sr">**</span> <span class="sr">{</span><span class="nv">$minbreak</span><span class="sr">}</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">                </span><span class="p">/</span><span class="o">,</span> <span class="p">:</span><span class="s">global</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="nv">$^word</span><span class="o">.</span><span class="p">&lt;</span><span class="s">broken</span><span class="p">&gt;</span> <span class="o">??</span> <span class="p">&#34;</span><span class="nv">$^word-</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="nv">$^word</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">         <span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="se">\n</span><span class="p">&#34;)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这个版本中，我们使用全局的 <code>.match</code> 而不是 <code>.comb</code> 来将文本分成几行，因为我们需要将长词打碎，只差一个字符的最大宽度(<code>. ** {$minbreak..$width-1}</code>)，然后将这些行标记为已打碎(<code>&lt;broken=before \S ** {$minwidth}&gt;</code>)，再给这些行加上一个连字符(<code>$^word.&lt;broken&gt;??&quot;$^word-&quot;!$^word</code>)。</p>
<p>这就产生了:</p>
<pre><code>  Look you, I shall have to be terminating my
  interdisciplinary investigation of consangui-
  neous antidisestablishmentarianism in
  Llanfairpwllgwyngyllgogerychwyrndrobwllllant-
  ysiliogogogoch. For I've just been electroph-
  otomicrographically diagnosed with pseudopne-
  umonoultramicroscopicsilicovolcanoconiosis,
  isn't it?
</code></pre>
<p>你好，TEX</p>
<p>即使我们做了改进，贪婪的换行算法也经常产生丑陋的不平衡段落。例如:</p>
<pre><code>  No one would have believed, in the last years
  of the nineteenth century, that human affairs
  were being watched from the timeless worlds
  of space. No one could have dreamed that we
  were being scrutinised as someone with a
  microscope studies creatures that swarm and
  multiply in a drop of water. And yet, across
  the gulf of space, minds immeasurably
  superior to ours regarded this Earth with
  envious eyes, and slowly, and surely, they
  drew their plans against us...
</code></pre>
<p>1981 年，唐纳德-克努斯和迈克尔-普拉斯公布了一种将文本断行的算法，作为 TEX 排版系统的一部分加以实施。该算法考虑了文本中每一个可能插入断行的点，然后找到这些点的子集，产生最均匀的整体结果。</p>
<p>当然，这比贪婪算法的先入为主的方法要复杂得多，成本也高得多。事实上，由于它要考虑从 N 个词中的每一个词开始建立一条线，并运行到 N-M 个后续词中的每一个词，因此，它显然要需要 <code>O(N²)</code> 的空间和时间来计算，而贪婪算法则是节俭的 <code>O(N)</code>。在一个典型的段落上，比如上面的例子，TEX 算法的运行速度要慢60倍左右。</p>
<p>但由于大多数段落都很短（50到100字），N² 的成本通常是可以接受的。所以这里是该方法的一个简单版本，在 Raku 中:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nf">TeX-wrap</span> <span class="p">(</span><span class="nv">$text</span><span class="o">,</span> <span class="o">:</span><span class="nv">$width</span> <span class="o">=</span> <span class="mi">80</span><span class="o">,</span> <span class="o">:</span><span class="nv">$minbreak</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Extract individual words, hyphenating if necessary...</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">@words</span> <span class="o">=</span> <span class="nv">$text</span><span class="o">.</span><span class="nb">words</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">my</span> <span class="nv">@breaks</span> <span class="o">=</span> <span class="o">.</span><span class="nb">comb</span><span class="o">:</span> <span class="nv">$width-$minbreak</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="nv">@breaks</span><span class="o">[</span><span class="mi">0</span><span class="o">..*-</span><span class="mi">2</span><span class="o">]</span> <span class="o">»~=»</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">                        <span class="o">|</span><span class="nv">@breaks</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Compute handy text statistics...</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">@word-len</span>   <span class="o">=</span> <span class="nv">@words</span><span class="o">».</span><span class="nb">chars</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$word-count</span> <span class="o">=</span> <span class="nv">@words</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># These track EOL gaps, plus cost and position of breaks...</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">@EOL-gap</span>    <span class="o">=</span> <span class="o">[</span><span class="mi">0</span> <span class="ow">xx</span> <span class="nv">$word-count</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="ow">xx</span> <span class="nv">$word-count</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">@line-cost</span>  <span class="o">=</span> <span class="o">[</span><span class="mi">0</span> <span class="ow">xx</span> <span class="nv">$word-count</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="ow">xx</span> <span class="nv">$word-count</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">@total-cost</span> <span class="o">=</span>  <span class="mi">0</span> <span class="ow">xx</span> <span class="nv">$word-count</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">@break-pos</span>  <span class="o">=</span>  <span class="mi">0</span> <span class="ow">xx</span> <span class="nv">$word-count</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Build table of EOL gaps for lines from word i to word j...</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="nv">$word-count</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nv">@EOL-gap</span><span class="o">[</span><span class="nv">$i</span><span class="o">][</span><span class="nv">$i</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$width</span> <span class="o">-</span> <span class="nv">@word-len</span><span class="o">[</span><span class="nv">$i-1</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="nv">$i</span><span class="o">+</span><span class="mi">1</span> <span class="o">..</span> <span class="nv">$word-count</span> <span class="k">-&gt;</span> <span class="nv">$j</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nv">@EOL-gap</span><span class="o">[</span><span class="nv">$i</span><span class="o">][</span><span class="nv">$j</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">                    <span class="o">=</span> <span class="nv">@EOL-gap</span><span class="o">[</span><span class="nv">$i</span><span class="o">][</span><span class="nv">$j-1</span><span class="o">]</span> <span class="o">-</span> <span class="nv">@word-len</span><span class="o">[</span><span class="nv">$j-1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Work out the cost of a line built from word i to word j...</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span>  <span class="mi">1</span><span class="o">..</span><span class="nv">$word-count</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nv">$i</span><span class="o">..</span><span class="nv">$word-count</span> <span class="k">-&gt;</span> <span class="nv">$j</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Overlength lines are infinitely expensive...</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nv">@EOL-gap</span><span class="o">[</span><span class="nv">$i</span><span class="o">][</span><span class="nv">$j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nv">@line-cost</span><span class="o">[</span><span class="nv">$i</span><span class="o">][</span><span class="nv">$j</span><span class="o">]</span> <span class="o">=</span> <span class="no">Inf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># A short final line costs nothing...</span>
</span></span><span class="line"><span class="cl">            <span class="k">elsif</span> <span class="nv">$j</span> <span class="o">==</span> <span class="nv">$word-count</span> <span class="o">&amp;&amp;</span> <span class="nv">@EOL-gap</span><span class="o">[</span><span class="nv">$i</span><span class="o">][</span><span class="nv">$j</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nv">@line-cost</span><span class="o">[</span><span class="nv">$i</span><span class="o">][</span><span class="nv">$j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># Cost of other lines is sum-of-squares of EOL gaps...</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nv">@line-cost</span><span class="o">[</span><span class="nv">$i</span><span class="o">][</span><span class="nv">$j</span><span class="o">]</span> <span class="o">=</span> <span class="nv">@EOL-gap</span><span class="o">[</span><span class="nv">$i</span><span class="o">][</span><span class="nv">$j</span><span class="o">]</span>²<span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Walk through cost table, finding the least-cost path...</span>
</span></span><span class="line"><span class="cl">        <span class="nv">@total-cost</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="nv">$word-count</span> <span class="k">-&gt;</span> <span class="nv">$j</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nv">@total-cost</span><span class="o">[</span><span class="nv">$j</span><span class="o">]</span> <span class="o">=</span> <span class="no">Inf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="nv">$j</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># Do words i to j (as a line) reduce total cost???</span>
</span></span><span class="line"><span class="cl">                <span class="k">my</span> <span class="nv">$line-ij-cost</span> <span class="o">=</span> <span class="nv">@total-cost</span><span class="o">[</span><span class="nv">$i-1</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">                                 <span class="o">+</span> <span class="nv">@line-cost</span><span class="o">[</span><span class="nv">$i</span><span class="o">][</span><span class="nv">$j</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nv">$line-ij-cost</span> <span class="o">&lt;</span> <span class="nv">@total-cost</span><span class="o">[</span><span class="nv">$j</span><span class="o">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nv">@total-cost</span><span class="o">[</span><span class="nv">$j</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$line-ij-cost</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="nv">@break-pos</span><span class="o">[</span><span class="nv">$j</span><span class="o">]</span>  <span class="o">=</span> <span class="nv">$i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Extract minimal-cost lines backwards from final line...</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">join</span> <span class="p">&#34;</span><span class="se">\n</span><span class="p">&#34;</span><span class="o">,</span> <span class="nb">reverse</span> <span class="k">gather</span> <span class="k">loop</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">state</span> <span class="nv">$end-word</span> <span class="o">=</span> <span class="nv">$word-count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">my</span> <span class="nv">$start-word</span> <span class="o">=</span> <span class="nv">@break-pos</span><span class="o">[</span><span class="nv">$end-word</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nb">take</span> <span class="nv">@words</span><span class="o">[</span><span class="nv">$start-word</span><span class="o">..</span><span class="nv">$end-word-1</span><span class="o">].</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$end-word</span> <span class="o">=</span> <span class="nv">$start-word</span> <span class="ow">or</span> <span class="nb">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>它比贪婪算法慢，也复杂得多，但是，就像生活中的许多其他方面一样，你得到了你所付出的东西&hellip;&hellip;因为它也能产生更好的行包，比如这些:</p>
<pre><code>  No one would have believed, in the last years
  of the nineteenth century, that human affairs
  were being watched from the timeless worlds
  of space. No one could have dreamed that
  we were being scrutinised as someone with
  a microscope studies creatures that swarm
  and multiply in a drop of water. And yet,
  across the gulf of space, minds immeasurably
  superior to ours regarded this Earth with
  envious eyes, and slowly, and surely, they
  drew their plans against us...

  It is a truth universally acknowledged, that
  a single man in possession of a good fortune
  must be in want of a wife. However little
  known the feelings or views of such a man
  may be on his first entering a neighbourhood,
  this truth is so well fixed in the minds
  of the surrounding families, that he is
  considered the rightful property of some one
  or other of their daughters.

  Look you, I shall have to be terminating
  my interdisciplinary investigation of
  consanguineous antidisestablishmentarianism
  in Llanfairpwllgwyngyllgogerychwyrndrobwlll-
  lantysiliogogogoch. For I've just been
  electrophotomicrographically diagnosed with
  pseudopneumonoultramicroscopicsilicovolc-
  anoconiosis, isn't it?
</code></pre>
<p>慢就是顺，顺就是快</p>
<p>你得到了你所支付的东西，但没有理由为这些好处支付过高的费用。Knuth/Plass 算法被广泛使用，因此一直是广泛优化努力的主题。现在已经设计出了在线性时间和空间中运行的版本，尽管内在的复杂性总是要到某个地方去，而且它通常会在代码本身&hellip;作为 <code>O(N³)</code> 不可理解。</p>
<p>但并不是所有的优化方案都是脑洞大开的复杂。例如，有一种优雅的<code>O(N * width)</code>算法，它隐含地将文本转换为一个有向图，其中每个节点是一个词，每个边的权重是在该词处断行的成本。然后，通过计算图中最短的路径，可以在线性时间内找到最优的断点。</p>
<p>在 Raku 中，是这样的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nf">shortest-wrap</span> <span class="p">(</span><span class="nv">$text</span><span class="o">,</span> <span class="o">:</span><span class="nv">$width</span> <span class="o">=</span> <span class="mi">80</span><span class="o">,</span> <span class="o">:</span><span class="nv">$minbreak</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Extract and hyphenate individual words (as for TeX)...</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">@words</span> <span class="o">=</span> <span class="nv">$text</span><span class="o">.</span><span class="nb">words</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">my</span> <span class="nv">@breaks</span> <span class="o">=</span> <span class="o">.</span><span class="nb">comb</span><span class="o">:</span> <span class="nv">$width-$minbreak</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="nv">@breaks</span><span class="o">[</span><span class="mi">0</span><span class="o">..*-</span><span class="mi">2</span><span class="o">]</span> <span class="o">»~=»</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">                        <span class="o">|</span><span class="nv">@breaks</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$word-count</span> <span class="o">=</span> <span class="nv">@words</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Compute index positions from start of text to each word...</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">@word-offset</span> <span class="o">=</span> <span class="o">[+]</span> <span class="mi">0</span><span class="o">,</span> <span class="o">|</span><span class="nv">@words</span><span class="o">».</span><span class="nb">chars</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># These track minimum cost, and optimal break positions...</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">@minimum</span>   <span class="o">=</span> <span class="nb">flat</span> <span class="mi">0</span><span class="o">,</span> <span class="no">Inf</span> <span class="ow">xx</span> <span class="nv">$word-count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">@break-pos</span> <span class="o">=</span> <span class="mi">0</span> <span class="ow">xx</span> <span class="nv">$word-count</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Walk through text tracking minimum cost...</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span>    <span class="mi">0</span><span class="o">..</span><span class="nv">$word-count</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nv">$i</span><span class="o">+</span><span class="mi">1</span><span class="o">..</span><span class="nv">$word-count</span> <span class="k">-&gt;</span> <span class="nv">$j</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Compute line width for line from word i to word j...</span>
</span></span><span class="line"><span class="cl">            <span class="k">my</span> <span class="nv">$line-ij-width</span>
</span></span><span class="line"><span class="cl">              <span class="o">=</span> <span class="nv">@word-offset</span><span class="o">[</span><span class="nv">$j</span><span class="o">]</span> <span class="o">-</span> <span class="nv">@word-offset</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span> <span class="o">+</span> <span class="nv">$j</span> <span class="o">-</span> <span class="nv">$i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># No need to track cost for lines wider than maximum...</span>
</span></span><span class="line"><span class="cl">            <span class="nb">last</span> <span class="k">if</span> <span class="nv">$line-ij-width</span> <span class="o">&gt;</span> <span class="nv">$width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># Cost of line increases with square of EOL gap...</span>
</span></span><span class="line"><span class="cl">            <span class="k">my</span> <span class="nv">$cost</span> <span class="o">=</span> <span class="nv">@minimum</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span> <span class="o">+</span> <span class="p">(</span><span class="nv">$width</span> <span class="o">-</span> <span class="nv">$line-ij-width</span><span class="p">)</span>²<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># Track least cost and optimal break position...</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nv">$cost</span> <span class="o">&lt;</span> <span class="nv">@minimum</span><span class="o">[</span><span class="nv">$j</span><span class="o">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nv">@minimum</span><span class="o">[</span><span class="nv">$j</span><span class="o">]</span>   <span class="o">=</span> <span class="nv">$cost</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="nv">@break-pos</span><span class="o">[</span><span class="nv">$j</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Extract minimal-cost lines backwards (as for TeX)...</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">join</span> <span class="p">&#34;</span><span class="se">\n</span><span class="p">&#34;</span><span class="o">,</span> <span class="nb">reverse</span> <span class="k">gather</span> <span class="k">loop</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">state</span> <span class="nv">$end-word</span> <span class="o">=</span> <span class="nv">$word-count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">my</span> <span class="nv">$start-word</span> <span class="o">=</span> <span class="nv">@break-pos</span><span class="o">[</span><span class="nv">$end-word</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nb">take</span> <span class="nv">@words</span><span class="o">[</span><span class="nv">$start-word</span><span class="o">..</span><span class="nv">$end-word-1</span><span class="o">].</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$end-word</span> <span class="o">=</span> <span class="nv">$start-word</span> <span class="ow">or</span> <span class="nb">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>这种方法有时会对断行进行优化，与 TEX 算法略有不同，但总体上总是保持相同的&quot;平衡&quot;外观。例如：</p>
<pre><code>  No one would have believed, in the last
  years of the nineteenth century, that human
  affairs were being watched from the timeless
  worlds of space. No one could have dreamed
  that we were being scrutinised as someone
  with a microscope studies creatures that
  swarm and multiply in a drop of water.
  And yet, across the gulf of space, minds
  immeasurably superior to ours regarded this
  Earth with envious eyes, and slowly, and
  surely, they drew their plans against us...
</code></pre>
<p>这两种&quot;最佳拟合&quot;算法的主要区别在于，最短路径方法试图平衡它所建立的所有线路，包括最后一条线路，所以它倾向于产生一个&quot;正方形&quot;包装，一般线路较短，但最后一条线路较长。</p>
<p>它的运行速度也比 TEX 方法快五倍（但仍比贪婪算法慢十倍）。</p>
<p>惩罚寡妇和孤儿</p>
<p>到目前为止，我们所研究的三种方法都存在一个微妙的问题：它们各自只针对一件事进行优化，而 Greedy wrapping 则是针对最大行宽进行优化，而 TEX wrapping 和 shortest-path wrapping 都是针对最大行平衡（即最小的粗糙度）进行优化。Greedy wrapping 优化了最大的行宽，而 TEX wrapping 和最短路径 wrapping 都优化了最大的行平衡（即最小的粗糙度）。</p>
<p>但是，尽管这些特性都是可取的，我们可能还希望在我们的包装文本中看到其他的排版特性。因为有许多其他的方式可以让一段文字变得丑陋。</p>
<pre><code>  Now is the winter of our discontent made
  glorious summer by this sun of York; and
  all the clouds that lour'd upon our
  house in the deep bosom of the ocean
  buried. Now are our brows bound with
  victorious wreaths; our bruised arms
  hung up for monuments; our stern
  alarums changed to merry meetings, our
  dreadful marches to delightful
  measures.
</code></pre>
<p>除了行文的不均匀性令人不安外，这种包袱也有轻微的刺激性，因为它反复在语法上不合适的地方断行，使单个词（如 &ldquo;and&rdquo;, &ldquo;buried&rdquo;, &ldquo;our&rdquo; 和 &ldquo;measures&rdquo;)）在视觉上与其短语的其他部分隔离开来。</p>
<p>孤立的词在行尾称为寡妇，在行首称为孤儿。通过换行将其与适当的上下文隔离开来，它们会使生成的代码看起来很笨拙，而且格式化很差，特别是当（像这里一样）一个鳏夫也构成了一个段落的最后一行。</p>
<p>通常情况下，可以通过提前或延后一个字的断行来避免产生鳏夫和孤儿。</p>
<pre><code>  Now is the winter of our discontent made
  glorious summer by this sun of York; and all
  the clouds that lour'd upon our house in
  the deep bosom of the ocean buried. Now are
  our brows bound with victorious wreaths;
  our bruised arms hung up for monuments;
  our stern alarums changed to merry meetings,
  our dreadful marches to delightful measures.
</code></pre>
<p>&hellip;但为了达到这种效果，我们的换行算法不仅要意识到它所创建的线条的宽度和平衡，还要意识到文本的内容，以及它选择在哪里断行的美学后果。在实际应用中，这意味着它需要一个更复杂的成本函数来优化。</p>
<p>贪婪算法试图最小化的成本函数只是每行末尾的间隙长度之和:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">cost</span> <span class="p">(</span><span class="nv">@lines</span><span class="o">,</span> <span class="nv">$width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">sum</span> <span class="p">(</span><span class="nv">$width</span> <span class="o">«-«</span> <span class="nv">@lines</span><span class="o">».</span><span class="nb">chars</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>相比之下，TEX 和最短路径算法试图通过最小化平方和来减少线端间隙长度的变化:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">cost</span> <span class="p">(</span><span class="nv">@lines</span><span class="o">,</span> <span class="nv">$width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">sum</span> <span class="p">(</span><span class="nv">$width</span> <span class="o">«-«</span> <span class="nv">@lines</span><span class="o">».</span><span class="nb">chars</span><span class="p">)</span><span class="o">»</span>²
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>但我们可以通过实现和应用更复杂的成本函数，轻松最小化一系列包装行的其他属性。例如，让我们重新设计贪婪算法（我们最快的替代方案），以改善其整体的行平衡，同时减少它在包装文本中留下的寡妇和孤儿的数量。</p>
<p>我们要使用的成本函数是这样的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nf">cost</span> <span class="p">(</span><span class="nv">@lines</span><span class="o">,</span> <span class="nv">$width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="p">(</span><span class="nv">$width</span> <span class="o">«-«</span> <span class="nv">@lines</span><span class="o">.</span><span class="nb">head</span><span class="p">(</span><span class="o">*-</span><span class="mi">1</span><span class="p">)</span><span class="o">».</span><span class="nb">chars</span><span class="p">)</span><span class="o">»</span>³<span class="o">».</span><span class="nb">abs</span><span class="o">.</span><span class="nb">sum</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span> <span class="nv">@lines</span>³
</span></span><span class="line"><span class="cl">        <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">(</span> <span class="nv">@lines</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="n">ORPHANS</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="o">+</span> <span class="nv">@lines</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="n">WIDOWS</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="p">)</span>³<span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>它计算的给定行数的成本是通过量化，然后乘以包装段落的三个理想特征得出的。</p>
<p>统一的包装行，测量为每行的行末间隙的立方之和，除了最后一行:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="nv">$width</span> <span class="o">«-«</span> <span class="nv">@lines</span><span class="o">.</span><span class="nb">head</span><span class="p">(</span><span class="o">*-</span><span class="mi">1</span><span class="p">)</span><span class="o">».</span><span class="nb">chars</span><span class="p">)</span><span class="o">»</span>³<span class="o">».</span><span class="nb">abs</span><span class="o">.</span><span class="nb">sum</span>
</span></span></code></pre></div><p>所产生的段落的紧凑程度，用总行数的立方来衡量: <code>@lines³</code>。</p>
<p>寡妇和孤儿的数量，以找到的孤立词总数的十倍的立方来衡量:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">(</span> <span class="nv">@lines</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="n">ORPHANS</span><span class="p">)</span> <span class="o">+</span> <span class="nv">@lines</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="n">WIDOWS</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>³
</span></span></code></pre></div><p>与理想线条的零成本相比，成本函数使用立方体而不是平方体，以更快地提高引入多个不需要的特征所产生的惩罚。应用于寡妇和孤儿的十因子反映了对它们的特别强大的美学反对（调整这个数字以适应你个人的排版热情水平）。</p>
<p>孤儿和寡妇的检测方法如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">ORPHANS</span> <span class="p">{/</span><span class="sr"> </span><span class="ni">^^</span><span class="sr">  </span><span class="p">\</span><span class="err">S+  &lt;[.!?,;:]&gt;  [\s | $$] </span><span class="p">/}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">WIDOWS</span>  <span class="p">{/</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr">.!?,;:</span><span class="p">]&gt;</span><span class="sr">  </span><span class="p">\</span><span class="err">s+  \S+  $$       </span><span class="p">/}</span>
</span></span></code></pre></div><p>孤字是指行首的一个单字(<code>^^\S+</code>)，后面是任何短语结束的标点符号(<code>&lt;[。!?,;:]&gt;</code>)，后面是空格或行尾(<code>[\s | $$]</code>)。寡妇是紧跟在标点符号后面的一个单字(<code>&lt;[.!?,;:]&gt; \s+ \S+</code>)，也是在行尾(<code>$$</code>)。</p>
<p>有了这个更复杂的成本函数，我们现在可以同时优化结构特性和美学特性。我们还可以扩展这个函数来惩罚其他不需要的人工制品，比如在介绍性介词后断裂的短语，分割的不定式，或者在行末悬空的文章:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nf">ESTRANGED</span> <span class="p">{</span> <span class="p">/</span><span class="sr"> </span><span class="p">\</span><span class="err">s [for|with|by|from|as|to|a|the] $$</span><span class="p">/</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nf">cost</span> <span class="p">(</span><span class="nv">@lines</span><span class="o">,</span> <span class="nv">$width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="p">(</span><span class="nv">$width</span> <span class="o">«-«</span> <span class="nv">@lines</span><span class="o">.</span><span class="nb">head</span><span class="p">(</span><span class="o">*-</span><span class="mi">1</span><span class="p">)</span><span class="o">».</span><span class="nb">chars</span><span class="p">)</span><span class="o">»</span>³<span class="o">».</span><span class="nb">abs</span><span class="o">.</span><span class="nb">sum</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span> <span class="nv">@lines</span>³
</span></span><span class="line"><span class="cl">        <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">(</span> <span class="nv">@lines</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="n">ORPHANS</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="o">+</span> <span class="nv">@lines</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="n">WIDOWS</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="o">+</span> <span class="nv">@lines</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="n">ESTRANGED</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="p">)</span>³<span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>为了使用这样一个复杂的成本函数来优化线路包络，我们需要一种方法来生成备选包络&hellip;然后我们可以评估、比较并从中选择。但是，贪婪的包装方法（事实上，TEX 算法和最短路径技术也是如此）总是只能生成一个包装。我们怎样才能得到更多呢？</p>
<p>一个简单快捷的方法是使用贪婪的方法来生成那些额外的包裹，但是要改变它包裹的宽度。例如，如果我们将同一文本包装到45列，然后再包装到相继缩短的宽度，就像这样:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">    <span class="k">for</span> <span class="mi">45</span><span class="o">...</span><span class="mi">40</span> <span class="k">-&gt;</span> <span class="nv">$width</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$wrapping</span> <span class="o">=</span> <span class="nf">greedy-wrap</span><span class="p">(</span><span class="nv">$text</span><span class="o">,</span> <span class="o">:</span><span class="nv">$width</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$cost</span>     <span class="o">=</span> <span class="nf">cost</span><span class="p">(</span><span class="nv">$wrapping</span><span class="o">.</span><span class="nb">lines</span><span class="o">,</span> <span class="nv">$width</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">[</span><span class="nv">$width</span><span class="s2"> columns --&gt; cost: </span><span class="nv">$cost</span><span class="s2">]</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$wrapping</span><span class="se">\n</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>&hellip;我们得到:</p>
<pre><code>  [45 columns --&gt; cost: 40768]
  Far back in the mists of ancient time, in the
  great and glorious days of the former
  Galactic Empire, life was wild, rich and
  largely tax free.

  [44 columns --&gt; cost: 10051712]
  Far back in the mists of ancient time, in
  the great and glorious days of the former
  Galactic Empire, life was wild, rich and
  largely tax free.

  [43 columns --&gt; cost: 3662912]
  Far back in the mists of ancient time, in
  the great and glorious days of the former
  Galactic Empire, life was wild, rich and
  largely tax free.

  [42 columns --&gt; cost: 851840]
  Far back in the mists of ancient time, in
  the great and glorious days of the former
  Galactic Empire, life was wild, rich and
  largely tax free.

  [41 columns --&gt; cost: 85184]
  Far back in the mists of ancient time, in
  the great and glorious days of the former
  Galactic Empire, life was wild, rich and
  largely tax free.

  [40 columns --&gt; cost: 2752]
  Far back in the mists of ancient time,
  in the great and glorious days of the
  former Galactic Empire, life was wild,
  rich and largely tax free.
</code></pre>
<p>40列包装显然能产生最平衡、最少的孤本或寡本，这一点反映在其最小的成本价值上。当然，我们不再利用整个可用的宽度，但为了大幅增加视觉吸引力，减少10%的行长似乎是可以接受的代价。</p>
<p>更有趣的是，以这种方式产生的40列替代方案也比更复杂的 TEX 算法所产生的包装更好看（不幸的是，TEX 算法把第一行末尾的 &ldquo;in&quot;给忽略了）。</p>
<pre><code>  Far back in the mists of ancient time, in
  the great and glorious days of the former
  Galactic Empire, life was wild, rich and
  largely tax free.
</code></pre>
<p>迭代的贪婪方案也比最短路径的方法要好，这种方法把 &ldquo;时间&quot;寡头化，把 &ldquo;生命&quot;孤儿化，把行数包装得比要求的45列少了整整20%:</p>
<pre><code>  Far back in the mists of ancient
  time, in the great and glorious days
  of the former Galactic Empire, life
  was wild, rich and largely tax free.
</code></pre>
<p>此外，尽管现在技术上是 <code>O(N²)</code>&ndash;因为O(N) <code>greedy-wrap</code> 函数现在必须被调用 <code>N/10</code> 次&ndash;迭代 greedy 技术仍然比 TEX 算法快 25%，比最短路径方法快近 75%。</p>
<p>但我们还可以做得更好。请注意，当我们将封装宽度从45减少到40时，较窄的边距只是有时改变了产生的封装（在这种情况下，只在45、44和40列）。因此，我们实际上做了两倍于严格意义上必要的工作来寻找最佳宽度。</p>
<p>事实证明，如果前一个包装中最长的行的宽度等于或短于下一个候选宽度，那么尝试下一个候选宽度总是白费力气&hellip;因为它必然再次产生完全相同的包装。</p>
<p>所以，我们可以通过跟踪每个包装的实际宽度，只在比这个宽度短的情况下尝试后续的候选宽度来改进我们的搜索循环。而且，如果我们在搜索的过程中还能跟踪到目前为止最好的包装（即成本最低的包装），那么我们就会有一个完整的迭代贪婪包装算法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nf">iterative-wrap</span> <span class="p">(</span><span class="nv">$text</span><span class="o">,</span> <span class="o">:</span><span class="nv">$width</span> <span class="o">=</span> <span class="mi">80</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Track the best wrapping we find...</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$best-wrapping</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Allow any width down to 90% of that specified...</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nv">$width</span><span class="o">...</span><span class="nb">floor</span><span class="p">(</span><span class="mf">0.9</span> <span class="o">*</span> <span class="nv">$width</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$next-width</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Only try widths that can produce new wrappings...</span>
</span></span><span class="line"><span class="cl">            <span class="k">state</span> <span class="nv">$prev-max-width</span> <span class="o">=</span> <span class="no">Inf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nb">next</span> <span class="k">if</span> <span class="nv">$next-width</span> <span class="o">&gt;</span> <span class="nv">$prev-max-width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># Build the wrapping and evaluate it...</span>
</span></span><span class="line"><span class="cl">            <span class="k">my</span> <span class="nv">$wrapping</span> <span class="o">=</span> <span class="nf">greedy-wrap</span><span class="p">(</span><span class="nv">$text</span><span class="o">,</span> <span class="p">:</span><span class="s">width</span><span class="p">(</span><span class="nv">$next-width</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">my</span> <span class="nv">$cost</span>     <span class="o">=</span> <span class="nf">cost</span><span class="p">(</span><span class="nv">$wrapping</span><span class="o">.</span><span class="nb">lines</span><span class="o">,</span> <span class="nv">$next-width</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># Keep the wrapping only if it&#39;s the best so far...</span>
</span></span><span class="line"><span class="cl">            <span class="k">state</span> <span class="nv">$lowest-cost</span> <span class="o">=</span> <span class="no">Inf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nv">$cost</span> <span class="o">&lt;</span> <span class="nv">$lowest-cost</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nv">$best-wrapping</span> <span class="o">=</span> <span class="nv">$wrapping</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="nv">$lowest-cost</span>   <span class="o">=</span> <span class="nv">$cost</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># Try one character narrower next time...</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$prev-max-width</span> <span class="o">=</span> <span class="nv">$wrapping</span><span class="o">.</span><span class="nb">lines</span><span class="o">».</span><span class="nb">chars</span><span class="o">.</span><span class="nb">max</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Send back the prettiest one we found...</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">$best-wrapping</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>通过对跳过非生产性宽度的优化，现在这个方案比 TEX 算法快了2.5倍，比最短路径方法快了25%。</p>
<p>作为最后一步，我们可以用更干净、更短、更 &ldquo;原生&quot;的 Raku 风格重写上面的代码，这可能也会使它更容易维护:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nf">iterative-wrap</span> <span class="p">(</span><span class="nv">$text</span><span class="o">,</span> <span class="o">:</span><span class="nv">$width</span> <span class="o">=</span> <span class="mi">80</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Return the least-cost candidate wrapping...</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">min</span> <span class="p">:</span><span class="s">by</span><span class="p">{</span><span class="o">.</span><span class="nf">cost</span><span class="p">}</span><span class="o">,</span> <span class="k">gather</span> <span class="k">loop</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Start at specified width; stop at 90% thereof...</span>
</span></span><span class="line"><span class="cl">            <span class="k">state</span> <span class="nv">$next-width</span> <span class="o">=</span> <span class="nv">$width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nb">last</span> <span class="k">if</span> <span class="nv">$next-width</span> <span class="o">&lt;</span> <span class="nb">floor</span><span class="p">(</span><span class="mf">0.9</span> <span class="o">*</span> <span class="nv">$width</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># Create and evaluate another candidate...</span>
</span></span><span class="line"><span class="cl">            <span class="k">my</span> <span class="nv">$wrapping</span> <span class="o">=</span> <span class="nf">greedy-wrap</span><span class="p">(</span><span class="nv">$text</span><span class="o">,</span> <span class="p">:</span><span class="s">width</span><span class="p">(</span><span class="nv">$next-width</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">my</span> <span class="nv">$cost</span>     <span class="o">=</span> <span class="nf">cost</span><span class="p">(</span><span class="nv">$wrapping</span><span class="o">.</span><span class="nb">lines</span><span class="o">,</span> <span class="nv">$next-width</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># Gather it, annotating it with its score...</span>
</span></span><span class="line"><span class="cl">            <span class="k">role</span> <span class="nc">Cost</span> <span class="p">{</span> <span class="k">has</span> <span class="nv">$.cost</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nb">take</span> <span class="nv">$wrapping</span> <span class="k">but</span> <span class="nc">Cost</span><span class="p">(</span><span class="nv">$cost</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># Try one character narrower next time...</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$next-width</span> <span class="o">=</span> <span class="nv">$wrapping</span><span class="o">.</span><span class="nb">lines</span><span class="o">».</span><span class="nb">chars</span><span class="o">.</span><span class="nb">max</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>在这个版本中，我们在一个无条件的循环中生成每一个候选的包装，从指定的宽度开始(<code>state $next-width = $width</code>)，到该宽度的90%结束(<code>last if $next-width &lt; floor(0.9 * $width)</code>)。</p>
<p>我们贪婪地创建每一个包装，并与之前完全一样地评估它，但随后我们只是简单地积累包装，用自己的成本来注释它（<code>take $wrapping but Cost($cost)</code>）。</p>
<p><code>Cost</code> 角色给我们提供了一个简单的方法，在不弄乱字符串本身的情况下，将成本信息添加到包含包装的字符串中。角色是一个方法和属性的集合，可以作为一个组件添加到现有的类中。其他语言也有类似的构造，但把它们称为&quot;接口&quot;或&quot;特质&quot;或&quot;协议扩展&quot;或&quot;混合&rdquo;。</p>
<p>在这种情况下，我们只是通过使用 <code>infix but</code> 操作符将额外的成本跟踪功能添加到包装字符串中&hellip;它将左操作数转化为一种从左操作数的 <code>Str</code> 类派生出来的新对象，但是（咳咳！）具有由作为右操作数的角色指定的额外行为。</p>
<p>因此，我们的 <code>gather</code> 循环收集了一连串的 wrapping 字符串，每个字符串现在都有一个额外的 <code>.cost</code> 方法来报告它的成本，然后我们可以应用内置的 <code>min</code> 函数来选择并返回循环产生的最佳 <code>wrapping(return min :by{.cost} gather for {...})</code>。</p>
<p>我们新的迭代-wrap子程序的代码比原来的贪婪-wrap实现要长7倍，慢7倍。但它产生的结果也至少漂亮了七倍。而这是一个非常值得的权衡。</p>
<p>Damian</p>


        </div>
    </div>
</article>



                <footer>
                    




<div class="no-text-decoration">
    <div class="jump top"><a href="#" title="Top of this page">⮉</a></div>
    <div class="jump bottom"><a href="#bottom" title="Bottom of this page">⮋</a></div>
</div>


 
    
        <div class="hugotoc no-text-decoration">
            <nav id="TableOfContents"></nav>
            <a href="#" class="back-to-top">Back to top</a>
        </div>
    
    
<script src="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js"></script>

<link rel="preload" href="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js" as="script">

<script type="application/javascript">(function() {
     var $window = $(window);
     if ($window.width() >= 1400) { 
         var $toc = $('#TableOfContents');
         if ($toc.length > 0) {
             function onScroll(){
                 var currentScroll = $window.scrollTop();
                 var h = $('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .h-feed h2');
                 var id = "";
                 h.each(function (i, e) {
                     e = $(e);
                     if (e.offset().top - 10 <= currentScroll) {
                         id = e.attr('id');
                     }
                 });
                 var current = $toc.find('a.current');
                 if (current.length == 1 && current.eq(0).attr('href') == '#' + id) return true;

                 current.each(function (i, e) {
                     $(e).removeClass('current').siblings('ul').hide();
                 });
                 $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                     $(e).children('a').addClass('current').siblings('ul').show();
                 });
             }
             $window.on('scroll', onScroll);
             $(document).ready(function() {
                 $toc.find('a').parent('li').find('ul').hide();
                 onScroll();
                 document.getElementsByClassName('hugotoc')[0].style.display = '';
             });}}})();</script>








<div class="backtotop center no-text-decoration">
    <a href="#">back to <span class="top">top</span></a>
</div>


<div class="right">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>
<div class="clear-float"></div>



<div class="prev-next-navigator clear-float">
    
        <span class="prev-post left no-text-decoration">
            <a href="https://ohmyweekly.github.io/notes/chopping-substrings/" class="nobr">« chopping-substrings</a>
        </span>
    
    
        <span class="next-post right no-text-decoration">
            <a href="https://ohmyweekly.github.io/notes/with-friends-like-these/" class="nobr">with friends like these »</a>
        </span>
    
</div>


<a id="bottom"></a>









                       







                    <ul class="no-bullets feed right inline">
    
        
        
    
</ul>
<div class="clear-float"></div>

                </footer>
                <hr />
            </div>               

            <footer> 
                

<ul class="social no-text-decoration">
    
</ul>










 
    
    



<p class="generated no-text-decoration">
    Generated using  <a href="https://gitlab.com/kaushalmodi/hugo-theme-refined"><code class="nobr">hugo-theme-refined</code></a> + <span class="nobr">Hugo <a href="https://github.com/gohugoio/hugo/commit/312735366b20d64bd61bff8627f593749f86c964">0.123.7</a></span>
</p>

<p>
    
</p>




<div class="badges no-text-decoration">
    
    

    
</div>




<script type="application/javascript">var nav=responsiveNav("#nav");</script>




<script defer src="/js/libs/fragmentions/wrapper.min.e8c468c89edc4f5dccaa8c720c6b220b3088a16cd7b1e4a1e3345985788260c9.js"></script>









            </footer>
        </div> 
    </body>
</html>
