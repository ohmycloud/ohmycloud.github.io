{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"content":{"html":"\u003cp\u003e学会了怎么创建类, 我们继续用它来构建我们的中心内容:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eHammer\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nf\"\u003ehammer\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$stuff\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eYou hammer on \u003c/span\u003e\u003cspan class=\"nv\"\u003e$stuff\u003c/span\u003e\u003cspan class=\"s2\"\u003e. BAM BAM BAM!\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eGavel\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nf\"\u003ehammer\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$stuff\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eYou hammer on \u003c/span\u003e\u003cspan class=\"nv\"\u003e$stuff\u003c/span\u003e\u003cspan class=\"s2\"\u003e. BAM BAM BAM!\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMallet\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nf\"\u003ehammer\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$stuff\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eYou hammer on \u003c/span\u003e\u003cspan class=\"nv\"\u003e$stuff\u003c/span\u003e\u003cspan class=\"s2\"\u003e. BAM BAM BAM!\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e但是注意到了吗？这三个方法包含了同样的方法, 在类中重复了。我们必须那样做如果我们想让每个 \u003cstrong\u003eHammar\u003c/strong\u003e、\u003cstrong\u003eGavel\u003c/strong\u003e 和 \u003cstrong\u003eMallet\u003c/strong\u003e 有能力击打的话。（并且那是合理的）。但是遗憾的是我们不得不把那个方法一式三份。\u003c/p\u003e\n\u003cp\u003e为什么遗憾？ 因为一方面在真实世界中, 方法并不是很彼此相似, 有一天你决定在 \u003cstrong\u003ehammer\u003c/strong\u003e 方法中更改某些东西, 并没有意识到这个方法在三个不同的地方\u0026hellip; 这导致了一堆痛苦和难受。\u003c/p\u003e\n\u003cp\u003e所以我们的新玩具, 类, 展现出了一个问题。我们想在每个类中重用 hammer 方法。一个新的概念, \u003cstrong\u003erole\u003c/strong\u003e 来拯救我们来了:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003erole\u003c/span\u003e \u003cspan class=\"nc\"\u003eHammering\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nf\"\u003ehammer\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$stuff\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eYou hammer on \u003c/span\u003e\u003cspan class=\"nv\"\u003e$stuff\u003c/span\u003e\u003cspan class=\"s2\"\u003e. BAM BAM BAM!\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e虽然类经常以一个合适的名词命名, 但是 roles 经常以一个分词命名, 例如 \u003cstrong\u003eHammering\u003c/strong\u003e。这不是一个必须遵守的规则, 但是它是一个好的经验法则。现在类的定义变的简单了:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eHammer\u003c/span\u003e \u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eHammering\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eGavel\u003c/span\u003e  \u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eHammering\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMallet\u003c/span\u003e \u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eHammering\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e是的, 我们喜欢那样。\u003c/p\u003e\n\u003cp\u003e这发生了什么？ 我们在类上使用 \u003cstrong\u003edoes\u003c/strong\u003e 是干什么用的？ role 定义中的所有方法都被拷贝到类定义中。因为它是一个拷贝操作, 所以我们可以使用尽可能多的类。\u003c/p\u003e\n\u003cp\u003e所以, 我们做的是: 当我们想重用方法的时候把方法放进 roles 里面。\u003c/p\u003e\n\u003cp\u003e但是好处不止这一点儿。至少有两个好处:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$hammer\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eHammer\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003enew\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e    \u003cspan class=\"c1\"\u003e# create a new hammer object\u003c/span\u003e\n\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e$hammer\u003c/span\u003e \u003cspan class=\"o\"\u003e~~\u003c/span\u003e \u003cspan class=\"n\"\u003eHammer\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e      \u003cspan class=\"c1\"\u003e# \u0026#34;Bool::True\u0026#34; -- yes, this we know\u003c/span\u003e\n\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e$hammer\u003c/span\u003e \u003cspan class=\"o\"\u003e~~\u003c/span\u003e \u003cspan class=\"n\"\u003eHammering\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e   \u003cspan class=\"c1\"\u003e# \u0026#34;Bool::True\u0026#34; -- ooh!\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e所以 \u003ccode\u003e$hammer\u003c/code\u003e 知道它遵守了(does) \u003cstrong\u003eHammering\u003c/strong\u003e, 我们现在不仅知道了对象属于哪个类, 还知道了对象并入了什么 role。这很有用如果我们不确定我们处理的是什么类型的对象:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nv\"\u003e$unkown_object\u003c/span\u003e \u003cspan class=\"o\"\u003e~~\u003c/span\u003e \u003cspan class=\"n\"\u003eHammering\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nv\"\u003e$unknown_object\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ehammer\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003e砸在钉子上\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;);\u003c/span\u003e     \u003cspan class=\"c1\"\u003e# will always work\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e一个类能一次接收几个 roles 吗？ 是的, 它可以:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003erole\u003c/span\u003e \u003cspan class=\"nc\"\u003eFlying\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nf\"\u003efly\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eWhooosh!\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eFlyingHammer\u003c/span\u003e \u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eHammering\u003c/span\u003e \u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eFlying\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e让一个类像那样遵守几个 roles 引入了一个有意思的可能: 冲突, 当来自两个不同 roles 的两个同名方法尝试占领同一个类时。这时会发生什么？ 好吧, 至少有 3 种可能:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003col\u003e\n\u003cli\u003e第一个 role 赢了。 它的方法住进了类中\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col\u003e\n\u003cli\u003e最后一个 role 赢了。 它覆盖了之前的方法\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col\u003e\n\u003cli\u003e编译失败。冲突必须被解决。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这种情况下选项 3  应该是正确答案。原因和之前相同: 因为类和工程越来越庞大, 程序员可能意识不到两个 role 之间在哪儿发生冲突。所以我们标记了它。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003erole\u003c/span\u003e \u003cspan class=\"nc\"\u003eSleeping\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nf\"\u003elie\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003e水平躺下\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003erole\u003c/span\u003e \u003cspan class=\"nc\"\u003eLying\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nf\"\u003elie\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003e说谎...\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eSleepingLiar\u003c/span\u003e \u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eSleeping\u003c/span\u003e \u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eLying\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e    \u003cspan class=\"c1\"\u003e# 冲突!\u003c/span\u003e\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e下一个问题, 那么: 当在类中有  role 冲突时, 我们怎么修复它？ 简单: 在类中自己定义一个同名的方法:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\n\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eSleepingLiar\u003c/span\u003e \u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eSleeping\u003c/span\u003e \u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eLying\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nf\"\u003elie\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eLying in my sleep....\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果你想从一个贴别的 role 中调用一个方法, 语法是这样的:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eSleepingLiar\u003c/span\u003e \u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eSleeping\u003c/span\u003e \u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eLying\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nf\"\u003elie\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"nb\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eSleeping::lie\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这就是 roles。它们把可重用的行为混合进类中。\u003c/p\u003e\n","text":"学会了怎么创建类, 我们继续用它来构建我们的中心内容:\nclass Hammer { method hammer($stuff) { say \u0026#34;You hammer on $stuff. BAM BAM BAM!\u0026#34;; } } class Gavel { method hammer($stuff) { say \u0026#34;You hammer on $stuff. BAM BAM BAM!\u0026#34;; } } class Mallet { method hammer($stuff) { say \u0026#34;You hammer on $stuff. BAM BAM BAM!\u0026#34;; } } 但是注意到了吗？这三个方法包含了同样的方法, 在类中重复了。我们必须那样做如果我们想让每个 Hammar、Gavel 和 Mallet 有能力击打的话。（并且那是合理的）。但是遗憾的是我们不得不把那个方法一式三份。\n为什么遗憾？ 因为一方面在真实世界中, 方法并不是很彼此相似, 有一天你决定在 hammer 方法中更改某些东西, 并没有意识到这个方法在三个不同的地方\u0026hellip; 这导致了一堆痛苦和难受。\n所以我们的新玩具, 类, 展现出了一个问题。我们想在每个类中重用 hammer 方法。一个新的概念, role 来拯救我们来了:\nrole Hammering { method hammer($stuff) { say \u0026#34;You hammer on $stuff. BAM BAM BAM!\u0026#34;; } } 虽然类经常以一个合适的名词命名, 但是 roles 经常以一个分词命名, 例如 Hammering。这不是一个必须遵守的规则, 但是它是一个好的经验法则。现在类的定义变的简单了:\nclass Hammer does Hammering { } class Gavel does Hammering { } class Mallet does Hammering { } 是的, 我们喜欢那样。\n这发生了什么？ 我们在类上使用 does 是干什么用的？ role 定义中的所有方法都被拷贝到类定义中。因为它是一个拷贝操作, 所以我们可以使用尽可能多的类。\n所以, 我们做的是: 当我们想重用方法的时候把方法放进 roles 里面。\n但是好处不止这一点儿。至少有两个好处:\nmy $hammer = Hammer.new; # create a new hammer object say $hammer ~~ Hammer; # \u0026#34;Bool::True\u0026#34; -- yes, this we know say $hammer ~~ Hammering; # \u0026#34;Bool::True\u0026#34; -- ooh! 所以 $hammer 知道它遵守了(does) Hammering, 我们现在不仅知道了对象属于哪个类, 还知道了对象并入了什么 role。这很有用如果我们不确定我们处理的是什么类型的对象:\nif $unkown_object ~~ Hammering { $unknown_object.hammer(\u0026#34;砸在钉子上\u0026#34;); # will always work } 一个类能一次接收几个 roles 吗？ 是的, 它可以:\nrole Flying { method fly { say \u0026#34;Whooosh!\u0026#34;; } } class FlyingHammer does Hammering does Flying { } 让一个类像那样遵守几个 roles 引入了一个有意思的可能: 冲突, 当来自两个不同 roles 的两个同名方法尝试占领同一个类时。这时会发生什么？ 好吧, 至少有 3 种可能:\n   第一个 role 赢了。 它的方法住进了类中     最后一个 role 赢了。 它覆盖了之前的方法     编译失败。冲突必须被解决。    这种情况下选项 3 应该是正确答案。原因和之前相同: 因为类和工程越来越庞大, 程序员可能意识不到两个 role 之间在哪儿发生冲突。所以我们标记了它。\nrole Sleeping { method lie { say \u0026#34;水平躺下\u0026#34;; } } role Lying { method lie { say \u0026#34;说谎...\u0026#34;; } } class SleepingLiar does Sleeping does Lying { } # 冲突! 下一个问题, 那么: 当在类中有 role 冲突时, 我们怎么修复它？ 简单: 在类中自己定义一个同名的方法:\nclass SleepingLiar does Sleeping does Lying { method lie { say \u0026#34;Lying in my sleep....\u0026#34;; } } 如果你想从一个贴别的 role 中调用一个方法, 语法是这样的:\nclass SleepingLiar does Sleeping does Lying { method lie { self.Sleeping::lie; } } 这就是 roles。它们把可重用的行为混合进类中。\n"},"name":"Raku 中的角色冲突","published":"2021-07-11T00:00:00+08:00","summary":"Roles Conflict in Raku","type":"entry","url":"https://ohmyweekly.github.io/notes/2015-11-16-roles-conflict-in-raku/"}