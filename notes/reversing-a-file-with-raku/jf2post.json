{"author":{"name":null,"type":"card","url":"https://ohmycloud.github.io/"},"content":{"html":"\u003cp\u003e欢迎来到\u003cstrong\u003eRaku One-Liner Advent Calendar的\u003c/strong\u003e第\u003ca href=\"https://raku.online/2018/12/22/reversing-a-file-with-perl-6/\"\u003e22\u003c/a\u003e天！今天，我们将继续使用文件，今天的目标是创建一个单行程序以相反的顺序打印文本文件的行（如\u003ccode\u003etail -r\u003c/code\u003e那样）。\u003c/p\u003e\n\u003cp\u003e第一个单行程序使用 STDIN 流完成工作：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esay\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"nv\"\u003e$\u003c/span\u003e\u003cspan class=\"err\"\u003e*\u003c/span\u003e\u003cspan class=\"nv\"\u003eIN\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elines\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ereverse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e运行程序为：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ raku reverse.pl \u0026lt; text.txt\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果要直接从Raku读取文件，请稍微修改程序以从命令行参数创建文件句柄：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esay\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"nv\"\u003e@\u003c/span\u003e\u003cspan class=\"err\"\u003e*\u003c/span\u003e\u003cspan class=\"nv\"\u003eARGS\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eIO\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eopen\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elines\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ereverse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e现在运行如下：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e$ raku reverse.pl text.txt\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e重要的是要记住，\u003ccode\u003elines\u003c/code\u003e方法的默认行为是从最后的行序列中排除换行符（该方法返回\u003ccode\u003eSeq\u003c/code\u003e对象，而不是数组或列表）。它可能与你在使用Perl 5时习惯的方式相反。使用\u003ccode\u003echomp\u003c/code\u003e是一种常见的做法。\u003c/p\u003e\n\u003cp\u003e在Raku中，\u003ccode\u003elines\u003c/code\u003e方法根据\u003ccode\u003eIO::Handle\u003c/code\u003e对象的\u003ca href=\"https://docs.raku.org/routine/nl-in\"\u003enl-in 属性\u003c/a\u003e中存储的值来拆分行。\u003c/p\u003e\n\u003cp\u003e您可以使用以下小脚本查看行分隔符的当前值：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003edd\u003c/span\u003e \u003cspan class=\"nv\"\u003e$_\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"nv\"\u003e@\u003c/span\u003e\u003cspan class=\"err\"\u003e*\u003c/span\u003e\u003cspan class=\"nv\"\u003eARGS\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eIO\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eopen\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enl\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这是您默认找到的内容：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e$[\u0026#34;\\n\u0026#34;, \u0026#34;\\r\\n\u0026#34;]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e有趣的是，你可以控制的 \u003ccode\u003elines\u003c/code\u003e 的行为，并告诉 Perl 不排除换行符：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e@*ARGS[0].IO.open(chomp =\u0026gt; False).lines.reverse.put\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e该 \u003ccode\u003echomp\u003c/code\u003e 属性由默认设置为 True。您还可以更改默认分隔符：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e@\u003c/span\u003e\u003cspan class=\"err\"\u003e*\u003c/span\u003e\u003cspan class=\"nv\"\u003eARGS\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eIO\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eopen\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003enl\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003ein\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;\\r\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003echomp\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eFalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elines\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ereverse\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eput\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e请注意，如果没有 chomping，则不需要对行进行显式的\u003ccode\u003efor\u003c/code\u003e循环：在最后两个单行中，直接在序列对象上调用\u003ccode\u003e.put\u003c/code\u003e方法。在早期版本中，字符串不包含换行符，因此它们将打印为单个长行。\u003c/p\u003e\n\u003cp\u003e今天我将给你留一些小功课：\u003cem\u003e告诉 \u003ccode\u003esay\u003c/code\u003e 和 \u003ccode\u003eput\u003c/code\u003e 之间的差异。\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e明天见！\u003c/p\u003e\n","text":"欢迎来到Raku One-Liner Advent Calendar的第22天！今天，我们将继续使用文件，今天的目标是创建一个单行程序以相反的顺序打印文本文件的行（如tail -r那样）。\n第一个单行程序使用 STDIN 流完成工作：\n.say for $*IN.lines.reverse 运行程序为：\n$ raku reverse.pl \u0026lt; text.txt 如果要直接从Raku读取文件，请稍微修改程序以从命令行参数创建文件句柄：\n.say for @*ARGS[0].IO.open.lines.reverse 现在运行如下：\n$ raku reverse.pl text.txt 重要的是要记住，lines方法的默认行为是从最后的行序列中排除换行符（该方法返回Seq对象，而不是数组或列表）。它可能与你在使用Perl 5时习惯的方式相反。使用chomp是一种常见的做法。\n在Raku中，lines方法根据IO::Handle对象的nl-in 属性中存储的值来拆分行。\n您可以使用以下小脚本查看行分隔符的当前值：\ndd $_ for @*ARGS[0].IO.open.nl-in 这是您默认找到的内容：\n$[\u0026#34;\\n\u0026#34;, \u0026#34;\\r\\n\u0026#34;] 有趣的是，你可以控制的 lines 的行为，并告诉 Perl 不排除换行符：\n@*ARGS[0].IO.open(chomp =\u0026gt; False).lines.reverse.put 该 chomp 属性由默认设置为 True。您还可以更改默认分隔符：\n@*ARGS[0].IO.open( nl-in =\u0026gt; \u0026#34;\\r\u0026#34;, chomp =\u0026gt; False ).lines.reverse.put 请注意，如果没有 chomping，则不需要对行进行显式的for循环：在最后两个单行中，直接在序列对象上调用.put方法。在早期版本中，字符串不包含换行符，因此它们将打印为单个长行。\n今天我将给你留一些小功课：告诉 say 和 put 之间的差异。\n明天见！\n"},"name":"🎄 22/25. 使用 Raku 反转文件","published":"2018-12-22T10:10:35Z","summary":"欢迎来到Raku One-Liner Advent Calendar的第22天！今天，我们将继续使用文件，今天的目标是创建一个单行程序以相反的顺序打印文本文件的行（如tail -r那样）。\n第一个单行程序使用 STDIN 流完成工作：\n.say for $*IN.lines.reverse 运行程序为：\n$ raku reverse.pl \u0026lt; text.txt 如果要直接从Raku读取文件，请稍微修改程序以从命令行参数创建文件句柄：\n.say for @*ARGS[0].IO.open.lines.reverse 现在运行如下：\n$ raku reverse.pl text.txt 重要的是要记住，lines方法的默认行为是从最后的行序列中排除换行符（该方法返回Seq对象，而不是数组或列表）。它可能与你在使用Perl 5时习惯的方式相反。使用chomp是一种常见的做法。\n在Raku中，lines方法根据IO::Handle对象的nl-in 属性中存储的值来拆分行。\n您可以使用以下小脚本查看行分隔符的当前值：\ndd $_ for @*ARGS[0].IO.open.nl-in 这是您默认找到的内容：\n$[\u0026#34;\\n\u0026#34;, \u0026#34;\\r\\n\u0026#34;] 有趣的是，你可以控制的 lines 的行为，并告诉 Perl 不排除换行符：\n@*ARGS[0].IO.open(chomp =\u0026gt; False).lines.reverse.put 该 chomp 属性由默认设置为 True。您还可以更改默认分隔符：\n@*ARGS[0].IO.open( nl-in =\u0026gt; \u0026#34;\\r\u0026#34;, chomp =\u0026gt; False ).lines.reverse.put 请注意，如果没有 chomping，则不需要对行进行显式的for循环：在最后两个单行中，直接在序列对象上调用.put方法。在早期版本中，字符串不包含换行符，因此它们将打印为单个长行。\n今天我将给你留一些小功课：告诉 say 和 put 之间的差异。\n明天见！","type":"entry","url":"https://ohmycloud.github.io/notes/reversing-a-file-with-raku/"}