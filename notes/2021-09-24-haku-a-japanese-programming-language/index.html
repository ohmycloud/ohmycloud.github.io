<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
    
    
    

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    
    <meta name="referrer" content="no-referrer">

    <title>
        
            Haku a Japanese Programming Language ❚ 焉知非鱼
        
    </title>

    
    


    
    
    
    

    
    
    
    

    
    
    

    
    
    
    <style>
     
     
     :root {
         --theme-color: #ac4142;
         --theme-color-light: rgba(172, 65, 66, 0.2);
     }
     
     html {
         line-height: 1.5;
     }
    </style>

    
    

    
    
    
    
    <link rel="stylesheet" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css">
    
    <link rel="preload" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css" as="style">

    



    
        <style>
         
         /* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }

         
         /* Overrides on top of the theme and Chroma CSS */
/* Chroma-based lines highlighting in code blocks */
.chroma .hl {
    background-color: #e8e8e8;
    /* Extend highlight up to 100 characters (assuming that the code blocks never have more than 100 characters in a line) */
    min-width: 100ch;
}
/* GenericHeading */ .chroma .gh { color: #999999; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa; font-weight: bold }

         
        </style>
    

    

    
    
    

    
    <script src="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js"></script>
    
    <link rel="preload" href="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js" as="script">

    
    
    <script defer src="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js"></script>
    
    <link rel="preload" href="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js" as="script">

    

    

    
    
    

    
    
<!-- rel="me" links for IndieAuth -->







    
 
<meta property="og:title" content="Haku a Japanese Programming Language" />
<meta property="og:description"
      content="Haku a Japanese Programming Language" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ohmycloud.github.io/notes/2021-09-24-haku-a-japanese-programming-language/" />


    
        <meta property="article:published_time" content="2021-09-24T00:00:00&#43;00:00"/>
    
    
        <meta property="article:modified_time" content="2021-09-24T00:00:00&#43;00:00"/>
    









    




     <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Haku a Japanese Programming Language"/>
<meta name="twitter:description" content="Haku a Japanese Programming Language"/>


    
    
    <link rel="alternate" type="application/jf2post+json" href="https://ohmycloud.github.io/notes/2021-09-24-haku-a-japanese-programming-language/jf2post.json" title="Jf2post for 焉知非鱼" />
    
     



    
    
    
        
    


     
        
        <meta name="DC.Creator" content="焉知非鱼"/>
    



    
    
    
    <meta name="hugo-build-date" content="2024-03-01T16:16:06Z"/>
    <meta name="hugo-commit-hash" content="312735366b20d64bd61bff8627f593749f86c964"/>
    <meta name="generator" content="Hugo 0.123.7">
</head>


    
        <body lang="en">
    

        
        <div class="border" id="home"></div>

        <div class="wrapper">   
            
<nav id="nav" class="nav-collapse opened" aria-hidden="false">
    <ul class="navbar">
        <li><a class="" href="/">Home</a></li>
        
            
                <li><a class="" href="https://ohmycloud.github.io/posts/">Posts</a></li>
            
        
            
                <li><a class="" href="https://ohmycloud.github.io/notes/">Notes</a></li>
            
        
        
            <li><a class="" href="https://ohmycloud.github.io/search/">Search</a></li>
        
    </ul>
</nav>

            <div class="container">
                <header class="masthead">
                    <div class="masthead-title no-text-decoration">
                        <a href="/">焉知非鱼</a> <span class="blinking-cursor">❚</span>
                    </div>
                    <div class="masthead-tagline">
                        Wait the light to fall
                    </div>
                </header>

                








<article class="post h-entry notes">
    <header>
        <div class="center">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>

        <h1 class="post-title p-name">Haku a Japanese Programming Language</h1>

        
        <data class="u-url" value="https://ohmycloud.github.io/notes/2021-09-24-haku-a-japanese-programming-language/"></data>

        <div class="date-syndication">
            


    
    
    <div class="post-date">
        
        <time datetime="2021-09-24T00:00:00+0000" class="dt-published">Fri Sep 24, 2021</time>
        
        
    </div>


            




        </div>
         



    
    
    
        
    


    
        
        <span class="hide">
            &mdash; <a href="https://ohmycloud.github.io/" class="u-author">焉知非鱼</a>
        </span>
    


    </header>

    <div class="content">
        
    <div class="description p-summary">
        
        
        
        
        
            
            
        
        <p>Haku a Japanese Programming Language</p>
    </div>



        





                       


        <div class="e-content">
            




<h1 id="haku-一种日语编程语言">Haku: 一种日语编程语言</h1>
<p>Haku 是一种基于文学性日语的自然语言功能编程语言。这篇文章是关于 Haku 在 <a href="https://raku.org/">Raku</a> 中的实现。你不需要懂日语或<a href="https://codeberg.org/wimvanderbauwhede/haku">阅读 Haku 的文档</a>。如果你不熟悉 Raku，你可能想阅读<a href="https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/#raku-intro">我的快速介绍</a>。</p>
<p>我确实假定你对解析、语法树和代码生成的概念很熟悉。如果你发现你对下面的内容缺乏背景，我推荐 Andrew Shitov 的系列文章<a href="https://andrewshitov.com/creating-a-compiler-with-raku/">《用 Raku 创建编译器》</a>，它采取了一个逐步的方法。</p>
<h2 id="haku">Haku&nbsp;<a class="headline-hash no-text-decoration" href="#haku">#</a> </h2>
<p>Haku 的目标是接近书面日语，因此它是由汉字、平假名和片假名这三种日语书写系统以及日语标点符号组合而成的。没有空格，Haku 不使用阿拉伯（甚至是罗马）数字，也不使用任何运算符。该语言的设计<a href="https://codeberg.org/wimvanderbauwhede/haku">在文档中得到了更详细的解释</a>。</p>
<p>下面是一个小的 Haku 程序的例子（更多的例子请看 <a href="https://codeberg.org/wimvanderbauwhede/haku/src/branch/main/examples">repo</a>）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">本とは
</span></span><span class="line"><span class="cl">「魄から楽まで」を見せる
</span></span><span class="line"><span class="cl">の事です。
</span></span></code></pre></div><p>这句话翻译过来就是:</p>
<blockquote>
<p>&ldquo;main is: to show &lsquo;From Haku to Raku&rsquo;&rdquo;</p>
</blockquote>
<p>而 Raku 版本是这样的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">From Haku to Raku</span><span class="p">&#39;;</span>
</span></span></code></pre></div><p>字符串&quot;本とは &ldquo;和 &ldquo;の事です&quot;表示主程序的开始和结束。&ldquo;魄から楽まで &ldquo;是一个字符串常数。&ldquo;见せる &ldquo;是打印函数。&lsquo;&lsquo;を&rsquo;表示前面的东西是函数的一个参数。示例代码中的换行符是可选的，纯粹是为了方便阅读。Haku 程序是一个没有空白或换行的单一字符串。</p>
<p>这个例子的实际生成的 Raku 代码是这样的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">HakuPrelude</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">show</span><span class="p">(&#39;</span><span class="s1">魄から楽まで</span><span class="p">&#39;)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">main</span><span class="p">();</span>
</span></span></code></pre></div><p>为了更接近文学性的日语，Haku 程序可以从右到左竖着写。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">の 忘 本 　 の 条 条 遠 　 の 物 忘
</span></span><span class="line"><span class="cl">事 れ と 　 こ を で い 　 こ で れ
</span></span><span class="line"><span class="cl">で か は 　 と 見 　 と 　 と 空 る
</span></span><span class="line"><span class="cl">す け 記 　 で せ 　 は 　 で 　 と
</span></span><span class="line"><span class="cl">。 て 憶 　 す る 　 　 　 す 　 は
</span></span><span class="line"><span class="cl">　 た は 　 。 　 　 　 　 。 　 　g
</span></span><span class="line"><span class="cl">　 遠 無 　 　 　 　 　 　 　 　 　
</span></span><span class="line"><span class="cl">　 い 、 　 　 　 　 　 　 　 　 　
</span></span><span class="line"><span class="cl">　 記 　 　 　 　 　 　 　 　 　 　
</span></span><span class="line"><span class="cl">　 憶 　 　 　 　 　 　 　 　 　 　
</span></span></code></pre></div><p>为这个 Haku 程序生成的 Raku 代码同样非常简单。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">HakuPrelude</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">wasureru</span><span class="p">(</span> \<span class="n">mono</span><span class="p">)</span> <span class="p">{</span><span class="o">[]</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">tooi</span><span class="p">(</span> \<span class="n">jou</span><span class="p">)</span> <span class="p">{</span><span class="nf">show</span><span class="p">(</span><span class="n">jou</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">hon</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">\kioku</span> <span class="o">=</span> <span class="kt">Nil</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">wasureru</span><span class="p">(</span><span class="nf">tooi</span><span class="p">(</span><span class="n">kioku</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">hon</span><span class="p">();</span>
</span></span></code></pre></div><p>Haku 是用 Raku 实现的。Haku 编译器是一个源到源的编译器（有时称为转译器），它从 Haku 源生成 Raku 源并执行它。Raku 在许多方面使编写这样的编译器变得容易。</p>
<h2 id="parsing-using-grammars">Parsing using Grammars&nbsp;<a class="headline-hash no-text-decoration" href="#parsing-using-grammars">#</a> </h2>
<p>我决定用 Raku 来实现 Haku，主要是因为我想使用 Raku 的 <a href="https://docs.raku.org/language/grammars">Grammar</a> 功能，而且它没有让我失望。Grammar 就像一个类，但它没有方法，而是有 rule 或 token，它们是解析器的构建块。任何 token 都可以在另一个 token 的定义中使用，例如用 <code>&lt;...&gt;</code> 将其括起来。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">adjective</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;</span><span class="nf">i-adjective</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">na-adjective</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>
</span></span></code></pre></div><p><code>i-adjective</code> 和 <code>na-adjective</code> 已经被分别定义，<code>adjective</code> 与其中一个相匹配。</p>
<p>我一直喜欢解析器组合器（如 Haskell 中的 <a href="https://www.futurelearn.com/info/courses/functional-programming-haskell/0/steps/27222">Parsec</a>），从某种角度看，Raku 的 grammar 也很相似。它们都是无扫描器，即没有单独的 token 化步骤，而且高度可组合。Parsec 提供的许多功能（如 <code>many</code>,<code> oneOf</code>, <code>sepBy</code>）都可以通过 Raku 的 regex 来实现。</p>
<p>Raku 的 grammar 有几个特点，有助于使 Haku 的解析器易于实现。</p>
<h3 id="excellent-unicode-support">Excellent Unicode support&nbsp;<a class="headline-hash no-text-decoration" href="#excellent-unicode-support">#</a> </h3>
<p>我认为 Raku 的 Unicode 支持真的很好。例如，由于对 Unicode 块的支持，我可以简单地写出:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">kanji</span> <span class="p">{</span><span class="sr">  
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;:</span><span class="na">Block</span><span class="p">(&#39;</span><span class="s1">CJK Unified Ideographs</span><span class="p">&#39;)&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>  
</span></span></code></pre></div><p>而不是把它们全部列举出来（该块中有 92,865 个汉字！）。事实上， <code>&lt;:...&gt;</code> 语法适用于任何 Unicode 属性，而不仅仅是 Blocks。</p>
<p>甚至更好。我有一些汉字被保留为关键词。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">reserved-kanji</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">本</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">事</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="o">..</span><span class="ni">.</span><span class="sr"> </span><span class="p">}</span>
</span></span></code></pre></div><p>为了确保这些被排除在 Haku 的有效汉字之外，我可以简单地使用一个差集。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">token</span> <span class="nf">kanji</span> <span class="p">{</span><span class="sr">  
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">&lt;:</span><span class="na">Block</span><span class="p">(&#39;</span><span class="s1">CJK Unified Ideographs</span><span class="p">&#39;)</span> <span class="o">-</span> <span class="sr">reserved</span><span class="o">-</span><span class="sr">kanji</span> <span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="p">}</span>  
</span></span></code></pre></div><p>(有一个细节让我感到不安的是，用户定义的字符类的等效语法需要一个显式的  &lsquo;+&rsquo;: <code>token set-difference { &lt; +set1 - set2&gt; }</code>)</p>
<h3 id="tokens-和-rules">Tokens 和 rules&nbsp;<a class="headline-hash no-text-decoration" href="#tokens-和-rules">#</a> </h3>
<p>幸运的是，Raku 默认不会假设你想解析可以忽略空白的东西，或者你想在空白处进行标记。如果你想忽略空白，你可以使用 <code>rule</code>。但是在 Haku 中，不允许不相干的空白（除了某些位置的换行）。所以我在任何地方都使用 <code>token</code>。(还有 <a href="https://docs.raku.org/language/grammars#index-entry-declarator_token-Named_Regexes"><code>regex</code>，可以回溯</a>。在 Haku 的语法中我不需要它）。)</p>
<h3 id="very-powerful-regexes">Very powerful regexes&nbsp;<a class="headline-hash no-text-decoration" href="#very-powerful-regexes">#</a> </h3>
<p>作为一个 lambdacamel，我一直很喜欢 Perl 的 regexes，现在无处不在的 <a href="https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions">PCREs</a>。然而，<a href="https://docs.raku.org/language/regexes">Raku 的 regexes</a> 在功能、表现力和可读性方面远远超过了它。</p>
<p>首先，它们是可组合的: 你可以用 <code>regex</code> 类型定义一个命名的 regex，然后用 <code>&lt;...&gt;</code> 语法在随后的 regex 中使用它。另外，设计时的谨慎使它们非常容易使用。例如，一个否定向前查看断言只是 <code>&lt;no&gt; &lt;!before &lt;koto&gt; &gt;</code>；而尝试顺序交替(<code>||</code>)和最长令牌匹配交替(<code>|</code>)的可用性是一个巨大的好处。我非常喜欢的另一件事是使一个字符类不被捕获的能力。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">lambda-expression</span> <span class="p">{</span><span class="sr"> 
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">aru</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">variable-list</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">de</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">expression</span><span class="p">&gt;</span><span class="sr"> 
</span></span></span><span class="line"><span class="cl"><span class="sr">    }
</span></span></span></code></pre></div><p>只有 <code>&lt;variable-list&gt;</code> 和 <code>&lt;expression&gt;</code> 会被捕获，所以很多具体的语法可以在解析时被删除。</p>
<h3 id="通过角色组合-grammar">通过角色组合 Grammar&nbsp;<a class="headline-hash no-text-decoration" href="#通过角色组合-grammar">#</a> </h3>
<p>Roles (Ruby 中的 &lsquo;mixins&rsquo;, Rust 中的 &rsquo;traits&rsquo;) 定义或实现这些接口。
我发现这比同样支持的类继承更适合我的目的。比如说:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">Nouns</span> <span class="k">does</span> <span class="nc">Characters</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">sa</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">さ</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">ki</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">き</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 一線 is OK,  一 is not OK, 線 is OK</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">noun</span> <span class="p">{</span><span class="sr"> 
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">&lt;</span><span class="nf">number-kanji</span><span class="p">&gt;</span><span class="o">?</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">non-number-kanji</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">kanji</span><span class="p">&gt;</span><span class="o">*</span><span class="sr"> 
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">[&lt;</span><span class="nf">sa</span><span class="p">&gt;</span><span class="o">|</span><span class="p">&lt;</span><span class="nf">ki</span><span class="p">&gt;]</span><span class="o">?</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">Identifiers</span> 
</span></span><span class="line"><span class="cl"><span class="k">does</span> <span class="nc">Verbs</span> 
</span></span><span class="line"><span class="cl"><span class="k">does</span> <span class="nc">Nouns</span> 
</span></span><span class="line"><span class="cl"><span class="k">does</span> <span class="nc">Adjectives</span> 
</span></span><span class="line"><span class="cl"><span class="k">does</span> <span class="nc">Variables</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">nominaliser</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">no</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="ow">before</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">koto</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&gt;</span><span class="sr"> 
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">koto</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="ow">before</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">desu</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&gt;</span><span class="sr"> 
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Identifiers are variables,</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># noun-style, verb-style</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># and adjective-style function names</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">identifier</span> <span class="p">{</span><span class="sr"> 
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">variable</span><span class="p">&gt;</span><span class="sr"> 
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">verb</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">nominaliser</span><span class="p">&gt;</span><span class="o">?</span><span class="sr"> 
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">noun</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">sura</span><span class="p">&gt;</span><span class="o">?</span><span class="sr"> 
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">adjective</span><span class="p">&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(虽然我希望有一个列表的语法，像 <code>role Identifiers does Verbs, Nouns, Adjectives, Variables {...}</code> 这样的语法。)</p>
<p>Grammar 和 regexes 的内容还有很多。Twitter 上好心的 Raku 朋友向我推荐了 Moritz Lenz 写的 <a href="https://link.springer.com/book/10.1007/978-1-4842-3228-6">Parsing with Perl 6 Regexes and Grammars</a> 一书，这本书特别是在调试 grammar 和处理错误信息方面非常有用。</p>
<h2 id="使用了角色的抽象语法树">使用了角色的抽象语法树&nbsp;<a class="headline-hash no-text-decoration" href="#使用了角色的抽象语法树">#</a> </h2>
<p>我喜欢把抽象语法树(AST)作为代数数据类型来实现，就像在 Haskell 中通常采用的方式。在 Raku 中，一种方法是使用参数化的角色，正如我在<a href="https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku">之前的文章中解释的那样</a>。大部分的 AST 直接映射到我的 grammar 中每个角色的顶层解析器，例如 lambda 表达式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">LambdaExpr</span><span class="o">[</span><span class="nv">@lambda-args</span><span class="o">,</span> <span class="nv">$expr</span><span class="o">]</span> <span class="k">does</span> <span class="nc">HakuExpr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Variable</span> <span class="nv">@.args</span> <span class="o">=</span> <span class="nv">@lambda-args</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="n">HakuExpr</span> <span class="nv">$.expr</span> <span class="o">=</span> <span class="nv">$expr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><h2 id="从解析树到抽象句法树">从解析树到抽象句法树&nbsp;<a class="headline-hash no-text-decoration" href="#从解析树到抽象句法树">#</a> </h2>
<p>Raku 的 grammar 提供了一个非常方便的机制来把解析树变成 AST，那就是 <a href="https://docs.raku.org/language/grammars#index-entry-Actions">Actions</a>。也就是说，你创建一个类，类中方法的名称与 grammar 中的 token 或 rule 相同。每个方法都获得由 token 创建的 <a href="https://docs.raku.org/type/Match">Match 对象</a>($/) 作为位置参数。</p>
<p>例如，从解析树中为 lambda 表达式填充 AST 节点:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">method</span> <span class="nf">lambda-expression</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">@args</span> <span class="o">=</span> <span class="nv">$&lt;variable-list&gt;</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$expr</span> <span class="o">=</span> <span class="nv">$&lt;expression&gt;</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">make</span> <span class="n">LambdaExpr</span><span class="o">[</span><span class="nv">@args</span><span class="o">,</span><span class="nv">$expr</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在 <code>lambda-expression</code> token 中使用的捕获 token 可以通过符号 <code>$&lt;...&gt;</code> 来访问，这是 <code>$/&lt;...&gt;</code> 的缩写，也就是说，它们是当前匹配对象的命名属性。</p>
<p>在 Haku grammar 中，有几个 token，其匹配对象是从一个备选列表中选择的，例如 <code>expression</code> token，它列举了任何在 Haku 中属于表达式的东西。对于这种 token，我使用以下代码从组成的 token 中&quot;继承&rdquo;:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">method</span> <span class="nf">expression</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">make</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">values</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="k">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>因为每个匹配都是一个 map，其键是捕获的 token 的名称，而且在这种情况下我们知道，只有一个 token 被选中，我们知道相应的 <code>values</code> 列表中的第一个元素将是那个特定 token 的匹配。</p>
<h2 id="代码生成">代码生成&nbsp;<a class="headline-hash no-text-decoration" href="#代码生成">#</a> </h2>
<p><code>haku.raku</code> 主程序基本上是做这样做的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$hon_parse</span> <span class="o">=</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Haku</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$program_str</span><span class="o">,</span> <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="n">HakuActions</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$hon_raku_code</span> <span class="o">=</span>  
</span></span><span class="line"><span class="cl">    <span class="nf">ppHakuProgram</span><span class="p">(</span><span class="nv">$hon_parse</span><span class="o">.</span><span class="k">made</span><span class="p">);</span>
</span></span></code></pre></div><p>使用 Haku grammar 对 Haku 程序字符串进行解析，并使用相应的 HakuActions 类中定义的方法来填充 AST。顶层的解析树节点必须是 <code>$&lt;haku-program&gt;</code>，这个节点的 <code>made</code> 方法返回 AST 节点 <code>HakuProgram</code>。例程 <code>ppHakuProgram</code> 是模块 <code>Raku</code> 中的顶层例程，它是 Haku 的 Raku 发射器。(在模块 <code>Scheme</code> 中也有一个 Scheme 发射器）。</p>
<p>所以 <code>ppHakuProgram($hon_parse.made)</code> 漂亮地打印出了 HakuProgram 的 AST 节点，从而将整个 Haku 程序变成 Raku 代码。</p>
<p>我喜欢基于角色的 AST 的原因是，你可以使用 <code>given/when</code> 对一个类型的变体进行模式匹配。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">ppHakuExpr</span><span class="p">(</span>\<span class="n">h</span><span class="p">)</span> <span class="p">{</span>            
</span></span><span class="line"><span class="cl">    <span class="k">given</span> <span class="n">h</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="n">BindExpr</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="n">FunctionApplyExpr</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="n">ListExpr</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="n">MapExpr</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>        
</span></span><span class="line"><span class="cl">        <span class="k">when</span>  <span class="n">IfExpr</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>   
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="n">LetExpr</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="n">LambdaExpr</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>        
</span></span><span class="line"><span class="cl">        <span class="o">...</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">TODO:</span><span class="p">&#34;</span> <span class="o">~</span> <span class="n">h</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>        
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>对应于 Haku AST 的 Raku 代码是非常直接的，但有几件事值得注意。</p>
<ul>
<li>因为 Haku 的变量是不可变的，我使用了 <code>\</code> 符号，这意味着我不必用符号建立一个变量表。</li>
<li>因为 Haku 是函数式的，<code>let</code> 和 <code>if</code> 是表达式，所以在 Raku 中我把它们包在 <code>do {}</code> 块中。</li>
<li>对于部分应用，我使用 <code>.assuming()</code>。</li>
<li>在 Haku 中，字符串是列表。在 Raku 中它们不是。我创建了一个小型的 Prelude 函数，在该 Prelude 中的列表操作函数使用 <code>given/when</code> 对类型进行模式匹配，看参数是字符串还是列表。</li>
</ul>
<h2 id="运行生成的-raku-代码">运行生成的 Raku 代码&nbsp;<a class="headline-hash no-text-decoration" href="#运行生成的-raku-代码">#</a> </h2>
<p>运行生成的 Raku 代码很简单。我把生成的 Raku 代码写到一个模块中并 <code>require</code> 它。生成的代码以调用 <code>hon()</code> 结束，这是 Haku 程序中的主函数，所以这将自动执行程序:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Write the parsed program to a module </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Hon.rakumod</span><span class="p">&#39;</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">open</span><span class="o">:</span> <span class="p">:</span><span class="s">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">put</span><span class="o">:</span> <span class="nv">$hon_raku_code</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Require the module. This will execute the program</span>
</span></span><span class="line"><span class="cl"><span class="k">require</span> <span class="n">Hon</span><span class="p">;</span>
</span></span></code></pre></div><p>Haku 让其他事情变得非常简单，就是创建命令行标志并记录它们的用法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">USAGE</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="k">Q</span><span class="sa">:to</span><span class="p">/EOH/;</span><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">    Usage: haku &lt;Haku program, written horizontally or vertically, utf-8 text file&gt;
</span></span></span><span class="line"><span class="cl"><span class="s">        [--tategaki, -t] : do not run the program but print it vertically.
</span></span></span><span class="line"><span class="cl"><span class="s">        [--miseru, -m] : just print the Raku source code, don&#39;t execute.
</span></span></span><span class="line"><span class="cl"><span class="s">        ...
</span></span></span><span class="line"><span class="cl"><span class="s">    </span><span class="p">EOH</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">unit</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="kt">Str</span> <span class="nv">$src_file</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">          <span class="kt">Bool</span> <span class="p">:</span><span class="s">t</span><span class="p">(</span><span class="nv">$tategaki</span><span class="p">)</span> <span class="o">=</span> <span class="kt">False</span><span class="o">,</span>   
</span></span><span class="line"><span class="cl">          <span class="kt">Bool</span> <span class="p">:</span><span class="s">m</span><span class="p">(</span><span class="nv">$miseru</span><span class="p">)</span> <span class="o">=</span> <span class="kt">False</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">          <span class="o">...</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>  
</span></span></code></pre></div><p>当调用 <code>MAIN</code> 时，如果参数错误(或没有参数)，则调用 <code>USAGE</code>。<code>MAIN</code> 的参数以 <code>:</code> 为前缀，是标志。<code>unit sub</code> 意味着在这个声明之后的任何内容都是主程序的一部分，所以不需要 <code>{...}</code>。</p>
<h2 id="总结">总结&nbsp;<a class="headline-hash no-text-decoration" href="#总结">#</a> </h2>
<p>这篇文章展示了懒惰的程序员创建自己的编程语言的方法: 让 Raku 做所有艰苦的工作。</p>
<p>或者用一个 Haku 程序来表达它:</p>
<p>　本真とは
　コンパイラを書いて、
　プログラムを書いて、
　プログラムを走らす
　と言う事です。</p>
<blockquote>
<p>the truth:
write the compiler,
write the program,
run the program.</p>
</blockquote>


        </div>
    </div>
</article>



                <footer>
                    




<div class="no-text-decoration">
    <div class="jump top"><a href="#" title="Top of this page">⮉</a></div>
    <div class="jump bottom"><a href="#bottom" title="Bottom of this page">⮋</a></div>
</div>


 
    
        <div class="hugotoc no-text-decoration">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#haku">Haku</a></li>
    <li><a href="#parsing-using-grammars">Parsing using Grammars</a>
      <ul>
        <li><a href="#excellent-unicode-support">Excellent Unicode support</a></li>
        <li><a href="#tokens-和-rules">Tokens 和 rules</a></li>
        <li><a href="#very-powerful-regexes">Very powerful regexes</a></li>
        <li><a href="#通过角色组合-grammar">通过角色组合 Grammar</a></li>
      </ul>
    </li>
    <li><a href="#使用了角色的抽象语法树">使用了角色的抽象语法树</a></li>
    <li><a href="#从解析树到抽象句法树">从解析树到抽象句法树</a></li>
    <li><a href="#代码生成">代码生成</a></li>
    <li><a href="#运行生成的-raku-代码">运行生成的 Raku 代码</a></li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
            <a href="#" class="back-to-top">Back to top</a>
        </div>
    
    
<script src="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js"></script>

<link rel="preload" href="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js" as="script">

<script type="application/javascript">(function() {
     var $window = $(window);
     if ($window.width() >= 1400) { 
         var $toc = $('#TableOfContents');
         if ($toc.length > 0) {
             function onScroll(){
                 var currentScroll = $window.scrollTop();
                 var h = $('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .h-feed h2');
                 var id = "";
                 h.each(function (i, e) {
                     e = $(e);
                     if (e.offset().top - 10 <= currentScroll) {
                         id = e.attr('id');
                     }
                 });
                 var current = $toc.find('a.current');
                 if (current.length == 1 && current.eq(0).attr('href') == '#' + id) return true;

                 current.each(function (i, e) {
                     $(e).removeClass('current').siblings('ul').hide();
                 });
                 $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                     $(e).children('a').addClass('current').siblings('ul').show();
                 });
             }
             $window.on('scroll', onScroll);
             $(document).ready(function() {
                 $toc.find('a').parent('li').find('ul').hide();
                 onScroll();
                 document.getElementsByClassName('hugotoc')[0].style.display = '';
             });}}})();</script>








<div class="backtotop center no-text-decoration">
    <a href="#">back to <span class="top">top</span></a>
</div>


<div class="right">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>
<div class="clear-float"></div>



<div class="prev-next-navigator clear-float">
    
        <span class="prev-post left no-text-decoration">
            <a href="https://ohmycloud.github.io/notes/2021-09-30-new-disp-is-here/" class="nobr">« New Disp Is Here</a>
        </span>
    
    
        <span class="next-post right no-text-decoration">
            <a href="https://ohmycloud.github.io/posts/2021-08-30-raku-features/" class="nobr">Raku Features »</a>
        </span>
    
</div>


<a id="bottom"></a>









                       







                    <ul class="no-bullets feed right inline">
    
        
        
    
</ul>
<div class="clear-float"></div>

                </footer>
                <hr />
            </div>               

            <footer> 
                

<ul class="social no-text-decoration">
    
</ul>










 
    
    



<p class="generated no-text-decoration">
    Generated using  <a href="https://gitlab.com/kaushalmodi/hugo-theme-refined"><code class="nobr">hugo-theme-refined</code></a> + <span class="nobr">Hugo <a href="https://github.com/gohugoio/hugo/commit/312735366b20d64bd61bff8627f593749f86c964">0.123.7</a></span>
</p>

<p>
    
</p>




<div class="badges no-text-decoration">
    
    

    
</div>




<script type="application/javascript">var nav=responsiveNav("#nav");</script>




<script defer src="/js/libs/fragmentions/wrapper.min.e8c468c89edc4f5dccaa8c720c6b220b3088a16cd7b1e4a1e3345985788260c9.js"></script>









            </footer>
        </div> 
    </body>
</html>
