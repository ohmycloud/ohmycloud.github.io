{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io/"},"content":{"html":"\u003ch1 id=\"haku-一种日语编程语言\"\u003eHaku: 一种日语编程语言\u003c/h1\u003e\n\u003cp\u003eHaku 是一种基于文学性日语的自然语言功能编程语言。这篇文章是关于 Haku 在 \u003ca href=\"https://raku.org/\"\u003eRaku\u003c/a\u003e 中的实现。你不需要懂日语或\u003ca href=\"https://codeberg.org/wimvanderbauwhede/haku\"\u003e阅读 Haku 的文档\u003c/a\u003e。如果你不熟悉 Raku，你可能想阅读\u003ca href=\"https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/#raku-intro\"\u003e我的快速介绍\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e我确实假定你对解析、语法树和代码生成的概念很熟悉。如果你发现你对下面的内容缺乏背景，我推荐 Andrew Shitov 的系列文章\u003ca href=\"https://andrewshitov.com/creating-a-compiler-with-raku/\"\u003e《用 Raku 创建编译器》\u003c/a\u003e，它采取了一个逐步的方法。\u003c/p\u003e\n\u003ch2 id=\"haku\"\u003eHaku\u003c/h2\u003e\n\u003cp\u003eHaku 的目标是接近书面日语，因此它是由汉字、平假名和片假名这三种日语书写系统以及日语标点符号组合而成的。没有空格，Haku 不使用阿拉伯（甚至是罗马）数字，也不使用任何运算符。该语言的设计\u003ca href=\"https://codeberg.org/wimvanderbauwhede/haku\"\u003e在文档中得到了更详细的解释\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e下面是一个小的 Haku 程序的例子（更多的例子请看 \u003ca href=\"https://codeberg.org/wimvanderbauwhede/haku/src/branch/main/examples\"\u003erepo\u003c/a\u003e）。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e本とは\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e「魄から楽まで」を見せる\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eの事です。\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这句话翻译过来就是:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u0026ldquo;main is: to show \u0026lsquo;From Haku to Raku\u0026rsquo;\u0026rdquo;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e而 Raku 版本是这样的:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003eFrom Haku to Raku\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e字符串\u0026quot;本とは \u0026ldquo;和 \u0026ldquo;の事です\u0026quot;表示主程序的开始和结束。\u0026ldquo;魄から楽まで \u0026ldquo;是一个字符串常数。\u0026ldquo;见せる \u0026ldquo;是打印函数。\u0026lsquo;\u0026lsquo;を\u0026rsquo;表示前面的东西是函数的一个参数。示例代码中的换行符是可选的，纯粹是为了方便阅读。Haku 程序是一个没有空白或换行的单一字符串。\u003c/p\u003e\n\u003cp\u003e这个例子的实际生成的 Raku 代码是这样的:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"k\"\u003ev\u003c/span\u003e\u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"nn\"\u003eHakuPrelude\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nf\"\u003eshow\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e魄から楽まで\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e为了更接近文学性的日语，Haku 程序可以从右到左竖着写。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eの 忘 本 　 の 条 条 遠 　 の 物 忘\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e事 れ と 　 こ を で い 　 こ で れ\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eで か は 　 と 見 　 と 　 と 空 る\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eす け 記 　 で せ 　 は 　 で 　 と\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e。 て 憶 　 す る 　 　 　 す 　 は\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e　 た は 　 。 　 　 　 　 。 　 　g\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e　 遠 無 　 　 　 　 　 　 　 　 　\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e　 い 、 　 　 　 　 　 　 　 　 　\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e　 記 　 　 　 　 　 　 　 　 　 　\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e　 憶 　 　 　 　 　 　 　 　 　 　\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e为这个 Haku 程序生成的 Raku 代码同样非常简单。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"k\"\u003ev\u003c/span\u003e\u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"nn\"\u003eHakuPrelude\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003ewasureru\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \\\u003cspan class=\"n\"\u003emono\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003etooi\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \\\u003cspan class=\"n\"\u003ejou\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"nf\"\u003eshow\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ejou\u003c/span\u003e\u003cspan class=\"p\"\u003e)}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003ehon\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e\\kioku\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kt\"\u003eNil\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nf\"\u003ewasureru\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nf\"\u003etooi\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekioku\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003ehon\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHaku 是用 Raku 实现的。Haku 编译器是一个源到源的编译器（有时称为转译器），它从 Haku 源生成 Raku 源并执行它。Raku 在许多方面使编写这样的编译器变得容易。\u003c/p\u003e\n\u003ch2 id=\"parsing-using-grammars\"\u003eParsing using Grammars\u003c/h2\u003e\n\u003cp\u003e我决定用 Raku 来实现 Haku，主要是因为我想使用 Raku 的 \u003ca href=\"https://docs.raku.org/language/grammars\"\u003eGrammar\u003c/a\u003e 功能，而且它没有让我失望。Grammar 就像一个类，但它没有方法，而是有 rule 或 token，它们是解析器的构建块。任何 token 都可以在另一个 token 的定义中使用，例如用 \u003ccode\u003e\u0026lt;...\u0026gt;\u003c/code\u003e 将其括起来。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003eadjective\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003ei-adjective\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003ena-adjective\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003ei-adjective\u003c/code\u003e 和 \u003ccode\u003ena-adjective\u003c/code\u003e 已经被分别定义，\u003ccode\u003eadjective\u003c/code\u003e 与其中一个相匹配。\u003c/p\u003e\n\u003cp\u003e我一直喜欢解析器组合器（如 Haskell 中的 \u003ca href=\"https://www.futurelearn.com/info/courses/functional-programming-haskell/0/steps/27222\"\u003eParsec\u003c/a\u003e），从某种角度看，Raku 的 grammar 也很相似。它们都是无扫描器，即没有单独的 token 化步骤，而且高度可组合。Parsec 提供的许多功能（如 \u003ccode\u003emany\u003c/code\u003e,\u003ccode\u003e oneOf\u003c/code\u003e, \u003ccode\u003esepBy\u003c/code\u003e）都可以通过 Raku 的 regex 来实现。\u003c/p\u003e\n\u003cp\u003eRaku 的 grammar 有几个特点，有助于使 Haku 的解析器易于实现。\u003c/p\u003e\n\u003ch3 id=\"excellent-unicode-support\"\u003eExcellent Unicode support\u003c/h3\u003e\n\u003cp\u003e我认为 Raku 的 Unicode 支持真的很好。例如，由于对 Unicode 块的支持，我可以简单地写出:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003ekanji\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;:\u003c/span\u003e\u003cspan class=\"na\"\u003eBlock\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003eCJK Unified Ideographs\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;)\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e而不是把它们全部列举出来（该块中有 92,865 个汉字！）。事实上， \u003ccode\u003e\u0026lt;:...\u0026gt;\u003c/code\u003e 语法适用于任何 Unicode 属性，而不仅仅是 Blocks。\u003c/p\u003e\n\u003cp\u003e甚至更好。我有一些汉字被保留为关键词。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003ereserved-kanji\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e本\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e事\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e..\u003c/span\u003e\u003cspan class=\"ni\"\u003e.\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e为了确保这些被排除在 Haku 的有效汉字之外，我可以简单地使用一个差集。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003ekanji\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;:\u003c/span\u003e\u003cspan class=\"na\"\u003eBlock\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003eCJK Unified Ideographs\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;)\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"sr\"\u003ereserved\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"sr\"\u003ekanji\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e(有一个细节让我感到不安的是，用户定义的字符类的等效语法需要一个显式的  \u0026lsquo;+\u0026rsquo;: \u003ccode\u003etoken set-difference { \u0026lt; +set1 - set2\u0026gt; }\u003c/code\u003e)\u003c/p\u003e\n\u003ch3 id=\"tokens-和-rules\"\u003eTokens 和 rules\u003c/h3\u003e\n\u003cp\u003e幸运的是，Raku 默认不会假设你想解析可以忽略空白的东西，或者你想在空白处进行标记。如果你想忽略空白，你可以使用 \u003ccode\u003erule\u003c/code\u003e。但是在 Haku 中，不允许不相干的空白（除了某些位置的换行）。所以我在任何地方都使用 \u003ccode\u003etoken\u003c/code\u003e。(还有 \u003ca href=\"https://docs.raku.org/language/grammars#index-entry-declarator_token-Named_Regexes\"\u003e\u003ccode\u003eregex\u003c/code\u003e，可以回溯\u003c/a\u003e。在 Haku 的语法中我不需要它）。)\u003c/p\u003e\n\u003ch3 id=\"very-powerful-regexes\"\u003eVery powerful regexes\u003c/h3\u003e\n\u003cp\u003e作为一个 lambdacamel，我一直很喜欢 Perl 的 regexes，现在无处不在的 \u003ca href=\"https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions\"\u003ePCREs\u003c/a\u003e。然而，\u003ca href=\"https://docs.raku.org/language/regexes\"\u003eRaku 的 regexes\u003c/a\u003e 在功能、表现力和可读性方面远远超过了它。\u003c/p\u003e\n\u003cp\u003e首先，它们是可组合的: 你可以用 \u003ccode\u003eregex\u003c/code\u003e 类型定义一个命名的 regex，然后用 \u003ccode\u003e\u0026lt;...\u0026gt;\u003c/code\u003e 语法在随后的 regex 中使用它。另外，设计时的谨慎使它们非常容易使用。例如，一个否定向前查看断言只是 \u003ccode\u003e\u0026lt;no\u0026gt; \u0026lt;!before \u0026lt;koto\u0026gt; \u0026gt;\u003c/code\u003e；而尝试顺序交替(\u003ccode\u003e||\u003c/code\u003e)和最长令牌匹配交替(\u003ccode\u003e|\u003c/code\u003e)的可用性是一个巨大的好处。我非常喜欢的另一件事是使一个字符类不被捕获的能力。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003elambda-expression\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003earu\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003evariable-list\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ede\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003eexpression\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e只有 \u003ccode\u003e\u0026lt;variable-list\u0026gt;\u003c/code\u003e 和 \u003ccode\u003e\u0026lt;expression\u0026gt;\u003c/code\u003e 会被捕获，所以很多具体的语法可以在解析时被删除。\u003c/p\u003e\n\u003ch3 id=\"通过角色组合-grammar\"\u003e通过角色组合 Grammar\u003c/h3\u003e\n\u003cp\u003eRoles (Ruby 中的 \u0026lsquo;mixins\u0026rsquo;, Rust 中的 \u0026rsquo;traits\u0026rsquo;) 定义或实现这些接口。\n我发现这比同样支持的类继承更适合我的目的。比如说:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003erole\u003c/span\u003e \u003cspan class=\"nc\"\u003eNouns\u003c/span\u003e \u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eCharacters\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003esa\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003eさ\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003eki\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003eき\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# 一線 is OK,  一 is not OK, 線 is OK\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003enoun\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003enumber-kanji\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"o\"\u003e?\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003enon-number-kanji\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003ekanji\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"sr\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e[\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003esa\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003eki\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;]\u003c/span\u003e\u003cspan class=\"o\"\u003e?\u003c/span\u003e\u003cspan class=\"sr\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003erole\u003c/span\u003e \u003cspan class=\"nc\"\u003eIdentifiers\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eVerbs\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eNouns\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eAdjectives\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eVariables\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003enominaliser\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e        \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003eno\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"ow\"\u003ebefore\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003ekoto\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e        \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003ekoto\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"ow\"\u003ebefore\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003edesu\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# Identifiers are variables,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# noun-style, verb-style\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# and adjective-style function names\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003eidentifier\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e        \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003evariable\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e        \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003everb\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003enominaliser\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"o\"\u003e?\u003c/span\u003e\u003cspan class=\"sr\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e        \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003enoun\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003esura\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"o\"\u003e?\u003c/span\u003e\u003cspan class=\"sr\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e        \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003eadjective\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e(虽然我希望有一个列表的语法，像 \u003ccode\u003erole Identifiers does Verbs, Nouns, Adjectives, Variables {...}\u003c/code\u003e 这样的语法。)\u003c/p\u003e\n\u003cp\u003eGrammar 和 regexes 的内容还有很多。Twitter 上好心的 Raku 朋友向我推荐了 Moritz Lenz 写的 \u003ca href=\"https://link.springer.com/book/10.1007/978-1-4842-3228-6\"\u003eParsing with Perl 6 Regexes and Grammars\u003c/a\u003e 一书，这本书特别是在调试 grammar 和处理错误信息方面非常有用。\u003c/p\u003e\n\u003ch2 id=\"使用了角色的抽象语法树\"\u003e使用了角色的抽象语法树\u003c/h2\u003e\n\u003cp\u003e我喜欢把抽象语法树(AST)作为代数数据类型来实现，就像在 Haskell 中通常采用的方式。在 Raku 中，一种方法是使用参数化的角色，正如我在\u003ca href=\"https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku\"\u003e之前的文章中解释的那样\u003c/a\u003e。大部分的 AST 直接映射到我的 grammar 中每个角色的顶层解析器，例如 lambda 表达式:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003erole\u003c/span\u003e \u003cspan class=\"nc\"\u003eLambdaExpr\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"nv\"\u003e@lambda-args\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nv\"\u003e$expr\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003edoes\u003c/span\u003e \u003cspan class=\"nc\"\u003eHakuExpr\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ehas\u003c/span\u003e \u003cspan class=\"kt\"\u003eVariable\u003c/span\u003e \u003cspan class=\"nv\"\u003e@.args\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nv\"\u003e@lambda-args\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ehas\u003c/span\u003e \u003cspan class=\"n\"\u003eHakuExpr\u003c/span\u003e \u003cspan class=\"nv\"\u003e$.expr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nv\"\u003e$expr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"从解析树到抽象句法树\"\u003e从解析树到抽象句法树\u003c/h2\u003e\n\u003cp\u003eRaku 的 grammar 提供了一个非常方便的机制来把解析树变成 AST，那就是 \u003ca href=\"https://docs.raku.org/language/grammars#index-entry-Actions\"\u003eActions\u003c/a\u003e。也就是说，你创建一个类，类中方法的名称与 grammar 中的 token 或 rule 相同。每个方法都获得由 token 创建的 \u003ca href=\"https://docs.raku.org/type/Match\"\u003eMatch 对象\u003c/a\u003e($/) 作为位置参数。\u003c/p\u003e\n\u003cp\u003e例如，从解析树中为 lambda 表达式填充 AST 节点:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nf\"\u003elambda-expression\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$/\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e@args\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nv\"\u003e$\u0026lt;variable-list\u0026gt;\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"k\"\u003emade\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$expr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nv\"\u003e$\u0026lt;expression\u0026gt;\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"k\"\u003emade\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003emake\u003c/span\u003e \u003cspan class=\"n\"\u003eLambdaExpr\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"nv\"\u003e@args\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\u003cspan class=\"nv\"\u003e$expr\u003c/span\u003e\u003cspan class=\"o\"\u003e].\u003c/span\u003e\u003cspan class=\"nb\"\u003enew\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 \u003ccode\u003elambda-expression\u003c/code\u003e token 中使用的捕获 token 可以通过符号 \u003ccode\u003e$\u0026lt;...\u0026gt;\u003c/code\u003e 来访问，这是 \u003ccode\u003e$/\u0026lt;...\u0026gt;\u003c/code\u003e 的缩写，也就是说，它们是当前匹配对象的命名属性。\u003c/p\u003e\n\u003cp\u003e在 Haku grammar 中，有几个 token，其匹配对象是从一个备选列表中选择的，例如 \u003ccode\u003eexpression\u003c/code\u003e token，它列举了任何在 Haku 中属于表达式的东西。对于这种 token，我使用以下代码从组成的 token 中\u0026quot;继承\u0026rdquo;:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nf\"\u003eexpression\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$/\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003emake\u003c/span\u003e \u003cspan class=\"nv\"\u003e$/\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003evalues\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e].\u003c/span\u003e\u003cspan class=\"k\"\u003emade\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e因为每个匹配都是一个 map，其键是捕获的 token 的名称，而且在这种情况下我们知道，只有一个 token 被选中，我们知道相应的 \u003ccode\u003evalues\u003c/code\u003e 列表中的第一个元素将是那个特定 token 的匹配。\u003c/p\u003e\n\u003ch2 id=\"代码生成\"\u003e代码生成\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ehaku.raku\u003c/code\u003e 主程序基本上是做这样做的:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$hon_parse\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eHaku\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eparse\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$program_str\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003eactions\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eHakuActions\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$hon_raku_code\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nf\"\u003eppHakuProgram\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$hon_parse\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"k\"\u003emade\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e使用 Haku grammar 对 Haku 程序字符串进行解析，并使用相应的 HakuActions 类中定义的方法来填充 AST。顶层的解析树节点必须是 \u003ccode\u003e$\u0026lt;haku-program\u0026gt;\u003c/code\u003e，这个节点的 \u003ccode\u003emade\u003c/code\u003e 方法返回 AST 节点 \u003ccode\u003eHakuProgram\u003c/code\u003e。例程 \u003ccode\u003eppHakuProgram\u003c/code\u003e 是模块 \u003ccode\u003eRaku\u003c/code\u003e 中的顶层例程，它是 Haku 的 Raku 发射器。(在模块 \u003ccode\u003eScheme\u003c/code\u003e 中也有一个 Scheme 发射器）。\u003c/p\u003e\n\u003cp\u003e所以 \u003ccode\u003eppHakuProgram($hon_parse.made)\u003c/code\u003e 漂亮地打印出了 HakuProgram 的 AST 节点，从而将整个 Haku 程序变成 Raku 代码。\u003c/p\u003e\n\u003cp\u003e我喜欢基于角色的 AST 的原因是，你可以使用 \u003ccode\u003egiven/when\u003c/code\u003e 对一个类型的变体进行模式匹配。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003eppHakuExpr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\\\u003cspan class=\"n\"\u003eh\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e            \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003egiven\u003c/span\u003e \u003cspan class=\"n\"\u003eh\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ewhen\u003c/span\u003e \u003cspan class=\"n\"\u003eBindExpr\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ewhen\u003c/span\u003e \u003cspan class=\"n\"\u003eFunctionApplyExpr\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ewhen\u003c/span\u003e \u003cspan class=\"n\"\u003eListExpr\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ewhen\u003c/span\u003e \u003cspan class=\"n\"\u003eMapExpr\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ewhen\u003c/span\u003e  \u003cspan class=\"n\"\u003eIfExpr\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e   \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ewhen\u003c/span\u003e \u003cspan class=\"n\"\u003eLetExpr\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ewhen\u003c/span\u003e \u003cspan class=\"n\"\u003eLambdaExpr\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003edefault\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nb\"\u003edie\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eTODO:\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e~\u003c/span\u003e \u003cspan class=\"n\"\u003eh\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eraku\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e对应于 Haku AST 的 Raku 代码是非常直接的，但有几件事值得注意。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e因为 Haku 的变量是不可变的，我使用了 \u003ccode\u003e\\\u003c/code\u003e 符号，这意味着我不必用符号建立一个变量表。\u003c/li\u003e\n\u003cli\u003e因为 Haku 是函数式的，\u003ccode\u003elet\u003c/code\u003e 和 \u003ccode\u003eif\u003c/code\u003e 是表达式，所以在 Raku 中我把它们包在 \u003ccode\u003edo {}\u003c/code\u003e 块中。\u003c/li\u003e\n\u003cli\u003e对于部分应用，我使用 \u003ccode\u003e.assuming()\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e在 Haku 中，字符串是列表。在 Raku 中它们不是。我创建了一个小型的 Prelude 函数，在该 Prelude 中的列表操作函数使用 \u003ccode\u003egiven/when\u003c/code\u003e 对类型进行模式匹配，看参数是字符串还是列表。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"运行生成的-raku-代码\"\u003e运行生成的 Raku 代码\u003c/h2\u003e\n\u003cp\u003e运行生成的 Raku 代码很简单。我把生成的 Raku 代码写到一个模块中并 \u003ccode\u003erequire\u003c/code\u003e 它。生成的代码以调用 \u003ccode\u003ehon()\u003c/code\u003e 结束，这是 Haku 程序中的主函数，所以这将自动执行程序:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# Write the parsed program to a module \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$fh\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003eHon.rakumod\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"kt\"\u003eIO\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eopen\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003ew\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$fh\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eput\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nv\"\u003e$hon_raku_code\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$fh\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eclose\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# Require the module. This will execute the program\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003erequire\u003c/span\u003e \u003cspan class=\"n\"\u003eHon\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHaku 让其他事情变得非常简单，就是创建命令行标志并记录它们的用法:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nb\"\u003eUSAGE\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003eprint\u003c/span\u003e \u003cspan class=\"k\"\u003eQ\u003c/span\u003e\u003cspan class=\"sa\"\u003e:to\u003c/span\u003e\u003cspan class=\"p\"\u003e/EOH/;\u003c/span\u003e\u003cspan class=\"s\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e    Usage: haku \u0026lt;Haku program, written horizontally or vertically, utf-8 text file\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e        [--tategaki, -t] : do not run the program but print it vertically.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e        [--miseru, -m] : just print the Raku source code, don\u0026#39;t execute.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e        ...\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003eEOH\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eunit\u003c/span\u003e \u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nb\"\u003eMAIN\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e          \u003cspan class=\"kt\"\u003eStr\u003c/span\u003e \u003cspan class=\"nv\"\u003e$src_file\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e          \u003cspan class=\"kt\"\u003eBool\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$tategaki\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kt\"\u003eFalse\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e   \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e          \u003cspan class=\"kt\"\u003eBool\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$miseru\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kt\"\u003eFalse\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e          \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e);\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e当调用 \u003ccode\u003eMAIN\u003c/code\u003e 时，如果参数错误(或没有参数)，则调用 \u003ccode\u003eUSAGE\u003c/code\u003e。\u003ccode\u003eMAIN\u003c/code\u003e 的参数以 \u003ccode\u003e:\u003c/code\u003e 为前缀，是标志。\u003ccode\u003eunit sub\u003c/code\u003e 意味着在这个声明之后的任何内容都是主程序的一部分，所以不需要 \u003ccode\u003e{...}\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\n\u003cp\u003e这篇文章展示了懒惰的程序员创建自己的编程语言的方法: 让 Raku 做所有艰苦的工作。\u003c/p\u003e\n\u003cp\u003e或者用一个 Haku 程序来表达它:\u003c/p\u003e\n\u003cp\u003e　本真とは\n　コンパイラを書いて、\n　プログラムを書いて、\n　プログラムを走らす\n　と言う事です。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003ethe truth:\nwrite the compiler,\nwrite the program,\nrun the program.\u003c/p\u003e\n\u003c/blockquote\u003e\n","text":"Haku: 一种日语编程语言 Haku 是一种基于文学性日语的自然语言功能编程语言。这篇文章是关于 Haku 在 Raku 中的实现。你不需要懂日语或阅读 Haku 的文档。如果你不熟悉 Raku，你可能想阅读我的快速介绍。\n我确实假定你对解析、语法树和代码生成的概念很熟悉。如果你发现你对下面的内容缺乏背景，我推荐 Andrew Shitov 的系列文章《用 Raku 创建编译器》，它采取了一个逐步的方法。\nHaku Haku 的目标是接近书面日语，因此它是由汉字、平假名和片假名这三种日语书写系统以及日语标点符号组合而成的。没有空格，Haku 不使用阿拉伯（甚至是罗马）数字，也不使用任何运算符。该语言的设计在文档中得到了更详细的解释。\n下面是一个小的 Haku 程序的例子（更多的例子请看 repo）。\n本とは 「魄から楽まで」を見せる の事です。 这句话翻译过来就是:\n\u0026ldquo;main is: to show \u0026lsquo;From Haku to Raku\u0026rsquo;\u0026rdquo;\n而 Raku 版本是这样的:\nsay \u0026#39;From Haku to Raku\u0026#39;; 字符串\u0026quot;本とは \u0026ldquo;和 \u0026ldquo;の事です\u0026quot;表示主程序的开始和结束。\u0026ldquo;魄から楽まで \u0026ldquo;是一个字符串常数。\u0026ldquo;见せる \u0026ldquo;是打印函数。\u0026lsquo;\u0026lsquo;を\u0026rsquo;表示前面的东西是函数的一个参数。示例代码中的换行符是可选的，纯粹是为了方便阅读。Haku 程序是一个没有空白或换行的单一字符串。\n这个例子的实际生成的 Raku 代码是这样的:\nuse v6; use HakuPrelude; sub main() { show(\u0026#39;魄から楽まで\u0026#39;) } main(); 为了更接近文学性的日语，Haku 程序可以从右到左竖着写。\nの 忘 本 の 条 条 遠 の 物 忘 事 れ と こ を で い こ で れ で か は と 見 と と 空 る す け 記 で せ は で と 。 て 憶 す る す は た は 。 。 g 遠 無 い 、 記 憶 为这个 Haku 程序生成的 Raku 代码同样非常简单。\nuse v6; use HakuPrelude; sub wasureru( \\mono) {[]} sub tooi( \\jou) {show(jou)} sub hon() { my \\kioku = Nil; wasureru(tooi(kioku)) } hon(); Haku 是用 Raku 实现的。Haku 编译器是一个源到源的编译器（有时称为转译器），它从 Haku 源生成 Raku 源并执行它。Raku 在许多方面使编写这样的编译器变得容易。\nParsing using Grammars 我决定用 Raku 来实现 Haku，主要是因为我想使用 Raku 的 Grammar 功能，而且它没有让我失望。Grammar 就像一个类，但它没有方法，而是有 rule 或 token，它们是解析器的构建块。任何 token 都可以在另一个 token 的定义中使用，例如用 \u0026lt;...\u0026gt; 将其括起来。\ntoken adjective { \u0026lt;i-adjective\u0026gt; | \u0026lt;na-adjective\u0026gt; } i-adjective 和 na-adjective 已经被分别定义，adjective 与其中一个相匹配。\n我一直喜欢解析器组合器（如 Haskell 中的 Parsec），从某种角度看，Raku 的 grammar 也很相似。它们都是无扫描器，即没有单独的 token 化步骤，而且高度可组合。Parsec 提供的许多功能（如 many, oneOf, sepBy）都可以通过 Raku 的 regex 来实现。\nRaku 的 grammar 有几个特点，有助于使 Haku 的解析器易于实现。\nExcellent Unicode support 我认为 Raku 的 Unicode 支持真的很好。例如，由于对 Unicode 块的支持，我可以简单地写出:\ntoken kanji { \u0026lt;:Block(\u0026#39;CJK Unified Ideographs\u0026#39;)\u0026gt; } 而不是把它们全部列举出来（该块中有 92,865 个汉字！）。事实上， \u0026lt;:...\u0026gt; 语法适用于任何 Unicode 属性，而不仅仅是 Blocks。\n甚至更好。我有一些汉字被保留为关键词。\ntoken reserved-kanji { \u0026#39;本\u0026#39; | \u0026#39;事\u0026#39; | ... } 为了确保这些被排除在 Haku 的有效汉字之外，我可以简单地使用一个差集。\ntoken kanji { \u0026lt;:Block(\u0026#39;CJK Unified Ideographs\u0026#39;) - reserved-kanji \u0026gt; } (有一个细节让我感到不安的是，用户定义的字符类的等效语法需要一个显式的 \u0026lsquo;+\u0026rsquo;: token set-difference { \u0026lt; +set1 - set2\u0026gt; })\nTokens 和 rules 幸运的是，Raku 默认不会假设你想解析可以忽略空白的东西，或者你想在空白处进行标记。如果你想忽略空白，你可以使用 rule。但是在 Haku 中，不允许不相干的空白（除了某些位置的换行）。所以我在任何地方都使用 token。(还有 regex，可以回溯。在 Haku 的语法中我不需要它）。)\nVery powerful regexes 作为一个 lambdacamel，我一直很喜欢 Perl 的 regexes，现在无处不在的 PCREs。然而，Raku 的 regexes 在功能、表现力和可读性方面远远超过了它。\n首先，它们是可组合的: 你可以用 regex 类型定义一个命名的 regex，然后用 \u0026lt;...\u0026gt; 语法在随后的 regex 中使用它。另外，设计时的谨慎使它们非常容易使用。例如，一个否定向前查看断言只是 \u0026lt;no\u0026gt; \u0026lt;!before \u0026lt;koto\u0026gt; \u0026gt;；而尝试顺序交替(||)和最长令牌匹配交替(|)的可用性是一个巨大的好处。我非常喜欢的另一件事是使一个字符类不被捕获的能力。\ntoken lambda-expression { \u0026lt;.aru\u0026gt; \u0026lt;variable-list\u0026gt; \u0026lt;.de\u0026gt; \u0026lt;expression\u0026gt; } 只有 \u0026lt;variable-list\u0026gt; 和 \u0026lt;expression\u0026gt; 会被捕获，所以很多具体的语法可以在解析时被删除。\n通过角色组合 Grammar Roles (Ruby 中的 \u0026lsquo;mixins\u0026rsquo;, Rust 中的 \u0026rsquo;traits\u0026rsquo;) 定义或实现这些接口。 我发现这比同样支持的类继承更适合我的目的。比如说:\nrole Nouns does Characters { token sa { \u0026#39;さ\u0026#39; } token ki { \u0026#39;き\u0026#39; } # 一線 is OK, 一 is not OK, 線 is OK token noun { \u0026lt;number-kanji\u0026gt;? \u0026lt;non-number-kanji\u0026gt; \u0026lt;kanji\u0026gt;* [\u0026lt;sa\u0026gt;|\u0026lt;ki\u0026gt;]? } } role Identifiers does Verbs does Nouns does Adjectives does Variables { token nominaliser { | \u0026lt;no\u0026gt; \u0026lt;!before \u0026lt;koto\u0026gt; \u0026gt; | \u0026lt;koto\u0026gt; \u0026lt;!before \u0026lt;desu\u0026gt; \u0026gt; } # Identifiers are variables, # noun-style, verb-style # and adjective-style function names token identifier { | \u0026lt;variable\u0026gt; | \u0026lt;verb\u0026gt; \u0026lt;nominaliser\u0026gt;? | \u0026lt;noun\u0026gt; \u0026lt;.sura\u0026gt;? | \u0026lt;adjective\u0026gt; } } (虽然我希望有一个列表的语法，像 role Identifiers does Verbs, Nouns, Adjectives, Variables {...} 这样的语法。)\nGrammar 和 regexes 的内容还有很多。Twitter 上好心的 Raku 朋友向我推荐了 Moritz Lenz 写的 Parsing with Perl 6 Regexes and Grammars 一书，这本书特别是在调试 grammar 和处理错误信息方面非常有用。\n使用了角色的抽象语法树 我喜欢把抽象语法树(AST)作为代数数据类型来实现，就像在 Haskell 中通常采用的方式。在 Raku 中，一种方法是使用参数化的角色，正如我在之前的文章中解释的那样。大部分的 AST 直接映射到我的 grammar 中每个角色的顶层解析器，例如 lambda 表达式:\nrole LambdaExpr[@lambda-args, $expr] does HakuExpr { has Variable @.args = @lambda-args; has HakuExpr $.expr = $expr; } 从解析树到抽象句法树 Raku 的 grammar 提供了一个非常方便的机制来把解析树变成 AST，那就是 Actions。也就是说，你创建一个类，类中方法的名称与 grammar 中的 token 或 rule 相同。每个方法都获得由 token 创建的 Match 对象($/) 作为位置参数。\n例如，从解析树中为 lambda 表达式填充 AST 节点:\nmethod lambda-expression($/) { my @args = $\u0026lt;variable-list\u0026gt;.made; my $expr = $\u0026lt;expression\u0026gt;.made; make LambdaExpr[@args,$expr].new; } 在 lambda-expression token 中使用的捕获 token 可以通过符号 $\u0026lt;...\u0026gt; 来访问，这是 $/\u0026lt;...\u0026gt; 的缩写，也就是说，它们是当前匹配对象的命名属性。\n在 Haku grammar 中，有几个 token，其匹配对象是从一个备选列表中选择的，例如 expression token，它列举了任何在 Haku 中属于表达式的东西。对于这种 token，我使用以下代码从组成的 token 中\u0026quot;继承\u0026rdquo;:\nmethod expression($/) { make $/.values[0].made; } 因为每个匹配都是一个 map，其键是捕获的 token 的名称，而且在这种情况下我们知道，只有一个 token 被选中，我们知道相应的 values 列表中的第一个元素将是那个特定 token 的匹配。\n代码生成 haku.raku 主程序基本上是做这样做的:\nmy $hon_parse = Haku.parse($program_str, :actions(HakuActions)); my $hon_raku_code = ppHakuProgram($hon_parse.made); 使用 Haku grammar 对 Haku 程序字符串进行解析，并使用相应的 HakuActions 类中定义的方法来填充 AST。顶层的解析树节点必须是 $\u0026lt;haku-program\u0026gt;，这个节点的 made 方法返回 AST 节点 HakuProgram。例程 ppHakuProgram 是模块 Raku 中的顶层例程，它是 Haku 的 Raku 发射器。(在模块 Scheme 中也有一个 Scheme 发射器）。\n所以 ppHakuProgram($hon_parse.made) 漂亮地打印出了 HakuProgram 的 AST 节点，从而将整个 Haku 程序变成 Raku 代码。\n我喜欢基于角色的 AST 的原因是，你可以使用 given/when 对一个类型的变体进行模式匹配。\nsub ppHakuExpr(\\h) { given h { when BindExpr { ... } when FunctionApplyExpr { ... } when ListExpr { ... } when MapExpr { ... } when IfExpr { ... } when LetExpr { ... } when LambdaExpr { ... } ... default { die \u0026#34;TODO:\u0026#34; ~ h.raku; } } } 对应于 Haku AST 的 Raku 代码是非常直接的，但有几件事值得注意。\n因为 Haku 的变量是不可变的，我使用了 \\ 符号，这意味着我不必用符号建立一个变量表。 因为 Haku 是函数式的，let 和 if 是表达式，所以在 Raku 中我把它们包在 do {} 块中。 对于部分应用，我使用 .assuming()。 在 Haku 中，字符串是列表。在 Raku 中它们不是。我创建了一个小型的 Prelude 函数，在该 Prelude 中的列表操作函数使用 given/when 对类型进行模式匹配，看参数是字符串还是列表。 运行生成的 Raku 代码 运行生成的 Raku 代码很简单。我把生成的 Raku 代码写到一个模块中并 require 它。生成的代码以调用 hon() 结束，这是 Haku 程序中的主函数，所以这将自动执行程序:\n# Write the parsed program to a module my $fh = \u0026#39;Hon.rakumod\u0026#39;.IO.open: :w; $fh.put: $hon_raku_code; $fh.close; # Require the module. This will execute the program require Hon; Haku 让其他事情变得非常简单，就是创建命令行标志并记录它们的用法:\nsub USAGE() { print Q:to/EOH/; Usage: haku \u0026lt;Haku program, written horizontally or vertically, utf-8 text file\u0026gt; [--tategaki, -t] : do not run the program but print it vertically. [--miseru, -m] : just print the Raku source code, don\u0026#39;t execute. ... EOH } unit sub MAIN( Str $src_file, Bool :t($tategaki) = False, Bool :m($miseru) = False, ... ); 当调用 MAIN 时，如果参数错误(或没有参数)，则调用 USAGE。MAIN 的参数以 : 为前缀，是标志。unit sub 意味着在这个声明之后的任何内容都是主程序的一部分，所以不需要 {...}。\n总结 这篇文章展示了懒惰的程序员创建自己的编程语言的方法: 让 Raku 做所有艰苦的工作。\n或者用一个 Haku 程序来表达它:\n本真とは コンパイラを書いて、 プログラムを書いて、 プログラムを走らす と言う事です。\nthe truth: write the compiler, write the program, run the program.\n"},"name":"Haku a Japanese Programming Language","published":"2021-09-24T00:00:00Z","summary":"Haku a Japanese Programming Language","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-09-24-haku-a-japanese-programming-language/"}