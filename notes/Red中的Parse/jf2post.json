{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io/"},"content":{"html":"\u003ch2 id=\"parse-入门\"\u003eParse 入门\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"http://rebol.com/\"\u003eRebol\u003c/a\u003e 语言最大的特色之一就是它的解析引擎，简称为 \u003cstrong\u003eParse\u003c/strong\u003e。这是卡尔·萨森拉斯（\u003ca href=\"http://en.wikipedia.org/wiki/Carl_Sassenrath\"\u003eCarl Sassenrath\u003c/a\u003e）的一个惊人设计，在过去的15年里，所有 Rebol 用户都免于使用臭名昭著的无法维护的 \u003ca href=\"http://en.wikipedia.org/wiki/Regular_expression\"\u003eregexp\u003c/a\u003e 的\u003ca href=\"http://www.codinghorror.com/blog/2005/02/regex-use-vs-regex-abuse.html\"\u003e痛苦\u003c/a\u003e。现在，Parse 也可用于 \u003cstrong\u003eR\u003c/strong\u003eed 用户，而且是增强版！\u003c/p\u003e\n\u003cp\u003e那么，简而言之，什么是 Parse？它是一个嵌入式 \u003ca href=\"http://en.wikipedia.org/wiki/Domain-specific_language\"\u003eDSL\u003c/a\u003e（我们称之为 Rebol 世界中的“方言”），用于使用语法规则解析输入序列。 Parse 方言是 \u003ca href=\"http://en.wikipedia.org/wiki/Top-down_parsing_language\"\u003eTDPL\u003c/a\u003e 家族的\u003ca href=\"http://www.rebol.net/wiki/Parse_Project#Theory_of_PARSE\"\u003e增强成员\u003c/a\u003e。 Parse 的常见用法是检查，验证，提取，修改输入数据，甚至实现嵌入式和外部 DSL。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eparse\u003c/code\u003e 函数调用语法很简单：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003eparse \u0026lt;input\u0026gt; \u0026lt;rules\u0026gt;  \n\n\u0026lt;input\u0026gt;: 任意系列值 (字符串, 文件, 块儿, 路径, ...)\n\u0026lt;rules\u0026gt;: 块儿! 具有有效 Parse 方言内容的值\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这里有几个例子，即使你不懂 Red 和解析方言，你仍然可以“获得”它们中的大多数，不像正则表达式。您可以将它们直接复制/粘贴到 Red 控制台中。\u003c/p\u003e\n\u003cp\u003e使用语法规则进行字符串或块输入验证的一些简单示例：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003eparse \u0026#34;a plane\u0026#34; [[\u0026#34;a\u0026#34; | \u0026#34;the\u0026#34;] space \u0026#34;plane\u0026#34;] ;-- rule 中的空格需要用 space 显式声明\nparse \u0026#34;the car\u0026#34; [[\u0026#34;a\u0026#34; | \u0026#34;the\u0026#34;] space [\u0026#34;plane\u0026#34; | \u0026#34;car\u0026#34;]]\n\nparse \u0026#34;123\u0026#34; [\u0026#34;1\u0026#34; \u0026#34;2\u0026#34; [\u0026#34;4\u0026#34; | \u0026#34;3\u0026#34;]] ;-- rule 中的空格默认被忽略\nparse \u0026#34;abbccc\u0026#34; [\u0026#34;a\u0026#34; 2 \u0026#34;b\u0026#34; 3 \u0026#34;c\u0026#34;]  ;-- 一个 a, 俩个 b, 三个 c\nparse \u0026#34;aaabbb\u0026#34; [copy letters some \u0026#34;a\u0026#34; (n: length? letters) n \u0026#34;b\u0026#34;]\n\nparse [a] [\u0026#39;b | \u0026#39;a | \u0026#39;c]\nparse [hello nice world] [3 word!] ;-- 三个单词\nparse [a a a b b b] [copy words some \u0026#39;a (n: length? words) n \u0026#39;b]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如何准确地解析 IPv4 地址：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003e    four:     charset \u0026#34;01234\u0026#34;\n    half:     charset \u0026#34;012345\u0026#34;\n    non-zero: charset \u0026#34;123456789\u0026#34;\n    digit:    union non-zero charset \u0026#34;0\u0026#34;\n\n    byte: [\n          \u0026#34;25\u0026#34; half\n        | \u0026#34;2\u0026#34; four digit\n        | \u0026#34;1\u0026#34; digit digit\n        | non-zero digit\n        | digit\n    ]\n    ipv4: [byte dot byte dot byte dot byte]\n\n    parse \u0026#34;192.168.10.1\u0026#34; ipv4\n    parse \u0026#34;127.0.0.1\u0026#34;    ipv4\n    parse \u0026#34;99.1234\u0026#34;      ipv4\n    parse \u0026#34;10.12.260.1\u0026#34;  ipv4\n\n    data: {\n        ID: 121.34\n        Version: 1.2.3-5.6\n        Your IP address is: 85.94.114.88.\n        NOTE: Your IP Address could be different tomorrow.\n    }\n    parse data [some [copy value ipv4 | skip]]\n    probe value                      ; will ouput: \u0026#34;85.94.114.88\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e一个粗略但实用的电子邮件地址验证器：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003e    digit:   charset \u0026#34;0123456789\u0026#34;               ;-- 数字字符集\n    letters: charset [#\u0026#34;a\u0026#34; - #\u0026#34;z\u0026#34; #\u0026#34;A\u0026#34; - #\u0026#34;Z\u0026#34;]  ;-- 字母字符集\n    special: charset \u0026#34;-\u0026#34;                        ;-- 特殊字符\n    chars:   union union letters special digit  ;-- 合并字符集\n    word:    [some chars]\n    host:    [word]\n    domain:  [word some [dot word]]\n    email:   [host \u0026#34;@\u0026#34; domain]\n\n    parse \u0026#34;john@doe.com\u0026#34; email\n    parse \u0026#34;n00b@lost.island.org\u0026#34; email\n    parse \u0026#34;h4x0r-l33t@domain.net\u0026#34; email\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e以字符串形式验证数学表达式（来自 Rebol/Core \u003ca href=\"http://www.rebol.com/docs/core23/rebolcore-15.html#section-6\"\u003e手册\u003c/a\u003e）：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003e    expr:    [term [\u0026#34;+\u0026#34; | \u0026#34;-\u0026#34;] expr | term]\n    term:    [factor [\u0026#34;*\u0026#34; | \u0026#34;/\u0026#34;] term | factor]\n    factor:  [primary \u0026#34;**\u0026#34; factor | primary]\n    primary: [some digit | \u0026#34;(\u0026#34; expr \u0026#34;)\u0026#34;]\n    digit:   charset \u0026#34;0123456789\u0026#34;\n    \n    parse \u0026#34;1+2*(3-2)/4\u0026#34; expr        ; will return true\n    parse \u0026#34;1-(3/)+2\u0026#34; expr           ; will return false\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e创建一个简单的 HTML 子集解析器：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003e    html: {\n        \u0026lt;html\u0026gt;\n            \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Test\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\n            \u0026lt;body\u0026gt;\u0026lt;div\u0026gt;\u0026lt;u\u0026gt;Hello\u0026lt;/u\u0026gt; \u0026lt;b\u0026gt;World\u0026lt;/b\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/body\u0026gt;\n        \u0026lt;/html\u0026gt;\n    }\n\n    ws: charset reduce [space tab cr lf]\n\n    parse html tags: [\n        collect [any [\n            ws\n            | \u0026#34;\u0026lt;/\u0026#34; thru \u0026#34;\u0026gt;\u0026#34; break\n            | \u0026#34;\u0026lt;\u0026#34; copy name to \u0026#34;\u0026gt;\u0026#34; skip keep (load name) opt tags\n            | keep to \u0026#34;\u0026lt;\u0026#34;\n        ]]\n    ]\n\n    ; will produce the following tree of blocks as output of parse:\n     [\n         html [\n             head [\n                 title [\u0026#34;Test\u0026#34;]\n             ]\n             body [\n                 div [\n                     u [\u0026#34;Hello\u0026#34;]\n                     b [\u0026#34;World\u0026#34;]\n                 ]\n             ]\n         ]\n     ]\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"parse-方言\"\u003eParse 方言\u003c/h2\u003e\n\u003cp\u003eParse 的核心原则是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e通过匹配 grammar 规则推进输入系列，直到顶级规则失败（返回 \u003ccode\u003efalse\u003c/code\u003e）或输入耗尽（返回 \u003ccode\u003etrue\u003c/code\u003e）(*)\u003c/li\u003e\n\u003cli\u003e有序选择（例如在[\u0026ldquo;a\u0026rdquo;|\u0026ldquo;ab\u0026rdquo;]规则中，第二个将永远不会成功）\u003c/li\u003e\n\u003cli\u003e规则可组合性（无限制）\u003c/li\u003e\n\u003cli\u003e有限的回溯：只有输入和规则位置被回溯，其他变化仍然存在\u003c/li\u003e\n\u003cli\u003e两种模式：字符串解析（例如：外部 DSL）或块解析（例如：嵌入式 DSL）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e(*) 如果在任何规则中以最简单的形式使用 \u003ccode\u003ecollect\u003c/code\u003e 关键字，则无论 root 规则是否成功，都将通过 \u003ccode\u003eparse\u003c/code\u003e 返回一个块。\u003c/p\u003e\n\u003cp\u003eParse规则可以来自：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ekeyword\u003c/strong\u003e       : 方言保留字（见下表）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eword\u003c/strong\u003e          : word 会被求值并将其值用作规则\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eword:\u003c/strong\u003e         : 将单词设置为当前输入位置\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e:word\u003c/strong\u003e         : 在单词引用的位置继续输入\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003einteger\u003c/strong\u003e value : 指定具有固定数量或迭代范围的迭代规则\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003evalue\u003c/strong\u003e         : 将输入与值匹配\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e|\u003c/strong\u003e             : 回溯并匹配下一个备用规则\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[rules]\u003c/strong\u003e       : 子规则块\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e(expression)\u003c/strong\u003e  : 转义 Parse方言，计算 Red 表达式并返回 Parse 方言\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eRed 的 Parse 实现中目前提供以下关键字。它们可以自由组合在一起。\u003c/p\u003e\n\u003ch2 id=\"匹配\"\u003e匹配\u003c/h2\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eahead\u003c/strong\u003e rule    : 向前查看规则, 匹配规则, 但不推进输入\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eend\u003c/strong\u003e           : 如果当前输入位置到终点了则返回成功\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003enone\u003c/strong\u003e          : 总是返回成功（catch-all 规则）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003enot\u003c/strong\u003e rule      : 反转子规则的结果\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eopt\u003c/strong\u003e rule      : 向前查看规则, 可选地匹配规则\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003equote\u003c/strong\u003e rule    : 按字面意思匹配下一个值（用于方言转义需求）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eskip\u003c/strong\u003e          : 将输入推进一个元素（一个字符或一个值）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ethru\u003c/strong\u003e rule     : 推进输入直到规则匹配, 输入设置在匹配的后面\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eto\u003c/strong\u003e rule       : 推进输入直到规则匹配, 输入设置在匹配的开头\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"控制流\"\u003e控制流\u003c/h2\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ebreak\u003c/strong\u003e         : 跳出匹配循环, 返回成功\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eif\u003c/strong\u003e(expr)      : 计算 Red 表达式，如果为 false 或 none，则失败并回溯\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003einto\u003c/strong\u003e rule     : 将输入切换到匹配的系列（字符串或块）并用规则解析它\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003efail\u003c/strong\u003e          : 强制当前规则失败并回溯\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ethen\u003c/strong\u003e          : 无论后续的失败或成功, 跳过下一个备用规则\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ereject\u003c/strong\u003e        : 跳出匹配循环, 返回失败\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"迭代\"\u003e迭代\u003c/h2\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eany\u003c/strong\u003e rule      : 重复规则零次或多次直到失败或输入没有推进\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003esome\u003c/strong\u003e rule     : 重复规则一次或多次直到失败或输入没有推进\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ewhile\u003c/strong\u003e rule    : 重复规则零次或多次直到失败， 无论输入是否推进\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"提取\"\u003e提取\u003c/h2\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ecollect\u003c/strong\u003e [rule]           : 从匹配的规则中返回一组收集的值\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ecollect set\u003c/strong\u003e word [rule]  : 从块中收集匹配规则的值，并将其设置为 word\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ecollect into\u003c/strong\u003e word [rule] : 从匹配的规则中收集值并将它们插入到由 word 引用的块中\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ecopy\u003c/strong\u003e word rule           : 将 word 设置为匹配输入的副本\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ekeep\u003c/strong\u003e rule                : 将匹配输入的副本附加到收集块\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ekeep\u003c/strong\u003e(expr)               : 将 Red 表达式中的最后一个值附加到收集块\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eset\u003c/strong\u003e word rule            : 将 word 设置为匹配输入的第一个值\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"修改\"\u003e修改\u003c/h2\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003einsert only\u003c/strong\u003e value        : 在当前输入位置插入[/only]值并在值后面推进输入\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eremove\u003c/strong\u003e rule              : 删除匹配的输入\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e核心原则提到了两种解析模式。这在 Red 中是必要的（就像在 Rebol 中），因为我们有两个基本的系列数据类型 : \u003ccode\u003estring!\u003c/code\u003e 和 \u003ccode\u003eblock!\u003c/code\u003e。\u003ccode\u003estring!\u003c/code\u003e datatype 当前是一个 Unicode 代码点数组（ Red 将在未来版本中支持字符数组），而 \u003ccode\u003eblock!\u003c/code\u003e datatype 是一个任意 Red 值的数组（包括其他块）。\u003c/p\u003e\n\u003cp\u003e在实践中，这导致 Parse 方言使用中的一些细微差别。例如，可以使用新的 \u003ccode\u003ebitset!\u003c/code\u003e  数据类型定义任意字符集！这仅对 \u003ccode\u003estring!\u003c/code\u003e 解析有用以便一次匹配大量字符。以下是仅使用 bitsets 匹配和迭代器的示例 :\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003eletter: charset [#\u0026#34;a\u0026#34; - #\u0026#34;z\u0026#34;]\ndigit:  charset \u0026#34;0123456789\u0026#34;\n\nparse \u0026#34;hello 123 world\u0026#34; [5 letter space 3 digit space some letter]\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"bitset-数据类型\"\u003eBitset! 数据类型\u003c/h2\u003e\n\u003cp\u003ebitset 值是用于存储布尔值的 bit 位数组。在 Parse 的上下文中，bitsets 对于在整个 Unicode 范围内表示任意字符集非常有用，可以在单个操作中与输入字符进行匹配。因为 \u003ccode\u003ebitset!\u003c/code\u003e 在此 0.4.1 版本中引入，值得概述下所支持的功能。基本上，它与 Rebol3 的 \u003ccode\u003ebitset!\u003c/code\u003e \u003ca href=\"http://www.rebol.com/r3/docs/datatypes/bitset.html\"\u003e实现\u003c/a\u003e相同。\u003c/p\u003e\n\u003cp\u003e要创建 bitset，您需要提供一个或多个字符作为基本规范。它们可以以不同的形式提供：codepoint 整数值，\u003ccode\u003echar!\u003c/code\u003e 值，\u003ccode\u003estring!\u003c/code\u003e 值，一个范围或一组之前的元素。使用以下语法创建新的 bitset：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003emake bitset! \u0026lt;spec\u0026gt;\n\n\u0026lt;spec\u0026gt;: char!, integer!, string! or block!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e例如:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003e    ; create an empty bitset with places at least for 50 bits\n    make bitset! 50\n\n    ; create a bitset with bit 65 set\n    make bitset! #\u0026#34;A\u0026#34;\n\n    ; create a bitset with bits 104 and 105 set\n    make bitset! \u0026#34;hi\u0026#34;\n\n    ; create and set bits using different values representations\n    make bitset! [120 \u0026#34;hello\u0026#34; #\u0026#34;A\u0026#34;]\n\n    ; create a bitset using ranges of values\n    make bitset! [#\u0026#34;0\u0026#34; - #\u0026#34;9\u0026#34; #\u0026#34;a\u0026#34; - #\u0026#34;z\u0026#34;]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e范围使用两个值（允许 \u003ccode\u003echar!\u003c/code\u003e 或 \u003ccode\u003einteger!\u003c/code\u003e）定义，用破折号字分隔。\u003c/p\u003e\n\u003cp\u003eBitsets 自动调整大小以适应所提供的规格值。大小舍入到高位字节边界。\u003c/p\u003e\n\u003cp\u003e还提供了快捷 \u003ccode\u003echarset\u003c/code\u003e 功能以供实际使用，因此您可以编写：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003e    charset \u0026#34;ABCDEF\u0026#34;\n    charset [120 \u0026#34;hello\u0026#34; #\u0026#34;A\u0026#34;]\n    charset [#\u0026#34;0\u0026#34; - #\u0026#34;9\u0026#34; #\u0026#34;a\u0026#34; - #\u0026#34;z\u0026#34;]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e对于读写单个 bits 位，路径表示法是最简单的方法：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003e    bs: charset [#\u0026#34;a\u0026#34; - #\u0026#34;z\u0026#34;]\n    bs/97     ; will return true\n    bs/40     ; will return false\n    bs/97: false\n    bs/97     ; will return false\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e（注意：bitset 索引从零开始。）\u003c/p\u003e\n\u003cp\u003e此外，\u003ccode\u003ebitset!\u003c/code\u003e 数据类型支持以下操作：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epick\u003c/code\u003e, \u003ccode\u003epoke\u003c/code\u003e, \u003ccode\u003efind\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, \u003ccode\u003eappend\u003c/code\u003e, \u003ccode\u003ecopy\u003c/code\u003e, \u003ccode\u003eremove\u003c/code\u003e, \u003ccode\u003eclear\u003c/code\u003e, \u003ccode\u003elength?\u003c/code\u003e, \u003ccode\u003emold\u003c/code\u003e, \u003ccode\u003eform\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e有关这些操作的使用的详细信息，请参阅 Rebol3 bitset \u003ca href=\"http://www.rebol.com/r3/docs/datatypes/bitset.html\"\u003e文档\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e为了处理各种 Unicode 字符，bitsets 之外的位被视为\u003cstrong\u003e虚拟位\u003c/strong\u003e，因此可以无错误地测试和设置它们，bitset 的大小将根据需要自动扩展。但这仍然不足以处理大的范围，例如除了数字之外的所有 Unicode 字符的 bitset。对于这种情况，可以定义补充的 bitset，该 bitset 表示指定位的补码范围。这使得在仅使用微小的存储器部分存储大的 bitset 成为可能。\u003c/p\u003e\n\u003cp\u003e补充的 bitsets 的创建方式与普通 bitsets 相同，但它们需要以 \u003ccode\u003enot\u003c/code\u003e 单词开头并始终对于他们的规格使用 \u003ccode\u003eblock!\u003c/code\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003e    ; all characters except digits\n    charset [not \u0026#34;0123456789\u0026#34;]\n\n    ; all characters but hexadecimal symbols\n    charset [not \u0026#34;ABCDEF\u0026#34; #\u0026#34;0\u0026#34; - #\u0026#34;9\u0026#34;]\n\n    ; all characters except whitespaces\n    charset reduce [\u0026#39;not space tab cr lf]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e设置操作也是可能的，但目前只有 \u003ccode\u003eunion\u003c/code\u003e 用 Red 实现了（它对于 bitsets 来说是最常用的）。使用 \u003ccode\u003eunion\u003c/code\u003e，您可以将两个 bitsets 合在一起以形成一个新的 bitsets，这在实践中非常有用：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003e    digit: charset \u0026#34;0123456789\u0026#34;\n    lower: charset [#\u0026#34;a\u0026#34; - #\u0026#34;z\u0026#34;]\n    upper: charset [#\u0026#34;A\u0026#34; - #\u0026#34;Z\u0026#34;]\n\n    letters:  union lower upper\n    hexa:     union upper digit\n    alphanum: union letters digit\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"parse-实现\"\u003eParse 实现\u003c/h2\u003e\n\u003cp\u003eParse 方言已经实现为 \u003ca href=\"http://en.wikipedia.org/wiki/Finite-state_machine\"\u003eFSM\u003c/a\u003e，它不同于依赖于递归函数调用的 Rebol3 实现。 FSM 方法可以实现几个有趣的功能，例如能够停止解析并在以后恢复它，甚至序列化解析状态，远程发送它并重新加载它以继续解析。现在可以用最少的努力来实现这些功能。\u003c/p\u003e\n\u003cp\u003eRed Parse \u003ca href=\"https://github.com/red/red/blob/master/runtime/parse.reds\"\u003e实现\u003c/a\u003e大约有1300行 Red/System 代码，其中很大一部分花在了针对常见情况的优化迭代循环上。大约有\u003ca href=\"https://github.com/red/red/blob/master/tests/source/units/parse-test.red\"\u003e770个单元测试\u003c/a\u003e是手写的，以涵盖基本的 Parse 功能。\u003c/p\u003e\n\u003cp\u003e当前的 Parse 作为解释器运行，对于大多数用例来说都足够快。对于需要最高性能的情况，已经开始在 Parse 静态编译器上开始工作，以便尽快为 Parse 密集型 Red 应用程序提供最快的速度。生成的代码是纯 Red/System 代码，平均比解释版本快一般。当 Red 将自托管时，将提供 Parse JIT 编译器来处理静态编译器无法处理的情况。\u003c/p\u003e\n\u003cp\u003e随着 Red 获得更多功能，Parse 将继续得到改进以利用它们。其他未来的改进，\u003ccode\u003ebinary!\u003c/code\u003e 解析将尽快添加一旦 \u003ccode\u003ebinary!\u003c/code\u003e 数据类型可用，当 \u003ccode\u003eport!\u003c/code\u003e 数据类型出现时流解析也将成为可能。\u003c/p\u003e\n\u003cp\u003eRed Parse 还以可选的回调函数的形式公开面向公共事件的 API，可以使用\u003ccode\u003e/trace\u003c/code\u003e 细化传递给 \u003ccode\u003eparse\u003c/code\u003e。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003e    parse/trace \u0026lt;input\u0026gt; \u0026lt;rules\u0026gt; \u0026lt;callback\u0026gt;\n\n    \u0026lt;callback\u0026gt; specification:\n\n    func [\n        event   [word!]   ; Trace events\n        match?  [logic!]  ; Result of last matching operation\n        rule    [block!]  ; Current rule at current position\n        input   [series!] ; Input series at next position to match\n        stack   [block!]  ; Internal parse rules stack\n        return: [logic!]  ; TRUE: continue parsing, FALSE: exit\n    ]\n\n    Events list:\n    - push    : once a rule or block has been pushed on stack\n    - pop     : before a rule or block is popped from stack\n    - fetch   : before a new rule is fetched\n    - match   : after a value matching occurs\n    - iterate : after a new iteration pass begins (ANY, SOME, ...)\n    - paren   : after a paren expression was evaluated\n    - end     : after end of input has been reached\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e此 API 将在未来进行扩展，以获得更细粒度的事件。这个 API 可用于为 Parse 提供跟踪，统计，调试\u0026hellip;\u0026hellip;让我们看看 Red 用户会想出什么！ ;-)\u003c/p\u003e\n\u003cp\u003e已实现\u003ca href=\"https://github.com/red/red/blob/master/boot.red#L1013\"\u003e默认回调\u003c/a\u003e以进行跟踪。可以使用方便的解析跟踪函数包装器访问它：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003eparse-trace \u0026lt;input\u0026gt; \u0026lt;rules\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e您可以使用简单的解析规则来尝试查看结果输出。\u003c/p\u003e\n\u003ch2 id=\"dsl-支持怎么样\"\u003eDSL 支持怎么样？\u003c/h2\u003e\n\u003cp\u003eParse 是实现 DSL 解析器（嵌入式和外部式）的强大工具，这要归功于它能够将 Red 表达式直接内联到规则中，从而可以轻松地将 DSL 语法与其相应的语义链接起来。为了说明这一点，这里是一个使用 Parse 编写的著名混淆\u003ca href=\"http://en.wikipedia.org/wiki/Brainfuck\"\u003e语言\u003c/a\u003e的简单解释器：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-red\" data-lang=\"red\"\u003ebf: function [prog [string!]][\n        size: 30000\n        cells: make string! size\n        append/dup cells null size\n\n        parse prog [\n            some [\n                  \u0026#34;\u0026gt;\u0026#34; (cells: next cells)\n                | \u0026#34;\u0026lt;\u0026#34; (cells: back cells)\n                | \u0026#34;+\u0026#34; (cells/1: cells/1 + 1)\n                | \u0026#34;-\u0026#34; (cells/1: cells/1 - 1)\n                | \u0026#34;.\u0026#34; (prin cells/1)\n                | \u0026#34;,\u0026#34; (cells/1: first input \u0026#34;\u0026#34;)\n                | \u0026#34;[\u0026#34; [if (cells/1 = null) thru \u0026#34;]\u0026#34; | none]\n                | \u0026#34;]\u0026#34; [\n                   pos: if (cells/1 \u0026lt;\u0026gt; null)\n                   (pos: find/reverse pos #\u0026#34;[\u0026#34;) :pos\n                   | none\n                  ]\n                | skip\n            ]\n        ]\n    ]\n\n    ; This code will print a Hello World! message\n    bf {\n        ++++++++++[\u0026gt;+++++++\u0026gt;++++++++++\u0026gt;+++\u0026gt;+\u0026lt;\u0026lt;\u0026lt;\u0026lt;-]\u0026gt;++.\u0026gt;+.+++++++..+++.\n        \u0026gt;++.\u0026lt;\u0026lt;+++++++++++++++.\u0026gt;.+++.------.--------.\u0026gt;+.\u0026gt;.\n    }\n\n    ; This one will print a famous quote\n    bf {\n        ++++++++[\u0026gt;+\u0026gt;++\u0026gt;+++\u0026gt;++++\u0026gt;+++++\u0026gt;++++++\u0026gt;+++++++\u0026gt;++++++++\u0026gt;\n        +++++++++\u0026gt;++++++++++\u0026gt;+++++++++++\u0026gt;++++++++++++\u0026gt;++++++++\n        +++++\u0026gt;++++++++++++++\u0026gt;+++++++++++++++\u0026gt;++++++++++++++++\u0026lt;\n        \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;-]\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;----.++++\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\n        \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;.\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;---.+++\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\n        \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;++.--\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;---.+++\u0026lt;\u0026lt;\u0026lt;\u0026lt;\n        \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;.\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;+.-\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\n        \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;+++.---\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;.\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;--.++\n        \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;-.+\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;.\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\n        \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;+++.---\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;.\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\n        \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;-.+\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;-.\n        +\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;--.++\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;+.-\n        \u0026lt;\u0026lt;\u0026lt;\u0026lt;.\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e注意：此实现仅限于一级“[\u0026hellip;]”嵌套，以使其尽可能短。\u003ca href=\"https://gist.github.com/dockimbel/7713170\"\u003e此处\u003c/a\u003e是仅使用 Parse 的完整但更长且更复杂的实现。\u003c/p\u003e\n\u003cp\u003e因此，这种方法对小型 DSL 非常有用。对于更复杂的 Parse，Parse 仍然可以正常工作，但随着 DSL 语义变得更加复杂，它可能没那么有用。对于大多数用户而言，为更高级的 DSL 实现解释器或编译器并非易事。 Red 将通过在Parse 之上提供元 DSL 包装器来解决这个问题，通过抽象出解释器或编译器的核心部分来暴露更高级别的 API 以构建更复杂的 DSL。用于构建其他 DSL 的 DSL 并不是一个疯狂的想法，它已经以一种非常强大的形式存在，例如\u003ca href=\"http://www.rascal-mpl.org/\"\u003eRascal\u003c/a\u003e 语言。 Red 将提供的只是朝这个方向迈出的一步，但没有像 Rascal 那样精密（和复杂）。\u003c/p\u003e\n\u003ch2 id=\"此版本中的其他更改\"\u003e此版本中的其他更改\u003c/h2\u003e\n\u003cp\u003e只是提到这个版本中的其他变化，现在我们摆脱了房间里的800磅大猩猩。此版本为 Red 和 Red/System 带来了大量的\u003ca href=\"https://github.com/red/red/issues?milestone=12\u0026amp;page=1\u0026amp;state=closed\"\u003e错误修复\u003c/a\u003e。此外，多亏了 qtxie，ELF 文件发射器在生成共享库时现在与其他文件发射器相当。\u003c/p\u003e\n\u003cp\u003e感谢所有参与帮助实现这一重大发布的人员，包括设计修复和改进，测试，错误报告和测试编写。\u003c/p\u003e\n\u003cp\u003e请享用！ :-)\u003c/p\u003e\n\u003ch2 id=\"链接\"\u003e链接\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.red-lang.org/2013/11/041-introducing-parse.html\"\u003eintroducing parse\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://doc.red-lang.org/zh-hans/\"\u003eRed 编程语言文档\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.red-by-example.org/parse.html\"\u003eRed by Example\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.michaelsydenham.com/reds-parse-dialect/\"\u003eRed’s Parse dialect\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.michaelsydenham.com/red-parse-simple-rules/\"\u003eRed Parse\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n","text":"Parse 入门 Rebol 语言最大的特色之一就是它的解析引擎，简称为 Parse。这是卡尔·萨森拉斯（Carl Sassenrath）的一个惊人设计，在过去的15年里，所有 Rebol 用户都免于使用臭名昭著的无法维护的 regexp 的痛苦。现在，Parse 也可用于 Red 用户，而且是增强版！\n那么，简而言之，什么是 Parse？它是一个嵌入式 DSL（我们称之为 Rebol 世界中的“方言”），用于使用语法规则解析输入序列。 Parse 方言是 TDPL 家族的增强成员。 Parse 的常见用法是检查，验证，提取，修改输入数据，甚至实现嵌入式和外部 DSL。\nparse 函数调用语法很简单：\nparse \u0026lt;input\u0026gt; \u0026lt;rules\u0026gt; \u0026lt;input\u0026gt;: 任意系列值 (字符串, 文件, 块儿, 路径, ...) \u0026lt;rules\u0026gt;: 块儿! 具有有效 Parse 方言内容的值 这里有几个例子，即使你不懂 Red 和解析方言，你仍然可以“获得”它们中的大多数，不像正则表达式。您可以将它们直接复制/粘贴到 Red 控制台中。\n使用语法规则进行字符串或块输入验证的一些简单示例：\nparse \u0026#34;a plane\u0026#34; [[\u0026#34;a\u0026#34; | \u0026#34;the\u0026#34;] space \u0026#34;plane\u0026#34;] ;-- rule 中的空格需要用 space 显式声明 parse \u0026#34;the car\u0026#34; [[\u0026#34;a\u0026#34; | \u0026#34;the\u0026#34;] space [\u0026#34;plane\u0026#34; | \u0026#34;car\u0026#34;]] parse \u0026#34;123\u0026#34; [\u0026#34;1\u0026#34; \u0026#34;2\u0026#34; [\u0026#34;4\u0026#34; | \u0026#34;3\u0026#34;]] ;-- rule 中的空格默认被忽略 parse \u0026#34;abbccc\u0026#34; [\u0026#34;a\u0026#34; 2 \u0026#34;b\u0026#34; 3 \u0026#34;c\u0026#34;] ;-- 一个 a, 俩个 b, 三个 c parse \u0026#34;aaabbb\u0026#34; [copy letters some \u0026#34;a\u0026#34; (n: length? letters) n \u0026#34;b\u0026#34;] parse [a] [\u0026#39;b | \u0026#39;a | \u0026#39;c] parse [hello nice world] [3 word!] ;-- 三个单词 parse [a a a b b b] [copy words some \u0026#39;a (n: length? words) n \u0026#39;b] 如何准确地解析 IPv4 地址：\nfour: charset \u0026#34;01234\u0026#34; half: charset \u0026#34;012345\u0026#34; non-zero: charset \u0026#34;123456789\u0026#34; digit: union non-zero charset \u0026#34;0\u0026#34; byte: [ \u0026#34;25\u0026#34; half | \u0026#34;2\u0026#34; four digit | \u0026#34;1\u0026#34; digit digit | non-zero digit | digit ] ipv4: [byte dot byte dot byte dot byte] parse \u0026#34;192.168.10.1\u0026#34; ipv4 parse \u0026#34;127.0.0.1\u0026#34; ipv4 parse \u0026#34;99.1234\u0026#34; ipv4 parse \u0026#34;10.12.260.1\u0026#34; ipv4 data: { ID: 121.34 Version: 1.2.3-5.6 Your IP address is: 85.94.114.88. NOTE: Your IP Address could be different tomorrow. } parse data [some [copy value ipv4 | skip]] probe value ; will ouput: \u0026#34;85.94.114.88\u0026#34; 一个粗略但实用的电子邮件地址验证器：\ndigit: charset \u0026#34;0123456789\u0026#34; ;-- 数字字符集 letters: charset [#\u0026#34;a\u0026#34; - #\u0026#34;z\u0026#34; #\u0026#34;A\u0026#34; - #\u0026#34;Z\u0026#34;] ;-- 字母字符集 special: charset \u0026#34;-\u0026#34; ;-- 特殊字符 chars: union union letters special digit ;-- 合并字符集 word: [some chars] host: [word] domain: [word some [dot word]] email: [host \u0026#34;@\u0026#34; domain] parse \u0026#34;john@doe.com\u0026#34; email parse \u0026#34;n00b@lost.island.org\u0026#34; email parse \u0026#34;h4x0r-l33t@domain.net\u0026#34; email 以字符串形式验证数学表达式（来自 Rebol/Core 手册）：\nexpr: [term [\u0026#34;+\u0026#34; | \u0026#34;-\u0026#34;] expr | term] term: [factor [\u0026#34;*\u0026#34; | \u0026#34;/\u0026#34;] term | factor] factor: [primary \u0026#34;**\u0026#34; factor | primary] primary: [some digit | \u0026#34;(\u0026#34; expr \u0026#34;)\u0026#34;] digit: charset \u0026#34;0123456789\u0026#34; parse \u0026#34;1+2*(3-2)/4\u0026#34; expr ; will return true parse \u0026#34;1-(3/)+2\u0026#34; expr ; will return false 创建一个简单的 HTML 子集解析器：\nhtml: { \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Test\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;div\u0026gt;\u0026lt;u\u0026gt;Hello\u0026lt;/u\u0026gt; \u0026lt;b\u0026gt;World\u0026lt;/b\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; } ws: charset reduce [space tab cr lf] parse html tags: [ collect [any [ ws | \u0026#34;\u0026lt;/\u0026#34; thru \u0026#34;\u0026gt;\u0026#34; break | \u0026#34;\u0026lt;\u0026#34; copy name to \u0026#34;\u0026gt;\u0026#34; skip keep (load name) opt tags | keep to \u0026#34;\u0026lt;\u0026#34; ]] ] ; will produce the following tree of blocks as output of parse: [ html [ head [ title [\u0026#34;Test\u0026#34;] ] body [ div [ u [\u0026#34;Hello\u0026#34;] b [\u0026#34;World\u0026#34;] ] ] ] ] Parse 方言 Parse 的核心原则是：\n通过匹配 grammar 规则推进输入系列，直到顶级规则失败（返回 false）或输入耗尽（返回 true）(*) 有序选择（例如在[\u0026ldquo;a\u0026rdquo;|\u0026ldquo;ab\u0026rdquo;]规则中，第二个将永远不会成功） 规则可组合性（无限制） 有限的回溯：只有输入和规则位置被回溯，其他变化仍然存在 两种模式：字符串解析（例如：外部 DSL）或块解析（例如：嵌入式 DSL） (*) 如果在任何规则中以最简单的形式使用 collect 关键字，则无论 root 规则是否成功，都将通过 parse 返回一个块。\nParse规则可以来自：\nkeyword : 方言保留字（见下表） word : word 会被求值并将其值用作规则 word: : 将单词设置为当前输入位置 :word : 在单词引用的位置继续输入 integer value : 指定具有固定数量或迭代范围的迭代规则 value : 将输入与值匹配 | : 回溯并匹配下一个备用规则 [rules] : 子规则块 (expression) : 转义 Parse方言，计算 Red 表达式并返回 Parse 方言 Red 的 Parse 实现中目前提供以下关键字。它们可以自由组合在一起。\n匹配 ahead rule : 向前查看规则, 匹配规则, 但不推进输入 end : 如果当前输入位置到终点了则返回成功 none : 总是返回成功（catch-all 规则） not rule : 反转子规则的结果 opt rule : 向前查看规则, 可选地匹配规则 quote rule : 按字面意思匹配下一个值（用于方言转义需求） skip : 将输入推进一个元素（一个字符或一个值） thru rule : 推进输入直到规则匹配, 输入设置在匹配的后面 to rule : 推进输入直到规则匹配, 输入设置在匹配的开头 控制流 break : 跳出匹配循环, 返回成功 if(expr) : 计算 Red 表达式，如果为 false 或 none，则失败并回溯 into rule : 将输入切换到匹配的系列（字符串或块）并用规则解析它 fail : 强制当前规则失败并回溯 then : 无论后续的失败或成功, 跳过下一个备用规则 reject : 跳出匹配循环, 返回失败 迭代 any rule : 重复规则零次或多次直到失败或输入没有推进 some rule : 重复规则一次或多次直到失败或输入没有推进 while rule : 重复规则零次或多次直到失败， 无论输入是否推进 提取 collect [rule] : 从匹配的规则中返回一组收集的值 collect set word [rule] : 从块中收集匹配规则的值，并将其设置为 word collect into word [rule] : 从匹配的规则中收集值并将它们插入到由 word 引用的块中 copy word rule : 将 word 设置为匹配输入的副本 keep rule : 将匹配输入的副本附加到收集块 keep(expr) : 将 Red 表达式中的最后一个值附加到收集块 set word rule : 将 word 设置为匹配输入的第一个值 修改 insert only value : 在当前输入位置插入[/only]值并在值后面推进输入 remove rule : 删除匹配的输入 核心原则提到了两种解析模式。这在 Red 中是必要的（就像在 Rebol 中），因为我们有两个基本的系列数据类型 : string! 和 block!。string! datatype 当前是一个 Unicode 代码点数组（ Red 将在未来版本中支持字符数组），而 block! datatype 是一个任意 Red 值的数组（包括其他块）。\n在实践中，这导致 Parse 方言使用中的一些细微差别。例如，可以使用新的 bitset! 数据类型定义任意字符集！这仅对 string! 解析有用以便一次匹配大量字符。以下是仅使用 bitsets 匹配和迭代器的示例 :\nletter: charset [#\u0026#34;a\u0026#34; - #\u0026#34;z\u0026#34;] digit: charset \u0026#34;0123456789\u0026#34; parse \u0026#34;hello 123 world\u0026#34; [5 letter space 3 digit space some letter] Bitset! 数据类型 bitset 值是用于存储布尔值的 bit 位数组。在 Parse 的上下文中，bitsets 对于在整个 Unicode 范围内表示任意字符集非常有用，可以在单个操作中与输入字符进行匹配。因为 bitset! 在此 0.4.1 版本中引入，值得概述下所支持的功能。基本上，它与 Rebol3 的 bitset! 实现相同。\n要创建 bitset，您需要提供一个或多个字符作为基本规范。它们可以以不同的形式提供：codepoint 整数值，char! 值，string! 值，一个范围或一组之前的元素。使用以下语法创建新的 bitset：\nmake bitset! \u0026lt;spec\u0026gt; \u0026lt;spec\u0026gt;: char!, integer!, string! or block! 例如:\n; create an empty bitset with places at least for 50 bits make bitset! 50 ; create a bitset with bit 65 set make bitset! #\u0026#34;A\u0026#34; ; create a bitset with bits 104 and 105 set make bitset! \u0026#34;hi\u0026#34; ; create and set bits using different values representations make bitset! [120 \u0026#34;hello\u0026#34; #\u0026#34;A\u0026#34;] ; create a bitset using ranges of values make bitset! [#\u0026#34;0\u0026#34; - #\u0026#34;9\u0026#34; #\u0026#34;a\u0026#34; - #\u0026#34;z\u0026#34;] 范围使用两个值（允许 char! 或 integer!）定义，用破折号字分隔。\nBitsets 自动调整大小以适应所提供的规格值。大小舍入到高位字节边界。\n还提供了快捷 charset 功能以供实际使用，因此您可以编写：\ncharset \u0026#34;ABCDEF\u0026#34; charset [120 \u0026#34;hello\u0026#34; #\u0026#34;A\u0026#34;] charset [#\u0026#34;0\u0026#34; - #\u0026#34;9\u0026#34; #\u0026#34;a\u0026#34; - #\u0026#34;z\u0026#34;] 对于读写单个 bits 位，路径表示法是最简单的方法：\nbs: charset [#\u0026#34;a\u0026#34; - #\u0026#34;z\u0026#34;] bs/97 ; will return true bs/40 ; will return false bs/97: false bs/97 ; will return false （注意：bitset 索引从零开始。）\n此外，bitset! 数据类型支持以下操作：\npick, poke, find, insert, append, copy, remove, clear, length?, mold, form\n有关这些操作的使用的详细信息，请参阅 Rebol3 bitset 文档。\n为了处理各种 Unicode 字符，bitsets 之外的位被视为虚拟位，因此可以无错误地测试和设置它们，bitset 的大小将根据需要自动扩展。但这仍然不足以处理大的范围，例如除了数字之外的所有 Unicode 字符的 bitset。对于这种情况，可以定义补充的 bitset，该 bitset 表示指定位的补码范围。这使得在仅使用微小的存储器部分存储大的 bitset 成为可能。\n补充的 bitsets 的创建方式与普通 bitsets 相同，但它们需要以 not 单词开头并始终对于他们的规格使用 block!\n; all characters except digits charset [not \u0026#34;0123456789\u0026#34;] ; all characters but hexadecimal symbols charset [not \u0026#34;ABCDEF\u0026#34; #\u0026#34;0\u0026#34; - #\u0026#34;9\u0026#34;] ; all characters except whitespaces charset reduce [\u0026#39;not space tab cr lf] 设置操作也是可能的，但目前只有 union 用 Red 实现了（它对于 bitsets 来说是最常用的）。使用 union，您可以将两个 bitsets 合在一起以形成一个新的 bitsets，这在实践中非常有用：\ndigit: charset \u0026#34;0123456789\u0026#34; lower: charset [#\u0026#34;a\u0026#34; - #\u0026#34;z\u0026#34;] upper: charset [#\u0026#34;A\u0026#34; - #\u0026#34;Z\u0026#34;] letters: union lower upper hexa: union upper digit alphanum: union letters digit Parse 实现 Parse 方言已经实现为 FSM，它不同于依赖于递归函数调用的 Rebol3 实现。 FSM 方法可以实现几个有趣的功能，例如能够停止解析并在以后恢复它，甚至序列化解析状态，远程发送它并重新加载它以继续解析。现在可以用最少的努力来实现这些功能。\nRed Parse 实现大约有1300行 Red/System 代码，其中很大一部分花在了针对常见情况的优化迭代循环上。大约有770个单元测试是手写的，以涵盖基本的 Parse 功能。\n当前的 Parse 作为解释器运行，对于大多数用例来说都足够快。对于需要最高性能的情况，已经开始在 Parse 静态编译器上开始工作，以便尽快为 Parse 密集型 Red 应用程序提供最快的速度。生成的代码是纯 Red/System 代码，平均比解释版本快一般。当 Red 将自托管时，将提供 Parse JIT 编译器来处理静态编译器无法处理的情况。\n随着 Red 获得更多功能，Parse 将继续得到改进以利用它们。其他未来的改进，binary! 解析将尽快添加一旦 binary! 数据类型可用，当 port! 数据类型出现时流解析也将成为可能。\nRed Parse 还以可选的回调函数的形式公开面向公共事件的 API，可以使用/trace 细化传递给 parse。\nparse/trace \u0026lt;input\u0026gt; \u0026lt;rules\u0026gt; \u0026lt;callback\u0026gt; \u0026lt;callback\u0026gt; specification: func [ event [word!] ; Trace events match? [logic!] ; Result of last matching operation rule [block!] ; Current rule at current position input [series!] ; Input series at next position to match stack [block!] ; Internal parse rules stack return: [logic!] ; TRUE: continue parsing, FALSE: exit ] Events list: - push : once a rule or block has been pushed on stack - pop : before a rule or block is popped from stack - fetch : before a new rule is fetched - match : after a value matching occurs - iterate : after a new iteration pass begins (ANY, SOME, ...) - paren : after a paren expression was evaluated - end : after end of input has been reached 此 API 将在未来进行扩展，以获得更细粒度的事件。这个 API 可用于为 Parse 提供跟踪，统计，调试\u0026hellip;\u0026hellip;让我们看看 Red 用户会想出什么！ ;-)\n已实现默认回调以进行跟踪。可以使用方便的解析跟踪函数包装器访问它：\nparse-trace \u0026lt;input\u0026gt; \u0026lt;rules\u0026gt; 您可以使用简单的解析规则来尝试查看结果输出。\nDSL 支持怎么样？ Parse 是实现 DSL 解析器（嵌入式和外部式）的强大工具，这要归功于它能够将 Red 表达式直接内联到规则中，从而可以轻松地将 DSL 语法与其相应的语义链接起来。为了说明这一点，这里是一个使用 Parse 编写的著名混淆语言的简单解释器：\nbf: function [prog [string!]][ size: 30000 cells: make string! size append/dup cells null size parse prog [ some [ \u0026#34;\u0026gt;\u0026#34; (cells: next cells) | \u0026#34;\u0026lt;\u0026#34; (cells: back cells) | \u0026#34;+\u0026#34; (cells/1: cells/1 + 1) | \u0026#34;-\u0026#34; (cells/1: cells/1 - 1) | \u0026#34;.\u0026#34; (prin cells/1) | \u0026#34;,\u0026#34; (cells/1: first input \u0026#34;\u0026#34;) | \u0026#34;[\u0026#34; [if (cells/1 = null) thru \u0026#34;]\u0026#34; | none] | \u0026#34;]\u0026#34; [ pos: if (cells/1 \u0026lt;\u0026gt; null) (pos: find/reverse pos #\u0026#34;[\u0026#34;) :pos | none ] | skip ] ] ] ; This code will print a Hello World! message bf { ++++++++++[\u0026gt;+++++++\u0026gt;++++++++++\u0026gt;+++\u0026gt;+\u0026lt;\u0026lt;\u0026lt;\u0026lt;-]\u0026gt;++.\u0026gt;+.+++++++..+++. \u0026gt;++.\u0026lt;\u0026lt;+++++++++++++++.\u0026gt;.+++.------.--------.\u0026gt;+.\u0026gt;. } ; This one will print a famous quote bf { ++++++++[\u0026gt;+\u0026gt;++\u0026gt;+++\u0026gt;++++\u0026gt;+++++\u0026gt;++++++\u0026gt;+++++++\u0026gt;++++++++\u0026gt; +++++++++\u0026gt;++++++++++\u0026gt;+++++++++++\u0026gt;++++++++++++\u0026gt;++++++++ +++++\u0026gt;++++++++++++++\u0026gt;+++++++++++++++\u0026gt;++++++++++++++++\u0026lt; \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;-]\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;----.++++\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;.\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;---.+++\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;++.--\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;---.+++\u0026lt;\u0026lt;\u0026lt;\u0026lt; \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;.\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;+.-\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;+++.---\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;.\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;--.++ \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;-.+\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;.\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt; \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;+++.---\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;.\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;-.+\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;-. +\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;--.++\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;+.- \u0026lt;\u0026lt;\u0026lt;\u0026lt;. } 注意：此实现仅限于一级“[\u0026hellip;]”嵌套，以使其尽可能短。此处是仅使用 Parse 的完整但更长且更复杂的实现。\n因此，这种方法对小型 DSL 非常有用。对于更复杂的 Parse，Parse 仍然可以正常工作，但随着 DSL 语义变得更加复杂，它可能没那么有用。对于大多数用户而言，为更高级的 DSL 实现解释器或编译器并非易事。 Red 将通过在Parse 之上提供元 DSL 包装器来解决这个问题，通过抽象出解释器或编译器的核心部分来暴露更高级别的 API 以构建更复杂的 DSL。用于构建其他 DSL 的 DSL 并不是一个疯狂的想法，它已经以一种非常强大的形式存在，例如Rascal 语言。 Red 将提供的只是朝这个方向迈出的一步，但没有像 Rascal 那样精密（和复杂）。\n此版本中的其他更改 只是提到这个版本中的其他变化，现在我们摆脱了房间里的800磅大猩猩。此版本为 Red 和 Red/System 带来了大量的错误修复。此外，多亏了 qtxie，ELF 文件发射器在生成共享库时现在与其他文件发射器相当。\n感谢所有参与帮助实现这一重大发布的人员，包括设计修复和改进，测试，错误报告和测试编写。\n请享用！ :-)\n链接 introducing parse Red 编程语言文档 Red by Example Red’s Parse dialect Red Parse "},"name":"Red 中的 Parse","published":"2018-12-14T21:51:07Z","summary":"Parse 入门 Rebol 语言最大的特色之一就是它的解析引擎，简称为 Parse。这是卡尔·萨森拉斯（Carl Sassenrath）的一个惊人设计，在过去的15年里，所有 Rebol 用户都免于使用臭名昭著的无法维护的 regexp 的痛苦。现在，Parse 也可用于 Red 用户，而且是增强版！\n那么，简而言之，什么是 Parse？它是一个嵌入式 DSL（我们称之为 Rebol 世界中的“方言”），用于使用语法规则解析输入序列。 Parse 方言是 TDPL 家族的增强成员。 Parse 的常见用法是检查，验证，提取，修改输入数据，甚至实现嵌入式和外部 DSL。\nparse 函数调用语法很简单：\nparse \u0026lt;input\u0026gt; \u0026lt;rules\u0026gt; \u0026lt;input\u0026gt;: 任意系列值 (字符串, 文件, 块儿, 路径, ...) \u0026lt;rules\u0026gt;: 块儿! 具有有效 Parse 方言内容的值 这里有几个例子，即使你不懂 Red 和解析方言，你仍然可以“获得”它们中的大多数，不像正则表达式。您可以将它们直接复制/粘贴到 Red 控制台中。\n使用语法规则进行字符串或块输入验证的一些简单示例：\nparse \u0026#34;a plane\u0026#34; [[\u0026#34;a\u0026#34; | \u0026#34;the\u0026#34;] space \u0026#34;plane\u0026#34;] ;-- rule 中的空格需要用 space 显式声明 parse \u0026#34;the car\u0026#34; [[\u0026#34;a\u0026#34; | \u0026#34;the\u0026#34;] space [\u0026#34;plane\u0026#34; | \u0026#34;car\u0026#34;]] parse \u0026#34;123\u0026#34; [\u0026#34;1\u0026#34; \u0026#34;2\u0026#34; [\u0026#34;4\u0026#34; | \u0026#34;3\u0026#34;]] ;-- rule 中的空格默认被忽略 parse \u0026#34;abbccc\u0026#34; [\u0026#34;a\u0026#34; 2 \u0026#34;b\u0026#34; 3 \u0026#34;c\u0026#34;] ;-- 一个 a, 俩个 b, 三个 c parse \u0026#34;aaabbb\u0026#34; [copy letters some \u0026#34;a\u0026#34; (n: length?","type":"entry","url":"https://ohmyweekly.github.io/notes/red%E4%B8%AD%E7%9A%84parse/"}