<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
    
    
    

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    
    <meta name="referrer" content="no-referrer">

    <title>
        
            Red 中的 Parse ❚ 焉知非鱼
        
    </title>

    
    


    
    
    
    

    
    
    
    

    
    
    

    
    
    
    <style>
     
     
     :root {
         --theme-color: #ac4142;
         --theme-color-light: rgba(172, 65, 66, 0.2);
     }
     
     html {
         line-height: 1.5;
     }
    </style>

    
    

    
    
    
    
    <link rel="stylesheet" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css">
    
    <link rel="preload" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css" as="style">

    



    
        <style>
         
         /* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }

         
         /* Overrides on top of the theme and Chroma CSS */
/* Chroma-based lines highlighting in code blocks */
.chroma .hl {
    background-color: #e8e8e8;
    /* Extend highlight up to 100 characters (assuming that the code blocks never have more than 100 characters in a line) */
    min-width: 100ch;
}
/* GenericHeading */ .chroma .gh { color: #999999; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa; font-weight: bold }

         
        </style>
    

    

    
    
    

    
    <script src="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js"></script>
    
    <link rel="preload" href="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js" as="script">

    
    
    <script defer src="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js"></script>
    
    <link rel="preload" href="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js" as="script">

    

    

    
    
    

    
    
<!-- rel="me" links for IndieAuth -->







    
 
<meta property="og:title" content="Red 中的 Parse" />
<meta property="og:description"
      content=" " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ohmycloud.github.io/notes/red%E4%B8%AD%E7%9A%84parse/" />


    
        <meta property="article:published_time" content="2018-12-14T21:51:07&#43;00:00"/>
    
    
        <meta property="article:modified_time" content="2018-12-14T21:51:07&#43;00:00"/>
    









    




     <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Red 中的 Parse"/>
<meta name="twitter:description" content=" "/>


    
    
    <link rel="alternate" type="application/jf2post+json" href="https://ohmycloud.github.io/notes/red%E4%B8%AD%E7%9A%84parse/jf2post.json" title="Jf2post for 焉知非鱼" />
    
     



    
    
    
        
    


     
        
        <meta name="DC.Creator" content="焉知非鱼"/>
    



    
    
    
    <meta name="hugo-build-date" content="2024-03-01T16:16:06Z"/>
    <meta name="hugo-commit-hash" content="312735366b20d64bd61bff8627f593749f86c964"/>
    <meta name="generator" content="Hugo 0.123.7">
</head>


    
        <body lang="en">
    

        
        <div class="border" id="home"></div>

        <div class="wrapper">   
            
<nav id="nav" class="nav-collapse opened" aria-hidden="false">
    <ul class="navbar">
        <li><a class="" href="/">Home</a></li>
        
            
                <li><a class="" href="https://ohmycloud.github.io/posts/">Posts</a></li>
            
        
            
                <li><a class="" href="https://ohmycloud.github.io/notes/">Notes</a></li>
            
        
        
            <li><a class="" href="https://ohmycloud.github.io/search/">Search</a></li>
        
    </ul>
</nav>

            <div class="container">
                <header class="masthead">
                    <div class="masthead-title no-text-decoration">
                        <a href="/">焉知非鱼</a> <span class="blinking-cursor">❚</span>
                    </div>
                    <div class="masthead-tagline">
                        Wait the light to fall
                    </div>
                </header>

                








<article class="post h-entry notes">
    <header>
        <div class="center">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>

        <h1 class="post-title p-name">Red 中的 Parse</h1>

        
        <data class="u-url" value="https://ohmycloud.github.io/notes/red%E4%B8%AD%E7%9A%84parse/"></data>

        <div class="date-syndication">
            


    
    
    <div class="post-date">
        
        <time datetime="2018-12-14T21:51:07+0000" class="dt-published">Fri Dec 14, 2018</time>
        
        
    </div>


            




        </div>
         



    
    
    
        
    


    
        
        <span class="hide">
            &mdash; <a href="https://ohmycloud.github.io/" class="u-author">焉知非鱼</a>
        </span>
    


    </header>

    <div class="content">
        


        





                       


        <div class="e-content">
            




<h2 id="parse-入门">Parse 入门&nbsp;<a class="headline-hash no-text-decoration" href="#parse-入门">#</a> </h2>
<p><a href="http://rebol.com/">Rebol</a> 语言最大的特色之一就是它的解析引擎，简称为 <strong>Parse</strong>。这是卡尔·萨森拉斯（<a href="http://en.wikipedia.org/wiki/Carl_Sassenrath">Carl Sassenrath</a>）的一个惊人设计，在过去的15年里，所有 Rebol 用户都免于使用臭名昭著的无法维护的 <a href="http://en.wikipedia.org/wiki/Regular_expression">regexp</a> 的<a href="http://www.codinghorror.com/blog/2005/02/regex-use-vs-regex-abuse.html">痛苦</a>。现在，Parse 也可用于 <strong>R</strong>ed 用户，而且是增强版！</p>
<p>那么，简而言之，什么是 Parse？它是一个嵌入式 <a href="http://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>（我们称之为 Rebol 世界中的“方言”），用于使用语法规则解析输入序列。 Parse 方言是 <a href="http://en.wikipedia.org/wiki/Top-down_parsing_language">TDPL</a> 家族的<a href="http://www.rebol.net/wiki/Parse_Project#Theory_of_PARSE">增强成员</a>。 Parse 的常见用法是检查，验证，提取，修改输入数据，甚至实现嵌入式和外部 DSL。</p>
<p><code>parse</code> 函数调用语法很简单：</p>
<pre tabindex="0"><code class="language-red" data-lang="red">parse &lt;input&gt; &lt;rules&gt;  

&lt;input&gt;: 任意系列值 (字符串, 文件, 块儿, 路径, ...)
&lt;rules&gt;: 块儿! 具有有效 Parse 方言内容的值
</code></pre><p>这里有几个例子，即使你不懂 Red 和解析方言，你仍然可以“获得”它们中的大多数，不像正则表达式。您可以将它们直接复制/粘贴到 Red 控制台中。</p>
<p>使用语法规则进行字符串或块输入验证的一些简单示例：</p>
<pre tabindex="0"><code class="language-red" data-lang="red">parse &#34;a plane&#34; [[&#34;a&#34; | &#34;the&#34;] space &#34;plane&#34;] ;-- rule 中的空格需要用 space 显式声明
parse &#34;the car&#34; [[&#34;a&#34; | &#34;the&#34;] space [&#34;plane&#34; | &#34;car&#34;]]

parse &#34;123&#34; [&#34;1&#34; &#34;2&#34; [&#34;4&#34; | &#34;3&#34;]] ;-- rule 中的空格默认被忽略
parse &#34;abbccc&#34; [&#34;a&#34; 2 &#34;b&#34; 3 &#34;c&#34;]  ;-- 一个 a, 俩个 b, 三个 c
parse &#34;aaabbb&#34; [copy letters some &#34;a&#34; (n: length? letters) n &#34;b&#34;]

parse [a] [&#39;b | &#39;a | &#39;c]
parse [hello nice world] [3 word!] ;-- 三个单词
parse [a a a b b b] [copy words some &#39;a (n: length? words) n &#39;b]
</code></pre><p>如何准确地解析 IPv4 地址：</p>
<pre tabindex="0"><code class="language-red" data-lang="red">    four:     charset &#34;01234&#34;
    half:     charset &#34;012345&#34;
    non-zero: charset &#34;123456789&#34;
    digit:    union non-zero charset &#34;0&#34;

    byte: [
          &#34;25&#34; half
        | &#34;2&#34; four digit
        | &#34;1&#34; digit digit
        | non-zero digit
        | digit
    ]
    ipv4: [byte dot byte dot byte dot byte]

    parse &#34;192.168.10.1&#34; ipv4
    parse &#34;127.0.0.1&#34;    ipv4
    parse &#34;99.1234&#34;      ipv4
    parse &#34;10.12.260.1&#34;  ipv4

    data: {
        ID: 121.34
        Version: 1.2.3-5.6
        Your IP address is: 85.94.114.88.
        NOTE: Your IP Address could be different tomorrow.
    }
    parse data [some [copy value ipv4 | skip]]
    probe value                      ; will ouput: &#34;85.94.114.88&#34;
</code></pre><p>一个粗略但实用的电子邮件地址验证器：</p>
<pre tabindex="0"><code class="language-red" data-lang="red">    digit:   charset &#34;0123456789&#34;               ;-- 数字字符集
    letters: charset [#&#34;a&#34; - #&#34;z&#34; #&#34;A&#34; - #&#34;Z&#34;]  ;-- 字母字符集
    special: charset &#34;-&#34;                        ;-- 特殊字符
    chars:   union union letters special digit  ;-- 合并字符集
    word:    [some chars]
    host:    [word]
    domain:  [word some [dot word]]
    email:   [host &#34;@&#34; domain]

    parse &#34;john@doe.com&#34; email
    parse &#34;n00b@lost.island.org&#34; email
    parse &#34;h4x0r-l33t@domain.net&#34; email
</code></pre><p>以字符串形式验证数学表达式（来自 Rebol/Core <a href="http://www.rebol.com/docs/core23/rebolcore-15.html#section-6">手册</a>）：</p>
<pre tabindex="0"><code class="language-red" data-lang="red">    expr:    [term [&#34;+&#34; | &#34;-&#34;] expr | term]
    term:    [factor [&#34;*&#34; | &#34;/&#34;] term | factor]
    factor:  [primary &#34;**&#34; factor | primary]
    primary: [some digit | &#34;(&#34; expr &#34;)&#34;]
    digit:   charset &#34;0123456789&#34;
    
    parse &#34;1+2*(3-2)/4&#34; expr        ; will return true
    parse &#34;1-(3/)+2&#34; expr           ; will return false
</code></pre><p>创建一个简单的 HTML 子集解析器：</p>
<pre tabindex="0"><code class="language-red" data-lang="red">    html: {
        &lt;html&gt;
            &lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;
            &lt;body&gt;&lt;div&gt;&lt;u&gt;Hello&lt;/u&gt; &lt;b&gt;World&lt;/b&gt;&lt;/div&gt;&lt;/body&gt;
        &lt;/html&gt;
    }

    ws: charset reduce [space tab cr lf]

    parse html tags: [
        collect [any [
            ws
            | &#34;&lt;/&#34; thru &#34;&gt;&#34; break
            | &#34;&lt;&#34; copy name to &#34;&gt;&#34; skip keep (load name) opt tags
            | keep to &#34;&lt;&#34;
        ]]
    ]

    ; will produce the following tree of blocks as output of parse:
     [
         html [
             head [
                 title [&#34;Test&#34;]
             ]
             body [
                 div [
                     u [&#34;Hello&#34;]
                     b [&#34;World&#34;]
                 ]
             ]
         ]
     ]
</code></pre><h2 id="parse-方言">Parse 方言&nbsp;<a class="headline-hash no-text-decoration" href="#parse-方言">#</a> </h2>
<p>Parse 的核心原则是：</p>
<ul>
<li>通过匹配 grammar 规则推进输入系列，直到顶级规则失败（返回 <code>false</code>）或输入耗尽（返回 <code>true</code>）(*)</li>
<li>有序选择（例如在[&ldquo;a&rdquo;|&ldquo;ab&rdquo;]规则中，第二个将永远不会成功）</li>
<li>规则可组合性（无限制）</li>
<li>有限的回溯：只有输入和规则位置被回溯，其他变化仍然存在</li>
<li>两种模式：字符串解析（例如：外部 DSL）或块解析（例如：嵌入式 DSL）</li>
</ul>
<p>(*) 如果在任何规则中以最简单的形式使用 <code>collect</code> 关键字，则无论 root 规则是否成功，都将通过 <code>parse</code> 返回一个块。</p>
<p>Parse规则可以来自：</p>
<ul>
<li><strong>keyword</strong>       : 方言保留字（见下表）</li>
<li><strong>word</strong>          : word 会被求值并将其值用作规则</li>
<li><strong>word:</strong>         : 将单词设置为当前输入位置</li>
<li><strong>:word</strong>         : 在单词引用的位置继续输入</li>
<li><strong>integer</strong> value : 指定具有固定数量或迭代范围的迭代规则</li>
<li><strong>value</strong>         : 将输入与值匹配</li>
<li><strong>|</strong>             : 回溯并匹配下一个备用规则</li>
<li><strong>[rules]</strong>       : 子规则块</li>
<li><strong>(expression)</strong>  : 转义 Parse方言，计算 Red 表达式并返回 Parse 方言</li>
</ul>
<p>Red 的 Parse 实现中目前提供以下关键字。它们可以自由组合在一起。</p>
<h2 id="匹配">匹配&nbsp;<a class="headline-hash no-text-decoration" href="#匹配">#</a> </h2>
<hr>
<ul>
<li><strong>ahead</strong> rule    : 向前查看规则, 匹配规则, 但不推进输入</li>
<li><strong>end</strong>           : 如果当前输入位置到终点了则返回成功</li>
<li><strong>none</strong>          : 总是返回成功（catch-all 规则）</li>
<li><strong>not</strong> rule      : 反转子规则的结果</li>
<li><strong>opt</strong> rule      : 向前查看规则, 可选地匹配规则</li>
<li><strong>quote</strong> rule    : 按字面意思匹配下一个值（用于方言转义需求）</li>
<li><strong>skip</strong>          : 将输入推进一个元素（一个字符或一个值）</li>
<li><strong>thru</strong> rule     : 推进输入直到规则匹配, 输入设置在匹配的后面</li>
<li><strong>to</strong> rule       : 推进输入直到规则匹配, 输入设置在匹配的开头</li>
</ul>
<h2 id="控制流">控制流&nbsp;<a class="headline-hash no-text-decoration" href="#控制流">#</a> </h2>
<hr>
<ul>
<li><strong>break</strong>         : 跳出匹配循环, 返回成功</li>
<li><strong>if</strong>(expr)      : 计算 Red 表达式，如果为 false 或 none，则失败并回溯</li>
<li><strong>into</strong> rule     : 将输入切换到匹配的系列（字符串或块）并用规则解析它</li>
<li><strong>fail</strong>          : 强制当前规则失败并回溯</li>
<li><strong>then</strong>          : 无论后续的失败或成功, 跳过下一个备用规则</li>
<li><strong>reject</strong>        : 跳出匹配循环, 返回失败</li>
</ul>
<h2 id="迭代">迭代&nbsp;<a class="headline-hash no-text-decoration" href="#迭代">#</a> </h2>
<hr>
<ul>
<li><strong>any</strong> rule      : 重复规则零次或多次直到失败或输入没有推进</li>
<li><strong>some</strong> rule     : 重复规则一次或多次直到失败或输入没有推进</li>
<li><strong>while</strong> rule    : 重复规则零次或多次直到失败， 无论输入是否推进</li>
</ul>
<h2 id="提取">提取&nbsp;<a class="headline-hash no-text-decoration" href="#提取">#</a> </h2>
<hr>
<ul>
<li><strong>collect</strong> [rule]           : 从匹配的规则中返回一组收集的值</li>
<li><strong>collect set</strong> word [rule]  : 从块中收集匹配规则的值，并将其设置为 word</li>
<li><strong>collect into</strong> word [rule] : 从匹配的规则中收集值并将它们插入到由 word 引用的块中</li>
<li><strong>copy</strong> word rule           : 将 word 设置为匹配输入的副本</li>
<li><strong>keep</strong> rule                : 将匹配输入的副本附加到收集块</li>
<li><strong>keep</strong>(expr)               : 将 Red 表达式中的最后一个值附加到收集块</li>
<li><strong>set</strong> word rule            : 将 word 设置为匹配输入的第一个值</li>
</ul>
<h2 id="修改">修改&nbsp;<a class="headline-hash no-text-decoration" href="#修改">#</a> </h2>
<hr>
<ul>
<li><strong>insert only</strong> value        : 在当前输入位置插入[/only]值并在值后面推进输入</li>
<li><strong>remove</strong> rule              : 删除匹配的输入</li>
</ul>
<p>核心原则提到了两种解析模式。这在 Red 中是必要的（就像在 Rebol 中），因为我们有两个基本的系列数据类型 : <code>string!</code> 和 <code>block!</code>。<code>string!</code> datatype 当前是一个 Unicode 代码点数组（ Red 将在未来版本中支持字符数组），而 <code>block!</code> datatype 是一个任意 Red 值的数组（包括其他块）。</p>
<p>在实践中，这导致 Parse 方言使用中的一些细微差别。例如，可以使用新的 <code>bitset!</code>  数据类型定义任意字符集！这仅对 <code>string!</code> 解析有用以便一次匹配大量字符。以下是仅使用 bitsets 匹配和迭代器的示例 :</p>
<pre tabindex="0"><code class="language-red" data-lang="red">letter: charset [#&#34;a&#34; - #&#34;z&#34;]
digit:  charset &#34;0123456789&#34;

parse &#34;hello 123 world&#34; [5 letter space 3 digit space some letter]
</code></pre><h2 id="bitset-数据类型">Bitset! 数据类型&nbsp;<a class="headline-hash no-text-decoration" href="#bitset-数据类型">#</a> </h2>
<p>bitset 值是用于存储布尔值的 bit 位数组。在 Parse 的上下文中，bitsets 对于在整个 Unicode 范围内表示任意字符集非常有用，可以在单个操作中与输入字符进行匹配。因为 <code>bitset!</code> 在此 0.4.1 版本中引入，值得概述下所支持的功能。基本上，它与 Rebol3 的 <code>bitset!</code> <a href="http://www.rebol.com/r3/docs/datatypes/bitset.html">实现</a>相同。</p>
<p>要创建 bitset，您需要提供一个或多个字符作为基本规范。它们可以以不同的形式提供：codepoint 整数值，<code>char!</code> 值，<code>string!</code> 值，一个范围或一组之前的元素。使用以下语法创建新的 bitset：</p>
<pre tabindex="0"><code class="language-red" data-lang="red">make bitset! &lt;spec&gt;

&lt;spec&gt;: char!, integer!, string! or block!
</code></pre><p>例如:</p>
<pre tabindex="0"><code class="language-red" data-lang="red">    ; create an empty bitset with places at least for 50 bits
    make bitset! 50

    ; create a bitset with bit 65 set
    make bitset! #&#34;A&#34;

    ; create a bitset with bits 104 and 105 set
    make bitset! &#34;hi&#34;

    ; create and set bits using different values representations
    make bitset! [120 &#34;hello&#34; #&#34;A&#34;]

    ; create a bitset using ranges of values
    make bitset! [#&#34;0&#34; - #&#34;9&#34; #&#34;a&#34; - #&#34;z&#34;]
</code></pre><p>范围使用两个值（允许 <code>char!</code> 或 <code>integer!</code>）定义，用破折号字分隔。</p>
<p>Bitsets 自动调整大小以适应所提供的规格值。大小舍入到高位字节边界。</p>
<p>还提供了快捷 <code>charset</code> 功能以供实际使用，因此您可以编写：</p>
<pre tabindex="0"><code class="language-red" data-lang="red">    charset &#34;ABCDEF&#34;
    charset [120 &#34;hello&#34; #&#34;A&#34;]
    charset [#&#34;0&#34; - #&#34;9&#34; #&#34;a&#34; - #&#34;z&#34;]
</code></pre><p>对于读写单个 bits 位，路径表示法是最简单的方法：</p>
<pre tabindex="0"><code class="language-red" data-lang="red">    bs: charset [#&#34;a&#34; - #&#34;z&#34;]
    bs/97     ; will return true
    bs/40     ; will return false
    bs/97: false
    bs/97     ; will return false
</code></pre><p>（注意：bitset 索引从零开始。）</p>
<p>此外，<code>bitset!</code> 数据类型支持以下操作：</p>
<p><code>pick</code>, <code>poke</code>, <code>find</code>, <code>insert</code>, <code>append</code>, <code>copy</code>, <code>remove</code>, <code>clear</code>, <code>length?</code>, <code>mold</code>, <code>form</code></p>
<p>有关这些操作的使用的详细信息，请参阅 Rebol3 bitset <a href="http://www.rebol.com/r3/docs/datatypes/bitset.html">文档</a>。</p>
<p>为了处理各种 Unicode 字符，bitsets 之外的位被视为<strong>虚拟位</strong>，因此可以无错误地测试和设置它们，bitset 的大小将根据需要自动扩展。但这仍然不足以处理大的范围，例如除了数字之外的所有 Unicode 字符的 bitset。对于这种情况，可以定义补充的 bitset，该 bitset 表示指定位的补码范围。这使得在仅使用微小的存储器部分存储大的 bitset 成为可能。</p>
<p>补充的 bitsets 的创建方式与普通 bitsets 相同，但它们需要以 <code>not</code> 单词开头并始终对于他们的规格使用 <code>block!</code></p>
<pre tabindex="0"><code class="language-red" data-lang="red">    ; all characters except digits
    charset [not &#34;0123456789&#34;]

    ; all characters but hexadecimal symbols
    charset [not &#34;ABCDEF&#34; #&#34;0&#34; - #&#34;9&#34;]

    ; all characters except whitespaces
    charset reduce [&#39;not space tab cr lf]
</code></pre><p>设置操作也是可能的，但目前只有 <code>union</code> 用 Red 实现了（它对于 bitsets 来说是最常用的）。使用 <code>union</code>，您可以将两个 bitsets 合在一起以形成一个新的 bitsets，这在实践中非常有用：</p>
<pre tabindex="0"><code class="language-red" data-lang="red">    digit: charset &#34;0123456789&#34;
    lower: charset [#&#34;a&#34; - #&#34;z&#34;]
    upper: charset [#&#34;A&#34; - #&#34;Z&#34;]

    letters:  union lower upper
    hexa:     union upper digit
    alphanum: union letters digit
</code></pre><h2 id="parse-实现">Parse 实现&nbsp;<a class="headline-hash no-text-decoration" href="#parse-实现">#</a> </h2>
<p>Parse 方言已经实现为 <a href="http://en.wikipedia.org/wiki/Finite-state_machine">FSM</a>，它不同于依赖于递归函数调用的 Rebol3 实现。 FSM 方法可以实现几个有趣的功能，例如能够停止解析并在以后恢复它，甚至序列化解析状态，远程发送它并重新加载它以继续解析。现在可以用最少的努力来实现这些功能。</p>
<p>Red Parse <a href="https://github.com/red/red/blob/master/runtime/parse.reds">实现</a>大约有1300行 Red/System 代码，其中很大一部分花在了针对常见情况的优化迭代循环上。大约有<a href="https://github.com/red/red/blob/master/tests/source/units/parse-test.red">770个单元测试</a>是手写的，以涵盖基本的 Parse 功能。</p>
<p>当前的 Parse 作为解释器运行，对于大多数用例来说都足够快。对于需要最高性能的情况，已经开始在 Parse 静态编译器上开始工作，以便尽快为 Parse 密集型 Red 应用程序提供最快的速度。生成的代码是纯 Red/System 代码，平均比解释版本快一般。当 Red 将自托管时，将提供 Parse JIT 编译器来处理静态编译器无法处理的情况。</p>
<p>随着 Red 获得更多功能，Parse 将继续得到改进以利用它们。其他未来的改进，<code>binary!</code> 解析将尽快添加一旦 <code>binary!</code> 数据类型可用，当 <code>port!</code> 数据类型出现时流解析也将成为可能。</p>
<p>Red Parse 还以可选的回调函数的形式公开面向公共事件的 API，可以使用<code>/trace</code> 细化传递给 <code>parse</code>。</p>
<pre tabindex="0"><code class="language-red" data-lang="red">    parse/trace &lt;input&gt; &lt;rules&gt; &lt;callback&gt;

    &lt;callback&gt; specification:

    func [
        event   [word!]   ; Trace events
        match?  [logic!]  ; Result of last matching operation
        rule    [block!]  ; Current rule at current position
        input   [series!] ; Input series at next position to match
        stack   [block!]  ; Internal parse rules stack
        return: [logic!]  ; TRUE: continue parsing, FALSE: exit
    ]

    Events list:
    - push    : once a rule or block has been pushed on stack
    - pop     : before a rule or block is popped from stack
    - fetch   : before a new rule is fetched
    - match   : after a value matching occurs
    - iterate : after a new iteration pass begins (ANY, SOME, ...)
    - paren   : after a paren expression was evaluated
    - end     : after end of input has been reached
</code></pre><p>此 API 将在未来进行扩展，以获得更细粒度的事件。这个 API 可用于为 Parse 提供跟踪，统计，调试&hellip;&hellip;让我们看看 Red 用户会想出什么！ ;-)</p>
<p>已实现<a href="https://github.com/red/red/blob/master/boot.red#L1013">默认回调</a>以进行跟踪。可以使用方便的解析跟踪函数包装器访问它：</p>
<pre tabindex="0"><code class="language-red" data-lang="red">parse-trace &lt;input&gt; &lt;rules&gt;
</code></pre><p>您可以使用简单的解析规则来尝试查看结果输出。</p>
<h2 id="dsl-支持怎么样">DSL 支持怎么样？&nbsp;<a class="headline-hash no-text-decoration" href="#dsl-支持怎么样">#</a> </h2>
<p>Parse 是实现 DSL 解析器（嵌入式和外部式）的强大工具，这要归功于它能够将 Red 表达式直接内联到规则中，从而可以轻松地将 DSL 语法与其相应的语义链接起来。为了说明这一点，这里是一个使用 Parse 编写的著名混淆<a href="http://en.wikipedia.org/wiki/Brainfuck">语言</a>的简单解释器：</p>
<pre tabindex="0"><code class="language-red" data-lang="red">bf: function [prog [string!]][
        size: 30000
        cells: make string! size
        append/dup cells null size

        parse prog [
            some [
                  &#34;&gt;&#34; (cells: next cells)
                | &#34;&lt;&#34; (cells: back cells)
                | &#34;+&#34; (cells/1: cells/1 + 1)
                | &#34;-&#34; (cells/1: cells/1 - 1)
                | &#34;.&#34; (prin cells/1)
                | &#34;,&#34; (cells/1: first input &#34;&#34;)
                | &#34;[&#34; [if (cells/1 = null) thru &#34;]&#34; | none]
                | &#34;]&#34; [
                   pos: if (cells/1 &lt;&gt; null)
                   (pos: find/reverse pos #&#34;[&#34;) :pos
                   | none
                  ]
                | skip
            ]
        ]
    ]

    ; This code will print a Hello World! message
    bf {
        ++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.
        &gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;.
    }

    ; This one will print a famous quote
    bf {
        ++++++++[&gt;+&gt;++&gt;+++&gt;++++&gt;+++++&gt;++++++&gt;+++++++&gt;++++++++&gt;
        +++++++++&gt;++++++++++&gt;+++++++++++&gt;++++++++++++&gt;++++++++
        +++++&gt;++++++++++++++&gt;+++++++++++++++&gt;++++++++++++++++&lt;
        &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
        &gt;&gt;&gt;&gt;&gt;&gt;.&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;
        &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;++.--&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;
        &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;.&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+.-&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
        &gt;&gt;&gt;&gt;&gt;&gt;+++.---&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;.&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;--.++
        &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;.&lt;&lt;&lt;&lt;&gt;
        &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+++.---&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;.&lt;&lt;&lt;&lt;&lt;&lt;
        &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.
        +&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;--.++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;+.-
        &lt;&lt;&lt;&lt;.
    }
</code></pre><p>注意：此实现仅限于一级“[&hellip;]”嵌套，以使其尽可能短。<a href="https://gist.github.com/dockimbel/7713170">此处</a>是仅使用 Parse 的完整但更长且更复杂的实现。</p>
<p>因此，这种方法对小型 DSL 非常有用。对于更复杂的 Parse，Parse 仍然可以正常工作，但随着 DSL 语义变得更加复杂，它可能没那么有用。对于大多数用户而言，为更高级的 DSL 实现解释器或编译器并非易事。 Red 将通过在Parse 之上提供元 DSL 包装器来解决这个问题，通过抽象出解释器或编译器的核心部分来暴露更高级别的 API 以构建更复杂的 DSL。用于构建其他 DSL 的 DSL 并不是一个疯狂的想法，它已经以一种非常强大的形式存在，例如<a href="http://www.rascal-mpl.org/">Rascal</a> 语言。 Red 将提供的只是朝这个方向迈出的一步，但没有像 Rascal 那样精密（和复杂）。</p>
<h2 id="此版本中的其他更改">此版本中的其他更改&nbsp;<a class="headline-hash no-text-decoration" href="#此版本中的其他更改">#</a> </h2>
<p>只是提到这个版本中的其他变化，现在我们摆脱了房间里的800磅大猩猩。此版本为 Red 和 Red/System 带来了大量的<a href="https://github.com/red/red/issues?milestone=12&amp;page=1&amp;state=closed">错误修复</a>。此外，多亏了 qtxie，ELF 文件发射器在生成共享库时现在与其他文件发射器相当。</p>
<p>感谢所有参与帮助实现这一重大发布的人员，包括设计修复和改进，测试，错误报告和测试编写。</p>
<p>请享用！ :-)</p>
<h2 id="链接">链接&nbsp;<a class="headline-hash no-text-decoration" href="#链接">#</a> </h2>
<ul>
<li><a href="https://www.red-lang.org/2013/11/041-introducing-parse.html">introducing parse</a></li>
<li><a href="https://doc.red-lang.org/zh-hans/">Red 编程语言文档</a></li>
<li><a href="http://www.red-by-example.org/parse.html">Red by Example</a></li>
<li><a href="http://www.michaelsydenham.com/reds-parse-dialect/">Red’s Parse dialect</a></li>
<li><a href="http://www.michaelsydenham.com/red-parse-simple-rules/">Red Parse</a></li>
</ul>


        </div>
    </div>
</article>



                <footer>
                    




<div class="no-text-decoration">
    <div class="jump top"><a href="#" title="Top of this page">⮉</a></div>
    <div class="jump bottom"><a href="#bottom" title="Bottom of this page">⮋</a></div>
</div>


 
    
        <div class="hugotoc no-text-decoration">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#parse-入门">Parse 入门</a></li>
    <li><a href="#parse-方言">Parse 方言</a></li>
    <li><a href="#匹配">匹配</a></li>
    <li><a href="#控制流">控制流</a></li>
    <li><a href="#迭代">迭代</a></li>
    <li><a href="#提取">提取</a></li>
    <li><a href="#修改">修改</a></li>
    <li><a href="#bitset-数据类型">Bitset! 数据类型</a></li>
    <li><a href="#parse-实现">Parse 实现</a></li>
    <li><a href="#dsl-支持怎么样">DSL 支持怎么样？</a></li>
    <li><a href="#此版本中的其他更改">此版本中的其他更改</a></li>
    <li><a href="#链接">链接</a></li>
  </ul>
</nav>
            <a href="#" class="back-to-top">Back to top</a>
        </div>
    
    
<script src="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js"></script>

<link rel="preload" href="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js" as="script">

<script type="application/javascript">(function() {
     var $window = $(window);
     if ($window.width() >= 1400) { 
         var $toc = $('#TableOfContents');
         if ($toc.length > 0) {
             function onScroll(){
                 var currentScroll = $window.scrollTop();
                 var h = $('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .h-feed h2');
                 var id = "";
                 h.each(function (i, e) {
                     e = $(e);
                     if (e.offset().top - 10 <= currentScroll) {
                         id = e.attr('id');
                     }
                 });
                 var current = $toc.find('a.current');
                 if (current.length == 1 && current.eq(0).attr('href') == '#' + id) return true;

                 current.each(function (i, e) {
                     $(e).removeClass('current').siblings('ul').hide();
                 });
                 $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                     $(e).children('a').addClass('current').siblings('ul').show();
                 });
             }
             $window.on('scroll', onScroll);
             $(document).ready(function() {
                 $toc.find('a').parent('li').find('ul').hide();
                 onScroll();
                 document.getElementsByClassName('hugotoc')[0].style.display = '';
             });}}})();</script>








<div class="backtotop center no-text-decoration">
    <a href="#">back to <span class="top">top</span></a>
</div>


<div class="right">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>
<div class="clear-float"></div>



<div class="prev-next-navigator clear-float">
    
        <span class="prev-post left no-text-decoration">
            <a href="https://ohmycloud.github.io/notes/playing-with-fibonacci-in-raku/" class="nobr">« 🎄 15/25. 在 Raku 中使用斐波那契数</a>
        </span>
    
    
        <span class="next-post right no-text-decoration">
            <a href="https://ohmycloud.github.io/posts/71.variables/" class="nobr">变量 »</a>
        </span>
    
</div>


<a id="bottom"></a>









                       







                    <ul class="no-bullets feed right inline">
    
        
        
    
</ul>
<div class="clear-float"></div>

                </footer>
                <hr />
            </div>               

            <footer> 
                

<ul class="social no-text-decoration">
    
</ul>










 
    
    



<p class="generated no-text-decoration">
    Generated using  <a href="https://gitlab.com/kaushalmodi/hugo-theme-refined"><code class="nobr">hugo-theme-refined</code></a> + <span class="nobr">Hugo <a href="https://github.com/gohugoio/hugo/commit/312735366b20d64bd61bff8627f593749f86c964">0.123.7</a></span>
</p>

<p>
    
</p>




<div class="badges no-text-decoration">
    
    

    
</div>




<script type="application/javascript">var nav=responsiveNav("#nav");</script>




<script defer src="/js/libs/fragmentions/wrapper.min.e8c468c89edc4f5dccaa8c720c6b220b3088a16cd7b1e4a1e3345985788260c9.js"></script>









            </footer>
        </div> 
    </body>
</html>
