{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"content":{"html":"\u003ch2 id=\"贪婪-junction-的奇闻异事\"\u003e贪婪 junction 的奇闻异事\u003c/h2\u003e\n\u003cp\u003e说明 Raku 的 junction 是如何贪婪的设计，以及一个建议。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://raku.org/\"\u003eRaku\u003c/a\u003e 有一个整洁的功能，叫做 \u003ca href=\"https://docs.raku.org/type/Junction\"\u003eJunction\u003c/a\u003e。在这篇短文中，我想强调一下 junction 与函数交互的一个特殊后果：它们是贪婪的，我的意思是它们会无意中把函数的其他参数变成 junction。为了说明这种行为，我将使用一个闭包创建一个 \u003ccode\u003epair\u003c/code\u003e 数据结构，它可以接受两个不同类型的值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eenum RGB \u0026lt;R G B\u0026gt;;\n\n# Pair Constructor: the arguments of pair() are captured\n# in a closure that is returned\nsub pair(\\x, \\y) {\n    sub (\u0026amp;p){ p(x, y) } \n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e所以 \u003ccode\u003epair\u003c/code\u003e 接受两个任意类型的参数，并返回一个以函数为参数的闭包。我们将使用这个函数来访问存储在 \u003ccode\u003epair\u003c/code\u003e 中的值。我将把这些访问(accessor)函数称为 \u003ccode\u003efst\u003c/code\u003e 和 \u003ccode\u003esnd\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# Accessors to get the values from the closure\nmy sub fst (\u0026amp;p) {p( sub (\\x,\\y){x})}\nmy sub snd (\u0026amp;p) {p( sub (\\x,\\y){y})}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e做实际选择的函数是由 \u003ccode\u003efst\u003c/code\u003e 和 \u003ccode\u003esnd\u003c/code\u003e 返回的匿名子程序，这纯粹是为了让我可以将它们应用于 \u003ccode\u003epair\u003c/code\u003e，而不是必须将它们作为参数传递。让我们看一个例子，一个 \u003ccode\u003eInt\u003c/code\u003e 和一个 \u003ccode\u003eRGB\u003c/code\u003e 的 pair。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \\p1 = pair 42, R;\n\nif ( 42 == fst p1) {\n    say snd p1;\t#=\u0026gt; says \u0026quot;R\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e所以我们用两个值调用 \u003ccode\u003epair\u003c/code\u003e 来创建一个 pair，并使用 \u003ccode\u003efst\u003c/code\u003e 和 \u003ccode\u003esnd\u003c/code\u003e 来访问 pair 中的值。这是一个不可变的数据结构，所以不可能进行更新。\u003c/p\u003e\n\u003cp\u003e现在让我们使用 junction 作为其中一个参数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# Example instance with a 'one'-type junction\nmy Junction \\p1j = pair (42^43),R;\n\nif ( 42 == fst p1j) {\n    say snd p1j; #=\u0026gt; one(R, R)\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这里发生的情况是，原始参数 \u003ccode\u003eR\u003c/code\u003e 已经不可逆转地变成了与自己的 junction，尽管我们从未明确地在 \u003ccode\u003eR\u003c/code\u003e 上创建过 junction，但还是发生了这种情况。这是将 junction 类型应用于函数的结果，它不是一个 bug，只是 junction 行为的一个影响。更详细的解释，请看我的文章\u0026quot;\u003ca href=\"https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e\"\u003e重构 Raku 的 Junction\u003c/a\u003e\u0026quot;。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://docs.raku.org/type/Junction\"\u003eRaku 关于 junction 的文档\u003c/a\u003e中说，你不应该真正尝试从 junction 中获取值。\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;Junction 是用来作为布尔上下文中的匹配器，不支持 junction 的自省。如果你觉得有自省 junction 的冲动，请使用 Set 或相关类型代替。\u0026rdquo;\u003c/p\u003e\n\u003cp\u003e然而，有一个 FAQ \u003ca href=\"https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)\"\u003e勉强地告诉你如何做\u003c/a\u003e。FAQ 再次警告不要这样做。\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;如果你想从 junction 中提取值（特征态），你可能做错了什么，应该用 Set 来代替。\u0026rdquo;\u003c/p\u003e\n\u003cp\u003e然而，正如我所举的例子所证明的那样，从 junction 中恢复值是有明确的用例的。当然，仅仅因为另一个值恰好是 junction，存储在 pair 中的其中一个值就变得不可访问，这不是我们的本意。\u003c/p\u003e\n\u003cp\u003e因此，我建议增加一个折叠(\u003ccode\u003ecollapse\u003c/code\u003e)函数，允许将这些无意中出现的 junction 值折叠成它们的原始值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif ( 42 == fst p1j) {\n    say collapse(snd p1j); #=\u0026gt; says 'R'\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e该函数的实现取自\u003ca href=\"https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)\"\u003e上述常见问题\u003c/a\u003e，并增加了一个检查，以确保 junction 上的所有值都相同。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub collapse(Junction \\j) {    \n    my @vvs;\n    -\u0026gt; Any \\s { push @vvs, s }.(j);    \n    my $v =  shift @vvs;        \n    my @ts = grep {!($_ ~~ $v)}, @vvs;\n    if (@ts.elems==0) {  \n        $v\n    } else {\n        die \u0026quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}\u0026quot;;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果能把这个功能作为一个 \u003ccode\u003ecollapse\u003c/code\u003e 方法添加到 \u003ccode\u003eJunction\u003c/code\u003e 类中就更好了。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003ehttps://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\u003c/a\u003e\u003c/p\u003e\n","text":"贪婪 junction 的奇闻异事 说明 Raku 的 junction 是如何贪婪的设计，以及一个建议。\nRaku 有一个整洁的功能，叫做 Junction。在这篇短文中，我想强调一下 junction 与函数交互的一个特殊后果：它们是贪婪的，我的意思是它们会无意中把函数的其他参数变成 junction。为了说明这种行为，我将使用一个闭包创建一个 pair 数据结构，它可以接受两个不同类型的值。\nenum RGB \u0026lt;R G B\u0026gt;; # Pair Constructor: the arguments of pair() are captured # in a closure that is returned sub pair(\\x, \\y) { sub (\u0026amp;p){ p(x, y) } } 所以 pair 接受两个任意类型的参数，并返回一个以函数为参数的闭包。我们将使用这个函数来访问存储在 pair 中的值。我将把这些访问(accessor)函数称为 fst 和 snd。\n# Accessors to get the values from the closure my sub fst (\u0026amp;p) {p( sub (\\x,\\y){x})} my sub snd (\u0026amp;p) {p( sub (\\x,\\y){y})} 做实际选择的函数是由 fst 和 snd 返回的匿名子程序，这纯粹是为了让我可以将它们应用于 pair，而不是必须将它们作为参数传递。让我们看一个例子，一个 Int 和一个 RGB 的 pair。\nmy \\p1 = pair 42, R; if ( 42 == fst p1) { say snd p1;\t#=\u0026gt; says \u0026quot;R\u0026quot; } 所以我们用两个值调用 pair 来创建一个 pair，并使用 fst 和 snd 来访问 pair 中的值。这是一个不可变的数据结构，所以不可能进行更新。\n现在让我们使用 junction 作为其中一个参数。\n# Example instance with a 'one'-type junction my Junction \\p1j = pair (42^43),R; if ( 42 == fst p1j) { say snd p1j; #=\u0026gt; one(R, R) } 这里发生的情况是，原始参数 R 已经不可逆转地变成了与自己的 junction，尽管我们从未明确地在 R 上创建过 junction，但还是发生了这种情况。这是将 junction 类型应用于函数的结果，它不是一个 bug，只是 junction 行为的一个影响。更详细的解释，请看我的文章\u0026quot;重构 Raku 的 Junction\u0026quot;。\nRaku 关于 junction 的文档中说，你不应该真正尝试从 junction 中获取值。\n\u0026ldquo;Junction 是用来作为布尔上下文中的匹配器，不支持 junction 的自省。如果你觉得有自省 junction 的冲动，请使用 Set 或相关类型代替。\u0026rdquo;\n然而，有一个 FAQ 勉强地告诉你如何做。FAQ 再次警告不要这样做。\n\u0026ldquo;如果你想从 junction 中提取值（特征态），你可能做错了什么，应该用 Set 来代替。\u0026rdquo;\n然而，正如我所举的例子所证明的那样，从 junction 中恢复值是有明确的用例的。当然，仅仅因为另一个值恰好是 junction，存储在 pair 中的其中一个值就变得不可访问，这不是我们的本意。\n因此，我建议增加一个折叠(collapse)函数，允许将这些无意中出现的 junction 值折叠成它们的原始值。\nif ( 42 == fst p1j) { say collapse(snd p1j); #=\u0026gt; says 'R' } 该函数的实现取自上述常见问题，并增加了一个检查，以确保 junction 上的所有值都相同。\nsub collapse(Junction \\j) { my @vvs; -\u0026gt; Any \\s { push @vvs, s }.(j); my $v = shift @vvs; my @ts = grep {!($_ ~~ $v)}, @vvs; if (@ts.elems==0) { $v } else { die \u0026quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}\u0026quot;; } } 如果能把这个功能作为一个 collapse 方法添加到 Junction 类中就更好了。\n原文链接: https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\n"},"name":"贪婪 Junction 的奇闻异事","published":"2020-10-04T00:00:00+08:00","summary":"The Strange Case of the Greedy Junction","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/"}