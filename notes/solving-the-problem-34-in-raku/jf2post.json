{"author":{"name":null,"type":"card","url":"https://ohmycloud.github.io/"},"content":{"html":"\u003cp\u003e欢迎来到 \u003cstrong\u003eRaku One-Liner Advent Calendar\u003c/strong\u003e 的第\u003ca href=\"https://raku.online/2018/12/11/solving-the-problem-34-in-perl-6/\"\u003e11\u003c/a\u003e天！ 今天，日历文章完全致力于解决欧拉计划的\u003ca href=\"https://projecteuler.net/problem=34\"\u003e问题34\u003c/a\u003e。 如果你想在看到我的答案之前找到自己的答案，请再次暂停阅读。\u003c/p\u003e\n\u003cp\u003e因此，任务是找到所有数字的总和，它们等于其数字的阶乘的总和。 听起来很清楚？ 🙂 你可以看一下单行程序的解决方案，以便更好地理解它。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e..\u003c/span\u003e\u003cspan class=\"mi\"\u003e50_000\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003egrep\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"nv\"\u003e$_\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecomb\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e({[\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e..\u003c/span\u003e\u003cspan class=\"nv\"\u003e$_\u003c/span\u003e\u003cspan class=\"p\"\u003e})})\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e让我们从\u0026hellip;\u0026hellip;开始吧。\u003c/p\u003e\n\u003cp\u003e我们循环范围 \u003ccode\u003e3 .. 50_000\u003c/code\u003e。上边界是基于某些要考虑因素的猜测。我不会在这里解释，但如果你好奇，你可能会试着找到答案。基本上，在某些时候你会理解这个数字要么包含太多数字，要么本身就太大了。请参阅有关 Project Euler 的讨论以获得纯理论的解释。\u003c/p\u003e\n\u003cp\u003e第二步是 \u003ccode\u003egrep\u003c/code\u003e。我们正在搜索与总和相等的数字（\u003ccode\u003e$_ ==\u003c/code\u003e）。它是通过第二个\u003ca href=\"https://raku.online/2018/12/10/reduction-operator-in-perl-6/\"\u003e化简\u003c/a\u003e加号 \u003ccode\u003e[+]\u003c/code\u003e 计算出来的，但你可以使用 \u003ccode\u003esum\u003c/code\u003e 方法代替：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"nv\"\u003e$_\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecomb\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e({[\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e..\u003c/span\u003e\u003cspan class=\"nv\"\u003e$_\u003c/span\u003e\u003cspan class=\"p\"\u003e})\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esum\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e请注意 \u003ccode\u003e.comb\u003c/code\u003e 是一个在默认变量 \u003ccode\u003e$_\u003c/code\u003e 上调用的方法。 \u003ccode\u003ecomb\u003c/code\u003e 方法将数字拆分为单独的数字（作为字符）。 \u003ccode\u003emap\u003c/code\u003e 方法将每个数字转换为阶乘（再次使用化简运算符 \u003ccode\u003e[*]\u003c/code\u003e，就像我们昨天所做的那样）。\u003c/p\u003e\n\u003cp\u003e最后，最外层的 \u003ccode\u003e[+]\u003c/code\u003e 将所有 grepped 的数字相加，并将结果传递给 \u003ccode\u003esay\u003c/code\u003e 例程。\u003c/p\u003e\n\u003cp\u003e虽然主要想法是展示一个单行，但在实际操作中，在使用它们之前准备因子是更明智的：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e@f\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e..\u003c/span\u003e\u003cspan class=\"mi\"\u003e9\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e({[\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e..\u003c/span\u003e\u003cspan class=\"nv\"\u003e$_\u003c/span\u003e\u003cspan class=\"p\"\u003e});\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003esay\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e..\u003c/span\u003e\u003cspan class=\"mi\"\u003e50_000\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003egrep\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"nv\"\u003e$_\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecomb\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"nv\"\u003e@f\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"nv\"\u003e$_\u003c/span\u003e\u003cspan class=\"p\"\u003e]})});\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这就是今天故事的结局。这个日历的其余部分还有更多内容！\u003c/p\u003e\n","text":"欢迎来到 Raku One-Liner Advent Calendar 的第11天！ 今天，日历文章完全致力于解决欧拉计划的问题34。 如果你想在看到我的答案之前找到自己的答案，请再次暂停阅读。\n因此，任务是找到所有数字的总和，它们等于其数字的阶乘的总和。 听起来很清楚？ 🙂 你可以看一下单行程序的解决方案，以便更好地理解它。\nsay [+] (3..50_000).grep({$_ == [+] .comb.map({[*] 2..$_})}) 让我们从\u0026hellip;\u0026hellip;开始吧。\n我们循环范围 3 .. 50_000。上边界是基于某些要考虑因素的猜测。我不会在这里解释，但如果你好奇，你可能会试着找到答案。基本上，在某些时候你会理解这个数字要么包含太多数字，要么本身就太大了。请参阅有关 Project Euler 的讨论以获得纯理论的解释。\n第二步是 grep。我们正在搜索与总和相等的数字（$_ ==）。它是通过第二个化简加号 [+] 计算出来的，但你可以使用 sum 方法代替：\n{$_ == .comb.map({[*] 2..$_}).sum} 请注意 .comb 是一个在默认变量 $_ 上调用的方法。 comb 方法将数字拆分为单独的数字（作为字符）。 map 方法将每个数字转换为阶乘（再次使用化简运算符 [*]，就像我们昨天所做的那样）。\n最后，最外层的 [+] 将所有 grepped 的数字相加，并将结果传递给 say 例程。\n虽然主要想法是展示一个单行，但在实际操作中，在使用它们之前准备因子是更明智的：\nmy @f = (0..9).map({[*] 1..$_}); say [+] (3..50_000).grep({$_ == [+] .comb.map({@f[$_]})}); 这就是今天故事的结局。这个日历的其余部分还有更多内容！\n"},"name":"🎄 11/25. 在 Raku 中解决34号问题","published":"2018-12-11T09:16:06Z","summary":"欢迎来到 Raku One-Liner Advent Calendar 的第11天！ 今天，日历文章完全致力于解决欧拉计划的问题34。 如果你想在看到我的答案之前找到自己的答案，请再次暂停阅读。\n因此，任务是找到所有数字的总和，它们等于其数字的阶乘的总和。 听起来很清楚？ 🙂 你可以看一下单行程序的解决方案，以便更好地理解它。\nsay [+] (3..50_000).grep({$_ == [+] .comb.map({[*] 2..$_})}) 让我们从\u0026hellip;\u0026hellip;开始吧。\n我们循环范围 3 .. 50_000。上边界是基于某些要考虑因素的猜测。我不会在这里解释，但如果你好奇，你可能会试着找到答案。基本上，在某些时候你会理解这个数字要么包含太多数字，要么本身就太大了。请参阅有关 Project Euler 的讨论以获得纯理论的解释。\n第二步是 grep。我们正在搜索与总和相等的数字（$_ ==）。它是通过第二个化简加号 [+] 计算出来的，但你可以使用 sum 方法代替：\n{$_ == .comb.map({[*] 2..$_}).sum} 请注意 .comb 是一个在默认变量 $_ 上调用的方法。 comb 方法将数字拆分为单独的数字（作为字符）。 map 方法将每个数字转换为阶乘（再次使用化简运算符 [*]，就像我们昨天所做的那样）。\n最后，最外层的 [+] 将所有 grepped 的数字相加，并将结果传递给 say 例程。\n虽然主要想法是展示一个单行，但在实际操作中，在使用它们之前准备因子是更明智的：\nmy @f = (0..9).map({[*] 1..$_}); say [+] (3..50_000).grep({$_ == [+] .comb.map({@f[$_]})}); 这就是今天故事的结局。这个日历的其余部分还有更多内容！","type":"entry","url":"https://ohmycloud.github.io/notes/solving-the-problem-34-in-raku/"}