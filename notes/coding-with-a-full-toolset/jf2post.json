{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io/"},"content":{"html":"\u003cp\u003e几年前，我在 Raku 中创建了一个关于 \u0026ldquo;transparadigm 编程\u0026quot;的\u003ca href=\"http://damian.conway.org/Seminars/RakuTransparadigm.html\"\u003e演讲\u003c/a\u003e（以及后来的\u003ca href=\"http://damian.conway.org/Courses/RakuTransparadigm.html\"\u003e整个课程\u003c/a\u003e）。\u003c/p\u003e\n\u003cp\u003e基本的前提是，当一些语言限制你只能使用一个单一的锤子（或者更糟的是：一个装满锤子的盒子）时，Raku 被设计成一个完整的工具箱：整合了 OO、函数式、并发、声明式和过程式工具，使你能够为每个工作选择正确的组合。\u003c/p\u003e\n\u003cp\u003e最近，这个想法又在我脑海中全面浮现。在\u003ca href=\"https://perlweeklychallenge.org/blog/perl-weekly-challenge-012/\"\u003e上周的每周挑战\u003c/a\u003e中，第二个任务是把文件路径列表，找到最长的共同初始子路径（即它们都共享的最深的目录）。\u003c/p\u003e\n\u003cp\u003e各个注册参与者提供的\u003ca href=\"https://perlweeklychallenge.org/blog/recap-challenge-012/\"\u003e解决方案\u003c/a\u003e都非常简洁，而且通常既高效又优雅。然而他们中的大多数都是同一个程序解决方案的变体。在目录分隔符上拆分每条路径，然后对于1到N： 比较所有第N个组件，如果它们不一样就退出。类似于:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e@components\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nv\"\u003e@list\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003esplit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e/\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;)};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e..*\u003c/span\u003e \u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$n\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003enext\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nb\"\u003eall\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e@components\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eelems\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"o\"\u003e[~~]\u003c/span\u003e \u003cspan class=\"nv\"\u003e@components\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003evalues\u003c/span\u003e\u003cspan class=\"o\"\u003e».[\u003c/span\u003e\u003cspan class=\"nv\"\u003e$n\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e@components\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003efirst\u003c/span\u003e\u003cspan class=\"o\"\u003e.[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e..\u003c/span\u003e\u003cspan class=\"nv\"\u003e$n-1\u003c/span\u003e\u003cspan class=\"o\"\u003e].\u003c/span\u003e\u003cspan class=\"nb\"\u003ejoin\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e/\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003elast\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e并不是说这种方法有什么不好。\u003c/p\u003e\n\u003cp\u003e只是感觉比实际需要的\u0026quot;体力劳动\u0026quot;多了很多；很多低级的程序化的\u0026quot;告诉我怎么做\u0026rdquo;，而不是高级的声明性或功能性的\u0026quot;告诉我做什么\u0026quot;。\u003c/p\u003e\n\u003cp\u003e当我自己来解决这个问题的时候，我是这样想的。\u003c/p\u003e\n\u003cp\u003e我的搜索空间是所有可能的初始子路径的所有路径。在这个空间内，我需要找到所有路径共享的最长的初始子路径。换句话说，我需要将每条路径转换成一组越来越长的子路径，然后找到这些集合的交集，再找到该交集中最长的元素。它可以直接翻译成 Raku，比如这样:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e@list\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"k\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"na\"\u003eex\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e^.*\u003c/span\u003e\\\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"p\"\u003e}»\u003c/span\u003e\u003cspan class=\"ni\"\u003e.\u003c/span\u003e\u003cspan class=\"sr\"\u003eStr}\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ereduce\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"nv\"\u003e$^a\u003c/span\u003e\u003cspan class=\"o\"\u003e∩\u003c/span\u003e\u003cspan class=\"nv\"\u003e$^b\u003c/span\u003e\u003cspan class=\"p\"\u003e})\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ekeys\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003emax\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*.\u003c/span\u003e\u003cspan class=\"nb\"\u003echars\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e或（对于喜欢注释的人）喜欢这样:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e@list\u003c/span\u003e\\                             \u003cspan class=\"c1\"\u003e# In the list...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"k\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"na\"\u003eex\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e^\u003c/span\u003e \u003cspan class=\"o\"\u003e.*\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e/\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;}\\\u003c/span\u003e\u003cspan class=\"sr\"\u003e           \u003c/span\u003e\u003cspan class=\"c1\"\u003e# Find all initial subpaths\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"sr\"\u003e      \u003c/span\u003e\u003cspan class=\"o\"\u003e»\u003c/span\u003e\u003cspan class=\"ni\"\u003e.\u003c/span\u003e\u003cspan class=\"sr\"\u003eStr}\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\\                     \u003cspan class=\"c1\"\u003e# ...as lists of strings\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ereduce\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"nv\"\u003e$^a\u003c/span\u003e \u003cspan class=\"o\"\u003e∩\u003c/span\u003e \u003cspan class=\"nv\"\u003e$^b\u003c/span\u003e\u003cspan class=\"p\"\u003e})\u003c/span\u003e\\     \u003cspan class=\"c1\"\u003e# Then find all shared subpaths\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e             \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ekeys\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003emax\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*.\u003c/span\u003e\u003cspan class=\"nb\"\u003echars\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\\   \u003cspan class=\"c1\"\u003e# Then find the longest \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e              \u003cspan class=\"c1\"\u003e# Then print it\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我们从路径列表开始，通过 \u003ccode\u003e.map\u003c/code\u003e 操作对每个路径进行转换。\u003c/p\u003e\n\u003cp\u003e映射中的 \u003ccode\u003em:ex{^ .* '/'}\u003c/code\u003e 是一个详尽的匹配操作。它不是只匹配以斜线结尾的最长字符序列，而是匹配以斜线结尾的所有可能的字符序列。换句话说，它匹配每一个可能的越来越长的初始子路径，并将它们全部返回\u0026hellip;作为一个匹配对象列表。\u003c/p\u003e\n\u003cp\u003e在详尽匹配后后面的 \u003ccode\u003e».Str\u003c/code\u003e 将每个这样的 \u003ccode\u003eMatch\u003c/code\u003e 对象转换为一个简单的字符串，这样周围的 \u003ccode\u003e.map\u003c/code\u003e 操作就会产生一个字符串列表，代表所有可能的初始子路径。\u003c/p\u003e\n\u003cp\u003e然后，我们需要将这些列表中的每一个都视为一个集合，并找到它们所有的交集（即它们都共享的子路径）。因此，我们需要在每个列表之间注入一个集交运算符（\u003ccode\u003e∩\u003c/code\u003e），这正是 \u003ccode\u003e.reduce({$^a ∩ $^b})\u003c/code\u003e 所做的事情。\u003c/p\u003e\n\u003cp\u003e这个操作的结果是一个单一的集合，包含所有原始路径共享的所有初始子路径，其中每个子路径是集合的一个键。所以调用 \u003ccode\u003e.keys\u003c/code\u003e 可以得到所有子路径的列表，我们可以通过求其中字符数最大的子路径来找到最长的子路径：\u003ccode\u003e.max(*.chars)\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e然后我们只要打印出那个最大的子路径（\u003ccode\u003e.say\u003c/code\u003e），就可以了。\u003c/p\u003e\n\u003cp\u003e对我来说，尽管这个版本比程序化的方法短得多，但也更容易理解。它严格地从左到右阅读，只需一行代码。而且在每一步的过程中，它只是描述了下一步想要的转换，让 Raku 来做艰苦的工作。它很直接\u0026hellip;因为它可以为整个任务中的每一步准确地使用正确的工具（OO、函数式或声明式）。而且它很短\u0026hellip;因为所有这些工具都已经直接内置于核心语言中。\u003c/p\u003e\n\u003cp\u003e所以这也是我喜欢 Raku 的另一点。\u0026ldquo;所有正确的工具，唾手可得。\u0026rdquo;\u003c/p\u003e\n\u003cp\u003eDamian\u003c/p\u003e\n\u003cp\u003e(而且，是的，我很清楚，我可以把我的版本至少缩短30%，就像这样:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ekeys\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e[∩]\u003c/span\u003e \u003cspan class=\"nv\"\u003e@list\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e~\u003c/span\u003e\u003cspan class=\"p\"\u003e«\u003c/span\u003e\u003cspan class=\"s2\"\u003em:ex\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e^.*\u003c/span\u003e\\\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"s2\"\u003e}).max(*.chars).say\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e问题是，这也让它至少难懂了30%！;-)\u003c/p\u003e\n\u003cp\u003eby \u003ca href=\"http://blogs.perl.org/users/damian_conway/2019/06/coding-with-a-full-toolset.html\"\u003eDemian\u003c/a\u003e\u003c/p\u003e\n","text":"几年前，我在 Raku 中创建了一个关于 \u0026ldquo;transparadigm 编程\u0026quot;的演讲（以及后来的整个课程）。\n基本的前提是，当一些语言限制你只能使用一个单一的锤子（或者更糟的是：一个装满锤子的盒子）时，Raku 被设计成一个完整的工具箱：整合了 OO、函数式、并发、声明式和过程式工具，使你能够为每个工作选择正确的组合。\n最近，这个想法又在我脑海中全面浮现。在上周的每周挑战中，第二个任务是把文件路径列表，找到最长的共同初始子路径（即它们都共享的最深的目录）。\n各个注册参与者提供的解决方案都非常简洁，而且通常既高效又优雅。然而他们中的大多数都是同一个程序解决方案的变体。在目录分隔符上拆分每条路径，然后对于1到N： 比较所有第N个组件，如果它们不一样就退出。类似于:\nmy @components = @list.map({.split(\u0026#39;/\u0026#39;)}; for 1..* -\u0026gt; $n { next if all(@components).elems \u0026gt; $n \u0026amp;\u0026amp; [~~] @components.values».[$n]; say @components.first.[0..$n-1].join(\u0026#39;/\u0026#39;); last; } 并不是说这种方法有什么不好。\n只是感觉比实际需要的\u0026quot;体力劳动\u0026quot;多了很多；很多低级的程序化的\u0026quot;告诉我怎么做\u0026rdquo;，而不是高级的声明性或功能性的\u0026quot;告诉我做什么\u0026quot;。\n当我自己来解决这个问题的时候，我是这样想的。\n我的搜索空间是所有可能的初始子路径的所有路径。在这个空间内，我需要找到所有路径共享的最长的初始子路径。换句话说，我需要将每条路径转换成一组越来越长的子路径，然后找到这些集合的交集，再找到该交集中最长的元素。它可以直接翻译成 Raku，比如这样:\n@list.map({m:ex{^.*\\/}».Str}).reduce({$^a∩$^b}).keys.max(*.chars).say; 或（对于喜欢注释的人）喜欢这样:\n@list\\ # In the list... .map({m:ex{^ .* \u0026#39;/\u0026#39;}\\ # Find all initial subpaths ».Str})\\ # ...as lists of strings .reduce({$^a ∩ $^b})\\ # Then find all shared subpaths .keys.max(*.chars)\\ # Then find the longest .say; # Then print it 我们从路径列表开始，通过 .map 操作对每个路径进行转换。\n映射中的 m:ex{^ .* '/'} 是一个详尽的匹配操作。它不是只匹配以斜线结尾的最长字符序列，而是匹配以斜线结尾的所有可能的字符序列。换句话说，它匹配每一个可能的越来越长的初始子路径，并将它们全部返回\u0026hellip;作为一个匹配对象列表。\n在详尽匹配后后面的 ».Str 将每个这样的 Match 对象转换为一个简单的字符串，这样周围的 .map 操作就会产生一个字符串列表，代表所有可能的初始子路径。\n然后，我们需要将这些列表中的每一个都视为一个集合，并找到它们所有的交集（即它们都共享的子路径）。因此，我们需要在每个列表之间注入一个集交运算符（∩），这正是 .reduce({$^a ∩ $^b}) 所做的事情。\n这个操作的结果是一个单一的集合，包含所有原始路径共享的所有初始子路径，其中每个子路径是集合的一个键。所以调用 .keys 可以得到所有子路径的列表，我们可以通过求其中字符数最大的子路径来找到最长的子路径：.max(*.chars)。\n然后我们只要打印出那个最大的子路径（.say），就可以了。\n对我来说，尽管这个版本比程序化的方法短得多，但也更容易理解。它严格地从左到右阅读，只需一行代码。而且在每一步的过程中，它只是描述了下一步想要的转换，让 Raku 来做艰苦的工作。它很直接\u0026hellip;因为它可以为整个任务中的每一步准确地使用正确的工具（OO、函数式或声明式）。而且它很短\u0026hellip;因为所有这些工具都已经直接内置于核心语言中。\n所以这也是我喜欢 Raku 的另一点。\u0026ldquo;所有正确的工具，唾手可得。\u0026rdquo;\nDamian\n(而且，是的，我很清楚，我可以把我的版本至少缩短30%，就像这样:\nkeys([∩] @list.map:{~«m:ex{^.*\\/}}).max(*.chars).say 问题是，这也让它至少难懂了30%！;-)\nby Demian\n"},"name":"编程之全套工具","published":"2020-07-03T22:22:59Z","summary":"几年前，我在 Raku 中创建了一个关于 \u0026ldquo;transparadigm 编程\u0026quot;的演讲（以及后来的整个课程）。\n基本的前提是，当一些语言限制你只能使用一个单一的锤子（或者更糟的是：一个装满锤子的盒子）时，Raku 被设计成一个完整的工具箱：整合了 OO、函数式、并发、声明式和过程式工具，使你能够为每个工作选择正确的组合。\n最近，这个想法又在我脑海中全面浮现。在上周的每周挑战中，第二个任务是把文件路径列表，找到最长的共同初始子路径（即它们都共享的最深的目录）。\n各个注册参与者提供的解决方案都非常简洁，而且通常既高效又优雅。然而他们中的大多数都是同一个程序解决方案的变体。在目录分隔符上拆分每条路径，然后对于1到N： 比较所有第N个组件，如果它们不一样就退出。类似于:\nmy @components = @list.map({.split(\u0026#39;/\u0026#39;)}; for 1..* -\u0026gt; $n { next if all(@components).elems \u0026gt; $n \u0026amp;\u0026amp; [~~] @components.values».[$n]; say @components.first.[0..$n-1].join(\u0026#39;/\u0026#39;); last; } 并不是说这种方法有什么不好。\n只是感觉比实际需要的\u0026quot;体力劳动\u0026quot;多了很多；很多低级的程序化的\u0026quot;告诉我怎么做\u0026rdquo;，而不是高级的声明性或功能性的\u0026quot;告诉我做什么\u0026quot;。\n当我自己来解决这个问题的时候，我是这样想的。\n我的搜索空间是所有可能的初始子路径的所有路径。在这个空间内，我需要找到所有路径共享的最长的初始子路径。换句话说，我需要将每条路径转换成一组越来越长的子路径，然后找到这些集合的交集，再找到该交集中最长的元素。它可以直接翻译成 Raku，比如这样:\n@list.map({m:ex{^.*\\/}».Str}).reduce({$^a∩$^b}).keys.max(*.chars).say; 或（对于喜欢注释的人）喜欢这样:\n@list\\ # In the list... .map({m:ex{^ .* \u0026#39;/\u0026#39;}\\ # Find all initial subpaths ».Str})\\ # ...as lists of strings .reduce({$^a ∩ $^b})\\ # Then find all shared subpaths .keys.max(*.chars)\\ # Then find the longest .","type":"entry","url":"https://ohmyweekly.github.io/notes/coding-with-a-full-toolset/"}