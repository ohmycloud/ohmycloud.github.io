{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"content":{"html":"\u003cp\u003eFlinkCEP 是在 Flink 之上实现的复杂事件处理（CEP）库。它允许你在无尽的事件流中检测事件模式, 让你有机会掌握数据中的重要内容。\u003c/p\u003e\n\u003cp\u003e本页介绍了 Flink CEP 中可用的 API 调用。我们首先介绍 \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/libs/cep.html#the-pattern-api\"\u003ePattern API\u003c/a\u003e, 它允许你指定你想在你的流中检测的模式, 然后介绍你如何\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/libs/cep.html#detecting-patterns\"\u003e检测并对匹配的事件序列采取行动\u003c/a\u003e。然后, 我们将介绍 CEP 库在\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/libs/cep.html#handling-lateness-in-event-time\"\u003e处理事件时间的延迟\u003c/a\u003e时做出的假设, 以及如何将你的工作从旧版 Flink \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/libs/cep.html#migrating-from-an-older-flink-versionpre-13\"\u003e迁移\u003c/a\u003e到 Flink-1.3。\u003c/p\u003e\n\u003ch1 id=\"入门\"\u003e入门\u003c/h1\u003e\n\u003cp\u003e如果你想直接进入, \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/project-configuration.html\"\u003e设置一个 Flink 程序\u003c/a\u003e, 并将 FlinkCEP 依赖关系添加到项目的 pom.xml 中。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003edependency\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003egroupId\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eorg\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eapache\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eflink\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"n\"\u003egroupId\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eartifactId\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eflink\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003ecep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003escala_2\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"mi\"\u003e11\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"n\"\u003eartifactId\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eversion\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"mf\"\u003e1.12\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"n\"\u003eversion\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"o\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"n\"\u003edependency\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e信息：FlinkCEP 不是二进制发行版的一部分。请在\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/project-configuration.html\"\u003e这里\u003c/a\u003e查看如何与它链接进行集群执行。\u003c/p\u003e\n\u003cp\u003e现在你可以开始使用模式 API 编写你的第一个 CEP 程序了。\u003c/p\u003e\n\u003cp\u003e注意: 你想应用模式匹配的 DataStream 中的事件必须实现适当的 \u003ccode\u003eequals()\u003c/code\u003e 和 \u003ccode\u003ehashCode()\u003c/code\u003e 方法, 因为 FlinkCEP 使用它们来比较和匹配事件。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataStream\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003epattern\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetId\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003esubtype\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eclassOf\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eSubEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetVolume\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"mf\"\u003e10.0\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;end\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetName\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;end\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003epatternStream\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eCEP\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataStream\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eAlert\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epatternStream\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprocess\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003ePatternProcessFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e, \u003cspan class=\"kt\"\u003eAlert\u003c/span\u003e\u003cspan class=\"o\"\u003e]()\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eoverride\u003c/span\u003e \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003eprocessMatch\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n              \u003cspan class=\"n\"\u003e`match`\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eutil.Map\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eutil.List\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]],\u003c/span\u003e\n              \u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003ePatternProcessFunction.Context\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n              \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eCollector\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eAlert\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eUnit\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecollect\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecreateAlertFrom\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n        \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e})\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"pattern-api\"\u003ePattern API\u003c/h1\u003e\n\u003cp\u003e模式 API 允许你定义你想从输入流中提取的复杂模式序列。\u003c/p\u003e\n\u003cp\u003e每个复杂模式序列由多个简单模式组成, 即寻找具有相同属性的单个事件的模式。从现在开始, 我们将把这些简单模式称为模式, 而最终我们要在流中寻找的复杂模式序列, 就是模式序列。你可以把模式序列看成是这样的模式图, 根据用户指定的条件, 从一个模式过渡到下一个模式, 例如 event.getName().equals(\u0026ldquo;end\u0026rdquo;)。一个匹配是一个输入事件的序列, 它通过有效的模式转换序列, 访问复杂模式图的所有模式。\u003c/p\u003e\n\u003cp\u003e注意: 每个模式必须有一个唯一的名称, 你以后用它来识别匹配事件。\u003c/p\u003e\n\u003cp\u003e注意: 模式名称不能包含字符 \u0026ldquo;:\u0026quot;。\u003c/p\u003e\n\u003cp\u003e在本节的其余部分, 我们将首先介绍如何定义 \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/libs/cep.html#individual-patterns\"\u003e单个模式\u003c/a\u003e, 然后介绍如何将单个模式组合成 \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/libs/cep.html#combining-patterns\"\u003e复杂模式\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"单个模式\"\u003e单个模式\u003c/h2\u003e\n\u003cp\u003e模式可以是单个模式, 也可以是循环模式。单元模式只接受一个事件, 而循环模式可以接受多个事件。在模式匹配符号中, 模式 \u0026ldquo;a b+ c?d\u0026rdquo;(或 \u0026ldquo;a\u0026rdquo;, 后面跟着一个或多个 \u0026ldquo;b\u0026rdquo;, 可选地跟着一个 \u0026ldquo;c\u0026rdquo;, 后面跟着一个 \u0026ldquo;d\u0026rdquo;), a、c? 和 d 是单个模式, 而 b+ 是循环模式。默认情况下, 模式是一个单个模式, 你可以通过使用量词将其转换为一个循环模式。每个模式可以有一个或多个条件, 基于这些条件, 它可以接受事件。\u003c/p\u003e\n\u003ch3 id=\"量词\"\u003e量词\u003c/h3\u003e\n\u003cp\u003e在 FlinkCEP 中, 你可以使用这些方法来指定循环模式：pattern.oneOrMore(), 用于期望给定事件出现一次或多次的模式(例如前面提到的 b+)；以及 pattern.times(#ofTimes), 用于期望给定事件出现的特定次数的模式, 例如 4 个 a；以及 pattern.times(#fromTimes, #toTimes), 用于期望给定事件的特定最小出现次数和最大出现次数的模式, 例如 2-4 个 a。\u003c/p\u003e\n\u003cp\u003e你可以使用 pattern.greedy() 方法使循环模式变得贪婪, 但你还不能使分组模式变得贪婪。你可以使用 pattern.option() 方法使所有模式, 不管是否循环, 都是可选的。\u003c/p\u003e\n\u003cp\u003e对于名为 start 的模式, 以下是有效的量词。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"c1\"\u003e// expecting 4 occurrences\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etimes\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// expecting 0 or 4 occurrences\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etimes\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eoptional\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// expecting 2, 3 or 4 occurrences\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etimes\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// expecting 2, 3 or 4 occurrences and repeating as many as possible\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etimes\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003egreedy\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// expecting 0, 2, 3 or 4 occurrences\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etimes\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eoptional\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// expecting 0, 2, 3 or 4 occurrences and repeating as many as possible\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etimes\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eoptional\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003egreedy\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// expecting 1 or more occurrences\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eoneOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// expecting 1 or more occurrences and repeating as many as possible\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eoneOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003egreedy\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// expecting 0 or more occurrences\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eoneOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eoptional\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// expecting 0 or more occurrences and repeating as many as possible\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eoneOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eoptional\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003egreedy\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// expecting 2 or more occurrences\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etimesOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// expecting 2 or more occurrences and repeating as many as possible\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etimesOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003egreedy\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// expecting 0, 2 or more occurrences\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etimesOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eoptional\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// expecting 0, 2 or more occurrences and repeating as many as possible\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etimesOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eoptional\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003egreedy\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e条件\u003c/p\u003e\n\u003cp\u003e对于每个模式, 你可以指定一个条件, 传入的事件必须满足这个条件才能被\u0026quot;接受\u0026quot;到模式中, 例如, 它的值应该大于 5, 或者大于之前接受的事件的平均值。你可以通过 pattern.where()、pattern.or() 或 pattern.until() 方法来指定事件属性的条件。这些条件可以是 IterativeConditions 或 SimpleConditions。\u003c/p\u003e\n\u003cp\u003e迭代条件。这是最通用的条件类型。你可以通过这种方式指定一个条件, 该条件基于之前接受的事件的属性或其中一个子集的统计量来接受后续事件。\u003c/p\u003e\n\u003cp\u003e下面是一个迭代条件的代码, 如果一个名为 \u0026ldquo;middle\u0026rdquo; 的模式的名称以 \u0026ldquo;foo\u0026rdquo; 开头, 并且如果该模式之前接受的事件的价格加上当前事件的价格之和不超过 5.0 的值, 则接受该模式的下一个事件。迭代条件可以发挥强大的作用, 尤其是与循环模式相结合, 例如 oneOrMore()。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003emiddle\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eoneOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esubtype\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eclassOf\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eSubEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n        \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"k\"\u003elazy\u003c/span\u003e \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003esum\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetEventsForPattern\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetPrice\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003esum\u003c/span\u003e\n            \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetName\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003estartsWith\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;foo\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003esum\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetPrice\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"mf\"\u003e5.0\u003c/span\u003e\n        \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e注意：调用 ctx.getEventsForPattern(\u0026hellip;) 可以为给定的潜在匹配找到所有之前接受的事件。这个操作的成本可能会有所不同, 所以在实现你的条件时, 尽量减少它的使用。\u003c/p\u003e\n\u003cp\u003e描述的上下文使人们也可以访问事件的时间特征。更多信息请看时间上下文。\u003c/p\u003e\n\u003cp\u003e简单条件。这种类型的条件扩展了前面提到的 IterativeCondition 类, 仅根据事件本身的属性来决定是否接受一个事件。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eevent\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eevent\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetName\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003estartsWith\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;foo\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e最后, 你还可以通过 pattern.subtype(subClass) 方法将接受的事件类型限制为初始事件类型的一个子类型（这里是 Event）。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esubtype\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eclassOf\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eSubEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esubEvent\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* some condition */\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e组合条件。如上所示, 你可以将子类型条件与其他条件结合起来。这对每个条件都适用。你可以通过依次调用 where() 来任意组合条件。最后的结果将是各个条件的结果的逻辑 AND。要使用 OR 组合条件, 可以使用 or() 方法, 如下所示。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eevent\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* some condition */\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eor\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eevent\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* or condition */\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e停止条件\u003c/strong\u003e：如果是循环模式(oneOrMore() 和 oneOrMore().option()), 你也可以指定一个停止条件, 例如, 接受值大于 5 的事件, 直到值的总和小于 50。\u003c/p\u003e\n\u003cp\u003e为了更好地理解它, 请看下面的例子。给定：\u003c/p\u003e\n\u003cp\u003e像 \u0026ldquo;(a+ until b)\u0026rdquo; (一个或多个 \u0026ldquo;a\u0026rdquo; 直到 \u0026ldquo;b\u0026rdquo;) 这样的模式\u003c/p\u003e\n\u003cp\u003e输入事件的序列 \u0026ldquo;a1\u0026rdquo; \u0026ldquo;c\u0026rdquo; \u0026ldquo;a2\u0026rdquo; \u0026ldquo;b\u0026rdquo; \u0026ldquo;a3\u0026rdquo;\u003c/p\u003e\n\u003cp\u003e该库将输出结果: {a1 a2} {a1} {a2} {a3}.\u003c/p\u003e\n\u003cp\u003e正如你所看到的 {a1 a2 a3} 或 {a2 a3} 由于停止条件没有返回。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ewhere(条件) - 定义当前模式的条件。要匹配模式, 一个事件必须满足条件。多个连续的 where() 子句会导致其条件被 AND 化。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eevent\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* some condition */\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eor(条件) - 添加一个新的条件, 该条件与现有的条件相匹配。一个事件只有在通过至少一个条件的情况下才能与模式匹配。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eevent\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* some condition */\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n       \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eor\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eevent\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* alternative condition */\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003euntil(条件) - 指定循环模式的停止条件。意思是如果发生了与给定条件相匹配的事件, 则不会再接受更多的事件进入模式。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e仅与 oneOrMore() 结合使用。\u003c/p\u003e\n\u003cp\u003e注意：它允许在事件条件下对相应的模式进行清洗状态。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eoneOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003euntil\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eevent\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* some condition */\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003esubtype(subClass)\t- 为当前模式定义一个子类型条件。只有当一个事件属于这个子类型时, 它才能与模式相匹配。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esubtype\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eclassOf\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eSubEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eoneOrMore() - 指定该模式期望匹配事件至少出现一次。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e默认情况下, 使用的是放宽的内部连续（在后续事件之间）。关于内部连续性的更多信息, 请参见 \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/libs/cep.html#consecutive_scala\"\u003econsecutive\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e注意：建议使用 until() 或 within() 来启用状态清除。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eoneOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003etimesOrMore(#times) - 指定该模式期望一个匹配事件至少出现 #times 次。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e默认情况下, 使用的是放宽的内部连续（在后续事件之间）。关于内部相邻性的更多信息, 请参见 \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/libs/cep.html#consecutive_scala\"\u003econsecutive\u003c/a\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etimesOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003etimes(#ofTimes) - 指定该模式期望匹配事件的准确出现次数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e默认情况下, 使用的是放宽的内部连续性（在后续事件之间）。关于内部相邻性的更多信息, 请参见 \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/libs/cep.html#consecutive_scala\"\u003econsecutive\u003c/a\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etimes\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003etimes(#fromTimes, #toTimes) - 指定该模式期望匹配事件的 #fromTimes 和 #toTimes 之间出现。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e默认情况下, 使用的是放宽的内部连续性（在后续事件之间）。关于内部相邻性的更多信息, 请参见 \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/libs/cep.html#consecutive_scala\"\u003econsecutive\u003c/a\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etimes\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eoptional() - 指定该模式是可选的, 即它可能根本不会出现。这适用于上述所有量词。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eoneOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eoptional\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003egreedy() - 指定该模式是贪婪的, 即会尽可能多的重复。这只适用于量词, 目前不支持组模式。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eoneOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003egreedy\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"组合模式\"\u003e组合模式\u003c/h3\u003e\n\u003cp\u003e现在你已经看到了单个模式的样子, 现在是时候看看如何将它们组合成一个完整的模式序列了。\u003c/p\u003e\n\u003cp\u003e一个模式序列必须从一个初始模式开始, 如下所示。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e \u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e, \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e下一步, 你可以通过指定它们之间所需的毗连条件, 将更多的模式附加到你的模式序列中。FlinkCEP 支持以下形式的事件之间的相邻性。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e严格相邻\u003c/strong\u003e: 希望所有匹配的事件严格地一个接一个出现, 中间没有任何非匹配的事件。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRelaxed Contiguity\u003c/strong\u003e: 忽略匹配事件之间出现的非匹配事件。\u003c/li\u003e\n\u003cli\u003e非决定性的松弛相邻性（Non-Deterministic Relaxed Contiguity）。进一步放宽相邻性, 允许忽略一些匹配事件的额外匹配。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e要在连续模式之间应用它们, 你可以使用:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003enext(), 用于严格相邻,\u003c/li\u003e\n\u003cli\u003efollowedBy(), 用于松散相邻, 和\u003c/li\u003e\n\u003cli\u003efollowedByAny(), 用于非确定性的松散相邻。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e或\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003enotNext(), 如果你不希望一个事件类型直接跟随另一个事件类型\u003c/li\u003e\n\u003cli\u003enotFollowedBy(), 如果你不想让一个事件类型位于两个其他事件类型之间的任何地方。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e注意：模式序列不能以 notFollowedBy() 结束。\u003c/p\u003e\n\u003cp\u003e注意： NOT 模式不能在前面加上一个可选模式。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"c1\"\u003e// strict contiguity\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003estrict\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e, \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// relaxed contiguity\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003erelaxed\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e, \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// non-deterministic relaxed contiguity\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003enonDetermin\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e, \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedByAny\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// NOT pattern with strict contiguity\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003estrictNot\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e, \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enotNext\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;not\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// NOT pattern with relaxed contiguity\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003erelaxedNot\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e, \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enotFollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;not\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e松散毗连意味着只有第一个后续的匹配事件才会被匹配, 而对于非确定性的松散毗连, 同一开头会发出多个匹配。举个例子, 一个模式 \u0026ldquo;a b\u0026rdquo;, 给定事件序列 \u0026ldquo;a\u0026rdquo;, \u0026ldquo;c\u0026rdquo;, \u0026ldquo;b1\u0026rdquo;, \u0026ldquo;b2\u0026rdquo;, 将得到以下结果。\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;a\u0026rdquo; 和 \u0026ldquo;b\u0026rdquo; 之间有严格的毗连性。{} (不匹配), \u0026ldquo;a\u0026rdquo; 后面的 \u0026ldquo;c\u0026rdquo; 会导致 \u0026ldquo;a\u0026rdquo; 被丢弃。\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;a\u0026rdquo; 和 \u0026ldquo;b\u0026rdquo; 之间的松散相邻性。{a b1}, 因为松散连续性被看作是 \u0026ldquo;跳过非匹配事件, 直到下一个匹配事件\u0026rdquo;。\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;a\u0026rdquo; 和 \u0026ldquo;b\u0026rdquo; 之间的非确定性松散相邻性。{a b1}, {a b2}, 因为这是最一般的形式。\u003c/p\u003e\n\u003cp\u003e也可以定义一个时间约束, 让模式有效。例如, 你可以通过 pattern.within() 方法定义一个模式应该在 10 秒内发生。处理时间和事件时间都支持时间模式。\u003c/p\u003e\n\u003cp\u003e注意: 模式序列只能有一个时间约束。如果在不同的单个模式上定义了多个这样的约束, 那么就采用最小的约束。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewithin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eTime\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eseconds\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e循环模式中的相邻性\u003c/p\u003e\n\u003cp\u003e你可以在循环模式中应用与上一节讨论的相同的相邻性条件。相邻性将被应用在这样一个模式中的元素之间。为了举例说明, 模式序列 \u0026ldquo;a b+ c\u0026rdquo;（\u0026ldquo;a\u0026rdquo; 后面跟着一个或多个 \u0026ldquo;b\u0026rdquo; 的任意（非确定的松散的）序列, 后面跟着一个 \u0026ldquo;c\u0026rdquo;）, 输入 \u0026ldquo;a\u0026rdquo;、\u0026ldquo;b1\u0026rdquo;、\u0026ldquo;d1\u0026rdquo;、\u0026ldquo;b2\u0026rdquo;、\u0026ldquo;d2\u0026rdquo;、\u0026ldquo;b3\u0026rdquo;、\u0026ldquo;c\u0026rdquo;, 会有以下结果。\u003c/p\u003e\n\u003cp\u003e严格相邻性：{a b3 c} - \u0026ldquo;b1\u0026rdquo; 后面的 \u0026ldquo;d1\u0026rdquo; 会导致 \u0026ldquo;b1\u0026rdquo; 被丢弃, \u0026ldquo;b2\u0026rdquo; 也会因为 \u0026ldquo;d2\u0026rdquo; 而被丢弃。\u003c/p\u003e\n\u003cp\u003e放宽相邻性：{a b1 c}, {a b1 b2 c}, {a b1 b2 b3 c}, {a b2 c}, {a b2 b3 c}, {a b3 c} - \u0026ldquo;d\u0026rdquo; 被忽略。\u003c/p\u003e\n\u003cp\u003e非确定性的松弛相邻性：{a b1 c}, {a b1 b2 c}, {a b1 b3 c}, {a b1 b2 b3 c}, {a b2 c}, {a b2 b3 c}, {a b3 c} - 注意{a b1 b3 c}, 这是 \u0026ldquo;b\u0026rdquo; 之间松弛相邻性的结果。\u003c/p\u003e\n\u003cp\u003e对于循环模式(例如 oneOrMore() 和 times()), 默认是放宽毗连性。如果你想要严格的相邻性, 你必须通过使用 continuous() 调用来明确指定, 如果你想要非确定性的松弛相邻性, 你可以使用 allowCombinations() 调用。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003econsecutive()\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e与 oneOrMore() 和 times() 一起使用, 并在匹配的事件之间施加严格的毗连性, 即任何不匹配的元素都会中断匹配（如 next()）。\u003c/p\u003e\n\u003cp\u003e如果不应用, 则使用宽松的连续性（如 followedBy()）。\u003c/p\u003e\n\u003cp\u003e例如, 像这样的模式。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetName\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eequals\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;c\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetName\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eequals\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;a\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n                       \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eoneOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003econsecutive\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;end1\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetName\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eequals\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;b\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e将为一个输入序列生成以下匹配。C D A1 A2 A3 D A4 B\u003c/p\u003e\n\u003cp\u003e与连续应用。{C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}。\u003c/p\u003e\n\u003cp\u003e不连续应用。{C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}, {C A1 A2 A3 A4 B}。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eallowCombinations()\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e与 oneOrMore()和 times()一起使用, 并在匹配的事件之间施加非确定性的松散相邻性（如 followedByAny()）。\u003c/p\u003e\n\u003cp\u003e如果不应用, 则使用松散的相邻性（如 followedBy()）。\u003c/p\u003e\n\u003cp\u003e例如, 像这样的模式。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetName\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eequals\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;c\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetName\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eequals\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;a\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n                       \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eoneOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eallowCombinations\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;end1\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetName\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eequals\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;b\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e将为一个输入序列生成以下匹配。C D A1 A2 A3 D A4 B\u003c/p\u003e\n\u003cp\u003e启用组合。{C A1 B}、{C A1 A2 B}、{C A1 A3 B}、{C A1 A4 B}、{C A1 A2 A3 B}、{C A1 A2 A4 B}、{C A1 A3 A4 B}、{C A1 A2 A3 A4 B}、{C A1 A2 A3 A4 B}。\u003c/p\u003e\n\u003cp\u003e不启用组合。{C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}, {C A1 A2 A3 A4 B}。\u003c/p\u003e\n\u003ch3 id=\"模式组\"\u003e模式组\u003c/h3\u003e\n\u003cp\u003e也可以定义一个模式序列作为 begin、followBy、followByAny 和 next 的条件。该模式序列将被视为逻辑上的匹配条件, 并将返回一个 GroupPattern, 并且可以对 GroupPattern 应用 oneOrMore()、times(#ofTimes)、times(#fromTimes、#toTimes)、optional()、continuous()、allowCombinations()。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e, \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...).\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;start_middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// strict contiguity\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003estrict\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e, \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;next_start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...).\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;next_middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003etimes\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// relaxed contiguity\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003erelaxed\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e, \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;followedby_start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...).\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;followedby_middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eoneOrMore\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// non-deterministic relaxed contiguity\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003enonDetermin\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e, \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedByAny\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;followedbyany_start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...).\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;followedbyany_middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eoptional\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003ebegin(#name) - 定义一个起始模式。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003ebegin(#pattern_sequence) - 定义一个起始模式。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...).\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003enext(#name) - 添加一个新的模式。一个匹配事件必须直接接替前一个匹配事件（严格相邻）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003enext\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003enext(#pattern_sequence) - 添加一个新的模式。一个匹配事件的序列必须直接接替前一个匹配事件（严格相邻）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003enext\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...).\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003efollowedBy(#name) - 添加一个新的模式。其他事件可以发生在一个匹配事件和上一个匹配事件之间（松散的相邻性）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003efollowedBy(#pattern_sequence)\t- 添加一个新的模式。其他事件可以发生在一系列匹配事件和前一个匹配事件之间（放松的相邻性）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...).\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003efollowedByAny(#name) - 添加一个新的模式。在一个匹配事件和上一个匹配事件之间可以发生其他事件, 并且对每一个备选匹配事件都会呈现备选匹配（非确定性的松散毗连性）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003efollowedByAny\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedByAny\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003efollowedByAny(#pattern_sequence) - 添加一个新的模式。在一个匹配事件序列和前一个匹配事件之间可以发生其他事件, 并且将为每一个可供选择的匹配事件序列呈现备选匹配（非确定性的松散毗连性）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003efollowedByAny\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedByAny\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...).\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003enotNext() - 添加一个新的否定模式。一个匹配（负值）事件必须直接接替前一个匹配事件（严格的相邻性）, 以使部分匹配被丢弃。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003enotNext\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enotNext\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;not\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003enotFollowedBy() - 添加一个新的负模式。即使在匹配（负值）事件和前一个匹配事件之间发生了其他事件, 部分匹配事件序列也会被丢弃（松散的相邻性）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003enotFollowedBy\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enotFollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;not\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ewithin(time) - 定义事件序列匹配模式的最大时间间隔。如果一个未完成的事件序列超过了这个时间, 它将被丢弃。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewithin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eTime\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eseconds\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"after-match-skip-strategy\"\u003eAfter Match Skip Strategy\u003c/h3\u003e\n\u003cp\u003e对于一个给定的模式, 同一个事件可能会被分配给多个成功的匹配。要控制一个事件将被分配到多少个匹配中, 你需要指定名为 AfterMatchSkipStrategy 的跳过策略。有五种类型的跳过策略, 如下所示。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNO_SKIP: 每一个可能的匹配都会被发出。\u003c/li\u003e\n\u003cli\u003eSKIP_TO_NEXT：丢弃每一个局部的匹配, 从相同的事件开始, 发射匹配开始。\u003c/li\u003e\n\u003cli\u003eSKIP_PAST_LAST_EVENT: 丢弃每一个在匹配开始后但结束前开始的部分匹配。\u003c/li\u003e\n\u003cli\u003eSKIP_TO_FIRST: 丢弃每个在匹配开始后但在 PatternName 的第一个事件发生之前开始的部分匹配。\u003c/li\u003e\n\u003cli\u003eSKIP_TO_LAST: 丢弃在匹配开始后但在 PatternName 的最后一个事件发生之前开始的每一个部分匹配。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e注意, 当使用 SKIP_TO_FIRST 和 SKIP_TO_LAST 跳过策略时, 还应该指定一个有效的 PatternName。\u003c/p\u003e\n\u003cp\u003e例如, 对于给定的模式 b+ c 和数据流 b1 b2 b3 c, 这四种跳过策略的区别如下。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003eSkip Strategy\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e结果\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e描述\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eNO_SKIP\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eb1 b2 b3 c \u003c!-- raw HTML omitted --\u003e b2 b3 c \u003c!-- raw HTML omitted --\u003e b3 c\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e找到匹配的 b1 b2 b3 c 后, 匹配过程不会丢弃任何结果。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eSKIP_TO_NEXT\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eb1 b2 b3 c \u003c!-- raw HTML omitted --\u003e b2 b3 c \u003c!-- raw HTML omitted --\u003e b3 c\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e找到匹配的 b1 b2 b3 c 后, 匹配过程不会丢弃任何结果, 因为没有其他匹配可以从 b1 开始。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eSKIP_PAST_LAST_EVENT\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eb1 b2 b3 c\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e在找到匹配的 b1 b2 b3 c 后, 匹配过程将放弃所有开始的部分匹配。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eSKIP_TO_FIRST[b]\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eb1 b2 b3 c \u003c!-- raw HTML omitted --\u003e b2 b3 c \u003c!-- raw HTML omitted --\u003e b3 c\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e找到匹配的 b1 b2 b3 c 后, 匹配过程会尝试丢弃所有在 b1 之前开始的部分匹配, 但没有这样的匹配。因此, 没有任何匹配结果会被丢弃。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eSKIP_TO_LAST[b]\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eb1 b2 b3 c \u003c!-- raw HTML omitted --\u003e b3 c\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e找到匹配的 b1 b2 b3 c 后, 匹配过程会尝试丢弃所有在 b3 之前开始的部分匹配。有一个这样的匹配 b2 b3 c。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e还可以看看另一个例子, 以更好地了解 NO_SKIP 和 SKIP_TO_FIRST 的区别：模式: (a | b | c) (b | c) c+.greedy d 和序列: a b c1 c2 c3 d 那么结果将是:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003eSkip Strategy\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e结果\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e描述\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eNO_SKIP\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003ea b c1 c2 c3 d \u003c!-- raw HTML omitted --\u003e b c1 c2 c3 d \u003c!-- raw HTML omitted --\u003e c1 c2 c3 d\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e找到匹配的 a b c1 c2 c3 d 后, 匹配过程不会丢弃任何结果。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eSKIP_TO_FIRST[c*]\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003ea b c1 c2 c3 d \u003c!-- raw HTML omitted --\u003e c1 c2 c3 d\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e在找到匹配的 a b c1 c2 c3 d 后, 匹配过程将丢弃所有在 c1 之前开始的部分匹配, 有一个这样的匹配 b c1 c2 c3 d。有一个这样的匹配 b c1 c2 c3 d。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e为了更好地理解 NO_SKIP 和 SKIP_TO_NEXT 的区别, 请看下面的例子: Pattern: a b+ 和序列: a b1 b2 b3 那么结果将是:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003eSkip Strategy\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e结果\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e描述\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eNO_SKIP\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003ea b1 \u003c!-- raw HTML omitted --\u003e a b1 b2 \u003c!-- raw HTML omitted --\u003e a b1 b2 b3\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e找到匹配的 b1 后, 匹配过程不会丢弃任何结果。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eSKIP_TO_NEXT\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003ea b1\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e在找到匹配的 b1 后, 匹配过程将丢弃从 a 开始的所有部分匹配, 这意味着既不能生成 b1 b2, 也不能生成 b1 b2 b3。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e要指定使用哪种跳过策略, 只需调用 AfterMatchSkipStrategy 来创建一个 AfterMatchSkipStrategy。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e功能\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e描述\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eAfterMatchSkipStrategy.noSkip()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e创建一个 NO_SKIP 跳过策略\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eAfterMatchSkipStrategy.skipToNext()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e创建一个 SKIP_TO_NEXT 跳过策略。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eAfterMatchSkipStrategy.skipPastLastEvent()\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e创建一个 SKIP_PAST_LAST_EVENT 跳过策略。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eAfterMatchSkipStrategy.skipToFirst(patternName)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用引用的模式名 patternName 创建一个 SKIP_TO_FIRST 跳过策略。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eAfterMatchSkipStrategy.skipToLast(patternName)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用引用的模式名 patternName 创建一个 SKIP_TO_LAST 跳过策略。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e然后通过调用跳过策略来应用于模式。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eskipStrategy\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;patternName\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eskipStrategy\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e注意 对于 SKIP_TO_FIRST/LAST 有两个选项来处理没有元素映射到指定变量的情况。默认情况下, 将使用 NO_SKIP 策略。另一个选项是在这种情况下抛出异常。我们可以通过以下方式启用这个选项\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"nc\"\u003eAfterMatchSkipStrategy\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eskipToFirst\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epatternName\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ethrowExceptionOnMiss\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"检测模式\"\u003e检测模式\u003c/h2\u003e\n\u003cp\u003e在指定了你要寻找的模式序列后, 现在是时候将其应用到你的输入流中以检测潜在的匹配。要针对你的模式序列运行事件流, 你必须创建一个 PatternStream。给定一个输入流输入、一个模式模式和一个可选的比较器比较器, 用于在 EventTime 的情况下对具有相同时间戳的事件或在同一时刻到达的事件进行排序, 你可以通过调用创建 PatternStream。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e \u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataStream\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003epattern\u003c/span\u003e \u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e, \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003cspan class=\"k\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ecomparator\u003c/span\u003e \u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eEventComparator\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"c1\"\u003e// optional\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003epatternStream\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003ePatternStream\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eCEP\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ecomparator\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e输入流可以是 keyed 的, 也可以是 non-keyed 的, 这取决于你的使用情况。\u003c/p\u003e\n\u003cp\u003e注意: 在 non-keyed 流上应用模式将导致作业的并行度等于 1。\u003c/p\u003e\n\u003ch3 id=\"从模式中选择\"\u003e从模式中选择\u003c/h3\u003e\n\u003cp\u003e一旦你获得了一个 PatternStream, 你就可以对检测到的事件序列进行转换。建议的方法是通过 PatternProcessFunction 来实现。\u003c/p\u003e\n\u003cp\u003ePatternProcessFunction 有一个 processMatch 方法, 它对每个匹配的事件序列都会被调用。它以 \u003ccode\u003eMap\u0026lt;String, List\u0026lt;IN\u0026gt;\u0026gt;\u003c/code\u003e 的形式接收匹配, 其中键是你的模式序列中每个模式的名称, 值是该模式的所有接受事件的列表（IN 是你的输入元素的类型）。给定模式的事件是按时间戳排序的。返回每个模式所接受的事件列表的原因是, 当使用循环模式(例如 oneToMany() 和 times())时, 一个给定模式可能会接受多个事件。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMyPatternProcessFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eIN\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eOUT\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003eextends\u003c/span\u003e \u003cspan class=\"nc\"\u003ePatternProcessFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eIN\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eOUT\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nd\"\u003e@Override\u003c/span\u003e\n    \u003cspan class=\"n\"\u003epublic\u003c/span\u003e \u003cspan class=\"n\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eprocessMatch\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eMap\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eList\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eIN\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003ematch\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eContext\u003c/span\u003e \u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eCollector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eOUT\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003ethrows\u003c/span\u003e \u003cspan class=\"nc\"\u003eException\u003c/span\u003e\u003cspan class=\"o\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"nc\"\u003eIN\u003c/span\u003e \u003cspan class=\"n\"\u003estartEvent\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003ematch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eget\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eget\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"nc\"\u003eIN\u003c/span\u003e \u003cspan class=\"n\"\u003eendEvent\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003ematch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eget\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;end\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eget\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecollect\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eOUT\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estartEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eendEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e));\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ePatternProcessFunction 提供了对 Context 对象的访问。通过它, 我们可以访问与时间相关的特性, 如当前处理时间或当前匹配的时间戳（这是分配给匹配的最后一个元素的时间戳）。更多信息请看\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/libs/cep.html#time-context\"\u003e时间上下文\u003c/a\u003e。通过这个上下文, 我们还可以将结果发送到一个\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/stream/side_output.html\"\u003e侧输出\u003c/a\u003e。\u003c/p\u003e\n\u003ch3 id=\"处理超时的部分模式\"\u003e处理超时的部分模式\u003c/h3\u003e\n\u003cp\u003e当一个模式通过 within 关键字附加了一个窗口长度时, 部分事件序列有可能因为超过窗口长度而被丢弃。要对一个超时的部分匹配采取行动, 可以使用 TimedOutPartialMatchHandler 接口。该接口应该以混搭的方式使用。这意味着你可以在你的 PatternProcessFunction 中额外实现这个接口。TimedOutPartialMatchHandler 提供了额外的 processTimedOutMatch 方法, 该方法将为每个超时部分匹配调用。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMyPatternProcessFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eIN\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eOUT\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003eextends\u003c/span\u003e \u003cspan class=\"nc\"\u003ePatternProcessFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eIN\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eOUT\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eimplements\u003c/span\u003e \u003cspan class=\"nc\"\u003eTimedOutPartialMatchHandler\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eIN\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nd\"\u003e@Override\u003c/span\u003e\n    \u003cspan class=\"n\"\u003epublic\u003c/span\u003e \u003cspan class=\"n\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eprocessMatch\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eMap\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eList\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eIN\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003ematch\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eContext\u003c/span\u003e \u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eCollector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eOUT\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003ethrows\u003c/span\u003e \u003cspan class=\"nc\"\u003eException\u003c/span\u003e\u003cspan class=\"o\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"nd\"\u003e@Override\u003c/span\u003e\n    \u003cspan class=\"n\"\u003epublic\u003c/span\u003e \u003cspan class=\"n\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eprocessTimedOutMatch\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eMap\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eList\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eIN\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003ematch\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eContext\u003c/span\u003e \u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003ethrows\u003c/span\u003e \u003cspan class=\"nc\"\u003eException\u003c/span\u003e\u003cspan class=\"o\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"nc\"\u003eIN\u003c/span\u003e \u003cspan class=\"n\"\u003estartEvent\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003ematch\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eget\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eget\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eoutput\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eoutputTag\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eT\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estartEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e));\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e注意: processTimedOutMatch 不给人访问主输出的机会。但你仍然可以通过 Context 对象, 通过\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/stream/side_output.html\"\u003e侧输出\u003c/a\u003e来发出结果。\u003c/p\u003e\n\u003ch4 id=\"方便的-api\"\u003e方便的 API\u003c/h4\u003e\n\u003cp\u003e前面提到的 PatternProcessFunction 是在 Flink 1.8 中引入的, 从那时起, 它就是推荐的与匹配交互的方式。人们仍然可以使用老式的 API, 比如 select/flatSelect, 内部会被翻译成 PatternProcessFunction。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003epatternStream\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003ePatternStream\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eCEP\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eoutputTag\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eOutputTag\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;side-output\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eSingleOutputStreamOperator\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eComplexEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epatternStream\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eflatSelect\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eoutputTag\u003c/span\u003e\u003cspan class=\"o\"\u003e){\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eMap\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eIterable\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]],\u003c/span\u003e \u003cspan class=\"n\"\u003etimestamp\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eCollector\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eTimeoutEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecollect\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eTimeoutEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e())\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003emutable.Map\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eIterable\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]],\u003c/span\u003e \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eCollector\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eComplexEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecollect\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eComplexEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e())\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003etimeoutResult\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataStream\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eTimeoutEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetSideOutput\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eoutputTag\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"在-cep-库中的时间\"\u003e在 CEP 库中的时间\u003c/h2\u003e\n\u003ch3 id=\"处理事件时间的延迟\"\u003e处理事件时间的延迟\u003c/h3\u003e\n\u003cp\u003e在 CEP 中, 处理元素的顺序很重要。为了保证元素在事件时间工作时以正确的顺序进行处理, 一个传入的元素最初会被放在一个缓冲区中, 在这个缓冲区中, 元素根据其时间戳按升序排序, 当一个水印到达时, 这个缓冲区中所有时间戳小于水印的元素都会被处理。这意味着水印之间的元素是按事件时间顺序处理的。\u003c/p\u003e\n\u003cp\u003e注意: 当在事件时间内工作时, 该库假定水印的正确性。\u003c/p\u003e\n\u003cp\u003e为了保证水印之间的元素按事件时间顺序处理, Flink 的 CEP 库假设水印的正确性, 并将时间戳小于最后看到的水印的元素视为迟到元素。迟到的元素不会被进一步处理。另外, 你可以指定一个 sideOutput 标签来收集最后一次看到的水印之后的迟到元素, 你可以这样使用。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003epatternStream\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003ePatternStream\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eCEP\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003elateDataOutputTag\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eOutputTag\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;late-data\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eSingleOutputStreamOperator\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eComplexEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epatternStream\u003c/span\u003e\n      \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esideOutputLateData\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elateDataOutputTag\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n      \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eselect\u003c/span\u003e\u003cspan class=\"o\"\u003e{\u003c/span\u003e\n          \u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eMap\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eIterable\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eComplexEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"nc\"\u003eComplexEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n      \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003elateData\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataStream\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetSideOutput\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elateDataOutputTag\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"时间上下文\"\u003e时间上下文\u003c/h3\u003e\n\u003cp\u003e在 \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/libs/cep.html#selecting-from-patterns\"\u003ePatternProcessFunction\u003c/a\u003e 以及 \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/libs/cep.html#conditions\"\u003eIterativeCondition\u003c/a\u003e 中, 用户可以访问一个实现 TimeContext 的上下文, 如下所示。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"cm\"\u003e/**\n\u003c/span\u003e\u003cspan class=\"cm\"\u003e * Enables access to time related characteristics such as current processing time or timestamp of\n\u003c/span\u003e\u003cspan class=\"cm\"\u003e * currently processed element. Used in {@link PatternProcessFunction} and\n\u003c/span\u003e\u003cspan class=\"cm\"\u003e * {@link org.apache.flink.cep.pattern.conditions.IterativeCondition}\n\u003c/span\u003e\u003cspan class=\"cm\"\u003e */\u003c/span\u003e\n\u003cspan class=\"nd\"\u003e@PublicEvolving\u003c/span\u003e\n\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kd\"\u003einterface\u003c/span\u003e \u003cspan class=\"nc\"\u003eTimeContext\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\n\t\u003cspan class=\"cm\"\u003e/**\n\u003c/span\u003e\u003cspan class=\"cm\"\u003e\t * Timestamp of the element currently being processed.\n\u003c/span\u003e\u003cspan class=\"cm\"\u003e\t *\n\u003c/span\u003e\u003cspan class=\"cm\"\u003e\t * \u0026lt;p\u0026gt;In case of {@link org.apache.flink.streaming.api.TimeCharacteristic#ProcessingTime} this\n\u003c/span\u003e\u003cspan class=\"cm\"\u003e\t * will be set to the time when event entered the cep operator.\n\u003c/span\u003e\u003cspan class=\"cm\"\u003e\t */\u003c/span\u003e\n\t\u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"nf\"\u003etimestamp\u003c/span\u003e\u003cspan class=\"o\"\u003e();\u003c/span\u003e\n\n\t\u003cspan class=\"cm\"\u003e/** Returns the current processing time. */\u003c/span\u003e\n\t\u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"nf\"\u003ecurrentProcessingTime\u003c/span\u003e\u003cspan class=\"o\"\u003e();\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个上下文让用户可以访问处理事件的时间特征（在 IterativeCondition 的情况下是传入记录, 在 PatternProcessFunction 的情况下是匹配）。调用 TimeContext#currentProcessingTime 总是给你当前处理时间的值, 这个调用应该比调用 System.currentTimeMillis()更可取。\u003c/p\u003e\n\u003cp\u003e在 TimeContext#timestamp() 的情况下, 返回的值等于 EventTime 中分配的时间戳。在 ProcessingTime 中, 这将等于所述事件进入 cep 运算符的时间点(或者在 PatternProcessFunction 的情况下生成匹配时)。这意味着该值将在对该方法的多次调用中保持一致。\u003c/p\u003e\n\u003ch2 id=\"例子\"\u003e例子\u003c/h2\u003e\n\u003cp\u003e下面的例子是在事件的键控数据流上检测模式 start, middle(name = \u0026ldquo;error\u0026rdquo;) -\u0026gt; end(name = \u0026ldquo;critical\u0026rdquo;)。这些事件通过其 id 进行 keyed, 一个有效的模式必须在 10 秒内出现。整个处理过程是以事件时间来完成的。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e \u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eStreamExecutionEnvironment\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e \u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataStream\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003epartitionedInput\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ekeyBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eevent\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eevent\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetId\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003epattern\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003ePattern\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;start\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;middle\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetName\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;error\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efollowedBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;end\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetName\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;critical\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewithin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eTime\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eseconds\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003epatternStream\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eCEP\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epartitionedInput\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epattern\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ealerts\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epatternStream\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eselect\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecreateAlert\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"从旧版本13-前迁移到-14-以上版本\"\u003e从旧版本(1.3 前)迁移到 1.4 以上版本\u003c/h2\u003e\n\u003ch3 id=\"迁移到-14-版本\"\u003e迁移到 1.4+ 版本\u003c/h3\u003e\n\u003cp\u003e在 Flink-1.4 中, CEP 库与 \u0026lt;= Flink 1.2 的向后兼容性被取消。不幸的是, 无法恢复曾经在 1.2.x 下运行的 CEP 作业。\u003c/p\u003e\n\u003ch3 id=\"迁移到-13x\"\u003e迁移到 1.3.x\u003c/h3\u003e\n\u003cp\u003eFlink-1.3 中的 CEP 库有很多新的特性, 这导致了 API 的一些变化。在这里, 我们描述了为了能够在 Flink-1.3 中运行, 你需要对你的旧 CEP 作业进行的修改。在做了这些改变并重新编译你的作业后, 你将能够从旧版作业的保存点恢复执行, 也就是说, 不需要重新处理你过去的数据。\u003c/p\u003e\n\u003cp\u003e所需的更改是:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e改变你的条件（在 where(\u0026hellip;) 子句中的条件）来扩展 SimpleCondition 类, 而不是实现 FilterFunction 接口。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e改变你的函数作为参数提供给 select(\u0026hellip;) 和 flatSelect(\u0026hellip;) 方法, 以期望与每个模式相关联的事件列表(Java 中为 List, Scala 中为 Iterable)。这是因为增加了循环模式后, 多个输入事件可以匹配一个（循环）模式。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFlink 1.1 和 1.2 中的 followBy() 暗示了非确定性的松散毗连性（见\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/libs/cep.html#conditions-on-contiguity\"\u003e这里\u003c/a\u003e）。在 Flink 1.3 中, 这一点发生了变化, followBy() 意味着松散毗连, 而 followByAny() 应该在需要非确定性松散毗连的情况下使用。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n","text":"FlinkCEP 是在 Flink 之上实现的复杂事件处理（CEP）库。它允许你在无尽的事件流中检测事件模式, 让你有机会掌握数据中的重要内容。\n本页介绍了 Flink CEP 中可用的 API 调用。我们首先介绍 Pattern API, 它允许你指定你想在你的流中检测的模式, 然后介绍你如何检测并对匹配的事件序列采取行动。然后, 我们将介绍 CEP 库在处理事件时间的延迟时做出的假设, 以及如何将你的工作从旧版 Flink 迁移到 Flink-1.3。\n入门 如果你想直接进入, 设置一个 Flink 程序, 并将 FlinkCEP 依赖关系添加到项目的 pom.xml 中。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.flink\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;flink-cep-scala_2.11\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.12.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 信息：FlinkCEP 不是二进制发行版的一部分。请在这里查看如何与它链接进行集群执行。\n现在你可以开始使用模式 API 编写你的第一个 CEP 程序了。\n注意: 你想应用模式匹配的 DataStream 中的事件必须实现适当的 equals() 和 hashCode() 方法, 因为 FlinkCEP 使用它们来比较和匹配事件。\nval input: DataStream[Event] = ... val pattern = Pattern.begin[Event](\u0026#34;start\u0026#34;).where(_.getId == 42) .next(\u0026#34;middle\u0026#34;).subtype(classOf[SubEvent]).where(_.getVolume \u0026gt;= 10.0) .followedBy(\u0026#34;end\u0026#34;).where(_.getName == \u0026#34;end\u0026#34;) val patternStream = CEP.pattern(input, pattern) val result: DataStream[Alert] = patternStream.process( new PatternProcessFunction[Event, Alert]() { override def processMatch( `match`: util.Map[String, util.List[Event]], ctx: PatternProcessFunction.Context, out: Collector[Alert]): Unit = { out.collect(createAlertFrom(pattern)) } }) Pattern API 模式 API 允许你定义你想从输入流中提取的复杂模式序列。\n每个复杂模式序列由多个简单模式组成, 即寻找具有相同属性的单个事件的模式。从现在开始, 我们将把这些简单模式称为模式, 而最终我们要在流中寻找的复杂模式序列, 就是模式序列。你可以把模式序列看成是这样的模式图, 根据用户指定的条件, 从一个模式过渡到下一个模式, 例如 event.getName().equals(\u0026ldquo;end\u0026rdquo;)。一个匹配是一个输入事件的序列, 它通过有效的模式转换序列, 访问复杂模式图的所有模式。\n注意: 每个模式必须有一个唯一的名称, 你以后用它来识别匹配事件。\n注意: 模式名称不能包含字符 \u0026ldquo;:\u0026quot;。\n在本节的其余部分, 我们将首先介绍如何定义 单个模式, 然后介绍如何将单个模式组合成 复杂模式。\n单个模式 模式可以是单个模式, 也可以是循环模式。单元模式只接受一个事件, 而循环模式可以接受多个事件。在模式匹配符号中, 模式 \u0026ldquo;a b+ c?d\u0026rdquo;(或 \u0026ldquo;a\u0026rdquo;, 后面跟着一个或多个 \u0026ldquo;b\u0026rdquo;, 可选地跟着一个 \u0026ldquo;c\u0026rdquo;, 后面跟着一个 \u0026ldquo;d\u0026rdquo;), a、c? 和 d 是单个模式, 而 b+ 是循环模式。默认情况下, 模式是一个单个模式, 你可以通过使用量词将其转换为一个循环模式。每个模式可以有一个或多个条件, 基于这些条件, 它可以接受事件。\n量词 在 FlinkCEP 中, 你可以使用这些方法来指定循环模式：pattern.oneOrMore(), 用于期望给定事件出现一次或多次的模式(例如前面提到的 b+)；以及 pattern.times(#ofTimes), 用于期望给定事件出现的特定次数的模式, 例如 4 个 a；以及 pattern.times(#fromTimes, #toTimes), 用于期望给定事件的特定最小出现次数和最大出现次数的模式, 例如 2-4 个 a。\n你可以使用 pattern.greedy() 方法使循环模式变得贪婪, 但你还不能使分组模式变得贪婪。你可以使用 pattern.option() 方法使所有模式, 不管是否循环, 都是可选的。\n对于名为 start 的模式, 以下是有效的量词。\n// expecting 4 occurrences start.times(4) // expecting 0 or 4 occurrences start.times(4).optional() // expecting 2, 3 or 4 occurrences start.times(2, 4) // expecting 2, 3 or 4 occurrences and repeating as many as possible start.times(2, 4).greedy() // expecting 0, 2, 3 or 4 occurrences start.times(2, 4).optional() // expecting 0, 2, 3 or 4 occurrences and repeating as many as possible start.times(2, 4).optional().greedy() // expecting 1 or more occurrences start.oneOrMore() // expecting 1 or more occurrences and repeating as many as possible start.oneOrMore().greedy() // expecting 0 or more occurrences start.oneOrMore().optional() // expecting 0 or more occurrences and repeating as many as possible start.oneOrMore().optional().greedy() // expecting 2 or more occurrences start.timesOrMore(2) // expecting 2 or more occurrences and repeating as many as possible start.timesOrMore(2).greedy() // expecting 0, 2 or more occurrences start.timesOrMore(2).optional() // expecting 0, 2 or more occurrences and repeating as many as possible start.timesOrMore(2).optional().greedy() 条件\n对于每个模式, 你可以指定一个条件, 传入的事件必须满足这个条件才能被\u0026quot;接受\u0026quot;到模式中, 例如, 它的值应该大于 5, 或者大于之前接受的事件的平均值。你可以通过 pattern.where()、pattern.or() 或 pattern.until() 方法来指定事件属性的条件。这些条件可以是 IterativeConditions 或 SimpleConditions。\n迭代条件。这是最通用的条件类型。你可以通过这种方式指定一个条件, 该条件基于之前接受的事件的属性或其中一个子集的统计量来接受后续事件。\n下面是一个迭代条件的代码, 如果一个名为 \u0026ldquo;middle\u0026rdquo; 的模式的名称以 \u0026ldquo;foo\u0026rdquo; 开头, 并且如果该模式之前接受的事件的价格加上当前事件的价格之和不超过 5.0 的值, 则接受该模式的下一个事件。迭代条件可以发挥强大的作用, 尤其是与循环模式相结合, 例如 oneOrMore()。\nmiddle.oneOrMore() .subtype(classOf[SubEvent]) .where( (value, ctx) =\u0026gt; { lazy val sum = ctx.getEventsForPattern(\u0026#34;middle\u0026#34;).map(_.getPrice).sum value.getName.startsWith(\u0026#34;foo\u0026#34;) \u0026amp;\u0026amp; sum + value.getPrice \u0026lt; 5.0 } ) 注意：调用 ctx.getEventsForPattern(\u0026hellip;) 可以为给定的潜在匹配找到所有之前接受的事件。这个操作的成本可能会有所不同, 所以在实现你的条件时, 尽量减少它的使用。\n描述的上下文使人们也可以访问事件的时间特征。更多信息请看时间上下文。\n简单条件。这种类型的条件扩展了前面提到的 IterativeCondition 类, 仅根据事件本身的属性来决定是否接受一个事件。\nstart.where(event =\u0026gt; event.getName.startsWith(\u0026#34;foo\u0026#34;)) 最后, 你还可以通过 pattern.subtype(subClass) 方法将接受的事件类型限制为初始事件类型的一个子类型（这里是 Event）。\nstart.subtype(classOf[SubEvent]).where(subEvent =\u0026gt; ... /* some condition */) 组合条件。如上所示, 你可以将子类型条件与其他条件结合起来。这对每个条件都适用。你可以通过依次调用 where() 来任意组合条件。最后的结果将是各个条件的结果的逻辑 AND。要使用 OR 组合条件, 可以使用 or() 方法, 如下所示。\npattern.where(event =\u0026gt; ... /* some condition */).or(event =\u0026gt; ... /* or condition */) 停止条件：如果是循环模式(oneOrMore() 和 oneOrMore().option()), 你也可以指定一个停止条件, 例如, 接受值大于 5 的事件, 直到值的总和小于 50。\n为了更好地理解它, 请看下面的例子。给定：\n像 \u0026ldquo;(a+ until b)\u0026rdquo; (一个或多个 \u0026ldquo;a\u0026rdquo; 直到 \u0026ldquo;b\u0026rdquo;) 这样的模式\n输入事件的序列 \u0026ldquo;a1\u0026rdquo; \u0026ldquo;c\u0026rdquo; \u0026ldquo;a2\u0026rdquo; \u0026ldquo;b\u0026rdquo; \u0026ldquo;a3\u0026rdquo;\n该库将输出结果: {a1 a2} {a1} {a2} {a3}.\n正如你所看到的 {a1 a2 a3} 或 {a2 a3} 由于停止条件没有返回。\n where(条件) - 定义当前模式的条件。要匹配模式, 一个事件必须满足条件。多个连续的 where() 子句会导致其条件被 AND 化。  pattern.where(event =\u0026gt; ... /* some condition */)  or(条件) - 添加一个新的条件, 该条件与现有的条件相匹配。一个事件只有在通过至少一个条件的情况下才能与模式匹配。  pattern.where(event =\u0026gt; ... /* some condition */) .or(event =\u0026gt; ... /* alternative condition */)  until(条件) - 指定循环模式的停止条件。意思是如果发生了与给定条件相匹配的事件, 则不会再接受更多的事件进入模式。  仅与 oneOrMore() 结合使用。\n注意：它允许在事件条件下对相应的模式进行清洗状态。\npattern.oneOrMore().until(event =\u0026gt; ... /* some condition */)  subtype(subClass)\t- 为当前模式定义一个子类型条件。只有当一个事件属于这个子类型时, 它才能与模式相匹配。  pattern.subtype(classOf[SubEvent])  oneOrMore() - 指定该模式期望匹配事件至少出现一次。  默认情况下, 使用的是放宽的内部连续（在后续事件之间）。关于内部连续性的更多信息, 请参见 consecutive。\n注意：建议使用 until() 或 within() 来启用状态清除。\npattern.oneOrMore()  timesOrMore(#times) - 指定该模式期望一个匹配事件至少出现 #times 次。  默认情况下, 使用的是放宽的内部连续（在后续事件之间）。关于内部相邻性的更多信息, 请参见 consecutive。\npattern.timesOrMore(2)  times(#ofTimes) - 指定该模式期望匹配事件的准确出现次数。  默认情况下, 使用的是放宽的内部连续性（在后续事件之间）。关于内部相邻性的更多信息, 请参见 consecutive。\npattern.times(2)  times(#fromTimes, #toTimes) - 指定该模式期望匹配事件的 #fromTimes 和 #toTimes 之间出现。  默认情况下, 使用的是放宽的内部连续性（在后续事件之间）。关于内部相邻性的更多信息, 请参见 consecutive。\npattern.times(2, 4)  optional() - 指定该模式是可选的, 即它可能根本不会出现。这适用于上述所有量词。  pattern.oneOrMore().optional()  greedy() - 指定该模式是贪婪的, 即会尽可能多的重复。这只适用于量词, 目前不支持组模式。  pattern.oneOrMore().greedy() 组合模式 现在你已经看到了单个模式的样子, 现在是时候看看如何将它们组合成一个完整的模式序列了。\n一个模式序列必须从一个初始模式开始, 如下所示。\nval start : Pattern[Event, _] = Pattern.begin(\u0026#34;start\u0026#34;) 下一步, 你可以通过指定它们之间所需的毗连条件, 将更多的模式附加到你的模式序列中。FlinkCEP 支持以下形式的事件之间的相邻性。\n 严格相邻: 希望所有匹配的事件严格地一个接一个出现, 中间没有任何非匹配的事件。 Relaxed Contiguity: 忽略匹配事件之间出现的非匹配事件。 非决定性的松弛相邻性（Non-Deterministic Relaxed Contiguity）。进一步放宽相邻性, 允许忽略一些匹配事件的额外匹配。  要在连续模式之间应用它们, 你可以使用:\n next(), 用于严格相邻, followedBy(), 用于松散相邻, 和 followedByAny(), 用于非确定性的松散相邻。  或\n notNext(), 如果你不希望一个事件类型直接跟随另一个事件类型 notFollowedBy(), 如果你不想让一个事件类型位于两个其他事件类型之间的任何地方。  注意：模式序列不能以 notFollowedBy() 结束。\n注意： NOT 模式不能在前面加上一个可选模式。\n// strict contiguity val strict: Pattern[Event, _] = start.next(\u0026#34;middle\u0026#34;).where(...) // relaxed contiguity val relaxed: Pattern[Event, _] = start.followedBy(\u0026#34;middle\u0026#34;).where(...) // non-deterministic relaxed contiguity val nonDetermin: Pattern[Event, _] = start.followedByAny(\u0026#34;middle\u0026#34;).where(...) // NOT pattern with strict contiguity val strictNot: Pattern[Event, _] = start.notNext(\u0026#34;not\u0026#34;).where(...) // NOT pattern with relaxed contiguity val relaxedNot: Pattern[Event, _] = start.notFollowedBy(\u0026#34;not\u0026#34;).where(...) 松散毗连意味着只有第一个后续的匹配事件才会被匹配, 而对于非确定性的松散毗连, 同一开头会发出多个匹配。举个例子, 一个模式 \u0026ldquo;a b\u0026rdquo;, 给定事件序列 \u0026ldquo;a\u0026rdquo;, \u0026ldquo;c\u0026rdquo;, \u0026ldquo;b1\u0026rdquo;, \u0026ldquo;b2\u0026rdquo;, 将得到以下结果。\n\u0026ldquo;a\u0026rdquo; 和 \u0026ldquo;b\u0026rdquo; 之间有严格的毗连性。{} (不匹配), \u0026ldquo;a\u0026rdquo; 后面的 \u0026ldquo;c\u0026rdquo; 会导致 \u0026ldquo;a\u0026rdquo; 被丢弃。\n\u0026ldquo;a\u0026rdquo; 和 \u0026ldquo;b\u0026rdquo; 之间的松散相邻性。{a b1}, 因为松散连续性被看作是 \u0026ldquo;跳过非匹配事件, 直到下一个匹配事件\u0026rdquo;。\n\u0026ldquo;a\u0026rdquo; 和 \u0026ldquo;b\u0026rdquo; 之间的非确定性松散相邻性。{a b1}, {a b2}, 因为这是最一般的形式。\n也可以定义一个时间约束, 让模式有效。例如, 你可以通过 pattern.within() 方法定义一个模式应该在 10 秒内发生。处理时间和事件时间都支持时间模式。\n注意: 模式序列只能有一个时间约束。如果在不同的单个模式上定义了多个这样的约束, 那么就采用最小的约束。\nnext.within(Time.seconds(10)) 循环模式中的相邻性\n你可以在循环模式中应用与上一节讨论的相同的相邻性条件。相邻性将被应用在这样一个模式中的元素之间。为了举例说明, 模式序列 \u0026ldquo;a b+ c\u0026rdquo;（\u0026ldquo;a\u0026rdquo; 后面跟着一个或多个 \u0026ldquo;b\u0026rdquo; 的任意（非确定的松散的）序列, 后面跟着一个 \u0026ldquo;c\u0026rdquo;）, 输入 \u0026ldquo;a\u0026rdquo;、\u0026ldquo;b1\u0026rdquo;、\u0026ldquo;d1\u0026rdquo;、\u0026ldquo;b2\u0026rdquo;、\u0026ldquo;d2\u0026rdquo;、\u0026ldquo;b3\u0026rdquo;、\u0026ldquo;c\u0026rdquo;, 会有以下结果。\n严格相邻性：{a b3 c} - \u0026ldquo;b1\u0026rdquo; 后面的 \u0026ldquo;d1\u0026rdquo; 会导致 \u0026ldquo;b1\u0026rdquo; 被丢弃, \u0026ldquo;b2\u0026rdquo; 也会因为 \u0026ldquo;d2\u0026rdquo; 而被丢弃。\n放宽相邻性：{a b1 c}, {a b1 b2 c}, {a b1 b2 b3 c}, {a b2 c}, {a b2 b3 c}, {a b3 c} - \u0026ldquo;d\u0026rdquo; 被忽略。\n非确定性的松弛相邻性：{a b1 c}, {a b1 b2 c}, {a b1 b3 c}, {a b1 b2 b3 c}, {a b2 c}, {a b2 b3 c}, {a b3 c} - 注意{a b1 b3 c}, 这是 \u0026ldquo;b\u0026rdquo; 之间松弛相邻性的结果。\n对于循环模式(例如 oneOrMore() 和 times()), 默认是放宽毗连性。如果你想要严格的相邻性, 你必须通过使用 continuous() 调用来明确指定, 如果你想要非确定性的松弛相邻性, 你可以使用 allowCombinations() 调用。\n consecutive()  与 oneOrMore() 和 times() 一起使用, 并在匹配的事件之间施加严格的毗连性, 即任何不匹配的元素都会中断匹配（如 next()）。\n如果不应用, 则使用宽松的连续性（如 followedBy()）。\n例如, 像这样的模式。\nPattern.begin(\u0026#34;start\u0026#34;).where(_.getName().equals(\u0026#34;c\u0026#34;)) .followedBy(\u0026#34;middle\u0026#34;).where(_.getName().equals(\u0026#34;a\u0026#34;)) .oneOrMore().consecutive() .followedBy(\u0026#34;end1\u0026#34;).where(_.getName().equals(\u0026#34;b\u0026#34;)) 将为一个输入序列生成以下匹配。C D A1 A2 A3 D A4 B\n与连续应用。{C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}。\n不连续应用。{C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}, {C A1 A2 A3 A4 B}。\n allowCombinations()  与 oneOrMore()和 times()一起使用, 并在匹配的事件之间施加非确定性的松散相邻性（如 followedByAny()）。\n如果不应用, 则使用松散的相邻性（如 followedBy()）。\n例如, 像这样的模式。\nPattern.begin(\u0026#34;start\u0026#34;).where(_.getName().equals(\u0026#34;c\u0026#34;)) .followedBy(\u0026#34;middle\u0026#34;).where(_.getName().equals(\u0026#34;a\u0026#34;)) .oneOrMore().allowCombinations() .followedBy(\u0026#34;end1\u0026#34;).where(_.getName().equals(\u0026#34;b\u0026#34;)) 将为一个输入序列生成以下匹配。C D A1 A2 A3 D A4 B\n启用组合。{C A1 B}、{C A1 A2 B}、{C A1 A3 B}、{C A1 A4 B}、{C A1 A2 A3 B}、{C A1 A2 A4 B}、{C A1 A3 A4 B}、{C A1 A2 A3 A4 B}、{C A1 A2 A3 A4 B}。\n不启用组合。{C A1 B}, {C A1 A2 B}, {C A1 A2 A3 B}, {C A1 A2 A3 A4 B}。\n模式组 也可以定义一个模式序列作为 begin、followBy、followByAny 和 next 的条件。该模式序列将被视为逻辑上的匹配条件, 并将返回一个 GroupPattern, 并且可以对 GroupPattern 应用 oneOrMore()、times(#ofTimes)、times(#fromTimes、#toTimes)、optional()、continuous()、allowCombinations()。\nval start: Pattern[Event, _] = Pattern.begin( Pattern.begin[Event](\u0026#34;start\u0026#34;).where(...).followedBy(\u0026#34;start_middle\u0026#34;).where(...) ) // strict contiguity val strict: Pattern[Event, _] = start.next( Pattern.begin[Event](\u0026#34;next_start\u0026#34;).where(...).followedBy(\u0026#34;next_middle\u0026#34;).where(...) ).times(3) // relaxed contiguity val relaxed: Pattern[Event, _] = start.followedBy( Pattern.begin[Event](\u0026#34;followedby_start\u0026#34;).where(...).followedBy(\u0026#34;followedby_middle\u0026#34;).where(...) ).oneOrMore() // non-deterministic relaxed contiguity val nonDetermin: Pattern[Event, _] = start.followedByAny( Pattern.begin[Event](\u0026#34;followedbyany_start\u0026#34;).where(...).followedBy(\u0026#34;followedbyany_middle\u0026#34;).where(...) ).optional()  begin(#name) - 定义一个起始模式。  val start = Pattern.begin[Event](\u0026#34;start\u0026#34;)  begin(#pattern_sequence) - 定义一个起始模式。  val start = Pattern.begin( Pattern.begin[Event](\u0026#34;start\u0026#34;).where(...).followedBy(\u0026#34;middle\u0026#34;).where(...) )  next(#name) - 添加一个新的模式。一个匹配事件必须直接接替前一个匹配事件（严格相邻）。  val next = start.next(\u0026#34;middle\u0026#34;)  next(#pattern_sequence) - 添加一个新的模式。一个匹配事件的序列必须直接接替前一个匹配事件（严格相邻）。  val next = start.next( Pattern.begin[Event](\u0026#34;start\u0026#34;).where(...).followedBy(\u0026#34;middle\u0026#34;).where(...) )  followedBy(#name) - 添加一个新的模式。其他事件可以发生在一个匹配事件和上一个匹配事件之间（松散的相邻性）。  val followedBy = start.followedBy(\u0026#34;middle\u0026#34;)  followedBy(#pattern_sequence)\t- 添加一个新的模式。其他事件可以发生在一系列匹配事件和前一个匹配事件之间（放松的相邻性）。  val followedBy = start.followedBy( Pattern.begin[Event](\u0026#34;start\u0026#34;).where(...).followedBy(\u0026#34;middle\u0026#34;).where(...) )  followedByAny(#name) - 添加一个新的模式。在一个匹配事件和上一个匹配事件之间可以发生其他事件, 并且对每一个备选匹配事件都会呈现备选匹配（非确定性的松散毗连性）。  val followedByAny = start.followedByAny(\u0026#34;middle\u0026#34;)  followedByAny(#pattern_sequence) - 添加一个新的模式。在一个匹配事件序列和前一个匹配事件之间可以发生其他事件, 并且将为每一个可供选择的匹配事件序列呈现备选匹配（非确定性的松散毗连性）。  val followedByAny = start.followedByAny( Pattern.begin[Event](\u0026#34;start\u0026#34;).where(...).followedBy(\u0026#34;middle\u0026#34;).where(...) ) notNext() - 添加一个新的否定模式。一个匹配（负值）事件必须直接接替前一个匹配事件（严格的相邻性）, 以使部分匹配被丢弃。\nval notNext = start.notNext(\u0026#34;not\u0026#34;)  notFollowedBy() - 添加一个新的负模式。即使在匹配（负值）事件和前一个匹配事件之间发生了其他事件, 部分匹配事件序列也会被丢弃（松散的相邻性）。  val notFollowedBy = start.notFollowedBy(\u0026#34;not\u0026#34;) within(time) - 定义事件序列匹配模式的最大时间间隔。如果一个未完成的事件序列超过了这个时间, 它将被丢弃。\npattern.within(Time.seconds(10)) After Match Skip Strategy 对于一个给定的模式, 同一个事件可能会被分配给多个成功的匹配。要控制一个事件将被分配到多少个匹配中, 你需要指定名为 AfterMatchSkipStrategy 的跳过策略。有五种类型的跳过策略, 如下所示。\n NO_SKIP: 每一个可能的匹配都会被发出。 SKIP_TO_NEXT：丢弃每一个局部的匹配, 从相同的事件开始, 发射匹配开始。 SKIP_PAST_LAST_EVENT: 丢弃每一个在匹配开始后但结束前开始的部分匹配。 SKIP_TO_FIRST: 丢弃每个在匹配开始后但在 PatternName 的第一个事件发生之前开始的部分匹配。 SKIP_TO_LAST: 丢弃在匹配开始后但在 PatternName 的最后一个事件发生之前开始的每一个部分匹配。  注意, 当使用 SKIP_TO_FIRST 和 SKIP_TO_LAST 跳过策略时, 还应该指定一个有效的 PatternName。\n例如, 对于给定的模式 b+ c 和数据流 b1 b2 b3 c, 这四种跳过策略的区别如下。\n   Skip Strategy 结果 描述     NO_SKIP b1 b2 b3 c b2 b3 c b3 c 找到匹配的 b1 b2 b3 c 后, 匹配过程不会丢弃任何结果。   SKIP_TO_NEXT b1 b2 b3 c b2 b3 c b3 c 找到匹配的 b1 b2 b3 c 后, 匹配过程不会丢弃任何结果, 因为没有其他匹配可以从 b1 开始。   SKIP_PAST_LAST_EVENT b1 b2 b3 c 在找到匹配的 b1 b2 b3 c 后, 匹配过程将放弃所有开始的部分匹配。   SKIP_TO_FIRST[b] b1 b2 b3 c b2 b3 c b3 c 找到匹配的 b1 b2 b3 c 后, 匹配过程会尝试丢弃所有在 b1 之前开始的部分匹配, 但没有这样的匹配。因此, 没有任何匹配结果会被丢弃。   SKIP_TO_LAST[b] b1 b2 b3 c b3 c 找到匹配的 b1 b2 b3 c 后, 匹配过程会尝试丢弃所有在 b3 之前开始的部分匹配。有一个这样的匹配 b2 b3 c。    还可以看看另一个例子, 以更好地了解 NO_SKIP 和 SKIP_TO_FIRST 的区别：模式: (a | b | c) (b | c) c+.greedy d 和序列: a b c1 c2 c3 d 那么结果将是:\n   Skip Strategy 结果 描述     NO_SKIP a b c1 c2 c3 d b c1 c2 c3 d c1 c2 c3 d 找到匹配的 a b c1 c2 c3 d 后, 匹配过程不会丢弃任何结果。   SKIP_TO_FIRST[c*] a b c1 c2 c3 d c1 c2 c3 d 在找到匹配的 a b c1 c2 c3 d 后, 匹配过程将丢弃所有在 c1 之前开始的部分匹配, 有一个这样的匹配 b c1 c2 c3 d。有一个这样的匹配 b c1 c2 c3 d。    为了更好地理解 NO_SKIP 和 SKIP_TO_NEXT 的区别, 请看下面的例子: Pattern: a b+ 和序列: a b1 b2 b3 那么结果将是:\n   Skip Strategy 结果 描述     NO_SKIP a b1 a b1 b2 a b1 b2 b3 找到匹配的 b1 后, 匹配过程不会丢弃任何结果。   SKIP_TO_NEXT a b1 在找到匹配的 b1 后, 匹配过程将丢弃从 a 开始的所有部分匹配, 这意味着既不能生成 b1 b2, 也不能生成 b1 b2 b3。    要指定使用哪种跳过策略, 只需调用 AfterMatchSkipStrategy 来创建一个 AfterMatchSkipStrategy。\n   功能 描述     AfterMatchSkipStrategy.noSkip() 创建一个 NO_SKIP 跳过策略   AfterMatchSkipStrategy.skipToNext() 创建一个 SKIP_TO_NEXT 跳过策略。   AfterMatchSkipStrategy.skipPastLastEvent() 创建一个 SKIP_PAST_LAST_EVENT 跳过策略。   AfterMatchSkipStrategy.skipToFirst(patternName) 用引用的模式名 patternName 创建一个 SKIP_TO_FIRST 跳过策略。   AfterMatchSkipStrategy.skipToLast(patternName) 用引用的模式名 patternName 创建一个 SKIP_TO_LAST 跳过策略。    然后通过调用跳过策略来应用于模式。\nval skipStrategy = ... Pattern.begin(\u0026#34;patternName\u0026#34;, skipStrategy) 注意 对于 SKIP_TO_FIRST/LAST 有两个选项来处理没有元素映射到指定变量的情况。默认情况下, 将使用 NO_SKIP 策略。另一个选项是在这种情况下抛出异常。我们可以通过以下方式启用这个选项\nAfterMatchSkipStrategy.skipToFirst(patternName).throwExceptionOnMiss() 检测模式 在指定了你要寻找的模式序列后, 现在是时候将其应用到你的输入流中以检测潜在的匹配。要针对你的模式序列运行事件流, 你必须创建一个 PatternStream。给定一个输入流输入、一个模式模式和一个可选的比较器比较器, 用于在 EventTime 的情况下对具有相同时间戳的事件或在同一时刻到达的事件进行排序, 你可以通过调用创建 PatternStream。\nval input : DataStream[Event] = ... val pattern : Pattern[Event, _] = ... var comparator : EventComparator[Event] = ... // optional  val patternStream: PatternStream[Event] = CEP.pattern(input, pattern, comparator) 输入流可以是 keyed 的, 也可以是 non-keyed 的, 这取决于你的使用情况。\n注意: 在 non-keyed 流上应用模式将导致作业的并行度等于 1。\n从模式中选择 一旦你获得了一个 PatternStream, 你就可以对检测到的事件序列进行转换。建议的方法是通过 PatternProcessFunction 来实现。\nPatternProcessFunction 有一个 processMatch 方法, 它对每个匹配的事件序列都会被调用。它以 Map\u0026lt;String, List\u0026lt;IN\u0026gt;\u0026gt; 的形式接收匹配, 其中键是你的模式序列中每个模式的名称, 值是该模式的所有接受事件的列表（IN 是你的输入元素的类型）。给定模式的事件是按时间戳排序的。返回每个模式所接受的事件列表的原因是, 当使用循环模式(例如 oneToMany() 和 times())时, 一个给定模式可能会接受多个事件。\nclass MyPatternProcessFunction\u0026lt;IN, OUT\u0026gt; extends PatternProcessFunction\u0026lt;IN, OUT\u0026gt; { @Override public void processMatch(Map\u0026lt;String, List\u0026lt;IN\u0026gt;\u0026gt; match, Context ctx, Collector\u0026lt;OUT\u0026gt; out) throws Exception; IN startEvent = match.get(\u0026#34;start\u0026#34;).get(0); IN endEvent = match.get(\u0026#34;end\u0026#34;).get(0); out.collect(OUT(startEvent, endEvent)); } } PatternProcessFunction 提供了对 Context 对象的访问。通过它, 我们可以访问与时间相关的特性, 如当前处理时间或当前匹配的时间戳（这是分配给匹配的最后一个元素的时间戳）。更多信息请看时间上下文。通过这个上下文, 我们还可以将结果发送到一个侧输出。\n处理超时的部分模式 当一个模式通过 within 关键字附加了一个窗口长度时, 部分事件序列有可能因为超过窗口长度而被丢弃。要对一个超时的部分匹配采取行动, 可以使用 TimedOutPartialMatchHandler 接口。该接口应该以混搭的方式使用。这意味着你可以在你的 PatternProcessFunction 中额外实现这个接口。TimedOutPartialMatchHandler 提供了额外的 processTimedOutMatch 方法, 该方法将为每个超时部分匹配调用。\nclass MyPatternProcessFunction\u0026lt;IN, OUT\u0026gt; extends PatternProcessFunction\u0026lt;IN, OUT\u0026gt; implements TimedOutPartialMatchHandler\u0026lt;IN\u0026gt; { @Override public void processMatch(Map\u0026lt;String, List\u0026lt;IN\u0026gt;\u0026gt; match, Context ctx, Collector\u0026lt;OUT\u0026gt; out) throws Exception; ... } @Override public void processTimedOutMatch(Map\u0026lt;String, List\u0026lt;IN\u0026gt;\u0026gt; match, Context ctx) throws Exception; IN startEvent = match.get(\u0026#34;start\u0026#34;).get(0); ctx.output(outputTag, T(startEvent)); } } 注意: processTimedOutMatch 不给人访问主输出的机会。但你仍然可以通过 Context 对象, 通过侧输出来发出结果。\n方便的 API 前面提到的 PatternProcessFunction 是在 Flink 1.8 中引入的, 从那时起, 它就是推荐的与匹配交互的方式。人们仍然可以使用老式的 API, 比如 select/flatSelect, 内部会被翻译成 PatternProcessFunction。\nval patternStream: PatternStream[Event] = CEP.pattern(input, pattern) val outputTag = OutputTag[String](\u0026#34;side-output\u0026#34;) val result: SingleOutputStreamOperator[ComplexEvent] = patternStream.flatSelect(outputTag){ (pattern: Map[String, Iterable[Event]], timestamp: Long, out: Collector[TimeoutEvent]) =\u0026gt; out.collect(TimeoutEvent()) } { (pattern: mutable.Map[String, Iterable[Event]], out: Collector[ComplexEvent]) =\u0026gt; out.collect(ComplexEvent()) } val timeoutResult: DataStream[TimeoutEvent] = result.getSideOutput(outputTag) 在 CEP 库中的时间 处理事件时间的延迟 在 CEP 中, 处理元素的顺序很重要。为了保证元素在事件时间工作时以正确的顺序进行处理, 一个传入的元素最初会被放在一个缓冲区中, 在这个缓冲区中, 元素根据其时间戳按升序排序, 当一个水印到达时, 这个缓冲区中所有时间戳小于水印的元素都会被处理。这意味着水印之间的元素是按事件时间顺序处理的。\n注意: 当在事件时间内工作时, 该库假定水印的正确性。\n为了保证水印之间的元素按事件时间顺序处理, Flink 的 CEP 库假设水印的正确性, 并将时间戳小于最后看到的水印的元素视为迟到元素。迟到的元素不会被进一步处理。另外, 你可以指定一个 sideOutput 标签来收集最后一次看到的水印之后的迟到元素, 你可以这样使用。\nval patternStream: PatternStream[Event] = CEP.pattern(input, pattern) val lateDataOutputTag = OutputTag[String](\u0026#34;late-data\u0026#34;) val result: SingleOutputStreamOperator[ComplexEvent] = patternStream .sideOutputLateData(lateDataOutputTag) .select{ pattern: Map[String, Iterable[ComplexEvent]] =\u0026gt; ComplexEvent() } val lateData: DataStream[String] = result.getSideOutput(lateDataOutputTag) 时间上下文 在 PatternProcessFunction 以及 IterativeCondition 中, 用户可以访问一个实现 TimeContext 的上下文, 如下所示。\n/** * Enables access to time related characteristics such as current processing time or timestamp of * currently processed element. Used in {@link PatternProcessFunction} and * {@link org.apache.flink.cep.pattern.conditions.IterativeCondition} */ @PublicEvolving public interface TimeContext { /** * Timestamp of the element currently being processed. * * \u0026lt;p\u0026gt;In case of {@link org.apache.flink.streaming.api.TimeCharacteristic#ProcessingTime} this * will be set to the time when event entered the cep operator. */ long timestamp(); /** Returns the current processing time. */ long currentProcessingTime(); } 这个上下文让用户可以访问处理事件的时间特征（在 IterativeCondition 的情况下是传入记录, 在 PatternProcessFunction 的情况下是匹配）。调用 TimeContext#currentProcessingTime 总是给你当前处理时间的值, 这个调用应该比调用 System.currentTimeMillis()更可取。\n在 TimeContext#timestamp() 的情况下, 返回的值等于 EventTime 中分配的时间戳。在 ProcessingTime 中, 这将等于所述事件进入 cep 运算符的时间点(或者在 PatternProcessFunction 的情况下生成匹配时)。这意味着该值将在对该方法的多次调用中保持一致。\n例子 下面的例子是在事件的键控数据流上检测模式 start, middle(name = \u0026ldquo;error\u0026rdquo;) -\u0026gt; end(name = \u0026ldquo;critical\u0026rdquo;)。这些事件通过其 id 进行 keyed, 一个有效的模式必须在 10 秒内出现。整个处理过程是以事件时间来完成的。\nval env : StreamExecutionEnvironment = ... val input : DataStream[Event] = ... val partitionedInput = input.keyBy(event =\u0026gt; event.getId) val pattern = Pattern.begin[Event](\u0026#34;start\u0026#34;) .next(\u0026#34;middle\u0026#34;).where(_.getName == \u0026#34;error\u0026#34;) .followedBy(\u0026#34;end\u0026#34;).where(_.getName == \u0026#34;critical\u0026#34;) .within(Time.seconds(10)) val patternStream = CEP.pattern(partitionedInput, pattern) val alerts = patternStream.select(createAlert(_)) 从旧版本(1.3 前)迁移到 1.4 以上版本 迁移到 1.4+ 版本 在 Flink-1.4 中, CEP 库与 \u0026lt;= Flink 1.2 的向后兼容性被取消。不幸的是, 无法恢复曾经在 1.2.x 下运行的 CEP 作业。\n迁移到 1.3.x Flink-1.3 中的 CEP 库有很多新的特性, 这导致了 API 的一些变化。在这里, 我们描述了为了能够在 Flink-1.3 中运行, 你需要对你的旧 CEP 作业进行的修改。在做了这些改变并重新编译你的作业后, 你将能够从旧版作业的保存点恢复执行, 也就是说, 不需要重新处理你过去的数据。\n所需的更改是:\n  改变你的条件（在 where(\u0026hellip;) 子句中的条件）来扩展 SimpleCondition 类, 而不是实现 FilterFunction 接口。\n  改变你的函数作为参数提供给 select(\u0026hellip;) 和 flatSelect(\u0026hellip;) 方法, 以期望与每个模式相关联的事件列表(Java 中为 List, Scala 中为 Iterable)。这是因为增加了循环模式后, 多个输入事件可以匹配一个（循环）模式。\n  Flink 1.1 和 1.2 中的 followBy() 暗示了非确定性的松散毗连性（见这里）。在 Flink 1.3 中, 这一点发生了变化, followBy() 意味着松散毗连, 而 followByAny() 应该在需要非确定性松散毗连的情况下使用。\n  "},"name":"FlinkCEP - Flink 的复杂事件处理","published":"2020-12-20T00:00:00+08:00","summary":"Flink Cep Complex Event Processing for Flink","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-12-20-flink-cep-complex-event-processing-for-flink/"}