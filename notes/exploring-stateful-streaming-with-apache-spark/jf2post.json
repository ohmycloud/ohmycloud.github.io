{"author":{"name":null,"type":"card","url":"https://ohmycloud.github.io/"},"content":{"html":"\u003cblockquote\u003e\n\u003cp\u003e更新(2017.08.01): Spark v2.2 最近推出了一个叫做 \u003ccode\u003emapGroupsWithState\u003c/code\u003e 的有状态流的新抽象, 我最近有一篇\u003ca href=\"https://blog.yuvalitzchakov.com/exploring-stateful-streaming-with-spark-structured-streaming/\"\u003e博客\u003c/a\u003e也是关于它的。我强烈建议你检查一下。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"介绍\"\u003e介绍\u003c/h2\u003e\n\u003cp\u003eApache Spark 由几个模块组成，每个模块都有不同的用途。 它的功能强大的模块之一是 Streaming API，它使开发人员能够在称为 Discretized Stream 或 DStream 的抽象下使用连续流（或准确地说是微批次）。\u003c/p\u003e\n\u003cp\u003e在这篇文章中，我将深入探讨 Spark Streaming 的一个特殊属性，它是有状态的 Streaming API。 有状态流使我们能够维护微批之间的状态，从而使我们能够形成数据的会话化。\u003c/p\u003e\n\u003cp\u003e免责声明-为了遵循本文的流程，应该对 Spark 的工作原理有基本的了解，并对 DStream 抽象具有一般的了解。 如果没有，请继续阅读，不用担心，我会等你\u0026hellip;\u003c/p\u003e\n\u003cp\u003e欢迎回来！ 让我们继续。\u003c/p\u003e\n\u003ch2 id=\"通过例子理解\"\u003e通过例子理解\u003c/h2\u003e\n\u003cp\u003e为了了解如何使用 API​​，让我们创建一个简单的传入数据示例，该示例要求我们进行会话化。我们的输入数据流将是 \u003ccode\u003eUserEvent\u003c/code\u003e 类型：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eUserEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eid\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eisLast\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eBoolean\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e每个事件描述一个唯一的用户。我们通过用户 ID 标识用户，并用 \u003ccode\u003eString\u003c/code\u003e 表示发生的事件的内容。我们还想知道用户何时结束会话，因此我们提供了一个 \u003ccode\u003eisLast\u003c/code\u003e 标志来指示会话结束。\u003c/p\u003e\n\u003cp\u003e我们负责汇总所有用户事件的状态将是 \u003ccode\u003eUserSession\u003c/code\u003e 类型的状态：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003euserEvents\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eSeq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eUserEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e其中包含特定用户发生的事件序列。在此示例中，我们假设数据源是来自于 Kafka 使用的 JSON 编码数据流。\u003c/p\u003e\n\u003cp\u003e我们的 \u003ccode\u003eId\u003c/code\u003e 属性将用作键，而 \u003ccode\u003eUserEvent\u003c/code\u003e 将是我们的值。两个放在一块，我们得到一个 \u003ccode\u003eDStream[(Int, UserEvent)]\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e在我们开始之前，有两个重要的关键点：\u003c/p\u003e\n\u003cp\u003e1.检查点是有状态流的初步选择\u003c/p\u003e\n\u003cp\u003e来自于 Spark 文档：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e流式应用程序必须24/7全天候运行，因此必须对与应用程序逻辑无关的故障（例如，系统故障，JVM崩溃等）具有弹性。为此，Spark Streaming 需要将足够的信息检查点指向容错存储系统，以便可以从故障中恢复。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSpark 的检查点机制是在我们 spark 工作的整个生命周期中保证容错能力的框架方法。当我们以24/7全天候运行时，某些故障可能无法直接控制，例如网络故障或数据中心崩溃。为了保证采用一种干净的恢复方式，Spark 可以在选择的每个时间间隔内将我们的数据检查到一个永久数据存储，例如 Amazon S3，HDFS 或 Azure Blob 存储（如果我们这样做的话）。\u003c/p\u003e\n\u003cp\u003e检查点是任何无状态转换的功能，但是\u003cstrong\u003e必须为有状态流提供检查点目录\u003c/strong\u003e，否则您的应用程序将无法启动。\u003c/p\u003e\n\u003cp\u003e提供检查点目录就像使用目录位置调用 \u003ccode\u003eStreamingContext\u003c/code\u003e 一样容易：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003esparkContext\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eSparkContext\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003essc\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eStreamingContext\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esparkContext\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eDuration\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e4000\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003essc\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003echeckpoint\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;path/to/persistent/storage\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e需要注意的重要一件事是，\u003cstrong\u003e只有在你未修改现有代码的情况下，检查点数据才可用\u003c/strong\u003e，并且主要适合于从作业失败中恢复。修改代码后（即将新版本上传到 Spark 集群），检查点数据不再兼容，必须删除这些数据后才能开始工作。\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eDStream 中的键值对\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e一个常见的错误是想知道为什么在使用 DStream 时为什么看不到有状态的转换方法（我们将很快看到的 \u003ccode\u003eupdateStateByKey\u003c/code\u003e 和 \u003ccode\u003emapWithState\u003c/code\u003e）。有状态转换要求我们对 DStream 进行操作，该 DStream 封装了一个键值对，格式为 \u003ccode\u003eDStream[(K,V)]\u003c/code\u003e，其中 \u003ccode\u003eK\u003c/code\u003e 是键的类型，\u003ccode\u003eV\u003c/code\u003e 是值的类型。通过使用此类流，Spark 可以根据键对数据进行随机排序，因此给定键的所有数据都可以在同一工作节点上使用，并允许您进行有意义的聚合。\u003c/p\u003e\n\u003cp\u003e好的，我们准备好了。我们去写一些代码。\u003c/p\u003e\n\u003ch2 id=\"简要回顾过去\"\u003e简要回顾过去\u003c/h2\u003e\n\u003cp\u003e在 Spark 1.6.0 之前，唯一可用的状态转换是 \u003ccode\u003ePairDStreamFunctions.updateStateByKey\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e最简单的形式（我们将要介绍）的签名如下所示：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003eupdateStateByKey\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eS\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"n\"\u003eupdateFunc\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eSeq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eV\u003c/span\u003e\u003cspan class=\"o\"\u003e],\u003c/span\u003e \u003cspan class=\"nc\"\u003eOption\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eS\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e \u003cspan class=\"k\"\u003e⇒\u003c/span\u003e \u003cspan class=\"nc\"\u003eOption\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eS\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003eupdateStateByKey\u003c/code\u003e 需要一个接受以下参数的函数：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eSeq[V]\u003c/code\u003e-当前批次中给定键收到的新值的列表。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eOption[S]\u003c/code\u003e-我们在每次迭代中更新的状态。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e对于我们的工作的第一次调用，状态将为 \u003ccode\u003eNone\u003c/code\u003e，表示它是给定键的第一批。之后，完全由我们来管理其值。完成给定键的特定状态后，我们需要返回 \u003ccode\u003eNone\u003c/code\u003e 来指示 Spark 我们不再需要该状态。\u003c/p\u003e\n\u003cp\u003e对于我们的场景而言，一个简单的实现看起来像这样：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003edef updateUserEvents(newEvents: Seq[UserEvent],\n                    state: Option[UserSession]): Option[UserSession] = {\n  /*\n  Append the new events to the state. If this the first time we\u0026#39;re invoked for the key\n  we fallback to creating a new UserSession with the new events.\n  */\n  val newState = state\n    .map(prev =\u0026gt; UserSession(prev.userEvents ++ newEvents))\n    .orElse(Some(UserSession(newEvents)))\n\n/*\nIf we received the `isLast` event in the current batch, save the session to the underlying store and return None to delete the state.\nOtherwise, return the accumulated state so we can keep updating it in the next batch.\n*/\n  if (newEvents.exists(_.isLast)) {\n    saveUserSession(state)\n    None\n  } else newState\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在每个批次中，我们都希望获取给定用户的状态，并将旧事件和新事件都合并到新的 \u003ccode\u003eOption[UserSession]\u003c/code\u003e 中。然后，我们要检查是否已到达此用户会话的末尾，因此我们在任何 \u003ccode\u003eUserEvent\u003c/code\u003e 上检查 \u003ccode\u003eisLast\u003c/code\u003e 标志的新到达序列。如果收到最后一条消息，则将用户操作保存到一些持久性存储中，然后返回 \u003ccode\u003eNone\u003c/code\u003e 表示我们已完成。如果尚未收到结束消息，则只需返回新创建的状态即可进行下一次迭代。\u003c/p\u003e\n\u003cp\u003e我们的Spark DAG（有向无环图）如下所示：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eval kafkaStream =\n      KafkaUtils.createDirectStream[String, String, StringDecoder, StringDecoder](ssc, kafkaParams, topics)\n\nkafkaStream\n  .map(deserializeUserEvent)\n  .updateStateByKey(updateUserEvents)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e第一个 \u003ccode\u003emap\u003c/code\u003e 用于将 JSON 解析为 \u003ccode\u003e（Int, UserEvent)\u003c/code\u003e 的元组，其中 \u003ccode\u003eInt\u003c/code\u003e 为 \u003ccode\u003eUserEvent.id\u003c/code\u003e。然后，将元组传递给我们的 \u003ccode\u003eupdateStateByKey\u003c/code\u003e 来完成其余的工作。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eupdateStateByKey 的缺点\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e使用 \u003ccode\u003eupdateStateByKey\u003c/code\u003e 的主要缺点是，对于每个新的传入批处理，转换都会迭代\u003cstrong\u003e整个状态存储\u003c/strong\u003e，而不管给定键的新值是否已被消耗。这可能会影响性能，尤其是随着时间处理大量状态时。有\u003ca href=\"http://spark.apache.org/docs/latest/streaming-programming-guide.html#reducing-the-batch-processing-times\"\u003e多种技术\u003c/a\u003e可以提高性能，但这仍然是一个难题。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e没有内置的超时机制-请考虑一下我们的示例中的情况，即如果表示用户会话结束的事件丢失或由于某种原因没有到达。 \u003ccode\u003eupdateStateByKey\u003c/code\u003e 迭代所有键这一事实的一个好处是，我们可以自己实现这样的超时，但这绝对是框架该做的功能。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e你收到的就是返回的内容-由于 \u003ccode\u003eupdateStateByKey\u003c/code\u003e 的返回值与我们存储的状态相同。对于我们的 \u003ccode\u003eOption[UserSession]\u003c/code\u003e，我们被迫将其返回到下游。但是，如果状态完成后，我想输出一个不同的类型并在另一个转换中使用它，会发生什么？目前，这是不可能的。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"引入-mapwithstate\"\u003e引入 mapWithState\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003emapWithState\u003c/code\u003e 是在 Spark 1.6.0 中作为实验性 API 发布的 \u003ccode\u003eupdateStateByKeys\u003c/code\u003e 的后继产品。这是从在 Spark 中使用状态流进行的过程中汲取的教训，并带来了新的有前途的产品。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emapWithState\u003c/code\u003e 带有 \u003ccode\u003eupdateStateByKey\u003c/code\u003e 中缺少的功能：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e内置的超时机制-我们可以告诉 \u003ccode\u003emapWithState\u003c/code\u003e 我们想要保持状态的时间，以防万一没有新数据出现。一旦达到超时，最后一次调用 \u003ccode\u003emapWithState\u003c/code\u003e 时会带有一个特殊标志（稍后将会看到）。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e部分更新-仅迭代在当前批次中具有新数据的键。这意味着不再需要在每个批处理间隔内迭代整个状态存储，这是一个很好的性能优化。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e选择你的返回类型-现在，无论我们的状态对象是哪种类型，我们都可以选择所需的返回类型。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e初始状态-我们可以选择一个自定义的 RDD 来在启动时初始化我们的状态转换。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e让我们看一下构成新 API 的不同部分。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emapWithState\u003c/code\u003e 的签名：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003emapWithState\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eStateType\u003c/span\u003e, \u003cspan class=\"kt\"\u003eMappedType\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"n\"\u003espec\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eStateSpec\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eK\u003c/span\u003e, \u003cspan class=\"kt\"\u003eV\u003c/span\u003e, \u003cspan class=\"kt\"\u003eStateType\u003c/span\u003e, \u003cspan class=\"kt\"\u003eMappedType\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e与 \u003ccode\u003eupdateStateByKey\u003c/code\u003e 要求我们传递带有消息序列的函数和状态（以 \u003ccode\u003eOption[S]\u003c/code\u003e 形式）相反，现在我们需要传递 \u003ca href=\"http://spark.apache.org/docs/1.6.1/api/scala/index.html#org.apache.spark.streaming.StateSpec\"\u003e\u003ccode\u003eStateSpec\u003c/code\u003e\u003c/a\u003e：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e表示对 DStream（Scala）或 JavaPairDStream（Java）的 DStream 转换 \u003ccode\u003emapWithState\u003c/code\u003e  操作的所有规范的抽象类。 使用 \u003ccode\u003eStateSpec.apply()\u003c/code\u003e 或 \u003ccode\u003eStateSpec.create()\u003c/code\u003e 创建此类的实例。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eScala中的示例：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// A mapping function that maintains an integer state and return a String\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003emappingFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eOption\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003estate\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eState\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eOption\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"c1\"\u003e// Use state.exists(), state.get(), state.update() and state.remove()\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// to manage state, and return the necessary string\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003espec\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eStateSpec\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efunction\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emappingFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e有趣的是 \u003ccode\u003eStateSpec.function\u003c/code\u003e，这是用于创建 \u003ccode\u003eStateSpec\u003c/code\u003e 的工厂方法。 它需要具有以下签名的功能：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003emappingFunction\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eKeyType\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eOption\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eValueType\u003c/span\u003e\u003cspan class=\"o\"\u003e],\u003c/span\u003e \u003cspan class=\"nc\"\u003eState\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eStateType\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"nc\"\u003eMappedType\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003emappingFunction\u003c/code\u003e 需要几个参数。 让我们构造它们以匹配我们的示例：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eKeyType\u003c/code\u003e-显然是键类型 \u003ccode\u003eInt\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eOption[ValueType]\u003c/code\u003e-传入数据类型，\u003ccode\u003eOption[UserEvent]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eState[StateType]\u003c/code\u003e-迭代之间要保留的状态，\u003ccode\u003eState[UserSession]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMappedType\u003c/code\u003e-我们的返回类型，可以是任何类型。 对于我们的示例，我们将传递一个 \u003ccode\u003eOption[UserSession]\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003emapWithState 和 updateStateByKey 之间的区别\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e我们键的值，以前没有暴露出来。\u003c/li\u003e\n\u003cli\u003e以 \u003ccode\u003eOption[S]\u003c/code\u003e 的形式传入的新值，以前是 \u003ccode\u003eSeq[S]\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e现在，我们的状态被封装在 \u003ccode\u003eState[StateType]\u003c/code\u003e 类型的对象中。\u003c/li\u003e\n\u003cli\u003e我们可以从转换中返回想要的任何类型，而不再局限于我们所持有的状态的类型。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e（存在一个更高级的 API，我们还可以收到一个 \u003cstrong\u003eTime\u003c/strong\u003e 对象，但这里不再赘述。请在\u003ca href=\"http://spark.apache.org/docs/1.6.1/api/scala/index.html#org.apache.spark.streaming.StateSpec$\"\u003e此处\u003c/a\u003e随意检查不同的重载）。\u003c/p\u003e\n\u003ch3 id=\"使用-state-对象探索状态管理\"\u003e使用 State 对象探索状态管理\u003c/h3\u003e\n\u003cp\u003e以前，管理我们的状态意味着要使用 \u003ccode\u003eOption[S]\u003c/code\u003e。为了更新状态，我们将创建一个新实例，并从转换中返回该实例。当我们想要删除状态时，我们将返回 \u003ccode\u003eNone\u003c/code\u003e。由于我们现在可以自由地从 \u003ccode\u003emapWithState\u003c/code\u003e 返回任何类型，因此我们需要一种与 Spark 交互的方式，以表达我们希望在每次迭代中对状态进行的处理。为此，我们有 \u003ccode\u003eState[S]\u003c/code\u003e 对象。\u003c/p\u003e\n\u003cp\u003e该对象公开了几种方法：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edef exist(): Boolean\u003c/code\u003e-检查状态是否存在。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edef get(): S\u003c/code\u003e-获取状态（如果存在），否则将抛出 java.util.NoSuchElementException。 （我们需要注意这一点！）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edef isTimingOut(): Boolean\u003c/code\u003e-当前批处理后，状态是否超时并且将被系统删除。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edef remove(): Unit\u003c/code\u003e-删除状态（如果存在）。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edef update(newState: S): Unit\u003c/code\u003e-用新值更新状态。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edef getOption(): Option[S]\u003c/code\u003e-获取状态为 \u003ccode\u003escala.Option\u003c/code\u003e 类型。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们很快就会看到。\u003c/p\u003e\n\u003ch3 id=\"更改我们的代码以符合新的-api\"\u003e更改我们的代码以符合新的 API\u003c/h3\u003e\n\u003cp\u003e让我们重建以前的 \u003ccode\u003eupdateUserEvents\u003c/code\u003e 以符合新的 API。现在，我们的新方法签名如下所示：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003eupdateUserEvents\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eOption\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eUserEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003estate\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eState\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eOption\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e现在，我们不再接收 \u003ccode\u003eSeq[UserEvent]\u003c/code\u003e，而是分别接收每个事件。\u003c/p\u003e\n\u003cp\u003e让我们继续进行更改：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003eupdateUserEvents\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                     \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eOption\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eUserEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                     \u003cspan class=\"n\"\u003estate\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eState\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eOption\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e  Get existing user events, or if this is our first iteration\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e  create an empty sequence of events.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e  */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eexistingEvents\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eSeq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eUserEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estate\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetOption\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003euserEvents\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetOrElse\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eSeq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eUserEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e  Extract the new incoming value, appending the new event with the old\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e  sequence of events.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e  */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eupdatedUserSession\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eUserSession\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enewEvent\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"nc\"\u003eUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enewEvent\u003c/span\u003e \u003cspan class=\"o\"\u003e+:\u003c/span\u003e \u003cspan class=\"n\"\u003eexistingEvents\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetOrElse\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eexistingEvents\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003eLook for the end event. If found, return the final `UserSession`,\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003eIf not, update the internal state and return `None`\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e*/\u003c/span\u003e      \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003eupdatedUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003euserEvents\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efind\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eisLast\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003ematch\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"nc\"\u003eSome\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"n\"\u003estate\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eremove\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"nc\"\u003eSome\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eupdatedUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"nc\"\u003eNone\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"n\"\u003estate\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eupdate\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eupdatedUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"nc\"\u003eNone\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e对于 \u003ccode\u003emapWithState\u003c/code\u003e 的每次迭代：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果这是我们的第一次迭代，则状态将为空。我们需要创建它并追加新事件。如果不是，那么事件已经存在，请从 \u003ccode\u003eState[UserSession]\u003c/code\u003e 中提取它们，然后将新事件与旧事件一起添加。\u003c/li\u003e\n\u003cli\u003e查找 \u003ccode\u003eisLast\u003c/code\u003e 事件标志。如果存在，请删除 \u003ccode\u003eUserSession\u003c/code\u003e 状态并返回 \u003ccode\u003eOption[UserSession]\u003c/code\u003e。否则，更新状态并返回 \u003ccode\u003eNone\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e返回 \u003ccode\u003eOption[UserSession]\u003c/code\u003e 转换的选择取决于我们。我们可以选择返回 \u003ccode\u003eUnit\u003c/code\u003e 并从 \u003ccode\u003emapWithState\u003c/code\u003e 发送完整的 \u003ccode\u003eUserSession\u003c/code\u003e，就像使用 \u003ccode\u003eupdateStateByKey\u003c/code\u003e 一样。但是，我更喜欢我们可以将 \u003ccode\u003eUserSession\u003c/code\u003e 传递给另一个转换，以根据需要执行更多工作。\u003c/p\u003e\n\u003cp\u003e我们的新Spark DAG现在看起来像这样：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003estateSpec\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eStateSpec\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efunction\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eupdateUserEvents\u003c/span\u003e \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ekafkaStream\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edeserializeUserEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emapWithState\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estateSpec\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e但是，还需要添加一件事。 由于我们没有将 \u003ccode\u003eUserSession\u003c/code\u003e 保存在转换中，因此我们需要添加其他转换以将其存储在持久性存储中。 为此，我们可以使用 \u003ccode\u003eforeachRDD\u003c/code\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ekafkaStream\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edeserializeUserEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emapWithState\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estateSpec\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eforeachRDD\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003erdd\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"o\"\u003e(!\u003c/span\u003e\u003cspan class=\"n\"\u003erdd\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eisEmpty\u003c/span\u003e\u003cspan class=\"o\"\u003e())\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"n\"\u003erdd\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eforeach\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emaybeUserSession\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003emaybeUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eforeach\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esaveUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e(如果您不想为 RDD 中的每个值打开与基础持久性存储的连接，那么请考虑使用 \u003ccode\u003erdd.foreachPartition\u003c/code\u003e 而不是 \u003ccode\u003erdd.foreach\u003c/code\u003e（但这超出了本文的范围)\u003c/p\u003e\n\u003ch3 id=\"超时结束\"\u003e超时结束\u003c/h3\u003e\n\u003cp\u003e实际上，当处理大量数据时，我们必须保护自己免受数据丢失的影响。在当前的实现中，如果 \u003ccode\u003eisLast\u003c/code\u003e 甚至都没有显示，我们最终将使用户操作“停留”在该状态。\u003c/p\u003e\n\u003cp\u003e添加超时很简单：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e构造 \u003ccode\u003eStateSpec\u003c/code\u003e 时添加超时。\u003c/li\u003e\n\u003cli\u003e处理有状态转换中的超时。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e第一步很容易达到：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003eorg.apache.spark.streaming._\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003estateSpec\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nc\"\u003eStateSpec\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efunction\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eupdateUserEvents\u003c/span\u003e \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etimeout\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eMinutes\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e(\u003ccode\u003eMinutes\u003c/code\u003e 是 Scala 的 Duration 类的 Spark 包装器类。)\u003c/p\u003e\n\u003cp\u003e对于我们的 \u003ccode\u003eupdateUserEvents\u003c/code\u003e，我们需要监视 \u003ccode\u003eState[S].isTimingOut\u003c/code\u003e 标志以了解我们正在超时。关于超时，我想提两件事：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e重要的是要注意，一旦发生超时，我们的 \u003ccode\u003evalue\u003c/code\u003e 参数将为 \u003ccode\u003eNone\u003c/code\u003e（解释为什么我们会收到 \u003ccode\u003eOption[S]\u003c/code\u003e 而不是 \u003ccode\u003eS\u003c/code\u003e 来获得值。有关更多信息，请参见\u003ca href=\"http://stackoverflow.com/questions/38397688/spark-mapwithstate-api-explanation/38397937#38397937\"\u003e此处\u003c/a\u003e）。\u003c/li\u003e\n\u003cli\u003e如果由于超时而调用 \u003ccode\u003emapWithState\u003c/code\u003e，则我们\u003cstrong\u003e不能调用 \u003ccode\u003estate.remove()\u003c/code\u003e\u003c/strong\u003e，它将由框架代表我们完成。从 \u003ccode\u003eState.remove\u003c/code\u003e 的文档中：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如果状态已被删除（即 \u003ccode\u003eremove()\u003c/code\u003e 已经被调用）或由于超时而将被删除（即 \u003ccode\u003eisTimingOut()\u003c/code\u003e 为 true），则无法更新状态。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e让我们修改代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003eupdateUserEvents\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                     \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eOption\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eUserEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                     \u003cspan class=\"n\"\u003estate\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eState\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eOption\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003eupdateUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enewEvent\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eUserEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eOption\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eexistingEvents\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eSeq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eUserEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"n\"\u003estate\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetOption\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003euserEvents\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetOrElse\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eSeq\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eUserEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e]())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eupdatedUserSession\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enewEvent\u003c/span\u003e \u003cspan class=\"o\"\u003e+:\u003c/span\u003e \u003cspan class=\"n\"\u003eexistingEvents\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eupdatedUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003euserEvents\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efind\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eisLast\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003ematch\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"nc\"\u003eSome\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estate\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eremove\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nc\"\u003eSome\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eupdatedUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"nc\"\u003eNone\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estate\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eupdate\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eupdatedUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nc\"\u003eNone\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003evalue\u003c/span\u003e \u003cspan class=\"k\"\u003ematch\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"nc\"\u003eSome\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enewEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eupdateUserSession\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enewEvent\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"k\"\u003e_\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003estate\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eisTimingOut\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003estate\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetOption\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我已将用户操作的更新提取到本地方法 \u003ccode\u003eupdateUserSession\u003c/code\u003e 中，如果由于新的传入值而调用该方法，则将调用该方法。否则，我们将超时，需要返回到目前为止累积的用户事件。\u003c/p\u003e\n\u003ch3 id=\"包装起来\"\u003e包装起来\u003c/h3\u003e\n\u003cp\u003e希望我能传达出 Spark 有状态流的一般用法。有状态流，尤其是新的 \u003ccode\u003emapWithState\u003c/code\u003e 转换为希望使用 Spark 处理有状态数据的最终用户带来了强大的功能，同时享受了 Spark 带来的弹性，分布和容错能力的保证。\u003c/p\u003e\n\u003cp\u003e在即将发布的 Spark 2.0.0 发行版中，还有更多改进，例如状态版本控制，这将使我们能够标记累积的数据，并且仅保留所存储状态的一个子集。如果您对更多内容感兴趣，请参阅“\u003ca href=\"https://docs.google.com/document/d/1-ncawFx8JS5Zyfq1HAEGBx56RDet9wfVp_hDM8ZL254/edit?usp=sharing\"\u003e用于流聚合的状态存储\u003c/a\u003e”建议。\u003c/p\u003e\n\u003cp\u003e如果您想玩转，可以在 \u003ca href=\"https://github.com/YuvalItzchakov/spark-stateful-example\"\u003eGitHub\u003c/a\u003e 上找到包含代码的完整工作库。\u003c/p\u003e\n\u003cp\u003e此外，\u003ca href=\"https://databricks.com/blog/2016/02/01/faster-stateful-stream-processing-in-apache-spark-streaming.html\"\u003e此\u003c/a\u003e DataBricks 帖子中对 \u003ccode\u003eupdateStateByKey\u003c/code\u003e 和 \u003ccode\u003emapWithState\u003c/code\u003e 性能特征进行了很好的比较。\u003c/p\u003e\n","text":" 更新(2017.08.01): Spark v2.2 最近推出了一个叫做 mapGroupsWithState 的有状态流的新抽象, 我最近有一篇博客也是关于它的。我强烈建议你检查一下。\n介绍 Apache Spark 由几个模块组成，每个模块都有不同的用途。 它的功能强大的模块之一是 Streaming API，它使开发人员能够在称为 Discretized Stream 或 DStream 的抽象下使用连续流（或准确地说是微批次）。\n在这篇文章中，我将深入探讨 Spark Streaming 的一个特殊属性，它是有状态的 Streaming API。 有状态流使我们能够维护微批之间的状态，从而使我们能够形成数据的会话化。\n免责声明-为了遵循本文的流程，应该对 Spark 的工作原理有基本的了解，并对 DStream 抽象具有一般的了解。 如果没有，请继续阅读，不用担心，我会等你\u0026hellip;\n欢迎回来！ 让我们继续。\n通过例子理解 为了了解如何使用 API​​，让我们创建一个简单的传入数据示例，该示例要求我们进行会话化。我们的输入数据流将是 UserEvent 类型：\ncase class UserEvent(id: Int, data: String, isLast: Boolean) 每个事件描述一个唯一的用户。我们通过用户 ID 标识用户，并用 String 表示发生的事件的内容。我们还想知道用户何时结束会话，因此我们提供了一个 isLast 标志来指示会话结束。\n我们负责汇总所有用户事件的状态将是 UserSession 类型的状态：\ncase class UserSession(userEvents: Seq[UserEvent]) 其中包含特定用户发生的事件序列。在此示例中，我们假设数据源是来自于 Kafka 使用的 JSON 编码数据流。\n我们的 Id 属性将用作键，而 UserEvent 将是我们的值。两个放在一块，我们得到一个 DStream[(Int, UserEvent)]。\n在我们开始之前，有两个重要的关键点：\n1.检查点是有状态流的初步选择\n来自于 Spark 文档：\n流式应用程序必须24/7全天候运行，因此必须对与应用程序逻辑无关的故障（例如，系统故障，JVM崩溃等）具有弹性。为此，Spark Streaming 需要将足够的信息检查点指向容错存储系统，以便可以从故障中恢复。\nSpark 的检查点机制是在我们 spark 工作的整个生命周期中保证容错能力的框架方法。当我们以24/7全天候运行时，某些故障可能无法直接控制，例如网络故障或数据中心崩溃。为了保证采用一种干净的恢复方式，Spark 可以在选择的每个时间间隔内将我们的数据检查到一个永久数据存储，例如 Amazon S3，HDFS 或 Azure Blob 存储（如果我们这样做的话）。\n检查点是任何无状态转换的功能，但是必须为有状态流提供检查点目录，否则您的应用程序将无法启动。\n提供检查点目录就像使用目录位置调用 StreamingContext 一样容易：\nval sparkContext = new SparkContext() val ssc = new StreamingContext(sparkContext, Duration(4000)) ssc.checkpoint(\u0026#34;path/to/persistent/storage\u0026#34;) 需要注意的重要一件事是，只有在你未修改现有代码的情况下，检查点数据才可用，并且主要适合于从作业失败中恢复。修改代码后（即将新版本上传到 Spark 集群），检查点数据不再兼容，必须删除这些数据后才能开始工作。\nDStream 中的键值对 一个常见的错误是想知道为什么在使用 DStream 时为什么看不到有状态的转换方法（我们将很快看到的 updateStateByKey 和 mapWithState）。有状态转换要求我们对 DStream 进行操作，该 DStream 封装了一个键值对，格式为 DStream[(K,V)]，其中 K 是键的类型，V 是值的类型。通过使用此类流，Spark 可以根据键对数据进行随机排序，因此给定键的所有数据都可以在同一工作节点上使用，并允许您进行有意义的聚合。\n好的，我们准备好了。我们去写一些代码。\n简要回顾过去 在 Spark 1.6.0 之前，唯一可用的状态转换是 PairDStreamFunctions.updateStateByKey。\n最简单的形式（我们将要介绍）的签名如下所示：\ndef updateStateByKey[S](updateFunc: (Seq[V], Option[S]) ⇒ Option[S]) updateStateByKey 需要一个接受以下参数的函数：\nSeq[V]-当前批次中给定键收到的新值的列表。 Option[S]-我们在每次迭代中更新的状态。 对于我们的工作的第一次调用，状态将为 None，表示它是给定键的第一批。之后，完全由我们来管理其值。完成给定键的特定状态后，我们需要返回 None 来指示 Spark 我们不再需要该状态。\n对于我们的场景而言，一个简单的实现看起来像这样：\ndef updateUserEvents(newEvents: Seq[UserEvent], state: Option[UserSession]): Option[UserSession] = { /* Append the new events to the state. If this the first time we\u0026#39;re invoked for the key we fallback to creating a new UserSession with the new events. */ val newState = state .map(prev =\u0026gt; UserSession(prev.userEvents ++ newEvents)) .orElse(Some(UserSession(newEvents))) /* If we received the `isLast` event in the current batch, save the session to the underlying store and return None to delete the state. Otherwise, return the accumulated state so we can keep updating it in the next batch. */ if (newEvents.exists(_.isLast)) { saveUserSession(state) None } else newState } 在每个批次中，我们都希望获取给定用户的状态，并将旧事件和新事件都合并到新的 Option[UserSession] 中。然后，我们要检查是否已到达此用户会话的末尾，因此我们在任何 UserEvent 上检查 isLast 标志的新到达序列。如果收到最后一条消息，则将用户操作保存到一些持久性存储中，然后返回 None 表示我们已完成。如果尚未收到结束消息，则只需返回新创建的状态即可进行下一次迭代。\n我们的Spark DAG（有向无环图）如下所示：\nval kafkaStream = KafkaUtils.createDirectStream[String, String, StringDecoder, StringDecoder](ssc, kafkaParams, topics) kafkaStream .map(deserializeUserEvent) .updateStateByKey(updateUserEvents) 第一个 map 用于将 JSON 解析为 （Int, UserEvent) 的元组，其中 Int 为 UserEvent.id。然后，将元组传递给我们的 updateStateByKey 来完成其余的工作。\nupdateStateByKey 的缺点\n使用 updateStateByKey 的主要缺点是，对于每个新的传入批处理，转换都会迭代整个状态存储，而不管给定键的新值是否已被消耗。这可能会影响性能，尤其是随着时间处理大量状态时。有多种技术可以提高性能，但这仍然是一个难题。\n没有内置的超时机制-请考虑一下我们的示例中的情况，即如果表示用户会话结束的事件丢失或由于某种原因没有到达。 updateStateByKey 迭代所有键这一事实的一个好处是，我们可以自己实现这样的超时，但这绝对是框架该做的功能。\n你收到的就是返回的内容-由于 updateStateByKey 的返回值与我们存储的状态相同。对于我们的 Option[UserSession]，我们被迫将其返回到下游。但是，如果状态完成后，我想输出一个不同的类型并在另一个转换中使用它，会发生什么？目前，这是不可能的。\n引入 mapWithState mapWithState 是在 Spark 1.6.0 中作为实验性 API 发布的 updateStateByKeys 的后继产品。这是从在 Spark 中使用状态流进行的过程中汲取的教训，并带来了新的有前途的产品。\nmapWithState 带有 updateStateByKey 中缺少的功能：\n内置的超时机制-我们可以告诉 mapWithState 我们想要保持状态的时间，以防万一没有新数据出现。一旦达到超时，最后一次调用 mapWithState 时会带有一个特殊标志（稍后将会看到）。\n部分更新-仅迭代在当前批次中具有新数据的键。这意味着不再需要在每个批处理间隔内迭代整个状态存储，这是一个很好的性能优化。\n选择你的返回类型-现在，无论我们的状态对象是哪种类型，我们都可以选择所需的返回类型。\n初始状态-我们可以选择一个自定义的 RDD 来在启动时初始化我们的状态转换。\n让我们看一下构成新 API 的不同部分。\nmapWithState 的签名：\nmapWithState[StateType, MappedType](spec: StateSpec[K, V, StateType, MappedType]) 与 updateStateByKey 要求我们传递带有消息序列的函数和状态（以 Option[S] 形式）相反，现在我们需要传递 StateSpec：\n表示对 DStream（Scala）或 JavaPairDStream（Java）的 DStream 转换 mapWithState 操作的所有规范的抽象类。 使用 StateSpec.apply() 或 StateSpec.create() 创建此类的实例。\nScala中的示例：\n// A mapping function that maintains an integer state and return a String def mappingFunction(key: String, value: Option[Int], state: State[Int]): Option[String] = { // Use state.exists(), state.get(), state.update() and state.remove() // to manage state, and return the necessary string } val spec = StateSpec.function(mappingFunction) 有趣的是 StateSpec.function，这是用于创建 StateSpec 的工厂方法。 它需要具有以下签名的功能：\nmappingFunction: (KeyType, Option[ValueType], State[StateType]) =\u0026gt; MappedType mappingFunction 需要几个参数。 让我们构造它们以匹配我们的示例：\nKeyType-显然是键类型 Int Option[ValueType]-传入数据类型，Option[UserEvent] State[StateType]-迭代之间要保留的状态，State[UserSession] MappedType-我们的返回类型，可以是任何类型。 对于我们的示例，我们将传递一个 Option[UserSession]。 mapWithState 和 updateStateByKey 之间的区别\n我们键的值，以前没有暴露出来。 以 Option[S] 的形式传入的新值，以前是 Seq[S]。 现在，我们的状态被封装在 State[StateType] 类型的对象中。 我们可以从转换中返回想要的任何类型，而不再局限于我们所持有的状态的类型。 （存在一个更高级的 API，我们还可以收到一个 Time 对象，但这里不再赘述。请在此处随意检查不同的重载）。\n使用 State 对象探索状态管理 以前，管理我们的状态意味着要使用 Option[S]。为了更新状态，我们将创建一个新实例，并从转换中返回该实例。当我们想要删除状态时，我们将返回 None。由于我们现在可以自由地从 mapWithState 返回任何类型，因此我们需要一种与 Spark 交互的方式，以表达我们希望在每次迭代中对状态进行的处理。为此，我们有 State[S] 对象。\n该对象公开了几种方法：\ndef exist(): Boolean-检查状态是否存在。 def get(): S-获取状态（如果存在），否则将抛出 java.util.NoSuchElementException。 （我们需要注意这一点！） def isTimingOut(): Boolean-当前批处理后，状态是否超时并且将被系统删除。 def remove(): Unit-删除状态（如果存在）。 def update(newState: S): Unit-用新值更新状态。 def getOption(): Option[S]-获取状态为 scala.Option 类型。 我们很快就会看到。\n更改我们的代码以符合新的 API 让我们重建以前的 updateUserEvents 以符合新的 API。现在，我们的新方法签名如下所示：\ndef updateUserEvents(key: Int, value: Option[UserEvent], state: State[UserSession]): Option[UserSession] 现在，我们不再接收 Seq[UserEvent]，而是分别接收每个事件。\n让我们继续进行更改：\ndef updateUserEvents(key: Int, value: Option[UserEvent], state: State[UserSession]): Option[UserSession] = { /* Get existing user events, or if this is our first iteration create an empty sequence of events. */ val existingEvents: Seq[UserEvent] = state .getOption() .map(_.userEvents) .getOrElse(Seq[UserEvent]()) /* Extract the new incoming value, appending the new event with the old sequence of events. */ val updatedUserSession: UserSession = value .map(newEvent =\u0026gt; UserSession(newEvent +: existingEvents)) .getOrElse(UserSession(existingEvents)) /* Look for the end event. If found, return the final `UserSession`, If not, update the internal state and return `None` */ updatedUserSession.userEvents.find(_.isLast) match { case Some(_) =\u0026gt; state.remove() Some(updatedUserSession) case None =\u0026gt; state.update(updatedUserSession) None } } 对于 mapWithState 的每次迭代：\n如果这是我们的第一次迭代，则状态将为空。我们需要创建它并追加新事件。如果不是，那么事件已经存在，请从 State[UserSession] 中提取它们，然后将新事件与旧事件一起添加。 查找 isLast 事件标志。如果存在，请删除 UserSession 状态并返回 Option[UserSession]。否则，更新状态并返回 None。 返回 Option[UserSession] 转换的选择取决于我们。我们可以选择返回 Unit 并从 mapWithState 发送完整的 UserSession，就像使用 updateStateByKey 一样。但是，我更喜欢我们可以将 UserSession 传递给另一个转换，以根据需要执行更多工作。\n我们的新Spark DAG现在看起来像这样：\nval stateSpec = StateSpec.function(updateUserEvents _) kafkaStream .map(deserializeUserEvent) .mapWithState(stateSpec) 但是，还需要添加一件事。 由于我们没有将 UserSession 保存在转换中，因此我们需要添加其他转换以将其存储在持久性存储中。 为此，我们可以使用 foreachRDD：\nkafkaStream .map(deserializeUserEvent) .mapWithState(stateSpec) .foreachRDD { rdd =\u0026gt; if (!rdd.isEmpty()) { rdd.foreach(maybeUserSession =\u0026gt; maybeUserSession.foreach(saveUserSession)) } } (如果您不想为 RDD 中的每个值打开与基础持久性存储的连接，那么请考虑使用 rdd.foreachPartition 而不是 rdd.foreach（但这超出了本文的范围)\n超时结束 实际上，当处理大量数据时，我们必须保护自己免受数据丢失的影响。在当前的实现中，如果 isLast 甚至都没有显示，我们最终将使用户操作“停留”在该状态。\n添加超时很简单：\n构造 StateSpec 时添加超时。 处理有状态转换中的超时。 第一步很容易达到：\nimport org.apache.spark.streaming._ val stateSpec = StateSpec .function(updateUserEvents _) .timeout(Minutes(5)) (Minutes 是 Scala 的 Duration 类的 Spark 包装器类。)\n对于我们的 updateUserEvents，我们需要监视 State[S].isTimingOut 标志以了解我们正在超时。关于超时，我想提两件事：\n重要的是要注意，一旦发生超时，我们的 value 参数将为 None（解释为什么我们会收到 Option[S] 而不是 S 来获得值。有关更多信息，请参见此处）。 如果由于超时而调用 mapWithState，则我们不能调用 state.remove()，它将由框架代表我们完成。从 State.remove 的文档中： 如果状态已被删除（即 remove() 已经被调用）或由于超时而将被删除（即 isTimingOut() 为 true），则无法更新状态。\n让我们修改代码：\ndef updateUserEvents(key: Int, value: Option[UserEvent], state: State[UserSession]): Option[UserSession] = { def updateUserSession(newEvent: UserEvent): Option[UserSession] = { val existingEvents: Seq[UserEvent] = state .getOption() .map(_.userEvents) .getOrElse(Seq[UserEvent]()) val updatedUserSession = UserSession(newEvent +: existingEvents) updatedUserSession.userEvents.find(_.isLast) match { case Some(_) =\u0026gt; state.remove() Some(updatedUserSession) case None =\u0026gt; state.update(updatedUserSession) None } } value match { case Some(newEvent) =\u0026gt; updateUserSession(newEvent) case _ if state.isTimingOut() =\u0026gt; state.getOption() } } 我已将用户操作的更新提取到本地方法 updateUserSession 中，如果由于新的传入值而调用该方法，则将调用该方法。否则，我们将超时，需要返回到目前为止累积的用户事件。\n包装起来 希望我能传达出 Spark 有状态流的一般用法。有状态流，尤其是新的 mapWithState 转换为希望使用 Spark 处理有状态数据的最终用户带来了强大的功能，同时享受了 Spark 带来的弹性，分布和容错能力的保证。\n在即将发布的 Spark 2.0.0 发行版中，还有更多改进，例如状态版本控制，这将使我们能够标记累积的数据，并且仅保留所存储状态的一个子集。如果您对更多内容感兴趣，请参阅“用于流聚合的状态存储”建议。\n如果您想玩转，可以在 GitHub 上找到包含代码的完整工作库。\n此外，此 DataBricks 帖子中对 updateStateByKey 和 mapWithState 性能特征进行了很好的比较。\n"},"name":"探索 Apache Spark 中的状态流","published":"2019-11-22T17:51:31Z","summary":"更新(2017.08.01): Spark v2.2 最近推出了一个叫做 mapGroupsWithState 的有状态流的新抽象, 我最近有一篇博客也是关于它的。我强烈建议你检查一下。\n介绍 Apache Spark 由几个模块组成，每个模块都有不同的用途。 它的功能强大的模块之一是 Streaming API，它使开发人员能够在称为 Discretized Stream 或 DStream 的抽象下使用连续流（或准确地说是微批次）。\n在这篇文章中，我将深入探讨 Spark Streaming 的一个特殊属性，它是有状态的 Streaming API。 有状态流使我们能够维护微批之间的状态，从而使我们能够形成数据的会话化。\n免责声明-为了遵循本文的流程，应该对 Spark 的工作原理有基本的了解，并对 DStream 抽象具有一般的了解。 如果没有，请继续阅读，不用担心，我会等你\u0026hellip;\n欢迎回来！ 让我们继续。\n通过例子理解 为了了解如何使用 API​​，让我们创建一个简单的传入数据示例，该示例要求我们进行会话化。我们的输入数据流将是 UserEvent 类型：\ncase class UserEvent(id: Int, data: String, isLast: Boolean) 每个事件描述一个唯一的用户。我们通过用户 ID 标识用户，并用 String 表示发生的事件的内容。我们还想知道用户何时结束会话，因此我们提供了一个 isLast 标志来指示会话结束。\n我们负责汇总所有用户事件的状态将是 UserSession 类型的状态：\ncase class UserSession(userEvents: Seq[UserEvent]) 其中包含特定用户发生的事件序列。在此示例中，我们假设数据源是来自于 Kafka 使用的 JSON 编码数据流。\n我们的 Id 属性将用作键，而 UserEvent 将是我们的值。两个放在一块，我们得到一个 DStream[(Int, UserEvent)]。","type":"entry","url":"https://ohmycloud.github.io/notes/exploring-stateful-streaming-with-apache-spark/"}