{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"content":{"html":"\u003ch1 id=\"raku-与-postgresql-的连接性一览\"\u003eRaku 与 PostgreSQL 的连接性一览\u003c/h1\u003e\n\u003cp\u003e在我看来，Raku 是一门伟大的语言，我每天都在使用它，而且越来越多。我可以说它将取代我的 Perl 脚本。\u003c/p\u003e\n\u003cp\u003eRaku 有一个广泛的模块库，当然包括数据库连接，这反过来又包括连接 PostgreSQL 的功能。\n在这篇简单的文章中，我将快速演示如何使用 Raku 的一段代码来完成许多比数据库应用程序还琐碎的任务。\n脚本是以增量的方式呈现的，所以连接数据库部分必须始终作为脚本的前言。\u003c/p\u003e\n\u003cp\u003eDB::Pg 模块在某种程度上与 Perl 5 的 DBD::Pg 很相似，所以很多概念和方法名都会让人想起后者。\u003c/p\u003e\n\u003ch2 id=\"安装方法\"\u003e安装方法\u003c/h2\u003e\n\u003cp\u003e可以使用 zef 来安装 DB::Pg 模块。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e% zef install DB::Pg\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e根据你的系统速度和已经安装的库，可能需要几分钟的时间。\u003c/p\u003e\n\u003cp\u003e如果你要使用 LISTEN/NOTIFY，你需要同时安装 epoLl.NET 和 EPOLl.NET。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e% zef install epoll\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"连接到数据库\"\u003e连接到数据库\u003c/h2\u003e\n\u003cp\u003e现在可以使用 DB::Pg 模块连接到数据库。例如，一个简单的脚本可以接受命令行上的所有参数（清晰的文本！），可以是：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e#!raku\n\nuse DB::Pg;\n\nsub MAIN( Str :$host = 'miguel',\n          Str :$username = 'luca',\n          Str :$password = 'secet',\n          Str :$database = 'testdb' ) {\n\n    \u0026quot;Connecting $username @ $host/$database\u0026quot;.say;\n\n    my $connection = DB::Pg.new: conninfo =\u0026gt; \u0026quot;host=$host user=$username password=$password dbname=$database\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如你所见，DB::Pg模块接受一个 conninfo 字符串。\u003c/p\u003e\n\u003ch2 id=\"读取查询和结果\"\u003e读取查询和结果\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e.query\u003c/code\u003e 方法允许向数据库发出读取查询。结果是一个 Result 类对象，它可以通过不同的方法来使用，最著名的是 \u003ccode\u003e.hash\u003c/code\u003e 和 \u003ccode\u003e.arrays\u003c/code\u003e，它们返回一连串的 hash 或 arrays，从查询中提取的每一行都有一个 \u003ccode\u003e.rows\u003c/code\u003e 和 \u003ccode\u003e.column\u003c/code\u003e 等特殊方法分别提供了查询返回的行数和结果集的列名。\u003c/p\u003e\n\u003cp\u003e举个例子，这里是一个简单的查询。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $query = 'SELECT current_role, current_time';\nmy $results = $connection.query: $query;\n\nsay \u0026quot;The query { $query } returned { $results.rows } rows with columns: { $results.columns.join( ', ' ) }\u0026quot;;\nfor $results.hashes -\u0026gt; $row {\n    for $row.kv -\u0026gt; $column, $value {\n        say \u0026quot;Column $column = $value\u0026quot;;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上面这段代码提供了一个类似于下面的输出。\u003c/p\u003e\n\u003cp\u003e查询 \u003ccode\u003eSELECT current_role, current_time\u003c/code\u003e 返回1行，列数为： current_role, current_time。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eColumn current_role = luca\nColumn current_time = 14:48:47.147983+02\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"光标\"\u003e光标\u003c/h2\u003e\n\u003cp\u003e默认情况下，\u003ccode\u003e.query\u003c/code\u003e 方法将从查询中获取所有的行，这对于较大的数据集来说是一个问题。可以使用 \u003ccode\u003e.cursor\u003c/code\u003e 方法，它可以接受可选的批量大小（默认为1000个元组），并可选地接受将结果获取为哈希序列的指定器。\u003c/p\u003e\n\u003cp\u003e作为一个简单的例子。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003efor $connection.cursor( 'select * from raku', fetch =\u0026gt; 2, :hash ) -\u0026gt; %row {\n    say \u0026quot;====================\u0026quot;;\n    for %row.kv -\u0026gt; $column, $value {\n        say \u0026quot;Column [ $column ] = $value\u0026quot;;\n    }\n    say \u0026quot;====================\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e产生和输出像这样的东西。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e====================\nColumn [ pk ] = 2\nColumn [ t ] = This is value 0\n====================\n====================\nColumn [ pk ] = 3\nColumn [ t ] = This is value 1\n====================\n====================\nColumn [ t ] = This is value 2\nColumn [ pk ] = 4\n====================\n====================\nColumn [ pk ] = 5\nColumn [ t ] = This is value 3\n====================\n...\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"撰写声明\"\u003e撰写声明\u003c/h2\u003e\n\u003cp\u003e编写语句可以通过 \u003ccode\u003e.execute\u003c/code\u003e 方法来执行，如:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e$connection.execute: q\u0026lt; insert into raku( t ) values( 'Hello World' )\u0026gt;;\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"交易和编制报表\"\u003e交易和编制报表\u003c/h2\u003e\n\u003cp\u003e为了处理事务，你需要访问被\u0026quot;屏蔽\u0026quot;到 DB::Pg 主对象中的数据库处理程序。数据库对象像往常一样提供了 \u003ccode\u003e.begin\u003c/code\u003e、\u003ccode\u003e.rollback\u003c/code\u003e、\u003ccode\u003e.commit\u003c/code\u003e等方法。\u003c/p\u003e\n\u003cp\u003e此外，还可以使用 \u003ccode\u003e.prepare\u003c/code\u003e 方法来获得一个已准备好的语句，该语句可以被缓存并用于循环和重复性任务中。值得注意的是，\u003ccode\u003e.prepare\u003c/code\u003e 方法使用了 \u003ccode\u003e$1\u003c/code\u003e、\u003ccode\u003e$2\u003c/code\u003e 等参数占位符，当语句接受单个值时，必须在 \u003ccode\u003e.execute\u003c/code\u003e 中不指定索引。\u003c/p\u003e\n\u003cp\u003e举个例子\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $database-handler = $connection.db;\nmy $statement = $database-handler.prepare: 'insert into raku( t ) values( $1 )';\n\n$database-handler.begin;\n$statement.execute( \u0026quot;This is value $_\u0026quot; )  for 0 .. 10;\n$database-handler.commit;\n$database-handler.finish;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述循环相当于一个SQL事务，如:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"k\"\u003eBEGIN\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"k\"\u003eINTO\u003c/span\u003e \u003cspan class=\"n\"\u003eraku\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eVALUES\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;This is value 0\u0026#39;\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"k\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"k\"\u003eINTO\u003c/span\u003e \u003cspan class=\"n\"\u003eraku\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eVALUES\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;This is value 1\u0026#39;\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"k\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"k\"\u003eINTO\u003c/span\u003e \u003cspan class=\"n\"\u003eraku\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eVALUES\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;This is value 2\u0026#39;\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003cspan class=\"k\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"k\"\u003eINTO\u003c/span\u003e \u003cspan class=\"n\"\u003eraku\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eVALUES\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;This is value 10\u0026#39;\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"k\"\u003eCOMMIT\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003e.finish\u003c/code\u003e 方法是必需的，因为 DB::Pg 处理缓存。请注意，\u003ccode\u003e.commit\u003c/code\u003e 和 \u003ccode\u003e.rollback\u003c/code\u003e 方法是流畅的，并返回一个对象实例，这样你就可以调用 \u003ccode\u003e.commit.finish\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"数据库与连接\"\u003e数据库与连接\u003c/h2\u003e\n\u003cp\u003e缓存的处理方式是，当发出一个查询时，会打开一个新的连接并使用。一旦工作完成，连接就会返回到内部池中。DB::Pg::Database 对象做的工作和 DB::Pg 的一样，不同的是它不会自动将连接返回到池中，所以需要自己进行 \u003ccode\u003e.\u003c/code\u003e 完成。\u003c/p\u003e\n\u003cp\u003e因此，你可以在两个对象上使用相同的 \u003ccode\u003e.query\u003c/code\u003e 和 \u003ccode\u003e.execute\u003c/code\u003e 方法，但 DB::Pg 会自动将连接返回到内部池中，而数据库对象则允许你对何时将连接返回到池中进行细粒度的控制。\u003c/p\u003e\n\u003ch2 id=\"复制\"\u003e复制\u003c/h2\u003e\n\u003cp\u003ePostgreSQL 提供了特殊的 COPY 命令，可以用来复制从和进入。有一个方法 \u003ccode\u003e.copy-in\u003c/code\u003e 可以执行 \u003ccode\u003eCOPY FROM\u003c/code\u003e，而 \u003ccode\u003eCOPY TO\u003c/code\u003e 可以在迭代循环中使用。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $file = '/tmp/raku.csv'.IO.open: :w;\nfor $connection.query: 'COPY raku TO stdout (FORMAT CSV)'  -\u0026gt; $row {\n    $file.print: $row;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e以上将 CSV 结果导出到文本文件上。\n如果要读回数据，可以发出 \u003ccode\u003e.copy-in\u003c/code\u003e 方法，但首先需要发出 \u003ccode\u003eSQL COPY\u003c/code\u003e。工作流程是\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eissue a COPY FROM STDIN;\nuse .copy-data to slurp all the data;\nuse .copy-end to notify the database that the COPY is concluded.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e对.copy-end的需求是一个建议：可以在一次运行中发出不同的.copy-data，例如从不同文件中导入数据。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e$database-handler = $connection.db;\n$database-handler.query: 'COPY raku FROM STDIN (FORMAT CSV)';\n$database-handler.copy-data:  '/tmp/raku1.csv'.IO.slurp;\n$database-handler.copy-data:  '/tmp/raku2.csv'.IO.slurp;\n$database-handler.copy-end;\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"转换器\"\u003e转换器\u003c/h2\u003e\n\u003cp\u003e可以指定转换器，即处理进出数据库的值的特殊角色；这让我想起了 DBI::Class 的 \u003ccode\u003einflate\u003c/code\u003e 和 \u003ccode\u003edeflate\u003c/code\u003e 选项。\n第一步是在 \u003ccode\u003eDB::Pg\u003c/code\u003e 中给转换器实例添加一个角色，这样的实例必须。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e增加一个新的类型转换方法。\u003c/li\u003e\n\u003cli\u003e增加一个转换方法来处理类型字符串化的值，并返回新值（在任何 Raku 实例中）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e作为一个例子，下面将一个文本 PostgreSQL 类型转换为一个 Str Raku 对象，并在其内容上进行反转。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e$connection.converter does role fluca-converter\n{\n    submethod BUILD { self.add-type( text =\u0026gt; Str ) }\n    multi method convert( Str:U, Str:D $value) {\n        $value.flip.uc;\n    }\n\n}\n\n.say for $connection.query( 'select * from raku' ).arrays;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e产生类似于的输出。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[442 DLROW OLLEH]\n[454 DLROW OLLEH]\n[466 DLROW OLLEH]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e其中字符串 Hello World 被翻转。\u003c/p\u003e\n\u003ch2 id=\"listen-和-notify\"\u003elisten 和 notify\u003c/h2\u003e\n\u003cp\u003eDB::Pg也可以处理LISTEN和NOTIFY，它们能够与Raku的react动态功能进行交互。\n首先，创建一个简单的机制来通知一些事件。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003etestdb=\u0026gt; create or replace rule r_raku_insert \n         as on insert to raku \n         do also \n         SELECT pg_notify( 'insert_event', 'INSERTING ROW(S)' );\nCREATE RULE\n\ntestdb=\u0026gt; create or replace rule r_raku_delete\n         as on delete to raku \n         do also \n         SELECT pg_notify( 'delete_event', 'DELETING ROW(S)' );\nCREATE RULE\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在，可以创建一个等待传入事件的 Raku 脚本。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003ereact {\n    whenever $connection.listen( 'delete_event' ) { .say; }\n    whenever $connection.listen( 'insert_event' ) { .say; }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e目的是，每次发出一个事件，\u003ccode\u003e.listen\u003c/code\u003e 都会将消息有效载荷传递给 react 代码块。因此，发出一些 \u003ccode\u003eDELETE\u003c/code\u003e 和 \u003ccode\u003eINSERT\u003c/code\u003e 会导致输出。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDELETING ROW(S)\nINSERTING ROW(S)\nINSERTING ROW(S)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可以通过 \u003ccode\u003e.unlisten\u003c/code\u003e 方法停止监听反应块。也可以通过 \u003ccode\u003e.notify\u003c/code\u003e 方法发出事件。\u003c/p\u003e\n\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\n\u003cp\u003eDB::Pg 是 PostgreSQL 的一个很好的驱动程序，它允许 Raku 直接在语言中利用很多功能。\u003c/p\u003e\n\u003cp\u003e文章 A glance at Raku connectivity towards PostgreSQL 已经由 Luca Ferrari 发布在博客上。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://fluca1978.github.io/2021/03/29/RakuPostgreSQL.html\"\u003ehttps://fluca1978.github.io/2021/03/29/RakuPostgreSQL.html\u003c/a\u003e\u003c/p\u003e\n","text":"Raku 与 PostgreSQL 的连接性一览 在我看来，Raku 是一门伟大的语言，我每天都在使用它，而且越来越多。我可以说它将取代我的 Perl 脚本。\nRaku 有一个广泛的模块库，当然包括数据库连接，这反过来又包括连接 PostgreSQL 的功能。 在这篇简单的文章中，我将快速演示如何使用 Raku 的一段代码来完成许多比数据库应用程序还琐碎的任务。 脚本是以增量的方式呈现的，所以连接数据库部分必须始终作为脚本的前言。\nDB::Pg 模块在某种程度上与 Perl 5 的 DBD::Pg 很相似，所以很多概念和方法名都会让人想起后者。\n安装方法 可以使用 zef 来安装 DB::Pg 模块。\n% zef install DB::Pg 根据你的系统速度和已经安装的库，可能需要几分钟的时间。\n如果你要使用 LISTEN/NOTIFY，你需要同时安装 epoLl.NET 和 EPOLl.NET。\n% zef install epoll 连接到数据库 现在可以使用 DB::Pg 模块连接到数据库。例如，一个简单的脚本可以接受命令行上的所有参数（清晰的文本！），可以是：\n#!raku use DB::Pg; sub MAIN( Str :$host = 'miguel', Str :$username = 'luca', Str :$password = 'secet', Str :$database = 'testdb' ) { \u0026quot;Connecting $username @ $host/$database\u0026quot;.say; my $connection = DB::Pg.new: conninfo =\u0026gt; \u0026quot;host=$host user=$username password=$password dbname=$database\u0026quot;; 如你所见，DB::Pg模块接受一个 conninfo 字符串。\n读取查询和结果 .query 方法允许向数据库发出读取查询。结果是一个 Result 类对象，它可以通过不同的方法来使用，最著名的是 .hash 和 .arrays，它们返回一连串的 hash 或 arrays，从查询中提取的每一行都有一个 .rows 和 .column 等特殊方法分别提供了查询返回的行数和结果集的列名。\n举个例子，这里是一个简单的查询。\nmy $query = 'SELECT current_role, current_time'; my $results = $connection.query: $query; say \u0026quot;The query { $query } returned { $results.rows } rows with columns: { $results.columns.join( ', ' ) }\u0026quot;; for $results.hashes -\u0026gt; $row { for $row.kv -\u0026gt; $column, $value { say \u0026quot;Column $column = $value\u0026quot;; } } 上面这段代码提供了一个类似于下面的输出。\n查询 SELECT current_role, current_time 返回1行，列数为： current_role, current_time。\nColumn current_role = luca Column current_time = 14:48:47.147983+02 光标 默认情况下，.query 方法将从查询中获取所有的行，这对于较大的数据集来说是一个问题。可以使用 .cursor 方法，它可以接受可选的批量大小（默认为1000个元组），并可选地接受将结果获取为哈希序列的指定器。\n作为一个简单的例子。\nfor $connection.cursor( 'select * from raku', fetch =\u0026gt; 2, :hash ) -\u0026gt; %row { say \u0026quot;====================\u0026quot;; for %row.kv -\u0026gt; $column, $value { say \u0026quot;Column [ $column ] = $value\u0026quot;; } say \u0026quot;====================\u0026quot;; } 产生和输出像这样的东西。\n==================== Column [ pk ] = 2 Column [ t ] = This is value 0 ==================== ==================== Column [ pk ] = 3 Column [ t ] = This is value 1 ==================== ==================== Column [ t ] = This is value 2 Column [ pk ] = 4 ==================== ==================== Column [ pk ] = 5 Column [ t ] = This is value 3 ==================== ... 撰写声明 编写语句可以通过 .execute 方法来执行，如:\n$connection.execute: q\u0026lt; insert into raku( t ) values( 'Hello World' )\u0026gt;; 交易和编制报表 为了处理事务，你需要访问被\u0026quot;屏蔽\u0026quot;到 DB::Pg 主对象中的数据库处理程序。数据库对象像往常一样提供了 .begin、.rollback、.commit等方法。\n此外，还可以使用 .prepare 方法来获得一个已准备好的语句，该语句可以被缓存并用于循环和重复性任务中。值得注意的是，.prepare 方法使用了 $1、$2 等参数占位符，当语句接受单个值时，必须在 .execute 中不指定索引。\n举个例子\nmy $database-handler = $connection.db; my $statement = $database-handler.prepare: 'insert into raku( t ) values( $1 )'; $database-handler.begin; $statement.execute( \u0026quot;This is value $_\u0026quot; ) for 0 .. 10; $database-handler.commit; $database-handler.finish; 上述循环相当于一个SQL事务，如:\nBEGIN; INSERT INTO raku( t ) VALUES (\u0026#39;This is value 0\u0026#39; ); INSERT INTO raku( t ) VALUES (\u0026#39;This is value 1\u0026#39; ); INSERT INTO raku( t ) VALUES (\u0026#39;This is value 2\u0026#39; ); ... INSERT INTO raku( t ) VALUES (\u0026#39;This is value 10\u0026#39; ); COMMIT; .finish 方法是必需的，因为 DB::Pg 处理缓存。请注意，.commit 和 .rollback 方法是流畅的，并返回一个对象实例，这样你就可以调用 .commit.finish。\n数据库与连接 缓存的处理方式是，当发出一个查询时，会打开一个新的连接并使用。一旦工作完成，连接就会返回到内部池中。DB::Pg::Database 对象做的工作和 DB::Pg 的一样，不同的是它不会自动将连接返回到池中，所以需要自己进行 . 完成。\n因此，你可以在两个对象上使用相同的 .query 和 .execute 方法，但 DB::Pg 会自动将连接返回到内部池中，而数据库对象则允许你对何时将连接返回到池中进行细粒度的控制。\n复制 PostgreSQL 提供了特殊的 COPY 命令，可以用来复制从和进入。有一个方法 .copy-in 可以执行 COPY FROM，而 COPY TO 可以在迭代循环中使用。\nmy $file = '/tmp/raku.csv'.IO.open: :w; for $connection.query: 'COPY raku TO stdout (FORMAT CSV)' -\u0026gt; $row { $file.print: $row; } 以上将 CSV 结果导出到文本文件上。 如果要读回数据，可以发出 .copy-in 方法，但首先需要发出 SQL COPY。工作流程是\nissue a COPY FROM STDIN; use .copy-data to slurp all the data; use .copy-end to notify the database that the COPY is concluded. 对.copy-end的需求是一个建议：可以在一次运行中发出不同的.copy-data，例如从不同文件中导入数据。\n$database-handler = $connection.db; $database-handler.query: 'COPY raku FROM STDIN (FORMAT CSV)'; $database-handler.copy-data: '/tmp/raku1.csv'.IO.slurp; $database-handler.copy-data: '/tmp/raku2.csv'.IO.slurp; $database-handler.copy-end; 转换器 可以指定转换器，即处理进出数据库的值的特殊角色；这让我想起了 DBI::Class 的 inflate 和 deflate 选项。 第一步是在 DB::Pg 中给转换器实例添加一个角色，这样的实例必须。\n 增加一个新的类型转换方法。 增加一个转换方法来处理类型字符串化的值，并返回新值（在任何 Raku 实例中）。  作为一个例子，下面将一个文本 PostgreSQL 类型转换为一个 Str Raku 对象，并在其内容上进行反转。\n$connection.converter does role fluca-converter { submethod BUILD { self.add-type( text =\u0026gt; Str ) } multi method convert( Str:U, Str:D $value) { $value.flip.uc; } } .say for $connection.query( 'select * from raku' ).arrays; 产生类似于的输出。\n[442 DLROW OLLEH] [454 DLROW OLLEH] [466 DLROW OLLEH] 其中字符串 Hello World 被翻转。\nlisten 和 notify DB::Pg也可以处理LISTEN和NOTIFY，它们能够与Raku的react动态功能进行交互。 首先，创建一个简单的机制来通知一些事件。\ntestdb=\u0026gt; create or replace rule r_raku_insert as on insert to raku do also SELECT pg_notify( 'insert_event', 'INSERTING ROW(S)' ); CREATE RULE testdb=\u0026gt; create or replace rule r_raku_delete as on delete to raku do also SELECT pg_notify( 'delete_event', 'DELETING ROW(S)' ); CREATE RULE 现在，可以创建一个等待传入事件的 Raku 脚本。\nreact { whenever $connection.listen( 'delete_event' ) { .say; } whenever $connection.listen( 'insert_event' ) { .say; } } 目的是，每次发出一个事件，.listen 都会将消息有效载荷传递给 react 代码块。因此，发出一些 DELETE 和 INSERT 会导致输出。\nDELETING ROW(S) INSERTING ROW(S) INSERTING ROW(S) 可以通过 .unlisten 方法停止监听反应块。也可以通过 .notify 方法发出事件。\n总结 DB::Pg 是 PostgreSQL 的一个很好的驱动程序，它允许 Raku 直接在语言中利用很多功能。\n文章 A glance at Raku connectivity towards PostgreSQL 已经由 Luca Ferrari 发布在博客上。\n原文链接: https://fluca1978.github.io/2021/03/29/RakuPostgreSQL.html\n"},"name":"Psql","published":"2021-04-05T00:00:00+08:00","summary":"Psql","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-04-05-psql/"}