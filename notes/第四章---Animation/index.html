<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
    
    
    

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    
    <meta name="referrer" content="no-referrer">

    <title>
        
            iOS 动画 ❚ 焉知非鱼
        
    </title>

    
    


    
    
    
    

    
    
    
    

    
    
    

    
    
    
    <style>
     
     
     :root {
         --theme-color: #ac4142;
         --theme-color-light: rgba(172, 65, 66, 0.2);
     }
     
     html {
         line-height: 1.5;
     }
    </style>

    
    

    
    
    
    
    <link rel="stylesheet" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css">
    
    <link rel="preload" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css" as="style">

    



    
        <style>
         
         /* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }

         
         /* Overrides on top of the theme and Chroma CSS */
/* Chroma-based lines highlighting in code blocks */
.chroma .hl {
    background-color: #e8e8e8;
    /* Extend highlight up to 100 characters (assuming that the code blocks never have more than 100 characters in a line) */
    min-width: 100ch;
}
/* GenericHeading */ .chroma .gh { color: #999999; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa; font-weight: bold }

         
        </style>
    

    

    
    
    

    
    <script src="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js"></script>
    
    <link rel="preload" href="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js" as="script">

    
    
    <script defer src="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js"></script>
    
    <link rel="preload" href="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js" as="script">

    

    

    
    
    

    
    
<!-- rel="me" links for IndieAuth -->







    
 
<meta property="og:title" content="iOS 动画" />
<meta property="og:description"
      content="Learning Animation" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ohmycloud.github.io/notes/%E7%AC%AC%E5%9B%9B%E7%AB%A0---animation/" />


    
        <meta property="article:published_time" content="2016-11-03T16:16:21&#43;00:00"/>
    
    
        <meta property="article:modified_time" content="2016-11-03T16:16:21&#43;00:00"/>
    









    




     <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="iOS 动画"/>
<meta name="twitter:description" content="Learning Animation"/>


    
    
    <link rel="alternate" type="application/jf2post+json" href="https://ohmycloud.github.io/notes/%E7%AC%AC%E5%9B%9B%E7%AB%A0---animation/jf2post.json" title="Jf2post for 焉知非鱼" />
    
     



    
    
    
        
    


     
        
        <meta name="DC.Creator" content="焉知非鱼"/>
    



    
    
    
    <meta name="hugo-build-date" content="2024-03-01T16:16:06Z"/>
    <meta name="hugo-commit-hash" content="312735366b20d64bd61bff8627f593749f86c964"/>
    <meta name="generator" content="Hugo 0.123.7">
</head>


    
        <body lang="en">
    

        
        <div class="border" id="home"></div>

        <div class="wrapper">   
            
<nav id="nav" class="nav-collapse opened" aria-hidden="false">
    <ul class="navbar">
        <li><a class="" href="/">Home</a></li>
        
            
                <li><a class="" href="https://ohmycloud.github.io/posts/">Posts</a></li>
            
        
            
                <li><a class="" href="https://ohmycloud.github.io/notes/">Notes</a></li>
            
        
        
            <li><a class="" href="https://ohmycloud.github.io/search/">Search</a></li>
        
    </ul>
</nav>

            <div class="container">
                <header class="masthead">
                    <div class="masthead-title no-text-decoration">
                        <a href="/">焉知非鱼</a> <span class="blinking-cursor">❚</span>
                    </div>
                    <div class="masthead-tagline">
                        Wait the light to fall
                    </div>
                </header>

                








<article class="post h-entry notes">
    <header>
        <div class="center">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>

        <h1 class="post-title p-name">iOS 动画</h1>

        
        <data class="u-url" value="https://ohmycloud.github.io/notes/%E7%AC%AC%E5%9B%9B%E7%AB%A0---animation/"></data>

        <div class="date-syndication">
            


    
    
    <div class="post-date">
        
        <time datetime="2016-11-03T16:16:21+0000" class="dt-published">Thu Nov 3, 2016</time>
        
        
    </div>


            




        </div>
         



    
    
    
        
    


    
        
        <span class="hide">
            &mdash; <a href="https://ohmycloud.github.io/" class="u-author">焉知非鱼</a>
        </span>
    


    </header>

    <div class="content">
        
    <div class="description p-summary">
        
        
        
        
        
            
            
        
        <p>Learning Animation</p>
    </div>



        





                       


        <div class="e-content">
            




<p>动画(Animation) 是属性随着时间的可变变化。变化中的属性可以是位置的: 物体移动或者改变尺寸。但是其它种类的属性也能 Animate。例如, 视图的背景色能从红色变为绿色, 不是马上的, 但是能感觉到从一种颜色渐变到另外一种颜色。或者一个视图可以从不透明变为透明, 不是立即的, 但是肉眼可以看到褪色。</p>
<p>动画花费很多计算和时间, 幸运的是你不是自己来执行动画: 你描述它, 整理它, 它会为你执行。你根据需要来获取动画。</p>
<p>要求一个动画能够像设置属性值那样简单; 有时一行代码就能设置动画:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="n">myLayer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="n">UIColor</span><span class="p">.</span><span class="n">redColor</span><span class="p">().</span><span class="n">CGColor</span> <span class="c1">// animate to red</span>
</span></span></code></pre></div><blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-bf98858e875efb01.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"> 选择模拟器的 Debug -&gt; Slow Animations 菜单可以让动画运行的更慢以帮助你检测动画的执行。</p>
</blockquote>
<h2 id="drawing-animation-and-threading">Drawing, Animation, and Threading&nbsp;<a class="headline-hash no-text-decoration" href="#drawing-animation-and-threading">#</a> </h2>
<hr>
<p>​</p>
<p>当你改变一个可见的视图属性, 那个改变不会立即可见。而是, 系统记录你想做的这个变化(change),  并把这个视图标记成需要<strong>重绘</strong>(redrawn)。然后, 当你的所有代码都完成而且系统有空闲时, 那么它就会重绘所有需要重绘的视图, 应用它们新的可见属性外貌(features)。我们把这叫做<strong>重绘时刻</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="c1">// 视图从绿色开始</span>
</span></span><span class="line"><span class="cl"><span class="n">view</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="n">UIColor</span><span class="p">.</span><span class="n">redColor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 耗时代码放在这儿</span>
</span></span><span class="line"><span class="cl"><span class="n">view</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="n">UIColor</span><span class="p">.</span><span class="n">greenColor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 代码结束, 重绘时刻</span>
</span></span></code></pre></div><p>系统累计所有想要的变化直到重绘时刻的到来, 并且重绘时刻不会发生直到你的代码完成了, 所以, 当重绘时刻确实发生了, 视图中最后一个积累的颜色变为绿色 — 它已经是它的 color 了。因此, 不管颜色变化之间有多少耗时代码, 用户一点也看不到任何颜色变化。</p>
<p>动画的工作原理也是这样, 处理过程也部分相同。当你要执行一个动画时, 动画不会出现在屏幕上直到下一个重绘时刻来临。(你可以强制动画立刻开始, 但这不常用)。</p>
<p>动画就像一种电影和卡通。所以, 当你让一个视图从位置 1 动画到位置 2, 通常有一个事件序列:</p>
<ol>
<li>重新配置视图。该视图现在被放置在位置 2,  但是还没到重绘时刻, 所以它仍然显示在位置 1 处。</li>
<li>为视图指定一个从位置 1 到位置 2的动画。</li>
<li>等剩下的代码执行完毕</li>
<li>现在到重绘的时刻了。如果没有动画, 那么该视图现在就会突然显示在位置 2 上。 但是如果有动画, 那么&quot;动画电影&quot; 就会出现。它从位置 1 开始展示视图, 所以那仍旧是用户所看到的。</li>
<li>动画继续, 然后在位置 1 和位置 2 中间的位置显示视图。</li>
<li>动画停止, 在位置 2 处显示结束视图</li>
<li>&ldquo;动画电影&quot;被移除, 视图显示在位置 2 处 — 在第一步放置它的地方。</li>
</ol>
<p>了解到&quot;动画电影&quot;和真实视图上所发生的是不同的东西是正确配置动画的关键。 新手经常抱怨的一个地方就是动画会发生跳跃, 就是动画执行的最后会跳到另外一个位置, 这跟他们的期望不符。发生这个的原因是视图没有在&quot;动画电影&quot;中匹配它最后的位置; &ldquo;跳跃&rdquo; 的发生是因为视图显示的实际位置和&quot;电影&quot;的最后一帧不匹配。</p>
<p>屏幕前面实际上没有&quot;动画电影&rdquo; — 实际上, 并不是图层(layer)自身显示到屏幕上; 它是派生出来的一个叫做显示层(<em>presentation layer</em>)。因此, 当你从位置 1 到位置 2 animate 视图或图层的位置的位置变化时, 它名义上的位置会立即变化; 同时, 显示层的位置仍旧保持不变直到重绘时刻, 然后会随着时间变化, 因为那是屏幕上实际上所绘制的, 它也是用户所看到的。</p>
<p>(图层的显示层可以通过它的 <em>presentionLayer</em> 方法访问 — 并且图层自身可以通过显示图层的 <strong>modeLayer</strong> 方法来访问, 在本章和下一章中, 我们也将访问显示层)。</p>
<p>就像真实的电影(特别是老式的卡通动画), &ldquo;动画电影&rdquo; 拥有 &ldquo;帧&rdquo;(frames)。Animated 值不会平滑和连续地变化; 它是以很小和独立的增长变化来给我们平滑连续变化的错觉。这种错觉有效, 因为设备自身也经受着周期性的迅速的, 或多或少的常规屏幕刷新, 并且不断增加的变化是在这些刷新之间平息的。Apple 调用系统组件来负责这种 &ldquo;animation server&rdquo;。</p>
<p>animation server 在单独的线程上操作。你不必担心细节, 但是你也不能忽略它。代码独立运行也可能和动画同时运行。 — 那就是多线程的意义 — 所以在动画和代码之间的沟通需要某些计划。</p>
<p>动画可以用来执行某些清理工作。其中之一就是对触摸(touches)的处理: 当动画在飞行时(in-flight), 如果代码没有在运行, 那么界面默认响应用户的触摸, 这会导致各种破坏, 因为视图会尝试响应触摸而动画仍旧在发生并且屏幕显示不匹配实际。常用的处理方式就是当你为视图设置了动画, 那就关闭该视图的对触摸的响应, 并在动画结束时把它改回来。</p>
<p>因为代码可以在设置动画之后运行或者在动画飞行过程中开始运行, 你需要关心创建有冲突的动画问题。多个动画可以被同时设置(和执行)。</p>
<p>不可抗力可能会打断动画。用户可能按下 Home 键让 app 进入后台或者在动画飞行的时候来电话。在 app 进入后台时, 系统会取消正在飞行中的动画。当 app 恢复后, 会显示动画最后的状态。但是如果你想把动画恢复到它离开的那个状态, 你需要一些精明的代码。</p>
<h2 id="image-view-and-image-animation">Image View and Image Animation&nbsp;<a class="headline-hash no-text-decoration" href="#image-view-and-image-animation">#</a> </h2>
<hr>
<p>​</p>
<p>给 <strong>UIImageView</strong> 提供一个 <strong>UIImages</strong> 数组, 作为它的 <strong>animationImages</strong> 或 <strong>highlitedAnimationImages</strong> 属性的值。这个数组代表着简单卡通的帧(frames); 当你发送 <strong>startAnimating</strong> 消息, 图片就会以 <strong>animationDuration</strong> 属性所定义的帧率轮流显示, 重复由 <strong>animationRepeatCount</strong> 属性指定的次数。(默认为 0, 意思是一直重复), 或者直到收到 <strong>stopAnimating</strong> 消息。在动画之前和之后, 该 image view 持续显示它的 <strong>image</strong>（或 highlightedImage）。</p>
<p>例如, 我们想让一个名为 Mars 的图片出现在屏幕上的某个地方并闪烁 3 次。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">mars</span> <span class="p">=</span> <span class="n">UIImage</span><span class="p">(</span><span class="n">named</span><span class="p">:</span> <span class="s">&#34;Mars&#34;</span><span class="p">)</span><span class="o">!</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 打开图形上下文</span>
</span></span><span class="line"><span class="cl">    <span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">mars</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取一个空白图像</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">empty</span> <span class="p">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">()</span><span class="o">!</span>
</span></span><span class="line"><span class="cl">    <span class="n">UIGraphicsEndImageContext</span><span class="p">()</span> <span class="c1">// 关闭图形上下文</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">arr</span> <span class="p">=</span> <span class="p">[</span><span class="n">mars</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span> <span class="n">mars</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span> <span class="n">mars</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">iv</span> <span class="p">=</span> <span class="n">UIImageView</span><span class="p">(</span><span class="n">image</span><span class="p">:</span><span class="n">empty</span><span class="p">)</span> <span class="c1">// 创建一个不含图片的 UIImageView</span>
</span></span><span class="line"><span class="cl">    <span class="n">iv</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span> <span class="p">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span> <span class="c1">// 把 UIImageView 添加到 view 上</span>
</span></span><span class="line"><span class="cl">    <span class="n">iv</span><span class="p">.</span><span class="n">animationImages</span> <span class="p">=</span> <span class="n">arr</span> <span class="c1">// 设置 UIImageView 的图片序列</span>
</span></span><span class="line"><span class="cl">    <span class="n">iv</span><span class="p">.</span><span class="n">animationDuration</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="n">iv</span><span class="p">.</span><span class="n">animationRepeatCount</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="n">iv</span><span class="p">.</span><span class="n">startAnimating</span><span class="p">()</span> <span class="c1">// 开始动画</span>
</span></span></code></pre></div><p>UIImageView 动画可以和其它类型的动画组合使用。例如, 闪烁 Mars 图片的同时向右滑动 UIImageView, 使用下一节描述的视图动画。</p>
<p>image 本身也可以是 <strong>animated image</strong>。多张图片组成了一个序列作为简单卡通的&quot;帧&quot;(frames)。使用下面的其中之一的 <strong>UIImage</strong> 类方法来创建一个 <em>animated image</em>:</p>
<ul>
<li><strong>animatedImageWithImages:duration:</strong></li>
</ul>
<p>​           就像 UIImageView 的 <strong>animationImages</strong>, 你提供一个 <strong>UIImage</strong> 的数组。你还可以提供整个动画的持续时间。</p>
<ul>
<li>
<p><strong>animatedImageNamed:duration:</strong></p>
<p>提供单个图片文件的名字, 就像 <strong>init(named:)</strong> 那样, 不带文件后缀。运行时会给你提供的图片名追加 &ldquo;0&rdquo;(失败则为 ”1“), 并把该图片设置为动画序列中的第一张图片。以此类推, 随后追加的数字自增(直到用光图片或达到 ”1024“)。</p>
</li>
<li>
<p><strong>animatedResizableImageNamed:capInsets:resizingMode:duration:</strong></p>
<p>​     把 animated image 和 resizable image 相结合</p>
</li>
</ul>
<p>animated image 可以像 UIImage 那样作为某个界面对象的属性出现在界面中的任何地方。 下面这个例子, 我构造了一个不同尺寸的红色圆形序列, 然后我在 UIBUtton 中展示这个被 animated 后的图形。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">ViewController</span><span class="p">:</span> <span class="n">UIViewController</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在 storyboard 中拖拽一个 UIButton, 并和该 b 变量连线</span>
</span></span><span class="line"><span class="cl">    <span class="kr">@IBOutlet</span> <span class="kd">var</span> <span class="nv">b</span><span class="p">:</span> <span class="n">UIButton</span><span class="p">!</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kc">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 一个跳动的红点</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="nv">arr</span> <span class="p">=</span> <span class="p">[</span><span class="n">UIImage</span><span class="p">]()</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nv">w</span> <span class="p">:</span> <span class="n">CGFloat</span> <span class="p">=</span> <span class="mi">18</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span> <span class="p">..</span><span class="o">&lt;</span> <span class="mi">6</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">),</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="kd">let</span> <span class="nv">con</span> <span class="p">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">()</span><span class="o">!</span>
</span></span><span class="line"><span class="cl">            <span class="n">CGContextSetFillColorWithColor</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">UIColor</span><span class="p">.</span><span class="n">redColor</span><span class="p">().</span><span class="n">CGColor</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="kd">let</span> <span class="nv">ii</span> <span class="p">=</span> <span class="n">CGFloat</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">CGContextAddEllipseInRect</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="o">+</span><span class="n">ii</span><span class="p">,</span><span class="mi">0</span><span class="o">+</span><span class="n">ii</span><span class="p">,</span><span class="n">w</span><span class="o">-</span><span class="n">ii</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">w</span><span class="o">-</span><span class="n">ii</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="n">CGContextFillPath</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="kd">let</span> <span class="nv">im</span> <span class="p">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="n">UIGraphicsEndImageContext</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span> <span class="o">+=</span> <span class="p">[</span><span class="n">im</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nv">im</span> <span class="p">=</span> <span class="n">UIImage</span><span class="p">.</span><span class="n">animatedImageWithImages</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span><span class="mf">0.5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">b</span><span class="p">.</span><span class="n">setImage</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">forState</span><span class="p">:.</span><span class="n">Normal</span><span class="p">)</span> <span class="c1">// b is a button in the interface</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">didReceiveMemoryWarning</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kc">super</span><span class="p">.</span><span class="n">didReceiveMemoryWarning</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Dispose of any resources that can be recreated.</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="view-animation">View Animation&nbsp;<a class="headline-hash no-text-decoration" href="#view-animation">#</a> </h2>
<hr>
<p>​</p>
<p>所有的动画最终都是图层动画(layer animation), 稍后我会在本章解释。然而, 对于有些属性, 你可以直接对 <strong>UIView</strong> 进行动画绘制: 这些属性是 <strong>alpha</strong>、 <strong>bounds</strong>、<strong>center</strong>、<strong>frame</strong> 、<strong>transform</strong> 还有(如果 那个view 没有实现 drawRect:) <strong>backgroundColor</strong>。 你也可以对 <strong>UIView</strong> 内容的变化绘制动画。</p>
<p>UIView 绘制动画的语法涉及调用一个 UIView 类方法, 并传递一个用于绘制动画的闭包。 假设我们在界面中有一个 <strong>self.v</strong> 的 UIView, 背景为黑色, 我们现在把它变红色:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="n">UIColor</span><span class="p">.</span><span class="n">redColor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></div><p>同时改变视图的颜色和位置:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="n">UIColor</span><span class="p">.</span><span class="n">redColor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></div><p>我们还可以使用同一个 <strong>animations:</strong> block 对多个视图绘制动画变化。假设我们想让一个视图溶解到另外一个视图中, 那么先让第二个视图显示在视图层级上, <strong>alpha</strong> 设置为 0, 以使它不可见。 然后我们把第一个视图的 <strong>alpha</strong> 设置为 0, 第二个视图的 <strong>alpha</strong> 设置为 1, 绘制动画。</p>
<p>那种情况下, 我们最好把视图层级中的第二个视图放在动画开始之前(不可见, 因为它的 <strong>alpha</strong> 从 0 开始)并且在动画结束时(不可见, 因为它的 <strong>alpha</strong> 以 0 结束)移除第一个视图。还有个额外的参数 <strong>completion</strong>: 用来指定动画结束后应该做点什么:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nv">v2</span> <span class="p">=</span> <span class="n">UIView</span><span class="p">(</span><span class="n">frame</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">50</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">v2</span><span class="p">.</span><span class="n">alpha</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">superView</span><span class="p">!.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">v2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">alpha</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="n">v2</span><span class="p">.</span><span class="n">alpha</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="n">completion</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kc">_</span> <span class="k">in</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">removeFromSuperview</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></div><p>现在界面中拖拽一个 UIView, 然后在控制器中声明一个名为 v , 继承自 UIView 的变量, 将它和界面中的那个视图连线。记住, **界面中的对象想要和控制器中的其它对象交互或者你需要用代码控制界面中的对象, 你需要在控制器中为该对象创建 outlet, 例如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kr">@IBOutlet</span> <span class="kd">var</span> <span class="nv">v</span><span class="p">:</span> <span class="n">UIView</span><span class="p">!</span>
</span></span></code></pre></div><blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-bf98858e875efb01.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"> 另外一种从带有动画的层级视图中移除一个视图的方法是调用 <strong>performSystemAnimation:onViews:options:animations:completion:</strong>, 第一个参数使用 <strong>。Delete</strong>（仅有的可用的第一个参数）。这会让那个视图变模糊、收缩和褪色, 之后再给它发送 <strong>removeFromSuperview</strong> 方法。</p>
</blockquote>
<p><strong>performWithoutAnimation:</strong> 方法会执行不会绘制动画的 block。下面这个伪造的例子中, 视图跳到新的位置上并慢慢变红:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="n">UIColor</span><span class="p">.</span><span class="n">redColor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">UIView</span><span class="p">.</span><span class="n">performWithoutAnimation</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></div><p>如果你在绘制动画过程中改变了视图的属性, 那么之后不应该再改变这个属性, 否则结果会让人迷惑。下面这段代码就不合逻辑:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">300</span>
</span></span></code></pre></div><p>实际发生的是这个视图向下跳跃 300 点, 然后向下绘制了 100 点的动画。那通常不是你想要的。你在 <strong>animations:</strong> block 中安排好将要被绘制动画的可动画视图属性之后, 不要再次更改视图属性的值直到动画执行完之后。</p>
<p>下面这段代码用单个动画使视图向下移动了 400 点:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">300</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></div><p>这是因为基本位置视图动画默认是可以叠加的(iOS 8 及以后)。 这意味着第二个动画和第一个动画是同时运行的, 它俩混合在一块儿。</p>
<blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-bf98858e875efb01.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"> 在新的 iOS 9 中, UIVisualEffectView 和普通的 UIView 那样也是可动画的。还有, 设置 UIVisualEffectView 的 <strong>effect</strong> 也是可动画的! 例如, 你可以在 <strong>animations:</strong> block 中把 UIVisualEffectView 的 <strong>effect</strong> 属性设置为 nil 然后设置它的 <strong>effect</strong> 属性为 <strong>UIBlurEffect</strong> 来绘制 blur 动画。</p>
</blockquote>
<h2 id="view-animation-options">View Animation Options&nbsp;<a class="headline-hash no-text-decoration" href="#view-animation-options">#</a> </h2>
<hr>
<p><em>UIView</em> 的类方法 <strong>animateWithDuration:</strong> 和  <strong>animateWithDuration:completion:</strong> 都是退化</p>
<p>了的形式。完整的形式是 <strong>animateWithDuration:delay:options:animations:completion:</strong></p>
<p>参数有:</p>
<ul>
<li><strong>duration</strong></li>
</ul>
<p>​        动画持续的时间: 动画从开始到完成花费了多长时间(以秒为单位 )。 你也可以把这个参数当作动画的速度。显而易见, 如果两个视图在同样的时间移动了不同的距离, 那么移动的更远的那个视图移动的更快。</p>
<ul>
<li><strong>delay</strong></li>
</ul>
<p>​        动画开始之前延迟的时间。默认没有延迟。延迟和应用到动画中使用的延迟执行不同; 动画是立即应用的, 但是当它空转的时候, 没有可见的变化, 直到 <strong>delay</strong> 时间过去。</p>
<ul>
<li><strong>options</strong></li>
</ul>
<p>​       组合额外选项的位掩码</p>
<ul>
<li><strong>animations</strong></li>
</ul>
<p>​      这个 block 包含了要被绘制动画的视图属性的变化。</p>
<ul>
<li><strong>completion</strong></li>
</ul>
<p>​      动画结束(或 nil)的时候运行这个 block。它接收一个 Bool 值来标示动画是否运行结束了。这个 block 含有一个标示 true 的参数以调用, 即使 <strong>animations:</strong> block 中没有任何触发动画的东西。这个块儿还能进一步指定动画, 结果就是链式动画。</p>
<p>下面是某些简明的 <strong>options:</strong> 值(UIViewAnimationOptions), 你可能用的到:</p>
<p><strong>Animation curve</strong></p>
<p>​          动画曲线(animation curve)描述了在动画期间动画的变化速度。术语 &ldquo;ease&rdquo; 的意思是在开始或结束时动画的中心速度和零速度之间是逐渐增加或减少的。至多指定一个:</p>
<ul>
<li><strong>.CurveEaseInOut</strong>(默认的)</li>
<li><strong>.CurveEaseIn</strong></li>
<li><strong>.CurveEaseOut</strong></li>
<li><strong>.CurveLinear</strong>(速度始终不变)</li>
</ul>
<p><strong>.Repeat</strong></p>
<p>​      如果包含了这个参数, 那么动画会无限重复。作为这个命令中的一部分, 没有办法去
​      指定一个明确的重复数字; 要么一直重复, 要么一点儿不重复。这看起来像是疏忽;
​      我会在之后提供一个变通方案。</p>
<p><strong>.Autoreverse</strong></p>
<p>​      如果包含了这个参数, 那么动画会从开始运行到结束(在给定的持续时间), 然后从结束运行到开始 (也是在给定持续时间)。文档中要求你只能在 repeat 不能接收时自动反转; 你可以使用其中一个或都使用(或都不使用)。</p>
<p>当使用 <strong>.Autoreverse</strong> 时, 你会想在结尾进行清除以至于当动画结束时视图能恢复到原来的位置:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nv">opts</span> <span class="p">=</span> <span class="n">UIViewAnimationOptions</span><span class="p">.</span><span class="n">Autoreverse</span>
</span></span><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">opts</span><span class="p">,</span> <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="n">completion</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
</span></span></code></pre></div><p>这个视图动画先向右移动 100 点在向左移动 100 点回到原来的位置, 最后跳回到右侧100点的位置上。原因是我们赋值给视图的 center 的 x 的最后实际值是 100 点向右, 所以当动画结束时, 视图仍旧显示 100 点向右。解决办法是在 <strong>completion:</strong> 处理中把视图移动回到它原来的位置上:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nv">opts</span>  <span class="p">=</span> <span class="n">UIViewAnimationOptions</span><span class="p">.</span><span class="n">Autoreverse</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nv">xorig</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span>
</span></span><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">opts</span><span class="p">,</span> <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="n">completion</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kc">_</span> <span class="k">in</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">xorig</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></div><p>使用一个过时的语法来设置动画重复的次数:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nv">count</span> <span class="p">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">opts</span><span class="p">,</span> <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">UIView</span><span class="p">.</span><span class="n">setAnimationRepeatCount</span><span class="p">(</span><span class="nb">Float</span><span class="p">(</span><span class="bp">count</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="n">completion</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kc">_</span> <span class="k">in</span> 
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">xorig</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></div><p>最好添加一个重复次数的参数, 在附录 B 中我会用一个类方法来扩展 UIView 给它添加一个重复次数的参数。</p>
<p>还有一些选项说明了如果另外一个动画已经指定(ordered)或正在飞行中(in-flight)会发生什么:</p>
<p><strong>.BeginFromCurrentState</strong></p>
<p>​      如果这个动画 animates 了一个之前已经指定好或<strong>in-flight</strong> 的动画 animated 过的属性, 那么不是取消之前的动画(立即完成所请求的变化),   如果它正常发生, 这个动画会使用显示层来决定从哪儿开始, 并且, 如果可能的话, 它会把它的动画和之前的动画混合在一块儿。</p>
<p><strong>.OverrideInheritedDuration</strong></p>
<p>​       阻止从周边或运动中(in-flight)的动画继承持续时间(duration), 默认是继承的。</p>
<p><strong>.OverrideInheritedCurve</strong></p>
<p>​      阻止从周边或运动中(in-flight)的动画继承动画曲线(curve), 默认是继承的。</p>
<p>iOS 7 及之前你或许会用到少量的 <strong>.BeginFromCurrentState</strong>, 因为 iOS 8 之后, 简单的视图动画默认是可叠加的。例如, 下面这段代码在 iOS 7 中如果你不使用 <strong>.BeginFromCurrentState</strong> 的话就会发生跳跃(因为我们正指定两个有冲突的视图位置的动画), 但是在 iOS 8 及之后就是单个流畅的对角线动画:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animatedWithDuration</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animatedWithDuration</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></div><p>为了看动画叠加的意思是什么, 尝试下面这段代码:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nv">opts</span> <span class="p">=</span> <span class="n">UIViewAnimationOptions</span><span class="p">.</span><span class="n">BeginFromCurrentState</span>
</span></span><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">opts</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span> <span class="n">completion</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="canceling-a-view-animation">Canceling a View Animation&nbsp;<a class="headline-hash no-text-decoration" href="#canceling-a-view-animation">#</a> </h2>
<hr>
<p>视图动画正在运行时你怎么取消它?  为了方便解释, 我把视图的原始位置和最终位置保存到了属性中:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kc">self</span><span class="p">.</span><span class="n">pOrig</span>    <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span>
</span></span><span class="line"><span class="cl"><span class="kc">self</span><span class="p">.</span><span class="n">pFinal</span>   <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span>
</span></span><span class="line"><span class="cl"><span class="kc">self</span><span class="p">.</span><span class="n">pFinal</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">pFinal</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></div><p>现在假想在动画执行期间有一个按钮, 按下按钮会取消动画。 我们怎么做到?</p>
<p>一种可能是我们到 CALayer 层并调用 <code>removeAllAnimations</code> 方法。(如果那个 layer 拥有不止一个动画, 而你只想移除它们中的一个, 你可以调用 <code>removeAnimationForKey:</code>方法; 我会在本章的后面谈论如何通过 key 来区分 layer 动画)。移除所有的动画实在是简明扼要, 但是缺点是它简单地让动画彻底停止了, 视图会跳转到它最后被设定的位置上, 和 app 进入后台系统自动调用的一样:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">removeAllAnimations</span><span class="p">()</span>
</span></span></code></pre></div><p>如果我们使用 <strong>removeAllAnimations</strong> 那么视图就会跳到它最后的位置上; 我们想让它在此刻保持在当前位置上 — 即动画的当前位置。那个位置是当前显示层所在的位置。因此我们重新配置位于它的显示层的位置的视图, 然后移除那个动画, 再然后执行最后的&quot;赶快回家&quot;动画:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl">    <span class="c1">// unrecognized selector sent to instance 0x7fc288eaf160&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 要把 Selector 中的方法放在 viewDidLoad 这个方法的外面,还要注意方法后不能有冒号(如果方法中不需要传递按钮本身这个参数)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">func</span> <span class="nf">cancelAnimate</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">presentationLayer</span><span class="p">()</span> <span class="k">as</span><span class="p">!</span> <span class="n">CALayer</span><span class="p">).</span><span class="n">position</span>
</span></span><span class="line"><span class="cl">        <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">removeAllAnimations</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="n">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">pFinal</span>
</span></span><span class="line"><span class="cl">        <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>如果取消动画意味着视图回到原来的位置, 那么把视图的 <strong>center</strong> 设置为 <strong>self.pOrig</strong> 而非 <strong>self.pFinal</strong>。如果你想把动画停在当前它运行到的位置上, 那么就省略最后一个动画。(即 0.1 的那个)</p>
<p>如果我们要取消的动画是无限重复自动反转的呢:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kc">self</span><span class="p">.</span><span class="n">pOrig</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nv">opts</span><span class="p">:</span> <span class="n">UIViewAnimationOptions</span> <span class="p">=</span> <span class="p">[.</span><span class="n">Autoreverse</span><span class="p">,</span> <span class="p">.</span><span class="nb">Repeat</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">opts</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span> <span class="n">completion</span><span class="p">:</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>那种情况下显示另外一个动画足够了, 因为新的动画不会和第一个动画叠加。只有简单视图动画是可叠加的, 什么是简单动画? 有一点必须是&quot;非重复的&quot;。因此, 第二个动画取消了第一个动画。下面通过快速把它返回到它原来的位置上来取消第一个动画:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="n">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">.</span><span class="n">BeginFromCurrentState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">animations</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kc">self</span><span class="p">.</span><span class="n">v</span><span class="p">.</span><span class="n">center</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">pOrig</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span> <span class="n">completion</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
</span></span></code></pre></div><p>这是 <strong>.BeginFromCurrentState</strong> 大显身手的地方! 它阻止了视图立即跳到右侧 100点最后的位置, 而是把它设置为初始的重复动画。</p>
<h2 id="custom-animatable-view-properties">Custom Animatable View Properties&nbsp;<a class="headline-hash no-text-decoration" href="#custom-animatable-view-properties">#</a> </h2>
<hr>
<p>你可以为自定义的视图属性绘制动画。</p>


        </div>
    </div>
</article>



                <footer>
                    




<div class="no-text-decoration">
    <div class="jump top"><a href="#" title="Top of this page">⮉</a></div>
    <div class="jump bottom"><a href="#bottom" title="Bottom of this page">⮋</a></div>
</div>


 
    
        <div class="hugotoc no-text-decoration">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#drawing-animation-and-threading">Drawing, Animation, and Threading</a></li>
    <li><a href="#image-view-and-image-animation">Image View and Image Animation</a></li>
    <li><a href="#view-animation">View Animation</a></li>
    <li><a href="#view-animation-options">View Animation Options</a></li>
    <li><a href="#canceling-a-view-animation">Canceling a View Animation</a></li>
    <li><a href="#custom-animatable-view-properties">Custom Animatable View Properties</a></li>
  </ul>
</nav>
            <a href="#" class="back-to-top">Back to top</a>
        </div>
    
    
<script src="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js"></script>

<link rel="preload" href="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js" as="script">

<script type="application/javascript">(function() {
     var $window = $(window);
     if ($window.width() >= 1400) { 
         var $toc = $('#TableOfContents');
         if ($toc.length > 0) {
             function onScroll(){
                 var currentScroll = $window.scrollTop();
                 var h = $('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .h-feed h2');
                 var id = "";
                 h.each(function (i, e) {
                     e = $(e);
                     if (e.offset().top - 10 <= currentScroll) {
                         id = e.attr('id');
                     }
                 });
                 var current = $toc.find('a.current');
                 if (current.length == 1 && current.eq(0).attr('href') == '#' + id) return true;

                 current.each(function (i, e) {
                     $(e).removeClass('current').siblings('ul').hide();
                 });
                 $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                     $(e).children('a').addClass('current').siblings('ul').show();
                 });
             }
             $window.on('scroll', onScroll);
             $(document).ready(function() {
                 $toc.find('a').parent('li').find('ul').hide();
                 onScroll();
                 document.getElementsByClassName('hugotoc')[0].style.display = '';
             });}}})();</script>








<div class="backtotop center no-text-decoration">
    <a href="#">back to <span class="top">top</span></a>
</div>


<div class="right">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>
<div class="clear-float"></div>



<div class="prev-next-navigator clear-float">
    
        <span class="prev-post left no-text-decoration">
            <a href="https://ohmycloud.github.io/notes/%E9%81%8D%E5%8E%86%E6%97%A5%E6%9C%9F/" class="nobr">« 使用 shell 遍历日期</a>
        </span>
    
    
        <span class="next-post right no-text-decoration">
            <a href="https://ohmycloud.github.io/notes/%E7%AC%AC%E4%B8%80%E7%AB%A0-views/" class="nobr">iOS 视图 »</a>
        </span>
    
</div>


<a id="bottom"></a>









                       







                    <ul class="no-bullets feed right inline">
    
        
        
    
</ul>
<div class="clear-float"></div>

                </footer>
                <hr />
            </div>               

            <footer> 
                

<ul class="social no-text-decoration">
    
</ul>










 
    
    



<p class="generated no-text-decoration">
    Generated using  <a href="https://gitlab.com/kaushalmodi/hugo-theme-refined"><code class="nobr">hugo-theme-refined</code></a> + <span class="nobr">Hugo <a href="https://github.com/gohugoio/hugo/commit/312735366b20d64bd61bff8627f593749f86c964">0.123.7</a></span>
</p>

<p>
    
</p>




<div class="badges no-text-decoration">
    
    

    
</div>




<script type="application/javascript">var nav=responsiveNav("#nav");</script>




<script defer src="/js/libs/fragmentions/wrapper.min.e8c468c89edc4f5dccaa8c720c6b220b3088a16cd7b1e4a1e3345985788260c9.js"></script>









            </footer>
        </div> 
    </body>
</html>
