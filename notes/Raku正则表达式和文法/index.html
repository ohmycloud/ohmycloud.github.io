<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
    
    
    

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    
    <meta name="referrer" content="no-referrer">

    <title>
        
            Raku 的正则表达式和文法 ❚ 焉知非鱼
        
    </title>

    
    


    
    
    
    

    
    
    
    

    
    
    

    
    
    
    <style>
     
     
     :root {
         --theme-color: #ac4142;
         --theme-color-light: rgba(172, 65, 66, 0.2);
     }
     
     html {
         line-height: 1.5;
     }
    </style>

    
    

    
    
    
    
    <link rel="stylesheet" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css">
    
    <link rel="preload" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css" as="style">

    



    
        <style>
         
         /* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }

         
         /* Overrides on top of the theme and Chroma CSS */
/* Chroma-based lines highlighting in code blocks */
.chroma .hl {
    background-color: #e8e8e8;
    /* Extend highlight up to 100 characters (assuming that the code blocks never have more than 100 characters in a line) */
    min-width: 100ch;
}
/* GenericHeading */ .chroma .gh { color: #999999; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa; font-weight: bold }

         
        </style>
    

    

    
    
    

    
    <script src="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js"></script>
    
    <link rel="preload" href="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js" as="script">

    
    
    <script defer src="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js"></script>
    
    <link rel="preload" href="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js" as="script">

    

    

    
    
    

    
    
<!-- rel="me" links for IndieAuth -->







    
 
<meta property="og:title" content="Raku 的正则表达式和文法" />
<meta property="og:description"
      content=" " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ohmyweekly.github.io/notes/raku%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%87%E6%B3%95/" />


    
        <meta property="article:published_time" content="2018-12-15T17:51:05&#43;00:00"/>
    
    
        <meta property="article:modified_time" content="2018-12-15T17:51:05&#43;00:00"/>
    









    




     <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Raku 的正则表达式和文法"/>
<meta name="twitter:description" content=" "/>


    
    
    <link rel="alternate" type="application/jf2post+json" href="https://ohmyweekly.github.io/notes/raku%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%87%E6%B3%95/jf2post.json" title="Jf2post for 焉知非鱼" />
    
     



    
    
    
        
    


     
        
        <meta name="DC.Creator" content="焉知非鱼"/>
    



    
    
    
    <meta name="hugo-build-date" content="2024-03-01T16:16:06Z"/>
    <meta name="hugo-commit-hash" content="312735366b20d64bd61bff8627f593749f86c964"/>
    <meta name="generator" content="Hugo 0.123.7">
</head>


    
        <body lang="en">
    

        
        <div class="border" id="home"></div>

        <div class="wrapper">   
            
<nav id="nav" class="nav-collapse opened" aria-hidden="false">
    <ul class="navbar">
        <li><a class="" href="/">Home</a></li>
        
            
                <li><a class="" href="https://ohmyweekly.github.io/posts/">Posts</a></li>
            
        
            
                <li><a class="" href="https://ohmyweekly.github.io/notes/">Notes</a></li>
            
        
        
            <li><a class="" href="https://ohmyweekly.github.io/search/">Search</a></li>
        
    </ul>
</nav>

            <div class="container">
                <header class="masthead">
                    <div class="masthead-title no-text-decoration">
                        <a href="/">焉知非鱼</a> <span class="blinking-cursor">❚</span>
                    </div>
                    <div class="masthead-tagline">
                        Wait the light to fall
                    </div>
                </header>

                








<article class="post h-entry notes">
    <header>
        <div class="center">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>

        <h1 class="post-title p-name">Raku 的正则表达式和文法</h1>

        
        <data class="u-url" value="https://ohmyweekly.github.io/notes/raku%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%87%E6%B3%95/"></data>

        <div class="date-syndication">
            


    
    
    <div class="post-date">
        
        <time datetime="2018-12-15T17:51:05+0000" class="dt-published">Sat Dec 15, 2018</time>
        
        
    </div>


            




        </div>
         



    
    
    
        
    


    
        
        <span class="hide">
            &mdash; <a href="https://ohmyweekly.github.io/" class="u-author">焉知非鱼</a>
        </span>
    


    </header>

    <div class="content">
        


        





                       


        <div class="e-content">
            




<h2 id="前所未有的表现力-图片不可用httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceimages128px-cameliasvgpng"><strong>前所未有的表现力</strong> <img src="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/images/128px-Camelia.svg.png" alt="图片不可用">&nbsp;<a class="headline-hash no-text-decoration" href="#前所未有的表现力-图片不可用httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceimages128px-cameliasvgpng">#</a> </h2>
<p>Perl 5 正则表达式的强大功能使该语言成为分析文本数据的首选工具。从那时起，许多其他编程语言都复制了 Perl 的正则表达式，这部分地削弱了 Perl 在该领域中优于其他语言的优势。</p>
<p>从 Perl 5 派生的新 Raku 语言创建了一个新的文本匹配模型，该模型源自正则表达式，但功能强大且富有表现力，并且从常规正则表达式中删除它已决定给它们一个新名称，正则表达式。</p>
<p>不仅 Perl 的正则表达式6的机理是它大大高于现有的所有系统的正则表达式更强大，但它被设计成正则表达式相结合，构建 Grammar 语境，也就是说能够实现词汇和语法分析（系统词法和解析）到更复杂的数据，例如 HTML 文本，XML，XHTML，JSON，YAML，其中，不包括简单的情形，都超出正则表达式的范围。这些 Grammar 甚至可以分析所有级别的计算机程序。Raku 程序本身是用 Raku 自己编写的 Grammar 编译的。</p>
<p>虽然它们远不是 Raku 的唯一创新，但我们相信 Raku 正则表达式和 Grammar 将至少与 Perl 的正则表达式一样彻底改变计算机语言，甚至可能更多。他们现在还没有时间这样做。</p>
<p>本教程的讨论在 Perl 论坛上公开，地址如下： <a href="http://www.developpez.net/forums/showthread.php?t=1551654">评论</a></p>
<h1 id="笔者">笔者</h1>
<p><a href="http://www.developpez.net/forums/u510897/lolo78/">劳伦特罗森菲尔德</a></p>
<h1 id="文章">文章</h1>
<p>发表于  2015年11月6日  - 更新于2018年  11月4日</p>
<p><a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/grammaires_raku.pdf">PDF</a>, <a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/grammaires_raku.zip">版离线版</a>, <a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/grammaires_raku.epub">ePub</a>, <a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/grammaires_raku.azw">Azw</a>, <a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/grammaires_raku.mobi">Mobi</a></p>
<h1 id="社交链接">社交链接</h1>
<p><a href="http://www.viadeo.com/shareit/share/?url=http%3A%2F%2Flaurent-rosenfeld.developpez.com%2Ftutoriels%2Fperl%2Fraku%2Fregex-grammaire-puissance%2F&amp;Title=Les+regex+et+grammaires+de+Perl+6"><img src="https://www.developpez.com/template/kit/kitbm-viadeo.png" alt="Viadeo"></a> <a href="http://twitter.com/timeline/home?status=http%3A%2F%2Flaurent-rosenfeld.developpez.com%2Ftutoriels%2Fperl%2Fraku%2Fregex-grammaire-puissance%2F"><img src="https://www.developpez.com/template/kit/kitbm-twitter.png" alt="叽叽喳喳"></a> <a href="http://www.facebook.com/sharer.php?u=http%3A%2F%2Flaurent-rosenfeld.developpez.com%2Ftutoriels%2Fperl%2Fraku%2Fregex-grammaire-puissance%2F"><img src="https://www.developpez.com/template/kit/kitbm-facebook.png" alt="Facebook的"></a> <a href="https://plus.google.com/share?url=http%3A%2F%2Flaurent-rosenfeld.developpez.com%2Ftutoriels%2Fperl%2Fraku%2Fregex-grammaire-puissance%2F"><img src="https://www.gstatic.com/images/icons/gplus-16.png" alt="在Google+上分享"></a></p>
<h1 id="1-正则表达式入门httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">1. <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">正则表达式入门</a></h1>
<p>在正则表达式（或正则表达式）从数学和将字符串通常已知的形式语言的计算机科学理论概念模式（或模式）来描述一个整体（成品或不）字符串由模式定义的共同特征，根据预定义的语法并且不考虑上下文。的图案（匹配图案匹配）是应用这些模式到文本的样本，以试图找到对应于这些模式的文本片段的过程。</p>
<p><strong>在你的计算机上安装Raku</strong></p>
<p>如果你想使用 Raku，我们建议你在<a href="http://rakudo.org/downloads/star/">此地址</a>下载 Rakudo Star。有关安装的更多信息，请参阅<a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/les-bases/#L1-2">Perl 5到Raku</a>教程的第一部分<a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/les-bases/#L1-2">- 第1部分：语言基础知识</a>。</p>
<p>在我们更新本文档（2018年10月）时，建议你选择 MoarVM 虚拟机。</p>
<h2 id="1-1-与文件搜索类比httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">1-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">与文件搜索类比</a>&nbsp;<a class="headline-hash no-text-decoration" href="#1-1-与文件搜索类比httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>要在目录中搜索名称以字母 “a” 开头且扩展名为 .txt 的所有文件，可以在系统的提示符下写入：</p>
<pre tabindex="0"><code>ls  a*.txt    # shell Unix, Linux, etc.
# ou :
dir a*.txt    # console DOS/cmd ou Powershell Windows, VMS, etc.
</code></pre><p>使用的命令名称（ls或dir）因操作系统而异，但此处使用的原因相同：a*.txt。更确切地说，它意味着字母 “a”，后跟任意数量的字符，后跟字符串 “.txt  ”。</p>
<p>使用的命令将在屏幕上显示当前目录中名称与模式 a*.txt 相关的所有文件 。过滤文件的名称在目录（或这样夹有图案 DOS/Windows 的术语）是正则表达式的工作原理：该模式所描述的，一般由左到右，一系列的元素必须在目标字符串中遇到（这里是文件名）：首先是字母  “a”，然后是任何字符，然后是字符串 “.txt”。</p>
<p>类比结束于此，因为编程语言中常用的正则表达式的语法赋予元字符 “*” 不同的含义（见第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-4">2.4</a>节  ）。</p>
<h2 id="1-2-正则表达式简史httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">1-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">正则表达式简史</a>&nbsp;<a class="headline-hash no-text-decoration" href="#1-2-正则表达式简史httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>正则表达式的使用是在1970年由计算机科学家 Ken Thompson，UNIX 的创作者第一个实现的，在 QED 和 ED 编辑器中（其很少使用）和 Unix 命令 grep，现在还很常用。</p>
<p>例如，在 Unix 或 Linux上，以下 grep 命令显示 text.txt 文件中包含字母“ab”的所有行，后跟任何字符，后跟字母“d”：</p>
<pre tabindex="0"><code>$&gt; grep ab.d texte.txt
</code></pre><p>在ab.d中，元字符 &ldquo;.&rdquo; 表示“任何单个字符”，上面的命令可以显示文件的以下行：</p>
<pre tabindex="0"><code>abcd
abvd ...
... abyd
... xyabcdz ...
xyab3dgh
</code></pre><p>现在仍在广泛使用的其他使用正则表达式的 Unix 实用程序也快速出现了：sed，vi，awk， lex，emacs，egrep 等。</p>
<p>Perl 语言（Perl 1出现于1987年12月）可能是第一个通用编程语言（除了awk，它不是通用语言，并且非常特别）具有集成的正则表达式，随后其它语言跟随。</p>
<p>很快，Perl（尤其是自1994年以来的Perl 5）大大扩展了它的正则表达式，以至于他们早已不再是严格意义上的“常规”或“理性”，而是提供另一方面，由于它们被许多编程语言（如Tcl，Python，PHP，Ruby，.NET，Java，JavaScript，Delphi等）复制而增加了表现力。Perl 5 对这些语言的影响是这样的，他们大多使用一种叫做“Perl兼容的正则表达式”（PCRE）库：简而言之，吸引用户，有必要强调的事实，提出的解决方案遵循 Perl 的“扩展正则表达式”的语法。</p>
<h2 id="1-3-raku-正则表达式的新功能httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">1-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">Raku 正则表达式的新功能</a>&nbsp;<a class="headline-hash no-text-decoration" href="#1-3-raku-正则表达式的新功能httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>使用 Raku 时，正则表达式总是使用从模式的左到右相同的渐进式匹配方法，但它们更不规则（严格意义上是原始的非上下文形式语言）并且甚至比那些更强大从Perl 5开始，所以决定放弃术语“正则表达式”来引用它们并将它们命名为正则表达式。随着时间的推移添加新功能最终使 Perl 的正则表达式语法有些蓬松，这在很大程度上是因为 Perl 5 一直专注于尽可能保持向后兼容。</p>
<p><strong>Raku 的正则表达式不再是 Perl 5 的正则表达式</strong></p>
<p>Perl 的正则表达式（尤其是Perl 5）已经显着影响了许多其他编程语言，以至于它们已成为事实上通常采用的标准（由PCRE库证明）。</p>
<p>注意，虽然他们保持清晰的相似性，Raku 的正则表达式重新制作，不再遵循 Perl 5 建立的标准。这种重新设计使它们更清晰，最重要的是更强大。因此，与PCRE不同，Raku 的正则表达式与 Perl 5 的正则表达式不兼容。</p>
<p>未来将告诉我们这个彻底打破常规的决定是否会被其他语言所遵循，以及 Raku 正则表达式是否会成为事实上的标准。我们认为 Raku 值得。</p>
<p>注意 ：但是，可以在 Raku 程序中使用副词 <strong>:P5</strong> 或 <strong>:Perl5</strong> 以使用 Perl 5 正则表达式语法（参见  <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-9-1-3">2.9.1.3。</a>）。然后我们找到与Perl 5兼容的正则表达式。</p>
<p>Raku 决定成为一种新语言并放弃这种向后兼容的要求，它允许相当深入地重写正则表达式的语言，使其大大扩展并使其更加连贯和合乎逻辑。</p>
<p>此外，下面的许多示例将显示如何构建简单的正则表达式并给正则表达式起个名字，以便它们可以像组装块一样组装成模式。越研究就越复杂。例如，IPv4 地址由四个字节组成（通常由十进制表示的四个整数表示，在0到255之间，由点号分隔）。这是很容易编写的第一个 Raku 正则表达式，因为这样的被称为字节，并检查它具有令人满意的数量在适当的条件，则装配一个新的正则表达式匹配那些字节四个，用点号分隔（见第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L4-2-4">4.2.4</a>节)</p>
<p>但是，Raku 正则表达式带来的真正革命是它们可以构建更强大的实体，即 Grammar（见 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3">§3</a>）。Grammar 是定义语法的形式主义，因此也是一种形式语言。在 Raku 中，它采用一组规则的形式，并命名为正则表达式，并允许逐步构建一个文本匹配系统，其结构远远少于正则表达式所能匹配的结构（甚至扩展）因此，Grammar 允许对文本进行词法和句法分析，例如计算机程序的源代码，以便编译它。Raku 有自己的 Raku Grammar，用 Raku编写。</p>
<p>正则表达式有时被认为是抽象的，难以理解。正则表达式使用简单的概念是比较难比的条件，了解构造，如果和循环，同时或为Perl语言本身。事实上，学习正则表达式的真正挑战在于理解通常用于表达这些概念的非常简洁，甚至是简洁的符号。事实上，Raku 通过提供插入空格，注释等能力，可以大大简化对正则表达式的理解。总是可以继续编写正则表达式非常简洁，有时候有点难以破译，有时候对于简单的问题就足够了，但没有人有义务。在本文档末尾附近<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L4-1">格式化代码</a>一章的示例中，显而易见。</p>
<h2 id="1-4-与正则表达式相关联的功能和方法httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">1-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">与正则表达式相关联的功能和方法</a>&nbsp;<a class="headline-hash no-text-decoration" href="#1-4-与正则表达式相关联的功能和方法httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>虽然这不是本教程的主题，但使用正则表达式之前简要回顾一些 Raku 运算符很有用。</p>
<p>在 Raku 中，基体操作者检查的字符串是否匹配的模式是操作员~~智能匹配（智能操作者匹配）。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;Reconnu&#34;</span> <span class="k">if</span> <span class="s">&#34;abcdef&#34;</span> <span class="o">~~</span> <span class="sr">/ab.d/</span><span class="p">;</span>    <span class="c1"># -&gt; Affiche : Reconnu</span>
</span></span></code></pre></div><p>这里，要解析的字符串是“abcdef”和正则表达式/ab.d/的模式。动机得到认可，因为人们可以在动机的四个原子之间建立对应关系（点“  。  ”匹配一个任意的角色，因此，在这里，它匹配“c”）和角色链的一部分; 该模式描述了链的这一部分。当然，/ ab.d /模式也会匹配出例如字符串“  <strong>abwd</strong> ef”，“  <strong>ab7d</strong> ef”或“su <strong>abZd</strong> a”。</p>
<p>需要注意的是智能匹配的操作~~这里用来连接字符串，用于在Raku的许多其他事情正则表达式模式（例如检查的项目在数组中，或检查变量与类型的兼容性等），但这不是本文档的目的（参见例如 <a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/annexe-01/#L2-2">智能匹配操作员</a>）。</p>
<p>如果要解析的字符串存储在默认变量$ _中，则不需要存在智能匹配运算符，并且可以直接在布尔上下文中评估正则表达式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">if</span> <span class="sr">/ ^ab /</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#34;La chaîne $_ commence par les lettres &#39;ab&#39;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以使用智能匹配操作符的否定形式 <code>!~~</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;Chaîne &#39;ab&#39; non trouvée&#34;</span> <span class="k">if</span> <span class="s">&#34;fedcba&#34;</span> <span class="o">!~~</span> <span class="sr">/ab/</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">                                      <span class="c1"># -&gt; Chaîne &#39;ab&#39; non-trouvée</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Équivalent à :</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;Chaîne &#39;ab&#39; non trouvée&#34;</span> <span class="k">unless</span> <span class="s">&#34;fedcba&#34;</span> <span class="o">~~</span> <span class="sr">/ab/</span><span class="p">;</span>
</span></span></code></pre></div><p>Raku 还允许使用 <code>.match</code> 这种面向对象的语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;Reconnu&#34;</span> <span class="k">if</span> <span class="s">&#34;abdcef&#34;</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sr">/c.f/</span><span class="p">);</span>   <span class="c1"># -&gt; Reconnu</span>
</span></span></code></pre></div><p>正则表达式还允许你进行替换：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$chaîne</span> <span class="o">=</span> <span class="s">&#34;abcde&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$chaîne</span> <span class="o">~~</span> <span class="sr">s/bc/CB/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="nv">$chaîne</span><span class="p">;</span>                              <span class="c1"># -&gt; affiche aCBde</span>
</span></span></code></pre></div><p>还有一个 <code>.subst</code> 方法来执行替换（但不是就地替换 ///）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$chaîne</span> <span class="o">=</span> <span class="s">&#34;abcde&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$chaîne</span><span class="o">-</span><span class="n">modifiée</span> <span class="o">=</span> <span class="nv">$chaîne</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="sr">/cd/</span><span class="p">,</span> <span class="s">&#34;DC&#34;</span><span class="p">);</span>  <span class="c1"># -&gt; abDCe</span>
</span></span></code></pre></div><p>但是，可以直接修改 <code>$string</code> 变量（不创建新变量），也可以将其放在赋值的左侧部分：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$chaîne</span> <span class="o">=</span> <span class="s">&#34;abcde&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$chaîne</span> <span class="o">=</span> <span class="nv">$chaîne</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="sr">/cd/</span><span class="p">,</span> <span class="s">&#34;DC&#34;</span><span class="p">)</span>      <span class="c1"># -&gt; abDCe</span>
</span></span></code></pre></div><p><code>.subst</code> 方法的第一个参数可以是正则表达式或字符串。</p>
<p><strong>split</strong> 函数和 <strong>.split</strong> 方法按照分割符将字符串划分为子字符串列表, 其第一个参数也可以使用字符串或正则表达式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="nb">split</span><span class="p">(</span><span class="s">&#39;;&#39;</span><span class="p">,</span> <span class="s">&#34;a;b;c,d&#34;</span><span class="p">)</span><span class="o">.</span><span class="n">perl</span><span class="p">;</span>        <span class="c1"># (&#34;a&#34;, &#34;b&#34;, &#34;c,d&#34;).Seq</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="nb">split</span><span class="p">(</span><span class="sr">/\;/</span><span class="p">,</span> <span class="s">&#34;a;b;c,d&#34;</span><span class="p">)</span><span class="o">.</span><span class="n">perl</span><span class="p">;</span>       <span class="c1"># (&#34;a&#34;, &#34;b&#34;, &#34;c,d&#34;).Seq</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="nb">split</span><span class="p">(</span><span class="sr">/&lt;[;,]&gt;/</span><span class="p">,</span> <span class="s">&#34;a;b;c,d&#34;</span><span class="p">)</span><span class="o">.</span><span class="n">perl</span><span class="p">;</span>   <span class="c1"># (&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;).Seq</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Version syntaxe de méthode orientée objet :</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;a;b;c,d&#34;</span><span class="o">.</span><span class="nb">split</span><span class="p">(</span><span class="sr">/&lt;[;,]&gt;/</span><span class="p">)</span><span class="o">.</span><span class="n">perl</span><span class="p">;</span>    <span class="c1"># (&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;).Seq</span>
</span></span></code></pre></div><p><strong>comb</strong> 函数和 <strong>.comb</strong> 方法返回字符串上模式的匹配（贪婪）列表：</p>
<pre tabindex="0"><code>say join &#34; &#34;, comb /\d+/, &#34;jeu du 7, 14 et 21&#34;;    # -&gt; 7 14 21
# syntaxe de méthode :
say &#34;3 fois 6 font 18&#34;.comb(/\d+/).join(&#34; &#34;);      # -&gt; 3 6 18
</code></pre><p>在不特定于正则表达式的情况下，建立布尔条件的其他函数或方法可以使用正则表达式模式（或其他内容，例如数字比较）来定义此条件。因此，函数 <strong>first</strong> 返回满足条件的列表的第一个元素，函数 <strong>grep</strong> 返回满足条件的列表的所有元素，正则表达式可写为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="n">first</span> <span class="sr">/ma/</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">jan</span> <span class="n">fév</span> <span class="n">mar</span> <span class="n">avr</span> <span class="n">mai</span><span class="o">&gt;</span><span class="p">;</span>             <span class="c1"># -&gt; mar</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="nb">grep</span>  <span class="sr">/ma/</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">jan</span> <span class="n">fév</span> <span class="n">mar</span> <span class="n">avr</span> <span class="n">mai</span><span class="o">&gt;</span><span class="p">;</span>             <span class="c1"># -&gt; (mar mai)</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="o">&lt;</span><span class="n">jan</span> <span class="n">fév</span> <span class="n">mar</span> <span class="n">avr</span> <span class="n">mai</span><span class="o">&gt;.</span><span class="nb">grep</span><span class="p">(</span><span class="sr">/v/</span><span class="p">);</span>               <span class="c1"># -&gt; (fév avr)</span>
</span></span></code></pre></div><p><strong>given-when</strong>构造（Raku 的“switch”）也经常使用正则表达式：</p>
<pre tabindex="0"><code>my $var = &#39;42&#39;;
given $var { 
    when /^4/   { say &#34;Commence par &#39;4&#39;&#34;; proceed}; 
    when /2$/   { say &#34;Finit par &#39;2&#39;&#34;; proceed}; 
    when /^42$/ { say &#34;Réponse à la Grande Question sur l&#39;Univers&#34; }
}
</code></pre><h1 id="2-raku的正则表达式httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2. <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">Raku的正则表达式</a></h1>
<h2 id="2-1-惯用法httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">惯用法</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-1-惯用法httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>Raku 提供了以下用于编写正则表达式的语法结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="sr">m/abc/</span><span class="p">;</span>         <span class="c1"># 立即应用于 $_ 的正则表达式</span>
</span></span><span class="line"><span class="cl"><span class="n">rx</span><span class="sr">/abc/</span><span class="p">;</span>        <span class="c1"># Regex 类型的正则表达式对象</span>
</span></span><span class="line"><span class="cl"><span class="sr">/abc/</span><span class="p">;</span>          <span class="c1"># Regex 类型的正则表达式对象</span>
</span></span></code></pre></div><p>前两个语法可以使用除斜杠之外的其他分隔符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="sr">m{abc}</span><span class="p">;</span>         <span class="c1"># 或者 m[abc];</span>
</span></span><span class="line"><span class="cl"><span class="n">rx</span><span class="p">{</span><span class="n">abc</span><span class="p">};</span>        <span class="c1"># 或者 rx!abc!;</span>
</span></span></code></pre></div><p>但请注意，冒号（“:”）不能用作正则表达式的分隔符。普通括号 &ldquo;( &quot; 和 &ldquo;)&rdquo; 只能作为分隔符，如果左括号由前面的rx 运算符的至少一个空格分隔（这是 Raku 的一般规则：括号前面标识符旁边的开头被分析为函数调用的开头）：</p>
<pre tabindex="0"><code>my $regex = rx(toto);  # 错误，解释为函数调用
my $regex = rx (toto); # OK
</code></pre><p>通常，默认情况下会忽略模式中的空格，除非使用（显式或隐式）副词 <strong>:s</strong> 或 <strong>:sigspace</strong>，请参见第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-9-1-2">2.9.1.2</a>节 （下文）。</p>
<pre tabindex="0"><code>say &#34;Reconnu&#34; if &#34;abc&#34; ~~ /a b  c /;    # -&gt; &#34;Reconnu&#34;
</code></pre><p>正如在 Raku 的注释，注释通常以 <code>#</code> 字符开始（通常称为字符英镑错误，英镑是不同的：“  ♯  ‘），除非蜘蛛被转义字符保护’ \“，并转到行的末尾（除非括号用作分隔符，在这种情况下，最好不要尝试将其用作注释开始字符）。<a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/les-bases/#L2-2-1">多行注释</a>也是可能的。</p>
<pre tabindex="0"><code># Commentaires unilignes :
my $regex = rx {
                 abc         # chaîne littérale &#39;abc&#39;
                 \d          # suivie d&#39;un chiffre
                 \w          # puis d&#39;un caractère alphanumérique.
};

# Commentaire multiligne :
my $regex = rx { 
                 abc \d \w   #`[ chaîne littérale &#39;abc&#39; suivie d&#39;un
                                 chiffre puis d&#39;un caractère
                                 alphanumérique quelconque.
                               ]
};
say &#34;Reconnu&#34; if &#34;XYabc6QUVW&#34; ~~ /&lt;$regex&gt;/; # reconnaît &#39;abc6Q&#39;
</code></pre><h2 id="2-2-字面量httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">字面量</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-2-字面量httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>正则表达式的匹配模式的最简单情况是常量字符串。在这种情况下，匹配模式是将模式作为字符串的子字符串查找：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$chaîne</span> <span class="o">=</span> <span class="s">&#34;Esperluette est le nom parfois donné au signe &amp;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$chaîne</span> <span class="o">~~</span> <span class="sr">m/ perl /</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#39;$chaîne contient &#34;perl&#34;&#39;</span><span class="p">;</span> <span class="c1"># -&gt; $chaîne contient &#34;perl&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>所有字母数字字符（Unicode）和带下划线或下划线的字符（“  _  ”）都是字面匹配。所有其他字符（标点符号，符号等）必须由反斜杠转义字符（“  \  ”）保护或引用单引号（或单引号）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="sr">/ &#39;deux mots&#39; /</span>    <span class="c1"># reconnaît &#39;deux mots&#39;, espace blanc compris</span>
</span></span><span class="line"><span class="cl"><span class="sr">/ &#34;a:b&#34;       /</span>    <span class="c1"># reconnaît &#39;a:b&#39;, caractère deux-points compris</span>
</span></span><span class="line"><span class="cl"><span class="sr">/ &#39;#&#39; /</span>            <span class="c1"># reconnaît le caractère croisillon (ou hash)</span>
</span></span><span class="line"><span class="cl"><span class="sr">/moi\@gmail\.com/</span>  <span class="c1"># échappements pour protéger l&#39;@ et le .</span>
</span></span><span class="line"><span class="cl"><span class="sr">/&#39;moi@gmail.com&#39;/</span>  <span class="c1"># équivalent à : /moi\@gmail\.com/</span>
</span></span></code></pre></div><p>当受转义字符保护时，字母数字字符通常具有特定含义：例如，元字符\ d表示可以表示任意数字（Unicode）的字符类; 稍后将给出许多例子（特别是在第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-3-1">2.3.1</a>节中  ）。</p>
<p>从左到右搜索字符串，因此，例如，子字符串等于模式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">if</span> <span class="s">&#39;abcdefg&#39;</span> <span class="o">~~</span> <span class="sr">/ de /</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="o">~</span><span class="vg">$/</span><span class="p">;</span>           <span class="c1"># de -&gt; motif reconnu</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="vg">$/</span><span class="o">.</span><span class="n">prematch</span><span class="p">;</span>   <span class="c1"># abc -&gt; ce qui précède le motif reconnu</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="vg">$/</span><span class="o">.</span><span class="n">postmatch</span><span class="p">;</span>  <span class="c1"># fg -&gt; ce qui suit le motif reconnu</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="vg">$/</span><span class="o">.</span><span class="n">from</span><span class="p">;</span>       <span class="c1"># 3 -&gt; position du début de la reconnaissance</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="vg">$/</span><span class="o">.</span><span class="n">to</span><span class="p">;</span>         <span class="c1"># 5 -&gt; position de ce qui suit la reconnaissance</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>匹配结果存储在变量$ /中（表示匹配对象，即使英文单词有时也意味着“ 匹配类型的对象”，它将在本文档中被“匹配对象”翻译 ），以及也通过承认来提及。如果匹配成功，则结果为Match类型，否则为Nil。</p>
<h2 id="2-3-元字符和字符类httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">元字符和字符类</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-3-元字符和字符类httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>甲字符类是不能匹配的单个特定的字符正则表达式语法元素，但一个字符属于范围可能与共同的特征的字符（例如匹配任何数字0至9，或任何小写字母字符）。</p>
<p><strong>点</strong>（“  。  ”）匹配任何简单字符（除非前面有转义字符，在这种情况下它匹配文字点）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="s">&#39;perl&#39;</span>   <span class="o">~~</span> <span class="sr">/per./</span><span class="p">;</span>       <span class="c1"># Reconnaît toute la chaîne</span>
</span></span><span class="line"><span class="cl"><span class="s">&#39;perl&#39;</span>   <span class="o">~~</span> <span class="sr">/ per . /</span><span class="p">;</span>    <span class="c1"># Idem (espaces blancs ignorés);</span>
</span></span><span class="line"><span class="cl"><span class="s">&#39;perl&#39;</span>   <span class="o">~~</span> <span class="sr">/ pe.l /</span><span class="p">;</span>     <span class="c1"># Idem: le . reconnaît le r</span>
</span></span><span class="line"><span class="cl"><span class="s">&#39;Épelle&#39;</span> <span class="o">~~</span> <span class="sr">/ pe.l/</span><span class="p">;</span>      <span class="c1"># Idem: le . reconnaît le premier l</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="s">&#39;perl&#39;</span> <span class="o">~~</span> <span class="sr">/. per /</span>        <span class="c1"># Pas de reconnaissance: </span>
</span></span><span class="line"><span class="cl">                          <span class="c1"># le . ne reconnaît rien avant la chaîne per</span>
</span></span></code></pre></div><p>与Perl 5和许多其正则表达式系统派生自Perl 5的语言不同，点也始终匹配换行符。</p>
<h3 id="2-3-1-转义字符和预定义的字符类httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-3-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">转义字符和预定义的字符类</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-3-1-转义字符和预定义的字符类httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>反斜杠（或反斜杠）形式的预定义字符类后跟一个字母，例如\ w。如果字母是大写的（\ W），则它是对应于相同小写字母的字符类的否定（即\ W识别\ w无法匹配的任何字符）：</p>
<ul>
<li><strong>字母数字字母</strong>（字母，数字和_）：\ w（补码：\ W）; 匹配例如一个，Ç，Ž，7个字符的Unicode 0041甲LATIN CAPITAL LETTER甲，0031 1一个数字，03B4δGREEK小写字母DELTA或0409ЉCYRILLIC CAPITAL LETTER LJE）;</li>
<li><strong>数字字符</strong>  ：\ d，和\ d（以Unicode意义上，不只是我们的阿拉伯数字单位数字：例如，U + 0E53 3 DIGIT三泰（泰图3）是由\ d识别）;</li>
<li><strong>水平空间</strong> l：\ h和\ H（白色空格，制表符，U + 00A0 NO-BREAK SPACE）;</li>
<li><strong>垂直空间</strong>  ：\ n和\ N;</li>
<li><strong>空间（水平或垂直）</strong>  ：\ s和\ S  ; 例如，在字符串&rsquo;包含以m开头的单词&rsquo;中，表达式/ m \ S + /匹配&rsquo;word&rsquo;。</li>
<li><strong>制表</strong>（U + 0009）：\ t和\ T  ;</li>
<li><strong>垂直空间</strong>  ：\ v和\ V（例如U + 000A LINE FEED，U + 000C CARRIAGE RETURN等）。</li>
</ul>
<h3 id="2-3-2-unicode属性httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-3-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">Unicode属性</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-3-2-unicode属性httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>上面看到的字符类对常见情况很有用。Unicode 属性的使用允许更系统和更精细的方法。调用语法的格式为 <code>&lt;:property&gt;</code>，其中 “property” 可以是 Unicode 属性的短名称或长名称。Unicode 属性本身的确切含义不是由Perl 定义的，而是由 Unicode 标准定义的。</p>
<p>以下是最常见的Unicode属性列表：</p>
<table>
<thead>
<tr>
<th>简称</th>
<th><strong>长名</strong></th>
<th><strong>意思和评论</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>Letter</td>
<td>字母</td>
</tr>
<tr>
<td>LC</td>
<td>Cased_Letter</td>
<td>带大小写的字母（区分大小写）</td>
</tr>
<tr>
<td>Lu</td>
<td>Upper_Cased_Letter或Upper</td>
<td>大写字母（大写）</td>
</tr>
<tr>
<td>Ll</td>
<td>Lower_Cased_Letter或Lower</td>
<td>小写字母（小写）</td>
</tr>
<tr>
<td>N</td>
<td>Number</td>
<td>数字</td>
</tr>
<tr>
<td>Nd</td>
<td>Decimal_Number或数字</td>
<td>十进制数（数字）</td>
</tr>
<tr>
<td>Nl</td>
<td>LETTER_NUMBER</td>
<td>号码信</td>
</tr>
<tr>
<td>P</td>
<td>Punctuation or punct</td>
<td>标点符号</td>
</tr>
<tr>
<td>Pd</td>
<td>Dash_Punctuation</td>
<td>标点符号类型破折号</td>
</tr>
<tr>
<td>Ps</td>
<td>Open_Punctuation</td>
<td>打开标点符号</td>
</tr>
<tr>
<td>Pe</td>
<td>Close_Punctuation</td>
<td>结束标点符号</td>
</tr>
<tr>
<td>S</td>
<td>Symbol</td>
<td>符号</td>
</tr>
<tr>
<td>Sm</td>
<td>Math_Symbol</td>
<td>数学符号</td>
</tr>
<tr>
<td>Sc</td>
<td>CURRENCY_SYMBOL</td>
<td>货币符号（例如$，£或€）</td>
</tr>
<tr>
<td>Z</td>
<td>Separator</td>
<td>分隔符</td>
</tr>
<tr>
<td>Zs</td>
<td>SPACE_SEPARATOR</td>
<td>空白分隔符</td>
</tr>
<tr>
<td>Zl</td>
<td>LINE_SEPARATOR</td>
<td>行分隔符</td>
</tr>
<tr>
<td>Zp</td>
<td>Paragraph_Separator</td>
<td>段落分隔符</td>
</tr>
</tbody>
</table>
<p>例如，<code>&lt;:Lu&gt;</code> 匹配单个大写字母。</p>
<p>使用 <code>&lt;:!property&gt;</code> 形式获取否定的 Unicode 属性，例如 <code>&lt;:!Lu&gt;</code> 将匹配任何不是大写字母的单个字符。</p>
<p>可以使用以下固定运算符组合多个属性：</p>
<table>
<thead>
<tr>
<th><strong>操作者</strong></th>
<th><strong>意</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>设置联盟</td>
<td>或属性之间的逻辑（金）</td>
</tr>
<tr>
<td>|</td>
<td>设置联盟</td>
<td>或属性之间的逻辑（金）</td>
</tr>
<tr>
<td>＆</td>
<td>设置交叉点</td>
<td>和属性之间的逻辑（和）</td>
</tr>
<tr>
<td>-</td>
<td>设定差异</td>
<td>拥有第一个属性而不是第二个属性</td>
</tr>
<tr>
<td>^</td>
<td>交点对称集</td>
<td>或属性之间的独占逻辑（XOR）</td>
</tr>
</tbody>
</table>
<p>例如，要匹配小写字母或数字，可以写入：&lt;：Ll +：N&gt;或&lt;：Ll +：Number&gt;或甚至&lt;+：Lowercase_Letter +：Number&gt;。</p>
<p>也可以使用括号对类别和类别组进行分组，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="s">&#39;raku&#39;</span> <span class="o">~~</span> <span class="sr">m{\w+(&lt;:Ll+:N&gt;)}</span>       <span class="c1"># 0 =&gt; ｢6｣</span>
</span></span></code></pre></div><h3 id="2-3-3-枚举的字符类和间隔httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-3-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">枚举的字符类和间隔</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-3-3-枚举的字符类和间隔httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>有时，元字符和预定义的字符类是不够的。幸运的是，通过放置&lt;[&hellip;]&gt;任意数量的字符和字符间隔（在这些间隔的边界之间有两个点“  ..  ”）来定义一个人自己的字符类很容易，或者没有空格：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="s">&#34;abacabadabacaba&#34;</span> <span class="o">~~</span> <span class="sr">/ &lt;[ a .. d 1 2 3 ]&gt; /</span> <span class="c1"># Vrai</span>
</span></span></code></pre></div><p>可以在&lt;&hellip;&gt;中使用与Unicode类别（+，|，＆，-，^）相同的运算符来组合多个区间定义，甚至可以将它们与上面的Unicode类别; 我们也可以在括号中使用用反斜杠定义的字符类：/ &lt;[\ d]  -  [13579]&gt; /，顺便说一下，它与/ &lt;[02468]不同。 &gt; /，因为第一个也匹配非阿拉伯数字。</p>
<p>在开放的V形符号之后用“ - ”符号获得这类字符的否定：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#39;pas de guillemets&#39;</span> <span class="o">~~</span> <span class="sr">/  &lt;-[ &#34; ]&gt; + /</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">      <span class="c1"># reconnaît les caractères autres que &#34;</span>
</span></span></code></pre></div><p>解析用引号分隔的字符串，使用使用字符类否定的模式是很常见的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#39;entre guillemets&#39;</span> <span class="o">~~</span> <span class="sr">/ &#39;&#34;&#39; &lt;-[ &#34; ]&gt; * &#39;&#34;&#39;/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1"># un guillemet, suivi de non-guillemets, suivi d&#39;un guillemet</span>
</span></span></code></pre></div><h2 id="2-4-量词httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">量词</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-4-量词httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>量化器使得有可能匹配，而不是一次，而是固定或可变次数，即它之前的原子。例如，量化器“  +  ”试图匹配上述中的一个或多个。</p>
<p>量化器具有比串联更高的优先级，因此/ ab + /匹配字母a后跟字母b的一倍或多倍。使用撇号反转情况：/&lsquo;ab&rsquo;+ /匹配字符串&rsquo;ab&rsquo;，&lsquo;abab&rsquo;&lsquo;ababab&rsquo;等。</p>
<table>
<thead>
<tr>
<th><strong>量词</strong></th>
<th><strong>意</strong></th>
<th><strong>注释或示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>一个或多个</td>
<td>匹配前面的原子一次或多次，没有上限</td>
</tr>
<tr>
<td>*</td>
<td>0次或更多次</td>
<td>例如，要在a和b之间允许一个或多个可选空格：/ a \ s * b /</td>
</tr>
<tr>
<td>？</td>
<td>0或1次</td>
<td>例如，对于单个可选字符</td>
</tr>
<tr>
<td>** min..max</td>
<td>min和max之间的任意次数</td>
<td>说Bool（&lsquo;a&rsquo;~~ / a ** 2..5 /）; ＃ - &gt;   假说Bool（&lsquo;aaa&rsquo;~~ / a ** 2..5 /）; ＃ - &gt;是的</td>
</tr>
<tr>
<td>**</td>
<td>恰好n次</td>
<td>说Bool（&lsquo;yyyy&rsquo;~~ / a ** 5 /）; ＃ - &gt;   假说Bool（&lsquo;aaaaa&rsquo;~~ / a ** 5 /）; ＃ - &gt;是的</td>
</tr>
<tr>
<td>％</td>
<td>量化器修改</td>
<td>为了更容易使用CSV，应用于上述量词之一的％修饰符允许匹配指定重复确认之间必须存在的分隔符。例如：/ a +％&rsquo;，&rsquo;/匹配&rsquo;a，a&rsquo;或&rsquo;a，a，a&rsquo;等，但ni&rsquo;a，&rsquo;，ni&rsquo;a，a，&rsquo;。</td>
</tr>
</tbody>
</table>
<h3 id="2-4-1-量词的亲和力和节俭httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-4-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">量词的亲和力和节俭</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-4-1-量词的亲和力和节俭httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>默认情况下，+和*量化器是贪婪或贪婪的，也就是说，它们在链中寻找最长的匹配。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="o">~</span><span class="vg">$/</span> <span class="k">if</span> <span class="s">&#39;aabaababa&#39;</span> <span class="o">~~</span> <span class="sr">/ .+ b /</span><span class="p">;</span>      <span class="c1"># -&gt; aabaabab</span>
</span></span></code></pre></div><p>在这里，子正则表达式。+搜索的任何字符，最长的可能字符串尚未承认正则表达式的其余部分，即原子b，这可能是目标。但经常发生这是初学者的错误，而且目标是匹配“任何角色直到第一个b  ”。在这种情况下，优选使用量词非贪婪（或“节俭”），得到通过用问号加上后缀原始计数，给予任+？那是*？。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="o">~</span><span class="vg">$/</span> <span class="k">if</span> <span class="s">&#39;aabaababa&#39;</span> <span class="o">~~</span> <span class="sr">/ .+? b /</span><span class="p">;</span>     <span class="c1"># -&gt; aab</span>
</span></span></code></pre></div><h2 id="2-5-替代品认识这个或那个httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">替代品（认识这个或那个）</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-5-替代品认识这个或那个httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>要匹配几种可能性中的一种，必须用“  ||  ”将它们分开 “; 发现的第一个匹配（从左到右）获胜。例如，初始化文件（config.ini样式）通常具有以下形式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="p">[</span><span class="n">section</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">clef</span> <span class="o">=</span> <span class="n">valeur</span>
</span></span></code></pre></div><p>从这样的文件中读取一行时，它可以是一个段或一个键值对。作为第一种方法，用于读取此类文件的正则表达式可以是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="sr">/ &#39;[&#39; \w+ &#39;]&#39; || \S+ \s* &#39;=&#39; \s* \S* /</span>
</span></span></code></pre></div><p>也就是说：</p>
<ul>
<li>括号中的一个词;</li>
<li>是由比白空间的其他字符，接着0或多个空格的字符串，然后等号“=”随后再次可选的空间，随后除白色空间的其他字符的进一步的字符串。</li>
</ul>
<p>还有另一种形式的替代方案，使用分隔符“  | （而不是“  ||  ”）。我们的想法是一样的，但是这是最长的匹配（无论是在第一），其被保留（只要你开始在同一位置），这意味着它们必须全部（可能并行测试）并进行比较。</p>
<p>以下示例说明了两个运算符之间的区别：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$chaîne</span> <span class="o">=</span> <span class="s">&#34;abcdef&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="o">~</span><span class="vg">$/</span> <span class="k">if</span> <span class="nv">$chaîne</span> <span class="o">~~</span> <span class="sr">/ab || abcde/</span><span class="p">;</span>       <span class="c1"># -&gt; ab</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="o">~</span><span class="vg">$/</span> <span class="k">if</span> <span class="nv">$chaîne</span> <span class="o">~~</span> <span class="sr">/ab |  abcde/</span><span class="p">;</span>       <span class="c1"># -&gt; abcde</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="o">~</span><span class="vg">$/</span> <span class="k">if</span> <span class="nv">$chaîne</span> <span class="o">~~</span> <span class="sr">/ab |  bcde/</span><span class="p">;</span>        <span class="c1"># -&gt; ab</span>
</span></span><span class="line"><span class="cl"><span class="c1"># dans ce dernier cas, la reconnaissance la plus à gauche l&#39;emporte</span>
</span></span></code></pre></div><p>最长匹配的规则对于属于例如Perl代码的字符串的词法分析特别有用。因此，它允许Perl语法匹配包含连字符的标识符（变量，函数等）（假设它们后跟字母字符）：Perl能够匹配由于这种最长匹配规则，这样的标识符（并且例如将其与较少放置在两个不同符号之间的算术运算符区分开）。</p>
<h3 id="2-5-1-连词认识到这一点和那个httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-5-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">连词（认识到这一点和那个）</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-5-1-连词认识到这一点和那个httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>替代方案在由运算符“  |  ”分隔的替代项的术语之间建立逻辑或（分离）»或««  | ”。</p>
<p>还有运算符“  ＆  ”和“  &amp;&amp;  ” 在它们分开的术语之间建立逻辑和（结合）。如果两个术语都被匹配并且它们匹配相同的子串（匹配的相同开头和相同末尾），则正则表达式只会成功：</p>
<pre tabindex="0"><code>my $regex = rx/a..d &amp; .bcd/;
say &#34;Reconnu&#34; if &#34;XZabcdZ&#34; ~~ /$regex/;    # -&gt; Reconnu
say ~$/;                                   # -&gt; abcd
</code></pre><h2 id="2-6-锚点httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-6 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">锚点</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-6-锚点httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>正则表达式引擎尝试通过从左到右搜索来查找字符串中的匹配项。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="s">&#39;Saperlipopette&#39;</span> <span class="o">~~</span> <span class="sr">/ perl /</span><span class="p">;</span>   <span class="c1"># True </span>
</span></span><span class="line"><span class="cl"><span class="c1">#         ^^^^</span>
</span></span><span class="line"><span class="cl"><span class="c1"># (so renvoie une évaluation booléenne, donc, en fait True ou False)</span>
</span></span></code></pre></div><p>但这并不总是你想要的。例如，我们可能想要匹配整个字符串，整行，或一个或多个整个单词，或者重视发生匹配的字符串的位置（例如，仅在字符串的开头） 。锚（以及后面第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-10">2.10</a>节中讨论的断言  ）允许指定匹配将在何处发生。</p>
<p>必须为整个正则表达式匹配正则表达式的锚点，但锚点不会消耗链中的字符。</p>
<table>
<thead>
<tr>
<th><strong>锚</strong></th>
<th><strong>意</strong></th>
<th><strong>注释或示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>字符串的开头</td>
<td>&lsquo;Saperlipopette&rsquo;~~ / perl /; #   True &lsquo;Soperlipopette&rsquo;~~ / ^ perl /; #False   &lsquo;perl&rsquo;~~ / ^ perl /; #True</td>
</tr>
<tr>
<td>^^</td>
<td>行首</td>
<td>^^匹配字符串的开头或返回字符后面的内容</td>
</tr>
<tr>
<td>$$</td>
<td>行尾</td>
<td>$$匹配字符串的结尾或后跟新行的字符</td>
</tr>
<tr>
<td>&laquo;</td>
<td>限于单词的左侧</td>
<td>换句话说，这个词的开头。或者，更准确地说：左边的非单词字符和右边的单词字符之间的边界。</td>
</tr>
<tr>
<td>&raquo;</td>
<td>限于单词的右侧</td>
<td>或者结尾。例如： &lsquo;Carpe diem&rsquo;~~ / arpe &raquo; /; #  true&rsquo;Carpe diem&rsquo;~~ / die &raquo; /; ＃fake</td>
</tr>
<tr>
<td>$</td>
<td>字符串的末尾</td>
<td>&lsquo;Carpe diem&rsquo;~~ / arpe $/; #   false &lsquo;Carpe diem&rsquo;~~ / diem $/; #true</td>
</tr>
</tbody>
</table>
<h2 id="2-7-分组和捕获httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-7 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">分组和捕获</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-7-分组和捕获httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<h3 id="2-7-1-分组httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-7-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">分组</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-7-1-分组httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>在常规 Raku 代码中（对于正则表达式），圆括号用于对表达式进行分组，通常用于更改执行优先级：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>      <span class="c1"># 9, 解析为: 1 + (4 * 2)</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1"># 10</span>
</span></span></code></pre></div><p>我们可以使用相同的想法对正则表达式的元素进行分组：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="sr">/ a || b c /</span>        <span class="c1"># 匹配 &#39;a&#39; 或 &#39;bc&#39;</span>
</span></span><span class="line"><span class="cl"><span class="sr">/ ( a || b ) c /</span>    <span class="c1"># 匹配 &#39;ac&#39; 或 &#39;bc&#39;</span>
</span></span></code></pre></div><p>相同的分组技术可以应用于量词：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="sr">/ a b+ /</span>            <span class="c1"># 匹配一个 &#39;a&#39;, 后跟一个或多个 &#39;b&#39;</span>
</span></span><span class="line"><span class="cl"><span class="sr">/ (a b)+ /</span>          <span class="c1"># 匹配一个或多个 &#39;ab&#39; 序列</span>
</span></span><span class="line"><span class="cl"><span class="sr">/ (a || b)+ /</span>       <span class="c1"># 匹配 &#39;a&#39; 和 &#39;b&#39; 的任何序列</span>
</span></span><span class="line"><span class="cl">                    <span class="c1"># 至少一个字符 &#39;b&#39;</span>
</span></span></code></pre></div><h3 id="2-7-2-捕获httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-7-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">捕获</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-7-2-捕获httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>圆括号不仅用于分组，它们还用于捕获，也就是说，它们将被匹配的部分存储在可重用变量的括号中，以及对象元素的形式认可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span>  <span class="s">&#39;nombre 42&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$str</span> <span class="o">~~</span> <span class="sr">/&#39;nombre &#39; (\d+) /</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#34;The number is $0&#34;</span><span class="p">;</span>         <span class="c1"># The number is 42</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 或</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#34;The number is $/[0]&#34;</span><span class="p">;</span>      <span class="c1"># The number is 42</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果有几对括号，它们从左到右编号，从零（<code>$0</code>，<code>$1</code>，<code>$2</code> 等）开始，与 Perl 5 不同，其捕获从<code>$1</code>开始。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">if</span> <span class="s">&#39;abc&#39;</span> <span class="o">~~</span> <span class="sr">/(a) b (c)/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#34;0: $0; 1: $1&#34;</span><span class="p">;</span>             <span class="c1"># 0: a; 1: c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>变量 <code>$0</code>，<code>$1</code> 等 实际上是捷径语法。<code>$/</code> 匹配对象作为一个列表，以至于 <code>$0</code>实际上是语法糖<code>$/[0]</code> ，<code>$1</code> 是<code>$/[1]</code> 等等。</p>
<p>强制匹配对象到列表上下文允许轻松访问所有元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">if</span> <span class="s">&#39;abcdef&#39;</span> <span class="o">~~</span> <span class="sr">/(a) b (c) (d) e (f)/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="vg">$/</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="nb">join</span><span class="p">:</span> <span class="s">&#39;, &#39;</span>  <span class="c1"># a, c, d, f</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="2-7-3-非捕获分组httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-7-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">非捕获分组</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-7-3-非捕获分组httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>圆括号提供双重功能：它们对正则表达式中的元素进行分组，并捕获括号内已匹配的内容。</p>
<p>为了仅保留分组行为（不捕获），我们可以使用方括号而不是圆括号：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">if</span> <span class="s">&#39;abc&#39;</span> <span class="o">~~</span> <span class="sr">/ [a||b] (c) /</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="o">~</span><span class="nv">$0</span><span class="p">;</span>                <span class="c1"># c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果你不需要捕获，那么使用非捕获组有三个优点：开发人员的意图更清晰，更容易计算你需要的捕获组，速度更快一点。</p>
<h3 id="2-7-4-捕获编号httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-7-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">捕获编号</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-7-4-捕获编号httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>上面已经说过，捕获组从左到右编号。这在原则上是正确的，但它有点过于简化。列出以下规则以使本文档尽可能完整，但如果你发现自己经常使用它，那么最好考虑<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-7-5">命名捕获</a>（第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-7-5">2.7.5</a>节  ）或甚至<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-8">Sub - 命名规则</a>（第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-8">2.8</a>节  ）。</p>
<p>备选分支将捕获的编号重置为0：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="sr">/ (x) (y)  || (a) (.) (.) /</span>
</span></span><span class="line"><span class="cl"><span class="c1"># $0  $1      $0  $1  $2</span>
</span></span></code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">if</span> <span class="s">&#39;abc&#39;</span> <span class="o">~~</span> <span class="sr">/(x)(y) || (a) (.) (.)/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">#                       $0  $1  $2</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="o">~</span><span class="nv">$1</span><span class="p">;</span>            <span class="c1"># b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果备选分支的不同选项（或多或少有点复杂）具有不同数量的捕获，则具有最大捕获编号的那个选项（逻辑上）确定下一个捕获的索引。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="nv">$chaîne</span> <span class="o">=</span> <span class="s">&#39;abcd&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$chaîne</span> <span class="sr">/ a [ b (.) || (x) (y) ] (.) /</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#              $0     $0  $1    $2</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="o">~</span><span class="nv">$2</span><span class="p">;</span>            <span class="c1"># d</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>捕获可以嵌套，在这种情况下，它们按级别编号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">if</span> <span class="s">&#39;abc&#39;</span> <span class="o">~~</span> <span class="sr">/ ( a (.) (.) ) /</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#34;Outer: $0&#34;</span><span class="p">;</span>               <span class="c1"># Outer: abc</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#34;Inner: $0[0] and $0[1]&#34;</span><span class="p">;</span>  <span class="c1"># Inner: b and c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="2-7-5-命名捕获httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-7-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">命名捕获</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-7-5-命名捕获httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>可以给捕获命名，而不是对捕获进行编号。命名捕获的通用（有点健谈）方式是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">if</span> <span class="s">&#39;abc&#39;</span> <span class="o">~~</span> <span class="sr">/ $&lt;my_name&gt; = [ \w+ ] /</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="o">~</span><span class="nv">$</span><span class="err">&lt;</span><span class="nv">my_name</span><span class="o">&gt;</span>      <span class="c1"># abc</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>访问命名快照 <code>$&lt;myname&gt;</code> 实际上是一个快捷方式，可以将匹配对象作为散列值访问，即<code>$/{'my_name'}</code> 或 <code>$/&lt;my_name&gt;</code>。</p>
<p>强制匹配对象在散列上下文中提供了一种访问所有命名快照的简单方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">if</span> <span class="s">&#39;count=23&#39;</span> <span class="o">~~</span> <span class="sr">/ $&lt;variable&gt;=\w+ &#39;=&#39; $&lt;value&gt;=\w+ /</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="vg">$/</span><span class="o">.</span><span class="n">hash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="nv">%h</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">sort</span><span class="o">.</span><span class="nb">join</span><span class="p">:</span> <span class="s">&#39;, &#39;</span><span class="p">;</span>        <span class="c1"># OUTPUT: «value, variable␤» </span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="nv">%h</span><span class="o">.</span><span class="nb">values</span><span class="o">.</span><span class="nb">sort</span><span class="o">.</span><span class="nb">join</span><span class="p">:</span> <span class="s">&#39;, &#39;</span><span class="p">;</span>      <span class="c1"># OUTPUT: «23, count␤» </span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nv">%h</span><span class="o">.</span><span class="nn">kv</span> <span class="o">-&gt;</span> <span class="nv">$k</span><span class="p">,</span> <span class="nv">$v</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">say</span> <span class="s">&#34;Found value &#39;$v&#39; with key &#39;$k&#39;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># outputs two lines: </span>
</span></span><span class="line"><span class="cl">        <span class="c1">#   Found value &#39;count&#39; with key &#39;variable&#39; </span>
</span></span><span class="line"><span class="cl">        <span class="c1">#   Found value &#39;23&#39; with key &#39;value&#39; </span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>下一节（<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-8">子规则或命名规则</a>）提供了访问命名捕获的通常更方便的方法。</p>
<h2 id="2-8-助理规则或规则命名httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-8 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">助理规则或规则命名</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-8-助理规则或规则命名httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>可以将正则表达式放入命名规则中，就像你可以将代码片段放入函数（或子例程）或方法中一样。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">ligne</span> <span class="p">{</span> <span class="o">\</span><span class="n">N</span><span class="o">*\</span><span class="n">n</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="s">&#34;abc\ndef&#34;</span> <span class="o">~~</span> <span class="sr">/&lt;ligne&gt; def/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#34;Première ligne: &#34;</span><span class="p">,</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">ligne</span><span class="o">&gt;.</span><span class="nb">chomp</span><span class="p">;</span>    <span class="c1"># Première ligne: abc</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>命名正则表达式可以使用语法my regex regexname {正则表达式的主体}声明自己，然后使用<!-- raw HTML omitted -->调用。此外，调用命名的regex ipso facto会创建一个具有相同名称的命名快照（上例中的$ <!-- raw HTML omitted -->）。</p>
<p>但是，如果需要，可以使用以下调用语法&lt;capture_name = regexname&gt;为捕获提供另一个名称 ; 然后，你可以使用符号$ &lt;capture_name&gt;访问捕获。我们举例说明在第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-9-1">3.9.1</a>节的语法MultDiv中  使用此功能<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-9-1">。</a>（<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-9-1">角色的组成</a>）。</p>
<p>如果你不需要捕获，则前缀&lt;.name_regex&gt;的点的正则表达式的名称将删除捕获。</p>
<p>这里是一个小全码（但仍然还相当有限）的摘录，分析文件类型的config.ini的§  <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-5">2.5</a> ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">header</span> <span class="p">{</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="s">&#39;[&#39;</span> <span class="p">(</span><span class="o">\</span><span class="n">w</span><span class="o">+</span><span class="p">)</span> <span class="s">&#39;]&#39;</span> <span class="o">\</span><span class="n">h</span><span class="o">*</span> <span class="o">\</span><span class="n">n</span><span class="o">+</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">identifier</span>  <span class="p">{</span> <span class="o">\</span><span class="n">w</span><span class="o">+</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">kvpair</span> <span class="p">{</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="sr">&lt;key=identifier&gt;</span> <span class="s">&#39;=&#39;</span> <span class="sr">&lt;value=identifier&gt;</span> <span class="o">\</span><span class="n">n</span><span class="o">+</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">section</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="sr">&lt;header&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="sr">&lt;kvpair&gt;</span><span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$contents</span> <span class="o">=</span> <span class="sx">q:to/EOI/; 
</span></span></span><span class="line"><span class="cl"><span class="sx">    [passwords]
</span></span></span><span class="line"><span class="cl"><span class="sx">        jack=password1
</span></span></span><span class="line"><span class="cl"><span class="sx">        joy=muchmoresecure123
</span></span></span><span class="line"><span class="cl"><span class="sx">    [quotas]
</span></span></span><span class="line"><span class="cl"><span class="sx">        jack=123
</span></span></span><span class="line"><span class="cl"><span class="sx">        joy=42
</span></span></span><span class="line"><span class="cl"><span class="sx">EOI
</span></span></span><span class="line"><span class="cl"><span class="sx"> 
</span></span></span><span class="line"><span class="cl"><span class="sx">my %config;
</span></span></span><span class="line"><span class="cl"><span class="sx">if $contents ~~ /&lt;section&gt;*/ {
</span></span></span><span class="line"><span class="cl"><span class="sx">    for $&lt;section&gt;.list -&gt; $section {
</span></span></span><span class="line"><span class="cl"><span class="sx">        my %section;
</span></span></span><span class="line"><span class="cl"><span class="sx">        for $section&lt;kvpair&gt;.list -&gt; $p {
</span></span></span><span class="line"><span class="cl"><span class="sx">            %section{ $p&lt;key&gt; } = ~$p&lt;value&gt;;
</span></span></span><span class="line"><span class="cl"><span class="sx">        }
</span></span></span><span class="line"><span class="cl"><span class="sx">        %config{ $section&lt;header&gt;[0] } = %section;
</span></span></span><span class="line"><span class="cl"><span class="sx">    }
</span></span></span><span class="line"><span class="cl"><span class="sx">}
</span></span></span><span class="line"><span class="cl"><span class="sx">say %config.perl;
</span></span></span><span class="line"><span class="cl"><span class="sx"> 
</span></span></span><span class="line"><span class="cl"><span class="sx"># OUTPUT:</span> <span class="err">«</span><span class="p">{:</span><span class="n">passwords</span><span class="p">(</span><span class="nv">$</span><span class="p">{:</span><span class="n">jack</span><span class="p">(</span><span class="s">&#34;password1&#34;</span><span class="p">),</span> <span class="p">:</span><span class="n">joy</span><span class="p">(</span><span class="s">&#34;muchmoresecure123&#34;</span><span class="p">)}),</span> 
</span></span><span class="line"><span class="cl"><span class="c1">#           :quotas(${:jack(&#34;123&#34;), :joy(&#34;42&#34;)})}» </span>
</span></span></code></pre></div><p>命名正则表达式可以分组为语法（见第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3">3</a>节  ），并且通常需要这样做（命名正则表达式的目的正是为了构建语法）。</p>
<p>有预定义的子规则，或多或少对应于之前看到的字符类，例如：</p>
<ul>
<li><code>&lt;ident&gt; </code> ：标识符;</li>
<li><code>&lt;upper&gt;</code>  ：单个大写字母;</li>
<li><code>&lt;lower&gt;</code>  ：单个小写字母;</li>
<li><code>&lt;alpha&gt;</code>  ：单个字母字符或带下划线的字符（对于没有带下划线字符的Unicode字母字符，请使用 <code>&lt;:alpha&gt;</code>  ;</li>
<li><code>&lt;digit&gt;</code>  ：单个十进制数;</li>
<li><code>&lt;xdigit&gt;</code>  ：单个十六进制数;</li>
<li><code>&lt;print&gt;</code>  ：单个可打印字符;</li>
<li><code>&lt;punct&gt;</code>  ：一个标点字符;</li>
<li><code>&lt;alnum&gt;</code>  ：单个字母数字字符（相当于<code>&lt;alpha&gt;</code> + <code>&lt;digit&gt;</code>）;</li>
<li><code>&lt;wb&gt;</code>  ：单词边界，零长度断言;</li>
<li><code>&lt;space&gt;</code>  ：单个空格（与 <code>\s</code> 相同）;</li>
<li>在 pattern 之前  ：在null length 之前断言，也就是说，验证一个是否处于匹配模式的位置，并且如果成功则返回零大小的已匹配对象（同样存在一个子排除离职后的图案向后）。另见第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-10">2.10</a>节）。</li>
</ul>
<p>在Synopse <a href="http://design.raku.org/S05.html#Predefined_Subrules">S05中</a>可以找到更完整的列表。</p>
<p>如在下一章讨论的，名为正则表达式或子规则也可以与关键字定义的 token 或 rule（而不是 regex），其改变方式的正则表达式引擎将分析链隐式使用副词：棘轮和/或（视情况而定）：sigspace（参见下面的<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-9-1-1">2.9.1.1</a>和<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-9-1-2">2.9.1.2</a>节）。声明的语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">token</span> <span class="n">nom</span><span class="o">-</span><span class="n">de</span><span class="o">-</span><span class="n">règle</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 或:</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">rule</span>  <span class="n">nom</span><span class="o">-</span><span class="n">de</span><span class="o">-</span><span class="n">règle</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span></code></pre></div><h2 id="2-9-副词httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-9 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">副词</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-9-副词httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>该副词（对应于所谓的改性剂在Perl 5 Perl的正则表达式5和包在其他语言如使用PCRE）改变工作方式正则表达式，并允许一些非常方便的快捷键重复的任务。</p>
<p>有两种副词：正则表达式副词适用于定义正则表达式的地方，以及匹配副词，其中模式匹配字符串。区别有时是模糊的，因为匹配和定义通常是文本近似的，但使用方法匹配的语法有助于澄清差异。</p>
<p>&lsquo;abc&rsquo;~~ /../大致相当于&rsquo;abc&rsquo;.match（/../），甚至可以用两个不同的行更清楚地写出来：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$regex</span> <span class="o">=</span> <span class="sr">/../</span><span class="p">;</span>           <span class="c1"># définition, deux caractères quelconques</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="s">&#39;abc&#39;</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nv">$regex</span><span class="p">)</span> <span class="p">{</span>    <span class="c1"># reconnaissance</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#34;&#39;abc&#39; a au moins deux caractères&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>正则表达式副词如：i（忽略大小写，即大写和小写字母之间的区别）进入定义，而匹配副词如：重叠被添加到调用匹配：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$regex</span> <span class="o">=</span> <span class="sr">/:i . a/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="s">&#39;baA&#39;</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="nv">$regex</span><span class="p">,</span> <span class="p">:</span><span class="n">overlap</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">$m</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="o">~</span><span class="nv">$m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Affiche :</span>
</span></span><span class="line"><span class="cl"><span class="c1">#     ba</span>
</span></span><span class="line"><span class="cl"><span class="c1">#     aA</span>
</span></span></code></pre></div><h3 id="2-9-1-正则表达式副词httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-9-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">正则表达式副词</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-9-1-正则表达式副词httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>声明正则表达式时出现的副词是正则表达式的一部分，并影响Raku编译器如何将正则表达式转换为二进制代码。</p>
<p>例如，副词：ignorecase或：i（忽略大小写）告诉编译器忽略大写和小写字母之间的区别。因此，&lsquo;a&rsquo;~~ / A /是假，而&rsquo;a&rsquo;~~ /：i A /被成功匹配。（有一个变体：ii或：samecase，在替换的情况下，确保替换字符串与匹配的字符串在相同的情况下。）</p>
<p>正则表达式的副词可以放在正则表达式语句之前或之内，并且只会影响下一个正则表达式的那部分。</p>
<p>这两个正则表达式是等价的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rx1</span> <span class="o">=</span> <span class="n">rx:i</span><span class="sr">/a/</span><span class="p">;</span>      <span class="c1"># avant</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rx2</span> <span class="o">=</span> <span class="n">rx</span><span class="sr">/:i a/</span><span class="p">;</span>     <span class="c1"># à l&#39;intérieur</span>
</span></span></code></pre></div><p>但这些不是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rx3</span> <span class="o">=</span> <span class="n">rx</span><span class="sr">/a :i b/</span><span class="p">;</span>   <span class="c1"># insensible à la casse seulement pour b</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$rx4</span> <span class="o">=</span> <span class="n">rx</span><span class="sr">/:i a b/</span><span class="p">;</span>   <span class="c1"># complètement insensible à la casse</span>
</span></span></code></pre></div><p>括号和括号限制了副词的范围：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="sr">/ (:i a b) c /</span>          <span class="c1"># reconnaît &#39;ABc&#39; mais pas &#39;ABC&#39;</span>
</span></span><span class="line"><span class="cl"><span class="sr">/ [:i a b] c /</span>          <span class="c1"># reconnaît &#39;ABc&#39; mais pas &#39;ABC&#39;</span>
</span></span></code></pre></div><h4 id="2-9-1-1-副词棘轮没有回溯httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-9-1-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">副词“棘轮”：没有回溯</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-9-1-1-副词棘轮没有回溯httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h4>
<p>副词：棘轮或：r告诉正则表达式引擎不要返回（回溯）。英语单词棘轮指非回捕（如棘轮扳手），机械系统，防止设备回去（并迫使从而隐含前进）。</p>
<p>如果没有这个副词，正则表达式的不同部分将尝试不同的方式来匹配字符串以允许正则表达式的其他部分匹配。例如，使用正则表达式&rsquo;abc&rsquo;~~ / w + ./，\ w +部分以消耗整个字符串abc开始，然后在“  。 以下是。然后有退格（或返回跟踪），也就是说\ w +放弃最后一个字符并且只识别ab，这允许“  。 “成功确认Ç。删除一个字符（或几个）以开始新的匹配尝试的过程称为回溯（有时回溯）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="s">&#39;abc&#39;</span> <span class="o">~~</span> <span class="sr">/ \w+ . /</span><span class="p">;</span>      <span class="c1"># Vrai</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="s">&#39;abc&#39;</span> <span class="o">~~</span> <span class="sr">/ :r \w+ . /</span><span class="p">;</span>   <span class="c1"># Faux</span>
</span></span></code></pre></div><p>使用这种棘轮可以是优化，因为回溯通常是昂贵的。但兴趣在于，没有回溯的匹配与人类分析他们阅读的文本的方式密切相关。使用正则表达式我的正则表达式标识符{\ w +}和我的正则表达式关键字{if | 别的| endif}，我们直观地等待标识符吸收完整的单词，而不需要恢复该单词的结尾以满足以下规则。例如，没有人希望将单词reason解析为单词标识符，后跟if关键字 ; 我们等待而不是因为它被解析为一个标识符，如果解析器等待该单词，则它会失败，而不是解析输入数据与预期的不同。</p>
<p>我们可以认为回溯一般期望行为分析低级别的一个字符，一个字符串，但研究棘爪（棘轮）通常更符合我们想要做的用于结构化文本的词法或句法分析。</p>
<p>由于棘轮的行为是如此经常在词法分析器（可取的词法分析器）和句法（解析器），存在一个正则表达式棘轮一个快捷方式：使用所述关键字设置的分则令牌而不是正则表达式  ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">token</span> <span class="n">truc</span> <span class="p">{</span> <span class="o">....</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># raccourci pour :</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">truc</span> <span class="p">{</span> <span class="p">:</span><span class="n">r</span> <span class="o">...</span> <span class="p">}</span>
</span></span></code></pre></div><p>使用关键字规则的子规则（参见  <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-9-1-2">§2.9.1.2。</a>）也会起到防止回溯的作用。</p>
<p>这些规则的存在令牌和规则的副词：棘轮还算是很少明确使用：它通常最好使用隐含定义子规则作为标记或规则。</p>
<h4 id="2-9-1-2-副词sigspace显着的空格httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-9-1-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">副词“sigspace”（显着的空格）</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-9-1-2-副词sigspace显着的空格httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h4>
<p>副词：sigspace其中：s在正则表达式中创建重要的空格（到目前为止，它们不再被忽略）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="s">&#34;J&#39;ai utilisé Photoshop®&#34;</span>  <span class="o">~~</span> <span class="n">m:i</span><span class="sr">/   photo shop /</span><span class="p">;</span> <span class="c1"># Vrai</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="s">&#34;J&#39;ai utilisé photo shop&#34;</span>  <span class="o">~~</span> <span class="n">m:i:s</span><span class="sr">/ photo shop /</span><span class="p">;</span> <span class="c1"># Vrai</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="s">&#34;J&#39;ai utilisé Photoshop®&#34;</span>  <span class="o">~~</span> <span class="n">m:i:s</span><span class="sr">/ photo shop /</span><span class="p">;</span> <span class="c1"># Faux</span>
</span></span></code></pre></div><p>m：s / photo shop /好像我们写了m / photo &lt;.ws&gt; shop &lt;.ws&gt; /。默认情况下，&lt;。ws&gt;确保单词是分开的，因此“a b”将被&lt;.ws&gt;识别，而不是“ab”。</p>
<p>正则表达式中的空格根据前面的空格转换为&lt;.ws&gt;或不转换为&lt;.ws&gt;。在上面的示例中，正则表达式开头的空格不会更改为&lt;.ws&gt;，而是字符后面的空格。通常，规则是如果术语可以匹配某些内容，则该术语后面的空格将转换为&lt;.ws&gt;。</p>
<p>另外，如果结束之后的空间中，但在此之前量词（+，*或？），&lt;.WS&gt;将这个术语的每个匹配后匹配，从而使富+变为[富&lt;。 ws&gt;] +。另一方面，量化器之后的空间表现得像正常有意义的空间，例如“foo +”变为foo + &lt;.ws&gt;。</p>
<p>最后，这段代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">rx</span> <span class="p">:</span><span class="n">s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">^^</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">say</span> <span class="s">&#34;Pas de sigspace après ceci&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="sr">&lt;.assertion_puis_ws&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">caractères_puis_ws</span><span class="o">+</span>
</span></span><span class="line"><span class="cl">    <span class="n">caractères_séparés_par_ws</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="o">|</span> <span class="n">des</span> <span class="s">&#34;trucs&#34;</span> <span class="o">..</span> <span class="o">.</span>
</span></span><span class="line"><span class="cl">    <span class="o">|</span> <span class="vg">$$</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">:</span><span class="k">my</span> <span class="nv">$toto</span> <span class="o">=</span> <span class="s">&#34;pas de ws après ceci&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$toto</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>变为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">rx</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">^^</span> <span class="sr">&lt;.ws&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">say</span> <span class="s">&#34;Pas d&#39;espace après ceci&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="sr">&lt;.assertion_puis_ws&gt;</span> <span class="sr">&lt;.ws&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">caractères_puis_ws</span><span class="o">++</span> <span class="sr">&lt;.ws&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span> <span class="n">caractères_séparés_par_ws</span> <span class="sr">&lt;.ws&gt;</span><span class="p">]</span><span class="o">*</span> <span class="sr">&lt;.ws&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="o">|</span> <span class="n">des</span> <span class="sr">&lt;.ws&gt;</span> <span class="s">&#34;trucs&#34;</span> <span class="sr">&lt;.ws&gt;</span> <span class="o">..</span> <span class="sr">&lt;.ws&gt;</span> <span class="o">.</span> <span class="sr">&lt;.ws&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="o">|</span> <span class="vg">$$</span> <span class="sr">&lt;.ws&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span> <span class="sr">&lt;.ws&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">:</span><span class="k">my</span> <span class="nv">$toto</span> <span class="o">=</span> <span class="s">&#34;pas de ws après ceci&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$toto</span> <span class="sr">&lt;.ws&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>就像使用token关键字声明的正则表达式隐含adverb ：ratchet一样，使用关键字rule声明的正则表达式意味着副词：ratchet和：sigspace。</p>
<p>语法提供了一种简单的方法来重新定义&lt;.ws&gt;将匹配的内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">Demo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">ws</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="sr">&lt;!ww&gt;</span>   <span class="c1"># reconnaissance si pas à l&#39;intérieur d&#39;un mot</span>
</span></span><span class="line"><span class="cl">        <span class="o">\</span><span class="n">h</span><span class="o">*</span>     <span class="c1"># reconnaît seulement les espaces horizontaux</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">TOP</span> <span class="p">{</span>  <span class="c1"># appelée par Demo.parse;</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span> <span class="n">b</span> <span class="s">&#39;.&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="n">Demo</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#34;ab.&#34;</span><span class="p">);</span>       <span class="c1"># Faux (espace requis entre a et b)</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="n">Demo</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#34;a b.&#34;</span><span class="p">);</span>      <span class="c1"># Vrai</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="n">Demo</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#34;a\tb .&#34;</span><span class="p">);</span>    <span class="c1"># Vrai</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="n">Demo</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#34;a\tb\n.&#34;</span><span class="p">);</span>   <span class="c1"># Faux (\n est un espace vertical)</span>
</span></span></code></pre></div><p>在解析某些类型的空白（例如，垂直空间）很重要的文件格式时，通常需要重新定义ws。</p>
<h4 id="2-9-1-3-和perl-5-兼容的副词httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-9-1-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">和Perl 5 兼容的副词</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-9-1-3-和perl-5-兼容的副词httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h4>
<p>副词 <code>:P5</code> 和 <code>:Perl5</code> 允许你在 Raku 程序中使用 Perl 5 正则表达式语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">next</span> <span class="k">if</span> <span class="nv">$ligne</span> <span class="o">=~</span> <span class="sr">m/[aeiou]/</span>   <span class="p">;</span>    <span class="c1"># Classe de caractères Perl 5</span>
</span></span><span class="line"><span class="cl"><span class="k">next</span> <span class="k">if</span> <span class="nv">$ligne</span> <span class="o">~~</span> <span class="n">m:P5</span><span class="sr">/[aeiou]/</span>   <span class="p">;</span> <span class="c1"># Raku, avec l&#39;adverbe P5</span>
</span></span><span class="line"><span class="cl"><span class="k">next</span> <span class="k">if</span> <span class="nv">$ligne</span> <span class="o">~~</span> <span class="n">m:Perl5</span><span class="sr">/[aeiou]/</span><span class="p">;</span> <span class="c1"># Raku, avec l&#39;adverbe Perl5</span>
</span></span><span class="line"><span class="cl"><span class="k">next</span> <span class="k">if</span> <span class="nv">$ligne</span> <span class="o">~~</span> <span class="sr">m/  &lt;[aeiou]&gt; /</span> <span class="p">;</span> <span class="c1"># Raku, nouvelle syntaxe des</span>
</span></span><span class="line"><span class="cl">                                    <span class="c1"># classes de caractères</span>
</span></span></code></pre></div><p>这可用于迁移方案或那些还没有习惯 Raku 正则表达式的情况，但我们没有更多的是住在我们对这种可能性在本教程旨在介绍Perl的正则表达式6的语法。</p>
<h3 id="2-9-2-认可副词httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-9-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">认可副词</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-9-2-认可副词httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>与正则表达式副词（第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-9-1">2.9.1</a>节  ）不同，它与正则表达式的声明相关，只有当你想匹配字符串和正则表达式时，匹配副词才有意义。</p>
<p>它们永远不会出现在正则表达式中，但只能出现在它之外，作为识别m / &hellip; /的一部分，或者作为匹配方法的参数。</p>
<h4 id="2-9-2-1-副词continue匹配的起始位置httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-9-2-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">副词“continue”（匹配的起始位置）</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-9-2-1-副词continue匹配的起始位置httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h4>
<p>副词 <code>:continue</code> 或 <code>:c</code> 接受一个参数：正则表达式开始搜索的位置。默认情况下，搜索从字符串的开头开始，但是副词 <code>:c</code> 会修改此行为。如果没有指定位置，则搜索将从位置0开始，除非定义了匹配对象 <code>$\</code>，在这种情况下，搜索将从位置 <code>$/</code>（在前一次匹配结束后的位置）开始。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">given</span> <span class="s">&#39;a1xa2&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="o">~</span><span class="sr">m/a./</span><span class="p">;</span>         <span class="c1"># a1</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="o">~</span><span class="n">m:c</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="sr">/a./</span><span class="p">;</span>    <span class="c1"># a2 (搜索从x的位置开始)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="2-9-2-2-副词exhaustive所有匹配httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-9-2-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">副词“exhaustive”（所有匹配）</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-9-2-2-副词exhaustive所有匹配httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h4>
<p>要查找正则表达式的所有可能匹配 - 包括重叠的那些 - 以及从相同位置开始的多个匹配，请使用副词 <code>:exhaustive</code> 或 <code>:ex</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">given</span> <span class="s">&#39;abracadabra&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">m:exhaustive</span><span class="sr">/ a .* a /</span> <span class="o">-&gt;</span> <span class="nv">$match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">say</span> <span class="s">&#39; &#39;</span> <span class="n">x</span> <span class="nv">$match</span><span class="o">.</span><span class="n">from</span><span class="p">,</span> <span class="o">~</span><span class="nv">$match</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面的代码显示以下结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">abracadabra</span>
</span></span><span class="line"><span class="cl"><span class="n">abracada</span>
</span></span><span class="line"><span class="cl"><span class="n">abraca</span>
</span></span><span class="line"><span class="cl"><span class="n">abra</span>
</span></span><span class="line"><span class="cl">   <span class="n">acadabra</span>
</span></span><span class="line"><span class="cl">   <span class="n">acada</span>
</span></span><span class="line"><span class="cl">   <span class="n">aca</span>
</span></span><span class="line"><span class="cl">     <span class="n">adabra</span>
</span></span><span class="line"><span class="cl">     <span class="n">ada</span>
</span></span><span class="line"><span class="cl">       <span class="n">abra</span>
</span></span></code></pre></div><h4 id="2-9-2-3-副词global所有匹配httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-9-2-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">副词“global”（所有匹配）</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-9-2-3-副词global所有匹配httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h4>
<p>不是搜索单个匹配并返回匹配对象，而是可以搜索每个匹配而不重叠，并使用副词 <code>:global</code> 或 <code>:g</code> 将结果作为列表返回 ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">given</span> <span class="s">&#39;Trois mots ici&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">@matches</span> <span class="o">=</span> <span class="n">m:global</span><span class="sr">/\w+/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="nv">@matches</span><span class="o">.</span><span class="n">elems</span><span class="p">;</span>         <span class="c1"># 3</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="o">~</span><span class="nv">@matches</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>           <span class="c1"># ici</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="2-9-2-4-副词poshttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-9-2-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">副词“pos”</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-9-2-4-副词poshttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h4>
<p>副词 <code>:pos</code> 或 <code>:p</code> 锚点匹配字符串中的特定位置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">given</span> <span class="s">&#39;abcdef&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$trouvé</span> <span class="o">=</span> <span class="n">m:pos</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="sr">/.*/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="nv">$trouvé</span><span class="o">.</span><span class="n">from</span><span class="p">;</span>        <span class="c1"># 2</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="o">~</span><span class="nv">$trouvé</span><span class="p">;</span>            <span class="c1"># cdef</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="2-9-2-5-副词overlap带重叠httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-9-2-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">副词“overlap”（带重叠）</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-9-2-5-副词overlap带重叠httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h4>
<p>要获得多个匹配，包括重叠匹配，但每个起始位置只有一个（最长），可以使用副词 <code>:overlap</code> 或 <code>:ov</code> ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">given</span> <span class="s">&#39;abracadabra&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">m:overlap</span><span class="sr">/ a .* a /</span> <span class="o">-&gt;</span> <span class="nv">$match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">say</span> <span class="s">&#39; &#39;</span> <span class="n">x</span> <span class="nv">$match</span><span class="o">.</span><span class="n">from</span><span class="p">,</span> <span class="o">~</span><span class="nv">$match</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个显示：</p>
<pre tabindex="0"><code>abracadabra
   acadabra
     adabra
       abra
</code></pre><h2 id="2-10-向前查看和向后查看断言httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-10 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">向前查看和向后查看（断言）</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-10-向前查看和向后查看断言httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>断言可以搜索向前或向后匹配，但不会像锚点那样消耗目标字符串（保持在相同位置）。</p>
<h3 id="2-10-1-before-断言httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-10-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">before 断言</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-10-1-before-断言httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>要检查模式之前，另一模式出现，它可以使用 before 断言，在下面的形式：<code>&lt;?before&gt;</code>。</p>
<p>因此，要搜索紧跟在字符串 titi 之后的字符串 foo，我们可以使用正则表达式 <code>rx {foo &lt;?before titi&gt;}</code>，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;tototiti&#34;</span> <span class="o">~~</span> <span class="n">rx</span><span class="p">{</span> <span class="n">toto</span> <span class="o">&lt;</span><span class="p">?</span><span class="n">before</span> <span class="n">titi</span><span class="o">&gt;</span><span class="p">};</span>   <span class="c1"># -&gt; toto</span>
</span></span></code></pre></div><p>相反，如果要搜索未紧跟其他模式的模式，则必须在断言以下形式之前使用否定： <code>&lt;!before pattern&gt;</code>。</p>
<p>例如，要查找不紧跟字符串titi的字符串foo，我们可以使用正则表达式 <code>rx {foo &lt;!before titi&gt;}</code>  ; 使用上面示例的字符串，此正则表达式将失败，因为foo后跟titi。</p>
<h3 id="2-10-2-after-断言httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-10-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">after 断言</a>&nbsp;<a class="headline-hash no-text-decoration" href="#2-10-2-after-断言httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>要检查模式是否出现在另一个模式之后，我们可以使用以下形式之后的断言 ：<code>&lt;?after pattern&gt;</code>。</p>
<p>例如，要找到紧跟在字符串titi之前的字符串foo，我们可以使用正则表达式 <code>rx {foo &lt;?after titi&gt;}</code>，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;tititoto&#34;</span> <span class="o">~~</span> <span class="n">rx</span><span class="p">{</span> <span class="o">&lt;</span><span class="p">?</span><span class="n">after</span> <span class="n">titi</span><span class="o">&gt;</span> <span class="n">toto</span> <span class="p">};</span>   <span class="c1"># -&gt; toto</span>
</span></span></code></pre></div><p>相反，如果要搜索不是紧接其他模式的模式，则必须使用以下形式的负数： <code>&lt;!after pattern&gt;</code>。</p>
<p>例如，要搜索的字符串FOO没有紧跟字符串蒂蒂，你可以使用正则表达式 <code>rx {&lt;!after&gt; foo}</code> ，其失败，上面的例子中的字符串（这是我们的目标）。</p>
<h1 id="3-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3. <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">Grammar</a></h1>
<p>语法是一种强大的工具，用于将文本分解为单个元素，并且通常返回通过解释该文本而创建的数据结构。</p>
<p>例如，使用Raku语法解释和执行Raku程序。</p>
<p>当前Raku用户的一个更实用的范围示例是Raku <a href="https://github.com/moritz/json">JSON::Tiny</a>模块，它可以反序列化任何有效的JSON文件。执行此反序列化的代码用不到100行简单代码编写，易于扩展。我们在下面描述（§3.6  <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-6">。</a>）这种语法的详细构造能够分析JSON。</p>
<p>如果你不喜欢在学校学习语法，不要逃避。Raku语法实际上是一种对正则表达式进行分组的简单方法，就像类可以将普通代码方法组合在一起一样（而且这个类比远比人们乍看之下想象的要多得多，因为它是稍后会看到）。</p>
<h2 id="3-1-该砖以建立一个语法httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">该“砖”，以建立一个语法</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-1-该砖以建立一个语法httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>上面已经看到了编写语法所需要知道和理解的大部分内容，特别是在第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-8">2.8</a> 章中<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-8">。</a><a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-8">子规则或命名规则</a>，以及子章节<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-9-1-1">2.9.1.1。</a>和<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-9-1-2">2.9.1.2。</a>以上。这些子规则或命名规则是语法的基本构建块。实际上，语法的主要目的之一是将命名的子表达或正则表达式（正则表达式，标记和规则类型）分组到明确定义的名称空间中，以避免标识符名称的冲突。在代码中的其他地方使用其他正则表达式。</p>
<p>回想一下， 正则表达式，标记和规则是非常相似的实体，用于以类似于函数或方法的定义的形式声明命名的正则表达式。在本章中，我们现在将它们统称为规则，而不管用于声明它们的关键字。它们声明如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">regex</span> <span class="n">ma_regex</span>  <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>  <span class="c1"># regex ordinaire</span>
</span></span><span class="line"><span class="cl"><span class="n">token</span> <span class="n">mon_token</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>  <span class="c1"># regex avec adverbe :ratchet implicite</span>
</span></span><span class="line"><span class="cl"><span class="n">rule</span> <span class="n">ma_règle</span>   <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>  <span class="c1"># regex avec :ratchet et :sigspace implicites</span>
</span></span></code></pre></div><p>记录：</p>
<ul>
<li>关键字regex表示普通的正则表达式;</li>
<li>关键字令牌隐含了副词：棘轮（“棘轮”），也就是说这种规则不会回溯（没有回溯）;</li>
<li>关键字规则隐式指示副词：棘轮（无后退空间）和：sigspace（模式的空格不被忽略）。</li>
</ul>
<p>以下是我们定义第一个数字规则的示例，并使用它来定义第二个十进制数  ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">chiffres</span> <span class="p">{</span> <span class="o">\</span><span class="n">d</span><span class="o">+</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">décimal</span> <span class="p">{</span> <span class="sr">&lt;chiffres&gt;</span> <span class="o">\.</span> <span class="sr">&lt;chiffres&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="s">&#34; Cet objet coûte 13.45 euros&#34;</span> <span class="o">~~</span> <span class="sr">/&lt;décimal&gt;/</span><span class="p">;</span> <span class="c1"># -&gt; True</span>
</span></span><span class="line"><span class="cl"><span class="c1"># (so renvoie une évaluation booléenne, donc, en fait True ou False)</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="o">~</span><span class="vg">$/</span><span class="p">;</span>                                              <span class="c1"># -&gt; 13.45</span>
</span></span></code></pre></div><p>我们在上面看到规则可以调用另一个规则，就像函数可以调用另一个函数一样。规则也可以递归调用自身。这个关键机制是Raku正则表达式的核心功能及其创建语法的能力。</p>
<p>令牌规则不会回滚：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">token</span> <span class="n">lettres</span> <span class="p">{</span> <span class="n">abc</span> <span class="o">.+</span> <span class="n">g</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;abcdefg&#34;</span> <span class="o">~~</span> <span class="sr">/&lt;lettres&gt;/</span> <span class="p">??</span> <span class="s">&#34;Réussit&#34;</span> <span class="o">!!</span> <span class="s">&#34;Échoue&#34;</span><span class="p">;</span> <span class="c1"># -&gt;  Échoue</span>
</span></span></code></pre></div><p>这条规则在这里失败，因为子模式。+，凭借其贪婪的量词“  +  ”消费链中的所有终端，包括最后一个字母“G”，所以该规则不再能匹配“G “最后已经消耗：因为她是不允许回去砸” G“，为了取得成功，离开它的处置模式的最后一个原子，它失败。</p>
<p>使用非贪婪（或节俭）量化器，修改后的字母规则成功：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">token</span> <span class="n">lettres</span> <span class="p">{</span> <span class="n">abc</span> <span class="o">.+</span><span class="p">?</span> <span class="n">g</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;abcdefg&#34;</span> <span class="o">~~</span> <span class="sr">/&lt;lettres&gt;/</span> <span class="p">??</span> <span class="s">&#34;Réussit&#34;</span> <span class="o">!!</span> <span class="s">&#34;Échoue&#34;</span><span class="p">;</span> <span class="c1"># -&gt;  Réussit</span>
</span></span></code></pre></div><p>使用相同的定义，类型规则规则将失败：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">rule</span>  <span class="n">lettres</span> <span class="p">{</span> <span class="n">abc</span> <span class="o">.+</span><span class="p">?</span> <span class="n">g</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;abcdefg&#34;</span> <span class="o">~~</span> <span class="sr">/&lt;lettres&gt;/</span> <span class="p">??</span> <span class="s">&#34;Réussit&#34;</span> <span class="o">!!</span> <span class="s">&#34;Échoue&#34;</span><span class="p">;</span> <span class="c1"># -&gt;  Échoue</span>
</span></span></code></pre></div><p>因为模式中的空格不再被忽略（并且在链中找不到）。</p>
<p>三种命名规则的名称，正则表达式，标记和规则，反映了这样一种观点，即在一种非常通用和模糊的方式中，正则表达式是关于通常所期望的。一个正则表达式（低级别分析，逐个字符），而一个令牌通常用于词法分析（将输入文本划分为“单词”或单个词位），并且规则将更频繁分析句法（分析lexemes之间的关系，可能取决于上下文）。这种理论上的任务划分受到许多例外的限制，并且不得在教条上遵循，但在决定不同类型的规则时，要牢记这一点。</p>
<h2 id="3-2-创建-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">创建 Grammar</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-2-创建-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>语法创建了一个合适的命名空间，并引入了关键字语法。</p>
<h3 id="3-2-1-语法的语法定义httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-2-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">语法的语法定义</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-2-1-语法的语法定义httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>就像一个类可以对命名的动作或方法进行分组：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">class</span> <span class="n">Identité</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">nom</span>     <span class="p">{</span> <span class="s">&#34;Nom = $!nom&#34;</span>     <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">âge</span>     <span class="p">{</span> <span class="s">&#34;Âge = $!âge&#34;</span>     <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">adresse</span> <span class="p">{</span> <span class="s">&#34;Adr = $!adresse&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">desc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">print</span> <span class="o">&amp;.</span><span class="n">nom</span><span class="p">(),</span>     <span class="s">&#34;\n&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="o">&amp;.</span><span class="n">âge</span><span class="p">(),</span>     <span class="s">&#34;\n&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="o">&amp;.</span><span class="n">adresse</span><span class="p">(),</span> <span class="s">&#34;\n&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># etc.</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>一个名为规则的语法组：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">Identité</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">nom</span>     <span class="p">{</span> <span class="n">Nom</span> <span class="s">&#39;=&#39;</span> <span class="p">(</span><span class="o">\</span><span class="n">N</span><span class="o">+</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># chaîne de caractères quelconques</span>
</span></span><span class="line"><span class="cl">                                   <span class="c1"># autres que des retours à la ligne</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">adresse</span> <span class="p">{</span> <span class="n">Adr</span> <span class="s">&#39;=&#39;</span> <span class="p">(</span><span class="o">\</span><span class="n">N</span><span class="o">+</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># idem</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">âge</span>     <span class="p">{</span> <span class="n">Age</span> <span class="s">&#39;=&#39;</span> <span class="p">(</span><span class="o">\</span><span class="n">d</span><span class="o">+</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># des chiffres</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">desc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="sr">&lt;nom&gt;</span>     <span class="o">\</span><span class="n">n</span>
</span></span><span class="line"><span class="cl">        <span class="sr">&lt;âge&gt;</span>     <span class="o">\</span><span class="n">n</span>
</span></span><span class="line"><span class="cl">        <span class="sr">&lt;adresse&gt;</span> <span class="o">\</span><span class="n">n</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># etc.</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里使用其他地方定义的其他规则（名称，年龄和地址）来定义desc规则。这使得逐渐建立越来越高的抽象水平成为可能。</p>
<p>这将创建一个语法类型对象，其类型表示正在分析的语言，并且可以以扩展语言的形式从中派生其他语法。</p>
<p>然后，新对象作为调用TOP方法（正则表达式，标记或规则）传递。这个默认的TOP方法可以被另一个传递给命名参数的规则替换：rule，这对于测试语法尤其有用。</p>
<p>请注意，不再需要使用my运算符声明规则，因为语法创建了必要的命名空间和词法范围。</p>
<h3 id="3-2-2-grammar-的继承httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-2-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">Grammar 的继承</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-2-2-grammar-的继承httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>语法可以从另一个（父）语法继承，就像一个类可以从另一个类继承一样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">texte</span>     <span class="p">{</span> <span class="sr">&lt;salutation&gt;</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">corps</span><span class="o">&gt;=</span><span class="sr">&lt;ligne&gt;</span><span class="o">+</span><span class="p">?</span> <span class="sr">&lt;fin&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">salutation</span>    <span class="p">{</span> <span class="p">[</span><span class="n">Salut</span><span class="o">|</span><span class="n">Bonjour</span><span class="p">]</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">dest</span><span class="o">&gt;=\</span><span class="n">S</span><span class="o">+</span><span class="p">?</span> <span class="s">&#39;,&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">fin</span>    <span class="p">{</span> <span class="p">[</span><span class="n">à</span><span class="o">|</span><span class="s">&#39;@&#39;</span><span class="p">]</span> <span class="n">plus</span> <span class="s">&#39;,&#39;</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">auteur</span><span class="o">&gt;=.+</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">ligne</span>    <span class="p">{</span> <span class="o">\</span><span class="n">N</span><span class="o">*</span> <span class="o">\</span><span class="n">n</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">MessageFormel</span> <span class="n">is</span> <span class="n">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">salutation</span> <span class="p">{</span> <span class="p">[</span><span class="n">Cher</span><span class="o">|</span><span class="n">Chère</span><span class="p">]</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">dest</span><span class="o">&gt;=\</span><span class="n">S</span><span class="o">+</span><span class="p">?</span> <span class="s">&#39;,&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">fin</span> <span class="p">{</span> <span class="n">Bien</span> <span class="n">cordialement</span> <span class="s">&#39;,&#39;</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">auteur</span><span class="o">&gt;=.+</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里，MessageFormel语法继承父语法消息。与类的方法一样，规则继承自父语法（和多态），因此无需重新定义不更改的文本和行规则。我们只重载改变的规则。</p>
<p>所有语法都是从语法类派生的，语法类除其他外提供了所有语法共有的方法，如.parse和.fileparse，如下所述。</p>
<p>语法从其他语法继承的能力是一种极其强大的工具，是允许Raku语言可扩展性的重要因素（见第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-9">3.9</a>节  ）。</p>
<h2 id="3-3-使用-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">使用 Grammar</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-3-使用-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>可以通过在该语法上调用.parse方法并可选地将操作对象作为参数传递来解析带有语法的字符串（参见下面的第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-4">3.4</a>节  ）。同样，.parsefile方法用于解析文件。</p>
<pre tabindex="0"><code>MaGrammaire.parse($chaîne, :actions($objet-action))
MaGrammar.parsefile($nom-fic, :actions($objet-action))
</code></pre><p>.parse和.parsefile方法锚定在文本的开头和结尾，如果未到达文本末尾则失败。</p>
<p>原则上，有必要使用语法来执行文本的实际词法和句法分析。要提取复杂数据，建议将操作对象与语法结合使用。</p>
<h2 id="3-4-类和对象的股票httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">类和对象的股票</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-4-类和对象的股票httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<h3 id="3-4-1-在确认期间执行代码httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-4-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">在确认期间执行代码</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-4-1-在确认期间执行代码httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>当语法成功解析文本时，它返回一个匹配对象的语法树。这棵树越深（并且它通常变得非常快），并且这棵树中的分支越多，探索这棵树以找到正在寻找的信息就越困难。</p>
<p>为了避免必须对匹配树进行这种探索，可以提供一个行动对象。在对命名的语法规则进行每次成功分析之后，它会尝试调用此操作对象的方法，该方法具有与规则相同的名称，方法是将其作为刚刚匹配的对象的位置参数提供创建。此方法（如果存在）可以特别用于构建抽象语法树（Astract语法树或AST）或执行将来可能需要的各种其他事物。如果此方法不存在，则忽略此步骤。</p>
<p>这是一个极简主义，有点人为的语法和动作一起工作的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">v6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">GrammaireTest</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">TOP</span> <span class="p">{</span> <span class="o">^</span> <span class="o">\</span><span class="n">d</span><span class="o">+</span> <span class="nv">$</span> <span class="err">}</span>
</span></span><span class="line"><span class="cl"><span class="err">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">class</span> <span class="n">ActionsTest</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">TOP</span><span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="vg">$/</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="o">~</span><span class="vg">$/</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$actions</span> <span class="o">=</span> <span class="n">ActionsTest</span><span class="o">.</span><span class="k">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$reconnu</span> <span class="o">=</span> <span class="n">GrammaireTest</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#39;40&#39;</span><span class="p">,</span> <span class="p">:</span><span class="nv">$actions</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="nv">$reconnu</span><span class="p">;</span>          <span class="c1"># -&gt; ｢40｣</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="nv">$reconnu</span><span class="o">.</span><span class="n">made</span><span class="p">;</span>     <span class="c1"># -&gt; 42</span>
</span></span></code></pre></div><p>Actiontest类的$ action对象被实例化，并在调用.parse方法时作为参数传递。当TOP规则匹配出该参数时，语法通过将匹配的对象作为参数传递给它来自动调用TOP方法。</p>
<p>类Match的make方法使用其参数提供结构$ / .Med（用户决定其内容，但通常是一个抽象的语法树）。</p>
<p>为了证明参数是一个公认的对象，该示例使用 <code>$/</code> 作为传递给action方法的参数名称，但这只是一个方便的约定，没有任何内在的必要条件在这里。通过认可的 <code>$</code> 也会起作用。（但请注意，使用 <code>$/</code> 可以提供快捷方式 <code>$&lt;capture&gt;</code> 而不是 <code>$/&lt;capture&gt;</code>。）</p>
<p>这是一个稍微更具体的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">v6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">PairesClésValeurs</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">TOP</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span><span class="sr">&lt;paire&gt;</span> <span class="o">\</span><span class="n">n</span><span class="o">+</span><span class="p">]</span><span class="o">*</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">ws</span> <span class="p">{</span> <span class="o">\</span><span class="n">h</span><span class="o">*</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">paire</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="sr">&lt;clé=.identifiant&gt;</span> <span class="s">&#39;=&#39;</span> <span class="sr">&lt;valeur=.identifiant&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">identifiant</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">\</span><span class="n">w</span><span class="o">+</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">class</span> <span class="n">PairesClésValeursActions</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">identifiant</span><span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span> <span class="vg">$/</span><span class="o">.</span><span class="n">make:</span> <span class="o">~</span><span class="vg">$/</span>                           <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">paire</span>      <span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span> <span class="vg">$/</span><span class="o">.</span><span class="n">make:</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">clé</span><span class="o">&gt;.</span><span class="n">made</span> <span class="o">=&gt;</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">valeur</span><span class="o">&gt;.</span><span class="n">made</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">TOP</span>        <span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span> <span class="vg">$/</span><span class="o">.</span><span class="n">make:</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">paire</span><span class="o">&gt;</span><span class="err">»</span><span class="o">.</span><span class="n">made</span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span>  <span class="nv">$res</span> <span class="o">=</span> <span class="n">PairesClésValeurs</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="sx">q:to/EOI/, :</span><span class="n">actions</span><span class="p">(</span><span class="n">PairesClésValeursActions</span><span class="p">))</span><span class="o">.</span><span class="n">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">phase</span><span class="o">=</span><span class="n">b</span>
</span></span><span class="line"><span class="cl">    <span class="n">points</span><span class="o">=</span><span class="mi">42</span>
</span></span><span class="line"><span class="cl">    <span class="n">Perl</span><span class="o">=</span><span class="mi">6</span>
</span></span><span class="line"><span class="cl">    <span class="n">EOI</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@$res</span> <span class="o">-&gt;</span> <span class="nv">$p</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#34;Clef : $p.clé()\tValeur : $p.valeur()&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其中显示以下结果：</p>
<pre tabindex="0"><code>Clef : phase      Valeur : b
Clef : points     Valeur : 42
Clef : Perl       Valeur : 6
</code></pre><p>规则对，其中分析一对由等于字符分隔的标识符，提供的别名规则的两个呼叫标识符来区分渔获的名称和使它们可更容易地且直观地。相应的action-method构造一个Pair类型的对象，并使用已匹配的子对象的属性.made。因此（以及TOP -action方法），它利用了子匹配的动作方法在对应于边界正则表达式之前被调用的事实。因此，以所需顺序调用动作方法。</p>
<p>TOP动作方法简单地收集由偶数规则的多个匹配生成的所有对象，并将它们作为列表返回。</p>
<p>另请注意，PairsKeyActionList在此作为类型对象（而不是对象的实例）传递给.parse方法，这是可能的，因为没有一个action-methods使用属性（仅在正确初始化的实例中可用）。</p>
<p>在某些情况下，可能需要将状态保留在属性中。在这种情况下，它是一个必须传递给.parse方法的实例化对象。</p>
<p>action-methods还可用于调试顽固语法，例如通过显示解析的中间状态。但是动作方法的基本作用是将简单语法转换为真正的解析工具，生成一个抽象语法树，Perl解释器（或其他工具）可以使用它来生成，例如可执行代码。</p>
<h3 id="3-4-2-在语法中执行代码的其他方法httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-4-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">在语法中执行代码的其他方法</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-4-2-在语法中执行代码的其他方法httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>在上面的例子中，action-methods是在一个与语法本身不同的动作中定义的，这通常是任何扩展的语法。</p>
<p>但是，对于简单的情况，也可以在语法本身中定义方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">Toto</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">regex</span> <span class="n">titi</span> <span class="p">{</span> <span class="sr">&lt;.configurer&gt;</span> <span class="n">blah</span> <span class="n">blah</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">configurer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># faire quelque chose ici</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>是的，语法可以定义方法（他们甚至可以使用角色，我们将在第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-9-1">3.9.1</a>节中详细介绍），它们实际上是类&hellip;&hellip;</p>
<p>通过在大括号之间插入代码，也可以在规则中执行代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">toto</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">regex</span> <span class="n">titi</span> <span class="p">{</span> <span class="n">blah</span> <span class="n">blah</span> <span class="p">{</span> <span class="n">say</span> <span class="s">&#34;Je suis arrivé ici&#34;</span><span class="p">}</span> <span class="n">blah</span> <span class="n">blah</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果匹配出代码块之前的模式部分，则立即执行该块。</p>
<p>本工程以真理的任何正则表达式（名为或非规则，甚至外的语法），这可以用于调试正则表达式的例子帮助（见 §  <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L4-6">4.6。</a> <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L4-6">调试Perl的正则表达式语法或6</a>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">lettres</span> <span class="p">{</span> <span class="n">a</span> <span class="n">b</span> <span class="p">{</span><span class="n">say</span> <span class="s">&#34;reconnu ab&#34;</span><span class="p">}</span> <span class="n">c</span> <span class="n">d</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span>  <span class="s">&#34;abc&#34;</span> <span class="o">~~</span> <span class="sr">/&lt;lettres&gt;/</span><span class="p">;</span> <span class="c1"># -&gt; reconnu ab / False</span>
</span></span><span class="line"><span class="cl"><span class="c1"># la regex ci-dessus a reconnu ab et l&#39;affiche et n&#39;a échoué qu&#39;ensuite</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span>  <span class="s">&#34;abcde&#34;</span> <span class="o">~~</span> <span class="sr">/&lt;lettres&gt;/</span><span class="p">;</span> <span class="c1"># -&gt; reconnu ab / True - ici, succès</span>
</span></span></code></pre></div><p>但是要小心：如果正则表达式是回溯，则可能会多次执行代码块：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="s">&#34;aaa&#34;</span> <span class="o">~~</span> <span class="sr">/ a { say &#34;Bonjour&#34; } b /</span><span class="p">;</span>
</span></span></code></pre></div><p>这个显示：</p>
<pre tabindex="0"><code>Bonjour
Bonjour
Bonjour
False
</code></pre><h2 id="3-5-验证perl模块名称的-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">验证Perl模块名称的 Grammar</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-5-验证perl模块名称的-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>此示例的目的是验证Perl模块名称。</p>
<p>Perl模块的名称可以分解为由冒号对分隔的标识符：“::”，例如<a href="http://search.cpan.org/~pevans/Scalar-List-Utils-1.42/lib/List/Util.pm">List::Util</a>或<a href="http://search.cpan.org/~rehsack/List-MoreUtils-0.413/lib/List/MoreUtils.pm">List::MoreUtils</a>（这里提供的模块名称示例是模块Perl 5）。标识符必须以字母字符（az）或带下划线的字符开头，后跟零个，一个或多个字母数字字符。</p>
<p>到目前为止没有什么非常复杂，但这有点复杂，因为有些模块有一个标识符（<a href="http://search.cpan.org/~mjd/Memoize-1.01/Memoize.pm">Memoize</a>），因此没有冒号，而其他模块可能有“扩展”名称：<a href="http://search.cpan.org/dist/Regexp-Common-Email-Address/lib/Regexp/Common/Email/Address.pm">Regexp::Common::Email::Address</a>。</p>
<p>他不是一个很好的语法候选人吗？</p>
<h3 id="3-5-1-验证-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-5-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">验证 Grammar</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-5-1-验证-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>例如，足以定义保证上面的命名规则和分隔符规则的标识符规则，并在语法中正确地组合它们。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">Valide</span><span class="o">-</span><span class="n">Nom</span><span class="o">-</span><span class="n">Module</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">TOP</span> <span class="p">{</span> <span class="o">^</span> <span class="sr">&lt;identifiant&gt;</span> <span class="p">[</span> <span class="sr">&lt;séparateur&gt;</span> <span class="sr">&lt;identifiant&gt;</span> <span class="p">]</span><span class="o">*</span> <span class="nv">$</span><span class="err">}</span>
</span></span><span class="line"><span class="cl">    <span class="nv">token</span> <span class="n">identifiant</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="sr">&lt;[A..Za..z_]&gt;</span>      <span class="c1"># &#39;mot&#39; commençant par un caractère </span>
</span></span><span class="line"><span class="cl">                           <span class="c1"># alphabétique ou un caractère souligné </span>
</span></span><span class="line"><span class="cl">        <span class="sr">&lt;[A..Za..z0..9_]&gt;</span><span class="o">*</span>  <span class="c1"># 0 ou plusieurs caractères alphanumériques</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">séparateur</span> <span class="p">{</span> <span class="s">&#39;::&#39;</span> <span class="p">}</span>    <span class="c1"># paire de caractères deux-points</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们现在可以使用一些有效的模块名来测试这个语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">for</span>  <span class="o">&lt;</span><span class="n">Super:Nouveau::Module</span> <span class="n">Super</span><span class="o">.</span><span class="n">Nouveau</span><span class="o">.</span><span class="n">Module</span> 
</span></span><span class="line"><span class="cl">      <span class="nn">Super::</span><span class="mi">6</span><span class="nn">ouveau::</span><span class="n">Module</span> <span class="nn">Super::Nouveau::</span><span class="n">Module</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="nv">$nom</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$reconnu</span> <span class="o">=</span>  <span class="n">Valide</span><span class="o">-</span><span class="n">Nom</span><span class="o">-</span><span class="n">Module</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nv">$nom</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#34;nom\t&#34;</span><span class="p">,</span> <span class="nv">$reconnu</span> <span class="p">??</span> <span class="nv">$reconnu</span> <span class="o">!!</span> <span class="s">&#34;Nom de module invalide&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个显示：</p>
<pre tabindex="0"><code>Super:Nouveau::Module   Nom de module invalide
Super.Nouveau.Module    Nom de module invalide
Super::6ouveau::Module  Nom de module invalide
Super::Nouveau::Module  ｢Super::Nouveau::Module｣
 identifiant =&gt; ｢Super｣
 séparateur =&gt; ｢::｣
 identifiant =&gt; ｢Nouveau｣
 séparateur =&gt; ｢::｣
 identifiant =&gt; ｢Module｣
</code></pre><p>只匹配出有效的模块名称，其他三个名称被正确拒绝。</p>
<p>有时，通过用短划线替换色列对来汇总模块名称。例如，官方名称是<a href="http://search.cpan.org/dist/Regexp-Common-Email-Address/lib/Regexp/Common/Email/Address.pm">Regexp::Common::Email::Address</a>，也可以是<a href="http://search.cpan.org/~cwest/Regexp-Common-Email-Address/">Regexp-Common-Email-Address</a>。如果想要验证第二次写作，只需修改分隔符以便它也授权破折号：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">rule</span> <span class="n">séparateur</span> <span class="p">{</span> <span class="s">&#39;::&#39;</span> <span class="o">||</span> <span class="o">\-</span> <span class="p">}</span>    <span class="c1"># deux car. deux-points ou tiret</span>
</span></span></code></pre></div><p>通过使用名称“Super-New-Module”测试语法，我们获得：</p>
<pre tabindex="0"><code>Super-Nouveau-Module  ｢Super-Nouveau-Module｣
 identifiant =&gt; ｢Super｣
 séparateur =&gt; ｢-｣
 identifiant =&gt; ｢Nouveau｣
 séparateur =&gt; ｢-｣
 identifiant =&gt; ｢Module｣
</code></pre><p>修改分隔符规则就足以使修改扩展到所有语法，直到规则TOP。</p>
<h3 id="3-5-2-添加动作对象httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-5-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">添加动作对象</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-5-2-添加动作对象httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>上述语法可以确定Perl模块名称是否有效。</p>
<p>我们现在想要在模块名称太长（超过5个标识符）时添加警告; 在这种情况下，模块的名称仍然有效，但建议模块的作者尝试选择较短的名称。</p>
<p>例如，只需添加如下定义的 Valide-Name-Module-Actions操作类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">class</span> <span class="n">Valide</span><span class="o">-</span><span class="n">Nom</span><span class="o">-</span><span class="n">Module</span><span class="o">-</span><span class="n">Actions</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">TOP</span><span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">identifiant</span><span class="o">&gt;.</span><span class="n">elems</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">warn</span> <span class="s">&#34;Nom de module très long! Peut-être le réduire ?\n&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>该类的定义并不特殊，它是一个普通的Raku类。重要的特征是这里定义的唯一方法与其中一个语法规则具有相同的名称（在本例中，语法中的输入规则为TOP）。如果标识符的数量超过5，将发送警告，但这不会阻止验证模块的名称。</p>
<p>调用语法的语法更改如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$reconnu</span> <span class="o">=</span>  <span class="n">Valide</span><span class="o">-</span><span class="n">Nom</span><span class="o">-</span><span class="n">Module</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nv">$nom</span><span class="p">,</span> <span class="p">:</span><span class="n">actions</span><span class="p">(</span><span class="n">Valide</span><span class="o">-</span><span class="n">Nom</span><span class="o">-</span><span class="n">Module</span><span class="o">-</span><span class="n">Actions</span><span class="p">));</span>
</span></span></code></pre></div><p>如果我们使用模块名称“ Super::New::Module  ”（或“  Super-New-Module  ”）调用语法，结果与之前相同  ，这是令人放心的。</p>
<p>但是使用Mary Poppins的模块名称：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$nom</span> <span class="o">=</span> <span class="s">&#34;Mon::Module::Super::Cali::Fragi::Listi::Cexpi::Delilicieux&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$reconnu</span> <span class="o">=</span>  <span class="n">Valide</span><span class="o">-</span><span class="n">Nom</span><span class="o">-</span><span class="n">Module</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nv">$nom</span><span class="p">,</span> <span class="p">:</span><span class="n">actions</span><span class="p">(</span><span class="n">Valide</span><span class="o">-</span><span class="n">Nom</span><span class="o">-</span><span class="n">Module</span><span class="o">-</span><span class="n">Actions</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="nv">$reconnu</span> <span class="k">if</span> <span class="nv">$reconnu</span><span class="p">;</span>
</span></span></code></pre></div><p>我们收到警告：</p>
<pre tabindex="0"><code>&gt; raku grammaire_nom_module.pl
Nom de module très long! Peut-être le réduire ?
  in method TOP at raku_grammaire_module.pl:15
｢Mon::Module::Super::Cali::Fragi::Listi::Cexpi::Delilicieux｣
 identifiant =&gt; ｢Mon｣
 séparateur =&gt; ｢::｣
 identifiant =&gt; ｢Module｣
 séparateur =&gt; ｢::｣
 identifiant =&gt; ｢Super｣
(...)
 identifiant =&gt; ｢Delilicieux｣
</code></pre><p>然后显示已匹配的对象。</p>
<p>请注意，语法调用直接作为操作类的参数传递给上面。如  <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-4-1">3.4.1中所述</a>，如有必要，可以传递此类的实例化对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$nom</span> <span class="o">=</span> <span class="s">&#34;Mon::Module::Super::Cali::Fragi::Listi::Cexpi::Delilicieux&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$actions</span> <span class="o">=</span> <span class="n">Valide</span><span class="o">-</span><span class="n">Nom</span><span class="o">-</span><span class="n">Module</span><span class="o">-</span><span class="n">Actions</span><span class="o">.</span><span class="k">new</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$reconnu</span> <span class="o">=</span>  <span class="n">Valide</span><span class="o">-</span><span class="n">Nom</span><span class="o">-</span><span class="n">Module</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nv">$nom</span><span class="p">,</span> <span class="p">:</span><span class="n">actions</span><span class="p">(</span><span class="nv">$actions</span><span class="p">));</span>
</span></span></code></pre></div><p>这个显示：</p>
<pre tabindex="0"><code>raku grammaire_nom_module.pl
Nom de module très long! Peut-être le réduire ?
  in method TOP at raku_grammaire_module.pl:15
</code></pre><p>这个验证模块名称的例子非常松散地基于 David Farrell的文章<a href="http://perltricks.com/article/144/2015/1/13/How-to-create-a-grammar-in-Perl-6">如何在Raku中创建语法</a> 。</p>
<h2 id="3-6-分析json的-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">分析JSON的 Grammar</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-6-分析json的-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>JavaScript Object Notation（JSON ）是从JavaScript对象表示法派生的文本数据格式。他成为（连同其他如XML和YAML）通常用于序列化的数据结构，例如允许平台或不同语言之间的交流，或将它们存储持久标准（例如，在文件中）。</p>
<h3 id="3-6-1-json文档的结构httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6-1<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#"> JSON文档的结构</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-6-1-json文档的结构httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p><a href="https://fr.wikipedia.org/wiki/JavaScript_Object_Notation">JSON</a>格式具有简单的优点。JSON文档包括两种类型的结构实体：</p>
<ul>
<li>对象或名称/值对列表（基本上对应于JavaScript对象或Perl散列表）;</li>
<li>有序的值列表（表）。</li>
</ul>
<p>值本身可以是（递归）对象或数组，如上所述，或基本通用数据：布尔值（true或false），数字，字符串或null（空值或无定义值） 。</p>
<p>字符串是包含整数（可能为零）unicode字符的序列。数字的格式为带符号的小数，可能包含小数或高功率部分（E表示法）。JSON不区分整数和浮点数。</p>
<h3 id="3-6-2-示例json文档httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">示例JSON文档</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-6-2-示例json文档httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>作为本教程的一部分，我们将使用以下JSON文档来检查语法的工作原理：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;prénom&#34;</span><span class="p">:</span> <span class="s2">&#34;Martine&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;nom&#34;</span><span class="p">:</span> <span class="s2">&#34;Unetelle&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;enVie&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;âge&#34;</span><span class="p">:</span> <span class="mi">28</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;sexe&#34;</span><span class="p">:</span> <span class="s2">&#34;F&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;adresse&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;NumRue&#34;</span><span class="p">:</span> <span class="s2">&#34;21 rue Pasteur&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;Ville&#34;</span><span class="p">:</span> <span class="s2">&#34;Lyon&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;CodePostal&#34;</span><span class="p">:</span> <span class="s2">&#34;F-69000&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;NumérosTéléphone&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;domicile&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;num&#34;</span><span class="p">:</span> <span class="s2">&#34;04 05 06 07 08&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;professionnel&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;num&#34;</span><span class="p">:</span> <span class="s2">&#34;04 08 07 06 05&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;mobile&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;num&#34;</span><span class="p">:</span> <span class="s2">&#34;06 12 34 56 78&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;enfants&#34;</span><span class="p">:</span> <span class="p">[],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;Conjoint&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;Profession&#34;</span><span class="p">:</span> <span class="s2">&#34;sage-femme&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;Hobbies&#34;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&#34;GRS&#34;</span><span class="p">,</span> <span class="s2">&#34;surf&#34;</span><span class="p">,</span> <span class="s2">&#34;peinture&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>已经使用可用工具验证了本文档符合JSON标准，并且可以看出它包含上述所有类型数据的示例。</p>
<h3 id="3-6-3-逐步写出json-grammar-的元素httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">逐步写出JSON Grammar 的元素</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-6-3-逐步写出json-grammar-的元素httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<h4 id="3-6-3-1-数字httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6-3-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">数字</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-6-3-1-数字httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h4>
<p>选择的示例JSON文档仅包含整数，但是数字实体的描述（第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-6-1">3.6.1</a>节）表明必须能够匹配具有例如以下格式的数字：“17”， “-138.27”，“1.2e-3”等</p>
<p>这可能会导致以下规则：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">token</span> <span class="n">nombre</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="o">\+|\-</span><span class="p">]?</span>             <span class="c1"># signe optionnel</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span> <span class="sr">&lt;[0..9]&gt;</span><span class="o">*</span> <span class="p">]</span>        <span class="c1"># chiffres optionnels (partie entière)</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span> <span class="o">\.</span> <span class="sr">&lt;[0..9]&gt;</span><span class="o">+</span> <span class="p">]?</span>    <span class="c1"># séparateur décimal et partie fractionnaire</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span> <span class="sr">&lt;[eE]&gt;</span> <span class="p">[</span><span class="o">\+|\-</span><span class="p">]?</span> <span class="sr">&lt;[0..9]&gt;</span><span class="o">+</span> <span class="p">]?</span>  <span class="c1"># exposant optionnel</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="3-6-3-2-字符串httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6-3-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">字符串</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-6-3-2-字符串httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h4>
<p>可以想象许多通过模式定义字符串的方法。对于选择的示例JSON文档，以下规则就足够了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">token</span> <span class="n">chaîne</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">\</span><span class="err">&#34;</span> <span class="o">&lt;</span><span class="p">[</span>  <span class="o">\</span><span class="n">w</span> <span class="o">\</span><span class="n">s</span> <span class="o">-</span> <span class="p">]</span><span class="o">&gt;+</span> <span class="o">\</span><span class="err">&#34;</span> <span class="c1"># caractères alphanumériques, espaces et</span>
</span></span><span class="line"><span class="cl">                          <span class="c1"># tirets, le tout entre des guillemets</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对于真正的JSON解析器，我们可能更喜欢使用负字符类的规则，该字符类不包括任何不属于字符串的内容，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">token</span> <span class="n">chaîne</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">\</span><span class="s">&#34; &lt;-[\n &#34;</span> <span class="o">\</span><span class="n">t</span><span class="p">]</span><span class="o">&gt;*</span> <span class="o">\</span><span class="err">&#34;</span>  <span class="c1"># tous caractères sauf guillemets, retours à</span>
</span></span><span class="line"><span class="cl">                         <span class="c1"># la ligne et tabulations, entre guillemets</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>应该查看JSON标准的细节，以精确地细化JSON字符串中可接受或不可接受的内容。上面引用的第一条规则足以满足所选的例子。</p>
<h4 id="3-6-3-3-json对象httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6-3-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">JSON对象</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-6-3-3-json对象httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h4>
<p>JSON对象是键/值对的列表。这些列表由大括号框起，并且这些对用逗号分隔。键/值对是标识符（字符串，上面已定义的规则），后跟冒号，后跟值。这可以翻译如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">rule</span> <span class="n">objet</span>       <span class="p">{</span> <span class="s">&#39;{&#39;</span>  <span class="sr">&lt;listepaires&gt;</span> <span class="s">&#39;}&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">rule</span> <span class="n">listepaires</span> <span class="p">{</span> <span class="sr">&lt;paire&gt;</span> <span class="o">*</span> <span class="nv">%</span> <span class="err">\</span><span class="p">,</span>         <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">rule</span> <span class="n">paire</span>       <span class="p">{</span> <span class="sr">&lt;chaîne&gt;</span> <span class="s">&#39;:&#39;</span> <span class="sr">&lt;valeur&gt;</span>  <span class="p">}</span>
</span></span></code></pre></div><p>为了理解{&lt;对&gt; *％} ，它是值得记住的修饰语“  ％  ”施加到量词指定的隔膜必须被重复认可之间存在（见第  <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-4">2.4。 </a>）。此修饰符可以轻松指定对以逗号分隔。如果没有此修饰符，则必须编写，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">rule</span> <span class="n">listepaires</span> <span class="p">{</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="o">|</span> <span class="p">[</span><span class="sr">&lt;paire&gt;</span> <span class="p">[</span><span class="s">&#39;,&#39;</span> <span class="sr">&lt;paire&gt;</span><span class="p">]</span><span class="o">*</span><span class="p">]</span> <span class="p">}</span>
</span></span></code></pre></div><p>这不太方便，可读性也差一点。</p>
<h4 id="3-6-3-4-json表httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6-3-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">JSON表</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-6-3-4-json表httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h4>
<p>表是值列表。列表用方括号括起来，值用逗号分隔：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">rule</span> <span class="n">tableau</span>       <span class="p">{</span> <span class="s">&#39;[&#39;</span> <span class="sr">&lt;listeTableaux&gt;</span> <span class="s">&#39;]&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">rule</span> <span class="n">listeTableaux</span> <span class="p">{</span>  <span class="sr">&lt;valeur&gt;</span> <span class="o">*</span> <span class="nv">%</span> <span class="err">[</span> <span class="err">\</span><span class="p">,</span> <span class="p">]</span>  <span class="p">}</span>
</span></span></code></pre></div><h4 id="3-6-3-5-值httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6-3-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">值</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-6-3-5-值httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h4>
<p>值可以是对象，数组，字符串，数字，布尔值或null。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">token</span> <span class="n">valeur</span> <span class="p">{</span> <span class="o">|</span> <span class="sr">&lt;objet&gt;</span> <span class="o">|</span> <span class="sr">&lt;tableau&gt;</span> <span class="o">|</span> <span class="sr">&lt;chaîne&gt;</span> <span class="o">|</span> <span class="sr">&lt;nombre&gt;</span> 
</span></span><span class="line"><span class="cl">               <span class="o">|</span> <span class="n">true</span>    <span class="o">|</span> <span class="n">false</span>     <span class="o">|</span> <span class="n">null</span> 
</span></span><span class="line"><span class="cl">             <span class="p">}</span>
</span></span></code></pre></div><p>这种语法非常有效，但是目前可以考虑一种有些先进的句法符号，这种符号在本文档中尚未解决，后面将在第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-9-4">3.9.4</a>节中讨论<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-9-4">原型规则</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">proto</span> <span class="n">token</span> <span class="n">valeur</span> <span class="p">{</span><span class="o">*</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">token</span> <span class="n">valeur:sym</span><span class="sr">&lt;nombre&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span>  <span class="s">&#39;-&#39;</span> <span class="o">|</span> <span class="s">&#39;+&#39;</span> <span class="p">]?</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span> <span class="sr">&lt;[0..9]&gt;</span><span class="o">*</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span> <span class="o">\.</span> <span class="sr">&lt;[0..9]&gt;</span><span class="o">+</span> <span class="p">]?</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span> <span class="sr">&lt;[eE]&gt;</span> <span class="p">[</span><span class="o">\+|\-</span><span class="p">]?</span> <span class="sr">&lt;[0..9]&gt;</span><span class="o">+</span> <span class="p">]?</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">token</span> <span class="n">chaîne</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">\</span><span class="err">&#34;</span> <span class="o">&lt;</span><span class="p">[</span>  <span class="o">\</span><span class="n">w</span> <span class="o">\</span><span class="n">s</span> <span class="o">-</span> <span class="p">]</span><span class="o">&gt;+</span> <span class="o">\</span><span class="err">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">token</span> <span class="n">valeur:sym</span><span class="sr">&lt;true&gt;</span>    <span class="p">{</span> <span class="sr">&lt;sym&gt;</span>     <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">token</span> <span class="n">valeur:sym</span><span class="sr">&lt;false&gt;</span>   <span class="p">{</span> <span class="sr">&lt;sym&gt;</span>     <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">token</span> <span class="n">valeur:sym</span><span class="sr">&lt;null&gt;</span>    <span class="p">{</span> <span class="sr">&lt;sym&gt;</span>     <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">token</span> <span class="n">valeur:sym</span><span class="sr">&lt;objet&gt;</span>   <span class="p">{</span> <span class="sr">&lt;objet&gt;</span>   <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">token</span> <span class="n">valeur:sym</span><span class="sr">&lt;tableau&gt;</span> <span class="p">{</span> <span class="sr">&lt;tableau&gt;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">token</span> <span class="n">valeur:sym</span><span class="sr">&lt;chaîne&gt;</span>  <span class="p">{</span> <span class="sr">&lt;chaîne&gt;</span>  <span class="p">}</span>
</span></span></code></pre></div><p>这种不那么简洁的符号具有促进语法扩展的优点，但是这里的兴趣相当有限，因为JSON标准是严格且相对不可变的。上面引用的第一条规则足以满足所选的例子。</p>
<h3 id="3-6-4-json-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">JSON Grammar</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-6-4-json-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>现在可以组合上面描述的不同元素并添加TOP规则来编写整个语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">JSON</span><span class="o">-</span><span class="n">Grammaire</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">TOP</span>          <span class="p">{</span> <span class="o">^</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="p">[</span> <span class="sr">&lt;objet&gt;</span> <span class="o">|</span> <span class="sr">&lt;tableau&gt;</span> <span class="p">]</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="nv">$</span> <span class="err">}</span>
</span></span><span class="line"><span class="cl">    <span class="nv">rule</span> <span class="n">objet</span>         <span class="p">{</span> <span class="s">&#39;{&#39;</span>  <span class="sr">&lt;listepaires&gt;</span> <span class="s">&#39;}&#39;</span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">listepaires</span>   <span class="p">{</span> <span class="sr">&lt;paire&gt;</span> <span class="o">*</span> <span class="nv">%</span> <span class="err">\</span><span class="p">,</span>          <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">paire</span>         <span class="p">{</span> <span class="sr">&lt;chaîne&gt;</span> <span class="s">&#39;:&#39;</span> <span class="sr">&lt;valeur&gt;</span>   <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">tableau</span>       <span class="p">{</span> <span class="s">&#39;[&#39;</span> <span class="sr">&lt;listeTableaux&gt;</span> <span class="s">&#39;]&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">listeTableaux</span> <span class="p">{</span>  <span class="sr">&lt;valeur&gt;</span> <span class="o">*</span> <span class="nv">%</span> <span class="err">[</span> <span class="err">\</span><span class="p">,</span> <span class="p">]</span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">chaîne</span>       <span class="p">{</span> <span class="o">\</span><span class="err">&#34;</span> <span class="p">(</span><span class="o">&lt;</span><span class="p">[</span> <span class="o">\</span><span class="n">w</span> <span class="o">\</span><span class="n">s</span> <span class="o">-</span> <span class="p">]</span><span class="o">&gt;+</span><span class="p">)</span> <span class="o">\</span><span class="err">&#34;</span>  <span class="p">}</span>    
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">nombre</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span><span class="o">\+</span> <span class="o">|</span> <span class="o">\-</span><span class="p">]?</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span> <span class="sr">&lt;[0..9]&gt;</span><span class="o">*</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span> <span class="o">\.</span> <span class="sr">&lt;[0..9]&gt;</span><span class="o">+</span> <span class="p">]?</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span> <span class="sr">&lt;[eE]&gt;</span> <span class="p">[</span><span class="o">\+</span> <span class="o">|</span> <span class="o">\-</span><span class="p">]?</span> <span class="sr">&lt;[0..9]&gt;</span><span class="o">+</span> <span class="p">]?</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">valeur</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">|</span> <span class="sr">&lt;objet&gt;</span> <span class="o">|</span> <span class="sr">&lt;tableau&gt;</span> <span class="o">|</span> <span class="sr">&lt;chaîne&gt;</span> <span class="o">|</span> <span class="sr">&lt;nombre&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="o">|</span> <span class="n">true</span>    <span class="o">|</span> <span class="n">false</span>     <span class="o">|</span> <span class="n">null</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>要测试，只需调用语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$reconnu</span> <span class="o">=</span> <span class="n">JSON</span><span class="o">-</span><span class="n">Grammaire</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nv">$chaîne_json</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="o">~</span><span class="nv">$reconnu</span> <span class="k">if</span> <span class="nv">$reconnu</span><span class="p">;</span>
</span></span></code></pre></div><p>这将显示包含整个原始JSON的已匹配对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="nv">$</span> <span class="nv">raku</span> <span class="n">json_grammaire</span><span class="o">.</span><span class="n">pl</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;prénom&#34;</span><span class="p">:</span> <span class="s">&#34;Martine&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;nom&#34;</span><span class="p">:</span> <span class="s">&#34;Unetelle&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;enVie&#34;</span><span class="p">:</span> <span class="n">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;âge&#34;</span><span class="p">:</span> <span class="mi">28</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">               <span class="c1"># [ ... affichage abrégé pour des raisons de place ] </span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="s">&#34;Profession&#34;</span><span class="p">:</span> <span class="s">&#34;sage-femme&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;Hobbies&#34;</span><span class="p">:</span> <span class="p">[</span><span class="s">&#34;GRS&#34;</span><span class="p">,</span> <span class="s">&#34;surf&#34;</span><span class="p">,</span> <span class="s">&#34;peinture&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>JSON文档已得到充分认可。这个JSON语法完全适用于作为示例选择的JSON文档，并且适用于少于20行。鼓励读者测试它。它还能够通过在JSON文档中引入错误来验证（例如，删除列表的两个值之间的逗号），不再进行匹配。</p>
<p>有人可能会反对这个语法只涵盖JSON的一个子集。实际情况并非如此。当然不建议在生产环境中使用此语法来解析任何JSON，因为它是作为教学示例完成的，但没有检查JSON标准的更精细细节，但是然而，上面的语法几乎完成了。</p>
<p>Raku 的<a href="https://github.com/moritz/json">JSON::Tiny</a>模块的语法可以解析任何有效的JSON文件，因为它可以容纳大约35行。</p>
<h3 id="3-6-5-添加动作httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">添加动作</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-6-5-添加动作httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>该JSON语法的工作，但如果打印是为JSON文档获得认可的对象树中使用例如大约300行文字，因为它提供的是已经认识到了一切的所有细节，而不是不是子模式的子模式。这对于理解语法的作用（例如在发生故障时）非常有用，但是探索这个树来提取数据可能会非常痛苦。</p>
<p>可以添加一类动作来构建抽象语法树（AST）。下面的类代码部分受到<a href="https://github.com/moritz/json">JSON::Tiny</a>模块的action类的启发 ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">class</span> <span class="n">JSON</span><span class="o">-</span><span class="n">actions</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">TOP</span><span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">make</span> <span class="vg">$/</span><span class="o">.</span><span class="nb">values</span><span class="o">.</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">objet</span><span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">make</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">listepaires</span><span class="o">&gt;.</span><span class="n">made</span><span class="o">.</span><span class="n">hash</span><span class="o">.</span><span class="n">item</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">listepaires</span><span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">make</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">paire</span><span class="o">&gt;&gt;&gt;.</span><span class="n">made</span><span class="o">.</span><span class="n">flat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">paire</span><span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">make</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">chaîne</span><span class="o">&gt;.</span><span class="n">made</span> <span class="o">=&gt;</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">valeur</span><span class="o">&gt;.</span><span class="n">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">tableau</span><span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">make</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">listeTableaux</span><span class="o">&gt;.</span><span class="n">made</span><span class="o">.</span><span class="n">item</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">listeTableaux</span><span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">make</span> <span class="p">[</span><span class="nv">$</span><span class="err">&lt;</span><span class="nv">valeur</span><span class="o">&gt;.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="n">made</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">chaîne</span><span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span> <span class="n">make</span> <span class="o">~</span><span class="nv">$0</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">nombre</span><span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span> <span class="n">make</span> <span class="o">+</span><span class="vg">$/</span><span class="o">.</span><span class="n">Str</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">valeur</span><span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">given</span> <span class="o">~</span><span class="vg">$/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">when</span> <span class="s">&#34;true&#34;</span>  <span class="p">{</span><span class="n">make</span> <span class="nn">Bool::</span><span class="n">True</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">            <span class="n">when</span> <span class="s">&#34;false&#34;</span> <span class="p">{</span><span class="n">make</span> <span class="nn">Bool::</span><span class="n">False</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">            <span class="n">when</span> <span class="s">&#34;null&#34;</span>  <span class="p">{</span><span class="n">make</span> <span class="n">Any</span><span class="p">;}</span> <span class="c1"># équivalent d&#39;undef en Perl5</span>
</span></span><span class="line"><span class="cl">            <span class="n">default</span>      <span class="p">{</span><span class="n">make</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">val</span><span class="o">&gt;.</span><span class="n">made</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>此操作类在value方法中使用名为 <code>$&lt;val&gt;</code> 的正则表达式，这使我们稍微修改语法的值规则：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">valeur</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">|</span> <span class="sr">&lt;val=objet&gt;</span> <span class="o">|</span> <span class="sr">&lt;val=tableau&gt;</span> <span class="o">|</span> <span class="sr">&lt;val=chaîne&gt;</span> <span class="o">|</span> <span class="sr">&lt;val=nombre&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="o">|</span> <span class="n">true</span>    <span class="o">|</span> <span class="n">false</span>     <span class="o">|</span> <span class="n">null</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>现在可以按如下方式调用语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$j</span><span class="o">-</span><span class="n">actions</span> <span class="o">=</span> <span class="n">JSON</span><span class="o">-</span><span class="n">actions</span><span class="o">.</span><span class="k">new</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$reconnu</span> <span class="o">=</span> <span class="n">JSON</span><span class="o">-</span><span class="n">Grammaire</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nv">$chaîne_json</span><span class="p">,</span> <span class="p">:</span><span class="n">actions</span><span class="p">(</span><span class="nv">$j</span><span class="o">-</span><span class="n">actions</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="nv">$reconnu</span><span class="o">.</span><span class="n">made</span> <span class="k">if</span> <span class="nv">$reconnu</span><span class="p">;</span>
</span></span></code></pre></div><p>对象$ reconnu.made现在有一个抽象语法树（AST），一个Perl数据结构6，它现在更容易发掘和利用。下面这棵树的显示略有重新格式化，其唯一目的是提高可读性：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Conjoint</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">Any</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Hobbies</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">GRS</span> <span class="n">surf</span> <span class="n">peinture</span><span class="p">],</span> 
</span></span><span class="line"><span class="cl">    <span class="n">NumérosTéléphone</span> <span class="o">=&gt;</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="n">num</span> <span class="o">=&gt;</span> <span class="mo">04</span> <span class="mo">05</span> <span class="mo">06</span> <span class="mo">07</span> <span class="mi">08</span><span class="p">,</span> <span class="n">type</span> <span class="o">=&gt;</span> <span class="n">domicile</span><span class="p">}</span> 
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="n">num</span> <span class="o">=&gt;</span> <span class="mo">04</span> <span class="mi">08</span> <span class="mo">07</span> <span class="mo">06</span> <span class="mo">05</span><span class="p">,</span> <span class="n">type</span> <span class="o">=&gt;</span> <span class="n">professionnel</span><span class="p">}</span> 
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="n">num</span> <span class="o">=&gt;</span> <span class="mo">06</span> <span class="mi">12</span> <span class="mi">34</span> <span class="mi">56</span> <span class="mi">78</span><span class="p">,</span> <span class="n">type</span> <span class="o">=&gt;</span> <span class="n">mobile</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">],</span> 
</span></span><span class="line"><span class="cl">    <span class="n">Profession</span> <span class="o">=&gt;</span> <span class="n">sage</span><span class="o">-</span><span class="n">femme</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">adresse</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">CodePostal</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">-</span><span class="mi">69000</span> 
</span></span><span class="line"><span class="cl">        <span class="n">Complément_Adr</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">Any</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">        <span class="n">NumRue</span> <span class="o">=&gt;</span> <span class="mi">21</span> <span class="n">rue</span> <span class="n">Pasteur</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="n">Ville</span> <span class="o">=&gt;</span> <span class="n">Lyon</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span> 
</span></span><span class="line"><span class="cl">    <span class="n">enVie</span> <span class="o">=&gt;</span> <span class="n">True</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">enfants</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
</span></span><span class="line"><span class="cl">    <span class="n">nom</span> <span class="o">=&gt;</span> <span class="n">Unetelle</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">prénom</span> <span class="o">=&gt;</span> <span class="n">Martine</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">sexe</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">âge</span> <span class="o">=&gt;</span> <span class="mi">28</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>现在可以轻松访问单个值，例如：</p>
<pre tabindex="0"><code>say $reconnu.made&lt;adresse&gt;&lt;CodePostal Ville&gt;;     # -&gt; (F-69000 Lyon)
</code></pre><h2 id="3-7-用于分析伪xml的-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-7 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">用于分析（伪）XML的 Grammar</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-7-用于分析伪xml的-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>一个<a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/approfondissements/#L2">语法章</a>节<a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/approfondissements">在Perl 5到Raku的：深化</a>介绍一步一步写语法解析文本尊重XML的一个子集。</p>
<p>该子集由以下测试套件定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@tests</span> <span class="o">=</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;abc&#39;</span>                       <span class="p">],</span>      <span class="c1"># 1</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;&lt;a&gt;&lt;/a&gt;&#39;</span>                   <span class="p">],</span>      <span class="c1"># 2</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;..&lt;ab&gt;foo&lt;/ab&gt;dd&#39;</span>          <span class="p">],</span>      <span class="c1"># 3</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;&lt;a&gt;&lt;b&gt;c&lt;/b&gt;&lt;/a&gt;&#39;</span>           <span class="p">],</span>      <span class="c1"># 4</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;&lt;a href=&#34;foo&#34;&gt;&lt;b&gt;c&lt;/b&gt;&lt;/a&gt;&#39;</span><span class="p">],</span>      <span class="c1"># 5</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;&lt;a empty=&#34;&#34; &gt;&lt;b&gt;c&lt;/b&gt;&lt;/a&gt;&#39;</span> <span class="p">],</span>      <span class="c1"># 6</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;&lt;a&gt;&lt;b&gt;c&lt;/b&gt;&lt;c&gt;&lt;/c&gt;&lt;/a&gt;&#39;</span>    <span class="p">],</span>      <span class="c1"># 7</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#39;&lt;&#39;</span>                         <span class="p">],</span>      <span class="c1"># 8</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#39;&lt;a&gt;b&lt;/b&gt;&#39;</span>                  <span class="p">],</span>      <span class="c1"># 9</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#39;&lt;a&gt;b&lt;/a&#39;</span>                   <span class="p">],</span>      <span class="c1"># 10</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#39;&lt;a&gt;b&lt;/a href=&#34;&#34;&gt;&#39;</span>          <span class="p">],</span>      <span class="c1"># 11</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;&lt;a/&gt;&#39;</span>                      <span class="p">],</span>      <span class="c1"># 12</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;&lt;a /&gt;&#39;</span>                     <span class="p">],</span>      <span class="c1"># 13</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span></code></pre></div><p>其中与第一个字段相关联的字符串等于1的字符串被认为是格式良好的XML字符串，而第一个字段为0的字符串被认为是格式不正确的。</p>
<p>强烈建议有兴趣的读者阅读本章，其中只引用最终语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">XML</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">TOP</span>   <span class="p">{</span> <span class="o">^</span> <span class="sr">&lt;xml&gt;</span> <span class="nv">$</span> <span class="err">};</span>
</span></span><span class="line"><span class="cl">    <span class="nv">token</span> <span class="n">xml</span>   <span class="p">{</span> <span class="sr">&lt;text&gt;</span> <span class="p">[</span> <span class="sr">&lt;tag&gt;</span> <span class="sr">&lt;text&gt;</span> <span class="p">]</span><span class="o">*</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">text</span> <span class="p">{</span>  <span class="sr">&lt;-[&lt;&gt;</span><span class="o">&amp;</span><span class="p">]</span><span class="o">&gt;*</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">tag</span>   <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#39;&lt;&#39;</span><span class="p">(</span><span class="o">\</span><span class="n">w</span><span class="o">+</span><span class="p">)</span> <span class="sr">&lt;attributes&gt;</span><span class="o">*</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span>
</span></span><span class="line"><span class="cl">            <span class="o">|</span> <span class="s">&#39;/&gt;&#39;</span>                 <span class="c1"># a single tag</span>
</span></span><span class="line"><span class="cl">            <span class="o">|</span> <span class="s">&#39;&gt;&#39;</span><span class="sr">&lt;xml&gt;</span><span class="s">&#39;&lt;/&#39;</span> <span class="nv">$0</span> <span class="s">&#39;&gt;&#39;</span>  <span class="c1"># an opening and a closing tag</span>
</span></span><span class="line"><span class="cl">        <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">attributes</span> <span class="p">{</span> <span class="o">\</span><span class="n">w</span><span class="o">+</span> <span class="s">&#39;=&#34;&#39;</span> <span class="sr">&lt;-[&#34;&lt;&gt;</span><span class="p">]</span><span class="o">&gt;*</span> <span class="s">&#39;&#34;&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="3-8-计算算术表达式计算器httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-8 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">计算算术表达式（计算器）</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-8-计算算术表达式计算器httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>这是一个使用计算器语法的程序的简单示例，该计算器语法可以评估基本的算术表达式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">v6</span><span class="o">.</span><span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">GrammaireArithmétique</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">TOP</span> <span class="p">{</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="sr">&lt;nombre&gt;</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="sr">&lt;operation&gt;</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="sr">&lt;nombre&gt;</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">operation</span> <span class="p">{</span> <span class="sr">&lt;[^*+/-]&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">nombre</span> <span class="p">{</span> <span class="o">\</span><span class="n">d</span><span class="o">+</span> <span class="o">|</span> <span class="o">\</span><span class="n">d</span><span class="o">+\.\</span><span class="n">d</span><span class="o">+</span> <span class="o">|</span> <span class="o">\.\</span><span class="n">d</span><span class="o">+</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">class</span> <span class="n">ActionsArithmétiques</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">TOP</span><span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">given</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">operation</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">when</span> <span class="s">&#39;*&#39;</span> <span class="p">{</span> <span class="vg">$/</span><span class="o">.</span><span class="n">make</span><span class="p">([</span><span class="o">*</span><span class="p">]</span> <span class="vg">$/</span><span class="sr">&lt;nombre&gt;</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">            <span class="n">when</span> <span class="s">&#39;+&#39;</span> <span class="p">{</span> <span class="vg">$/</span><span class="o">.</span><span class="n">make</span><span class="p">([</span><span class="o">+</span><span class="p">]</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">nombre</span><span class="o">&gt;</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">            <span class="n">when</span> <span class="s">&#39;/&#39;</span> <span class="p">{</span> <span class="vg">$/</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="nv">$</span><span class="err">&lt;</span><span class="nv">nombre</span><span class="o">&gt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">nombre</span><span class="o">&gt;</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">when</span> <span class="s">&#39;-&#39;</span> <span class="p">{</span> <span class="vg">$/</span><span class="o">.</span><span class="n">make</span><span class="p">([</span><span class="o">-</span><span class="p">]</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">nombre</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">when</span> <span class="s">&#39;^&#39;</span> <span class="p">{</span> <span class="vg">$/</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="nv">$</span><span class="err">&lt;</span><span class="nv">nombre</span><span class="o">&gt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">nombre</span><span class="o">&gt;</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="s">&#39;   6*7  &#39;</span><span class="p">,</span> <span class="s">&#39;46.2 -4.2&#39;</span><span class="p">,</span> <span class="s">&#39;28+ 14.0 &#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#39;70 * .6 &#39;</span><span class="p">,</span> <span class="s">&#39;126   /3&#39;</span><span class="p">,</span> <span class="s">&#39;6.4807407 ^ 2&#39;</span> <span class="o">-&gt;</span> <span class="nv">$op</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$reconnu</span> <span class="o">=</span> <span class="n">GrammaireArithmétique</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nv">$op</span><span class="p">,</span> <span class="p">:</span><span class="n">actions</span><span class="p">(</span><span class="n">ActionsArithmétiques</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">say</span> <span class="s">&#34;$reconnu\t= &#34;</span><span class="p">,</span> <span class="nv">$reconnu</span><span class="o">.</span><span class="n">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>语法GrammaireArithmétique是特别简单：我们试图匹配号码，然后按算术运算符（四个基本操作幂），其次是另一个号码。</p>
<p>算术动作库存类本身不产生AST，而只是评估在两个数字项之间执行的算术运算的结果。</p>
<p>在运行时，这将显示以下结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="nv">$</span> <span class="nv">raku</span> <span class="n">grammaire_arithm</span><span class="o">.</span><span class="n">pl6</span>
</span></span><span class="line"><span class="cl">   <span class="mi">6</span><span class="o">*</span><span class="mi">7</span>          <span class="o">=</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="mf">46.2</span> <span class="o">-</span><span class="mf">4.2</span>       <span class="o">=</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="mi">28</span><span class="o">+</span> <span class="mf">14.0</span>        <span class="o">=</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="mi">70</span> <span class="o">*</span> <span class="mf">.6</span>         <span class="o">=</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="mi">126</span>   <span class="o">/</span><span class="mi">3</span>        <span class="o">=</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="mf">6.4807407</span> <span class="o">^</span> <span class="mi">2</span>   <span class="o">=</span> <span class="mf">42.00000002063649</span>
</span></span></code></pre></div><p>我们发现它工作得很好，但我们希望能够处理包含多个操作的更复杂的算术表达式，同时考虑操作之间的通常优先级规则，以及通常用于修改这些优先级的括号。</p>
<p>特别是，我们想要正确处理以下算术表达式：</p>
<ul>
<li>3 + 4 + 5;</li>
<li>3 + 4 * 5; ＃预期的结果是23</li>
<li>（3 + 4）* 5; ＃预期的结果是35</li>
</ul>
<p>要实现这种结果，我们必须以不同的方式对待具有不同优先级的运营商。在下面的语法中，表达式（expr）由几个由+或-运算符分隔的术语组成。甲术语由一个原子或多个原子 S按运算符分隔*或/。并且原子是括号中的简单数字或算术表达式。</p>
<p>这确保符合优先的规则：乘法和除法的分析过程中的加法和减法，因为之前评估，EXPR，考虑长期的个性化，才能完成评估一个表达。类似地，由于带括号的表达式是原子，因此有必要在完成对该术语中包含括号表达式的术语的评估之前评估原子的值。</p>
<p>语法比以前复杂一点，但至少在外观上仍然相对简单：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">grammar</span> <span class="n">Calculette</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">TOP</span>            <span class="p">{</span> <span class="sr">&lt;expr&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">expr</span>           <span class="p">{</span> <span class="sr">&lt;terme&gt;</span> <span class="o">+</span> <span class="nv">%</span> <span class="err">&lt;</span><span class="nv">plus</span><span class="o">-</span><span class="n">moins</span><span class="o">-</span><span class="n">op</span><span class="o">&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">plus</span><span class="o">-</span><span class="n">moins</span><span class="o">-</span><span class="n">op</span> <span class="p">{</span> <span class="p">[</span><span class="o">&lt;</span> <span class="o">+</span> <span class="o">-</span> <span class="o">&gt;</span><span class="p">]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">terme</span>           <span class="p">{</span> <span class="sr">&lt;atome&gt;</span> <span class="o">+</span> <span class="nv">%</span> <span class="err">&lt;</span><span class="nv">mult</span><span class="o">-</span><span class="n">div</span><span class="o">-</span><span class="n">op</span><span class="o">&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">mult</span><span class="o">-</span><span class="n">div</span><span class="o">-</span><span class="n">op</span>   <span class="p">{</span> <span class="p">[</span><span class="o">&lt;</span> <span class="o">*</span> <span class="o">/</span> <span class="o">&gt;</span><span class="p">]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">atome</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">|</span> <span class="sr">&lt;nombre&gt;</span> <span class="p">{</span> <span class="n">make</span> <span class="o">+</span><span class="nv">$</span><span class="err">&lt;</span><span class="nv">nombre</span><span class="o">&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">|</span> <span class="sr">&lt;expr-parenth&gt;</span> <span class="p">{</span> <span class="n">make</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">expr</span><span class="o">-</span><span class="n">parenth</span><span class="o">&gt;.</span><span class="n">made</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">nombre</span>            <span class="p">{</span> <span class="sr">&lt;signe&gt;</span> <span class="p">?</span> <span class="p">[</span><span class="o">\</span><span class="n">d</span><span class="o">+</span> <span class="o">|</span> <span class="o">\</span><span class="n">d</span><span class="o">+\.\</span><span class="n">d</span><span class="o">+</span> <span class="o">|</span> <span class="o">\.\</span><span class="n">d</span><span class="o">+</span> <span class="p">]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">expr</span><span class="o">-</span><span class="n">parenth</span>     <span class="p">{</span> <span class="s">&#39;(&#39;</span> <span class="sr">&lt;expr&gt;</span> <span class="s">&#39;)&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">signe</span>          <span class="p">{</span> <span class="p">[</span><span class="o">&lt;</span> <span class="o">+</span> <span class="o">-</span> <span class="o">&gt;</span><span class="p">]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意，在括号中的表达式的情况下，可以递归地调用expr规则。这种递归调用的可能性是语法能力的重要组成部分，但必须采取一些预防措施来避免进入无限递归的风险; 这些预防措施将在<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L4-5">4.5</a>节中详细讨论  <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L4-5">。</a>（<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L4-5">避免左递归的陷阱</a>）。</p>
<p>我们还可以注意到，我们在语法中集成了两个动作（在原子规则中））。我们特别出于实际原因做出了这样的选择：由于原子规则包含非常不同的命名子规则，因此更容易将操作直接集成到子规则的上下文中。如果这些股票被放置在一类股票中，则有必要确定哪些子规则已得到承认。这并不难，但它会使代码更复杂一些。第二个原因是教学法：尽管创建一个单独的一类行动通常会更好（我们将在本例中很快完成此操作），但有必要知道可以偶尔直接集成行动。用语法。对于一个非常简单的语法，它可能是过度工程 而不是仅为一个或两个动作创建一个动作类。</p>
<p>以下是与此语法相关的操作类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">class</span> <span class="n">CalcActions</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">TOP</span> <span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">make</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">expr</span><span class="o">&gt;.</span><span class="n">made</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">expr</span> <span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$</span><span class="err">.</span><span class="nv">calculer</span><span class="p">(</span><span class="vg">$/</span><span class="p">,</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">terme</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">plus</span><span class="o">-</span><span class="n">moins</span><span class="o">-</span><span class="n">op</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">terme</span> <span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$</span><span class="err">.</span><span class="nv">calculer</span><span class="p">(</span><span class="vg">$/</span><span class="p">,</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">atome</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">mult</span><span class="o">-</span><span class="n">div</span><span class="o">-</span><span class="n">op</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">expr</span><span class="o">-</span><span class="n">parenth</span> <span class="p">(</span><span class="vg">$/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="n">make</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">expr</span><span class="o">&gt;.</span><span class="n">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">calculer</span> <span class="p">(</span><span class="vg">$/</span><span class="p">,</span> <span class="nv">$operandes</span><span class="p">,</span> <span class="nv">$operateurs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$result</span> <span class="o">=</span> <span class="p">(</span><span class="nb">shift</span> <span class="nv">$operandes</span><span class="p">)</span><span class="o">.</span><span class="n">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="k">my</span> <span class="nv">$op</span> <span class="o">=</span> <span class="nb">shift</span> <span class="nv">$operateurs</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">my</span> <span class="nv">$nombre</span> <span class="o">=</span> <span class="p">(</span><span class="nb">shift</span> <span class="nv">$operandes</span><span class="p">)</span><span class="o">.</span><span class="n">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">given</span> <span class="nv">$op</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">when</span> <span class="s">&#39;+&#39;</span> <span class="p">{</span> <span class="nv">$result</span> <span class="o">+=</span> <span class="nv">$nombre</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">when</span> <span class="s">&#39;-&#39;</span> <span class="p">{</span> <span class="nv">$result</span> <span class="o">-=</span> <span class="nv">$nombre</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">when</span> <span class="s">&#39;*&#39;</span> <span class="p">{</span> <span class="nv">$result</span> <span class="o">*=</span> <span class="nv">$nombre</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">when</span> <span class="s">&#39;/&#39;</span> <span class="p">{</span> <span class="nv">$result</span> <span class="o">/=</span> <span class="nv">$nombre</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">default</span>  <span class="p">{</span> <span class="nb">die</span> <span class="s">&#34;operateur inconnu &#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">make</span> <span class="nv">$result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>计算方法从左到右确定表达式（由加法或减法运算符分隔的项）和项（由乘法或除法运算符分隔的原子）的值，因为这些运算符在左侧都是关联的。</p>
<p>可以使用以下代码片段测试此语法和与其关联的操作类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">for</span> <span class="o">|&lt;</span> <span class="mi">3</span><span class="o">*</span><span class="mi">4</span> <span class="mi">5</span><span class="sr">/6 3+5 74-32 5+7/</span><span class="mi">3</span> <span class="mi">5</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="mi">2</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span> <span class="mi">4</span><span class="o">+</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="sr">/5 4+(3-1)/</span><span class="mi">4</span> <span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;12 + 6 * 5&#34;</span><span class="p">,</span> <span class="s">&#34; 7 + 12 + 23&#34;</span><span class="p">,</span> <span class="s">&#34; 2 + (10 * 4) &#34;</span><span class="p">,</span> <span class="s">&#34;3 * (7 + 7)&#34;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$résultat</span> <span class="o">=</span> <span class="n">Calculette</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nv">$_</span><span class="p">,</span> <span class="p">:</span><span class="n">actions</span><span class="p">(</span><span class="n">CalcActions</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># say $résultat;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">printf</span> <span class="s">&#34;%-15s %.3f\n&#34;</span><span class="p">,</span> <span class="vg">$/</span><span class="p">,</span>  <span class="nv">$résultat</span><span class="o">.</span><span class="n">made</span> <span class="k">if</span> <span class="nv">$résultat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其中显示以下结果：</p>
<pre tabindex="0"><code>$ raku grammaire_arithm_2.pl6
3*4             12.000
5/6             0.833
3+5             8.000
74-32           42.000
5+7/3           7.333
5*3*2           30.000
(4*5)           20.000
(3*2)+5         11.000
4+3-1/5         6.800
4+(3-1)/4       4.500
12 + 6 * 5      42.000
 7 + 12 + 23    42.000
 2 + (10 * 4)   42.000
3 * (7 + 7)     42.000
</code></pre><p>有人可能想知道这个程序是否适用于嵌套括号。当我编写这段代码时，我问自己这个问题，我认为在这种情况下它可能无法正常工作，并且我可能需要添加一些东西以正确分析表达式嵌套括号。事实证明它不是，它适用于嵌套括号：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">for</span> <span class="s">&#34;(((2+3)*(5-2))-1)*3&#34;</span><span class="p">,</span> <span class="s">&#34;2 * ((4-1)*((3*7) - (5+2)))&#34;</span>  <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$résultat</span> <span class="o">=</span> <span class="n">Calculette</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nv">$_</span><span class="p">,</span> <span class="p">:</span><span class="n">actions</span><span class="p">(</span><span class="n">CalcActions</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nb">printf</span> <span class="s">&#34;%-30s %.3f\n&#34;</span><span class="p">,</span> <span class="vg">$/</span><span class="p">,</span>  <span class="nv">$résultat</span><span class="o">.</span><span class="n">made</span> <span class="k">if</span> <span class="nv">$résultat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个显示正确的结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="p">(((</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span>            <span class="mf">42.000</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="mi">4</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="mi">7</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">5</span><span class="o">+</span><span class="mi">2</span><span class="p">)))</span>    <span class="mf">84.000</span>
</span></span></code></pre></div><h2 id="3-9-grammar先进的理念和观点httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">Grammar：先进的理念和观点</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-9-grammar先进的理念和观点httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<h3 id="3-9-1-角色构成httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">角色构成</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-9-1-角色构成httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>在面向对象的编程中，角色对可以由不同类共享的行为（通常是方法）进行分组。角色在技术上与类非常相似，但最大的区别在于不期望直接从角色实例化对象。在OOP中，可以将角色添加到整个类，或仅添加到类的各个对象。将角色功能添加到类中称为角色组合。</p>
<p>使用关键字do将角色添加到类（或对象） ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">role</span> <span class="n">Personne</span><span class="o">-</span><span class="n">details</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">has</span> <span class="n">Adresse</span> <span class="nv">$</span><span class="err">.</span><span class="nv">adresse</span> <span class="n">is</span> <span class="n">rw</span><span class="p">;</span> <span class="c1"># Adresse : type défini préalablement</span>
</span></span><span class="line"><span class="cl">    <span class="n">has</span> <span class="n">NumString</span> <span class="nv">$</span><span class="err">.</span><span class="nv">telephone</span><span class="o">-</span><span class="n">fixe</span> <span class="n">is</span> <span class="n">rw</span><span class="p">;</span>        <span class="c1"># idem pour NumString</span>
</span></span><span class="line"><span class="cl">    <span class="n">method</span> <span class="n">déménage</span> <span class="p">(</span><span class="n">Adresse</span> <span class="nv">$nouvelle</span><span class="o">-</span><span class="n">adresse</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$</span><span class="err">.</span><span class="nv">adresse</span> <span class="o">=</span> <span class="nv">$nouvelle</span><span class="o">-</span><span class="n">adresse</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># … autres méthodes</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">class</span> <span class="n">Personne</span><span class="o">-</span><span class="n">privée</span> <span class="n">does</span> <span class="n">Personne</span><span class="o">-</span><span class="n">details</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">has</span> <span class="n">Str</span> <span class="nv">$</span><span class="err">.</span><span class="nv">nom</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">has</span> <span class="n">Str</span> <span class="nv">$</span><span class="err">.</span><span class="nv">prénom</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># autres attributs et méthodes</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>角色是在OOP中重用代码的一种非常强大的方法。有关OOB角色组成的更多信息，请参阅<img src="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/images/100000000000000C0000000C8ED6566A.jpg" alt="图片不可用"><a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/objets/">Perl对象，类和角色教程6 - 面向对象编程教程</a>。</p>
<p>读者已经理解Raku的语法最终只是一种特定的类形式，并不会惊讶于我们也可以在语法中添加角色。这些角色最终可能包含OOP中使用的属性和方法，但它们通常包含命名规则。</p>
<p>通常，角色将是从较小的独立组件汇编语法的好方法。例如，匹配引号（或撇号）中的数字和字符串是一种非常常见的需求，对于分析JSON，YAML，HTML，配置文件或数学表达式非常有用。因此，我们可以想象将角色形式的通用组件添加到更具体的语法（或添加到语法中的其他角色）。</p>
<p>在下面的示例中，我们定义了第一个角色Integer，它提供了用于匹配有符号或无符号整数的规则; 然后我们使用Integer角色的一些规则定义第二个角色Floating：感谢子句Do Integer并提供匹配浮点数的规则：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">role</span> <span class="n">Entier</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">non</span><span class="o">-</span><span class="n">signé</span> <span class="p">{</span> <span class="sr">&lt;[0..9]&gt;</span><span class="o">+</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">signe</span> <span class="p">{</span> <span class="p">[</span> <span class="s">&#39;+&#39;</span> <span class="o">|</span> <span class="s">&#39;-&#39;</span> <span class="p">]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">entier</span><span class="o">-</span><span class="n">signé</span> <span class="p">{</span> <span class="sr">&lt;signe&gt;</span><span class="p">?</span> <span class="sr">&lt;non-signé&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">role</span> <span class="n">Flottant</span> <span class="n">does</span> <span class="n">Entier</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">exposant</span> <span class="p">{</span> <span class="p">:</span><span class="n">i</span> <span class="n">e</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="sr">&lt;entier-signé&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">point</span><span class="o">-</span><span class="n">décimal</span> <span class="p">{</span> <span class="s">&#39;.&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">nombre</span><span class="o">-</span><span class="n">fractionnaire</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="o">||</span> <span class="sr">&lt;entier-signé&gt;</span> <span class="sr">&lt;point-décimal&gt;</span> <span class="sr">&lt;entier-signé&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="o">||</span> <span class="sr">&lt;point-décimal&gt;</span> <span class="sr">&lt;entier-signé&gt;</span> 
</span></span><span class="line"><span class="cl">        <span class="o">||</span> <span class="sr">&lt;entier-signé&gt;</span> <span class="sr">&lt;point-décimal&gt;</span><span class="p">?</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">flottant</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="sr">&lt;nombre-fractionnaire&gt;</span> <span class="sr">&lt;exposant&gt;</span><span class="p">?</span>   
</span></span><span class="line"><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这为我们提供了以下语法分析简单算术表达式中的重用组件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">MultDiv</span> <span class="n">does</span> <span class="n">Flottant</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">TOP</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">||</span> <span class="sr">&lt;dividende=nombre&gt;</span> <span class="s">&#39;/&#39;</span> <span class="sr">&lt;diviseur=nombre&gt;</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">                <span class="n">make</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">dividende</span><span class="o">&gt;</span> <span class="o">/</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">diviseur</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">           <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">||</span> <span class="p">[</span> <span class="sr">&lt;nombre&gt;</span> <span class="p">]</span><span class="o">+</span> <span class="nv">%</span> <span class="err">\*</span> <span class="p">{</span> <span class="n">make</span> <span class="p">[</span><span class="o">*</span><span class="p">]</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">nombre</span><span class="o">&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">nombre</span> <span class="p">{</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="p">[</span><span class="sr">&lt;entier-signé&gt;</span> <span class="o">|</span> <span class="sr">&lt;flottant&gt;</span> <span class="p">]</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="s">&#39;7 * 6&#39;</span><span class="p">,</span> <span class="s">&#39;3*2*7&#39;</span><span class="p">,</span> <span class="s">&#39;126/3&#39;</span><span class="p">,</span> <span class="s">&#39;147.0 / 3.5&#39;</span> <span class="o">-&gt;</span> <span class="nv">$expr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$match</span> <span class="o">=</span> <span class="n">MultDiv</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nv">$expr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nb">printf</span> <span class="s">&#34;%-20s %s %d \n&#34;</span><span class="p">,</span> <span class="nv">$match</span><span class="p">,</span> <span class="s">&#34;La réponse est: &#34;</span><span class="p">,</span> <span class="nv">$match</span><span class="o">.</span><span class="n">made</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Floating Does子句将Floating角色中定义的规则和Integer角色都导入到MultDiv语法中。</p>
<p>显示的结果符合预期：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="nv">$</span> <span class="nv">raku</span> <span class="n">grammaire_roles</span><span class="o">.</span><span class="n">pl6</span>
</span></span><span class="line"><span class="cl"><span class="mi">7</span> <span class="o">*</span> <span class="mi">6</span>                <span class="n">La</span> <span class="n">réponse</span> <span class="n">est:</span>  <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">7</span>                <span class="n">La</span> <span class="n">réponse</span> <span class="n">est:</span>  <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="mi">126</span><span class="o">/</span><span class="mi">3</span>                <span class="n">La</span> <span class="n">réponse</span> <span class="n">est:</span>  <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="mf">147.0</span> <span class="o">/</span> <span class="mf">3.5</span>          <span class="n">La</span> <span class="n">réponse</span> <span class="n">est:</span>  <span class="mi">42</span>
</span></span></code></pre></div><p>请注意，我们再次将操作直接插入到语法中，并在此处使用为命名规则的捕获提供特定名称的可能性（参见<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-8">§2.8  </a>）以区分规则提供的捕获在分割的情况下的数字。</p>
<p>现在我们已经构建了这些软件块，它们是由Integer和Floating角色提供的整数签名和浮动规则，我们也可以重用它们来匹配我们语法中用于解析<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-6-4">3.6</a> JSON的相同类型的实体。  <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-6-4">0.4</a> ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">JSON</span><span class="o">-</span><span class="n">Grammaire</span> <span class="n">does</span> <span class="n">Flottant</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">TOP</span>          <span class="p">{</span> <span class="o">^</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="p">[</span> <span class="sr">&lt;objet&gt;</span> <span class="o">|</span> <span class="sr">&lt;tableau&gt;</span> <span class="p">]</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="nv">$</span> <span class="err">}</span>
</span></span><span class="line"><span class="cl">    <span class="err">#</span> <span class="err">…</span> <span class="nv">Règles</span> <span class="n">définissant</span> <span class="n">les</span> <span class="n">objets</span><span class="p">,</span> <span class="n">paires</span><span class="p">,</span> <span class="n">tableaux</span><span class="p">,</span> <span class="n">chaînes</span><span class="p">,</span> <span class="n">etc</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">nombre</span> <span class="p">{</span> <span class="sr">&lt;entier-signé&gt;</span> <span class="o">|</span> <span class="sr">&lt;flottant&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">valeur</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">|</span> <span class="sr">&lt;objet&gt;</span> <span class="o">|</span> <span class="sr">&lt;tableau&gt;</span> <span class="o">|</span> <span class="sr">&lt;chaîne&gt;</span> <span class="o">|</span> <span class="sr">&lt;nombre&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="o">|</span> <span class="n">true</span>    <span class="o">|</span> <span class="n">false</span>     <span class="o">|</span> <span class="n">null</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们发现构建可重用的角色软件库以简化语法编写变得非常容易。</p>
<p>与继承相关，角色组合具有从编译而不是执行中检测命名冲突的优点。这迫使你解决这些冲突，并使角色组合比继承更可靠和安全，无论是面向对象的编程还是语法创建。</p>
<h3 id="3-9-2-设定规则httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">设定规则</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-9-2-设定规则httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>可以使用参数定义规则（名为类型正则表达式，标记或规则的正则表达式），从而使用参数调用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">token</span> <span class="n">date</span><span class="p">(</span><span class="nv">$mois</span><span class="p">)</span> <span class="p">{</span> <span class="o">\</span><span class="n">d</span><span class="o">\</span><span class="n">d</span><span class="p">?</span> <span class="o">\</span><span class="n">s</span><span class="o">+</span> <span class="nv">$mois</span> <span class="o">\</span><span class="n">s</span><span class="o">+</span> <span class="o">\</span><span class="n">d</span><span class="o">**</span><span class="mi">4</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;En juin&#34;</span> <span class="k">if</span> <span class="s">&#34;13 juin 2015&#34;</span> <span class="o">~~</span> <span class="sr">/&lt;date(&#34;juin&#34;)&gt;/</span><span class="p">;</span>   <span class="c1"># -&gt; En juin</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;En mai&#34;</span>  <span class="k">if</span> <span class="s">&#34;13 juin 2015&#34;</span> <span class="o">~~</span> <span class="sr">/&lt;date(&#34;mai&#34;)&gt;/</span><span class="p">;</span>    <span class="c1"># (échec)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$date</span> <span class="o">=</span> <span class="s">&#34;13 $_ 2015&#34;</span> <span class="ow">and</span> <span class="n">say</span> <span class="nv">$date</span> <span class="o">~~</span> <span class="sr">/&lt;date(&#34;mai&#34;)&gt;/</span> 
</span></span><span class="line"><span class="cl">    <span class="p">??</span> <span class="s">&#34;Date $date en $_&#34;</span> 
</span></span><span class="line"><span class="cl">    <span class="o">!!</span> <span class="s">&#34;Date $date pas en $_&#34;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">&lt;</span><span class="n">mars</span> <span class="n">avril</span> <span class="n">mai</span> <span class="n">juin</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># affiche :</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Date 13 mars 2015 pas en mars</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Date 13 avril 2015 pas en avril</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Date 13 mai 2015 en mai</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Date 13 juin 2015 pas en juin</span>
</span></span></code></pre></div><p>这是一个稍微复杂的带有参数规则的更复杂结构的示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">token</span> <span class="n">mots</span> <span class="p">{</span> <span class="o">&lt;</span><span class="p">[</span> <span class="o">\</span><span class="n">w</span> <span class="o">\</span><span class="n">s</span> <span class="o">\-</span><span class="p">]</span><span class="o">&gt;+</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">token</span> <span class="n">entre</span><span class="o">-</span><span class="n">crochets</span>    <span class="p">{</span> <span class="sr">&lt;start(&#34;[&#34;)&gt;</span> <span class="sr">&lt;ident&gt;</span> <span class="sr">&lt;end(&#34;]&#34;)&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">token</span> <span class="n">entre</span><span class="o">-</span><span class="n">paren</span>       <span class="p">{</span> <span class="sr">&lt;start(&#34;(&#34;)&gt;</span> <span class="sr">&lt;mots&gt;</span>  <span class="sr">&lt;end(&#34;)&#34;)&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">token</span> <span class="n">entre</span><span class="o">-</span><span class="n">chevrons</span>    <span class="p">{</span> <span class="sr">&lt;start(&#34;&lt;&#34;)&gt;</span> <span class="sr">&lt;ident&gt;</span> <span class="sr">&lt;end(&#34;&gt;</span><span class="s">&#34;)&gt; }
</span></span></span><span class="line"><span class="cl"><span class="s">my token start($début) { $début }
</span></span></span><span class="line"><span class="cl"><span class="s">my token end($fin) { $fin }
</span></span></span><span class="line"><span class="cl"><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">say ~$&lt;entre-crochets&gt; if &#34;</span><span class="p">[</span><span class="n">Capitaine_Crochet</span><span class="p">]</span><span class="s">&#34; ~~ /&lt;entre-crochets&gt;/;
</span></span></span><span class="line"><span class="cl"><span class="s"># Affiche : [Capitaine_Crochet]
</span></span></span><span class="line"><span class="cl"><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">say $&lt;entre-paren&gt; if &#34;</span><span class="p">[</span><span class="n">par</span><span class="o">-</span><span class="n">parenthèse</span><span class="p">]</span><span class="s">&#34; ~~ /&lt;entre-paren&gt;/;  # -&gt; () 
</span></span></span><span class="line"><span class="cl"><span class="s"># (échec puisqu&#39;il y a des crochets et non des parenthèses
</span></span></span><span class="line"><span class="cl"><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">say $&lt;entre-paren&gt; if &#34;</span><span class="p">(</span><span class="n">par</span><span class="o">-</span><span class="n">parenthèse</span><span class="p">)</span><span class="err">&#34;</span> <span class="o">~~</span> <span class="sr">/&lt;entre-paren&gt;/</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="c1"># Affiche :  </span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ｢(par-parenthèse)｣</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#  start =&gt; ｢(｣</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#  mots =&gt; ｢par-parenthèse｣</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#  end =&gt; ｢)｣</span>
</span></span></code></pre></div><h3 id="3-9-3-递归规则和动态变量httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">递归规则和动态变量</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-9-3-递归规则和动态变量httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>语法规则本质上通常是递归的。例如，要匹配嵌套括号，你可能希望编写此样式的递归语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">G</span> <span class="p">{</span> <span class="n">rule</span> <span class="n">TOP</span> <span class="p">{</span> <span class="s">&#39;(&#39;</span> <span class="o">~</span> <span class="s">&#39;)&#39;</span> <span class="p">[</span> <span class="p">[</span> <span class="nv">$</span><span class="err">&lt;</span><span class="nv">int</span><span class="o">&gt;=\</span><span class="n">d</span><span class="o">+</span> <span class="p">]</span><span class="o">+|</span> <span class="sr">&lt;TOP&gt;</span> <span class="p">]</span> <span class="o">+</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">G</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#34;(22 (43 45))&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Affiche :</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># ｢(22 (43 45))｣</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#  int =&gt; ｢22｣</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#  TOP =&gt; ｢(43 45)｣</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#   int =&gt; ｢43｣</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#   int =&gt; ｢45｣</span>
</span></span></code></pre></div><p>这里，递归调用TOP规则来解析嵌套括号。它可以很容易地分析具有较高嵌套级别的字符串，例如“（22（43（46 45（41）））”。</p>
<p>将上下文传递给递归调用的规则时，这会变得更加棘手。</p>
<p>人们可以使用原则参数规则（见第  <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-9-2">3.9.2</a>上图）可以更改上下文，但它可能很快就会变得非常冗长。也正是在原则上可以使用全局变量，但是全局变量通常被认为是不好的做法（可能除了一些特殊情况，如环境变量，这是全球性的），因为全局变量经常违反结构化编程的原则，不清楚，不健壮和危险，并且它通常不适用于线程。</p>
<p>无论是语法还是简单的函数调用或普通的方法，因为它使用递归调用机制，语法可以是艰巨的，当你需要管理多个变量传递回调用函数或函数的返回值。</p>
<p>动态变量（使用twigil *）解决了这个问题。他们是词法声明，但他们不仅在窝寻求词汇包容性，而且在窝动态的包容性。</p>
<p>例如，考虑一个计算数字阶乘的简单递归函数，可以写成如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">fact</span><span class="p">($n){</span><span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="nv">$n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$n</span><span class="o">*</span><span class="n">fact</span><span class="p">(</span><span class="nv">$n</span><span class="o">-</span><span class="mi">1</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">callfact</span><span class="p">(Int $n){</span>
</span></span><span class="line"><span class="cl">    <span class="nb">die</span> <span class="s">&#34;Factorielle non définie pour nombre négatif&#34;</span> <span class="k">if</span> <span class="nv">$n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#34;Factorielle = &#34;</span><span class="p">,</span> <span class="n">fact</span><span class="p">(</span><span class="nv">$n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">callfact</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>       <span class="c1"># -&gt; 120</span>
</span></span></code></pre></div><p>假设我们还想计算低于所考虑数的整数之和。参数和多个返回值的通过可能变得相当快速且不可读。以下是将部分和存储在动态变量中的可能语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">fact</span><span class="p">($n){</span><span class="nv">$</span><span class="err">*</span><span class="nv">sum</span> <span class="o">+=</span> <span class="nv">$n</span><span class="p">;</span> <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="nv">$n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$n</span><span class="o">*</span><span class="n">fact</span><span class="p">(</span><span class="nv">$n</span><span class="o">-</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">callfact</span><span class="p">(Int $n){</span>
</span></span><span class="line"><span class="cl">    <span class="nb">die</span> <span class="s">&#34;Factorielle non définie pour nombre négatif&#34;</span> <span class="k">if</span> <span class="nv">$n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$</span><span class="err">*</span><span class="nv">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#34;Fact = &#34;</span><span class="p">,</span> <span class="n">fact</span><span class="p">(</span><span class="nv">$n</span><span class="p">);</span> <span class="n">say</span> <span class="s">&#34;Somme = &#34;</span><span class="p">,</span> <span class="nv">$</span><span class="err">*</span><span class="nv">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">callfact</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>       <span class="c1"># -&gt; Fact = 120 \n Somme = 15</span>
</span></span></code></pre></div><p>动态变量 <code>$*sum</code> 在调用函数callfact中声明并初始化为0 。它在词法上是callfact函数的本地，但它在函数事实中是可见的和可修改的，因为事实是由callfact调用的，因此它驻留在callfact的动态范围内。这个变量成为这两个函数的全局变量（可能是它们可能调用的函数），这消除了传递参数或在它们之间返回值的需要，但它仍然是一个变量。词汇变量“私有”，因为它在程序的其余部分是不可见的。</p>
<p>动态变量不一定是标量，可以类似地定义数组（例如，<code>@*</code>数组）或动态散列。</p>
<p>当语法变得有点复杂时，动态变量通常可以简化实现。</p>
<p>语法<a href="https://github.com/raku/std/blob/master/STD.pm6">STD.pm</a> Raku的大量使用动态变量，尤其是定义将被传递给函数词法或句法分析上下文，调用的方法或规则，而不需要建立天然气厂的真实通道参数和返回值。例如，有一种动态散列％* LANG定义了不同的“子语言”的Raku（基本Raku中，正则表达式，Perl的正则表达式5等）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl">            <span class="nv">%</span><span class="err">*</span><span class="nv">LANG</span><span class="sr">&lt;MAIN&gt;</span>    <span class="o">=</span> <span class="o">::</span><span class="nn">STD::</span><span class="n">P6</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%</span><span class="err">*</span><span class="nv">LANG</span><span class="sr">&lt;Q&gt;</span>       <span class="o">=</span> <span class="o">::</span><span class="nn">STD::</span><span class="n">Q</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%</span><span class="err">*</span><span class="nv">LANG</span><span class="sr">&lt;Quasi&gt;</span>   <span class="o">=</span> <span class="o">::</span><span class="nn">STD::</span><span class="n">Quasi</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%</span><span class="err">*</span><span class="nv">LANG</span><span class="sr">&lt;Regex&gt;</span>   <span class="o">=</span> <span class="o">::</span><span class="nn">STD::</span><span class="n">Regex</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%</span><span class="err">*</span><span class="nv">LANG</span><span class="sr">&lt;P5&gt;</span>      <span class="o">=</span> <span class="o">::</span><span class="n">STD5</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%</span><span class="err">*</span><span class="nv">LANG</span><span class="sr">&lt;P5Regex&gt;</span> <span class="o">=</span> <span class="o">::</span><span class="nn">STD5::</span><span class="n">Regex</span> <span class="p">;</span>
</span></span></code></pre></div><h3 id="3-9-4-所谓原类型的规则httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">所谓原类型的规则</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-9-4-所谓原类型的规则httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>同样有可能，由于关键字多，写几个函数或方法的倍数相同的名字，但是编译器可以用不同的签名区分，我们可以写，用的是-clef 原，名称相同的规则，但适用于不同的实体。</p>
<p>例如，当前的Raku语法使用以下构造来定义sigils：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">proto</span> <span class="n">token</span> <span class="n">sigil</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ...</span>
</span></span><span class="line"><span class="cl"><span class="n">token</span> <span class="n">sigil:sym</span><span class="sr">&lt;$&gt;</span>  <span class="p">{</span> <span class="sr">&lt;sym&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">token</span> <span class="n">sigil:sym</span><span class="sr">&lt;@&gt;</span>  <span class="p">{</span> <span class="sr">&lt;sym&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">token</span> <span class="n">sigil:sym</span><span class="sr">&lt;%&gt;</span>  <span class="p">{</span> <span class="sr">&lt;sym&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">token</span> <span class="n">sigil:sym</span><span class="sr">&lt;&amp;&gt;</span>  <span class="p">{</span> <span class="sr">&lt;sym&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ... une petite dizaine d&#39;autres définitions de sigils</span>
</span></span></code></pre></div><p>这将创建一个名为sigil（proto）的组和（在此示例中）属于该组的四个规则（它们属于该组，因为它们具有相同的名称）作为参数接收sym标识符。这些规则中的第一个将sym分配给$，然后在规则的主体中匹配此符号（带有符号 <code>&lt;sym&gt;</code>）。第二条规则与@相同，依此类推。</p>
<p>如果语法调用规则<code>&lt;sigil&gt;</code>，我们会得到这五个规则的列表，它们之间有一个或逻辑。这与你编写规则的方法大致相同，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">token</span> <span class="n">sigil</span> <span class="p">{</span> <span class="s">&#39;$&#39;</span> <span class="o">|</span> <span class="s">&#39;@&#39;</span> <span class="o">|</span> <span class="s">&#39;%&#39;</span> <span class="o">|</span> <span class="s">&#39;&amp;&#39;</span> <span class="p">}</span>
</span></span></code></pre></div><p>但是，使用这些原型或protoregex，可以更容易地扩展语法，如下所示（第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-9-6">3.9.6</a>节  ）。</p>
<p><a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-6-3-5">为了§3.6.3.5</a><a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-6-3-5">的</a>记忆，已经给出了可能使用原型规则的另一个例子  。</p>
<h3 id="3-9-5-继承和可变语法httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">继承和可变语法</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-9-5-继承和可变语法httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>继承了语法的可能性提供了一种没有料到的表达能力和巨大的前景：它是可能的，例如作为模块的一部分，写语法的“子语法”语法或女儿重载操作符，添加功能甚至修改语法元素，并使用此本地修改语法运行具有相同Raku编译器的Perl程序。</p>
<p>正是由于这种基本机制，Raku的语法是动态的，例如，很容易定义自己的运算符（请参阅<a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/les-nouveautes/#L6">创建自己</a>的教程<a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/les-nouveautes/#L6">操作符</a><a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/les-nouveautes">从Perl到Raku - Part 2：新奇事物</a>）。然而，没有必要控制继承和语法的可变性，以建立自己的运营商，因为语言提供了最高级别的一个简单的机制来做到这一点，如在运营商的定义因子 “  ！ “</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">multi</span> <span class="k">sub</span> <span class="nf">postfix</span><span class="p">:&lt;!&gt;(Int $x) {</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$factorielle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$factorielle</span> <span class="o">*=</span> <span class="nv">$_</span> <span class="k">for</span> <span class="mi">2</span><span class="o">..</span><span class="nv">$x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nv">$factorielle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="mi">5</span><span class="o">!</span><span class="p">;</span>          <span class="c1"># -&gt; imprime 120</span>
</span></span></code></pre></div><p>Raku宏（在编译时运行的各种函数）也使用Raku语法的可变性作为底层机制。</p>
<h3 id="3-9-6-语法和语言可扩展性的变化httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9-6 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">语法和语言可扩展性的变化</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-9-6-语法和语言可扩展性的变化httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>对语法进行低级修改以扩展语言可能看起来像是白魔法，但实际上并不像看起来那么神秘。</p>
<p>通过采用允许定义语言符号的proto类型规则（第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-9-4">3.9.4</a>节  ），可以很容易地将新的符号添加到Raku的子语法中。例如，假设编译器使用的Raku的语法称为“Raku”（其实名实际上类似于STD：ver <!-- raw HTML omitted -->，其中xxx是版本号），我们可以添加sigil“  μ  ”：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">NouveauSigilP6</span> <span class="n">is</span> <span class="n">Raku</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">sigil:sym</span><span class="sr">&lt;µ&gt;</span> <span class="p">{</span> <span class="sr">&lt;sym&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>或者，对于系统使用“  $  ”违背亲欧洲信念的读者，修改现有的印记：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">EuroRaku</span> <span class="n">is</span> <span class="n">Raku</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">sigil:sym</span><span class="sr">&lt;$&gt;</span> <span class="p">{</span> <span class="s">&#39;€&#39;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>语法EuroRaku现在允许使用的印记“  €  ”为标量，但因为它是用相同的参数相同的规则（：印记符号 <code>&lt;$&gt;</code> ，原来的语法，编译器没有）难以知道该怎么做。英国的欧洲怀疑论者可能，如果他们希望通过印记“  £  ”音乐爱好者“  ♪  ”，也是过敏反全球化“  $  ”的锤子和镰刀（“  ☭  ”）或符号变就变。</p>
<h3 id="3-9-7-展望httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9-7 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">展望</a>&nbsp;<a class="headline-hash no-text-decoration" href="#3-9-7-展望httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>还有许多其他真正令人惊叹和惊人的扩展可能性，但它们更倾向于极客或语言专家，而不是普通用户。在这里探索它们是不可能的，因为它可能需要几十个额外的页面，并且不属于本教程的范围。</p>
<p>在撰写这些页面的时候，目前几乎没有关于这个主题的文档（实际上关于Raku语法，甚至是英语），最丰富的信息来源可能是参考Raku和现有模块的标准语法（以及实验）。然而，感兴趣的读者可以通过咨询以下链接加深：Patrick Michaud的<a href="https://rakuadvent.wordpress.com/2009/12/24/day-24-the-perl-6-standard-grammar/">The Raku标准语法</a> r和Moritz Lenz的<a href="http://perlgeek.de/en/article/mutable-grammar-for-perl-6">Raku的可变语法</a>。不幸的是，这些来源很老，但如果某些细节点可能已经过时，那么概念性讨论仍然非常重要。</p>
<p>前款规定原文为2015年和可用的文件已经在优秀图书的2017年12月以来的出版物明确扩大解析Raku个语法和的正则表达式-一个递归下降到解析由莫里茨伦茨（Apress出版，201页）。如果你读英语，那你有兴趣，请不要犹豫一秒，这真的是我的书也喜欢看，当我开始学习正则表达式，特别是Raku语法。</p>
<h1 id="4-最佳实践和陷阱httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4. <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">最佳实践和陷阱</a></h1>
<p>Raku正则表达式和语法单独形成一个真正的编程模型，通常至少部分是新的，因此需要掌握。</p>
<p>为了帮助读者编写强大的正则表达式和语法，这里有一些好的做法，应用似乎是明智的（从常识来看，这些不是盲目遵循的规则）。这些良好实践的范围从简单的小规模代码格式到对匹配的精细理解，包括帮助避免可能的陷阱和不可读的代码。</p>
<h2 id="4-1-格式化代码httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">格式化代码</a>&nbsp;<a class="headline-hash no-text-decoration" href="#4-1-格式化代码httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>当不使用副词：sigspace时，在Raku正则表达式中忽略空格（和注释）。这具有插入空格和注释以提高可读性的优点。</p>
<p>比较这个非常紧凑的正则表达式来匹配浮点数（浮点数）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">float</span> <span class="p">{</span><span class="sr">&lt;[+-]&gt;</span><span class="p">?</span><span class="o">\</span><span class="n">d</span><span class="o">*</span><span class="s">&#39;.&#39;</span><span class="o">\</span><span class="n">d</span><span class="o">+</span><span class="p">[</span><span class="n">e</span><span class="sr">&lt;[+-]&gt;</span><span class="p">?</span><span class="o">\</span><span class="n">d</span><span class="o">+</span><span class="p">]?}</span>
</span></span></code></pre></div><p>用它，等价，但更具可读性：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">float</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="sr">&lt;[+-]&gt;</span><span class="p">?</span>            <span class="c1"># signe optionnel</span>
</span></span><span class="line"><span class="cl">     <span class="o">\</span><span class="n">d</span><span class="o">*</span>                <span class="c1"># chiffres de début, optionnels</span>
</span></span><span class="line"><span class="cl">     <span class="s">&#39;.&#39;</span>                <span class="c1"># séparateur décimal</span>
</span></span><span class="line"><span class="cl">     <span class="o">\</span><span class="n">d</span><span class="o">+</span>
</span></span><span class="line"><span class="cl">     <span class="p">[</span>                  <span class="c1"># exposant optionnel</span>
</span></span><span class="line"><span class="cl">        <span class="n">e</span> <span class="sr">&lt;[+-]&gt;</span><span class="p">?</span>  <span class="o">\</span><span class="n">d</span><span class="o">+</span>
</span></span><span class="line"><span class="cl">     <span class="p">]?</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>（上面这个非常简单的例子只是为了说明格式化，我们之前已经给出了更好的方法来匹配浮点数，我们将把它提高一点。）</p>
<p>通常，希望：</p>
<ul>
<li>使用原子周围和群内空间;</li>
<li>将量词直接放在原子之后，不插入空格，并且;</li>
<li>垂直对齐括号和括号打开或关闭。</li>
</ul>
<p>同样，垂直条“  | 分离替代方案的不同可能性：</p>
<pre tabindex="0"><code>my regex exemple {
    &lt;début&gt;
    [
    || &lt;choix_1&gt;
    || &lt;choix_2&gt;
    || &lt;choix_3&gt;
    ]+
    &lt;fin&gt;
}
</code></pre><h2 id="4-2-限制尺寸httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">限制尺寸</a>&nbsp;<a class="headline-hash no-text-decoration" href="#4-2-限制尺寸httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>正则表达式需要非常少的装饰或船码，因此它们通常比普通代码更紧凑。保持足够小是很重要的。</p>
<p>当捕获量变高或者我们使用命名捕获量来更好地理解它时，我们应该问自己是否应该更进一步并转到命名的正则表达式。</p>
<h3 id="4-2-1-识别浮点数httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-2-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">识别浮点数</a>&nbsp;<a class="headline-hash no-text-decoration" href="#4-2-1-识别浮点数httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>例如，前一章（第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L4-1">4.1</a>节  ）的正则表达式浮点数可以分解为更小的部分：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">token</span> <span class="n">signe</span> <span class="p">{</span> <span class="sr">&lt;[+-]&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">token</span> <span class="n">décimal</span> <span class="p">{</span> <span class="o">\</span><span class="n">d</span><span class="o">+</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">token</span> <span class="n">exposant</span> <span class="p">{</span> <span class="s">&#39;e&#39;</span> <span class="sr">&lt;signe&gt;</span><span class="p">?</span> <span class="sr">&lt;décimal&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">float</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="sr">&lt;signe&gt;</span><span class="p">?</span>
</span></span><span class="line"><span class="cl">    <span class="sr">&lt;décimal&gt;</span><span class="p">?</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#39;.&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="sr">&lt;décimal&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="sr">&lt;exposant&gt;</span><span class="p">?</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>当正则表达式变得更复杂时，这会有所帮助。例如，如果要在有指数时使小数点（“逗号”）可选：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">float</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="sr">&lt;signe&gt;</span><span class="p">?</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="o">||</span> <span class="sr">&lt;décimal&gt;</span><span class="p">?</span>  <span class="s">&#39;.&#39;</span> <span class="sr">&lt;décimal&gt;</span> <span class="sr">&lt;exposant&gt;</span><span class="p">?</span>
</span></span><span class="line"><span class="cl">    <span class="o">||</span> <span class="sr">&lt;décimal&gt;</span> <span class="sr">&lt;exposant&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这也允许更好地重用代码。上面定义的符号和小数规则（标记）也可以非常简单地定义一个整数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">entier</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="sr">&lt;signe&gt;</span><span class="p">?</span>
</span></span><span class="line"><span class="cl">    <span class="sr">&lt;décimal&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="4-2-2-识别复数httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-2-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">识别复数</a>&nbsp;<a class="headline-hash no-text-decoration" href="#4-2-2-识别复数httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>类似地，再次通过重用上面定义的符号和十进制规则（标记），我们可以定义一个复数（用笛卡尔代数表示法），如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">rule</span> <span class="n">nombre</span> <span class="p">{</span> <span class="sr">&lt;float&gt;</span> <span class="o">||</span> <span class="sr">&lt;signe&gt;</span><span class="p">?</span> <span class="sr">&lt;décimal&gt;</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">complexe</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="o">||</span> <span class="p">[</span><span class="sr">&lt;nombre&gt;</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="sr">&lt;signe&gt;</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="p">]?</span>  <span class="sr">&lt;nombre&gt;</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="s">&#39;i&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="o">||</span> <span class="sr">&lt;nombre&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;Reconnu&#34;</span> <span class="k">if</span> <span class="s">&#39;3+4i&#39;</span> <span class="o">~~</span> <span class="sr">/&lt;complexe&gt;/</span><span class="p">;</span>  <span class="c1"># -&gt; Reconnu</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Accéder aux différents éléments du nombre complexe reconnu :</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="o">~</span><span class="vg">$/</span><span class="sr">&lt;complexe&gt;</span> 
</span></span><span class="line"><span class="cl">     <span class="k">if</span> <span class="s">&#39;3.5e-7 + 4.17i&#39;</span> <span class="o">~~</span> <span class="sr">/&lt;complexe&gt;/</span><span class="p">;</span> <span class="c1"># 3.5e-7 + 4.17i</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="o">~</span><span class="vg">$/</span><span class="sr">&lt;complexe&gt;&lt;nombre&gt;</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>             <span class="c1"># -&gt;  3.5e-7</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="o">~</span><span class="vg">$/</span><span class="sr">&lt;complexe&gt;&lt;nombre&gt;</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>             <span class="c1"># -&gt;  4.17</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="o">~</span><span class="vg">$/</span><span class="sr">&lt;complexe&gt;&lt;nombre&gt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="sr">&lt;float&gt;</span>       <span class="c1"># -&gt;  3.5e-7</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="o">~</span><span class="vg">$/</span><span class="sr">&lt;complexe&gt;&lt;signe&gt;</span>                  <span class="c1"># -&gt;  +</span>
</span></span></code></pre></div><p>很明显，即使不使用语法（至少对于这个非常简单的情况），人们也可以使用命名规则构建真正的乐高游戏的砖块。识别IP地址将给出另一个例子。</p>
<h3 id="4-2-3-识别urlhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-2-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">识别URL</a>&nbsp;<a class="headline-hash no-text-decoration" href="#4-2-3-识别urlhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>我们将在此考虑简化URL（Web地址）可以是IP地址（由句点分隔的四个数字的系列），也可以是表示协议和域名的字符串，后跟路径访问资源。</p>
<p>我们可以从尝试识别IP地址开始。</p>
<h3 id="4-2-4-识别ip地址httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-2-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">识别IP地址</a>&nbsp;<a class="headline-hash no-text-decoration" href="#4-2-4-识别ip地址httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>IPv4地址由4个数字组成，由1到3位数字以点分隔。</p>
<p>正则表达式首次尝试识别IP地址可能是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="sr">/(\d**1..3) \. (\d**1..3) \. (\d**1..3) \. (\d**1..3)/</span>
</span></span></code></pre></div><p>但它至少相当费力和笨拙。</p>
<p>应用于量化器的％修饰符（参见上面的第<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2-4">2.4</a>节  ）允许你指定重复确认之间必须存在的分隔符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="sr">/ (\d ** 1..3) ** 4 % &#39;.&#39; /</span>
</span></span></code></pre></div><p>它已经好多了，但遗憾的是从某种观点来看是错误的：这个正则表达式会毫无问题地匹配字符串“125.266.742.12”，这不是有效的IP地址（四个数字中的每一个都必须表示一个字节，因此可以用十进制表示法理解，在0到255之间。这一切当然取决于我们究竟要做什么，上面的正则表达式足以捕获我们正在寻找的东西，但它并不能完全确保输入数据的验证。</p>
<p>要验证一个字节是否捕获好字节（数字低于255），可以构建一个正则表达式（或令牌）字节，它将检查这些条件，然后使用字节的正则表达式ip  ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">octet</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">                  <span class="o">||</span> <span class="p">(</span><span class="mi">25</span> <span class="sr">&lt;[0..5]&gt;</span>              <span class="c1"># 250 à 255</span>
</span></span><span class="line"><span class="cl">                  <span class="o">||</span> <span class="mi">2</span> <span class="sr">&lt;[0..4]&gt;</span> <span class="o">\</span><span class="n">d</span>             <span class="c1"># 200 à 249</span>
</span></span><span class="line"><span class="cl">                  <span class="o">||</span> <span class="mi">1</span> <span class="o">\</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span>                   <span class="c1"># 100 à 199</span>
</span></span><span class="line"><span class="cl">                  <span class="o">||</span> <span class="o">\</span><span class="n">d</span><span class="o">**</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="p">)</span>                 <span class="c1"># 0 à 99 </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">ip</span> <span class="p">{</span> <span class="sr">&lt;octet&gt;</span> <span class="o">**</span> <span class="mi">4</span> <span class="nv">%</span> <span class="err">&#39;.&#39;</span> <span class="err">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">say</span> <span class="s">&#34;Reconnu&#34;</span> <span class="k">if</span> <span class="s">&#34;244.7.245.23&#34;</span> <span class="o">~~</span> <span class="sr">/&lt;ip&gt;/</span><span class="p">;</span>     <span class="c1"># -&gt; Reconnu</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="o">~</span><span class="vg">$/</span><span class="p">;</span>                                       <span class="c1"># -&gt; 244.7.245.23</span>
</span></span></code></pre></div><p>请注意，通过使用代码类型断言（结束），可以显着简化正则表达式字节：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">octet</span> <span class="p">{(</span><span class="o">\</span><span class="n">d</span> <span class="o">**</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;</span><span class="p">?{</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="nv">$0</span> <span class="o">&lt;=</span> <span class="mi">255</span> <span class="p">}</span><span class="o">&gt;</span> <span class="p">}</span>
</span></span></code></pre></div><p>最后两个版本的正则表达式字节仍然存在一些缺陷，在某些情况下可能会出现在字符串的最后一个八位字节：字符串“244.7.245.263”（不是IP地址）正确，因为最后一个数字大于255），IP正则表达式 将识别IP地址显然是正确的，但可能不需要：“244.7.245.26”。为了避免这个问题，我们可以在字节定义中关于少于三位数字节的部分断言之前添加否定值（&lt;！Before &hellip;&gt;）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">octet</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">                  <span class="o">||</span> <span class="p">(</span><span class="mi">25</span> <span class="sr">&lt;[0..5]&gt;</span>              <span class="c1"># 250 à 255</span>
</span></span><span class="line"><span class="cl">                  <span class="o">||</span> <span class="mi">2</span> <span class="sr">&lt;[0..4]&gt;</span> <span class="o">\</span><span class="n">d</span>             <span class="c1"># 200 à 249</span>
</span></span><span class="line"><span class="cl">                  <span class="o">||</span> <span class="mi">1</span><span class="o">\</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span>                    <span class="c1"># 100 à 199</span>
</span></span><span class="line"><span class="cl">                  <span class="o">||</span> <span class="o">\</span><span class="n">d</span><span class="o">**</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;!</span><span class="n">before</span> <span class="o">\</span><span class="n">d</span><span class="o">&gt;</span><span class="p">)</span>   <span class="c1"># 0 à 99 </span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">ip</span> <span class="p">{</span> <span class="sr">&lt;octet&gt;</span> <span class="o">**</span> <span class="mi">4</span> <span class="nv">%</span> <span class="err">&#39;.&#39;</span> <span class="err">}</span>
</span></span></code></pre></div><p>同样，简单IP地址的情况非常简单，我们可能不用编写语法，因为上面的正则表达式的组合基本上就足够了。</p>
<p>但为什么我们要避免语法的定义呢？编写和使用语法并不复杂（只要你习惯了），而不是组装一系列命名规则，并且可以更容易地将语法扩展到其他元素，例如URL。如有必要，这也将受益于与语法相关的额外优势（受限命名空间，继承，方法操作，.parse和.fileparse方法等）</p>
<h3 id="4-2-5-识别url的-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-2-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">识别URL的 Grammar</a>&nbsp;<a class="headline-hash no-text-decoration" href="#4-2-5-识别url的-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h3>
<p>解析URL的语法（相当基础）可以具有以下形式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">URL</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">TOP</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="sr">&lt;schéma&gt;</span> <span class="s">&#39;://&#39;</span> 
</span></span><span class="line"><span class="cl">        <span class="p">[</span><span class="sr">&lt;ip&gt;</span> <span class="o">|</span> <span class="sr">&lt;nom-domaine&gt;</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span> <span class="s">&#39;:&#39;</span> <span class="sr">&lt;port&gt;</span><span class="p">]?</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#39;/&#39;</span> <span class="sr">&lt;chemin&gt;</span><span class="p">?</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">octet</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">\</span><span class="n">d</span><span class="o">**</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;</span><span class="p">?{</span> <span class="nv">$0</span> <span class="o">&lt;</span> <span class="mi">256</span> <span class="p">}</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">ip</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="sr">&lt;octet&gt;</span> <span class="p">[</span><span class="o">\.</span> <span class="sr">&lt;octet&gt;</span> <span class="p">]</span> <span class="o">**</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">schéma</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">\</span><span class="n">w</span><span class="o">+</span>       <span class="c1"># Ce pourrait aussi être : [http | https | ftp | ...]</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">nom</span><span class="o">-</span><span class="n">domaine</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">\</span><span class="n">w</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span> <span class="o">\.</span> <span class="o">\</span><span class="n">w</span><span class="o">+</span> <span class="p">)</span><span class="o">*</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">port</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">\</span><span class="n">d</span><span class="o">+</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">chemin</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">&lt;</span><span class="p">[</span> <span class="n">a</span><span class="o">..</span><span class="n">z</span> <span class="n">A</span><span class="o">..</span><span class="n">Z</span> <span class="mi">0</span><span class="o">..</span><span class="mi">9</span> <span class="o">\-</span><span class="n">_</span><span class="o">.!~*</span><span class="s">&#39;():@&amp;=+$,/ ]&gt;+
</span></span></span><span class="line"><span class="cl"><span class="s">    }
</span></span></span><span class="line"><span class="cl"><span class="s">}
</span></span></span><span class="line"><span class="cl"><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">my $cible = URL.parse(&#39;</span><span class="n">http:</span><span class="sr">//</span><span class="n">raku</span><span class="o">.</span><span class="n">org</span><span class="sr">/documentation/</span><span class="err">&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="nv">$cible</span><span class="sr">&lt;nom-domaine&gt;</span><span class="p">;</span>       <span class="c1"># -&gt; raku.org</span>
</span></span></code></pre></div><h2 id="4-3-要匹配什么httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">要匹配什么？</a>&nbsp;<a class="headline-hash no-text-decoration" href="#4-3-要匹配什么httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>通常，输入数据的格式没有明确指定，或者规范（如果存在）是程序员不知道的。对于预期的内容，相当自由或灵活通常是有用的，但仅限于没有模棱两可的风险。</p>
<p>如果我们以.ini文件为例：</p>
<pre tabindex="0"><code>[section]
key=value
</code></pre><p>部分标题中可以包含哪些内容？只允许一个单词可能限制太多，也许有人会写[两个单词]，或者使用破折号，或者只有上帝知道还有什么&hellip;&hellip;而不是问什么是允许的在此标题内，询问不允许的内容可能会有所帮助。</p>
<p>很明显，禁止关闭钩子，因为[a] b]至少可以说是模棱两可的。从同一观点来看，必须禁止开口钩。哪个可以给我们以下规则：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">token</span> <span class="n">entête</span> <span class="p">{</span> <span class="s">&#39;[&#39;</span> <span class="o">&lt;-</span><span class="p">[</span> <span class="o">\</span><span class="p">[</span><span class="o">\</span><span class="p">]</span> <span class="p">]</span><span class="o">&gt;+</span> <span class="s">&#39;]&#39;</span> <span class="p">}</span>
</span></span></code></pre></div><p>如果我们分析一行，这似乎运作良好。但如果我们处理整个文件，突然规则分析：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="p">[</span> <span class="n">avec</span> <span class="n">un</span>
</span></span><span class="line"><span class="cl"><span class="n">retour</span> <span class="n">à</span> <span class="n">la</span> <span class="n">ligne</span> <span class="n">entre</span> <span class="n">deux</span><span class="p">]</span>
</span></span></code></pre></div><p>作为一个正确的标题，这可能不是一个好主意。务实的妥协可能是写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">token</span> <span class="n">entête</span> <span class="p">{</span> <span class="s">&#39;[&#39;</span> <span class="o">&lt;-</span><span class="p">[</span> <span class="o">\</span><span class="p">[</span><span class="o">\</span><span class="p">]</span> <span class="o">\</span><span class="n">n</span> <span class="p">]</span><span class="o">&gt;+</span> <span class="s">&#39;]&#39;</span> <span class="p">}</span>
</span></span></code></pre></div><p>然后，在后处理中，消除空格，制表符等。在节标题的开头和结尾处。</p>
<h2 id="4-4-匹配空白httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">匹配空白</a>&nbsp;<a class="headline-hash no-text-decoration" href="#4-4-匹配空白httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>副词：sigspace（或使用规则，而不是正则表达式或令牌）对于分析可能出现在多个位置的空间非常有用。</p>
<p>如果我们回到ini文件分析的例子，规则可以是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">kvpair</span> <span class="p">{</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="sr">&lt;clef=identifiant&gt;</span> <span class="s">&#39;=&#39;</span> <span class="sr">&lt;val=identifiant&gt;</span> <span class="o">\</span><span class="n">n</span><span class="o">+</span> <span class="p">}</span>
</span></span></code></pre></div><p>这原则上有效，但可能不像人们希望的那样灵活。由于用户可以决定在等号周围放置空格，可能应该是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">regex</span> <span class="n">kvpair</span> <span class="p">{</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="sr">&lt;clef=identifiant&gt;</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="s">&#39;=&#39;</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="sr">&lt;val=identifiant&gt;</span> <span class="o">\</span><span class="n">n</span><span class="o">+</span> <span class="p">}</span>
</span></span></code></pre></div><p>这很快就会变得不切实际。所以我们可以尝试使用规则而不是正则表达式并写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">rule</span> <span class="n">kvpair</span> <span class="p">{</span> <span class="sr">&lt;clef=identifiant&gt;</span> <span class="s">&#39;=&#39;</span> <span class="sr">&lt;val=identifiant&gt;</span> <span class="o">\</span><span class="n">n</span><span class="o">+</span> <span class="p">}</span>
</span></span></code></pre></div><p>但要小心！在值消耗所有可用空间（包括换行符）后隐式匹配空格，因此\ n + final无法匹配。并且通常禁用回溯，它不起作用。</p>
<p>这是将隐式空间重新定义为输入格式中不重要的空间非常有用的地方，这可以通过重新定义ws 令牌 来完成（但它只能起作用） &lsquo;语法内部）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">IniFormat</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">ws</span> <span class="p">{</span> <span class="sr">&lt;!ww&gt;</span> <span class="o">\</span><span class="n">h</span><span class="o">*</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">entête</span> <span class="p">{</span> <span class="s">&#39;[&#39;</span> <span class="p">(</span><span class="o">\</span><span class="n">w</span><span class="o">+</span><span class="p">)</span> <span class="s">&#39;]&#39;</span> <span class="o">\</span><span class="n">n</span><span class="o">+</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">identifiant</span>  <span class="p">{</span> <span class="o">\</span><span class="n">w</span><span class="o">+</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rule</span> <span class="n">kvpair</span> <span class="p">{</span> <span class="o">\</span><span class="n">s</span><span class="o">*</span> <span class="sr">&lt;clef=identifiant&gt;</span> <span class="s">&#39;=&#39;</span> <span class="sr">&lt;val=identifiant&gt;</span> <span class="o">\</span><span class="n">n</span><span class="o">+</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">section</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="sr">&lt;entête&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="sr">&lt;kvpair&gt;</span><span class="o">*</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">TOP</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="sr">&lt;section&gt;</span><span class="o">*</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Exemple de fichier ini dans un document &#34;ici même&#34; :</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$contenu</span> <span class="o">=</span> <span class="n">q:to</span><span class="sr">/FIN_INI/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="n">passwords</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">jean</span><span class="o">=</span><span class="n">mdp1</span>
</span></span><span class="line"><span class="cl">        <span class="n">anne</span><span class="o">=</span><span class="n">plusfiable123</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="n">quotas</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">jean</span><span class="o">=</span><span class="mi">123</span>
</span></span><span class="line"><span class="cl">        <span class="n">anne</span><span class="o">=</span><span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="n">FIN_INI</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="n">so</span> <span class="n">IniFormat</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nv">$contenu</span><span class="p">);</span>
</span></span></code></pre></div><p>除了把所有的正则表达式语法，使他们成为的想法令牌或规则（正则表达式，因为这些不需要反正回溯），以及有趣的新点定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">token</span> <span class="n">ws</span> <span class="p">{</span> <span class="sr">&lt;!ww&gt;</span> <span class="o">\</span><span class="n">h</span><span class="o">*</span> <span class="p">}</span>
</span></span></code></pre></div><p>在隐式空间分析期间调用。它匹配零个或多个不在单词类型的两个字符之间的水平空格（&lt;！Ww&gt;，否定单词中的断言“）。对水平空间的限制是必要的，因为换行符（它们是垂直空格）界定了记录，因此不应该隐式匹配为仅仅空格。</p>
<p>弯道周围的空间可能仍然存在问题。正则表达式\ n +将无法匹配字符串，例如\ n \ n，因为两个换行符之间有一个空格。要匹配这种输入字符串，可以用 \ n \ s *替换 \ n +。</p>
<h2 id="4-5-避免递归左陷阱httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">避免递归左陷阱</a>&nbsp;<a class="headline-hash no-text-decoration" href="#4-5-避免递归左陷阱httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>所谓的左递归（递归或左），其中如果规则称自己年初模式，不一定消耗分析系统的字符语法可能进入无限循环的情况下（例如，因为像？或*这样的量化器允许匹配空字符串。</p>
<p>例如，请考虑以下规则：</p>
<p>避免</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">token</span> <span class="n">x</span> <span class="p">{</span> <span class="sr">&lt;x&gt;</span><span class="p">?</span> <span class="s">&#39;x&#39;</span> <span class="p">}</span>
</span></span></code></pre></div><p>有人可能认为这个规则等同于x +模式，但事实并非如此，这个规则将进入无限递归，因为量词？允许它匹配一个空字符串，然后在递归调用自身时不消耗已解析字符串的元素。</p>
<p>要避免此陷阱，必须确保每个递归调用使正则表达式引擎的光标前进至少一个字符。</p>
<p>在间接递归的情况下也可能出现左递归情况：例如，如果规则<!-- raw HTML omitted -->调用规则<!-- raw HTML omitted -->，它本身调用规则<!-- raw HTML omitted -->，并且规则<!-- raw HTML omitted -->调用反过来规则<!-- raw HTML omitted -->：如果某些字符串可能发生三个规则都不会消耗字符，那么我们再次冒险进入无限递归循环。同样，游行是为了保证这三个规则中至少有一个消耗链中的至少一个字符。</p>
<p><a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-8">3.8</a>节中计算器的语法  <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-8">。</a>提出这种间接递归。例如，你可以使用以下规则调用序列找到自己：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">TOP</span> <span class="err">→</span> <span class="n">expr</span> <span class="err">→</span> <span class="n">terme</span> <span class="err">→</span> <span class="n">atome</span> <span class="err">→</span> <span class="n">expr</span><span class="o">-</span><span class="n">parenth</span> <span class="err">→</span> <span class="n">expr</span> <span class="err">…</span>
</span></span></code></pre></div><p>其中expr规则本身是间接调用的。</p>
<p>但是在这个语法中没有无限递归的风险，因为这个递归链中的一个规则在它可以调用下一个字符串之前在解析后的字符串中消耗至少一个字符; 更确切地说，规则expr-parenth  ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">rule</span> <span class="n">expr</span><span class="o">-</span><span class="n">parenth</span>     <span class="p">{</span> <span class="s">&#39;(&#39;</span> <span class="sr">&lt;expr&gt;</span> <span class="s">&#39;)&#39;</span> <span class="p">}</span>
</span></span></code></pre></div><p>在调用递归expr之前，必须使用已解析字符串的左括号。</p>
<h2 id="4-6-调试正则表达式或raku-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-6 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">调试正则表达式或Raku Grammar</a>&nbsp;<a class="headline-hash no-text-decoration" href="#4-6-调试正则表达式或raku-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">#</a> </h2>
<p>当你开始学习编程时，你会因为愚蠢的小错误而浪费很多时间。凭借经验，你可以学会减少错误并编写更快的代码。</p>
<p>随着语法（以及更普遍的正则表达式），一切似乎都重新开始：即使是有经验的程序员在处理语法时也会开始犯愚蠢的错误。编写正则表达式以及更多的语法与开发普通程序程序没有太大关系，需要一个新的学习阶段。</p>
<p>以下是一些帮助编写和调试语法的方法（部分加入了上面已经给出的一些提示）：</p>
<ul>
<li>
<p>**小规模地继续，**按规则统治，并在你去的时候测试规则;</p>
</li>
<li>
<p><strong>单独测试规则</strong>  ：如果你的语法不起作用，请逐个测试每个规则以确定规则是错误的，错误命名（或从未调用过），等等。：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">MaGrammaire</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">TOP</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">^</span> <span class="p">[</span> <span class="sr">&lt;commentaire&gt;</span> <span class="o">|</span> <span class="sr">&lt;truc&gt;</span> <span class="p">]</span><span class="o">*</span> <span class="nv">$</span>
</span></span><span class="line"><span class="cl">    <span class="err">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">token</span> <span class="n">commentaire</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#39;#&#39;</span> <span class="o">\</span><span class="n">N</span><span class="o">*</span> <span class="vg">$$</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">truc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">^^</span><span class="p">(</span><span class="o">\</span><span class="n">S</span><span class="o">+</span><span class="p">)</span> <span class="o">\=</span> <span class="p">(</span><span class="o">\</span><span class="n">S</span><span class="o">+</span><span class="p">)</span> <span class="vg">$$</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Essayer de parser l&#39;ensemble:</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="p">?</span><span class="n">MaGrammaire</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#34;#commentaire\ntoto = titi&#34;</span><span class="p">);</span>       <span class="c1"># 0</span>
</span></span><span class="line"><span class="cl"><span class="c1"># La grammaire ne reconnaît pas le test, voyons les règles une à une</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="p">?</span><span class="n">MaGrammaire</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#34;#commentaire\n&#34;</span><span class="p">,</span> <span class="p">:</span><span class="n">rule</span><span class="sr">&lt;commentaire&gt;</span><span class="p">);</span> <span class="c1"># 1 - OK</span>
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="p">?</span><span class="n">MaGrammaire</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#34;toto = titi&#34;</span><span class="p">,</span> <span class="p">:</span><span class="n">rule</span><span class="sr">&lt;truc&gt;</span><span class="p">);</span>           <span class="c1"># 0 - KO</span>
</span></span><span class="line"><span class="cl"><span class="c1"># C&#39;est la règle &lt;truc&gt; qui ne fonctionne pas.</span>
</span></span></code></pre></div></li>
<li>
<p><strong>插入显示</strong>（打印或说）; 只需将它们放在大括号中，这些显示就可以作为普通代码运行（参见  <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L3-4-2">3.4.2。</a>）。让我们回到上一个我们到达的例子（<code>&lt;trick&gt;</code>规则不起作用）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">grammar</span> <span class="n">MaGrammaire</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">token</span> <span class="n">truc</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span> <span class="n">say</span> <span class="s">&#34;truc: appelé&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">^^</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span> <span class="n">say</span> <span class="s">&#34;truc: trouvé début de ligne&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">\</span><span class="n">S</span><span class="o">+</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="p">{</span> <span class="n">say</span> <span class="s">&#34;truc: trouvé premier identifiant: $0&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">\=</span> 
</span></span><span class="line"><span class="cl">        <span class="p">{</span> <span class="n">say</span> <span class="s">&#34;truc: trouvé =&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">\</span><span class="n">S</span><span class="o">+</span><span class="p">)</span> <span class="vg">$$</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="p">?</span><span class="n">MaGrammaire</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#34;toto = titi&#34;</span><span class="p">,</span> <span class="p">:</span><span class="n">rule</span><span class="sr">&lt;truc&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Affichage:</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1"># truc: appelé</span>
</span></span><span class="line"><span class="cl"><span class="c1"># truc: trouvé début de ligne</span>
</span></span><span class="line"><span class="cl"><span class="c1"># truc: trouvé premier identifiant: toto</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 0</span>
</span></span><span class="line"><span class="cl"><span class="c1"># C&#39;est le signe égal qui n&#39;est pas reconnu. Pourquoi? À cause</span>
</span></span><span class="line"><span class="cl"><span class="c1"># de l&#39;espace qui le précède et qui n&#39;est pas dans la règle. Il</span>
</span></span><span class="line"><span class="cl"><span class="c1"># suffit par exemple de transformer le token en rule</span>
</span></span></code></pre></div></li>
<li>
<p><strong>注意回溯</strong> ：许多习惯于Perl 5或相关正则表达式系统的程序员都熟悉回溯的使用，非常自然且非常强大，只需要简单的正则表达式。但是在嵌套语法（甚至是一组正则表达式）中很难掌握回溯。大多数词汇和句法问题都可以用不需要（或很少）回溯的方式来表达，因此强烈建议避免在语法中回溯，以及有效性的原因只是作为开发者心理健康的保障。也就是说，使用退格键更容易编写一些模式; 如果你使用它们，请务必将范围限制为唯一需要的正则表达式，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">rule</span> <span class="n">verbatim</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#39;[%&#39;</span> <span class="o">~</span> <span class="s">&#39;%]&#39;</span> <span class="n">verbatim</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Autorise le retour arrière à partir d&#39;ici seulement</span>
</span></span><span class="line"><span class="cl">    <span class="p">:</span><span class="o">!</span><span class="n">ratchet</span>
</span></span><span class="line"><span class="cl">    <span class="o">.*</span><span class="p">?</span> <span class="s">&#39;[%&#39;</span> <span class="n">endverbatim</span> <span class="s">&#39;%]&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Le retour arrière sera activé dans la regex finale, mais, dès </span>
</span></span><span class="line"><span class="cl"><span class="c1"># qu&#39;une reconnaissance aura été trouvée, on n&#39;en essaiera pas d&#39;autre</span>
</span></span></code></pre></div></li>
<li>
<p>最后，让我们提一下 Jonathan Worthington 在 Rakudo/Raku 下的<strong>优秀</strong><a href="https://github.com/jnthn/grammar-debugger/">语法和正则表达式调试</a><strong>模块</strong>。添加一个使用 Regex::Tracer; 在你的代码中，词法范围内的所有语法都会显示颜色详细的调试信息，特别显示调用哪些规则，哪些规则有效以及哪些规则失败。 <a href="https://rakuadvent.wordpress.com/2011/12/02/grammartracer-and-grammardebugger/">Advent Calendar Raku</a>提供了示例和更多详细信息。</p>
</li>
</ul>
<p>本节中的信息  <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L4-6">4.6 </a> <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L4-6">调试正则表达式或Raku语法</a>基本上是基于 Moritz Lenz的<a href="http://perlgeek.de/en/article/debug-a-perl-6-grammar">如何调试Raku语法</a>。</p>
<h1 id="5-结论httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">5. <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">结论</a></h1>
<p>正则表达式和Raku级的语法是远不是唯一的新的Raku，但他们对自己的完全新的机会开放，既为文字记录功能丰富度分析语言的表现力和可扩展性。我们很可能会发现，经验使用很难在今天进行思考。在我们看来，语法是应该使Raku成为一种语言的一部分，这种语言将在20年或更长时间内保持坚定的现代性。</p>
<h1 id="6-另见来源httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">6. <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">另见/来源</a></h1>
<p>关于Raku的文档取得了相当大的进展，但有时仍然不完整。</p>
<p>章<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2">2</a>。 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#L2">Perl的正则表达式6</a>这份文件在很大程度上是官方文档的法国适应<a href="http://doc.raku.org/language/regexes">的正则表达式</a>（匿名者），这是我们添加了来自下面的Raku次的测试中，信息剧情简介 <a href="http://design.raku.org/S05.html">S05</a>和一些官方文档的其他外围文档，此处和那里找到的文章以及个人实验产生的元素。</p>
<p>当我们最初撰写本文档时，官方英语语法文档（<a href="http://doc.raku.org/language/grammars">Grammars</a>）在当时（2015年底）非常不完整。在2018年，情况现在好多了。</p>
<p>在我们发布本文档的第一个版本时，毫无疑问是关于该主题的最完整的文档，无论是法语还是英语。在这种情况下，我们将此文档置于知识共享许可 “署名CC BY”下，以授权（甚至鼓励）任何想要自由恢复内容的人，同时希望尽可能引用来源及其作者。即使导致我们做出这种选择的情况不再具有真正的相关性（官方文档已经说过，我们已经说过，已经有了很大的改进），我们认为没有理由改变我们的想法和因此，我们保留此知识共享许可证 “Attribution CC BY”。</p>
<p>与我们在2015年撰写本文档的第一版时相比，另一个重大变化是2017年在Raku上发布了大量的六本书，从我自己的书，Think Raku - 如何像计算机科学家一样思考（450页，O&rsquo;Reilly，2017年5月），可以<a href="https://greenteapress.com/wp/think-perl-6/">电子</a>格式<a href="https://greenteapress.com/wp/think-perl-6/">免费</a>打印和<a href="https://greenteapress.com/wp/think-perl-6/">下载</a>。在2018年，这本书已被Luis F. Uceta翻译成西班牙语，可以免费下载：<a href="https://uzluisf.gitlab.io/piensaraku/">Piensa en Raku</a>。在我们写这些专栏的那天（2018年10月底），这本书已经完全翻译，但它仍在等待最后的重读。</p>
<p>其中一个新的书，发表在2017年12月，是专门讨论正则表达式和语法：用Raku的正则表达式和语法解析-一个递归下降到解析，莫里茨伦茨（215页，Apress出版）。我只能非常热情地向所有希望深化这一主题的人推荐这本优秀的书籍。</p>
<h1 id="7-致谢httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">7. <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">致谢</a></h1>
<p>我感谢<a href="http://doc.raku.org/">官方Raku文档</a>的匿名作者，<a href="http://doc.raku.org/">本文档的</a>某些部分部分是法语的免费改编。</p>
<p>我感谢<a href="http://www.developpez.net/forums/u35657/djibril/">Djibril</a>，<a href="http://www.developpez.net/forums/u471763/roland-chastain/">Roland Chastain</a>，<a href="http://www.developpez.net/forums/u124512/claudeleloup/">Claude Leloup</a>和<a href="http://www.developpez.net/forums/u940069/cognominal/">Cognominal</a>的校对以及他们非常有用的改进建议。还要感谢<a href="https://www.developpez.net/forums/u293449/cosmoknacki/">CosmoKnacki</a>和<a href="https://www.developpez.net/forums/u970486/pyramidev/">Pyramidev</a>，他们在出版后亲切地报道了一些 bug。</p>
<p>除了 Developpez.com 还有如下教程可供参考:</p>
<ul>
<li><a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/les-bases/">Perl 5到Raku-第1部分：基础知识</a></li>
<li><a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/les-nouveautes/">Perl 5到Raku - 第2部分：最新消息</a></li>
<li><a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/approfondissements/">Perl 5到Raku：深入</a></li>
<li><a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/annexe-01/">Perl 5到Raku - 附录1：Perl 5和Raku之间有什么变化</a></li>
<li><a href="http://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/annexe-02/">Perl 5到Raku - 附录2：Raku中的新功能</a></li>
<li><a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/objets/">Raku中的对象，类和角色 - 面向对象的编程教程</a></li>
<li><a href="https://naoumhankache.developpez.com/tutoriels/raku/rakuintro/">Raku简介 - Naoum Hankache和Romuald Nuguet的教程</a></li>
</ul>


        </div>
    </div>
</article>



                <footer>
                    




<div class="no-text-decoration">
    <div class="jump top"><a href="#" title="Top of this page">⮉</a></div>
    <div class="jump bottom"><a href="#bottom" title="Bottom of this page">⮋</a></div>
</div>


 
    
        <div class="hugotoc no-text-decoration">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#前所未有的表现力-图片不可用httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceimages128px-cameliasvgpng"><strong>前所未有的表现力</strong> <img src="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/images/128px-Camelia.svg.png" alt="图片不可用"></a></li>
  </ul>

  <ul>
    <li><a href="#1-1-与文件搜索类比httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">1-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">与文件搜索类比</a></a></li>
    <li><a href="#1-2-正则表达式简史httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">1-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">正则表达式简史</a></a></li>
    <li><a href="#1-3-raku-正则表达式的新功能httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">1-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">Raku 正则表达式的新功能</a></a></li>
    <li><a href="#1-4-与正则表达式相关联的功能和方法httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">1-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">与正则表达式相关联的功能和方法</a></a></li>
  </ul>

  <ul>
    <li><a href="#2-1-惯用法httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">惯用法</a></a></li>
    <li><a href="#2-2-字面量httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">字面量</a></a></li>
    <li><a href="#2-3-元字符和字符类httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">元字符和字符类</a></a>
      <ul>
        <li><a href="#2-3-1-转义字符和预定义的字符类httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-3-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">转义字符和预定义的字符类</a></a></li>
        <li><a href="#2-3-2-unicode属性httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-3-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">Unicode属性</a></a></li>
        <li><a href="#2-3-3-枚举的字符类和间隔httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-3-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">枚举的字符类和间隔</a></a></li>
      </ul>
    </li>
    <li><a href="#2-4-量词httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">量词</a></a>
      <ul>
        <li><a href="#2-4-1-量词的亲和力和节俭httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-4-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">量词的亲和力和节俭</a></a></li>
      </ul>
    </li>
    <li><a href="#2-5-替代品认识这个或那个httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">替代品（认识这个或那个）</a></a>
      <ul>
        <li><a href="#2-5-1-连词认识到这一点和那个httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-5-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">连词（认识到这一点和那个）</a></a></li>
      </ul>
    </li>
    <li><a href="#2-6-锚点httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-6 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">锚点</a></a></li>
    <li><a href="#2-7-分组和捕获httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-7 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">分组和捕获</a></a>
      <ul>
        <li><a href="#2-7-1-分组httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-7-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">分组</a></a></li>
        <li><a href="#2-7-2-捕获httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-7-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">捕获</a></a></li>
        <li><a href="#2-7-3-非捕获分组httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-7-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">非捕获分组</a></a></li>
        <li><a href="#2-7-4-捕获编号httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-7-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">捕获编号</a></a></li>
        <li><a href="#2-7-5-命名捕获httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-7-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">命名捕获</a></a></li>
      </ul>
    </li>
    <li><a href="#2-8-助理规则或规则命名httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-8 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">助理规则或规则命名</a></a></li>
    <li><a href="#2-9-副词httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-9 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">副词</a></a>
      <ul>
        <li><a href="#2-9-1-正则表达式副词httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-9-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">正则表达式副词</a></a></li>
        <li><a href="#2-9-2-认可副词httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-9-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">认可副词</a></a></li>
      </ul>
    </li>
    <li><a href="#2-10-向前查看和向后查看断言httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-10 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">向前查看和向后查看（断言）</a></a>
      <ul>
        <li><a href="#2-10-1-before-断言httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-10-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">before 断言</a></a></li>
        <li><a href="#2-10-2-after-断言httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">2-10-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">after 断言</a></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#3-1-该砖以建立一个语法httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">该“砖”，以建立一个语法</a></a></li>
    <li><a href="#3-2-创建-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">创建 Grammar</a></a>
      <ul>
        <li><a href="#3-2-1-语法的语法定义httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-2-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">语法的语法定义</a></a></li>
        <li><a href="#3-2-2-grammar-的继承httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-2-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">Grammar 的继承</a></a></li>
      </ul>
    </li>
    <li><a href="#3-3-使用-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">使用 Grammar</a></a></li>
    <li><a href="#3-4-类和对象的股票httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">类和对象的股票</a></a>
      <ul>
        <li><a href="#3-4-1-在确认期间执行代码httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-4-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">在确认期间执行代码</a></a></li>
        <li><a href="#3-4-2-在语法中执行代码的其他方法httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-4-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">在语法中执行代码的其他方法</a></a></li>
      </ul>
    </li>
    <li><a href="#3-5-验证perl模块名称的-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">验证Perl模块名称的 Grammar</a></a>
      <ul>
        <li><a href="#3-5-1-验证-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-5-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">验证 Grammar</a></a></li>
        <li><a href="#3-5-2-添加动作对象httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-5-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">添加动作对象</a></a></li>
      </ul>
    </li>
    <li><a href="#3-6-分析json的-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">分析JSON的 Grammar</a></a>
      <ul>
        <li><a href="#3-6-1-json文档的结构httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6-1<a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#"> JSON文档的结构</a></a></li>
        <li><a href="#3-6-2-示例json文档httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">示例JSON文档</a></a></li>
        <li><a href="#3-6-3-逐步写出json-grammar-的元素httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">逐步写出JSON Grammar 的元素</a></a></li>
        <li><a href="#3-6-4-json-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">JSON Grammar</a></a></li>
        <li><a href="#3-6-5-添加动作httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-6-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">添加动作</a></a></li>
      </ul>
    </li>
    <li><a href="#3-7-用于分析伪xml的-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-7 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">用于分析（伪）XML的 Grammar</a></a></li>
    <li><a href="#3-8-计算算术表达式计算器httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-8 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">计算算术表达式（计算器）</a></a></li>
    <li><a href="#3-9-grammar先进的理念和观点httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">Grammar：先进的理念和观点</a></a>
      <ul>
        <li><a href="#3-9-1-角色构成httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">角色构成</a></a></li>
        <li><a href="#3-9-2-设定规则httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">设定规则</a></a></li>
        <li><a href="#3-9-3-递归规则和动态变量httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">递归规则和动态变量</a></a></li>
        <li><a href="#3-9-4-所谓原类型的规则httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">所谓原类型的规则</a></a></li>
        <li><a href="#3-9-5-继承和可变语法httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">继承和可变语法</a></a></li>
        <li><a href="#3-9-6-语法和语言可扩展性的变化httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9-6 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">语法和语言可扩展性的变化</a></a></li>
        <li><a href="#3-9-7-展望httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">3-9-7 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">展望</a></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#4-1-格式化代码httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">格式化代码</a></a></li>
    <li><a href="#4-2-限制尺寸httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">限制尺寸</a></a>
      <ul>
        <li><a href="#4-2-1-识别浮点数httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-2-1 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">识别浮点数</a></a></li>
        <li><a href="#4-2-2-识别复数httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-2-2 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">识别复数</a></a></li>
        <li><a href="#4-2-3-识别urlhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-2-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">识别URL</a></a></li>
        <li><a href="#4-2-4-识别ip地址httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-2-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">识别IP地址</a></a></li>
        <li><a href="#4-2-5-识别url的-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-2-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">识别URL的 Grammar</a></a></li>
      </ul>
    </li>
    <li><a href="#4-3-要匹配什么httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-3 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">要匹配什么？</a></a></li>
    <li><a href="#4-4-匹配空白httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-4 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">匹配空白</a></a></li>
    <li><a href="#4-5-避免递归左陷阱httpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-5 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">避免递归左陷阱</a></a></li>
    <li><a href="#4-6-调试正则表达式或raku-grammarhttpslaurent-rosenfelddeveloppezcomtutorielsperlrakuregex-grammaire-puissanceutm_sourcedlvritutm_mediumtwitter">4-6 <a href="https://laurent-rosenfeld.developpez.com/tutoriels/perl/raku/regex-grammaire-puissance/?utm_source=dlvr.it&amp;utm_medium=twitter#">调试正则表达式或Raku Grammar</a></a></li>
  </ul>
</nav>
            <a href="#" class="back-to-top">Back to top</a>
        </div>
    
    
<script src="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js"></script>

<link rel="preload" href="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js" as="script">

<script type="application/javascript">(function() {
     var $window = $(window);
     if ($window.width() >= 1400) { 
         var $toc = $('#TableOfContents');
         if ($toc.length > 0) {
             function onScroll(){
                 var currentScroll = $window.scrollTop();
                 var h = $('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .h-feed h2');
                 var id = "";
                 h.each(function (i, e) {
                     e = $(e);
                     if (e.offset().top - 10 <= currentScroll) {
                         id = e.attr('id');
                     }
                 });
                 var current = $toc.find('a.current');
                 if (current.length == 1 && current.eq(0).attr('href') == '#' + id) return true;

                 current.each(function (i, e) {
                     $(e).removeClass('current').siblings('ul').hide();
                 });
                 $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                     $(e).children('a').addClass('current').siblings('ul').show();
                 });
             }
             $window.on('scroll', onScroll);
             $(document).ready(function() {
                 $toc.find('a').parent('li').find('ul').hide();
                 onScroll();
                 document.getElementsByClassName('hugotoc')[0].style.display = '';
             });}}})();</script>








<div class="backtotop center no-text-decoration">
    <a href="#">back to <span class="top">top</span></a>
</div>


<div class="right">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>
<div class="clear-float"></div>



<div class="prev-next-navigator clear-float">
    
        <span class="prev-post left no-text-decoration">
            <a href="https://ohmyweekly.github.io/notes/distance-between-two-points-in-raku/" class="nobr">« 🎄 16/25. Raku 中两点之间的距离</a>
        </span>
    
    
        <span class="next-post right no-text-decoration">
            <a href="https://ohmyweekly.github.io/notes/%E5%AE%9E%E7%94%A8%E7%9A%84web%E5%86%85%E5%AE%B9munging/" class="nobr">第十五天 - 实用的Web内容Munging »</a>
        </span>
    
</div>


<a id="bottom"></a>









                       







                    <ul class="no-bullets feed right inline">
    
        
        
    
</ul>
<div class="clear-float"></div>

                </footer>
                <hr />
            </div>               

            <footer> 
                

<ul class="social no-text-decoration">
    
</ul>










 
    
    



<p class="generated no-text-decoration">
    Generated using  <a href="https://gitlab.com/kaushalmodi/hugo-theme-refined"><code class="nobr">hugo-theme-refined</code></a> + <span class="nobr">Hugo <a href="https://github.com/gohugoio/hugo/commit/312735366b20d64bd61bff8627f593749f86c964">0.123.7</a></span>
</p>

<p>
    
</p>




<div class="badges no-text-decoration">
    
    

    
</div>




<script type="application/javascript">var nav=responsiveNav("#nav");</script>




<script defer src="/js/libs/fragmentions/wrapper.min.e8c468c89edc4f5dccaa8c720c6b220b3088a16cd7b1e4a1e3345985788260c9.js"></script>









            </footer>
        </div> 
    </body>
</html>
