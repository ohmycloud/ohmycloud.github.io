<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
    
    
    

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    
    <meta name="referrer" content="no-referrer">

    <title>
        
            为最年轻的 Raku 贡献力量 ❚ 焉知非鱼
        
    </title>

    
    


    
    
    
    

    
    
    
    

    
    
    

    
    
    
    <style>
     
     
     :root {
         --theme-color: #ac4142;
         --theme-color-light: rgba(172, 65, 66, 0.2);
     }
     
     html {
         line-height: 1.5;
     }
    </style>

    
    

    
    
    
    
    <link rel="stylesheet" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css">
    
    <link rel="preload" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css" as="style">

    



    
        <style>
         
         /* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }

         
         /* Overrides on top of the theme and Chroma CSS */
/* Chroma-based lines highlighting in code blocks */
.chroma .hl {
    background-color: #e8e8e8;
    /* Extend highlight up to 100 characters (assuming that the code blocks never have more than 100 characters in a line) */
    min-width: 100ch;
}
/* GenericHeading */ .chroma .gh { color: #999999; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa; font-weight: bold }

         
        </style>
    

    

    
    
    

    
    <script src="/js/responsive-nav-orig.min.bd7287557074084b7eba924cf5291f3c285cf8e8324c500f4389ff9fb1a92169.js"></script>
    
    <link rel="preload" href="/js/responsive-nav-orig.min.bd7287557074084b7eba924cf5291f3c285cf8e8324c500f4389ff9fb1a92169.js" as="script">

    
    
    <script defer src="/js/libs/fa/fontawesome-all.min.3ca622508ac5fb18aee4bc98a61b16f99348c918b1c684528246d1a95d82fd34.js"></script>
    
    <link rel="preload" href="/js/libs/fa/fontawesome-all.min.3ca622508ac5fb18aee4bc98a61b16f99348c918b1c684528246d1a95d82fd34.js" as="script">

    

    

    
    
    

    
    
<!-- rel="me" links for IndieAuth -->







    
 
<meta property="og:title" content="为最年轻的 Raku 贡献力量" />
<meta property="og:description"
      content="Contributing to Raku" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/" />


    
        <meta property="article:published_time" content="2021-02-16T00:00:00&#43;08:00"/>
    
    
        <meta property="article:modified_time" content="2021-02-16T00:00:00&#43;08:00"/>
    









    




     <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="为最年轻的 Raku 贡献力量"/>
<meta name="twitter:description" content="Contributing to Raku"/>


    
    
    <link rel="alternate" type="application/jf2post+json" href="https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/jf2post.json" title="Jf2post for 焉知非鱼" />
    
     



    
    
    
        
    


     
        
        <meta name="DC.Creator" content="焉知非鱼"/>
    



    
    
    
    <meta name="hugo-build-date" content="2021-07-05T10:46:28Z"/>
    <meta name="hugo-commit-hash" content="724d5db5"/>
    <meta name="generator" content="Hugo 0.85.0" />
</head>


    
        <body lang="en">
    

        
        <div class="border" id="home"></div>

        <div class="wrapper">   
            
<nav id="nav" class="nav-collapse opened" aria-hidden="false">
    <ul class="navbar">
        <li><a class="" href="/">Home</a></li>
        
            
                <li><a class="" href="https://ohmyweekly.github.io/posts/">Posts</a></li>
            
        
            
                <li><a class="" href="https://ohmyweekly.github.io/notes/">Notes</a></li>
            
        
        
            <li><a class="" href="https://ohmyweekly.github.io/search/">Search</a></li>
        
    </ul>
</nav>

            <div class="container">
                <header class="masthead">
                    <div class="masthead-title no-text-decoration">
                        <a href="/">焉知非鱼</a> <span class="blinking-cursor">❚</span>
                    </div>
                    <div class="masthead-tagline">
                        rakulang, dartlang, nimlang, golang, rustlang, lang lang no see
                    </div>
                </header>

                








<article class="post h-entry notes">
    <header>
        <div class="center">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 74 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__raku__"
                                
                                
                                title="See all 19 posts tagged with ‘Raku’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/raku/">Raku</a>
                            </li>
                        
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 13 posts tagged with ‘Rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/rakulang/">Rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>

        <h1 class="post-title p-name">为最年轻的 Raku 贡献力量</h1>

        
        <data class="u-url" value="https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/"></data>

        <div class="date-syndication">
            


    
    
    <div class="post-date">
        
        <time datetime="2021-02-16T00:00:00+0800" class="dt-published">Tue Feb 16, 2021</time>
        
        
    </div>


            




        </div>
         



    
    
    
        
    


    
        
        <span class="hide">
            &mdash; <a href="https://ohmyweekly.github.io" class="u-author">焉知非鱼</a>
        </span>
    


    </header>

    <div class="content">
        
    <div class="description p-summary">
        
        
        
        
        
            
            
        
        <p>Contributing to Raku</p>
    </div>



        





                       


        <div class="e-content">
            




<p>在过去的几周里，我看到了一些<a href="https://mydeveloperplanet.com/2021/01/20/how-to-start-contributing-to-open-source/">文章</a>和<a href="https://youtu.be/GAqfMNB-YBU">视频</a>，讲述了在开源软件中构思是多么的伟大。这次我又想起了另一篇旧文<a href="http://strangelyconsistent.org/blog/perl-6-is-my-mmorpg">Raku 是我的 MMORPG</a>。它说，你可以从以下几个方面受益于开源软件。比如说，可以做一个大侠，基于一些开源软件来写软件。作为写手，可以写博客、微博等，对所选软件产生兴趣。或者你可以成为一个法师 - 实现新的功能和修复 bug。今天小编就带着弓箭手来告诉大家如何成为 <a href="https://raku.org/">Raku</a> 编程语言的法师。</p>
<h2 id="选择一个任务">选择一个任务&nbsp;<a class="headline-hash no-text-decoration" href="#选择一个任务">#</a> </h2>
<p>让我们挑选一些编译器的 bug，并修复它。让我们去 <a href="https://rakudo.org/">Rakudo</a> 编译器 <a href="https://github.com/rakudo/rakudo/issues">issues</a>中选择我们想要修复的 bug。我滚动了一下 bug 列表，遇到了解析 - 运气不错，我前段时间一直在研究<a href="https://www.apress.com/gp/book/9781484232279">编译器语法</a>，看了一本这方面的好书。找到了四个问题。</p>
<p><img src="https://rakurs.atroxaper.net/assets/img/posts/2021-02-13-contributing-raku-1.png" alt="img"></p>
<ol>
<li>标签为 LTA （Less Than Awesome - 当真实行为与直觉预期不同时）- 我们暂时把它划掉。</li>
<li>标签 &ldquo;需要共识&rdquo; - 我们只想修复一个不复杂的 bug - 肯定要划掉。</li>
<li>标签为 &ldquo;grammar and actions&rdquo; 的关于一个可能死的代码是一个很好的候选人的第一个任务。</li>
</ol>
<p>任务确定后，现在我们需要配置工作环境。在 Windows、Linux 和 macOS 中，一切应该都差不多。我将通过 macOS 的例子来告诉你。</p>
<h2 id="建立工作环境">建立工作环境&nbsp;<a class="headline-hash no-text-decoration" href="#建立工作环境">#</a> </h2>
<p>为源码和我们建立的编译器建立文件夹。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">mkdir ~/dev-rakudo <span class="o">&amp;&amp;</span> mkdir ~/dev-rakudo-install
</code></pre></div><p>Rakudo 编译器由三部分组成。</p>
<ol>
<li>虚拟机。现在有三种 - JVM、JS 和 MoarVM。我们以 MoarVM 为最稳定的一个。</li>
<li>NQP（Not Quite Perl），是一种低级（中级）语言的实现，它是 Raku 的一个 &ldquo;子集&rdquo;。虚拟机可以执行用 NQP 编写的代码。</li>
<li>Rakudo 编译器本身，用 NQP 和 Raku 编写。</li>
</ol>
<p>下载并编译这三个组件。我分别花了一分半钟、半分钟和两分半钟才编好。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:MoarVM/MoarVM.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> MoarVM
perl Configure.pl --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install

<span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:Raku/nqp.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> nqp
perl Configure.pl --backend<span class="o">=</span>moar --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install

<span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:rakudo/rakudo.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> rakudo
perl Configure.pl --backend<span class="o">=</span>moar --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install
</code></pre></div><p>注意参数。<code>--prefix</code> 显示了 <code>make install</code> 命令后可执行文件的复制位置，<code>--backend=moar</code> 表示正在使用的虚拟机，而 <code>-j 4</code> 则要求跨多线程并行化（以防加快进度）。现在我们已经建立了 Rakudo 编译器 <code>~/dev-rakudo-install/bin/raku</code>。我们还需要官方的编译器测试套件。你应该把它和它的代码一起放在文件夹里。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">cd</span> ~/dev-rakudo/rakudo <span class="o">&amp;&amp;</span> git clone https://github.com/Raku/roast.git t/spec
</code></pre></div><p>我们先进行测试。这种情况很常见，有些测试甚至在新的变化之前就失败了。我们需要辨别出来，这样以后就不会害怕这些变化破坏了一些不必要的东西。</p>
<p>这里和下面我将在 <code>~/dev-rakudo/rakudo</code> 文件夹中工作，除非另有说明。</p>
<pre><code>&gt; make spectest
[...]
Test Summary Report
-------------------
t/spec/S32-str/utf8-c8.t    (Wstat: 65280 Tests: 54 Failed: 0)
  Non-zero exit status: 255
  Parse errors: Bad plan.  You planned 66 tests but ran 54.
Files=1346, Tests=117144, 829 wallclock secs (27.70 usr  6.04 sys + 2638.79 cusr 210.98 csys = 2883.51 CPU)
Result: FAIL
make: *** [m-spectest5] Error 1
</code></pre><p>14分钟内共运行了1,346个文件中的117,144次测试。一些与utf8相关的测试由于某种原因失败了，其他的都能正常工作。我们已经准备好去工作了!</p>
<h2 id="让我们来看看问题的陈述">让我们来看看问题的陈述&nbsp;<a class="headline-hash no-text-decoration" href="#让我们来看看问题的陈述">#</a> </h2>
<p>问题陈述说，某个元运算符 <code>R</code> 在 colonpair 上出了问题。我打开文档，搜索 R 这个词，但下拉列表中没有这个名字的元运算符。我试着输入 metaop，看到的是反向元操作符(R)。原来，如果你想把二元运算的操作数按相反的顺序写出来，你可以在其符号前使用前缀 R。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">3</span> <span class="ow">R</span><span class="o">-</span> <span class="mi">2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># Output: True</span>
</code></pre></div><p>Colonpair 是命名对的语法。它看起来就像名字前面有一个冒号，前面有一个括号，有一个值。例如 <code>:foo(42)</code> 是一个名称为 <code>foo</code>、值为 <code>42</code> 的对儿。这个语法通常用于在调用函数时，向函数传递一个命名参数中的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-with-named-parameter</span><span class="p">(</span><span class="o">:</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-with-named-parameter</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1"># Output: 42</span>
</code></pre></div><p>如果一个函数参数不是命名的，而是位置的，那么在用命名对调用时，就会出现编译错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-without-named-parameter</span><span class="p">(</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># &lt;- 没有冒号</span>
  <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-without-named-parameter</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1"># Unexpected named argument &#39;foo&#39; passed</span>
</code></pre></div><p>如果你在调用这样的函数时用括号包围一个参数，整个参数对将被传递到位置参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-without-named-parameter</span><span class="p">(</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-without-named-parameter</span><span class="p">((:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">)));</span> <span class="c1"># Output: foo =&gt; 42</span>
</code></pre></div><p>在 Raku 中，你可以写一个函数来捕获所有传递给它的参数并分析它们。这是在单个参数 - 捕获前用竖线完成的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-with-capture</span><span class="p">(</span><span class="o">|</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># &lt;- 参数捕获</span>
  <span class="nb">say</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-with-capture</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>     <span class="c1"># Output: \(:foo(42))</span>
<span class="nf">sub-with-capture</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>           <span class="c1"># Output: \(42)</span>
<span class="nf">sub-with-capture</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">3</span> <span class="ow">Z</span><span class="o">-</span> <span class="mi">2</span><span class="p">));</span> <span class="c1"># Output: \(:foo((1,).Seq))</span>
<span class="nf">sub-with-capture</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">3</span> <span class="ow">R</span><span class="o">-</span> <span class="mi">2</span><span class="p">));</span> <span class="c1"># Output: \(-1)</span>
</code></pre></div><p>倒数第二行使用了 Z 元操作符 - zip 操作符。它将左右两部分作为一个列表，按顺序每次从它们中抽取一个元素，并进行操作，从而形成一个序列。</p>
<p>在最后一行，只用了我们需要的 R 元操作符。在这种情况下，它不是一个对，而是一个常量，它被传递到函数中。我们可以假设这是元运算符工作方式的一些特殊性，但用 Z 的例子表明并非如此。其实这是一个 bug - 当一个对被传递到一个使用 R 元运算符的函数中时，它的值会被转换。</p>
<h2 id="我们需要一个新的测试">我们需要一个新的测试&nbsp;<a class="headline-hash no-text-decoration" href="#我们需要一个新的测试">#</a> </h2>
<p>为了确保未来的变化能够修复错误的行为，我们需要写一个新的测试。在测试文件中不难找到 R 元操作符的测试（<a href="https://github.com/Raku/roast/blob/fea1d16d993eb851d2935155e0b0d074fa3593bf/S03-metaops/reverse.t">S03-metops/reverse.t</a>）。下面我将补充以下测试。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># https://github.com/rakudo/rakudo/issues/1632</span>
<span class="p">{</span>
  <span class="k">sub</span> <span class="nf">subroutine</span><span class="p">(</span><span class="nv">$expected</span><span class="o">,</span> <span class="o">|</span><span class="n">actual</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">is</span> <span class="nc">actual</span><span class="o">.</span><span class="nb">gist</span><span class="o">,</span> <span class="nv">$expected</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Сolonpair exists</span><span class="p">&#34;</span>
  <span class="p">}</span>

  <span class="nf">subroutine</span><span class="p">(&#39;</span><span class="s1">\(:foo(-1))</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">foo</span><span class="p">(</span><span class="mi">3</span> <span class="ow">R</span><span class="o">-</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div><p>该测试有一个功能，有两个参数 - 正常和捕获。在函数体中，第一个参数和传递的 Capture 的字符串表示进行比较。你可以使用 <code>make</code> 对新构建的编译器进行单独测试。</p>
<pre><code>&gt; make t/spec/S03-metaops/reverse.t
[...]
ok 69 - [R~]=
not ok 70 - Colonpair exists
# Failed test 'Colonpair exists'
# at t/spec/S03-metaops/reverse.t line 191
# expected: '\(:foo(-1))'
#      got: '\(-1)'
# You planned 69 tests, but ran 70
# You failed 1 test of 70
</code></pre><p>你可以看到，测试失败了（如预期）。还有一个单独的说明，系统预计69次测试，但收到70次。这是基于 TAP 的测试系统的特点 - 必须在文件的顶部修正传递给 <code>plan</code> 函数的数字。现在测试崩溃了，但编号没有受到影响。你可以开始修复它。</p>
<h2 id="凝视法">凝视法&nbsp;<a class="headline-hash no-text-decoration" href="#凝视法">#</a> </h2>
<p>一开始我很相信任务上的标签 - 如果是解析的话，一定是源码解析阶段的某个地方出现了问题。目前我的认识如下：</p>
<ol>
<li>基础解析器代码在文件 <code>rakudo/src/Perl6/Grammar.nqp</code> 中。</li>
<li>这个解析器是从 <code>nqp/src/HLL/Grammar.nqp</code> 文件中的基础解析器继承的。</li>
<li>元操作符的解析和工作方式都差不多，你可以通过仔细观察来发现不同之处。</li>
</ol>
<p>我在基础解析器代码中找到了对元操作符的引用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">infix_prefix_meta_operator:sym</span>&lt;R&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">infixish</span><span class="p">(&#39;</span><span class="s1">R</span><span class="p">&#39;)&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">can_meta</span><span class="p">(</span><span class="nv">$&lt;infixish&gt;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">reverse the args of</span><span class="p">&#34;)&gt;</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="nv">O</span><span class="o">=.</span><span class="nf">revO</span><span class="p">(</span><span class="nv">$&lt;infixish&gt;</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>

<span class="k">token</span> <span class="nf">infix_prefix_meta_operator:sym</span>&lt;Z&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">infixish</span><span class="p">(&#39;</span><span class="s1">Z</span><span class="p">&#39;)&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">can_meta</span><span class="p">(</span><span class="nv">$&lt;infixish&gt;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">zip with</span><span class="p">&#34;)&gt;</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="sr">O(|</span><span class="nv">%list_infix</span><span class="sr">)</span><span class="p">&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>这需要对 Raku grammar 有一定的了解。据我所知，原来这两个元运算符在解析上并没有根本的区别。一段时间后，在解析器的源代码中挖得够多了，我开始怀疑解析工作是否正确。认为代码 <code>my $r = :foo(3 R- 2); say $r; # Output: foo =&gt; -1</code> 正确工作的建议 - 问题恰恰发生在调用函数时。显然，我白白相信了任务栏上的标签。</p>
<h2 id="编译器将帮助我们">编译器将帮助我们&nbsp;<a class="headline-hash no-text-decoration" href="#编译器将帮助我们">#</a> </h2>
<p>颇为迟钝的我想起了我从一开始就应该做的事情。Rakudo 编译器有 <code>--target</code> 调试开关。它取编译器阶段的名称，你想将其结果输出到控制台并退出。我想看看 <code>--target=parse</code>（因为我只知道这一个）。</p>
<p>我从 <code>~/dev-rakudo/rakudo</code> 文件夹中使用 <code>rakumo-m</code>，这样我就不必等待通过 <code>make install</code> 命令将所需文件复制到 <code>~/dev-rakudo-install</code>。简单的脚本可以这样运行。更复杂的脚本必须在 <code>make install</code> 之后从 <code>-install</code> 中运行。</p>
<pre><code>&gt; cat ~/test.raku
sub s(|c) { say c }
s(:foo(3 R- 2));
s(:foo(3 Z- 2));

&gt; ./rakudo-m --target=parse ~/test.raku
[...]
- args: (:foo(3 R- 2))
  - semiarglist: :foo(3 R- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 R- 2)
        - colonpair: :foo(3 R- 2)
          - identifier: foo
          - coloncircumfix: (3 R- 2)
            - circumfix: (3 R- 2)
              - semilist: 3 R- 2
                - statement: 1 matches
                  - EXPR: R- 2
[...]
- args: (:foo(3 Z- 2))
  - semiarglist: :foo(3 Z- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 Z- 2)
        - colonpair: :foo(3 Z- 2)
          - identifier: foo
          - coloncircumfix: (3 Z- 2)
            - circumfix: (3 Z- 2)
              - semilist: 3 Z- 2
                - statement: 1 matches
                  - EXPR: Z- 2
[...]
</code></pre><p>结论：R 和 Z 的解析是一样的。</p>
<h2 id="这不是解析">这不是解析&nbsp;<a class="headline-hash no-text-decoration" href="#这不是解析">#</a> </h2>
<p>所有被解析的东西都会被传递给所谓的 Action，把字词变成一棵语法树。在我们的例子中，Actions 位于文件 <code>rakudo/src/Perl6/Actions.nqp</code> 和 <code>nqp/src/HLL/Actions.nqp</code> 中。这里就比较容易搞清楚了，毕竟是代码，是 grammar。</p>
<p>我在主 Actions 中找到了以下代码。</p>
<pre><code>[...]
elsif $&lt;infix_prefix_meta_operator&gt; {
[...]
  if    $metasym eq 'R' { $helper := '&amp;METAOP_REVERSE'; $t := nqp::flip($t) if $t; }
  elsif $metasym eq 'X' { $helper := '&amp;METAOP_CROSS'; $t := nqp::uc($t); }
  elsif $metasym eq 'Z' { $helper := '&amp;METAOP_ZIP'; $t := nqp::uc($t); }
  
  my $metapast := QAST::Op.new( :op&lt;call&gt;, :name($helper), WANTED($basepast,'infixish') );
  $metapast.push(QAST::Var.new(:name(baseop_reduce($base&lt;OPER&gt;&lt;O&gt;.made)), :scope&lt;lexical&gt;))
    if $metasym eq 'X' || $metasym eq 'Z';
[...]
</code></pre><p>它说，如果在代码中解析了元操作符 <code>R</code>、<code>Z</code> 或 <code>X</code>，就应该在语法树中添加一些 <code>METAOP_</code> 函数调用。在 <code>Z</code> 和 <code>X</code> 的情况下，它会多一个参数，即某种还原函数。所有这些功能都可以在 <code>rakudo/src/core.c/metaops.pm6</code> 中找到。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">METAOP_REVERSE</span><span class="p">(</span>\<span class="n">op</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
  <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">args</span> <span class="p">{</span> <span class="n">op</span><span class="o">.</span><span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="o">.</span><span class="nb">reverse</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">METAOP_ZIP</span><span class="p">(</span>\<span class="n">op</span><span class="o">,</span> <span class="nv">&amp;reduce</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
 <span class="nf">nqp::if</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="nf">prec</span><span class="p">(&#39;</span><span class="s1">thunky</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">starts-with</span><span class="p">(&#39;</span><span class="s1">.</span><span class="p">&#39;)</span><span class="o">,</span>
  <span class="k">-&gt;</span> <span class="o">+</span><span class="n">lol</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$arity</span> <span class="o">=</span> <span class="n">lol</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
    <span class="o">[...]</span>
  <span class="p">}</span><span class="o">,</span>
  <span class="k">-&gt;</span> <span class="o">+</span><span class="n">lol</span> <span class="p">{</span>
    <span class="nb">Seq</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="n">Rakudo::Iterator</span><span class="o">.</span><span class="nf">ZipIterablesOp</span><span class="p">(</span><span class="n">lol</span><span class="o">,</span><span class="n">op</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>给你：</p>
<ol>
<li><code>\op</code> 是由我们的元操作符，即-，在前面的操作。</li>
<li>Trait <code>implementation-detail</code> 只是表明这不是公共代码，是编译器实现的一部分。</li>
<li>由于-操作没有笨重的特性，所以 <code>&amp;reduce</code> 函数不会参与计算，<code>Z</code> 的结果是 <code>Seq.new(...)</code>。</li>
<li><code>R</code> 的结果是一个操作调用 - 参数顺序相反。</li>
</ol>
<p>这时我想起还有一个 - 目标，即星。它将显示行动的结果。</p>
<pre><code>&gt; ./rakudo-m --target=ast ~/test.raku
[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-
    - QAST::Op(call &amp;METAOP_REVERSE) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;7&gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(:named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;8&gt; :before_promotion&lt;?&gt; Z-
    - QAST::Op(call &amp;METAOP_ZIP) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
      - QAST::Var(lexical &amp;METAOP_REDUCE_LEFT)
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
</code></pre><p>一如所料。除了调用不同的 <code>METAOP_</code> 函数外，所有的东西几乎都是一样的。从它们的代码中我们可以知道，原则上这些函数的不同之处在于返回值的类型 - 分别是 <code>Int</code> 和 <code>Seq</code>。众所周知，Raku 对不同类型的对象的上下文相当敏感&hellip;&hellip;我想，它关注的可能是返回值。我试着用下面的方式修改代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">METAOP_REVERSE</span><span class="p">(</span>\<span class="n">op</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
  <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">args</span> <span class="p">{</span> <span class="nb">Seq</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="o">.</span><span class="nb">reverse</span><span class="p">))</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>编译、运行。</p>
<pre><code>&gt; make
[...]
Stage start      :   0.000
Stage parse      :  61.026
Stage syntaxcheck:   0.000
Stage ast        :   0.000
Stage optimize   :   7.076
Stage mast       :  14.120
Stage mbc        :   3.941
[...]
&gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
</code></pre><p>一切都没有改变。所以，不是返回值&hellip;&hellip;想了想，不知道为什么结果又是 <code>-1</code> 而不是 <code>(-1,).Seq</code>。而且，从代码来看，<code>Seq</code> 根本就没有一个合适的构造函数。下一次，作为一些疯狂的事情，我尝试调用 <code>METAOP_REVERSE</code> 结果只是为了崩溃。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">METAOP_REVERSE</span><span class="p">(</span>\<span class="n">op</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
  <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">args</span> <span class="p">{</span> <span class="nb">die</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>编译、运行。</p>
<pre><code>&gt; make
[...]
&gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
</code></pre><p>怎么会呢？语法树中包含了对 <code>METAOP_REVERSE</code> 的调用，它的代码应该是折叠的，但计算仍然进行，我们得到 <code>-1</code>。</p>
<p>这些都不是《行动》。</p>
<p>这里我的目光落在编译器的构建日志上。它是一些阶段被列在那里。我随机试了 <code>--target=mast</code>。</p>
<pre><code>&gt; ./rakudo-m --target=mast ~/test.raku
[...]
MAST::Frame name&lt;s&gt;, cuuid&lt;1&gt;
  Local types: 0&lt;obj&gt;, 1&lt;obj&gt;, 2&lt;obj&gt;, 3&lt;obj&gt;, 4&lt;int&gt;, 5&lt;str&gt;, 6&lt;obj&gt;, 7&lt;obj&gt;, 8&lt;obj&gt;,
  Lexical types: 0&lt;obj&gt;, 1&lt;obj&gt;, 2&lt;obj&gt;, 3&lt;obj&gt;, 4&lt;obj&gt;,
  Lexical names: 0&lt;c&gt;, 1&lt;$¢&gt;, 2&lt;$!&gt;, 3&lt;$/&gt;, 4&lt;$*DISPATCHER&gt;,
  Lexical map: $!&lt;2&gt;, c&lt;0&gt;, $*DISPATCHER&lt;4&gt;, $¢&lt;1&gt;, $/&lt;3&gt;,
  Outer: name&lt;&lt;unit&gt;&gt;, cuuid&lt;2&gt;
[...]
</code></pre><p>某种不可读的矩阵。星号和桅杆之间有一个阶段性的优化。</p>
<pre><code>&gt; ./rakudo-m --target=optimize ~/test.raku
[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;infix:&lt;-&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;7&gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;8&gt; :before_promotion&lt;?&gt; Z-
    - QAST::Op(callstatic &amp;METAOP_ZIP) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
      - QAST::Var(lexical &amp;METAOP_REDUCE_LEFT)
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
</code></pre><p>哈，就是这样。在优化阶段后，行将失踪。</p>
<ul>
<li><code>QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-.</code>
并将整个 <code>METAOP_REVERSE</code> 调用替换为通常的操作 <code>(&amp;infix:&lt;-&gt;)</code>。所以问题一定在优化器的某个地方。</li>
</ul>
<p>只有在 <code>optim_nameless_call</code> 方法中才会提到 <code>&amp;METAOP_ASSIGN</code>，其中 <code>QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;)</code>。显然，这个操作负责生成一个命名对 - 它已经有了一个名字（命名参数），它需要计算值。从优化 <code>_</code> 无名方法的执行路径来看，我们可以得出结论，我们对最后一个块感兴趣。</p>
<pre><code>[...]
  elsif self.op_eq_core($metaop, '&amp;METAOP_REVERSE') {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;&amp; nqp::elems($op) == 3;
    return QAST::Op.new(:op&lt;call&gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;
  }
[...]
</code></pre><p>让我提醒你，优化前的树是这样的。</p>
<pre><code>[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-
    - QAST::Op(call &amp;METAOP_REVERSE) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
    - QAST::Want &lt;wanted&gt; 3
    - QAST::Want &lt;wanted&gt; 2
[...]
</code></pre><p>而精简之后，是这样的。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;infix:&lt;-&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
    - QAST::Want &lt;wanted&gt; 3
[...]
</code></pre><p>也就是说，优化 <code>_nameless_call</code> 做了以下工作。</p>
<p>如果我们的 <code>QAST::Op+{QAST::SpecialArg}</code> 操作没有三个参数，如果 <code>METAOP_REVERSE</code> 调用没有一个正确的类型，我们就返回空。这不是我们的情况。
否则，我们将返回一个新的操作，代替我们的 <code>QAST::Op+{QAST::SpecialArg}</code> 操作，以相反的顺序调用 <code>&amp;infix:&lt;-&gt;</code> 参数。就是说，把结果打包成一对就没了。</p>
<p>在摸索了一下如何解决这个问题，并阅读了 <code>QAST::SpecialArg</code> 和 <code>QAST::Node</code> 的实现后，我想到了下面的代码。</p>
<pre><code>[...]
  elsif self.op_eq_core($metaop, '&amp;METAOP_REVERSE') {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;&amp; nqp::elems($op) == 3;
    my $opt_result := QAST::Op.new(:op&lt;call&gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;
    if $op.named { $opt_result.named($op.named) } # 添加选项 named 
    if $op.flat { $opt_result.flat($op.flat) }    # 添加选项 flat
    return $opt_result;
  }
[...]
</code></pre><p>还有木头。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call &amp;infix:&lt;-&gt; :named&lt;foo&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
    - QAST::Want &lt;wanted&gt; 3
[...]
</code></pre><p>命名的参数返回到它的位置。测试也开始通过。</p>
<pre><code>&gt; make t/spec/S03-metaops/reverse.t
[...]
All tests successful.
Files=1, Tests=70,  3 wallclock secs ( 0.03 usr  0.01 sys +  3.61 cusr  0.17 csys =  3.82 CPU)
Result: PASS
</code></pre><p>我们本可以就此打住，但这是编译器优化器的代码，它的结果是一个有两个整数参数的方法调用。我认为这在某种程度上是次优的。如果我们将返回表达式改为返回 <code>self.visit_op: $opt_result;</code>，对产生的非优化操作调用优化器，那么产生的树就会像这样。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Want+{QAST::SpecialArg}(:named&lt;foo&gt;)
    - QAST::WVal+{QAST::SpecialArg}(Int :named&lt;foo&gt;)
    - QAST::IVal(-1)
[...]
</code></pre><p>现在一切都很理想。</p>
<h2 id="分享成果">分享成果&nbsp;<a class="headline-hash no-text-decoration" href="#分享成果">#</a> </h2>
<p>我们已经到了终点线。现在我们只需要分享我们的经验。</p>
<ol>
<li>重要的是：运行所有的 <code>make spectest</code> 测试，确保没有新的东西被破坏。</li>
<li>在 GitHub 上使用 Rakudo 编译器和测试制作 fork 仓库。</li>
<li>将 fork 仓库添加为新的 git 远程仓库。</li>
<li>cd ~/dev-rakudo/rakudo &amp;&amp; git remote add fork <!-- raw HTML omitted -->。</li>
<li>cd ~/dev-rakudo/t/spec &amp;&amp; git remote add fork <!-- raw HTML omitted -->。</li>
</ol>
<p>重要：确保两个仓库在 git 中都有正确的用户名和用户邮箱。</p>
<p>提交到两个版本库，详细说明你为什么做了哪些改动，并添加对原始问题跟踪器的引用。</p>
<p>运行提交。</p>
<pre><code>cd ~/dev-rakudo/rakudo &amp;&amp; git push fork
cd ~/dev-rakudo/t/spec &amp;&amp; git push fork
</code></pre><p>向两个仓库提出拉取请求。在他们的描述中，最好是相互参照和原任务。</p>
<h2 id="结论">结论&nbsp;<a class="headline-hash no-text-decoration" href="#结论">#</a> </h2>
<p>对开源软件的贡献是：</p>
<ol>
<li>趣味性和趣味性。</li>
<li>给你的感觉是，你正在做一些有用的事情，你真的是。</li>
<li>让你认识新的有趣和专业的人（任何关于 Raku 的问题都会在 <code>#raku IRC</code> 频道中得到回答）。</li>
<li>解决非标准任务，没有截止日期的压力，是一种很好的体验。</li>
</ol>
<p>选择你觉得最舒服的角色等级，去做新的任务吧!</p>


        </div>
    </div>
</article>



                <footer>
                    




<div class="no-text-decoration">
    <div class="jump top"><a href="#" title="Top of this page">⮉</a></div>
    <div class="jump bottom"><a href="#bottom" title="Bottom of this page">⮋</a></div>
</div>


 
    
        <div class="hugotoc no-text-decoration">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#选择一个任务">选择一个任务</a></li>
    <li><a href="#建立工作环境">建立工作环境</a></li>
    <li><a href="#让我们来看看问题的陈述">让我们来看看问题的陈述</a></li>
    <li><a href="#我们需要一个新的测试">我们需要一个新的测试</a></li>
    <li><a href="#凝视法">凝视法</a></li>
    <li><a href="#编译器将帮助我们">编译器将帮助我们</a></li>
    <li><a href="#这不是解析">这不是解析</a></li>
    <li><a href="#分享成果">分享成果</a></li>
    <li><a href="#结论">结论</a></li>
  </ul>
</nav>
            <a href="#" class="back-to-top">Back to top</a>
        </div>
    
    
<script src="/js/libs/jquery/3.3.1/jquery.slim.min.min.0ba8e190674d48a904a724830c26f36870743a24700151e5e415dbeb9bff8db3.js"></script>

<link rel="preload" href="/js/libs/jquery/3.3.1/jquery.slim.min.min.0ba8e190674d48a904a724830c26f36870743a24700151e5e415dbeb9bff8db3.js" as="script">

<script type="application/javascript">(function() {
     var $window = $(window);
     if ($window.width() >= 1400) { 
         var $toc = $('#TableOfContents');
         if ($toc.length > 0) {
             function onScroll(){
                 var currentScroll = $window.scrollTop();
                 var h = $('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .h-feed h2');
                 var id = "";
                 h.each(function (i, e) {
                     e = $(e);
                     if (e.offset().top - 10 <= currentScroll) {
                         id = e.attr('id');
                     }
                 });
                 var current = $toc.find('a.current');
                 if (current.length == 1 && current.eq(0).attr('href') == '#' + id) return true;

                 current.each(function (i, e) {
                     $(e).removeClass('current').siblings('ul').hide();
                 });
                 $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                     $(e).children('a').addClass('current').siblings('ul').show();
                 });
             }
             $window.on('scroll', onScroll);
             $(document).ready(function() {
                 $toc.find('a').parent('li').find('ul').hide();
                 onScroll();
                 document.getElementsByClassName('hugotoc')[0].style.display = '';
             });}}})();</script>








<div class="backtotop center no-text-decoration">
    <a href="#">back to <span class="top">top</span></a>
</div>


<div class="right">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 74 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__raku__"
                                
                                
                                title="See all 19 posts tagged with ‘Raku’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/raku/">Raku</a>
                            </li>
                        
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 13 posts tagged with ‘Rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/rakulang/">Rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>
<div class="clear-float"></div>



<div class="prev-next-navigator clear-float">
    
        <span class="prev-post left no-text-decoration">
            <a href="https://ohmyweekly.github.io/notes/2021-02-28-custom-when/" class="nobr">« 自定义 when</a>
        </span>
    
    
        <span class="next-post right no-text-decoration">
            <a href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/" class="nobr">Caesarean Substrings With Raku and Perl »</a>
        </span>
    
</div>


<a id="bottom"></a>









                       







                    <ul class="no-bullets feed right inline">
    
        
        
    
</ul>
<div class="clear-float"></div>

                </footer>
                <hr />
            </div>               

            <footer> 
                

<ul class="social no-text-decoration">
    
</ul>










 
    
    



<p class="generated no-text-decoration">
    Generated using  <a href="https://gitlab.com/kaushalmodi/hugo-theme-refined"><code class="nobr">hugo-theme-refined</code></a> + <span class="nobr">Hugo <a href="https://github.com/gohugoio/hugo/commit/724d5db5">0.85.0</a></span>
</p>

<p>
    
</p>




<div class="badges no-text-decoration">
    
    

    
</div>




<script type="application/javascript">var nav=responsiveNav("#nav");</script>




<script defer src="/js/libs/fragmentions/wrapper.min.bb9cba24742e67e37fba39db0232882a4017cc42418c890851b702c95d7b558c.js"></script>









            </footer>
        </div> 
    </body>
</html>
