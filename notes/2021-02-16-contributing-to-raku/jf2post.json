{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"content":{"html":"\u003cp\u003e在过去的几周里，我看到了一些\u003ca href=\"https://mydeveloperplanet.com/2021/01/20/how-to-start-contributing-to-open-source/\"\u003e文章\u003c/a\u003e和\u003ca href=\"https://youtu.be/GAqfMNB-YBU\"\u003e视频\u003c/a\u003e，讲述了在开源软件中构思是多么的伟大。这次我又想起了另一篇旧文\u003ca href=\"http://strangelyconsistent.org/blog/perl-6-is-my-mmorpg\"\u003eRaku 是我的 MMORPG\u003c/a\u003e。它说，你可以从以下几个方面受益于开源软件。比如说，可以做一个大侠，基于一些开源软件来写软件。作为写手，可以写博客、微博等，对所选软件产生兴趣。或者你可以成为一个法师 - 实现新的功能和修复 bug。今天小编就带着弓箭手来告诉大家如何成为 \u003ca href=\"https://raku.org/\"\u003eRaku\u003c/a\u003e 编程语言的法师。\u003c/p\u003e\n\u003ch2 id=\"选择一个任务\"\u003e选择一个任务\u003c/h2\u003e\n\u003cp\u003e让我们挑选一些编译器的 bug，并修复它。让我们去 \u003ca href=\"https://rakudo.org/\"\u003eRakudo\u003c/a\u003e 编译器 \u003ca href=\"https://github.com/rakudo/rakudo/issues\"\u003eissues\u003c/a\u003e中选择我们想要修复的 bug。我滚动了一下 bug 列表，遇到了解析 - 运气不错，我前段时间一直在研究\u003ca href=\"https://www.apress.com/gp/book/9781484232279\"\u003e编译器语法\u003c/a\u003e，看了一本这方面的好书。找到了四个问题。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://rakurs.atroxaper.net/assets/img/posts/2021-02-13-contributing-raku-1.png\" alt=\"img\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e标签为 LTA （Less Than Awesome - 当真实行为与直觉预期不同时）- 我们暂时把它划掉。\u003c/li\u003e\n\u003cli\u003e标签 \u0026ldquo;需要共识\u0026rdquo; - 我们只想修复一个不复杂的 bug - 肯定要划掉。\u003c/li\u003e\n\u003cli\u003e标签为 \u0026ldquo;grammar and actions\u0026rdquo; 的关于一个可能死的代码是一个很好的候选人的第一个任务。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e任务确定后，现在我们需要配置工作环境。在 Windows、Linux 和 macOS 中，一切应该都差不多。我将通过 macOS 的例子来告诉你。\u003c/p\u003e\n\u003ch2 id=\"建立工作环境\"\u003e建立工作环境\u003c/h2\u003e\n\u003cp\u003e为源码和我们建立的编译器建立文件夹。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003emkdir ~/dev-rakudo \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e mkdir ~/dev-rakudo-install\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eRakudo 编译器由三部分组成。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e虚拟机。现在有三种 - JVM、JS 和 MoarVM。我们以 MoarVM 为最稳定的一个。\u003c/li\u003e\n\u003cli\u003eNQP（Not Quite Perl），是一种低级（中级）语言的实现，它是 Raku 的一个 \u0026ldquo;子集\u0026rdquo;。虚拟机可以执行用 NQP 编写的代码。\u003c/li\u003e\n\u003cli\u003eRakudo 编译器本身，用 NQP 和 Raku 编写。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e下载并编译这三个组件。我分别花了一分半钟、半分钟和两分半钟才编好。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~/dev-rakudo \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e git clone git@github.com:MoarVM/MoarVM.git \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e MoarVM\nperl Configure.pl --prefix ~/dev-rakudo-install \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make -j \u003cspan class=\"m\"\u003e4\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make install\n\n\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~/dev-rakudo \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e git clone git@github.com:Raku/nqp.git \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e nqp\nperl Configure.pl --backend\u003cspan class=\"o\"\u003e=\u003c/span\u003emoar --prefix ~/dev-rakudo-install \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make -j \u003cspan class=\"m\"\u003e4\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make install\n\n\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~/dev-rakudo \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e git clone git@github.com:rakudo/rakudo.git \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e rakudo\nperl Configure.pl --backend\u003cspan class=\"o\"\u003e=\u003c/span\u003emoar --prefix ~/dev-rakudo-install \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make -j \u003cspan class=\"m\"\u003e4\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make install\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e注意参数。\u003ccode\u003e--prefix\u003c/code\u003e 显示了 \u003ccode\u003emake install\u003c/code\u003e 命令后可执行文件的复制位置，\u003ccode\u003e--backend=moar\u003c/code\u003e 表示正在使用的虚拟机，而 \u003ccode\u003e-j 4\u003c/code\u003e 则要求跨多线程并行化（以防加快进度）。现在我们已经建立了 Rakudo 编译器 \u003ccode\u003e~/dev-rakudo-install/bin/raku\u003c/code\u003e。我们还需要官方的编译器测试套件。你应该把它和它的代码一起放在文件夹里。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~/dev-rakudo/rakudo \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e git clone https://github.com/Raku/roast.git t/spec\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我们先进行测试。这种情况很常见，有些测试甚至在新的变化之前就失败了。我们需要辨别出来，这样以后就不会害怕这些变化破坏了一些不必要的东西。\u003c/p\u003e\n\u003cp\u003e这里和下面我将在 \u003ccode\u003e~/dev-rakudo/rakudo\u003c/code\u003e 文件夹中工作，除非另有说明。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; make spectest\n[...]\nTest Summary Report\n-------------------\nt/spec/S32-str/utf8-c8.t    (Wstat: 65280 Tests: 54 Failed: 0)\n  Non-zero exit status: 255\n  Parse errors: Bad plan.  You planned 66 tests but ran 54.\nFiles=1346, Tests=117144, 829 wallclock secs (27.70 usr  6.04 sys + 2638.79 cusr 210.98 csys = 2883.51 CPU)\nResult: FAIL\nmake: *** [m-spectest5] Error 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e14分钟内共运行了1,346个文件中的117,144次测试。一些与utf8相关的测试由于某种原因失败了，其他的都能正常工作。我们已经准备好去工作了!\u003c/p\u003e\n\u003ch2 id=\"让我们来看看问题的陈述\"\u003e让我们来看看问题的陈述\u003c/h2\u003e\n\u003cp\u003e问题陈述说，某个元运算符 \u003ccode\u003eR\u003c/code\u003e 在 colonpair 上出了问题。我打开文档，搜索 R 这个词，但下拉列表中没有这个名字的元运算符。我试着输入 metaop，看到的是反向元操作符(R)。原来，如果你想把二元运算的操作数按相反的顺序写出来，你可以在其符号前使用前缀 R。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e \u003cspan class=\"ow\"\u003eR\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"c1\"\u003e# Output: True\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eColonpair 是命名对的语法。它看起来就像名字前面有一个冒号，前面有一个括号，有一个值。例如 \u003ccode\u003e:foo(42)\u003c/code\u003e 是一个名称为 \u003ccode\u003efoo\u003c/code\u003e、值为 \u003ccode\u003e42\u003c/code\u003e 的对儿。这个语法通常用于在调用函数时，向函数传递一个命名参数中的值。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003esub-with-named-parameter\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"nf\"\u003esub-with-named-parameter\u003c/span\u003e\u003cspan class=\"p\"\u003e(:\u003c/span\u003e\u003cspan class=\"s\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e \u003cspan class=\"c1\"\u003e# Output: 42\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果一个函数参数不是命名的，而是位置的，那么在用命名对调用时，就会出现编译错误。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003esub-without-named-parameter\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"c1\"\u003e# \u0026lt;- 没有冒号\u003c/span\u003e\n  \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"nf\"\u003esub-without-named-parameter\u003c/span\u003e\u003cspan class=\"p\"\u003e(:\u003c/span\u003e\u003cspan class=\"s\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e \u003cspan class=\"c1\"\u003e# Unexpected named argument \u0026#39;foo\u0026#39; passed\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果你在调用这样的函数时用括号包围一个参数，整个参数对将被传递到位置参数。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003esub-without-named-parameter\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nv\"\u003e$foo\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"nf\"\u003esub-without-named-parameter\u003c/span\u003e\u003cspan class=\"p\"\u003e((:\u003c/span\u003e\u003cspan class=\"s\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e)));\u003c/span\u003e \u003cspan class=\"c1\"\u003e# Output: foo =\u0026gt; 42\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 Raku 中，你可以写一个函数来捕获所有传递给它的参数并分析它们。这是在单个参数 - 捕获前用竖线完成的。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003esub-with-capture\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"n\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"c1\"\u003e# \u0026lt;- 参数捕获\u003c/span\u003e\n  \u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"n\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"nf\"\u003esub-with-capture\u003c/span\u003e\u003cspan class=\"p\"\u003e(:\u003c/span\u003e\u003cspan class=\"s\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e     \u003cspan class=\"c1\"\u003e# Output: \\(:foo(42))\u003c/span\u003e\n\u003cspan class=\"nf\"\u003esub-with-capture\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e           \u003cspan class=\"c1\"\u003e# Output: \\(42)\u003c/span\u003e\n\u003cspan class=\"nf\"\u003esub-with-capture\u003c/span\u003e\u003cspan class=\"p\"\u003e(:\u003c/span\u003e\u003cspan class=\"s\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e \u003cspan class=\"ow\"\u003eZ\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e \u003cspan class=\"c1\"\u003e# Output: \\(:foo((1,).Seq))\u003c/span\u003e\n\u003cspan class=\"nf\"\u003esub-with-capture\u003c/span\u003e\u003cspan class=\"p\"\u003e(:\u003c/span\u003e\u003cspan class=\"s\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e \u003cspan class=\"ow\"\u003eR\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e \u003cspan class=\"c1\"\u003e# Output: \\(-1)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e倒数第二行使用了 Z 元操作符 - zip 操作符。它将左右两部分作为一个列表，按顺序每次从它们中抽取一个元素，并进行操作，从而形成一个序列。\u003c/p\u003e\n\u003cp\u003e在最后一行，只用了我们需要的 R 元操作符。在这种情况下，它不是一个对，而是一个常量，它被传递到函数中。我们可以假设这是元运算符工作方式的一些特殊性，但用 Z 的例子表明并非如此。其实这是一个 bug - 当一个对被传递到一个使用 R 元运算符的函数中时，它的值会被转换。\u003c/p\u003e\n\u003ch2 id=\"我们需要一个新的测试\"\u003e我们需要一个新的测试\u003c/h2\u003e\n\u003cp\u003e为了确保未来的变化能够修复错误的行为，我们需要写一个新的测试。在测试文件中不难找到 R 元操作符的测试（\u003ca href=\"https://github.com/Raku/roast/blob/fea1d16d993eb851d2935155e0b0d074fa3593bf/S03-metaops/reverse.t\"\u003eS03-metops/reverse.t\u003c/a\u003e）。下面我将补充以下测试。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"c1\"\u003e# https://github.com/rakudo/rakudo/issues/1632\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003esubroutine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$expected\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"n\"\u003eactual\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eis\u003c/span\u003e \u003cspan class=\"nc\"\u003eactual\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003egist\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nv\"\u003e$expected\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eСolonpair exists\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\n  \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n  \u003cspan class=\"nf\"\u003esubroutine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e\\(:foo(-1))\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e \u003cspan class=\"ow\"\u003eR\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e该测试有一个功能，有两个参数 - 正常和捕获。在函数体中，第一个参数和传递的 Capture 的字符串表示进行比较。你可以使用 \u003ccode\u003emake\u003c/code\u003e 对新构建的编译器进行单独测试。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; make t/spec/S03-metaops/reverse.t\n[...]\nok 69 - [R~]=\nnot ok 70 - Colonpair exists\n# Failed test 'Colonpair exists'\n# at t/spec/S03-metaops/reverse.t line 191\n# expected: '\\(:foo(-1))'\n#      got: '\\(-1)'\n# You planned 69 tests, but ran 70\n# You failed 1 test of 70\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e你可以看到，测试失败了（如预期）。还有一个单独的说明，系统预计69次测试，但收到70次。这是基于 TAP 的测试系统的特点 - 必须在文件的顶部修正传递给 \u003ccode\u003eplan\u003c/code\u003e 函数的数字。现在测试崩溃了，但编号没有受到影响。你可以开始修复它。\u003c/p\u003e\n\u003ch2 id=\"凝视法\"\u003e凝视法\u003c/h2\u003e\n\u003cp\u003e一开始我很相信任务上的标签 - 如果是解析的话，一定是源码解析阶段的某个地方出现了问题。目前我的认识如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e基础解析器代码在文件 \u003ccode\u003erakudo/src/Perl6/Grammar.nqp\u003c/code\u003e 中。\u003c/li\u003e\n\u003cli\u003e这个解析器是从 \u003ccode\u003enqp/src/HLL/Grammar.nqp\u003c/code\u003e 文件中的基础解析器继承的。\u003c/li\u003e\n\u003cli\u003e元操作符的解析和工作方式都差不多，你可以通过仔细观察来发现不同之处。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e我在基础解析器代码中找到了对元操作符的引用。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003einfix_prefix_meta_operator:sym\u003c/span\u003e\u0026lt;R\u0026gt; \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e\n\u003c/span\u003e\u003cspan class=\"sr\"\u003e  \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003esym\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003einfixish\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003eR\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;)\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{}\u003c/span\u003e\u003cspan class=\"sr\"\u003e\n\u003c/span\u003e\u003cspan class=\"sr\"\u003e  \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ecan_meta\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$\u0026lt;infixish\u0026gt;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003ereverse the args of\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;)\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e\n\u003c/span\u003e\u003cspan class=\"sr\"\u003e  \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nv\"\u003eO\u003c/span\u003e\u003cspan class=\"o\"\u003e=.\u003c/span\u003e\u003cspan class=\"nf\"\u003erevO\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$\u0026lt;infixish\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e\n\u003c/span\u003e\u003cspan class=\"sr\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003etoken\u003c/span\u003e \u003cspan class=\"nf\"\u003einfix_prefix_meta_operator:sym\u003c/span\u003e\u0026lt;Z\u0026gt; \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"sr\"\u003e\n\u003c/span\u003e\u003cspan class=\"sr\"\u003e  \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003esym\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003einfixish\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003eZ\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;)\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{}\u003c/span\u003e\u003cspan class=\"sr\"\u003e\n\u003c/span\u003e\u003cspan class=\"sr\"\u003e  \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ecan_meta\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$\u0026lt;infixish\u0026gt;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003ezip with\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;)\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e\n\u003c/span\u003e\u003cspan class=\"sr\"\u003e  \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"sr\"\u003eO(|\u003c/span\u003e\u003cspan class=\"nv\"\u003e%list_infix\u003c/span\u003e\u003cspan class=\"sr\"\u003e)\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e\n\u003c/span\u003e\u003cspan class=\"sr\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这需要对 Raku grammar 有一定的了解。据我所知，原来这两个元运算符在解析上并没有根本的区别。一段时间后，在解析器的源代码中挖得够多了，我开始怀疑解析工作是否正确。认为代码 \u003ccode\u003emy $r = :foo(3 R- 2); say $r; # Output: foo =\u0026gt; -1\u003c/code\u003e 正确工作的建议 - 问题恰恰发生在调用函数时。显然，我白白相信了任务栏上的标签。\u003c/p\u003e\n\u003ch2 id=\"编译器将帮助我们\"\u003e编译器将帮助我们\u003c/h2\u003e\n\u003cp\u003e颇为迟钝的我想起了我从一开始就应该做的事情。Rakudo 编译器有 \u003ccode\u003e--target\u003c/code\u003e 调试开关。它取编译器阶段的名称，你想将其结果输出到控制台并退出。我想看看 \u003ccode\u003e--target=parse\u003c/code\u003e（因为我只知道这一个）。\u003c/p\u003e\n\u003cp\u003e我从 \u003ccode\u003e~/dev-rakudo/rakudo\u003c/code\u003e 文件夹中使用 \u003ccode\u003erakumo-m\u003c/code\u003e，这样我就不必等待通过 \u003ccode\u003emake install\u003c/code\u003e 命令将所需文件复制到 \u003ccode\u003e~/dev-rakudo-install\u003c/code\u003e。简单的脚本可以这样运行。更复杂的脚本必须在 \u003ccode\u003emake install\u003c/code\u003e 之后从 \u003ccode\u003e-install\u003c/code\u003e 中运行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; cat ~/test.raku\nsub s(|c) { say c }\ns(:foo(3 R- 2));\ns(:foo(3 Z- 2));\n\n\u0026gt; ./rakudo-m --target=parse ~/test.raku\n[...]\n- args: (:foo(3 R- 2))\n  - semiarglist: :foo(3 R- 2)\n    - arglist: 1 matches\n      - EXPR: :foo(3 R- 2)\n        - colonpair: :foo(3 R- 2)\n          - identifier: foo\n          - coloncircumfix: (3 R- 2)\n            - circumfix: (3 R- 2)\n              - semilist: 3 R- 2\n                - statement: 1 matches\n                  - EXPR: R- 2\n[...]\n- args: (:foo(3 Z- 2))\n  - semiarglist: :foo(3 Z- 2)\n    - arglist: 1 matches\n      - EXPR: :foo(3 Z- 2)\n        - colonpair: :foo(3 Z- 2)\n          - identifier: foo\n          - coloncircumfix: (3 Z- 2)\n            - circumfix: (3 Z- 2)\n              - semilist: 3 Z- 2\n                - statement: 1 matches\n                  - EXPR: Z- 2\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e结论：R 和 Z 的解析是一样的。\u003c/p\u003e\n\u003ch2 id=\"这不是解析\"\u003e这不是解析\u003c/h2\u003e\n\u003cp\u003e所有被解析的东西都会被传递给所谓的 Action，把字词变成一棵语法树。在我们的例子中，Actions 位于文件 \u003ccode\u003erakudo/src/Perl6/Actions.nqp\u003c/code\u003e 和 \u003ccode\u003enqp/src/HLL/Actions.nqp\u003c/code\u003e 中。这里就比较容易搞清楚了，毕竟是代码，是 grammar。\u003c/p\u003e\n\u003cp\u003e我在主 Actions 中找到了以下代码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\nelsif $\u0026lt;infix_prefix_meta_operator\u0026gt; {\n[...]\n  if    $metasym eq 'R' { $helper := '\u0026amp;METAOP_REVERSE'; $t := nqp::flip($t) if $t; }\n  elsif $metasym eq 'X' { $helper := '\u0026amp;METAOP_CROSS'; $t := nqp::uc($t); }\n  elsif $metasym eq 'Z' { $helper := '\u0026amp;METAOP_ZIP'; $t := nqp::uc($t); }\n  \n  my $metapast := QAST::Op.new( :op\u0026lt;call\u0026gt;, :name($helper), WANTED($basepast,'infixish') );\n  $metapast.push(QAST::Var.new(:name(baseop_reduce($base\u0026lt;OPER\u0026gt;\u0026lt;O\u0026gt;.made)), :scope\u0026lt;lexical\u0026gt;))\n    if $metasym eq 'X' || $metasym eq 'Z';\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e它说，如果在代码中解析了元操作符 \u003ccode\u003eR\u003c/code\u003e、\u003ccode\u003eZ\u003c/code\u003e 或 \u003ccode\u003eX\u003c/code\u003e，就应该在语法树中添加一些 \u003ccode\u003eMETAOP_\u003c/code\u003e 函数调用。在 \u003ccode\u003eZ\u003c/code\u003e 和 \u003ccode\u003eX\u003c/code\u003e 的情况下，它会多一个参数，即某种还原函数。所有这些功能都可以在 \u003ccode\u003erakudo/src/core.c/metaops.pm6\u003c/code\u003e 中找到。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003eMETAOP_REVERSE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\\\u003cspan class=\"n\"\u003eop\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eis\u003c/span\u003e \u003cspan class=\"nc\"\u003eimplementation-detail\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"nb\"\u003eargs\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003eop\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"nb\"\u003eargs\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ereverse\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003eMETAOP_ZIP\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\\\u003cspan class=\"n\"\u003eop\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nv\"\u003e\u0026amp;reduce\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eis\u003c/span\u003e \u003cspan class=\"nc\"\u003eimplementation-detail\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n \u003cspan class=\"nf\"\u003enqp::if\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eop\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eprec\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003ethunky\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003estarts-with\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e.\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;)\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003elol\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$arity\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003elol\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eelems\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e[...]\u003c/span\u003e\n  \u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003elol\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nb\"\u003eSeq\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003enew\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eRakudo::Iterator\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eZipIterablesOp\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elol\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eop\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n  \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e给你：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e\\op\u003c/code\u003e 是由我们的元操作符，即-，在前面的操作。\u003c/li\u003e\n\u003cli\u003eTrait \u003ccode\u003eimplementation-detail\u003c/code\u003e 只是表明这不是公共代码，是编译器实现的一部分。\u003c/li\u003e\n\u003cli\u003e由于-操作没有笨重的特性，所以 \u003ccode\u003e\u0026amp;reduce\u003c/code\u003e 函数不会参与计算，\u003ccode\u003eZ\u003c/code\u003e 的结果是 \u003ccode\u003eSeq.new(...)\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eR\u003c/code\u003e 的结果是一个操作调用 - 参数顺序相反。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这时我想起还有一个 - 目标，即星。它将显示行动的结果。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; ./rakudo-m --target=ast ~/test.raku\n[...]\n- QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R-\n    - QAST::Op(call \u0026amp;METAOP_REVERSE) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt;\n      - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt;\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(3)  3\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(2)  2\n[...]\n- QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;7\u0026gt; s(:foo(3 Z- 2))\n  - QAST::Op+{QAST::SpecialArg}(:named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;8\u0026gt; :before_promotion\u0026lt;?\u0026gt; Z-\n    - QAST::Op(call \u0026amp;METAOP_ZIP) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt;\n      - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt;\n      - QAST::Var(lexical \u0026amp;METAOP_REDUCE_LEFT)\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(3)  3\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(2)  2\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e一如所料。除了调用不同的 \u003ccode\u003eMETAOP_\u003c/code\u003e 函数外，所有的东西几乎都是一样的。从它们的代码中我们可以知道，原则上这些函数的不同之处在于返回值的类型 - 分别是 \u003ccode\u003eInt\u003c/code\u003e 和 \u003ccode\u003eSeq\u003c/code\u003e。众所周知，Raku 对不同类型的对象的上下文相当敏感\u0026hellip;\u0026hellip;我想，它关注的可能是返回值。我试着用下面的方式修改代码。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003eMETAOP_REVERSE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\\\u003cspan class=\"n\"\u003eop\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eis\u003c/span\u003e \u003cspan class=\"nc\"\u003eimplementation-detail\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"nb\"\u003eargs\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nb\"\u003eSeq\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003enew\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eop\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"nb\"\u003eargs\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ereverse\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e编译、运行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; make\n[...]\nStage start      :   0.000\nStage parse      :  61.026\nStage syntaxcheck:   0.000\nStage ast        :   0.000\nStage optimize   :   7.076\nStage mast       :  14.120\nStage mbc        :   3.941\n[...]\n\u0026gt; ./rakudo-m ~/test.raku\n\\(-1)\n\\(:foo((1,).Seq))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e一切都没有改变。所以，不是返回值\u0026hellip;\u0026hellip;想了想，不知道为什么结果又是 \u003ccode\u003e-1\u003c/code\u003e 而不是 \u003ccode\u003e(-1,).Seq\u003c/code\u003e。而且，从代码来看，\u003ccode\u003eSeq\u003c/code\u003e 根本就没有一个合适的构造函数。下一次，作为一些疯狂的事情，我尝试调用 \u003ccode\u003eMETAOP_REVERSE\u003c/code\u003e 结果只是为了崩溃。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003eMETAOP_REVERSE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\\\u003cspan class=\"n\"\u003eop\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eis\u003c/span\u003e \u003cspan class=\"nc\"\u003eimplementation-detail\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"nb\"\u003eargs\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nb\"\u003edie\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e编译、运行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; make\n[...]\n\u0026gt; ./rakudo-m ~/test.raku\n\\(-1)\n\\(:foo((1,).Seq))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e怎么会呢？语法树中包含了对 \u003ccode\u003eMETAOP_REVERSE\u003c/code\u003e 的调用，它的代码应该是折叠的，但计算仍然进行，我们得到 \u003ccode\u003e-1\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这些都不是《行动》。\u003c/p\u003e\n\u003cp\u003e这里我的目光落在编译器的构建日志上。它是一些阶段被列在那里。我随机试了 \u003ccode\u003e--target=mast\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; ./rakudo-m --target=mast ~/test.raku\n[...]\nMAST::Frame name\u0026lt;s\u0026gt;, cuuid\u0026lt;1\u0026gt;\n  Local types: 0\u0026lt;obj\u0026gt;, 1\u0026lt;obj\u0026gt;, 2\u0026lt;obj\u0026gt;, 3\u0026lt;obj\u0026gt;, 4\u0026lt;int\u0026gt;, 5\u0026lt;str\u0026gt;, 6\u0026lt;obj\u0026gt;, 7\u0026lt;obj\u0026gt;, 8\u0026lt;obj\u0026gt;,\n  Lexical types: 0\u0026lt;obj\u0026gt;, 1\u0026lt;obj\u0026gt;, 2\u0026lt;obj\u0026gt;, 3\u0026lt;obj\u0026gt;, 4\u0026lt;obj\u0026gt;,\n  Lexical names: 0\u0026lt;c\u0026gt;, 1\u0026lt;$¢\u0026gt;, 2\u0026lt;$!\u0026gt;, 3\u0026lt;$/\u0026gt;, 4\u0026lt;$*DISPATCHER\u0026gt;,\n  Lexical map: $!\u0026lt;2\u0026gt;, c\u0026lt;0\u0026gt;, $*DISPATCHER\u0026lt;4\u0026gt;, $¢\u0026lt;1\u0026gt;, $/\u0026lt;3\u0026gt;,\n  Outer: name\u0026lt;\u0026lt;unit\u0026gt;\u0026gt;, cuuid\u0026lt;2\u0026gt;\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e某种不可读的矩阵。星号和桅杆之间有一个阶段性的优化。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; ./rakudo-m --target=optimize ~/test.raku\n[...]\n- QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Op(call \u0026amp;infix:\u0026lt;-\u0026gt;)  :METAOP_opt_result\u0026lt;?\u0026gt;\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(2)  2\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(3)  3\n[...]\n- QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;7\u0026gt; s(:foo(3 Z- 2))\n  - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;8\u0026gt; :before_promotion\u0026lt;?\u0026gt; Z-\n    - QAST::Op(callstatic \u0026amp;METAOP_ZIP) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt;\n      - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt;\n      - QAST::Var(lexical \u0026amp;METAOP_REDUCE_LEFT)\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(3)  3\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(2)  2\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e哈，就是这样。在优化阶段后，行将失踪。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eQAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R-.\u003c/code\u003e\n并将整个 \u003ccode\u003eMETAOP_REVERSE\u003c/code\u003e 调用替换为通常的操作 \u003ccode\u003e(\u0026amp;infix:\u0026lt;-\u0026gt;)\u003c/code\u003e。所以问题一定在优化器的某个地方。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e只有在 \u003ccode\u003eoptim_nameless_call\u003c/code\u003e 方法中才会提到 \u003ccode\u003e\u0026amp;METAOP_ASSIGN\u003c/code\u003e，其中 \u003ccode\u003eQAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;)\u003c/code\u003e。显然，这个操作负责生成一个命名对 - 它已经有了一个名字（命名参数），它需要计算值。从优化 \u003ccode\u003e_\u003c/code\u003e 无名方法的执行路径来看，我们可以得出结论，我们对最后一个块感兴趣。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n  elsif self.op_eq_core($metaop, '\u0026amp;METAOP_REVERSE') {\n    return NQPMu unless nqp::istype($metaop[0], QAST::Var)\n      \u0026amp;\u0026amp; nqp::elems($op) == 3;\n    return QAST::Op.new(:op\u0026lt;call\u0026gt;, :name($metaop[0].name),\n      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;\n  }\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e让我提醒你，优化前的树是这样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n- QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R-\n    - QAST::Op(call \u0026amp;METAOP_REVERSE) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt;\n      - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt;\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e而精简之后，是这样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n- QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Op(call \u0026amp;infix:\u0026lt;-\u0026gt;)  :METAOP_opt_result\u0026lt;?\u0026gt;\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e也就是说，优化 \u003ccode\u003e_nameless_call\u003c/code\u003e 做了以下工作。\u003c/p\u003e\n\u003cp\u003e如果我们的 \u003ccode\u003eQAST::Op+{QAST::SpecialArg}\u003c/code\u003e 操作没有三个参数，如果 \u003ccode\u003eMETAOP_REVERSE\u003c/code\u003e 调用没有一个正确的类型，我们就返回空。这不是我们的情况。\n否则，我们将返回一个新的操作，代替我们的 \u003ccode\u003eQAST::Op+{QAST::SpecialArg}\u003c/code\u003e 操作，以相反的顺序调用 \u003ccode\u003e\u0026amp;infix:\u0026lt;-\u0026gt;\u003c/code\u003e 参数。就是说，把结果打包成一对就没了。\u003c/p\u003e\n\u003cp\u003e在摸索了一下如何解决这个问题，并阅读了 \u003ccode\u003eQAST::SpecialArg\u003c/code\u003e 和 \u003ccode\u003eQAST::Node\u003c/code\u003e 的实现后，我想到了下面的代码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n  elsif self.op_eq_core($metaop, '\u0026amp;METAOP_REVERSE') {\n    return NQPMu unless nqp::istype($metaop[0], QAST::Var)\n      \u0026amp;\u0026amp; nqp::elems($op) == 3;\n    my $opt_result := QAST::Op.new(:op\u0026lt;call\u0026gt;, :name($metaop[0].name),\n      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;\n    if $op.named { $opt_result.named($op.named) } # 添加选项 named \n    if $op.flat { $opt_result.flat($op.flat) }    # 添加选项 flat\n    return $opt_result;\n  }\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e还有木头。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n- QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Op+{QAST::SpecialArg}(call \u0026amp;infix:\u0026lt;-\u0026gt; :named\u0026lt;foo\u0026gt;)  :METAOP_opt_result\u0026lt;?\u0026gt;\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e命名的参数返回到它的位置。测试也开始通过。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; make t/spec/S03-metaops/reverse.t\n[...]\nAll tests successful.\nFiles=1, Tests=70,  3 wallclock secs ( 0.03 usr  0.01 sys +  3.61 cusr  0.17 csys =  3.82 CPU)\nResult: PASS\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们本可以就此打住，但这是编译器优化器的代码，它的结果是一个有两个整数参数的方法调用。我认为这在某种程度上是次优的。如果我们将返回表达式改为返回 \u003ccode\u003eself.visit_op: $opt_result;\u003c/code\u003e，对产生的非优化操作调用优化器，那么产生的树就会像这样。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n- QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Want+{QAST::SpecialArg}(:named\u0026lt;foo\u0026gt;)\n    - QAST::WVal+{QAST::SpecialArg}(Int :named\u0026lt;foo\u0026gt;)\n    - QAST::IVal(-1)\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在一切都很理想。\u003c/p\u003e\n\u003ch2 id=\"分享成果\"\u003e分享成果\u003c/h2\u003e\n\u003cp\u003e我们已经到了终点线。现在我们只需要分享我们的经验。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e重要的是：运行所有的 \u003ccode\u003emake spectest\u003c/code\u003e 测试，确保没有新的东西被破坏。\u003c/li\u003e\n\u003cli\u003e在 GitHub 上使用 Rakudo 编译器和测试制作 fork 仓库。\u003c/li\u003e\n\u003cli\u003e将 fork 仓库添加为新的 git 远程仓库。\u003c/li\u003e\n\u003cli\u003ecd ~/dev-rakudo/rakudo \u0026amp;\u0026amp; git remote add fork \u003c!-- raw HTML omitted --\u003e。\u003c/li\u003e\n\u003cli\u003ecd ~/dev-rakudo/t/spec \u0026amp;\u0026amp; git remote add fork \u003c!-- raw HTML omitted --\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e重要：确保两个仓库在 git 中都有正确的用户名和用户邮箱。\u003c/p\u003e\n\u003cp\u003e提交到两个版本库，详细说明你为什么做了哪些改动，并添加对原始问题跟踪器的引用。\u003c/p\u003e\n\u003cp\u003e运行提交。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecd ~/dev-rakudo/rakudo \u0026amp;\u0026amp; git push fork\ncd ~/dev-rakudo/t/spec \u0026amp;\u0026amp; git push fork\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e向两个仓库提出拉取请求。在他们的描述中，最好是相互参照和原任务。\u003c/p\u003e\n\u003ch2 id=\"结论\"\u003e结论\u003c/h2\u003e\n\u003cp\u003e对开源软件的贡献是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e趣味性和趣味性。\u003c/li\u003e\n\u003cli\u003e给你的感觉是，你正在做一些有用的事情，你真的是。\u003c/li\u003e\n\u003cli\u003e让你认识新的有趣和专业的人（任何关于 Raku 的问题都会在 \u003ccode\u003e#raku IRC\u003c/code\u003e 频道中得到回答）。\u003c/li\u003e\n\u003cli\u003e解决非标准任务，没有截止日期的压力，是一种很好的体验。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e选择你觉得最舒服的角色等级，去做新的任务吧!\u003c/p\u003e\n","text":"在过去的几周里，我看到了一些文章和视频，讲述了在开源软件中构思是多么的伟大。这次我又想起了另一篇旧文Raku 是我的 MMORPG。它说，你可以从以下几个方面受益于开源软件。比如说，可以做一个大侠，基于一些开源软件来写软件。作为写手，可以写博客、微博等，对所选软件产生兴趣。或者你可以成为一个法师 - 实现新的功能和修复 bug。今天小编就带着弓箭手来告诉大家如何成为 Raku 编程语言的法师。\n选择一个任务 让我们挑选一些编译器的 bug，并修复它。让我们去 Rakudo 编译器 issues中选择我们想要修复的 bug。我滚动了一下 bug 列表，遇到了解析 - 运气不错，我前段时间一直在研究编译器语法，看了一本这方面的好书。找到了四个问题。\n 标签为 LTA （Less Than Awesome - 当真实行为与直觉预期不同时）- 我们暂时把它划掉。 标签 \u0026ldquo;需要共识\u0026rdquo; - 我们只想修复一个不复杂的 bug - 肯定要划掉。 标签为 \u0026ldquo;grammar and actions\u0026rdquo; 的关于一个可能死的代码是一个很好的候选人的第一个任务。  任务确定后，现在我们需要配置工作环境。在 Windows、Linux 和 macOS 中，一切应该都差不多。我将通过 macOS 的例子来告诉你。\n建立工作环境 为源码和我们建立的编译器建立文件夹。\nmkdir ~/dev-rakudo \u0026amp;\u0026amp; mkdir ~/dev-rakudo-install Rakudo 编译器由三部分组成。\n 虚拟机。现在有三种 - JVM、JS 和 MoarVM。我们以 MoarVM 为最稳定的一个。 NQP（Not Quite Perl），是一种低级（中级）语言的实现，它是 Raku 的一个 \u0026ldquo;子集\u0026rdquo;。虚拟机可以执行用 NQP 编写的代码。 Rakudo 编译器本身，用 NQP 和 Raku 编写。  下载并编译这三个组件。我分别花了一分半钟、半分钟和两分半钟才编好。\ncd ~/dev-rakudo \u0026amp;\u0026amp; git clone git@github.com:MoarVM/MoarVM.git \u0026amp;\u0026amp; cd MoarVM perl Configure.pl --prefix ~/dev-rakudo-install \u0026amp;\u0026amp; make -j 4 \u0026amp;\u0026amp; make install cd ~/dev-rakudo \u0026amp;\u0026amp; git clone git@github.com:Raku/nqp.git \u0026amp;\u0026amp; cd nqp perl Configure.pl --backend=moar --prefix ~/dev-rakudo-install \u0026amp;\u0026amp; make -j 4 \u0026amp;\u0026amp; make install cd ~/dev-rakudo \u0026amp;\u0026amp; git clone git@github.com:rakudo/rakudo.git \u0026amp;\u0026amp; cd rakudo perl Configure.pl --backend=moar --prefix ~/dev-rakudo-install \u0026amp;\u0026amp; make -j 4 \u0026amp;\u0026amp; make install 注意参数。--prefix 显示了 make install 命令后可执行文件的复制位置，--backend=moar 表示正在使用的虚拟机，而 -j 4 则要求跨多线程并行化（以防加快进度）。现在我们已经建立了 Rakudo 编译器 ~/dev-rakudo-install/bin/raku。我们还需要官方的编译器测试套件。你应该把它和它的代码一起放在文件夹里。\ncd ~/dev-rakudo/rakudo \u0026amp;\u0026amp; git clone https://github.com/Raku/roast.git t/spec 我们先进行测试。这种情况很常见，有些测试甚至在新的变化之前就失败了。我们需要辨别出来，这样以后就不会害怕这些变化破坏了一些不必要的东西。\n这里和下面我将在 ~/dev-rakudo/rakudo 文件夹中工作，除非另有说明。\n\u0026gt; make spectest [...] Test Summary Report ------------------- t/spec/S32-str/utf8-c8.t (Wstat: 65280 Tests: 54 Failed: 0) Non-zero exit status: 255 Parse errors: Bad plan. You planned 66 tests but ran 54. Files=1346, Tests=117144, 829 wallclock secs (27.70 usr 6.04 sys + 2638.79 cusr 210.98 csys = 2883.51 CPU) Result: FAIL make: *** [m-spectest5] Error 1 14分钟内共运行了1,346个文件中的117,144次测试。一些与utf8相关的测试由于某种原因失败了，其他的都能正常工作。我们已经准备好去工作了!\n让我们来看看问题的陈述 问题陈述说，某个元运算符 R 在 colonpair 上出了问题。我打开文档，搜索 R 这个词，但下拉列表中没有这个名字的元运算符。我试着输入 metaop，看到的是反向元操作符(R)。原来，如果你想把二元运算的操作数按相反的顺序写出来，你可以在其符号前使用前缀 R。\nsay 3 R- 2 == -1 # Output: True Colonpair 是命名对的语法。它看起来就像名字前面有一个冒号，前面有一个括号，有一个值。例如 :foo(42) 是一个名称为 foo、值为 42 的对儿。这个语法通常用于在调用函数时，向函数传递一个命名参数中的值。\nsub sub-with-named-parameter(:$foo) { say $foo; } sub-with-named-parameter(:foo(42)); # Output: 42 如果一个函数参数不是命名的，而是位置的，那么在用命名对调用时，就会出现编译错误。\nsub sub-without-named-parameter($foo) { # \u0026lt;- 没有冒号 say $foo; } sub-without-named-parameter(:foo(42)); # Unexpected named argument \u0026#39;foo\u0026#39; passed 如果你在调用这样的函数时用括号包围一个参数，整个参数对将被传递到位置参数。\nsub sub-without-named-parameter($foo) { say $foo; } sub-without-named-parameter((:foo(42))); # Output: foo =\u0026gt; 42 在 Raku 中，你可以写一个函数来捕获所有传递给它的参数并分析它们。这是在单个参数 - 捕获前用竖线完成的。\nsub sub-with-capture(|foo) { # \u0026lt;- 参数捕获 say foo; } sub-with-capture(:foo(42)); # Output: \\(:foo(42)) sub-with-capture(42); # Output: \\(42) sub-with-capture(:foo(3 Z- 2)); # Output: \\(:foo((1,).Seq)) sub-with-capture(:foo(3 R- 2)); # Output: \\(-1) 倒数第二行使用了 Z 元操作符 - zip 操作符。它将左右两部分作为一个列表，按顺序每次从它们中抽取一个元素，并进行操作，从而形成一个序列。\n在最后一行，只用了我们需要的 R 元操作符。在这种情况下，它不是一个对，而是一个常量，它被传递到函数中。我们可以假设这是元运算符工作方式的一些特殊性，但用 Z 的例子表明并非如此。其实这是一个 bug - 当一个对被传递到一个使用 R 元运算符的函数中时，它的值会被转换。\n我们需要一个新的测试 为了确保未来的变化能够修复错误的行为，我们需要写一个新的测试。在测试文件中不难找到 R 元操作符的测试（S03-metops/reverse.t）。下面我将补充以下测试。\n# https://github.com/rakudo/rakudo/issues/1632 { sub subroutine($expected, |actual) { is actual.gist, $expected, \u0026#34;Сolonpair exists\u0026#34; } subroutine(\u0026#39;\\(:foo(-1))\u0026#39;, :foo(3 R- 2)); } 该测试有一个功能，有两个参数 - 正常和捕获。在函数体中，第一个参数和传递的 Capture 的字符串表示进行比较。你可以使用 make 对新构建的编译器进行单独测试。\n\u0026gt; make t/spec/S03-metaops/reverse.t [...] ok 69 - [R~]= not ok 70 - Colonpair exists # Failed test 'Colonpair exists' # at t/spec/S03-metaops/reverse.t line 191 # expected: '\\(:foo(-1))' # got: '\\(-1)' # You planned 69 tests, but ran 70 # You failed 1 test of 70 你可以看到，测试失败了（如预期）。还有一个单独的说明，系统预计69次测试，但收到70次。这是基于 TAP 的测试系统的特点 - 必须在文件的顶部修正传递给 plan 函数的数字。现在测试崩溃了，但编号没有受到影响。你可以开始修复它。\n凝视法 一开始我很相信任务上的标签 - 如果是解析的话，一定是源码解析阶段的某个地方出现了问题。目前我的认识如下：\n 基础解析器代码在文件 rakudo/src/Perl6/Grammar.nqp 中。 这个解析器是从 nqp/src/HLL/Grammar.nqp 文件中的基础解析器继承的。 元操作符的解析和工作方式都差不多，你可以通过仔细观察来发现不同之处。  我在基础解析器代码中找到了对元操作符的引用。\ntoken infix_prefix_meta_operator:sym\u0026lt;R\u0026gt; {\u0026lt;sym\u0026gt;\u0026lt;infixish(\u0026#39;R\u0026#39;)\u0026gt;{}\u0026lt;.can_meta($\u0026lt;infixish\u0026gt;, \u0026#34;reverse the args of\u0026#34;)\u0026gt;\u0026lt;O=.revO($\u0026lt;infixish\u0026gt;)\u0026gt;} token infix_prefix_meta_operator:sym\u0026lt;Z\u0026gt; {\u0026lt;sym\u0026gt;\u0026lt;infixish(\u0026#39;Z\u0026#39;)\u0026gt;{}\u0026lt;.can_meta($\u0026lt;infixish\u0026gt;, \u0026#34;zip with\u0026#34;)\u0026gt;\u0026lt;O(|%list_infix)\u0026gt;} 这需要对 Raku grammar 有一定的了解。据我所知，原来这两个元运算符在解析上并没有根本的区别。一段时间后，在解析器的源代码中挖得够多了，我开始怀疑解析工作是否正确。认为代码 my $r = :foo(3 R- 2); say $r; # Output: foo =\u0026gt; -1 正确工作的建议 - 问题恰恰发生在调用函数时。显然，我白白相信了任务栏上的标签。\n编译器将帮助我们 颇为迟钝的我想起了我从一开始就应该做的事情。Rakudo 编译器有 --target 调试开关。它取编译器阶段的名称，你想将其结果输出到控制台并退出。我想看看 --target=parse（因为我只知道这一个）。\n我从 ~/dev-rakudo/rakudo 文件夹中使用 rakumo-m，这样我就不必等待通过 make install 命令将所需文件复制到 ~/dev-rakudo-install。简单的脚本可以这样运行。更复杂的脚本必须在 make install 之后从 -install 中运行。\n\u0026gt; cat ~/test.raku sub s(|c) { say c } s(:foo(3 R- 2)); s(:foo(3 Z- 2)); \u0026gt; ./rakudo-m --target=parse ~/test.raku [...] - args: (:foo(3 R- 2)) - semiarglist: :foo(3 R- 2) - arglist: 1 matches - EXPR: :foo(3 R- 2) - colonpair: :foo(3 R- 2) - identifier: foo - coloncircumfix: (3 R- 2) - circumfix: (3 R- 2) - semilist: 3 R- 2 - statement: 1 matches - EXPR: R- 2 [...] - args: (:foo(3 Z- 2)) - semiarglist: :foo(3 Z- 2) - arglist: 1 matches - EXPR: :foo(3 Z- 2) - colonpair: :foo(3 Z- 2) - identifier: foo - coloncircumfix: (3 Z- 2) - circumfix: (3 Z- 2) - semilist: 3 Z- 2 - statement: 1 matches - EXPR: Z- 2 [...] 结论：R 和 Z 的解析是一样的。\n这不是解析 所有被解析的东西都会被传递给所谓的 Action，把字词变成一棵语法树。在我们的例子中，Actions 位于文件 rakudo/src/Perl6/Actions.nqp 和 nqp/src/HLL/Actions.nqp 中。这里就比较容易搞清楚了，毕竟是代码，是 grammar。\n我在主 Actions 中找到了以下代码。\n[...] elsif $\u0026lt;infix_prefix_meta_operator\u0026gt; { [...] if $metasym eq 'R' { $helper := '\u0026amp;METAOP_REVERSE'; $t := nqp::flip($t) if $t; } elsif $metasym eq 'X' { $helper := '\u0026amp;METAOP_CROSS'; $t := nqp::uc($t); } elsif $metasym eq 'Z' { $helper := '\u0026amp;METAOP_ZIP'; $t := nqp::uc($t); } my $metapast := QAST::Op.new( :op\u0026lt;call\u0026gt;, :name($helper), WANTED($basepast,'infixish') ); $metapast.push(QAST::Var.new(:name(baseop_reduce($base\u0026lt;OPER\u0026gt;\u0026lt;O\u0026gt;.made)), :scope\u0026lt;lexical\u0026gt;)) if $metasym eq 'X' || $metasym eq 'Z'; [...] 它说，如果在代码中解析了元操作符 R、Z 或 X，就应该在语法树中添加一些 METAOP_ 函数调用。在 Z 和 X 的情况下，它会多一个参数，即某种还原函数。所有这些功能都可以在 rakudo/src/core.c/metaops.pm6 中找到。\nsub METAOP_REVERSE(\\op) is implementation-detail { -\u0026gt; |args { op.(|args.reverse) } } sub METAOP_ZIP(\\op, \u0026amp;reduce) is implementation-detail { nqp::if(op.prec(\u0026#39;thunky\u0026#39;).starts-with(\u0026#39;.\u0026#39;), -\u0026gt; +lol { my $arity = lol.elems; [...] }, -\u0026gt; +lol { Seq.new(Rakudo::Iterator.ZipIterablesOp(lol,op)) } ) } 给你：\n \\op 是由我们的元操作符，即-，在前面的操作。 Trait implementation-detail 只是表明这不是公共代码，是编译器实现的一部分。 由于-操作没有笨重的特性，所以 \u0026amp;reduce 函数不会参与计算，Z 的结果是 Seq.new(...)。 R 的结果是一个操作调用 - 参数顺序相反。  这时我想起还有一个 - 目标，即星。它将显示行动的结果。\n\u0026gt; ./rakudo-m --target=ast ~/test.raku [...] - QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R- - QAST::Op(call \u0026amp;METAOP_REVERSE) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt; - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt; - QAST::Want \u0026lt;wanted\u0026gt; 3 - QAST::WVal(Int) - Ii - QAST::IVal(3) 3 - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::WVal(Int) - Ii - QAST::IVal(2) 2 [...] - QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;7\u0026gt; s(:foo(3 Z- 2)) - QAST::Op+{QAST::SpecialArg}(:named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;8\u0026gt; :before_promotion\u0026lt;?\u0026gt; Z- - QAST::Op(call \u0026amp;METAOP_ZIP) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt; - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt; - QAST::Var(lexical \u0026amp;METAOP_REDUCE_LEFT) - QAST::Want \u0026lt;wanted\u0026gt; 3 - QAST::WVal(Int) - Ii - QAST::IVal(3) 3 - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::WVal(Int) - Ii - QAST::IVal(2) 2 [...] 一如所料。除了调用不同的 METAOP_ 函数外，所有的东西几乎都是一样的。从它们的代码中我们可以知道，原则上这些函数的不同之处在于返回值的类型 - 分别是 Int 和 Seq。众所周知，Raku 对不同类型的对象的上下文相当敏感\u0026hellip;\u0026hellip;我想，它关注的可能是返回值。我试着用下面的方式修改代码。\nsub METAOP_REVERSE(\\op) is implementation-detail { -\u0026gt; |args { Seq.new(op.(|args.reverse)) } } 编译、运行。\n\u0026gt; make [...] Stage start : 0.000 Stage parse : 61.026 Stage syntaxcheck: 0.000 Stage ast : 0.000 Stage optimize : 7.076 Stage mast : 14.120 Stage mbc : 3.941 [...] \u0026gt; ./rakudo-m ~/test.raku \\(-1) \\(:foo((1,).Seq)) 一切都没有改变。所以，不是返回值\u0026hellip;\u0026hellip;想了想，不知道为什么结果又是 -1 而不是 (-1,).Seq。而且，从代码来看，Seq 根本就没有一个合适的构造函数。下一次，作为一些疯狂的事情，我尝试调用 METAOP_REVERSE 结果只是为了崩溃。\nsub METAOP_REVERSE(\\op) is implementation-detail { -\u0026gt; |args { die } } 编译、运行。\n\u0026gt; make [...] \u0026gt; ./rakudo-m ~/test.raku \\(-1) \\(:foo((1,).Seq)) 怎么会呢？语法树中包含了对 METAOP_REVERSE 的调用，它的代码应该是折叠的，但计算仍然进行，我们得到 -1。\n这些都不是《行动》。\n这里我的目光落在编译器的构建日志上。它是一些阶段被列在那里。我随机试了 --target=mast。\n\u0026gt; ./rakudo-m --target=mast ~/test.raku [...] MAST::Frame name\u0026lt;s\u0026gt;, cuuid\u0026lt;1\u0026gt; Local types: 0\u0026lt;obj\u0026gt;, 1\u0026lt;obj\u0026gt;, 2\u0026lt;obj\u0026gt;, 3\u0026lt;obj\u0026gt;, 4\u0026lt;int\u0026gt;, 5\u0026lt;str\u0026gt;, 6\u0026lt;obj\u0026gt;, 7\u0026lt;obj\u0026gt;, 8\u0026lt;obj\u0026gt;, Lexical types: 0\u0026lt;obj\u0026gt;, 1\u0026lt;obj\u0026gt;, 2\u0026lt;obj\u0026gt;, 3\u0026lt;obj\u0026gt;, 4\u0026lt;obj\u0026gt;, Lexical names: 0\u0026lt;c\u0026gt;, 1\u0026lt;$¢\u0026gt;, 2\u0026lt;$!\u0026gt;, 3\u0026lt;$/\u0026gt;, 4\u0026lt;$*DISPATCHER\u0026gt;, Lexical map: $!\u0026lt;2\u0026gt;, c\u0026lt;0\u0026gt;, $*DISPATCHER\u0026lt;4\u0026gt;, $¢\u0026lt;1\u0026gt;, $/\u0026lt;3\u0026gt;, Outer: name\u0026lt;\u0026lt;unit\u0026gt;\u0026gt;, cuuid\u0026lt;2\u0026gt; [...] 某种不可读的矩阵。星号和桅杆之间有一个阶段性的优化。\n\u0026gt; ./rakudo-m --target=optimize ~/test.raku [...] - QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Op(call \u0026amp;infix:\u0026lt;-\u0026gt;) :METAOP_opt_result\u0026lt;?\u0026gt; - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::WVal(Int) - Ii - QAST::IVal(2) 2 - QAST::Want \u0026lt;wanted\u0026gt; 3 - QAST::WVal(Int) - Ii - QAST::IVal(3) 3 [...] - QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;7\u0026gt; s(:foo(3 Z- 2)) - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;8\u0026gt; :before_promotion\u0026lt;?\u0026gt; Z- - QAST::Op(callstatic \u0026amp;METAOP_ZIP) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt; - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt; - QAST::Var(lexical \u0026amp;METAOP_REDUCE_LEFT) - QAST::Want \u0026lt;wanted\u0026gt; 3 - QAST::WVal(Int) - Ii - QAST::IVal(3) 3 - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::WVal(Int) - Ii - QAST::IVal(2) 2 [...] 哈，就是这样。在优化阶段后，行将失踪。\n QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R-. 并将整个 METAOP_REVERSE 调用替换为通常的操作 (\u0026amp;infix:\u0026lt;-\u0026gt;)。所以问题一定在优化器的某个地方。  只有在 optim_nameless_call 方法中才会提到 \u0026amp;METAOP_ASSIGN，其中 QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;)。显然，这个操作负责生成一个命名对 - 它已经有了一个名字（命名参数），它需要计算值。从优化 _ 无名方法的执行路径来看，我们可以得出结论，我们对最后一个块感兴趣。\n[...] elsif self.op_eq_core($metaop, '\u0026amp;METAOP_REVERSE') { return NQPMu unless nqp::istype($metaop[0], QAST::Var) \u0026amp;\u0026amp; nqp::elems($op) == 3; return QAST::Op.new(:op\u0026lt;call\u0026gt;, :name($metaop[0].name), $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1; } [...] 让我提醒你，优化前的树是这样的。\n[...] - QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R- - QAST::Op(call \u0026amp;METAOP_REVERSE) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt; - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt; - QAST::Want \u0026lt;wanted\u0026gt; 3 - QAST::Want \u0026lt;wanted\u0026gt; 2 [...] 而精简之后，是这样的。\n[...] - QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Op(call \u0026amp;infix:\u0026lt;-\u0026gt;) :METAOP_opt_result\u0026lt;?\u0026gt; - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::Want \u0026lt;wanted\u0026gt; 3 [...] 也就是说，优化 _nameless_call 做了以下工作。\n如果我们的 QAST::Op+{QAST::SpecialArg} 操作没有三个参数，如果 METAOP_REVERSE 调用没有一个正确的类型，我们就返回空。这不是我们的情况。 否则，我们将返回一个新的操作，代替我们的 QAST::Op+{QAST::SpecialArg} 操作，以相反的顺序调用 \u0026amp;infix:\u0026lt;-\u0026gt; 参数。就是说，把结果打包成一对就没了。\n在摸索了一下如何解决这个问题，并阅读了 QAST::SpecialArg 和 QAST::Node 的实现后，我想到了下面的代码。\n[...] elsif self.op_eq_core($metaop, '\u0026amp;METAOP_REVERSE') { return NQPMu unless nqp::istype($metaop[0], QAST::Var) \u0026amp;\u0026amp; nqp::elems($op) == 3; my $opt_result := QAST::Op.new(:op\u0026lt;call\u0026gt;, :name($metaop[0].name), $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1; if $op.named { $opt_result.named($op.named) } # 添加选项 named if $op.flat { $opt_result.flat($op.flat) } # 添加选项 flat return $opt_result; } [...] 还有木头。\n[...] - QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Op+{QAST::SpecialArg}(call \u0026amp;infix:\u0026lt;-\u0026gt; :named\u0026lt;foo\u0026gt;) :METAOP_opt_result\u0026lt;?\u0026gt; - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::Want \u0026lt;wanted\u0026gt; 3 [...] 命名的参数返回到它的位置。测试也开始通过。\n\u0026gt; make t/spec/S03-metaops/reverse.t [...] All tests successful. Files=1, Tests=70, 3 wallclock secs ( 0.03 usr 0.01 sys + 3.61 cusr 0.17 csys = 3.82 CPU) Result: PASS 我们本可以就此打住，但这是编译器优化器的代码，它的结果是一个有两个整数参数的方法调用。我认为这在某种程度上是次优的。如果我们将返回表达式改为返回 self.visit_op: $opt_result;，对产生的非优化操作调用优化器，那么产生的树就会像这样。\n[...] - QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Want+{QAST::SpecialArg}(:named\u0026lt;foo\u0026gt;) - QAST::WVal+{QAST::SpecialArg}(Int :named\u0026lt;foo\u0026gt;) - QAST::IVal(-1) [...] 现在一切都很理想。\n分享成果 我们已经到了终点线。现在我们只需要分享我们的经验。\n 重要的是：运行所有的 make spectest 测试，确保没有新的东西被破坏。 在 GitHub 上使用 Rakudo 编译器和测试制作 fork 仓库。 将 fork 仓库添加为新的 git 远程仓库。 cd ~/dev-rakudo/rakudo \u0026amp;\u0026amp; git remote add fork 。 cd ~/dev-rakudo/t/spec \u0026amp;\u0026amp; git remote add fork 。  重要：确保两个仓库在 git 中都有正确的用户名和用户邮箱。\n提交到两个版本库，详细说明你为什么做了哪些改动，并添加对原始问题跟踪器的引用。\n运行提交。\ncd ~/dev-rakudo/rakudo \u0026amp;\u0026amp; git push fork cd ~/dev-rakudo/t/spec \u0026amp;\u0026amp; git push fork 向两个仓库提出拉取请求。在他们的描述中，最好是相互参照和原任务。\n结论 对开源软件的贡献是：\n 趣味性和趣味性。 给你的感觉是，你正在做一些有用的事情，你真的是。 让你认识新的有趣和专业的人（任何关于 Raku 的问题都会在 #raku IRC 频道中得到回答）。 解决非标准任务，没有截止日期的压力，是一种很好的体验。  选择你觉得最舒服的角色等级，去做新的任务吧!\n"},"name":"为最年轻的 Raku 贡献力量","published":"2021-02-16T00:00:00+08:00","summary":"Contributing to Raku","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/"}