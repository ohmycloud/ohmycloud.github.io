{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"content":{"html":"\u003ch1 id=\"self-describing-code\"\u003eSelf-describing code\u003c/h1\u003e\n\u003ch2 id=\"junctions\"\u003eJunctions\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eDistributive\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e%hash{any(@keys)}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e等价于:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eany(%hash{@keys})\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eBoolean\u003c/li\u003e\n\u003c/ul\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e类型\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e操作符\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003eTrue if \u0026hellip;\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eany\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e|\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e至少一个值为真\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eall\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u0026amp;\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e所有值都为真\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eone\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e^\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e只有一个值为真\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003enone\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e值都不为真\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eJunctions 通常出现在布尔上下文中。例如, 在下面的例子中, \u003ccode\u003e$value\u003c/code\u003e 和几个值进行相等性比较。很容易写出这样的代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif $value == 1 || $value == 2 || $value == 5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e使用 \u003ccode\u003eany\u003c/code\u003e Junction 会简洁不少:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif $value == any(1, 2, 5)\nif $value == (1,2,4).any\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e惯用法是使用 \u003ccode\u003e|\u003c/code\u003e 操作符号来进行多值比较:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif $value == 1|2|5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e找出数组中满足条件的第一个元素, 我们首先想到的可能是, 使用 \u003ccode\u003efor\u003c/code\u003e 循环迭代数组, 找出满足条件的元素就立即退出循环:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $result = False;\n\nfor @values -\u0026gt; $value {\n    if $value \u0026gt; 42 {\n        $result = True;\n        last;\n    }\n}\n\nif $result { ... }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e改用 Junction 后等价于:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif any(@values) \u0026gt; 42 { ... }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e还可以在 Junction 上调用方法或运算符:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif one(@values).is-prime { ... }\nif all(@values) %% 3 { ... }\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"named-arguments命名参数\"\u003eNamed arguments(命名参数)\u003c/h2\u003e\n\u003cp\u003eColonpair(冒号对儿) 通常用于命名参数中:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e:foo(42)\nfoo =\u0026gt; 42\n\nsub bar(:$foo) {\n    say $foo;\n}\n\nbar(:foo(42));\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e有几种特殊形式的冒号对儿:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e:foo\n:foo(True)\n\n:!foo\n:foo(False)\n\n:foo\u0026lt;bar\u0026gt;\n:foo(\u0026quot;bar\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e:foo\u003c/code\u003e 与 \u003ccode\u003efoo =\u0026gt; True\u003c/code\u003e 相同, \u003ccode\u003e:!foo\u003c/code\u003e 等价于 \u003ccode\u003efoo =\u0026gt; False\u003c/code\u003e。\u003ccode\u003e:foo\u0026lt;bar\u0026gt;\u003c/code\u003e 使用了一组尖括号引起了值, 值在尖括号中不进行插值。\u003c/p\u003e\n\u003cp\u003e来看一个命名参数例子, 下面的代码遍历 \u003ccode\u003e@dirs\u003c/code\u003e 中的目录, 找出后缀名为 txt 且不为空的文件:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003efor find(@dirs, :file, :ext\u0026lt;txt\u0026gt;, :!empty) -\u0026gt; $file {\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e冒号对儿的值可以是变量, 但是在圆括号中再写一遍变量名就显得啰嗦:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003efoo(:bar($bar), :baz($baz), :quz($quz))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e因此, 冒号对儿提供了一种简写形式, 如果冒号后面紧跟着 \u003ccode\u003e$\u003c/code\u003e、\u003ccode\u003e@\u003c/code\u003e、\u003ccode\u003e%\u003c/code\u003e 和 \u003ccode\u003e\u0026amp;\u003c/code\u003e 等符号, 那么冒号对儿的值就是 \u003ccode\u003e$sth\u003c/code\u003e、\u003ccode\u003e@sth\u003c/code\u003e、\u003ccode\u003e%sth\u003c/code\u003e 和 \u003ccode\u003e\u0026amp;sth\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003efoo(:$bar, :$baz, :$quz)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这种简写形式消除了命名参数的重复。\u003c/p\u003e\n\u003ch2 id=\"pointy-blocks尖号块儿\"\u003ePointy blocks(尖号块儿)\u003c/h2\u003e\n\u003cp\u003eAll blocks are \u003cstrong\u003eCallable\u003c/strong\u003e, 即所有的块儿都是可调用的。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efor\u003c/code\u003e blocks\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003e-\u0026gt; $elem { ...}\u003c/code\u003e 就是尖号块儿:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003efor @array -\u0026gt; $elem {\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003efor\u003c/code\u003e 循环依次把 \u003ccode\u003e@array\u003c/code\u003e 中的每个元素赋值给尖号块儿中的 \u003ccode\u003e$elem\u003c/code\u003e 变量, 然后执行尖号块儿的主体。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOrdering\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如果 \u003ccode\u003efoo\u003c/code\u003e 例程有返回值且不为假, 则赋值给 \u003ccode\u003e$value\u003c/code\u003e, 然后执行块儿的主体:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif my $value = foo() { ... }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e但是上面的语句在 Raku  中是不合法的, 要使用尖号块儿的方式:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif foo() -\u0026gt; $value { ... }\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"signatures签名\"\u003eSignatures(签名)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003efor\u003c/code\u003e 循环可以一次迭代两个(或多个)元素。尖号块儿相当于匿名函数, 其中的 \u003ccode\u003e$first, $second\u003c/code\u003e 就是尖号块儿的签名。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003efor @array -\u0026gt; $first, $second {\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e下面的智能匹配中, 变量 \u003ccode\u003e$1\u003c/code\u003e 和 \u003ccode\u003e$2\u003c/code\u003e 有些多余:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif / (\\S+) \\s+ (.*) / { \n    my $name = $1;\n    my $value = $2;\n    ...\n }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通过尖号块儿, 把匹配结果直接赋值给 \u003ccode\u003e$name\u003c/code\u003e 和 \u003ccode\u003e$value\u003c/code\u003e, 节省了两个变量名:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif / (\\S+) \\s+ (.*) / -\u0026gt; ($name, $value) {\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003efor\u003c/code\u003e 尖号块儿和 \u003ccode\u003eif\u003c/code\u003e 尖号块儿的结构类似, 语法上非常整齐:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003efor expression() -\u0026gt; $value { ... }\nif expression() -\u0026gt; $value { ... }\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"whatever-code\"\u003eWhatever code\u003c/h2\u003e\n\u003cp\u003e如果 grep 的过滤条件中有多个变量, 那么使用尖号块儿这种匿名函数比较合适:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e@numbers.grep(-\u0026gt; $n { $n \u0026gt; 2 });\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果过滤条件中只有一个变量, 那么形式更短的 Whatever code 更符合惯用法:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e@numbers.grep(* \u0026gt; 2);\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"meta-operators\"\u003eMeta-operators\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eReduction\u003c/li\u003e\n\u003cli\u003eZip\u003c/li\u003e\n\u003cli\u003eCorss\u003c/li\u003e\n\u003cli\u003eHyper\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eReduction meta operators\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efold/reduce an infix operator\u003c/li\u003e\n\u003cli\u003eRespects associativity\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ereduce\u003c/code\u003e 运算符可以用于求和:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $sum = reduce { $^a + $^b }, @list;\nmy $sum = [+] @list\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e[+]   # sum\n[*]   # product\n[~]   # join\n[===] # all equal\n[\u0026lt;\u0026gt;]  # ascending order\n[||]  # first true value, if any\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eZip 元运算符用于连接列表:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e(1, 2, 3) Z+ (30, 20 ,10)\n# (21, 22, 13)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e-\u0026gt; ($a, $b)\u003c/code\u003e 解构 Zip 后的元素:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003efor @a Z @b -\u0026gt; ($a, $b) {\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eZ=\u0026gt;\u003c/code\u003e 运算符通常用于从两个列表中制作哈希:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e%hash = @keys Z=\u0026gt; @values\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eZip 元运算符可以写成链式的:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e@a Z @b Z @c\n[Z] @list-of-lists\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCross 是交叉运算符。使用两层 for 循环也可以实现交叉运算符的功能, 就是代码稍长:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003egather for 3, 9 -\u0026gt; $i {\n    for 2, 10 -\u0026gt; $j {\n        take $i + $j\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e而使用交叉运算符, 一行代码搞定:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e3, 9 X+ 2, 10\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e添加前缀也很简单:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u0026quot;prefix-\u0026quot; X~ @list\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHyper 运算符可以把任何运算符(中缀、前缀和后缀等)应用到列表上:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e@list».abs\n@list.map(*.abs)\n\n!«@list\n@list.map(!*)\n\n@list»[1]\n@list.map(*[1])\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e欧几里得距离:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e@a Z- @b\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSquared(平方)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e(@a Z- @b)»²\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSummed(求和)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e[+] (@a Z- @b)»²\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSquare root(求平方根)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esqrt [+] (@a Z- @b)»²\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"smartmatch智能匹配\"\u003eSmartmatch(智能匹配)\u003c/h2\u003e\n\u003cp\u003e“Is the value part of this set”\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e@list.grep(* \u0026gt; 2)\n@list.grep({ $_ eq \u0026quot;foo\u0026quot; })\n@list.grep(Int)\n@list.grep({ .isa(Innt) })\n@list.grep(/foo .* bar/)\n@list.grep({ .match(/foo .* bar/) })\n@list.grep(2..4)\n@list.grep({ 2 \u0026lt;= $_ \u0026lt;= 4 })\n\n@list.grep(:is-prime)\n@list.grep({ .is-prime })\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ecombine junctions(结合 Junctions):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e@list.grep(:is-prime \u0026amp; /22/)\n@list.grep({ .is-prime \u0026amp;\u0026amp; .matches(/22/) })\n\n@list.grep(none(/22/))\n@list.grep({ !.matches(/22/) })\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后, 还是查找文件的例子:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003efind(@dirs,\n  :ext('rakumo'|'pm6'),\n  :size(* \u0026gt; 1024),\n  :depth(3..5),\n  :contains(/raku/)\n);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e原文链接: \u003ca href=\"https://www.youtube.com/watch?v=elalwvfmYgk\"\u003ehttps://www.youtube.com/watch?v=elalwvfmYgk\u003c/a\u003e\u003c/p\u003e\n","text":"Self-describing code Junctions  Distributive  %hash{any(@keys)} 等价于:\nany(%hash{@keys})  Boolean     类型 操作符 True if \u0026hellip;     any | 至少一个值为真   all \u0026amp; 所有值都为真   one ^ 只有一个值为真   none  值都不为真    Junctions 通常出现在布尔上下文中。例如, 在下面的例子中, $value 和几个值进行相等性比较。很容易写出这样的代码:\nif $value == 1 || $value == 2 || $value == 5 使用 any Junction 会简洁不少:\nif $value == any(1, 2, 5) if $value == (1,2,4).any 惯用法是使用 | 操作符号来进行多值比较:\nif $value == 1|2|5 找出数组中满足条件的第一个元素, 我们首先想到的可能是, 使用 for 循环迭代数组, 找出满足条件的元素就立即退出循环:\nmy $result = False; for @values -\u0026gt; $value { if $value \u0026gt; 42 { $result = True; last; } } if $result { ... } 改用 Junction 后等价于:\nif any(@values) \u0026gt; 42 { ... } 还可以在 Junction 上调用方法或运算符:\nif one(@values).is-prime { ... } if all(@values) %% 3 { ... } Named arguments(命名参数) Colonpair(冒号对儿) 通常用于命名参数中:\n:foo(42) foo =\u0026gt; 42 sub bar(:$foo) { say $foo; } bar(:foo(42)); 有几种特殊形式的冒号对儿:\n:foo :foo(True) :!foo :foo(False) :foo\u0026lt;bar\u0026gt; :foo(\u0026quot;bar\u0026quot;) :foo 与 foo =\u0026gt; True 相同, :!foo 等价于 foo =\u0026gt; False。:foo\u0026lt;bar\u0026gt; 使用了一组尖括号引起了值, 值在尖括号中不进行插值。\n来看一个命名参数例子, 下面的代码遍历 @dirs 中的目录, 找出后缀名为 txt 且不为空的文件:\nfor find(@dirs, :file, :ext\u0026lt;txt\u0026gt;, :!empty) -\u0026gt; $file { ... } 冒号对儿的值可以是变量, 但是在圆括号中再写一遍变量名就显得啰嗦:\nfoo(:bar($bar), :baz($baz), :quz($quz)) 因此, 冒号对儿提供了一种简写形式, 如果冒号后面紧跟着 $、@、% 和 \u0026amp; 等符号, 那么冒号对儿的值就是 $sth、@sth、%sth 和 \u0026amp;sth:\nfoo(:$bar, :$baz, :$quz) 这种简写形式消除了命名参数的重复。\nPointy blocks(尖号块儿) All blocks are Callable, 即所有的块儿都是可调用的。\n for blocks  -\u0026gt; $elem { ...} 就是尖号块儿:\nfor @array -\u0026gt; $elem { ... } for 循环依次把 @array 中的每个元素赋值给尖号块儿中的 $elem 变量, 然后执行尖号块儿的主体。\n Ordering  如果 foo 例程有返回值且不为假, 则赋值给 $value, 然后执行块儿的主体:\nif my $value = foo() { ... } 但是上面的语句在 Raku 中是不合法的, 要使用尖号块儿的方式:\nif foo() -\u0026gt; $value { ... } Signatures(签名) for 循环可以一次迭代两个(或多个)元素。尖号块儿相当于匿名函数, 其中的 $first, $second 就是尖号块儿的签名。\nfor @array -\u0026gt; $first, $second { ... } 下面的智能匹配中, 变量 $1 和 $2 有些多余:\nif / (\\S+) \\s+ (.*) / { my $name = $1; my $value = $2; ... } 通过尖号块儿, 把匹配结果直接赋值给 $name 和 $value, 节省了两个变量名:\nif / (\\S+) \\s+ (.*) / -\u0026gt; ($name, $value) { ... } for 尖号块儿和 if 尖号块儿的结构类似, 语法上非常整齐:\nfor expression() -\u0026gt; $value { ... } if expression() -\u0026gt; $value { ... } Whatever code 如果 grep 的过滤条件中有多个变量, 那么使用尖号块儿这种匿名函数比较合适:\n@numbers.grep(-\u0026gt; $n { $n \u0026gt; 2 }); 如果过滤条件中只有一个变量, 那么形式更短的 Whatever code 更符合惯用法:\n@numbers.grep(* \u0026gt; 2); Meta-operators  Reduction Zip Corss Hyper  Reduction meta operators\n fold/reduce an infix operator Respects associativity  reduce 运算符可以用于求和:\nmy $sum = reduce { $^a + $^b }, @list; my $sum = [+] @list [+] # sum [*] # product [~] # join [===] # all equal [\u0026lt;\u0026gt;] # ascending order [||] # first true value, if any  Zip 元运算符用于连接列表:\n(1, 2, 3) Z+ (30, 20 ,10) # (21, 22, 13) -\u0026gt; ($a, $b) 解构 Zip 后的元素:\nfor @a Z @b -\u0026gt; ($a, $b) { ... } Z=\u0026gt; 运算符通常用于从两个列表中制作哈希:\n%hash = @keys Z=\u0026gt; @values Zip 元运算符可以写成链式的:\n@a Z @b Z @c [Z] @list-of-lists Cross 是交叉运算符。使用两层 for 循环也可以实现交叉运算符的功能, 就是代码稍长:\ngather for 3, 9 -\u0026gt; $i { for 2, 10 -\u0026gt; $j { take $i + $j } } 而使用交叉运算符, 一行代码搞定:\n3, 9 X+ 2, 10 添加前缀也很简单:\n\u0026quot;prefix-\u0026quot; X~ @list Hyper 运算符可以把任何运算符(中缀、前缀和后缀等)应用到列表上:\n@list».abs @list.map(*.abs) !«@list @list.map(!*) @list»[1] @list.map(*[1]) 欧几里得距离:\n@a Z- @b Squared(平方)\n(@a Z- @b)»² Summed(求和)\n[+] (@a Z- @b)»² Square root(求平方根)\nsqrt [+] (@a Z- @b)»² Smartmatch(智能匹配) “Is the value part of this set”\n@list.grep(* \u0026gt; 2) @list.grep({ $_ eq \u0026quot;foo\u0026quot; }) @list.grep(Int) @list.grep({ .isa(Innt) }) @list.grep(/foo .* bar/) @list.grep({ .match(/foo .* bar/) }) @list.grep(2..4) @list.grep({ 2 \u0026lt;= $_ \u0026lt;= 4 }) @list.grep(:is-prime) @list.grep({ .is-prime }) combine junctions(结合 Junctions):\n@list.grep(:is-prime \u0026amp; /22/) @list.grep({ .is-prime \u0026amp;\u0026amp; .matches(/22/) }) @list.grep(none(/22/)) @list.grep({ !.matches(/22/) }) 最后, 还是查找文件的例子:\nfind(@dirs, :ext('rakumo'|'pm6'), :size(* \u0026gt; 1024), :depth(3..5), :contains(/raku/) ); 原文链接: https://www.youtube.com/watch?v=elalwvfmYgk\n"},"name":"Raku Syntax I Miss in Other Languages","published":"2021-06-17T00:00:00+08:00","summary":"Raku Syntax I Miss in Other Languages","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-06-17-raku-syntax-i-miss-in-other-languages/"}