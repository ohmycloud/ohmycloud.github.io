{"author":{"name":null,"type":"card","url":"https://ohmycloud.github.io/"},"content":{"html":"\u003cp\u003e欢迎来到今年的 \u003cstrong\u003eRaku One-Liner Advent Calendar\u003c/strong\u003e 的第\u003ca href=\"https://raku.online/2018/12/08/adding-up-even-fibonacci-numbers-in-perl-6/\"\u003e8\u003c/a\u003e天。 它大约是整个系列的 ¼，并且不要忘记你可以在 Raku 中键入 ¼ 而不是0.25！\u003c/p\u003e\n\u003cp\u003e今天，我们正在解决欧拉项目的\u003ca href=\"https://projecteuler.net/problem=2\"\u003e问题2\u003c/a\u003e。 任务是找到所有偶数斐波纳契数都低于四百万的数字的总和。\u003c/p\u003e\n\u003cp\u003e这是完整的答案：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e4_000_000\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003egrep\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"nv\"\u003e%%\u003c/span\u003e \u003cspan class=\"nv\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esum\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esay\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e从左侧或右侧解析代码同样有趣。 我们从左边开始吧。\u003c/p\u003e\n\u003cp\u003e在第一个圆括号内，我们生成一个斐波纳契数\u003ca href=\"https://docs.raku.org/type/Seq\"\u003e序列\u003c/a\u003e，从两个1开始，每个跟随的数字是前两个数之和。 在 Raku 中，您可以使用 \u003ca href=\"https://docs.raku.org/type/WhateverCode\"\u003eWhateverCode\u003c/a\u003e 块表达它：\u003ccode\u003e* + *\u003c/code\u003e 相当于 \u003ccode\u003e{$^a + $^b}\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003eRaku 序列的一个鲜为人知的特征是最终条件。 在许多例子中，你会看到裸\u003ca href=\"https://rakuadvent.wordpress.com/2017/12/11/all-the-stars-of-perl-6/\"\u003e星\u003c/a\u003e或 \u003ca href=\"https://docs.raku.org/type/Num#index-entry-Inf_%28definition%29\"\u003eInf\u003c/a\u003e。 在我们的示例中，我们使用显式的上边界限制序列。\u003c/p\u003e\n\u003cp\u003e请注意，您不能简单地写成这样：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"mi\"\u003e4_000_000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e要更好地将其可视化，请尝试更小的限制，例如100：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"mi\"\u003e100\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e \u003cspan class=\"mi\"\u003e5\u003c/span\u003e \u003cspan class=\"mi\"\u003e8\u003c/span\u003e \u003cspan class=\"mi\"\u003e13\u003c/span\u003e \u003cspan class=\"mi\"\u003e21\u003c/span\u003e \u003cspan class=\"mi\"\u003e34\u003c/span\u003e \u003cspan class=\"mi\"\u003e55\u003c/span\u003e \u003cspan class=\"mi\"\u003e89\u003c/span\u003e \u003cspan class=\"mi\"\u003e144\u003c/span\u003e \u003cspan class=\"mi\"\u003e233\u003c/span\u003e \u003cspan class=\"mi\"\u003e377\u003c/span\u003e \u003cspan class=\"mi\"\u003e610\u003c/span\u003e \u003cspan class=\"mi\"\u003e987\u003c/span\u003e \u003cspan class=\"mi\"\u003e1597\u003c/span\u003e \u003cspan class=\"mi\"\u003e2584\u003c/span\u003e \u003cspan class=\"mi\"\u003e4181\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e当序列越过我们想要的边界时，Raku 没有停止，并继续生成数字。 只有当序列的下一个计算元素完全等于给定数字时，它才会停止它，例如：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"mi\"\u003e144\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e \u003cspan class=\"mi\"\u003e5\u003c/span\u003e \u003cspan class=\"mi\"\u003e8\u003c/span\u003e \u003cspan class=\"mi\"\u003e13\u003c/span\u003e \u003cspan class=\"mi\"\u003e21\u003c/span\u003e \u003cspan class=\"mi\"\u003e34\u003c/span\u003e \u003cspan class=\"mi\"\u003e55\u003c/span\u003e \u003cspan class=\"mi\"\u003e89\u003c/span\u003e \u003cspan class=\"mi\"\u003e144\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果您不知道四百万之前的斐波纳契数，请使用另一个具有布尔条件的 WhateverCode 块：\u003ccode\u003e*\u0026gt; 4_000_000\u003c/code\u003e。 请注意，这里的条件与你在常规循环中所写的内容相反，因为我们要求超过四百万，而不是少于。 当你必须停止序列时，这是变为 True 的条件。 如果不用星号，您可以使用默认变量：\u003ccode\u003e{$_ \u0026gt; 4_000_000}\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e其余的代码会\u003ca href=\"https://docs.raku.org/routine/grep\"\u003egrep\u003c/a\u003es偶数数字并把它们\u003ca href=\"https://docs.raku.org/routine/sum\"\u003e加\u003c/a\u003e起来。 有关这些操作的更详细说明，请参见\u003ca href=\"https://raku.online/2018/12/02/grep-dividable-numbers/\"\u003e第2天\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e听起来很棒！ 让我们明天再多谈谈很酷的 Raku 单行程序吧。\u003c/p\u003e\n","text":"欢迎来到今年的 Raku One-Liner Advent Calendar 的第8天。 它大约是整个系列的 ¼，并且不要忘记你可以在 Raku 中键入 ¼ 而不是0.25！\n今天，我们正在解决欧拉项目的问题2。 任务是找到所有偶数斐波纳契数都低于四百万的数字的总和。\n这是完整的答案：\n(1, 1, * + * ... * \u0026gt; 4_000_000).grep(* %% 2).sum.say 从左侧或右侧解析代码同样有趣。 我们从左边开始吧。\n在第一个圆括号内，我们生成一个斐波纳契数序列，从两个1开始，每个跟随的数字是前两个数之和。 在 Raku 中，您可以使用 WhateverCode 块表达它：* + * 相当于 {$^a + $^b}。\nRaku 序列的一个鲜为人知的特征是最终条件。 在许多例子中，你会看到裸星或 Inf。 在我们的示例中，我们使用显式的上边界限制序列。\n请注意，您不能简单地写成这样：\n1, 1, * + * ... 4_000_000 要更好地将其可视化，请尝试更小的限制，例如100：\n\u0026gt; (1, 1, * + * ... 100) (1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 当序列越过我们想要的边界时，Raku 没有停止，并继续生成数字。 只有当序列的下一个计算元素完全等于给定数字时，它才会停止它，例如：\n\u0026gt; (1, 1, * + * ... 144) (1 1 2 3 5 8 13 21 34 55 89 144) 如果您不知道四百万之前的斐波纳契数，请使用另一个具有布尔条件的 WhateverCode 块：*\u0026gt; 4_000_000。 请注意，这里的条件与你在常规循环中所写的内容相反，因为我们要求超过四百万，而不是少于。 当你必须停止序列时，这是变为 True 的条件。 如果不用星号，您可以使用默认变量：{$_ \u0026gt; 4_000_000}。\n其余的代码会greps偶数数字并把它们加起来。 有关这些操作的更详细说明，请参见第2天。\n听起来很棒！ 让我们明天再多谈谈很酷的 Raku 单行程序吧。\n"},"name":"🎄 8/25. 在 Raku 中加总偶数斐波纳契数","published":"2018-12-08T11:08:09Z","summary":"欢迎来到今年的 Raku One-Liner Advent Calendar 的第8天。 它大约是整个系列的 ¼，并且不要忘记你可以在 Raku 中键入 ¼ 而不是0.25！\n今天，我们正在解决欧拉项目的问题2。 任务是找到所有偶数斐波纳契数都低于四百万的数字的总和。\n这是完整的答案：\n(1, 1, * + * ... * \u0026gt; 4_000_000).grep(* %% 2).sum.say 从左侧或右侧解析代码同样有趣。 我们从左边开始吧。\n在第一个圆括号内，我们生成一个斐波纳契数序列，从两个1开始，每个跟随的数字是前两个数之和。 在 Raku 中，您可以使用 WhateverCode 块表达它：* + * 相当于 {$^a + $^b}。\nRaku 序列的一个鲜为人知的特征是最终条件。 在许多例子中，你会看到裸星或 Inf。 在我们的示例中，我们使用显式的上边界限制序列。\n请注意，您不能简单地写成这样：\n1, 1, * + * ... 4_000_000 要更好地将其可视化，请尝试更小的限制，例如100：\n\u0026gt; (1, 1, * + * ... 100) (1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 当序列越过我们想要的边界时，Raku 没有停止，并继续生成数字。 只有当序列的下一个计算元素完全等于给定数字时，它才会停止它，例如：","type":"entry","url":"https://ohmycloud.github.io/notes/adding-up-even-fibonacci-numbers-in-perl-6/"}