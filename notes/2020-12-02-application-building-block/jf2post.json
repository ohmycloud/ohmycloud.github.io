{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"content":{"html":"\u003ch2 id=\"应用构件\"\u003e应用构件\u003c/h2\u003e\n\u003cp\u003eStateful Functions 为构建事件驱动应用程序提供了一个框架。在这里，我们将解释 Stateful Function 架构的重要方面。\u003c/p\u003e\n\u003ch2 id=\"事件输入\"\u003e事件输入\u003c/h2\u003e\n\u003cp\u003e有状态函数应用正好坐在事件驱动的领域，所以自然要从把事件摄入系统开始。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ci.apache.org/projects/flink/flink-statefun-docs-release-2.2/fig/concepts/statefun-app-ingress.svg\" alt=\"img\"\u003e\u003c/p\u003e\n\u003cp\u003e在有状态函数中，将记录摄入系统的组件称为事件入口。这可以是任何东西，从 Kafka 主题，到 messsage 队列，再到 http 请求 - 任何能够将数据引入系统并触发初始函数开始计算的东西。\u003c/p\u003e\n\u003ch2 id=\"有状态函数\"\u003e有状态函数\u003c/h2\u003e\n\u003cp\u003e该图的核心是命名的有状态函数。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ci.apache.org/projects/flink/flink-statefun-docs-release-2.2/fig/concepts/statefun-app-functions.svg\" alt=\"img\"\u003e\u003c/p\u003e\n\u003cp\u003e把这些函数看作是你的服务的构件。它们可以任意地相互发送消息，这也是这个框架摆脱传统的流处理观点的一种方式。这些函数可以以任意的、可能是循环的、甚至是往返的方式相互通信，而不是建立一个静态的数据流 DAG。\u003c/p\u003e\n\u003cp\u003e如果你熟悉 actor 编程，这在组件之间动态消息的能力上确实有某些相似之处。然而，也有一些显著的区别。\u003c/p\u003e\n\u003ch2 id=\"持续状态\"\u003e持续状态\u003c/h2\u003e\n\u003cp\u003e首先是所有函数都有本地嵌入的状态，即所谓的持久化状态。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ci.apache.org/projects/flink/flink-statefun-docs-release-2.2/fig/concepts/statefun-app-state.svg\" alt=\"img\"\u003e\u003c/p\u003e\n\u003cp\u003eApache Flink 的核心优势之一就是它能够提供容错的本地状态。当在一个函数内部，当它在执行一些计算时，你总是在本地变量中处理本地状态。\u003c/p\u003e\n\u003ch2 id=\"容错\"\u003e容错\u003c/h2\u003e\n\u003cp\u003e对于状态和消息传递，Stateful Functions 能够提供用户从现代数据处理框架中期望的精确的一次保证。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ci.apache.org/projects/flink/flink-statefun-docs-release-2.2/fig/concepts/statefun-app-fault-tolerance.svg\" alt=\"img\"\u003e\u003c/p\u003e\n\u003cp\u003e在失败的情况下，整个世界的状态（包括持久化的状态和消息）都会被回滚，以模拟完全无故障的执行。\u003c/p\u003e\n\u003cp\u003e这些保证是在不需要数据库的情况下提供的，相反，Stateful Function 利用了 Apache Flink 的成熟快照机制。\u003c/p\u003e\n\u003ch2 id=\"事件出口\"\u003e事件出口\u003c/h2\u003e\n\u003cp\u003e最后，应用程序可以通过事件出口向外部系统输出数据。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://ci.apache.org/projects/flink/flink-statefun-docs-release-2.2/fig/concepts/statefun-app-egress.svg\" alt=\"img\"\u003e\u003c/p\u003e\n\u003cp\u003e当然，函数执行任意计算，可以随心所欲，这包括进行 RPC 调用和连接到其他系统。通过使用事件出口，应用程序可以利用建立在 Apache Flink 连接器生态系统之上的预建集成。\u003c/p\u003e\n","text":"应用构件 Stateful Functions 为构建事件驱动应用程序提供了一个框架。在这里，我们将解释 Stateful Function 架构的重要方面。\n事件输入 有状态函数应用正好坐在事件驱动的领域，所以自然要从把事件摄入系统开始。\n在有状态函数中，将记录摄入系统的组件称为事件入口。这可以是任何东西，从 Kafka 主题，到 messsage 队列，再到 http 请求 - 任何能够将数据引入系统并触发初始函数开始计算的东西。\n有状态函数 该图的核心是命名的有状态函数。\n把这些函数看作是你的服务的构件。它们可以任意地相互发送消息，这也是这个框架摆脱传统的流处理观点的一种方式。这些函数可以以任意的、可能是循环的、甚至是往返的方式相互通信，而不是建立一个静态的数据流 DAG。\n如果你熟悉 actor 编程，这在组件之间动态消息的能力上确实有某些相似之处。然而，也有一些显著的区别。\n持续状态 首先是所有函数都有本地嵌入的状态，即所谓的持久化状态。\nApache Flink 的核心优势之一就是它能够提供容错的本地状态。当在一个函数内部，当它在执行一些计算时，你总是在本地变量中处理本地状态。\n容错 对于状态和消息传递，Stateful Functions 能够提供用户从现代数据处理框架中期望的精确的一次保证。\n在失败的情况下，整个世界的状态（包括持久化的状态和消息）都会被回滚，以模拟完全无故障的执行。\n这些保证是在不需要数据库的情况下提供的，相反，Stateful Function 利用了 Apache Flink 的成熟快照机制。\n事件出口 最后，应用程序可以通过事件出口向外部系统输出数据。\n当然，函数执行任意计算，可以随心所欲，这包括进行 RPC 调用和连接到其他系统。通过使用事件出口，应用程序可以利用建立在 Apache Flink 连接器生态系统之上的预建集成。\n"},"name":"Application Building Blocks","published":"2020-12-02T00:00:00+08:00","summary":"Application Building Block","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-12-02-application-building-block/"}