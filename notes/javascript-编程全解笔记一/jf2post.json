{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io/"},"content":{"html":"\u003ch2 id=\"函数javascript-的函数是一种对象\"\u003e函数JavaScript 的函数是一种对象。\u003c/h2\u003e\n\u003ch2 id=\"对象\"\u003e对象\u003c/h2\u003e\n\u003cp\u003eJavascript 中没有\u003cstrong\u003e类\u003c/strong\u003e这样的语言结构, Javascript 中的对象是一个 \u003ccode\u003e名称\u003c/code\u003e与\u003ccode\u003e值\u003c/code\u003e配对的\u003cstrong\u003e集合\u003c/strong\u003e。这样一对儿名称和值的配对被称为属性。例如一个人的属性有:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e身高: 178cm\u003c/li\u003e\n\u003cli\u003e体重 65kg\u003c/li\u003e\n\u003cli\u003e年龄 28\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e所以, Javascript 对象可以定义为\u003ccode\u003e属性\u003c/code\u003e 的集合。Javascript 的对象\u003cstrong\u003e字面量\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 对象字面量表达式的语法\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nx\"\u003e属性名\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e属性值\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"nx\"\u003e属性名\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e属性值\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e......\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e属性名可以是标识符。字符串和数值：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 对象字面量表达式的例子\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nx\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ey\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// 属性名是标识符\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;x\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;y\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// 属性名是字符串值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;x\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;y\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e      \u003cspan class=\"c1\"\u003e// 属性名是字符串值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// 属性名是数值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nx\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ey\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eenable\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecolor\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nx\"\u003er\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"mi\"\u003e255\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eg\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"mi\"\u003e255\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eb\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"mi\"\u003e255\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 各种类型的属性值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e对对象字面量表达式求值所得到的结果，是所生成对象的一个引用。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 对象字面量表达式与赋值表达式\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"nx\"\u003ejs\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"kd\"\u003evar\u003c/span\u003e \u003cspan class=\"nx\"\u003eobj\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nx\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ey\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e \u003cspan class=\"p\"\u003e};\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 所生成对象的引用将被赋值给变量 obj\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"nx\"\u003ejs\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003etypeof\u003c/span\u003e \u003cspan class=\"nx\"\u003eobj\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 通过 typeof 运算符来判别 obj 的类型，得到的结果是 object\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"nx\"\u003eobject\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"属性访问\"\u003e属性访问\u003c/h2\u003e\n\u003cp\u003e通过点语法和方括号访问属性：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var obj = {x:3, y:4}\njs\u0026gt; typeof(obj)\n\u0026#34;object\u0026#34;\njs\u0026gt; print(obj.x)\n3\njs\u0026gt; print(obj[\u0026#39;x\u0026#39;])\n3\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"方法\"\u003e方法\u003c/h2\u003e\n\u003cp\u003e可以把任意类型的值、对象或者函数赋值给对象的属性。正如前节所讲，对匿名函数表达式求值所\n得到的结果是函数对象的引用，所以，也可以像下面这样来书写。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; obj.fn = function (a, b) {return Number(a) + Number(b); };      // 将函数赋值给对象 obj 的属性 fn\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可以像下面这样，对被赋值给属性的函数进行调用。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; obj.fn(3, 4); // 调用函数\n7\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e回顾一下之前章节的说明可以发现，在代码清单 2.2 之后还可以像下面这样书写。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; obj.fn2 = sum;  // sum 是在代码清单 2.2 中定义的函数\njs\u0026gt; obj.fn2(3, 4); // 调用函数\n\n7\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"数组\"\u003e数组\u003c/h2\u003e\n\u003cp\u003eJavascript 中数组中的元素可以是不同的类型：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evar arr = [1, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, 5]\nprint(arr[1])     ///  foo\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"数据类型\"\u003e数据类型\u003c/h2\u003e\n\u003cp\u003e像 Java 这样，变量具有数据类型的语言，被称为静态数据类型语言；而像 JavaScript 这样，变量没有类型的语言，则被称为动态数据类型语言。\n在 JavaScript 中，字符串值会被隐式地转换为字符串对象类型\u003c/p\u003e\n\u003cp\u003e在 JavaScript 中书写 \u0026lsquo;012\u0026rsquo;.lenght 的话，（属于内建类型的）字符串值会先被隐式地转换为\n字符串对象 ，然后再读取字符串对象的 length 属性。隐式类型转换也能反向进行。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evar sobj = new String(\u0026#39;abc\u0026#39;); // 生成字符串对象\nvar s = sobj + \u0026#39;def\u0026#39;;               // 将字符串对象隐式转换为了字符串值\nprint(s);\n// abcdef\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e字符串值和字符串对象之间可以进行隐式类型转换。因此，一般来说并不需要在意值和对象之间的\n区别。不过正因看起来非常相似，所以会存在一些陷阱。例如，在判定两者是否相等上是有差异的。\u003ccode\u003e对 象的相等运算，判断的是两者是否引用了同一个对象（而非两者的内容是否相同）\u003c/code\u003e。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var sobj1 = new String(\u0026#39;abc\u0026#39;);\njs\u0026gt; var sobj2 = new String(\u0026#39;abc\u0026#39;);\njs\u0026gt; sobj1 == sobj2;  // 虽然字符串的内容相同，但是并非引用了同一个对象，所以结果是 false\nfalse\njs\u0026gt; sobj1 === sobj2; // 虽然字符串的内容相同，但是并非引用了同一个对象，所以结果是 false\nfalse\n\njs\u0026gt; sobj3 = sobj2\n(new String(\u0026#34;abc\u0026#34;))\njs\u0026gt; sobj3 == sobj2\ntrue\njs\u0026gt; sobj3 === sobj2\ntrue\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上面的两个字符串对象，在通过 + 与空字符串值连接之\n后，就会进行隐式数据类型转换而变为字符串值，从而结果也将发生变化。（比较的是两者的内容是否相同）\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 继续之前的代码（以下只是用于说明的代码，实际中并不推荐这样使用）\njs\u0026gt; sobj1 + \u0026#39;\u0026#39; == sobj2 + \u0026#39;\u0026#39;;\ntrue\njs\u0026gt; sobj1 + \u0026#39;\u0026#39; === sobj2 + \u0026#39;\u0026#39;;\ntrue\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e对于字符串值和字符串对象的等值判断，如果使用的是会进行隐式数据类型转换的 == 运算，则只会判定其内容是否相同，如果内容相同则结果为真。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var sobj = new String(\u0026#39;abc\u0026#39;);\njs\u0026gt; var s = \u0026#39;abc\u0026#39;;\njs\u0026gt; sobj == s;  // 进行数据类型转换的等值运算的结果为 true\ntrue;\njs\u0026gt; sobj === s;  // 不进行数据类型转换的等值运算的结果为 false\nfalse\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e要尽量避免显式地使用 \u003ccode\u003enew Stirng\u003c/code\u003e 生成字符串对象。尽情享受隐式转换就好了。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var s = \u0026#39;abc\u0026#39;;  // 返回字符串值下标为 1 的字符\njs\u0026gt; s.charAt(1);\nb\njs\u0026gt; \u0026#39;abc\u0026#39;.charAt(1); // 对于字符串字面量也能像这样进行方法调用\nb\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e调用 String 函数进行显式数据类型转换：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var s = String(\u0026#39;abc\u0026#39;);\njs\u0026gt; typeof s; // 变量 s 的值是字符串型\nstring\njs\u0026gt; var s = String(47);  // 由数值类型向字符串值类型的显式数据类型变换\njs\u0026gt; print(s);\n47\njs\u0026gt; typeof s; // 变量 s 的值是字符串型\nstring\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eString 类的函数以及构造函数调用\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e函数或是构造函数\n说明\u003c/p\u003e\n\u003cp\u003eString([value])\n将参数 value 转换为字符串值类型\u003c/p\u003e\n\u003cp\u003enew String([value])\n生成 String 类的实例\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eString类的属性\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e属性名\n说明\u003c/p\u003e\n\u003cp\u003efromCharCode([char0[,char1,\u0026hellip;]])\n将参数 value 转换为字符串值类型\u003c/p\u003e\n\u003cp\u003elength\n 值为1\u003c/p\u003e\n\u003cp\u003eprototype\n原型链\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eString.prototype 对象所具有的属性\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e属性名\n说明\u003c/p\u003e\n\u003cp\u003echarAt(pos)\n返回下标 pos 位置字符长度为 1 的字符串值。下标从 0 开始。如果下标超界则返回空字符串值\u003c/p\u003e\n\u003cp\u003echarCodeAt(pos)\n返回下标 pos 位置处字符的字符编码。如果超过了下标的范围, 则返回 NaN\u003c/p\u003e\n\u003cp\u003econcat([string0, string1,\u0026hellip;])\n和参数字符串相连接后返回新的字符串值\u003c/p\u003e\n\u003cp\u003econstructor\n引用一个 String 类对象\u003c/p\u003e\n\u003cp\u003eindexOf(searchString[, pos])\n返回在字符串中第一个遇到的字符串值 searchString 的下标值。可以通过第二个可选参数指定搜索的起始位置。如果没有找到符合条件的结果, 则返回 -1\u003c/p\u003e\n\u003cp\u003elocaleCompare(that)\n比较和本地运行环境相关的字符串。根据比较的结果分别返回正数、0 或者负数\u003c/p\u003e\n\u003cp\u003ematch(regexp)\n返回匹配正则表达式 regexp 的结果\u003c/p\u003e\n\u003cp\u003equote()\nJavascript 自定义的增强功能。在字符串外加上双引号之后返回这一新的字符串值\u003c/p\u003e\n\u003cp\u003ereplace(searchValue, replaceValue)\n将 searchValue (正则表达式活字符串值) 替换为 replaceValue (字符串或函数) 后返回经过替换后的字符串\u003c/p\u003e\n\u003cp\u003esearch(regexp)\n返回匹配正则表达式 regexp 的位置的下标\u003c/p\u003e\n\u003cp\u003eslice(start, end)\n将参数 start 开始至 end 结束的字符串部分作为新的字符串返回。 如果 start 和 end 是负数, 则返回从末尾逆向起数的下标值\u003c/p\u003e\n\u003cp\u003esplit(separator, limit)\n根据字符串或正则表达式形式的参数 separator 将字符串分割, 返回相应的字符串值数组\u003c/p\u003e\n\u003cp\u003esubstring(start, end)\n将参数 start 开始至 end 结束的字符串部分作为新的字符串返回。其作用和 slice 相同, 但是不支持以负数作为参数\u003c/p\u003e\n\u003cp\u003etoLocaleLowerCase()\n将字符串中所有字符转换为和本地环境相应的小写字符\u003c/p\u003e\n\u003cp\u003etoLocaleUpperCase()\n将字符串中所有字符转换为和本地环境相应的大写字符\u003c/p\u003e\n\u003cp\u003etoLowerCase()\n将字符串中所有字符转换为小写字符\u003c/p\u003e\n\u003cp\u003etoSource()\nJavascript 自定义的增强功能。返回用于生成 String 实例的字符串(即源代码)\u003c/p\u003e\n\u003cp\u003etoString()\n将 Stirng 实例转换为字符串值(并返回)\u003c/p\u003e\n\u003cp\u003etoUpperCase()\n将字符串中的所有字符转换为大写字符\u003c/p\u003e\n\u003cp\u003etrim()\n去除字符串前后的空白符\u003c/p\u003e\n\u003cp\u003etrimLeft()\nJavascript 自定义的增强功能。去除字符串左侧(头部) 的空白符\u003c/p\u003e\n\u003cp\u003etrimRight()\nJavascript 自定义的增强功能。去除字符串右侧(尾部) 的空白符\u003c/p\u003e\n\u003cp\u003evalueOf()\n将 String 实例转换为字符串值并返回\u003c/p\u003e\n\u003cp\u003e还可以像下面这样，通过数值属性获取指定下标的字符（不过这是 JavaScript 自定义的增强功能）。其返回值是一个 String 对象。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var s = new String(\u0026#39;abc\u0026#39;);\njs\u0026gt; print(s[1]); // 下标为 1 的字符\nb\njs\u0026gt; print(\u0026#39;abc\u0026#39;[2]); // 由于有隐式数据类型转换，所以对字符串值也能进行这样的操作\nc\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"数值\"\u003e数值\u003c/h2\u003e\n\u003cp\u003eJavascript 中， 大部分情况下浮点数只能表达数值的近似值。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; 0.1 + 0.2;  // 0.1 与 0.2 的和并不是 0.3。\n0.30000000000000004\njs\u0026gt; (0.1 + 0.2) == 0.3  // 两者不一致。\nfalse\njs\u0026gt; (0.1 + 0.2) === 0.3  // 两者不一致。\nfalse\njs\u0026gt; 1/3 // 1 除以 3 之后的近似结果。\n0.333333333333333\njs\u0026gt; 10/3 – 3; // 这同样是近似值。\n0.333333333333333\njs\u0026gt; (10/3 – 3) == (1/3);  // 这两个近似值是不一致的。\nfalse\njs\u0026gt; (10/3 – 3) === (1/3);\nfalse\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e而 Raku 就不会出现这种情况。数值也存在数值对象：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var nobj = new Number(1);\njs\u0026gt; var nobj1 = new Number(1);\njs\u0026gt; nobj == nobj1;  // 虽然值是相同的，但是所引用的对象不同，因而结果为 false\nfalse\njs\u0026gt; nobj === nobj1;  // 虽然值是相同的，但是所引用的对象不同，因而结果为 false\nfalse\njs\u0026gt; nobj == 1;  // 会进行数据类型转换的等值运算结果为 true\ntrue\njs\u0026gt; nobj === 1;  // 不会进行数据类型转换的等值运算结果为 false\nfalse\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e调用 Number 函数：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var n1 = Number(1);\njs\u0026gt; typeof n1;  // 变量 n1 的值为数值\nnumber\njs\u0026gt; n1 == 1;\ntrue\njs\u0026gt; n1 === 1;\ntrue\njs\u0026gt; var n = Number(\u0026#39;1\u0026#39;);  // 从字符串值至数值型的显式数据类型转换\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"第四章\"\u003e 第四章\u003c/h2\u003e\n\u003cp\u003eJavascript 标识符区分大小写。JavaScript（准确地说是 ECMAScript）的代码块中的变量并不存在块级作用域这样\n的概念。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 变量声明的例子\nvar foo;\nvar foo, bar; // 同时声明多个变量\nvar foo = \u0026#39;FOO\u0026#39;, bar = \u0026#39;BAR\u0026#39;; // 在声明变量的同时进行初始化\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eJavascript 中的 switch/case\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evar x = 0;\nswitch (x) {\ncase 0:\n    print(\u0026#34;0\u0026#34;);\ncase 1:\n    print(\u0026#34;1\u0026#34;);\ncase 2:\n    print(\u0026#34;2\u0026#34;);\ndefault:\n    print(\u0026#34;default\u0026#34;);\n    break;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e使用 switch 语句时，等值比较表达式可以被隐藏起来，所以与使用了等值比较的 if-else 语句相比表达\n上更为简洁。需要注意的是，switch 语句所隐藏的等值比较运算是不会对数据类型进行转换的 === 运算。\n如果原来的 if-else 语句中的表达式使用的是 == 运算的话，就可能会在执行上有一些细微的差别\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evar s = \u0026#39;foo\u0026#39;;\nswitch (s) { // 可以在 switch 表达式中使用字符串值。\n// 可以在 case 表达式中使用和 switch 表达式类型不同的值。\n// s === 0 的值为假，所以将继续进行比较。\ncase 0:\n    print(\u0026#39;not here\u0026#39;);\n    break;\n// 可以在 case 表达式中使用含有变量的表达式。\n// s === s.length 的值为假，所以将继续进行比较。\ncase s.length:\n    print(\u0026#39;not here\u0026#39;);\n    break;\n// 可以在 case 表达式中使用方法调用表达式。\n// s === (0).toString() 的值为假，所以将继续进行比较。\ncase (0).toString();\n    print(\u0026#39;not here\u0026#39;);\n    break;\n// 还可以在 case 表达式中书写这样的表达式。\n// s === \u0026#39;f\u0026#39; + \u0026#39;o\u0026#39; + \u0026#39;o\u0026#39; 为真，所以将执行以下的代码。\ncase \u0026#39;f\u0026#39; + \u0026#39;o\u0026#39; + \u0026#39;o\u0026#39;:\n    print(\u0026#39;here\u0026#39;);\n    break;\n// 如果所有的 case 表达式在等值运算（===）后得到的结果都为假，则执行以下的代码。\ndefault:\n    print(\u0026#39;not here\u0026#39;);\n    break;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e标签：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 使用标签来同时跳出嵌套的循环\nouter_loop:\nwhile (true) {\n    print(\u0026#34;outer loop\u0026#34;);\n    while (true) {\n        print(\u0026#34;inner loop\u0026#34;);\n        break outer_loop;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e外层循环被标以 outer_loop 的标签（此前提到过，请再回想一下，while 循环以及相应的代码块共同组成了一句语句）。\u003c/p\u003e\n\u003cp\u003e异常：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// try-catch-finally 结构的语法\ntry {\n    语句\n    语句\n    ……\n} catch ( 变量名 ) { // 该变量是一个引用了所捕捉到的异常对象的局部变量\n    语句\n    语句\n    ……\n} finally {\n    语句\n    语句\n    ……\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在 try 语句之外，或者没有 catch 子句的 try 语句，都是无法捕捉异常的。这时函数会中断并返回至调用该函数之处。\u003c/p\u003e\n\u003cp\u003efinally 子句必定会在跳出 try 语句之时被执行。即使没有产生异常，finally 子句也会被执行。也就是说，如果没有产生异常的话，在执行完 try 子句之后会继续执行 finally 子句的代码；如果产生了异常，则会在执行 finally 子句之前首先执行 catch 子句。对于没有 catch 子句的 try 语句来说，异常将会被直接传\n递至上一层，但 finally 子句仍然会被执行。\u003c/p\u003e\n\u003cp\u003e代码清单 4.9 try 语句的执行示例\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003etry {\n    print(\u0026#39;1\u0026#39;);\n    null.x; // 在此处强制产生一个 TypeError 异常\n    print(\u0026#39;not here\u0026#39;);  // 这条语句不会被执行\n} catch (e) { // 对象 e 是 TypeError 对象的一个引用\n    print(\u0026#39;2\u0026#39;);\n} finally {\n    print(\u0026#39;3\u0026#39;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 代码清单 4.9 的运行结果\n1\n2\n3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ewith 表达式：\u003c/p\u003e\n\u003cp\u003ewith 语句用于临时改变名称（变量名或是函数名）的查找范围。with 语句中使用的表达式是 Object\n类型的。如果使用了其他类型的值，则会被转换为 Object 类型。在 with 语句内对变量名进行查找时，将\n会从所指定对象的属性开始寻找。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// with 语句的例子\njs\u0026gt; var x = 1;  // 全局变量\njs\u0026gt; var obj = { x:7, y:8 };\njs\u0026gt; with (obj) {\n    print(x);  // 如果要查找变量 x，则会在查找全局变量 x 之前先查找到 obj.x\n}\n7\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e注释：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 单行注释\n/* 注释 */\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e运算符和操作数在英语中分别称为 operator 和 operand。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 赋值表达式的结合律为右结合\nx = y = z = 0;\n将以\nx = (y = (z = 0);\n的方式被求值\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在 JavaScript 所有算术运算中的数值都是浮点小数。\u003c/p\u003e\n\u003cp\u003eECMAScript 中，=== 被称为 Strict Equals 运算符，而 == 则被称为 Equals 运算符。\n将 Strict Equals 运算符（===）称为全等运算符，而将 Equals 运算符（==）称为相等运算符。两者的区别在于，是否会在进行相等判定时进行数据类型转换。\n全等运算不会进行数据类型转换，因此数据类型是否一致也是判断是否相等的内容之一。而相等运算 （==）会先进行数据类型转换，在数据类型相同后再进行相等判断。两种运算符的运算结果都是布尔值。\u003c/p\u003e\n\u003cp\u003e下面总结了全等运算的一些特性。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e1. x 与 y 如果数据类型不相符，则结果为假。\u003c/li\u003e\n\u003cli\u003e2. 两者都是 undefined 值或两者都是 null 值的情况，结果为真。\u003c/li\u003e\n\u003cli\u003e3.  两者都是数值，但有一方为 NaN，或者两者都是 NaN 的情况，结果为假。否则，如果数值相等则结果为真，不相等则为假。\u003c/li\u003e\n\u003cli\u003e4. 两者都是字符串的情况下，如果内容一致则结果为真，否则结果为假。\u003c/li\u003e\n\u003cli\u003e5. 两者都是布尔值的情况下，如果值一致则结果为真，否则结果为假。\u003c/li\u003e\n\u003cli\u003e6. 两者都是对象引用的情况下，如果引用的是同一个对象则结果为真，否则结果为假。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e相等运算 == 由于会进行隐式数据类型转换，所以其执行方式更为复杂。下面是对其运算规则的总结。\u003c/p\u003e\n\u003cp\u003e  ● x 与 y 的数据类型相同时，与全等运算的结果相同。\n  ● x 与 y 的数据类型不同时，判定规则如下。\n　 （1）一方为 null 值，另一方为 undefined 值的情况，结果为真。\n　 （2）一方为数值，另一方为字符串值的情况，将字符串值转换为数值之后对数值进行比较。\n　 （3）一方为布尔值，另一方为数值的情况，将布尔值转换为数值之后对数值进行比较。\n　 （4）一方为布尔值，另一方为字符串值的情况，将两者都转换为数值后对数值进行比较。\n　 （5）一方为数值，另一方为对象引用的情况，将对象引用转换为数值后对数值进行比较。\n　 （6）一方为字符串值，另一方为对象引用的情况，将对象引用转换为字符串值后对字符串的内容进行比较。\n　 （7）以上 6 种情况之外的运算结果都为假\u003c/p\u003e\n\u003cp\u003evoid 运算符：\u003c/p\u003e\n\u003cp\u003e无论向其传递什么操作数，其运算结果都会是 undefined 值。下面是一个具体的例子。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; print(void 0);  // 操作数为数值\nundefined\njs\u0026gt; print(void \u0026#39;x\u0026#39;); // 操作数为字符串值\nundefined\njs\u0026gt; var x = 0;\njs\u0026gt; void x++; // 由于会先对操作数进行求值，所以 x 将自增\njs\u0026gt; print(x);\n1\njs\u0026gt; void(x); // 常常会把操作数通过括号包围起来\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在客户端 JavaScript 中有不少相关的习惯用法。下面是一个在 HTML 中点击了标签 a 之后发送表单内容的 JavaScript 代码的例子。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u0026lt;a href=\u0026#34;javascript:void(document.form.submit())\u0026#34;\u0026gt; 发送 HTML 表单数据但不跳转页面 \u0026lt;/a\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ehred 属性中所写的表达式如果具有值的话，则会被标签 a 认为是 URL 并跳转至该页面。为了阻止标签 a 的这一行为，需要将 href 属性中表达式的值强制设为 undefined 值。对此最为简单的惯用方法就是通过 void 运算来实现。\u003c/p\u003e\n\u003cp\u003e逗号运算符（,）是一个双目运算符，其作用为依次对其左操作数与右操作数求值。逗号运算符的运\n算结果是其右操作数的值，也就是说其结果的类型取决于所使用的操作数。下面是一个具体的例子。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; print((x = 1, y = 2)); // 请注意，如果不在真个参数外加括号的话，其含义就会变为参数的数量是两个\n2\njs\u0026gt; print((x = 1, ++x, ++x)); // 由于是左结合，相当于 ((x = 1, ++x), ++x)\n3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e字符 .（点）称为点运算符，中括号 [] 称为中括号运算符，它们都是用于访问属性的运算符。虽然这\n两个运算符不太显眼，却有着很重要的作用。\n其左操作数为对象引用，右操作数为属性名。如果左操作数不是对象引用的话，则会被转换为\nObject 类型。点运算符的右操作数是一个用于表示属性名的标识符，而中括号运算符的右操作数为字符\n串型或是可以被转换为字符串型的值。\u003c/p\u003e\n\u003ch2 id=\"第五章-变量与对象\"\u003e第五章 变量与对象\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evar a = a || 7;  // 一种习惯用法。如果变量 a 已经具有某个值（严格来说是具有某个可以被转换为 true 的值）就直接使用，否则就把 7 赋值给 a\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e准确地说，对象的赋值其实是将对象的引用进行赋值。变量有值类型和引用类型。将基本类型的值赋值给变量的话，变量将把这个值本身保存起来。这时，可以将变量简单地理解为一个装了该值的箱子。变量本身装有所赋的这个值，所以能够将该值从变量中取出。\u003c/p\u003e\n\u003cp\u003e如果将一个对象赋值给变量，其实是把这个对象的引用赋值给了该变量。对象本身是无法赋值给一个变量的。如果在右侧写上了这样的变量，该变量所表示的引用将被复制给赋值目标处（左侧）的变量。对象本身并不会被复制。 var a = {x:2, y:3}  “变量 a 所引用的对象\u0026quot;.\u003c/p\u003e\n\u003cp\u003e在上下文不会发生误会的情况下，可以用“对象”这一术语来指代“对象的引用”。对象是一个实体，而引用是用于指示这一实体的位置信息，两者本应是不同的。不过根据上下文可以知\n道，“将对象赋值给变量 a”的说法很显然是指将对象的引用赋值，所以方便起见可以直接这么说。\u003c/p\u003e\n\u003ch3 id=\"变量和属性\"\u003e变量和属性\u003c/h3\u003e\n\u003cp\u003e很多读者都会觉得对象的属性和变量非常相似吧。两者都可以通过其名字（变量名或属性名）来获取其值，也都可以作为赋值对象，而写在赋值表达式的左侧。其实，在 JavaScript 中变量就是属性，两者何止是相似，本身就是同一个概念。全局变量和局部变量两者的本质都是属性。全局变量（以及全局函数名）是全局对象的属性。全局对象是从程序运行一开始就存在的对象。下面的代码证明，全局变量即为全局对象的属性。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var x = \u0026#39;foo\u0026#39;;  // 对全局变量 x 进行赋值\njs\u0026gt; print(this.x);  // 可以通过 this.x 进行访问\nfoo\njs\u0026gt; function fn() {return \u0026#34;functon\u0026#34;}; // 全局函数。\njs\u0026gt; \u0026#39;fn\u0026#39; in this; // 全局对象的属性 fn\ntrue\n\njs\u0026gt;this.fn() // \u0026#34;function\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最外层代码中的 this 引用是对全局对象的引用。因此上面代码中的 this.x，指的就是全局对象的属性 x，这也就是全局变量 x。\u003c/p\u003e\n\u003cp\u003e像下面这样，在最外层代码中将 this 引用的值赋值给全局变量 global 的话，这个变量就不但是全局对象的属性，同时也是一个对全局对象的引用，从而形成了一种自己引用自己的关系.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var global = this;  // 将 this 引用赋值给全局变量 global\njs\u0026gt; \u0026#39;global\u0026#39; in this; // 全局对象的属性 global\ntrue\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在最外层代码中对变量名进行查找，就是查找全局对象的属性。这其实只是换了一种说法，在最外层代码中能够使用的变量与函数，只有全局变量与全局函数而已。\u003c/p\u003e\n\u003cp\u003e至于对函数内的变量名的查找，前一节中已经介绍过，是按照先查找 Call 对象的属性，再查找全局对象的属性来进行的。这相当于在函数内可以同时使用局部变量（以及参数变量）与全局变量。对于\n嵌套函数的情况，则会由内向外依次查找函数的 Call 对象的属性，并在最后查找全局对象的属性。\u003c/p\u003e\n\u003ch3 id=\"对变量是否存在的检验\"\u003e对变量是否存在的检验\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evar a = a || 7;  // 一种习惯用法。如果变量 a 已经具有某值，则使用变量 a 的值\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 如果变量 a 已经具有某值，则使用变量 a 的值。代码示例（1）\nvar a;\nvar b = a || 7;\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 如果变量 a 已经具有某值，则使用变量 a 的值。代码示例（2）\nvar a;\nvar b = a !== undefined ? a : 7;\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 如果变量 a 已经具有某值，则使用变量 a 的值。代码示例（3）\n// （不使用 var a 的版本）\nif (typeof a !== \u0026#39;undefined\u0026#39;) {\n    var b = a;\n} else {\n    var b = 7;\n}\n// 从这里开始可以使用变量 b, 因为 Javascript 中没有块级作用域。\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可以在最外层代码中，像下面这样来判断在全局对象中是否存在属性 a，也就是说，可以用来检测\n全局变量 a 是否存在。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 用于判断变量 a 是否已经被声明的代码\nif (\u0026#39;a\u0026#39; in this) {\n    var b = a;\n} else {\n    var b = 7;\n}\n// 从这里开始可以使用变量 b\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"对属性是否存在的检验\"\u003e对属性是否存在的检验\u003c/h3\u003e\n\u003cp\u003e变量与属性实质上是一样的。不过，如果变量或属性本身不存在，处理方式则会有所不同。请看下面的例子：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; print(x); // 访问未声明的变量会导致 ReferenceError 异常\nReferenceError: x is not defined\njs\u0026gt; print(this.x);  // 访问不存在的属性并不会引起错误\nundefined\njs\u0026gt; var obj = {};\njs\u0026gt; print(obj.x); // 读取不存在的属性仅会返回 undefined 值，并不会引起错误\nundefined\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e读取不存在的属性仅会返回 undefined 值，而不会引起错误。但是如果对 undefined 值进行属性访问的话，则会像下面这样产生 TpyeError 异常。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; print(obj.x.y);\nTypeError: obj.x is undefined\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e为了避免产生 TypeError 异常，一般会使用下面的方法。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eobj.x \u0026amp;\u0026amp; obj.x.y\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e但如果是为了检测对象内是否存在某一属性，还请使用 in 运算符。\u003c/p\u003e\n\u003cp\u003e### 构造函数与 new 表达式\u003c/p\u003e\n\u003cp\u003e构造函数是用于生成对象的函数。可以直观地将代码清单 5.8 理解为 MyClass 类的类定义。在调用时通过 new 来生成一个对象实例。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 构造函数（类的定义）\nfunction MyClass(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\n// 对代码清单 5.8 的构造函数的调用\njs\u0026gt; var obj = new MyClass(3, 2);\njs\u0026gt; print(obj.x, obj.y);\n3 2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e从形式上来看，构造函数的调用方式如下。\n  ● 构造函数本身和普通的函数声明形式相同。\n  ● 构造函数通过 new 表达式来调用。\n  ● 调用构造函数的 new 表达式的值是（被新生成的）对象的引用。\n  ● 通过 new 表达式调用的构造函数内的 this 引用引用了（被新生成的）对象\u003c/p\u003e\n\u003cp\u003e- new 表达式的操作\u003c/p\u003e\n\u003cp\u003e在此说明一下 new 表达式在求值时的操作。首先生成一个不具有特别的操作对象。之后通过 new 表达式调用指定的函数（即构造函数）。构造函数内的 this 引用引用了新生成的对象。执行完构造函数后，它将返回对象的引用作为 new 表达式的值。new 表达式的操作就是以上这些。实际上其中还含有一个和原型链有关的问题，将会在之后进行说明。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"http://upload-images.jianshu.io/upload_images/326727-1c40083ea6bc56f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"img\"\u003e\u003c/p\u003e\n\u003cp\u003e构造函数总是由 new 表达式调用。为了和普通的函数调用区别开， 将使用 new 表达式的调用称为\u003cstrong\u003e构造函数的调用\u003c/strong\u003e。构造函数的名称一般以大写字母开始。(例如 MyClass)。\n构造函数在最后会\u003cstrong\u003e隐式地\u003c/strong\u003e执行 \u003ccode\u003ereturn this\u003c/code\u003e 操作。所以构造函数最终会返回新生成的这个对象。\u003c/p\u003e\n\u003ch3 id=\"构造函数与类的定义\"\u003e 构造函数与类的定义\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 模拟类定义（尚有改进的余地）\n\n// 相当于类的定义\nfunction MyClass(x, y) {\n    // 相当于域\n    this.x = x;\n    this.y = y;\n    // 相当于方法\n    this.show = function() {\n        print(this.x, this.y);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 对代码清单 5.9 中的构造函数的调用（实例生成）\njs\u0026gt; var obj = new MyClass(3, 2);\njs\u0026gt; obj.show();\n3 2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这段代码简单地实现了Javascript \u003cem\u003e类\u003c/em\u003e的定义， 但是有两个问题：\u003c/p\u003e\n\u003cp\u003e ● 由于所有的实例都是复制了同一个方法所定义的实体，所以效率（内存效率与执行效率）低下。\n ● 无法对属性值进行访问控制（private 或 public 等）。\u003c/p\u003e\n\u003cp\u003e前者可以通过\u003ccode\u003e原型继承\u003c/code\u003e来解决，后者可以通过\u003ccode\u003e闭包\u003c/code\u003e来解决。\u003c/p\u003e\n\u003ch3 id=\"属性的访问\"\u003e属性的访问\u003c/h3\u003e\n\u003cp\u003e通过点运算符和方括号运算符来访问对象的属性。在点运算符之后书写的属性名会被认为是标识符，而中括号运算符内的则是被转为字符串值的表达式。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var obj = { x:3, y:4 };\njs\u0026gt; print(obj.x); // 属性 x\n3\njs\u0026gt; print(obj[\u0026#39;x\u0026#39;]); // 属性 x\n3\njs\u0026gt; var key = \u0026#39;x\u0026#39;;\njs\u0026gt; print(obj[key]); // 属性 x（而非属性 key）\n3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e属性访问的\u003cstrong\u003e运算对象\u003c/strong\u003e并不是变量，而是\u003cstrong\u003e对象的引用\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; ({x:3, y:4}).x;  // 属性 x\n3\n\njs\u0026gt; ({x:3, y:4})[\u0026#39;x\u0026#39;];  // 属性 x\n3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现实中几乎不会对对象字面量进行运算。不过当这种运算对象不是一个变量时，倒是常常会以方法链之类的形式出现。\u003c/p\u003e\n\u003cp\u003e### 点运算符与中括号运算符在使用上的区别\u003c/p\u003e\n\u003cp\u003e只能使用中括号运算符的情况分为以下几种。\n  ● 使用了不能作为标识符的属性名的情况。\n  ● 将变量的值作为属性名使用的情况。\n  ● 将表达式的求值结果作为属性名使用的情况。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 含有横杠的属性名\njs\u0026gt; obj = { \u0026#39;foo-bar\u0026#39;:5 };\njs\u0026gt; obj.foo-bar; // 将解释为 obj.foo 减去 bar，从而造成错误\nReferenceError: bar is not defined\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e无法作为标识符被使用的字符串，仍可以在中括号运算符中使用。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; obj[\u0026#39;foo-bar\u0026#39;];  // 使用 [] 运算以字符串值指定了一个属性名。可以正常执行\n5\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"属性的枚举\"\u003e属性的枚举\u003c/h3\u003e\n\u003cp\u003e可以通过 for in 语句对属性名进行枚举（代码清单 5.10）。通过在 for in 语句中使用中括号运算符，可以间接地实现对属性值的枚举。使用 for each in 语句可以直接枚举属性值。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evar obj = { x:3, y:4, z:5 };\nfor (var key in obj) {\n    print(\u0026#39;key = \u0026#39;, key); // 属性名的枚举\n    print(\u0026#39;val = \u0026#39;, obj[key]); // 属性值的枚举\n}\n\n// 代码清单 5.10 的运行结果\nkey = x\nval = 3\nkey = y\nval = 4\nkey = z\nval = 5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e属性可以分为直接属性以及继承于原型的属性。for in 语句和 for each in 语句都会枚举继承于原型的属性。\u003c/p\u003e\n\u003cp\u003e### 作为关联数组的对象\u003c/p\u003e\n\u003cp\u003e在 JavaScript 中，必须通过对象来实现关联数组（字典、散列）\u003c/p\u003e\n\u003cp\u003e简单说来，原型继承指的是一种对象继承其他对象的属性并将其作为自身的属性一样来使用的做法。如下所示，从形式上来说，对象 obj 的属性并不是其直接属性，而是通过原型继承而得到的属性。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; function MyClass() {}\njs\u0026gt; MyClass.prototype.z = 5;  // 在原型链上设定属性 z\njs\u0026gt; var obj = new MyClass();  // 属性 z 继承了原型\njs\u0026gt; print(obj.z);\n5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003efor in 语句将枚举通过原型继承而得到的属性。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 接之前的代码\njs\u0026gt; for (var key in obj) { print(key); }  // for in 语句也会枚举通过原型继承得到的属性\nz\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e请注意，通过原型继承而得到的属性无法被 delete。继续接之前的代码。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 接之前的代码\njs\u0026gt; delete obj.z; // 尽管没有被 delete，但还是会返回 true……\n\ntrue\njs\u0026gt; print(obj.z); // 无法 delete 通过原型继承而得到的属性\n5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e即使通过使用空的对象字面量创建一个没有元素的空的关联数组， 也仍然会从 \u003cstrong\u003eObject\u003c/strong\u003e 类中继承原型的属性。 可以通过 in 运算对此进行检验。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var map = { };         // 通过空的对象字面量生成关联数组\njs\u0026gt; \u0026#39;toString\u0026#39; in map;    // map 所引用的对象从 Object 类中继承了属性 toString\ntrue\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e但是，通过 for in 语句对元素进行枚举不会有任何效果。这是由于 enumerable 属性的缘故，将在之后的小节中说明。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 接之前的代码\njs\u0026gt; for (var key in map) {\n　　　print(key);\n}\n// 没有元素会被枚举\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通过 in 运算符检测关联数组的键是否存在，就会发生与原型继承而来的属性相关的问题。因此，像下面这样通过 hasOwnProperty 来对其进行检测，是一种更安全的做法。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var map = {};\njs\u0026gt; map.hasOwnProperty(\u0026#39;toString\u0026#39;);      // 由于 toString 不是直接属性，因此结果为 false\nfalse\njs\u0026gt; map[\u0026#39;toString\u0026#39;] = 1;\njs\u0026gt; map.hasOwnProperty(\u0026#39;toString\u0026#39;);\ntrue\njs\u0026gt; delete map[\u0026#39;toString\u0026#39;];\njs\u0026gt; map.hasOwnProperty(\u0026#39;toString\u0026#39;);\nfalse\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e### 属性的属性\u003c/p\u003e\n\u003cp\u003e在标准的对象中有一部分属性的 enumerable 属性为假而无法通过 for in 语句枚举。其中一个很容易理解的例子是数列的 length 属性。\u003c/p\u003e\n\u003cp\u003e属性的属性名\n含义\u003c/p\u003e\n\u003cp\u003ewritable\n可以改写属性值\u003c/p\u003e\n\u003cp\u003eenumerable\n可以通过 for in 语句枚举\u003c/p\u003e\n\u003cp\u003econfigurable\n可以改变属性的属性。可以删除属性\u003c/p\u003e\n\u003cp\u003eget\n可以指定属性值的 getter 函数\u003c/p\u003e\n\u003cp\u003eset\n可以指定属性值的 setter 函数\u003c/p\u003e\n\u003ch3 id=\"垃圾回收\"\u003e垃圾回收\u003c/h3\u003e\n\u003cp\u003e不再使用的对象的内存将会自动回收，这种功能称作垃圾回收。所谓不再使用的对象，指的是没有被任何一个**属性（变量）**引用的对象。\u003c/p\u003e\n\u003cp\u003e循环引用会造成内存泄漏。所谓循环引用，指的是对象通过属性相互引用而导致它们不会被判定为不再使用的状态。\u003c/p\u003e\n\u003cp\u003e### 不可变对象\u003c/p\u003e\n\u003cp\u003e所谓不可变对象，指的是在被生成之后状态不能再被改变的对象。由于对象的状态是由其各个属性的值所决定的，因此从形式上来说也是指无法改变属性的值的对象\u003c/p\u003e\n\u003cp\u003eJavaScript 中的一种典型的不可变对象就是字符串对象。\u003c/p\u003e\n\u003cp\u003e在 JavaScript 中可以通过以下方式实现对象的不可变。\u003c/p\u003e\n\u003cp\u003e  ● 将属性（状态）隐藏，不提供变更操作。\n  ● 灵活运用 ECMAScript 第 5 版中提供的函数。\n  ● 灵活运用 writable 属性、configurable 属性以及 setter 和 getter。\u003c/p\u003e\n\u003cp\u003e为了将属性隐藏，可以使用一种被称为闭包的方法。\u003c/p\u003e\n\u003cp\u003e在 ECMAScript 第 5 版中有一些用于支持对象的不可变化的函数（表 5.2）。seal 可以向下兼容 preventExtensions，freeze 可以向下兼容 seal。这里的向下兼容，指的是比后者有更为严格的限制。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eECMAScript 第 5 版中用于支持对象的不可变化的函数\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e方法名\n属性新增\n属性删除\n属性值变更\n确认方法\u003c/p\u003e\n\u003cp\u003epreventExtensions\nX\nO\nO\nObject.isExtensible\u003c/p\u003e\n\u003cp\u003eseal\nX\nX\nO\nObject.isSealed\u003c/p\u003e\n\u003cp\u003efreeze\nX\nX\nX\nObject.isFrozen\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eObject.preventExtensions 的例子\u003c/strong\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var obj = { x:2, y:3 };\njs\u0026gt; Object.preventExtensions(obj);\n// 无法新增属性\njs\u0026gt; obj.z = 4;\njs\u0026gt; Object.keys(obj);\n[\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;]\n// 可以删除属性\njs\u0026gt; delete obj.y;\njs\u0026gt; Object.keys(obj);\n[\u0026#34;x\u0026#34;]\n// 可以更改属性值\njs\u0026gt; obj.x = 20;\njs\u0026gt; print(obj.x);\n20\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eObject.seal 的例子\u003c/strong\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var obj = { x:2, y:3 };\njs\u0026gt; Object.seal(obj);\n// 无法删除属性\njs\u0026gt; delete obj.y; // 将返回 false\njs\u0026gt; Object.keys(obj);\n[\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;]\n// 可以更改属性值\njs\u0026gt; obj.x = 20;\njs\u0026gt; print(obj.x);\n20\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eObject.freeze 的例子\u003c/strong\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; var obj = { x:2, y:3 };\njs\u0026gt; Object.freeze(obj);\n// 无法更改属性值\njs\u0026gt; obj.x = 20;\njs\u0026gt; print(obj.x);\n2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e● 一旦更改就无法还原。\n● 如果想让原型继承中的被继承方也不可变化，需要对其进行显式的操作。\u003c/p\u003e\n\u003ch2 id=\"方法-1\"\u003e方法\u003c/h2\u003e\n\u003cp\u003e我们将作为对象属性的函数称为方法。那些使用了 this 引用来调用并访问了对象的属性的函数，被称为方法。\u003c/p\u003e\n\u003ch3 id=\"this-引用\"\u003ethis 引用\u003c/h3\u003e\n\u003cp\u003ethis 引用有着会根据代码的上下文语境自动改变其引用对象的特性。\u003c/p\u003e\n\u003cp\u003e在此，总结一下 this 引用的规则。\u003c/p\u003e\n\u003cp\u003e● 在最外层代码中，this 引用引用的是全局对象。\n● 在函数内，this 引用根据函数调用方式的不同而有所不同（参见表 5.3）。\u003c/p\u003e\n\u003cp\u003e对于函数内部的情况，this 引用的引用对象并不是根据函数的内容或声明方式而改变的，而是根据其调用方式而改变。也就是说，即使是同一个函数，如果调用方式不同，this 引用的引用对象也会有所不同。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e函数内部的 this 引用\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e函数的调用方式\nthis 引用的引用对象\u003c/p\u003e\n\u003cp\u003e构造函数调用\n所生成的对象\u003c/p\u003e\n\u003cp\u003e方法调用\n接收方对象\u003c/p\u003e\n\u003cp\u003eapply 或是 call 调用\n由 apply 或 call 的参数指定的对象\u003c/p\u003e\n\u003cp\u003e其它方式的调用\n全局对象\u003c/p\u003e\n\u003cp\u003e对于构造函数调用的情况，this 引用的引用对象是所生成的对象。 上表中的方法调用的说明中的\u003cstrong\u003e接收方对象\u003c/strong\u003e是这样一种对象： ● 通过点运算符或中括号运算符调用对象的方法时，在运算符左侧所指定的对象。\u003c/p\u003e\n\u003cp\u003e方法是对象的属性所引用的函数。下面是一个关于方法和接收方对象的具体例子。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 对象定义\njs\u0026gt; var obj = {\n    x:3,\n    doit: function() { print(\u0026#39;method is called.\u0026#39; + this.x ); }\n};\njs\u0026gt; obj.doit();  // 对象 obj 是接收方对象。doit 是方法。\nmethod is called. 3\njs\u0026gt; obj[\u0026#39;doit\u0026#39;]();  // 对象 obj 是接收方对象。doit 是方法。\nmethod is called. 3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在说明上面的例子。首先是将对象的引用赋值给了变量 obj。这个对象有两个属性。属性 x 的值为数值 3，属性 doit 的值是一个函数。将该函数称为方法 doit。可以通过点运算符或中括号运算符对 obj 调用方法 doit。这时，方法调用的目标对象被称为接收方对象（也就是说，obj 所引用的对象是一个接收方对象）。被调用的方法内的 this 引用引用了该接收方对象。\u003c/p\u003e\n\u003ch3 id=\"this-引用注意点\"\u003ethis 引用注意点\u003c/h3\u003e\n\u003cp\u003e 在 Java 中, this 所引用的接收方对象始终是该类的实例, 而在 Javascript 中却不一定总是如此。Javascript 的 this 引用的引用对象会随着方法调用方式的不同而改变。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evar obj = { \n    x : 3;\n    doit: function() { print(\u0026#39;method is called.\u0026#39; + this.x ); }\n}\n\nvar fn = obj.doit;       // 将 ojb.doit 引用的 Function 对象赋值给全局变量\nfn();                          // 函数内的 this 引用引用了全局对象, 现在全局变量中还没有定义变量 x, 所以下面会打印 undefined\nmethod is called. undefined\nvar x = 5;                 // 确认 this 引用确实引用了全局对象\nfn();\nmethod is called. 5\nvar obj2 = { x:4, doit2:fn };  //  将obj的方法（Function对象的引用）赋值给了另一个对象obj2的属性\nobj2.doit2(); // 方法内的 this 引用引用了对象 obj2\nmethod is called. 4\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"在方法内部调用方法的情况\"\u003e在方法内部调用方法的情况\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// 从 doit 方法内调用 doit2 方法时，必须通过 this 引用，以 this.doit2() 的方式实现\njs\u0026gt; var obj = {\nx:3,\ndoit: function() { print(\u0026#39;doit is called.\u0026#39; + this.x ); this.doit2(); },\ndoit2: function() { print(\u0026#39;doit2 is called.\u0026#39; + this.x); }\n};\njs\u0026gt; obj.doit();\ndoit is called. 3\ndoit2 is called. 3\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"apply-与-call\"\u003eapply 与 call\u003c/h3\u003e\n\u003cp\u003e在 Function 对象中包含 apply 与 call 这两种方法，通过它们调用的函数的 this 引用，可以指向任意特定的对象。也就是说，可以理解为它们能够显式地指定接收方对象。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; function f() { print(this.x); }\njs\u0026gt; var obj = { x:4 };\njs\u0026gt; f.apply(obj); // 通过 apply 调用函数 f。函数内的 this 引用引用了对象 obj\n4\njs\u0026gt; f.call(obj); // 通过 call 调用函数 f。函数内的 this 引用引用了对象 obj\n4\n// 将接收方对象指定为另一个对象并进行方法调用\njs\u0026gt; var obj = {\n    x:3,\n    doit: function() { print(\u0026#39;method is called.\u0026#39; + this.x ); }\n};\njs\u0026gt; var obj2 = { x:4 };\njs\u0026gt; obj.doit.apply(obj2);  // 通过 apply 调用 obj.doit 方法。方法内的 this 引用引用了对象 obj2\n\nmethod is called. 4\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e apply 与 call 之间的不同之处在于两者对其他参数的传递方式。对于 apply 来说，剩余的参数将通过数组来传递，而 call 是直接按原样传递形参。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ejs\u0026gt; function f(a, b) { print(\u0026#39;this.x = \u0026#39; + this.x + \u0026#39;, a = \u0026#39; + a + \u0026#39;, b = \u0026#39; + b); }\njs\u0026gt; f.apply({x:4}, [1, 2]);  // 作为第 2 个参数的数列中的元素都是函数 f 的参数\nthis.x = 4, a = 1, b = 2\njs\u0026gt; f.call({x:4}, 1, 2);  // 从第 2 个参数起的参数都是函数 f 的参数\nthis.x = 4, a =1 , b = 2\n\u003c/code\u003e\u003c/pre\u003e","text":"函数JavaScript 的函数是一种对象。 对象 Javascript 中没有类这样的语言结构, Javascript 中的对象是一个 名称与值配对的集合。这样一对儿名称和值的配对被称为属性。例如一个人的属性有:\n身高: 178cm 体重 65kg 年龄 28 所以, Javascript 对象可以定义为属性 的集合。Javascript 的对象字面量：\n// 对象字面量表达式的语法 { 属性名 : 属性值, 属性名 : 属性值, ...... } 属性名可以是标识符。字符串和数值：\n// 对象字面量表达式的例子 { x: 2, y:1 } // 属性名是标识符 { \u0026#34;x\u0026#34;:2, \u0026#34;y\u0026#34;:1 } // 属性名是字符串值 { \u0026#39;x\u0026#39;:2, \u0026#39;y\u0026#39;:1 } // 属性名是字符串值 { 1:2, 2:1 } // 属性名是数值 { x:2, y:1, enable:true, color:{ r:255, g:255, b:255 } } // 各种类型的属性值 对对象字面量表达式求值所得到的结果，是所生成对象的一个引用。\n// 对象字面量表达式与赋值表达式 js\u0026gt; var obj = { x:3, y:4 }; // 所生成对象的引用将被赋值给变量 obj js\u0026gt; typeof obj; // 通过 typeof 运算符来判别 obj 的类型，得到的结果是 object object 属性访问 通过点语法和方括号访问属性：\njs\u0026gt; var obj = {x:3, y:4} js\u0026gt; typeof(obj) \u0026#34;object\u0026#34; js\u0026gt; print(obj.x) 3 js\u0026gt; print(obj[\u0026#39;x\u0026#39;]) 3 方法 可以把任意类型的值、对象或者函数赋值给对象的属性。正如前节所讲，对匿名函数表达式求值所 得到的结果是函数对象的引用，所以，也可以像下面这样来书写。\njs\u0026gt; obj.fn = function (a, b) {return Number(a) + Number(b); }; // 将函数赋值给对象 obj 的属性 fn 可以像下面这样，对被赋值给属性的函数进行调用。\njs\u0026gt; obj.fn(3, 4); // 调用函数 7 回顾一下之前章节的说明可以发现，在代码清单 2.2 之后还可以像下面这样书写。\njs\u0026gt; obj.fn2 = sum; // sum 是在代码清单 2.2 中定义的函数 js\u0026gt; obj.fn2(3, 4); // 调用函数 7 数组 Javascript 中数组中的元素可以是不同的类型：\nvar arr = [1, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, 5] print(arr[1]) /// foo 数据类型 像 Java 这样，变量具有数据类型的语言，被称为静态数据类型语言；而像 JavaScript 这样，变量没有类型的语言，则被称为动态数据类型语言。 在 JavaScript 中，字符串值会被隐式地转换为字符串对象类型\n在 JavaScript 中书写 \u0026lsquo;012\u0026rsquo;.lenght 的话，（属于内建类型的）字符串值会先被隐式地转换为 字符串对象 ，然后再读取字符串对象的 length 属性。隐式类型转换也能反向进行。\nvar sobj = new String(\u0026#39;abc\u0026#39;); // 生成字符串对象 var s = sobj + \u0026#39;def\u0026#39;; // 将字符串对象隐式转换为了字符串值 print(s); // abcdef 字符串值和字符串对象之间可以进行隐式类型转换。因此，一般来说并不需要在意值和对象之间的 区别。不过正因看起来非常相似，所以会存在一些陷阱。例如，在判定两者是否相等上是有差异的。对 象的相等运算，判断的是两者是否引用了同一个对象（而非两者的内容是否相同）。\njs\u0026gt; var sobj1 = new String(\u0026#39;abc\u0026#39;); js\u0026gt; var sobj2 = new String(\u0026#39;abc\u0026#39;); js\u0026gt; sobj1 == sobj2; // 虽然字符串的内容相同，但是并非引用了同一个对象，所以结果是 false false js\u0026gt; sobj1 === sobj2; // 虽然字符串的内容相同，但是并非引用了同一个对象，所以结果是 false false js\u0026gt; sobj3 = sobj2 (new String(\u0026#34;abc\u0026#34;)) js\u0026gt; sobj3 == sobj2 true js\u0026gt; sobj3 === sobj2 true 上面的两个字符串对象，在通过 + 与空字符串值连接之 后，就会进行隐式数据类型转换而变为字符串值，从而结果也将发生变化。（比较的是两者的内容是否相同）\n// 继续之前的代码（以下只是用于说明的代码，实际中并不推荐这样使用） js\u0026gt; sobj1 + \u0026#39;\u0026#39; == sobj2 + \u0026#39;\u0026#39;; true js\u0026gt; sobj1 + \u0026#39;\u0026#39; === sobj2 + \u0026#39;\u0026#39;; true 对于字符串值和字符串对象的等值判断，如果使用的是会进行隐式数据类型转换的 == 运算，则只会判定其内容是否相同，如果内容相同则结果为真。\njs\u0026gt; var sobj = new String(\u0026#39;abc\u0026#39;); js\u0026gt; var s = \u0026#39;abc\u0026#39;; js\u0026gt; sobj == s; // 进行数据类型转换的等值运算的结果为 true true; js\u0026gt; sobj === s; // 不进行数据类型转换的等值运算的结果为 false false 要尽量避免显式地使用 new Stirng 生成字符串对象。尽情享受隐式转换就好了。\njs\u0026gt; var s = \u0026#39;abc\u0026#39;; // 返回字符串值下标为 1 的字符 js\u0026gt; s.charAt(1); b js\u0026gt; \u0026#39;abc\u0026#39;.charAt(1); // 对于字符串字面量也能像这样进行方法调用 b 调用 String 函数进行显式数据类型转换：\njs\u0026gt; var s = String(\u0026#39;abc\u0026#39;); js\u0026gt; typeof s; // 变量 s 的值是字符串型 string js\u0026gt; var s = String(47); // 由数值类型向字符串值类型的显式数据类型变换 js\u0026gt; print(s); 47 js\u0026gt; typeof s; // 变量 s 的值是字符串型 string String 类的函数以及构造函数调用\n函数或是构造函数 说明\nString([value]) 将参数 value 转换为字符串值类型\nnew String([value]) 生成 String 类的实例\nString类的属性\n属性名 说明\nfromCharCode([char0[,char1,\u0026hellip;]]) 将参数 value 转换为字符串值类型\nlength 值为1\nprototype 原型链\nString.prototype 对象所具有的属性\n属性名 说明\ncharAt(pos) 返回下标 pos 位置字符长度为 1 的字符串值。下标从 0 开始。如果下标超界则返回空字符串值\ncharCodeAt(pos) 返回下标 pos 位置处字符的字符编码。如果超过了下标的范围, 则返回 NaN\nconcat([string0, string1,\u0026hellip;]) 和参数字符串相连接后返回新的字符串值\nconstructor 引用一个 String 类对象\nindexOf(searchString[, pos]) 返回在字符串中第一个遇到的字符串值 searchString 的下标值。可以通过第二个可选参数指定搜索的起始位置。如果没有找到符合条件的结果, 则返回 -1\nlocaleCompare(that) 比较和本地运行环境相关的字符串。根据比较的结果分别返回正数、0 或者负数\nmatch(regexp) 返回匹配正则表达式 regexp 的结果\nquote() Javascript 自定义的增强功能。在字符串外加上双引号之后返回这一新的字符串值\nreplace(searchValue, replaceValue) 将 searchValue (正则表达式活字符串值) 替换为 replaceValue (字符串或函数) 后返回经过替换后的字符串\nsearch(regexp) 返回匹配正则表达式 regexp 的位置的下标\nslice(start, end) 将参数 start 开始至 end 结束的字符串部分作为新的字符串返回。 如果 start 和 end 是负数, 则返回从末尾逆向起数的下标值\nsplit(separator, limit) 根据字符串或正则表达式形式的参数 separator 将字符串分割, 返回相应的字符串值数组\nsubstring(start, end) 将参数 start 开始至 end 结束的字符串部分作为新的字符串返回。其作用和 slice 相同, 但是不支持以负数作为参数\ntoLocaleLowerCase() 将字符串中所有字符转换为和本地环境相应的小写字符\ntoLocaleUpperCase() 将字符串中所有字符转换为和本地环境相应的大写字符\ntoLowerCase() 将字符串中所有字符转换为小写字符\ntoSource() Javascript 自定义的增强功能。返回用于生成 String 实例的字符串(即源代码)\ntoString() 将 Stirng 实例转换为字符串值(并返回)\ntoUpperCase() 将字符串中的所有字符转换为大写字符\ntrim() 去除字符串前后的空白符\ntrimLeft() Javascript 自定义的增强功能。去除字符串左侧(头部) 的空白符\ntrimRight() Javascript 自定义的增强功能。去除字符串右侧(尾部) 的空白符\nvalueOf() 将 String 实例转换为字符串值并返回\n还可以像下面这样，通过数值属性获取指定下标的字符（不过这是 JavaScript 自定义的增强功能）。其返回值是一个 String 对象。\njs\u0026gt; var s = new String(\u0026#39;abc\u0026#39;); js\u0026gt; print(s[1]); // 下标为 1 的字符 b js\u0026gt; print(\u0026#39;abc\u0026#39;[2]); // 由于有隐式数据类型转换，所以对字符串值也能进行这样的操作 c 数值 Javascript 中， 大部分情况下浮点数只能表达数值的近似值。\njs\u0026gt; 0.1 + 0.2; // 0.1 与 0.2 的和并不是 0.3。 0.30000000000000004 js\u0026gt; (0.1 + 0.2) == 0.3 // 两者不一致。 false js\u0026gt; (0.1 + 0.2) === 0.3 // 两者不一致。 false js\u0026gt; 1/3 // 1 除以 3 之后的近似结果。 0.333333333333333 js\u0026gt; 10/3 – 3; // 这同样是近似值。 0.333333333333333 js\u0026gt; (10/3 – 3) == (1/3); // 这两个近似值是不一致的。 false js\u0026gt; (10/3 – 3) === (1/3); false 而 Raku 就不会出现这种情况。数值也存在数值对象：\njs\u0026gt; var nobj = new Number(1); js\u0026gt; var nobj1 = new Number(1); js\u0026gt; nobj == nobj1; // 虽然值是相同的，但是所引用的对象不同，因而结果为 false false js\u0026gt; nobj === nobj1; // 虽然值是相同的，但是所引用的对象不同，因而结果为 false false js\u0026gt; nobj == 1; // 会进行数据类型转换的等值运算结果为 true true js\u0026gt; nobj === 1; // 不会进行数据类型转换的等值运算结果为 false false 调用 Number 函数：\njs\u0026gt; var n1 = Number(1); js\u0026gt; typeof n1; // 变量 n1 的值为数值 number js\u0026gt; n1 == 1; true js\u0026gt; n1 === 1; true js\u0026gt; var n = Number(\u0026#39;1\u0026#39;); // 从字符串值至数值型的显式数据类型转换 第四章 Javascript 标识符区分大小写。JavaScript（准确地说是 ECMAScript）的代码块中的变量并不存在块级作用域这样 的概念。\n// 变量声明的例子 var foo; var foo, bar; // 同时声明多个变量 var foo = \u0026#39;FOO\u0026#39;, bar = \u0026#39;BAR\u0026#39;; // 在声明变量的同时进行初始化 Javascript 中的 switch/case\nvar x = 0; switch (x) { case 0: print(\u0026#34;0\u0026#34;); case 1: print(\u0026#34;1\u0026#34;); case 2: print(\u0026#34;2\u0026#34;); default: print(\u0026#34;default\u0026#34;); break; } 使用 switch 语句时，等值比较表达式可以被隐藏起来，所以与使用了等值比较的 if-else 语句相比表达 上更为简洁。需要注意的是，switch 语句所隐藏的等值比较运算是不会对数据类型进行转换的 === 运算。 如果原来的 if-else 语句中的表达式使用的是 == 运算的话，就可能会在执行上有一些细微的差别\nvar s = \u0026#39;foo\u0026#39;; switch (s) { // 可以在 switch 表达式中使用字符串值。 // 可以在 case 表达式中使用和 switch 表达式类型不同的值。 // s === 0 的值为假，所以将继续进行比较。 case 0: print(\u0026#39;not here\u0026#39;); break; // 可以在 case 表达式中使用含有变量的表达式。 // s === s.length 的值为假，所以将继续进行比较。 case s.length: print(\u0026#39;not here\u0026#39;); break; // 可以在 case 表达式中使用方法调用表达式。 // s === (0).toString() 的值为假，所以将继续进行比较。 case (0).toString(); print(\u0026#39;not here\u0026#39;); break; // 还可以在 case 表达式中书写这样的表达式。 // s === \u0026#39;f\u0026#39; + \u0026#39;o\u0026#39; + \u0026#39;o\u0026#39; 为真，所以将执行以下的代码。 case \u0026#39;f\u0026#39; + \u0026#39;o\u0026#39; + \u0026#39;o\u0026#39;: print(\u0026#39;here\u0026#39;); break; // 如果所有的 case 表达式在等值运算（===）后得到的结果都为假，则执行以下的代码。 default: print(\u0026#39;not here\u0026#39;); break; } 标签：\n// 使用标签来同时跳出嵌套的循环 outer_loop: while (true) { print(\u0026#34;outer loop\u0026#34;); while (true) { print(\u0026#34;inner loop\u0026#34;); break outer_loop; } } 外层循环被标以 outer_loop 的标签（此前提到过，请再回想一下，while 循环以及相应的代码块共同组成了一句语句）。\n异常：\n// try-catch-finally 结构的语法 try { 语句 语句 …… } catch ( 变量名 ) { // 该变量是一个引用了所捕捉到的异常对象的局部变量 语句 语句 …… } finally { 语句 语句 …… } 在 try 语句之外，或者没有 catch 子句的 try 语句，都是无法捕捉异常的。这时函数会中断并返回至调用该函数之处。\nfinally 子句必定会在跳出 try 语句之时被执行。即使没有产生异常，finally 子句也会被执行。也就是说，如果没有产生异常的话，在执行完 try 子句之后会继续执行 finally 子句的代码；如果产生了异常，则会在执行 finally 子句之前首先执行 catch 子句。对于没有 catch 子句的 try 语句来说，异常将会被直接传 递至上一层，但 finally 子句仍然会被执行。\n代码清单 4.9 try 语句的执行示例\ntry { print(\u0026#39;1\u0026#39;); null.x; // 在此处强制产生一个 TypeError 异常 print(\u0026#39;not here\u0026#39;); // 这条语句不会被执行 } catch (e) { // 对象 e 是 TypeError 对象的一个引用 print(\u0026#39;2\u0026#39;); } finally { print(\u0026#39;3\u0026#39;); } // 代码清单 4.9 的运行结果 1 2 3 with 表达式：\nwith 语句用于临时改变名称（变量名或是函数名）的查找范围。with 语句中使用的表达式是 Object 类型的。如果使用了其他类型的值，则会被转换为 Object 类型。在 with 语句内对变量名进行查找时，将 会从所指定对象的属性开始寻找。\n// with 语句的例子 js\u0026gt; var x = 1; // 全局变量 js\u0026gt; var obj = { x:7, y:8 }; js\u0026gt; with (obj) { print(x); // 如果要查找变量 x，则会在查找全局变量 x 之前先查找到 obj.x } 7 注释：\n// 单行注释 /* 注释 */ 运算符和操作数在英语中分别称为 operator 和 operand。\n// 赋值表达式的结合律为右结合 x = y = z = 0; 将以 x = (y = (z = 0); 的方式被求值 在 JavaScript 所有算术运算中的数值都是浮点小数。\nECMAScript 中，=== 被称为 Strict Equals 运算符，而 == 则被称为 Equals 运算符。 将 Strict Equals 运算符（===）称为全等运算符，而将 Equals 运算符（==）称为相等运算符。两者的区别在于，是否会在进行相等判定时进行数据类型转换。 全等运算不会进行数据类型转换，因此数据类型是否一致也是判断是否相等的内容之一。而相等运算 （==）会先进行数据类型转换，在数据类型相同后再进行相等判断。两种运算符的运算结果都是布尔值。\n下面总结了全等运算的一些特性。\n1. x 与 y 如果数据类型不相符，则结果为假。 2. 两者都是 undefined 值或两者都是 null 值的情况，结果为真。 3. 两者都是数值，但有一方为 NaN，或者两者都是 NaN 的情况，结果为假。否则，如果数值相等则结果为真，不相等则为假。 4. 两者都是字符串的情况下，如果内容一致则结果为真，否则结果为假。 5. 两者都是布尔值的情况下，如果值一致则结果为真，否则结果为假。 6. 两者都是对象引用的情况下，如果引用的是同一个对象则结果为真，否则结果为假。 相等运算 == 由于会进行隐式数据类型转换，所以其执行方式更为复杂。下面是对其运算规则的总结。\n● x 与 y 的数据类型相同时，与全等运算的结果相同。 ● x 与 y 的数据类型不同时，判定规则如下。 （1）一方为 null 值，另一方为 undefined 值的情况，结果为真。 （2）一方为数值，另一方为字符串值的情况，将字符串值转换为数值之后对数值进行比较。 （3）一方为布尔值，另一方为数值的情况，将布尔值转换为数值之后对数值进行比较。 （4）一方为布尔值，另一方为字符串值的情况，将两者都转换为数值后对数值进行比较。 （5）一方为数值，另一方为对象引用的情况，将对象引用转换为数值后对数值进行比较。 （6）一方为字符串值，另一方为对象引用的情况，将对象引用转换为字符串值后对字符串的内容进行比较。 （7）以上 6 种情况之外的运算结果都为假\nvoid 运算符：\n无论向其传递什么操作数，其运算结果都会是 undefined 值。下面是一个具体的例子。\njs\u0026gt; print(void 0); // 操作数为数值 undefined js\u0026gt; print(void \u0026#39;x\u0026#39;); // 操作数为字符串值 undefined js\u0026gt; var x = 0; js\u0026gt; void x++; // 由于会先对操作数进行求值，所以 x 将自增 js\u0026gt; print(x); 1 js\u0026gt; void(x); // 常常会把操作数通过括号包围起来 在客户端 JavaScript 中有不少相关的习惯用法。下面是一个在 HTML 中点击了标签 a 之后发送表单内容的 JavaScript 代码的例子。\n\u0026lt;a href=\u0026#34;javascript:void(document.form.submit())\u0026#34;\u0026gt; 发送 HTML 表单数据但不跳转页面 \u0026lt;/a\u0026gt; hred 属性中所写的表达式如果具有值的话，则会被标签 a 认为是 URL 并跳转至该页面。为了阻止标签 a 的这一行为，需要将 href 属性中表达式的值强制设为 undefined 值。对此最为简单的惯用方法就是通过 void 运算来实现。\n逗号运算符（,）是一个双目运算符，其作用为依次对其左操作数与右操作数求值。逗号运算符的运 算结果是其右操作数的值，也就是说其结果的类型取决于所使用的操作数。下面是一个具体的例子。\njs\u0026gt; print((x = 1, y = 2)); // 请注意，如果不在真个参数外加括号的话，其含义就会变为参数的数量是两个 2 js\u0026gt; print((x = 1, ++x, ++x)); // 由于是左结合，相当于 ((x = 1, ++x), ++x) 3 字符 .（点）称为点运算符，中括号 [] 称为中括号运算符，它们都是用于访问属性的运算符。虽然这 两个运算符不太显眼，却有着很重要的作用。 其左操作数为对象引用，右操作数为属性名。如果左操作数不是对象引用的话，则会被转换为 Object 类型。点运算符的右操作数是一个用于表示属性名的标识符，而中括号运算符的右操作数为字符 串型或是可以被转换为字符串型的值。\n第五章 变量与对象 var a = a || 7; // 一种习惯用法。如果变量 a 已经具有某个值（严格来说是具有某个可以被转换为 true 的值）就直接使用，否则就把 7 赋值给 a 准确地说，对象的赋值其实是将对象的引用进行赋值。变量有值类型和引用类型。将基本类型的值赋值给变量的话，变量将把这个值本身保存起来。这时，可以将变量简单地理解为一个装了该值的箱子。变量本身装有所赋的这个值，所以能够将该值从变量中取出。\n如果将一个对象赋值给变量，其实是把这个对象的引用赋值给了该变量。对象本身是无法赋值给一个变量的。如果在右侧写上了这样的变量，该变量所表示的引用将被复制给赋值目标处（左侧）的变量。对象本身并不会被复制。 var a = {x:2, y:3} “变量 a 所引用的对象\u0026quot;.\n在上下文不会发生误会的情况下，可以用“对象”这一术语来指代“对象的引用”。对象是一个实体，而引用是用于指示这一实体的位置信息，两者本应是不同的。不过根据上下文可以知 道，“将对象赋值给变量 a”的说法很显然是指将对象的引用赋值，所以方便起见可以直接这么说。\n变量和属性 很多读者都会觉得对象的属性和变量非常相似吧。两者都可以通过其名字（变量名或属性名）来获取其值，也都可以作为赋值对象，而写在赋值表达式的左侧。其实，在 JavaScript 中变量就是属性，两者何止是相似，本身就是同一个概念。全局变量和局部变量两者的本质都是属性。全局变量（以及全局函数名）是全局对象的属性。全局对象是从程序运行一开始就存在的对象。下面的代码证明，全局变量即为全局对象的属性。\njs\u0026gt; var x = \u0026#39;foo\u0026#39;; // 对全局变量 x 进行赋值 js\u0026gt; print(this.x); // 可以通过 this.x 进行访问 foo js\u0026gt; function fn() {return \u0026#34;functon\u0026#34;}; // 全局函数。 js\u0026gt; \u0026#39;fn\u0026#39; in this; // 全局对象的属性 fn true js\u0026gt;this.fn() // \u0026#34;function\u0026#34; 最外层代码中的 this 引用是对全局对象的引用。因此上面代码中的 this.x，指的就是全局对象的属性 x，这也就是全局变量 x。\n像下面这样，在最外层代码中将 this 引用的值赋值给全局变量 global 的话，这个变量就不但是全局对象的属性，同时也是一个对全局对象的引用，从而形成了一种自己引用自己的关系.\njs\u0026gt; var global = this; // 将 this 引用赋值给全局变量 global js\u0026gt; \u0026#39;global\u0026#39; in this; // 全局对象的属性 global true 在最外层代码中对变量名进行查找，就是查找全局对象的属性。这其实只是换了一种说法，在最外层代码中能够使用的变量与函数，只有全局变量与全局函数而已。\n至于对函数内的变量名的查找，前一节中已经介绍过，是按照先查找 Call 对象的属性，再查找全局对象的属性来进行的。这相当于在函数内可以同时使用局部变量（以及参数变量）与全局变量。对于 嵌套函数的情况，则会由内向外依次查找函数的 Call 对象的属性，并在最后查找全局对象的属性。\n对变量是否存在的检验 var a = a || 7; // 一种习惯用法。如果变量 a 已经具有某值，则使用变量 a 的值 // 如果变量 a 已经具有某值，则使用变量 a 的值。代码示例（1） var a; var b = a || 7; // 如果变量 a 已经具有某值，则使用变量 a 的值。代码示例（2） var a; var b = a !== undefined ? a : 7; // 如果变量 a 已经具有某值，则使用变量 a 的值。代码示例（3） // （不使用 var a 的版本） if (typeof a !== \u0026#39;undefined\u0026#39;) { var b = a; } else { var b = 7; } // 从这里开始可以使用变量 b, 因为 Javascript 中没有块级作用域。 可以在最外层代码中，像下面这样来判断在全局对象中是否存在属性 a，也就是说，可以用来检测 全局变量 a 是否存在。\n// 用于判断变量 a 是否已经被声明的代码 if (\u0026#39;a\u0026#39; in this) { var b = a; } else { var b = 7; } // 从这里开始可以使用变量 b 对属性是否存在的检验 变量与属性实质上是一样的。不过，如果变量或属性本身不存在，处理方式则会有所不同。请看下面的例子：\njs\u0026gt; print(x); // 访问未声明的变量会导致 ReferenceError 异常 ReferenceError: x is not defined js\u0026gt; print(this.x); // 访问不存在的属性并不会引起错误 undefined js\u0026gt; var obj = {}; js\u0026gt; print(obj.x); // 读取不存在的属性仅会返回 undefined 值，并不会引起错误 undefined 读取不存在的属性仅会返回 undefined 值，而不会引起错误。但是如果对 undefined 值进行属性访问的话，则会像下面这样产生 TpyeError 异常。\njs\u0026gt; print(obj.x.y); TypeError: obj.x is undefined 为了避免产生 TypeError 异常，一般会使用下面的方法。\nobj.x \u0026amp;\u0026amp; obj.x.y 但如果是为了检测对象内是否存在某一属性，还请使用 in 运算符。\n### 构造函数与 new 表达式\n构造函数是用于生成对象的函数。可以直观地将代码清单 5.8 理解为 MyClass 类的类定义。在调用时通过 new 来生成一个对象实例。\n// 构造函数（类的定义） function MyClass(x, y) { this.x = x; this.y = y; } // 对代码清单 5.8 的构造函数的调用 js\u0026gt; var obj = new MyClass(3, 2); js\u0026gt; print(obj.x, obj.y); 3 2 从形式上来看，构造函数的调用方式如下。 ● 构造函数本身和普通的函数声明形式相同。 ● 构造函数通过 new 表达式来调用。 ● 调用构造函数的 new 表达式的值是（被新生成的）对象的引用。 ● 通过 new 表达式调用的构造函数内的 this 引用引用了（被新生成的）对象\n- new 表达式的操作\n在此说明一下 new 表达式在求值时的操作。首先生成一个不具有特别的操作对象。之后通过 new 表达式调用指定的函数（即构造函数）。构造函数内的 this 引用引用了新生成的对象。执行完构造函数后，它将返回对象的引用作为 new 表达式的值。new 表达式的操作就是以上这些。实际上其中还含有一个和原型链有关的问题，将会在之后进行说明。\n构造函数总是由 new 表达式调用。为了和普通的函数调用区别开， 将使用 new 表达式的调用称为构造函数的调用。构造函数的名称一般以大写字母开始。(例如 MyClass)。 构造函数在最后会隐式地执行 return this 操作。所以构造函数最终会返回新生成的这个对象。\n构造函数与类的定义 // 模拟类定义（尚有改进的余地） // 相当于类的定义 function MyClass(x, y) { // 相当于域 this.x = x; this.y = y; // 相当于方法 this.show = function() { print(this.x, this.y); } } // 对代码清单 5.9 中的构造函数的调用（实例生成） js\u0026gt; var obj = new MyClass(3, 2); js\u0026gt; obj.show(); 3 2 这段代码简单地实现了Javascript 类的定义， 但是有两个问题：\n● 由于所有的实例都是复制了同一个方法所定义的实体，所以效率（内存效率与执行效率）低下。 ● 无法对属性值进行访问控制（private 或 public 等）。\n前者可以通过原型继承来解决，后者可以通过闭包来解决。\n属性的访问 通过点运算符和方括号运算符来访问对象的属性。在点运算符之后书写的属性名会被认为是标识符，而中括号运算符内的则是被转为字符串值的表达式。\njs\u0026gt; var obj = { x:3, y:4 }; js\u0026gt; print(obj.x); // 属性 x 3 js\u0026gt; print(obj[\u0026#39;x\u0026#39;]); // 属性 x 3 js\u0026gt; var key = \u0026#39;x\u0026#39;; js\u0026gt; print(obj[key]); // 属性 x（而非属性 key） 3 属性访问的运算对象并不是变量，而是对象的引用：\njs\u0026gt; ({x:3, y:4}).x; // 属性 x 3 js\u0026gt; ({x:3, y:4})[\u0026#39;x\u0026#39;]; // 属性 x 3 现实中几乎不会对对象字面量进行运算。不过当这种运算对象不是一个变量时，倒是常常会以方法链之类的形式出现。\n### 点运算符与中括号运算符在使用上的区别\n只能使用中括号运算符的情况分为以下几种。 ● 使用了不能作为标识符的属性名的情况。 ● 将变量的值作为属性名使用的情况。 ● 将表达式的求值结果作为属性名使用的情况。\n// 含有横杠的属性名 js\u0026gt; obj = { \u0026#39;foo-bar\u0026#39;:5 }; js\u0026gt; obj.foo-bar; // 将解释为 obj.foo 减去 bar，从而造成错误 ReferenceError: bar is not defined 无法作为标识符被使用的字符串，仍可以在中括号运算符中使用。\njs\u0026gt; obj[\u0026#39;foo-bar\u0026#39;]; // 使用 [] 运算以字符串值指定了一个属性名。可以正常执行 5 属性的枚举 可以通过 for in 语句对属性名进行枚举（代码清单 5.10）。通过在 for in 语句中使用中括号运算符，可以间接地实现对属性值的枚举。使用 for each in 语句可以直接枚举属性值。\nvar obj = { x:3, y:4, z:5 }; for (var key in obj) { print(\u0026#39;key = \u0026#39;, key); // 属性名的枚举 print(\u0026#39;val = \u0026#39;, obj[key]); // 属性值的枚举 } // 代码清单 5.10 的运行结果 key = x val = 3 key = y val = 4 key = z val = 5 属性可以分为直接属性以及继承于原型的属性。for in 语句和 for each in 语句都会枚举继承于原型的属性。\n### 作为关联数组的对象\n在 JavaScript 中，必须通过对象来实现关联数组（字典、散列）\n简单说来，原型继承指的是一种对象继承其他对象的属性并将其作为自身的属性一样来使用的做法。如下所示，从形式上来说，对象 obj 的属性并不是其直接属性，而是通过原型继承而得到的属性。\njs\u0026gt; function MyClass() {} js\u0026gt; MyClass.prototype.z = 5; // 在原型链上设定属性 z js\u0026gt; var obj = new MyClass(); // 属性 z 继承了原型 js\u0026gt; print(obj.z); 5 for in 语句将枚举通过原型继承而得到的属性。\n// 接之前的代码 js\u0026gt; for (var key in obj) { print(key); } // for in 语句也会枚举通过原型继承得到的属性 z 请注意，通过原型继承而得到的属性无法被 delete。继续接之前的代码。\n// 接之前的代码 js\u0026gt; delete obj.z; // 尽管没有被 delete，但还是会返回 true…… true js\u0026gt; print(obj.z); // 无法 delete 通过原型继承而得到的属性 5 即使通过使用空的对象字面量创建一个没有元素的空的关联数组， 也仍然会从 Object 类中继承原型的属性。 可以通过 in 运算对此进行检验。\njs\u0026gt; var map = { }; // 通过空的对象字面量生成关联数组 js\u0026gt; \u0026#39;toString\u0026#39; in map; // map 所引用的对象从 Object 类中继承了属性 toString true 但是，通过 for in 语句对元素进行枚举不会有任何效果。这是由于 enumerable 属性的缘故，将在之后的小节中说明。\n// 接之前的代码 js\u0026gt; for (var key in map) { print(key); } // 没有元素会被枚举 通过 in 运算符检测关联数组的键是否存在，就会发生与原型继承而来的属性相关的问题。因此，像下面这样通过 hasOwnProperty 来对其进行检测，是一种更安全的做法。\njs\u0026gt; var map = {}; js\u0026gt; map.hasOwnProperty(\u0026#39;toString\u0026#39;); // 由于 toString 不是直接属性，因此结果为 false false js\u0026gt; map[\u0026#39;toString\u0026#39;] = 1; js\u0026gt; map.hasOwnProperty(\u0026#39;toString\u0026#39;); true js\u0026gt; delete map[\u0026#39;toString\u0026#39;]; js\u0026gt; map.hasOwnProperty(\u0026#39;toString\u0026#39;); false ### 属性的属性\n在标准的对象中有一部分属性的 enumerable 属性为假而无法通过 for in 语句枚举。其中一个很容易理解的例子是数列的 length 属性。\n属性的属性名 含义\nwritable 可以改写属性值\nenumerable 可以通过 for in 语句枚举\nconfigurable 可以改变属性的属性。可以删除属性\nget 可以指定属性值的 getter 函数\nset 可以指定属性值的 setter 函数\n垃圾回收 不再使用的对象的内存将会自动回收，这种功能称作垃圾回收。所谓不再使用的对象，指的是没有被任何一个**属性（变量）**引用的对象。\n循环引用会造成内存泄漏。所谓循环引用，指的是对象通过属性相互引用而导致它们不会被判定为不再使用的状态。\n### 不可变对象\n所谓不可变对象，指的是在被生成之后状态不能再被改变的对象。由于对象的状态是由其各个属性的值所决定的，因此从形式上来说也是指无法改变属性的值的对象\nJavaScript 中的一种典型的不可变对象就是字符串对象。\n在 JavaScript 中可以通过以下方式实现对象的不可变。\n● 将属性（状态）隐藏，不提供变更操作。 ● 灵活运用 ECMAScript 第 5 版中提供的函数。 ● 灵活运用 writable 属性、configurable 属性以及 setter 和 getter。\n为了将属性隐藏，可以使用一种被称为闭包的方法。\n在 ECMAScript 第 5 版中有一些用于支持对象的不可变化的函数（表 5.2）。seal 可以向下兼容 preventExtensions，freeze 可以向下兼容 seal。这里的向下兼容，指的是比后者有更为严格的限制。\nECMAScript 第 5 版中用于支持对象的不可变化的函数\n方法名 属性新增 属性删除 属性值变更 确认方法\npreventExtensions X O O Object.isExtensible\nseal X X O Object.isSealed\nfreeze X X X Object.isFrozen\nObject.preventExtensions 的例子\njs\u0026gt; var obj = { x:2, y:3 }; js\u0026gt; Object.preventExtensions(obj); // 无法新增属性 js\u0026gt; obj.z = 4; js\u0026gt; Object.keys(obj); [\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;] // 可以删除属性 js\u0026gt; delete obj.y; js\u0026gt; Object.keys(obj); [\u0026#34;x\u0026#34;] // 可以更改属性值 js\u0026gt; obj.x = 20; js\u0026gt; print(obj.x); 20 Object.seal 的例子\njs\u0026gt; var obj = { x:2, y:3 }; js\u0026gt; Object.seal(obj); // 无法删除属性 js\u0026gt; delete obj.y; // 将返回 false js\u0026gt; Object.keys(obj); [\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;] // 可以更改属性值 js\u0026gt; obj.x = 20; js\u0026gt; print(obj.x); 20 Object.freeze 的例子\njs\u0026gt; var obj = { x:2, y:3 }; js\u0026gt; Object.freeze(obj); // 无法更改属性值 js\u0026gt; obj.x = 20; js\u0026gt; print(obj.x); 2 ● 一旦更改就无法还原。 ● 如果想让原型继承中的被继承方也不可变化，需要对其进行显式的操作。\n方法 我们将作为对象属性的函数称为方法。那些使用了 this 引用来调用并访问了对象的属性的函数，被称为方法。\nthis 引用 this 引用有着会根据代码的上下文语境自动改变其引用对象的特性。\n在此，总结一下 this 引用的规则。\n● 在最外层代码中，this 引用引用的是全局对象。 ● 在函数内，this 引用根据函数调用方式的不同而有所不同（参见表 5.3）。\n对于函数内部的情况，this 引用的引用对象并不是根据函数的内容或声明方式而改变的，而是根据其调用方式而改变。也就是说，即使是同一个函数，如果调用方式不同，this 引用的引用对象也会有所不同。\n函数内部的 this 引用\n函数的调用方式 this 引用的引用对象\n构造函数调用 所生成的对象\n方法调用 接收方对象\napply 或是 call 调用 由 apply 或 call 的参数指定的对象\n其它方式的调用 全局对象\n对于构造函数调用的情况，this 引用的引用对象是所生成的对象。 上表中的方法调用的说明中的接收方对象是这样一种对象： ● 通过点运算符或中括号运算符调用对象的方法时，在运算符左侧所指定的对象。\n方法是对象的属性所引用的函数。下面是一个关于方法和接收方对象的具体例子。\n// 对象定义 js\u0026gt; var obj = { x:3, doit: function() { print(\u0026#39;method is called.\u0026#39; + this.x ); } }; js\u0026gt; obj.doit(); // 对象 obj 是接收方对象。doit 是方法。 method is called. 3 js\u0026gt; obj[\u0026#39;doit\u0026#39;](); // 对象 obj 是接收方对象。doit 是方法。 method is called. 3 现在说明上面的例子。首先是将对象的引用赋值给了变量 obj。这个对象有两个属性。属性 x 的值为数值 3，属性 doit 的值是一个函数。将该函数称为方法 doit。可以通过点运算符或中括号运算符对 obj 调用方法 doit。这时，方法调用的目标对象被称为接收方对象（也就是说，obj 所引用的对象是一个接收方对象）。被调用的方法内的 this 引用引用了该接收方对象。\nthis 引用注意点 在 Java 中, this 所引用的接收方对象始终是该类的实例, 而在 Javascript 中却不一定总是如此。Javascript 的 this 引用的引用对象会随着方法调用方式的不同而改变。\nvar obj = { x : 3; doit: function() { print(\u0026#39;method is called.\u0026#39; + this.x ); } } var fn = obj.doit; // 将 ojb.doit 引用的 Function 对象赋值给全局变量 fn(); // 函数内的 this 引用引用了全局对象, 现在全局变量中还没有定义变量 x, 所以下面会打印 undefined method is called. undefined var x = 5; // 确认 this 引用确实引用了全局对象 fn(); method is called. 5 var obj2 = { x:4, doit2:fn }; // 将obj的方法（Function对象的引用）赋值给了另一个对象obj2的属性 obj2.doit2(); // 方法内的 this 引用引用了对象 obj2 method is called. 4 在方法内部调用方法的情况 // 从 doit 方法内调用 doit2 方法时，必须通过 this 引用，以 this.doit2() 的方式实现 js\u0026gt; var obj = { x:3, doit: function() { print(\u0026#39;doit is called.\u0026#39; + this.x ); this.doit2(); }, doit2: function() { print(\u0026#39;doit2 is called.\u0026#39; + this.x); } }; js\u0026gt; obj.doit(); doit is called. 3 doit2 is called. 3 apply 与 call 在 Function 对象中包含 apply 与 call 这两种方法，通过它们调用的函数的 this 引用，可以指向任意特定的对象。也就是说，可以理解为它们能够显式地指定接收方对象。\njs\u0026gt; function f() { print(this.x); } js\u0026gt; var obj = { x:4 }; js\u0026gt; f.apply(obj); // 通过 apply 调用函数 f。函数内的 this 引用引用了对象 obj 4 js\u0026gt; f.call(obj); // 通过 call 调用函数 f。函数内的 this 引用引用了对象 obj 4 // 将接收方对象指定为另一个对象并进行方法调用 js\u0026gt; var obj = { x:3, doit: function() { print(\u0026#39;method is called.\u0026#39; + this.x ); } }; js\u0026gt; var obj2 = { x:4 }; js\u0026gt; obj.doit.apply(obj2); // 通过 apply 调用 obj.doit 方法。方法内的 this 引用引用了对象 obj2 method is called. 4 apply 与 call 之间的不同之处在于两者对其他参数的传递方式。对于 apply 来说，剩余的参数将通过数组来传递，而 call 是直接按原样传递形参。\njs\u0026gt; function f(a, b) { print(\u0026#39;this.x = \u0026#39; + this.x + \u0026#39;, a = \u0026#39; + a + \u0026#39;, b = \u0026#39; + b); } js\u0026gt; f.apply({x:4}, [1, 2]); // 作为第 2 个参数的数列中的元素都是函数 f 的参数 this.x = 4, a = 1, b = 2 js\u0026gt; f.call({x:4}, 1, 2); // 从第 2 个参数起的参数都是函数 f 的参数 this.x = 4, a =1 , b = 2 "},"name":"JavaScript 编程全解","published":"2017-05-02T16:16:21Z","summary":"函数JavaScript 的函数是一种对象。 对象 Javascript 中没有类这样的语言结构, Javascript 中的对象是一个 名称与值配对的集合。这样一对儿名称和值的配对被称为属性。例如一个人的属性有:\n身高: 178cm 体重 65kg 年龄 28 所以, Javascript 对象可以定义为属性 的集合。Javascript 的对象字面量：\n// 对象字面量表达式的语法 { 属性名 : 属性值, 属性名 : 属性值, ...... } 属性名可以是标识符。字符串和数值：\n// 对象字面量表达式的例子 { x: 2, y:1 } // 属性名是标识符 { \u0026#34;x\u0026#34;:2, \u0026#34;y\u0026#34;:1 } // 属性名是字符串值 { \u0026#39;x\u0026#39;:2, \u0026#39;y\u0026#39;:1 } // 属性名是字符串值 { 1:2, 2:1 } // 属性名是数值 { x:2, y:1, enable:true, color:{ r:255, g:255, b:255 } } // 各种类型的属性值 对对象字面量表达式求值所得到的结果，是所生成对象的一个引用。","type":"entry","url":"https://ohmyweekly.github.io/notes/javascript-%E7%BC%96%E7%A8%8B%E5%85%A8%E8%A7%A3%E7%AC%94%E8%AE%B0%E4%B8%80/"}