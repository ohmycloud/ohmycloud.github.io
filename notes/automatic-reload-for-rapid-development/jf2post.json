{"author":{"name":null,"type":"card","url":"http://localhost:1313/"},"content":{"html":"\u003cp\u003e使用 \u003ca href=\"http://mojolicious.org/\"\u003eMojolicious\u003c/a\u003e 开发 Web 应用程序非常有趣！使用 \u003ca href=\"https://mojolicious.org/perldoc/morbo\"\u003e\u003ccode\u003emorbo\u003c/code\u003e\u003c/a\u003e 服务器进行开发，对我的 webapp 的每次更改都会导致重新启动以加载我的更改。这样我下一个请求就有了我的新代码！\u003c/p\u003e\n\u003cp\u003e所以，我改变了我的代码，重新启动了 webapp，然后我回到浏览器窗口。等等\u0026hellip;\u0026hellip;我的新代码在哪里？为什么不修复错误？没有\u0026hellip;我忘记重新加载我的浏览器窗口了吗？啊!当然！\u003c/p\u003e\n\u003cp\u003e这是否发生在你身上？可能不是。但是，在每次后端代码更改后重新加载浏览器窗口仍然很烦人。如果每次重新启动 Web 服务器时我的浏览器窗口都会自动重新加载，那就太好了！\u003c/p\u003e\n\u003ch2 id=\"autoreload-插件\"\u003eAutoReload 插件\u003c/h2\u003e\n\u003cp\u003e像 Perl 中的每个问题一样，有一个 CPAN 模块：\u003ca href=\"http://metacpan.org/pod/Mojolicious::Plugin::AutoReload\"\u003eMojolicious::Plugin::AutoReload\u003c/a\u003e。将此插件添加到我们的应用程序将自动重新加载连接到我们的应用程序的任何浏览器窗口，使开发 Mojolicious 应用程序更容易！\u003c/p\u003e\n\u003cp\u003e要使用该插件，我们使用 \u003ccode\u003eplugin\u003c/code\u003e 方法将其添加到我们的应用程序中。然后，我们将 \u003ccode\u003eauto_reload\u003c/code\u003e 帮助器添加到\u003ca href=\"https://metacpan.org/pod/distribution/Mojolicious/lib/Mojolicious/Guides/Tutorial.pod#Layouts\"\u003e布局模板\u003c/a\u003e中:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"nn\"\u003eMojolicious::Lite\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eplugin\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#39;AutoReload\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eget\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#39;/\u0026#39;\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#39;index\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nn\"\u003eapp\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"bp\"\u003e__DATA__\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e@@\u003c/span\u003e \u003cspan class=\"nv\"\u003elayouts\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003edefault\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ehtml\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eep\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e%\u003c/span\u003e\u003cspan class=\"err\"\u003e=\u003c/span\u003e \u003cspan class=\"nv\"\u003eauto_reload\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e%\u003c/span\u003e\u003cspan class=\"err\"\u003e=\u003c/span\u003e \u003cspan class=\"nv\"\u003econtent\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e@@\u003c/span\u003e \u003cspan class=\"nv\"\u003eindex\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ehtml\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eep\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e%\u003c/span\u003e \u003cspan class=\"nv\"\u003elayout\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#39;default\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"sr\"\u003e\u0026lt;h1\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eHello\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eWorld\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"sr\"\u003e\u0026lt;/h1\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ca href=\"https://mojolicious.io/blog/2018/12/02/automatic-reload-for-rapid-development/myapp.pl\"\u003e在这里下载代码\u003c/a\u003e。现在，当我们在浏览器中打开应用程序时，如果服务器重新启动，我们的浏览器将重新加载页面以查看新应用程序！\u003c/p\u003e\n\u003ch2 id=\"工作原理\"\u003e工作原理\u003c/h2\u003e\n\u003cp\u003e这个插件简单优雅：当浏览器加载页面时，它连接到位于 \u003ccode\u003e/auto_reload\u003c/code\u003e 的 WebSocket。服务器重新启动时，WebSocket 连接中断。客户端看到断开的连接，等待服务器再次开始侦听连接，然后重新加载页面。\u003c/p\u003e\n\u003ch2 id=\"在生产中禁用\"\u003e在生产中禁用\u003c/h2\u003e\n\u003cp\u003e一旦我们从 \u003ccode\u003emorbo\u003c/code\u003e 切换到 \u003ccode\u003ehypnotoad\u003c/code\u003e，我们就不再需要自动重新加载了。因此，插件不会向浏览器发送 JavaScript 来构建 websocket。这是使用 \u003ca href=\"https://mojolicious.org/perldoc/Mojolicious/Guides/Tutorial#Mode\"\u003e\u003ccode\u003emode\u003c/code\u003e\u003c/a\u003e 属性控制的。当 \u003ccode\u003emode\u003c/code\u003e 为 \u003ccode\u003edevelopment\u003c/code\u003e 模式（\u003ccode\u003emorbo\u003c/code\u003e 的默认模式）时，将告知浏览器创建 WebSocket。当 \u003ccode\u003emode\u003c/code\u003e 为其他任何模式时，不会创建 WebSocket。\u003c/p\u003e\n\u003cp\u003e让 Mojolicious 变得如此有趣的部分原因在于它是多么容易。\u003ca href=\"https://github.com/preaction/Mojolicious-Plugin-AutoReload/blob/v0.003/lib/Mojolicious/Plugin/AutoReload.pm#L56-L92\"\u003e整个插件只有40行代码\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e现在，使用 Mojolicious::Plugin::AutoReload，在 Mojolicious 开发时只是更容易一点，而且更有趣！\u003c/p\u003e\n","text":"使用 Mojolicious 开发 Web 应用程序非常有趣！使用 morbo 服务器进行开发，对我的 webapp 的每次更改都会导致重新启动以加载我的更改。这样我下一个请求就有了我的新代码！\n所以，我改变了我的代码，重新启动了 webapp，然后我回到浏览器窗口。等等\u0026hellip;\u0026hellip;我的新代码在哪里？为什么不修复错误？没有\u0026hellip;我忘记重新加载我的浏览器窗口了吗？啊!当然！\n这是否发生在你身上？可能不是。但是，在每次后端代码更改后重新加载浏览器窗口仍然很烦人。如果每次重新启动 Web 服务器时我的浏览器窗口都会自动重新加载，那就太好了！\nAutoReload 插件 像 Perl 中的每个问题一样，有一个 CPAN 模块：Mojolicious::Plugin::AutoReload。将此插件添加到我们的应用程序将自动重新加载连接到我们的应用程序的任何浏览器窗口，使开发 Mojolicious 应用程序更容易！\n要使用该插件，我们使用 plugin 方法将其添加到我们的应用程序中。然后，我们将 auto_reload 帮助器添加到布局模板中:\nuse Mojolicious::Lite; plugin \u0026#39;AutoReload\u0026#39;; get \u0026#39;/\u0026#39; =\u0026gt; \u0026#39;index\u0026#39;; app-\u0026gt;start; __DATA__ @@ layouts/default.html.ep %= auto_reload %= content @@ index.html.ep % layout \u0026#39;default\u0026#39;; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; 在这里下载代码。现在，当我们在浏览器中打开应用程序时，如果服务器重新启动，我们的浏览器将重新加载页面以查看新应用程序！\n工作原理 这个插件简单优雅：当浏览器加载页面时，它连接到位于 /auto_reload 的 WebSocket。服务器重新启动时，WebSocket 连接中断。客户端看到断开的连接，等待服务器再次开始侦听连接，然后重新加载页面。\n在生产中禁用 一旦我们从 morbo 切换到 hypnotoad，我们就不再需要自动重新加载了。因此，插件不会向浏览器发送 JavaScript 来构建 websocket。这是使用 mode 属性控制的。当 mode 为 development 模式（morbo 的默认模式）时，将告知浏览器创建 WebSocket。当 mode 为其他任何模式时，不会创建 WebSocket。\n让 Mojolicious 变得如此有趣的部分原因在于它是多么容易。整个插件只有40行代码。\n现在，使用 Mojolicious::Plugin::AutoReload，在 Mojolicious 开发时只是更容易一点，而且更有趣！\n"},"name":"第二天 - 自动重载以实现快速开发","published":"2018-12-02T20:48:06Z","summary":"使用 Mojolicious 开发 Web 应用程序非常有趣！使用 morbo 服务器进行开发，对我的 webapp 的每次更改都会导致重新启动以加载我的更改。这样我下一个请求就有了我的新代码！\n所以，我改变了我的代码，重新启动了 webapp，然后我回到浏览器窗口。等等\u0026hellip;\u0026hellip;我的新代码在哪里？为什么不修复错误？没有\u0026hellip;我忘记重新加载我的浏览器窗口了吗？啊!当然！\n这是否发生在你身上？可能不是。但是，在每次后端代码更改后重新加载浏览器窗口仍然很烦人。如果每次重新启动 Web 服务器时我的浏览器窗口都会自动重新加载，那就太好了！\nAutoReload 插件 像 Perl 中的每个问题一样，有一个 CPAN 模块：Mojolicious::Plugin::AutoReload。将此插件添加到我们的应用程序将自动重新加载连接到我们的应用程序的任何浏览器窗口，使开发 Mojolicious 应用程序更容易！\n要使用该插件，我们使用 plugin 方法将其添加到我们的应用程序中。然后，我们将 auto_reload 帮助器添加到布局模板中:\nuse Mojolicious::Lite; plugin \u0026#39;AutoReload\u0026#39;; get \u0026#39;/\u0026#39; =\u0026gt; \u0026#39;index\u0026#39;; app-\u0026gt;start; __DATA__ @@ layouts/default.html.ep %= auto_reload %= content @@ index.html.ep % layout \u0026#39;default\u0026#39;; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; 在这里下载代码。现在，当我们在浏览器中打开应用程序时，如果服务器重新启动，我们的浏览器将重新加载页面以查看新应用程序！\n工作原理 这个插件简单优雅：当浏览器加载页面时，它连接到位于 /auto_reload 的 WebSocket。服务器重新启动时，WebSocket 连接中断。客户端看到断开的连接，等待服务器再次开始侦听连接，然后重新加载页面。\n在生产中禁用 一旦我们从 morbo 切换到 hypnotoad，我们就不再需要自动重新加载了。因此，插件不会向浏览器发送 JavaScript 来构建 websocket。这是使用 mode 属性控制的。当 mode 为 development 模式（morbo 的默认模式）时，将告知浏览器创建 WebSocket。当 mode 为其他任何模式时，不会创建 WebSocket。","type":"entry","url":"http://localhost:1313/notes/automatic-reload-for-rapid-development/"}