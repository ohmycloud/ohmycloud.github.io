{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io/"},"content":{"html":"\u003cp\u003e\u003ca href=\"https://vrurg.github.io/2020/12/26/Coercion-Return-Values\"\u003eVadim 不同意\u003c/a\u003e我的观点。他也不应该同意。我几乎从不同意自己的观点。另外，我很高兴他的不同意，因为这让我可以写一个我已经排了很久的题目。\u003c/p\u003e\n\u003cp\u003e基本的说法是，强制类型允许在编译时，甚至可能更早 - 在大脑时 - 对接口进行推理。在静态类型的语言中，这是一件合理的事情。当涉及到对象时，Raku 会在运行时进行大量的思考。让我们来看看两个例子。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eFoo\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003esubmethod\u003c/span\u003e \u003cspan class=\"nf\"\u003eshift-right\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$i\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nf\"\u003eFoo\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"nv\"\u003e$handle\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nv\"\u003e$handle\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eshift-right\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eFoo\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003enew\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eBar\u003c/span\u003e \u003cspan class=\"k\"\u003eis\u003c/span\u003e \u003cspan class=\"nc\"\u003eFoo\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eBar\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003enew\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# OUTPUT: No such method \u0026#39;shift-right\u0026#39; for invocant of type \u0026#39;Bar\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我们要求编译器对 Foo 进行类型检查，使 Bar 满足。然后，我们继续对一个只由 Foo 提供的 Bar 实例调用一个方法。编译器试图帮助我们，但不能。在这个例子中，我们的接口不是 Foo 及其方法，而只是 Foo - 不包括它的子类 - 及其方法。这是一个微妙的差异，会在运行时伤害我们。通过另一个例子，我可以很清楚地说明原因。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eCatchall\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ehas\u003c/span\u003e \u003cspan class=\"nv\"\u003e$.the-object\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nb\"\u003eFALLBACK\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$name\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nb\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ethe-object\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"nv\"\u003e$name\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;(\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCatchall\u003c/span\u003e \u003cspan class=\"nv\"\u003e$c\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nv\"\u003e$c\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eany-name\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"nf\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003eCatchall\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003enew\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003ethe-object\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003e::\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nf\"\u003eany-name\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$i\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mi\"\u003e42\u003c/span\u003e \u003cspan class=\"o\"\u003e~~\u003c/span\u003e \u003cspan class=\"nv\"\u003e$i\u003c/span\u003e \u003cspan class=\"o\"\u003e??\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003eUniverse\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e \u003cspan class=\"o\"\u003e!!\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003ewut‽\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;\u003c/span\u003e  \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# OUTPUT: Universe\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e你能说出 \u003ccode\u003esub foo\u003c/code\u003e 使用的接口的名称吗？这当然是个刻薄的问题，因为提供接口的类没有名字。类型约束提供了 \u003ccode\u003e$.the-object\u003c/code\u003e 和任何从 Any 继承的访问器方法的接口。后者可能会随着新的语言版本而改变。因此，真正的接口更像是 \u003ccode\u003e*.any-name()\u003c/code\u003e，类型约束是 Any。这两个是简单的例子。你使用的任何模块都可能 \u003ccode\u003euse MONKEY-TYPING\u003c/code\u003e 或者摆弄 MOP。运行时接口在 Raku 中是完全不可预测的，我们都最好 \u003ccode\u003euse Test\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e也就是说，Vadim 坚持最小惊喜的原则是对的。我们用大写字母开始角色的名字，以表示它是一个类型对象，从而希望尊重某种接口。我很乐意为\u0026quot;浆糊\u0026quot;强转的问题提供一个更通用的解决方案。从技术上讲，Raku 已经得到了它的语法。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003eFilish\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eAny:D\u003c/span\u003e \u003cspan class=\"nv\"\u003e$handle\u003c/span\u003e \u003cspan class=\"k\"\u003ewhere\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e~~\u003c/span\u003e \u003cspan class=\"kt\"\u003eStr\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"kt\"\u003eIO::Handle\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"kt\"\u003eIO::Path\u003c/span\u003e \u003cspan class=\"k\"\u003e--\u0026gt;\u003c/span\u003e \u003cspan class=\"kt\"\u003eIO::Handle\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e# ... coerce away here\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e\u0026amp;Filish\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"nv\"\u003e$handle\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nv\"\u003e$handle\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eput\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s2\"\u003eThis would make me happy!\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#34;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这种形式基本上会说：\u0026ldquo;我想让一个叫 Filish 的子系统来处理胁迫\u0026rdquo;。这将允许 Filish 中的代码被重用，从而提供灵活性，而不会给人以承诺接口的印象。至少在这个例子中，强转 sub 的签名包含了自己的文档。甚至可能还有一些编译时检查的空间，只要我们不使用多。参数 \u003ccode\u003e$handle\u003c/code\u003e 必须满足 Filish 的签名。有一个 sub 将允许模块用户对其进行 \u003ccode\u003e.wrap\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e与自己一般的分歧是很有挑战性的，但确实让我很容易改变自己的想法。由于这很可能是我今年的最后一篇博文，我祝愿大家在 2021 年有专属的好理由改变自己的想法。\u003c/p\u003e\n","text":"Vadim 不同意我的观点。他也不应该同意。我几乎从不同意自己的观点。另外，我很高兴他的不同意，因为这让我可以写一个我已经排了很久的题目。\n基本的说法是，强制类型允许在编译时，甚至可能更早 - 在大脑时 - 对接口进行推理。在静态类型的语言中，这是一件合理的事情。当涉及到对象时，Raku 会在运行时进行大量的思考。让我们来看看两个例子。\nclass Foo { submethod shift-right($i) { } } sub foo(Foo() $handle) { $handle.shift-right(4); } foo(Foo.new); class Bar is Foo { } foo(Bar.new); # OUTPUT: No such method \u0026#39;shift-right\u0026#39; for invocant of type \u0026#39;Bar\u0026#39; 我们要求编译器对 Foo 进行类型检查，使 Bar 满足。然后，我们继续对一个只由 Foo 提供的 Bar 实例调用一个方法。编译器试图帮助我们，但不能。在这个例子中，我们的接口不是 Foo 及其方法，而只是 Foo - 不包括它的子类 - 及其方法。这是一个微妙的差异，会在运行时伤害我们。通过另一个例子，我可以很清楚地说明原因。\nclass Catchall { has $.the-object; method FALLBACK($name, |c) { self.the-object.\u0026#34;$name\u0026#34;(|c) } } sub foo(Catchall $c) { $c.any-name(42); } say foo( Catchall.new: the-object =\u0026gt; class :: { method any-name($i) { 42 ~~ $i ?? \u0026#39;Universe\u0026#39; !! \u0026#39;wut‽\u0026#39; } } ); # OUTPUT: Universe 你能说出 sub foo 使用的接口的名称吗？这当然是个刻薄的问题，因为提供接口的类没有名字。类型约束提供了 $.the-object 和任何从 Any 继承的访问器方法的接口。后者可能会随着新的语言版本而改变。因此，真正的接口更像是 *.any-name()，类型约束是 Any。这两个是简单的例子。你使用的任何模块都可能 use MONKEY-TYPING 或者摆弄 MOP。运行时接口在 Raku 中是完全不可预测的，我们都最好 use Test。\n也就是说，Vadim 坚持最小惊喜的原则是对的。我们用大写字母开始角色的名字，以表示它是一个类型对象，从而希望尊重某种接口。我很乐意为\u0026quot;浆糊\u0026quot;强转的问题提供一个更通用的解决方案。从技术上讲，Raku 已经得到了它的语法。\nsub Filish(Any:D $handle where * ~~ Str|IO::Handle|IO::Path --\u0026gt; IO::Handle) { # ... coerce away here } sub foo(\u0026amp;Filish() $handle) { $handle.put: \u0026#34;This would make me happy!\u0026#34;; } 这种形式基本上会说：\u0026ldquo;我想让一个叫 Filish 的子系统来处理胁迫\u0026rdquo;。这将允许 Filish 中的代码被重用，从而提供灵活性，而不会给人以承诺接口的印象。至少在这个例子中，强转 sub 的签名包含了自己的文档。甚至可能还有一些编译时检查的空间，只要我们不使用多。参数 $handle 必须满足 Filish 的签名。有一个 sub 将允许模块用户对其进行 .wrap。\n与自己一般的分歧是很有挑战性的，但确实让我很容易改变自己的想法。由于这很可能是我今年的最后一篇博文，我祝愿大家在 2021 年有专属的好理由改变自己的想法。\n"},"name":"假定的可预测性","published":"2020-12-27T22:33:14+08:00","summary":"assumed predictability","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-12-27-assumed-predictability/"}