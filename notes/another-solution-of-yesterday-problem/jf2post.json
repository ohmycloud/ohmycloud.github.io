{"author":{"name":null,"type":"card","url":"https://ohmycloud.github.io/"},"content":{"html":"\u003cp\u003e欢迎来到 \u003cstrong\u003eRaku One-Liner Advent Calendar\u003c/strong\u003e 的第\u003ca href=\"https://raku.online/2018/12/14/another-solution-of-yesterdays-problem/\"\u003e14\u003c/a\u003e天！今天，我们正在提出我们昨天解决的问题的另一个答案。任务是计算二十世纪第一个月的所有星期日。\u003c/p\u003e\n\u003cp\u003e昨天，我们只扫描了整个世纪的所有日子，选择星期日（ \u003ccode\u003e.day-of-week == 7\u003c/code\u003e）并且是本月的第一天（\u003ccode\u003e.day == 1\u003c/code\u003e）。\u003c/p\u003e\n\u003cp\u003e可以制作更有效的算法。由于我们只对本月的第一天感兴趣，因此无需在100年内扫描所有36525天，而只需要扫描100天，这是1901年到2000年之间每个月的第一天。\u003c/p\u003e\n\u003cp\u003e因此，我们需要两个嵌套循环：年和月。我们需要两个 \u003ccode\u003efor\u003c/code\u003e 吗？不必要。我们使用 \u003ca href=\"https://raku.online/2018/12/09/more-on-x-in-perl-6/\"\u003eX 运算符\u003c/a\u003e;我们从以前的出版帖子中熟悉它。\u003c/p\u003e\n\u003cp\u003e这是我们今天的单行：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003egather\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"mi\"\u003e1901\u003c/span\u003e\u003cspan class=\"o\"\u003e..\u003c/span\u003e\u003cspan class=\"mi\"\u003e2000\u003c/span\u003e \u003cspan class=\"n\"\u003eX\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e..\u003c/span\u003e\u003cspan class=\"mi\"\u003e12\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003etake\u003c/span\u003e \u003cspan class=\"n\"\u003eDate\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"nv\"\u003e@_\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e})\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003egrep\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*.\u003c/span\u003e\u003cspan class=\"n\"\u003eday\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003eof\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003eweek\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e7\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eelems\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esay\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003efor 1901..2000 X 1..12\u003c/code\u003e 循环在遍历二十世纪的每个月份。对于每个循环变量，我们通过调用具有三个参数的构造函数来创建 \u003ccode\u003eDate\u003c/code\u003e 对象。\u003c/p\u003e\n\u003cp\u003e请注意，在循环内部，您可以同时使用 \u003ccode\u003e$_[0]\u003c/code\u003e 和 \u003ccode\u003e$_[1]\u003c/code\u003e，以及 \u003ccode\u003e@_[0]\u003c/code\u003e 和 \u003ccode\u003e@_[1]\u003c/code\u003e。在第一种情况下，\u003ccode\u003e$_\u003c/code\u003e 变量包含两个元素的列表，而在第二种情况下，它是一个数组 \u003ccode\u003e@_\u003c/code\u003e。如果您只是使用点来调用主题（默认）变量上的方法，则可以实现最短的代码：\u003ccode\u003e.[0]\u003c/code\u003e 和 \u003ccode\u003e.[1]\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e您可以键入 \u003ccode\u003eDate.new(.[0], .[1], 1)\u003c/code\u003e 代替 \u003ccode\u003eDate.new(|@_, 1)\u003c/code\u003e。 \u003ccode\u003e|@_\u003c/code\u003e 语法用于展开数组，否则 Raku 会认为您将数组作为第一个参数传递。\u003c/p\u003e\n\u003cp\u003e在 \u003ca href=\"https://docs.raku.org/syntax/gather%20take\"\u003egather-take\u003c/a\u003e 对儿的帮助下，将这些月份的所有第一天收集到序列中。\u003c/p\u003e\n\u003cp\u003e最后一步是昨天的 \u003ccode\u003egrep\u003c/code\u003e，但这次我们只需要选择星期日，所以单个 \u003ccode\u003e*.day-of-week == 7\u003c/code\u003e 条件就足够了。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eelems\u003c/code\u003e 方法的调用返回列表中元素的数量，即我们正在寻找的星期日数量。因此，请用 \u003ccode\u003esay\u003c/code\u003e 打印出来。\u003c/p\u003e\n\u003cp\u003e一个新的想法和一个新的答案应该让你在这个 One-Liner 日历中至少有一天感到高兴，直到明天的帖子！\u003c/p\u003e\n","text":"欢迎来到 Raku One-Liner Advent Calendar 的第14天！今天，我们正在提出我们昨天解决的问题的另一个答案。任务是计算二十世纪第一个月的所有星期日。\n昨天，我们只扫描了整个世纪的所有日子，选择星期日（ .day-of-week == 7）并且是本月的第一天（.day == 1）。\n可以制作更有效的算法。由于我们只对本月的第一天感兴趣，因此无需在100年内扫描所有36525天，而只需要扫描100天，这是1901年到2000年之间每个月的第一天。\n因此，我们需要两个嵌套循环：年和月。我们需要两个 for 吗？不必要。我们使用 X 运算符;我们从以前的出版帖子中熟悉它。\n这是我们今天的单行：\n(gather for 1901..2000 X 1..12 { take Date.new(|@_, 1) }).grep(*.day-of-week == 7).elems.say; for 1901..2000 X 1..12 循环在遍历二十世纪的每个月份。对于每个循环变量，我们通过调用具有三个参数的构造函数来创建 Date 对象。\n请注意，在循环内部，您可以同时使用 $_[0] 和 $_[1]，以及 @_[0] 和 @_[1]。在第一种情况下，$_ 变量包含两个元素的列表，而在第二种情况下，它是一个数组 @_。如果您只是使用点来调用主题（默认）变量上的方法，则可以实现最短的代码：.[0] 和 .[1]。\n您可以键入 Date.new(.[0], .[1], 1) 代替 Date.new(|@_, 1)。 |@_ 语法用于展开数组，否则 Raku 会认为您将数组作为第一个参数传递。\n在 gather-take 对儿的帮助下，将这些月份的所有第一天收集到序列中。\n最后一步是昨天的 grep，但这次我们只需要选择星期日，所以单个 *.day-of-week == 7 条件就足够了。\nelems 方法的调用返回列表中元素的数量，即我们正在寻找的星期日数量。因此，请用 say 打印出来。\n一个新的想法和一个新的答案应该让你在这个 One-Liner 日历中至少有一天感到高兴，直到明天的帖子！\n"},"name":"🎄 14/25. 昨天问题的另一个解决方案","published":"2018-12-14T09:15:43Z","summary":"欢迎来到 Raku One-Liner Advent Calendar 的第14天！今天，我们正在提出我们昨天解决的问题的另一个答案。任务是计算二十世纪第一个月的所有星期日。\n昨天，我们只扫描了整个世纪的所有日子，选择星期日（ .day-of-week == 7）并且是本月的第一天（.day == 1）。\n可以制作更有效的算法。由于我们只对本月的第一天感兴趣，因此无需在100年内扫描所有36525天，而只需要扫描100天，这是1901年到2000年之间每个月的第一天。\n因此，我们需要两个嵌套循环：年和月。我们需要两个 for 吗？不必要。我们使用 X 运算符;我们从以前的出版帖子中熟悉它。\n这是我们今天的单行：\n(gather for 1901..2000 X 1..12 { take Date.new(|@_, 1) }).grep(*.day-of-week == 7).elems.say; for 1901..2000 X 1..12 循环在遍历二十世纪的每个月份。对于每个循环变量，我们通过调用具有三个参数的构造函数来创建 Date 对象。\n请注意，在循环内部，您可以同时使用 $_[0] 和 $_[1]，以及 @_[0] 和 @_[1]。在第一种情况下，$_ 变量包含两个元素的列表，而在第二种情况下，它是一个数组 @_。如果您只是使用点来调用主题（默认）变量上的方法，则可以实现最短的代码：.[0] 和 .[1]。\n您可以键入 Date.new(.[0], .[1], 1) 代替 Date.new(|@_, 1)。 |@_ 语法用于展开数组，否则 Raku 会认为您将数组作为第一个参数传递。\n在 gather-take 对儿的帮助下，将这些月份的所有第一天收集到序列中。\n最后一步是昨天的 grep，但这次我们只需要选择星期日，所以单个 *.day-of-week == 7 条件就足够了。\nelems 方法的调用返回列表中元素的数量，即我们正在寻找的星期日数量。因此，请用 say 打印出来。","type":"entry","url":"https://ohmycloud.github.io/notes/another-solution-of-yesterday-problem/"}