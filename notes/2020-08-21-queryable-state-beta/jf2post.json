{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"content":{"html":"\u003cp\u003e注意：可查询状态的客户端 API 目前处于不断发展的状态，对所提供接口的稳定性不做保证。在即将到来的 Flink 版本中，客户端的 API 很可能会有突破性的变化。\u003c/p\u003e\n\u003cp\u003e简而言之，这个功能将 Flink 的 managed keyed (partitioned) state（参见 \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html\"\u003eWorking with State\u003c/a\u003e）暴露给外界，并允许用户从 Flink 外部查询作业的状态。对于某些场景来说，可查询状态消除了与外部系统（如键值存储）进行分布式操作/交易的需求，而这往往是实践中的瓶颈。此外，该功能对于调试目的可能特别有用。\u003c/p\u003e\n\u003cp\u003e注意事项: 当查询一个状态对象时，该对象是在没有任何同步或复制的情况下从一个并发线程访问的。这是一个设计上的选择，因为上述任何一种情况都会导致作业延迟的增加，这是我们想要避免的。因为任何使用 Java 堆空间的状态后端，如 MemoryStateBackend 或 FsStateBackend，在检索值时都不会使用副本，而是直接引用存储的值，所以读-修改-写模式是不安全的，可能会导致可查询状态服务器因并发修改而失败。RocksDBStateBackend 则可以避免这些问题。\u003c/p\u003e\n\u003ch2 id=\"架构\"\u003e架构\u003c/h2\u003e\n\u003cp\u003e在展示如何使用可查询状态之前，先简单介绍一下构成它的实体。Queryable State 功能由三个主要实体组成。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eQueryableStateClient，它（可能）运行在 Flink 集群之外，并提交用户查询。\u003c/li\u003e\n\u003cli\u003eQueryableStateClientProxy，它运行在每个 TaskManager 上（即 Flink 集群内部），负责接收客户端的查询，代表他从负责的 TaskManager 中获取所请求的状态，并将其返回给客户端，以及\u003c/li\u003e\n\u003cli\u003eQueryableStateServer，它运行在每个 TaskManager 上，负责为本地存储的状态提供服务。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e客户端连接到其中一个代理，并发送一个与特定键 \u003cem\u003ek\u003c/em\u003e 相关联的状态的请求。正如在\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html\"\u003e使用状态\u003c/a\u003e中所述，keyed state 被组织在键组(Key Groups)中，每个 TaskManager 都被分配了一些这样的键组(Key Groups)。为了发现哪个 TaskManager 负责持有 \u003cem\u003ek\u003c/em\u003e 的键组，代理将询问 JobManager。根据答案，代理将查询运行在该 TaskManager 上的 QueryableStateServer，以获取与 \u003cem\u003ek\u003c/em\u003e 相关联的状态，并将响应转发到客户端。\u003c/p\u003e\n\u003ch2 id=\"激活可查询状态\"\u003e激活可查询状态\u003c/h2\u003e\n\u003cp\u003e要在 Flink 集群上启用可查询状态，你需要做以下工作。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将 \u003ccode\u003eflink-queryable-state-runtime_2.11-1.11.0.jar\u003c/code\u003e 从 \u003ca href=\"https://flink.apache.org/downloads.html\"\u003eFlink 发行版\u003c/a\u003e的 \u003ccode\u003eopt/\u003c/code\u003e 文件夹中复制到 \u003ccode\u003elib/\u003c/code\u003e  文件夹中。\u003c/li\u003e\n\u003cli\u003e设置属性 \u003ccode\u003equeryable-state.enable\u003c/code\u003e 为 \u003ccode\u003etrue\u003c/code\u003e。请参阅\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/config.html#queryable-state\"\u003e配置\u003c/a\u003e文档了解详情和附加参数。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e要验证您的群集是否在启用可查询状态后运行，请检查任何 TaskManager 的日志中的行。\u0026ldquo;Started the Queryable State Proxy Server @ \u0026hellip;\u0026quot;。\u003c/p\u003e\n\u003ch3 id=\"使状态可查询\"\u003e使状态可查询\u003c/h3\u003e\n\u003cp\u003e现在你已经在集群上激活了可查询状态，现在是时候看看如何使用它了。为了使一个状态对外界可见，它需要通过使用以下方式明确地成为可查询状态。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eQueryableStateStream, 一个方便的对象，它作为一个接收器(sink)，并把它的传入值作为可查询的状态提供，或者是\u003c/li\u003e\n\u003cli\u003estateDescriptor.setQueryable(String queryableStateName) 方法，使得状态描述符所代表的 keyed state，可以查询。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e下面的章节将解释这两种方法的使用。\u003c/p\u003e\n\u003ch3 id=\"可查询的状态流\"\u003e可查询的状态流\u003c/h3\u003e\n\u003cp\u003e在 KeyedStream 上调用 \u003ccode\u003e.asQueryableState(stateName, stateDescriptor)\u003c/code\u003e 会返回一个 \u003ccode\u003eQueryableStateStream\u003c/code\u003e，它将其值作为可查询状态提供。根据状态的类型，\u003ccode\u003easQueryableState()\u003c/code\u003e 方法有以下几种变体。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"c1\"\u003e// ValueState\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eQueryableStateStream\u003c/span\u003e \u003cspan class=\"nf\"\u003easQueryableState\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eString\u003c/span\u003e \u003cspan class=\"n\"\u003equeryableStateName\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eValueStateDescriptor\u003c/span\u003e \u003cspan class=\"n\"\u003estateDescriptor\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// Shortcut for explicit ValueStateDescriptor variant\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eQueryableStateStream\u003c/span\u003e \u003cspan class=\"nf\"\u003easQueryableState\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e \u003cspan class=\"n\"\u003equeryableStateName\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// FoldingState\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eQueryableStateStream\u003c/span\u003e \u003cspan class=\"nf\"\u003easQueryableState\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eString\u003c/span\u003e \u003cspan class=\"n\"\u003equeryableStateName\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eFoldingStateDescriptor\u003c/span\u003e \u003cspan class=\"n\"\u003estateDescriptor\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// ReducingState\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eQueryableStateStream\u003c/span\u003e \u003cspan class=\"nf\"\u003easQueryableState\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eString\u003c/span\u003e \u003cspan class=\"n\"\u003equeryableStateName\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eReducingStateDescriptor\u003c/span\u003e \u003cspan class=\"n\"\u003estateDescriptor\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e注意：没有可查询的 \u003ccode\u003eListState\u003c/code\u003e 接收器，因为这会导致一个不断增长的列表，可能无法清理，因此最终会消耗过多的内存。\u003c/p\u003e\n\u003cp\u003e返回的 \u003ccode\u003eQueryableStateStream\u003c/code\u003e 可以被看作是一个接收器(sink)，不能被进一步转换。在内部，一个 \u003ccode\u003eQueryableStateStream\u003c/code\u003e 会被翻译成一个操作符，它使用所有传入的记录来更新可查询状态实例。更新逻辑是由 \u003ccode\u003easQueryableState\u003c/code\u003e 调用中提供的 \u003ccode\u003eStateDescriptor\u003c/code\u003e 的类型暗示的。在像下面这样的程序中，keyed stream 的所有记录将通过 \u003ccode\u003eValueState.update(value)\u003c/code\u003e 来更新状态实例:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003estream\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ekeyBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003easQueryableState\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;query-name\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这就像 Scala API 的 \u003ccode\u003eflatMapWithState\u003c/code\u003e 一样。\u003c/p\u003e\n\u003ch3 id=\"管理的-keyed-state\"\u003e管理的 Keyed State\u003c/h3\u003e\n\u003cp\u003e通过 \u003ccode\u003eStateDescriptor.setQueryable(String queryableStateName)\u003c/code\u003e 使相应的状态描述符成为可查询的状态，可以使操作符的托管键控状态(参见\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html#using-managed-keyed-state\"\u003e使用 Managed Keyed State)\u003c/a\u003e)成为可查询的状态，如下面的例子。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"nc\"\u003eValueStateDescriptor\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003edescriptor\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e\n        \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eValueStateDescriptor\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u0026gt;(\u003c/span\u003e\n                \u003cspan class=\"s\"\u003e\u0026#34;average\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"c1\"\u003e// the state name\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e                \u003cspan class=\"nc\"\u003eTypeInformation\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eof\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eTypeHint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nc\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;()\u003c/span\u003e \u003cspan class=\"o\"\u003e{}));\u003c/span\u003e \u003cspan class=\"c1\"\u003e// type information\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003cspan class=\"n\"\u003edescriptor\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esetQueryable\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;query-name\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e// queryable state name\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e注意：\u003ccode\u003equeryableStateName\u003c/code\u003e 参数可以任意选择，并且只用于查询。它不一定要与状态本身的名称相同。\u003c/p\u003e\n\u003cp\u003e这个变体对于哪种类型的状态可以被查询没有限制。这意味着它可以用于任何 ValueState、ReduceState、ListState、MapState、AggregatingState 以及目前已被废弃的 FoldingState。\u003c/p\u003e\n\u003ch3 id=\"查询状态\"\u003e查询状态\u003c/h3\u003e\n\u003cp\u003e到目前为止，你已经设置了你的集群以可查询的状态运行，并且你已经将你的（部分）状态声明为可查询。现在是时候看看如何查询这个状态了。\u003c/p\u003e\n\u003cp\u003e为此，你可以使用 \u003ccode\u003eQueryableStateClient\u003c/code\u003e 辅助类。它可以在 \u003ccode\u003eflink-queryable-state-client jar\u003c/code\u003e 中找到，它必须和 flink-core 一起被显式地包含在项目的 pom.xml 中作为依赖，如下所示。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;dependency\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"nt\"\u003e\u0026lt;groupId\u0026gt;\u003c/span\u003eorg.apache.flink\u003cspan class=\"nt\"\u003e\u0026lt;/groupId\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"nt\"\u003e\u0026lt;artifactId\u0026gt;\u003c/span\u003eflink-core\u003cspan class=\"nt\"\u003e\u0026lt;/artifactId\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"nt\"\u003e\u0026lt;version\u0026gt;\u003c/span\u003e1.11.0\u003cspan class=\"nt\"\u003e\u0026lt;/version\u0026gt;\u003c/span\u003e\n\u003cspan class=\"nt\"\u003e\u0026lt;/dependency\u0026gt;\u003c/span\u003e\n\u003cspan class=\"nt\"\u003e\u0026lt;dependency\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"nt\"\u003e\u0026lt;groupId\u0026gt;\u003c/span\u003eorg.apache.flink\u003cspan class=\"nt\"\u003e\u0026lt;/groupId\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"nt\"\u003e\u0026lt;artifactId\u0026gt;\u003c/span\u003eflink-queryable-state-client-java\u003cspan class=\"nt\"\u003e\u0026lt;/artifactId\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"nt\"\u003e\u0026lt;version\u0026gt;\u003c/span\u003e1.11.0\u003cspan class=\"nt\"\u003e\u0026lt;/version\u0026gt;\u003c/span\u003e\n\u003cspan class=\"nt\"\u003e\u0026lt;/dependency\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e更多的内容，可以查看如何\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/project-configuration.html\"\u003e设置 Flink 程序\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eQueryableStateClient\u003c/code\u003e 会将你的查询提交给内部代理，然后代理会处理你的查询并返回最终结果。初始化客户端的唯一要求是提供一个有效的 TaskManager 主机名（记住每个 TaskManager 上都有一个可查询状态代理运行）和代理监听的端口。更多关于如何配置代理和状态服务器端口的信息请参见\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/queryable_state.html#configuration\"\u003e配置部分\u003c/a\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"n\"\u003eQueryableStateClient\u003c/span\u003e \u003cspan class=\"n\"\u003eclient\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eQueryableStateClient\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etmHostname\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eproxyPort\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e客户端准备好后，要查询一个类型为 V 的状态，与类型为 K 的键相关联，可以使用该方法。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"n\"\u003eCompletableFuture\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eS\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"nf\"\u003egetKvState\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eJobID\u003c/span\u003e \u003cspan class=\"n\"\u003ejobId\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eString\u003c/span\u003e \u003cspan class=\"n\"\u003equeryableStateName\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eK\u003c/span\u003e \u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eTypeInformation\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eK\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ekeyTypeInfo\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eStateDescriptor\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eS\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eV\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003estateDescriptor\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e以上返回一个 CompletableFuture，最终持有 ID 为 jobID 的作业的 \u003ccode\u003equeryableStateName\u003c/code\u003e 所标识的可查询状态实例的状态值。key 是你对其状态感兴趣的键，keyTypeInfo 将告诉 Flink 如何序列化/解序列化它。最后，\u003ccode\u003estateDescriptor\u003c/code\u003e 包含了关于所请求的状态的必要信息，即它的类型（Value、Reduce 等）和如何序列化/解序列化它的必要信息。\u003c/p\u003e\n\u003cp\u003e细心的读者会注意到，返回的 future 包含一个 S 类型的值，即一个包含实际值的 \u003ccode\u003eState\u003c/code\u003e 对象。这可以是 Flink 支持的任何一种状态类型。ValueState，ReduceState，ListState，MapState，AggregatingState，以及目前已经废弃的 FoldingState。\u003c/p\u003e\n\u003cp\u003e注意：这些状态对象不允许对包含的状态进行修改。您可以使用它们来获取状态的实际值，例如使用 \u003ccode\u003evalueState.get()\u003c/code\u003e，或者迭代包含的 \u003ccode\u003e\u0026lt;K，V\u0026gt;\u003c/code\u003e 条目，例如使用 \u003ccode\u003emapState.entry()\u003c/code\u003e，但您不能修改它们。举个例子，在返回的列表状态上调用 \u003ccode\u003eadd()\u003c/code\u003e 方法会抛出一个 \u003ccode\u003eUnsupportedOperationException\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e注意：客户端是异步的，可以被多个线程共享。在未使用时需要通过 \u003ccode\u003eQueryableStateClient.shutdown()\u003c/code\u003e 来关闭它，以释放资源。\u003c/p\u003e\n\u003ch3 id=\"例子\"\u003e例子\u003c/h3\u003e\n\u003cp\u003e下面的例子扩展了 \u003ccode\u003eCountWindowAverage\u003c/code\u003e 的例子(请看\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html#using-managed-keyed-state\"\u003e使用 Managed Keyed State\u003c/a\u003e)，使其可查询，并展示了如何查询这个值。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eCountWindowAverage\u003c/span\u003e \u003cspan class=\"kd\"\u003eextends\u003c/span\u003e \u003cspan class=\"n\"\u003eRichFlatMapFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;,\u003c/span\u003e \u003cspan class=\"n\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\n    \u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e \u003cspan class=\"kd\"\u003etransient\u003c/span\u003e \u003cspan class=\"n\"\u003eValueState\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003esum\u003c/span\u003e\u003cspan class=\"o\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// a tuple containing the count and the sum\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n    \u003cspan class=\"nd\"\u003e@Override\u003c/span\u003e\n    \u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eflatMap\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eCollector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"kd\"\u003ethrows\u003c/span\u003e \u003cspan class=\"n\"\u003eException\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ecurrentSum\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003esum\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e();\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ecurrentSum\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ef0\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ecurrentSum\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ef1\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ef1\u003c/span\u003e\u003cspan class=\"o\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"n\"\u003esum\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eupdate\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrentSum\u003c/span\u003e\u003cspan class=\"o\"\u003e);\u003c/span\u003e\n\n        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrentSum\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ef0\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ecollect\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u0026gt;(\u003c/span\u003e\u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ef0\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ecurrentSum\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ef1\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"n\"\u003ecurrentSum\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ef0\u003c/span\u003e\u003cspan class=\"o\"\u003e));\u003c/span\u003e\n            \u003cspan class=\"n\"\u003esum\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eclear\u003c/span\u003e\u003cspan class=\"o\"\u003e();\u003c/span\u003e\n        \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"nd\"\u003e@Override\u003c/span\u003e\n    \u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eopen\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eConfiguration\u003c/span\u003e \u003cspan class=\"n\"\u003econfig\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eValueStateDescriptor\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003edescriptor\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e\n                \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eValueStateDescriptor\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u0026gt;(\u003c/span\u003e\n                        \u003cspan class=\"s\"\u003e\u0026#34;average\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"c1\"\u003e// the state name\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e                        \u003cspan class=\"n\"\u003eTypeInformation\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eof\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eTypeHint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;()\u003c/span\u003e \u003cspan class=\"o\"\u003e{}));\u003c/span\u003e \u003cspan class=\"c1\"\u003e// type information\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"n\"\u003edescriptor\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003esetQueryable\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;query-name\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"n\"\u003esum\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003egetRuntimeContext\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"na\"\u003egetState\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edescriptor\u003c/span\u003e\u003cspan class=\"o\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"n\"\u003eOnce\u003c/span\u003e \u003cspan class=\"n\"\u003eused\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"n\"\u003ejob\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eyou\u003c/span\u003e \u003cspan class=\"n\"\u003ecan\u003c/span\u003e \u003cspan class=\"n\"\u003eretrieve\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003ejob\u003c/span\u003e \u003cspan class=\"n\"\u003eID\u003c/span\u003e \u003cspan class=\"n\"\u003eand\u003c/span\u003e \u003cspan class=\"n\"\u003ethen\u003c/span\u003e \u003cspan class=\"n\"\u003equery\u003c/span\u003e \u003cspan class=\"n\"\u003eany\u003c/span\u003e \u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"err\"\u003e’\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e \u003cspan class=\"n\"\u003ecurrent\u003c/span\u003e \u003cspan class=\"n\"\u003estate\u003c/span\u003e \u003cspan class=\"n\"\u003efrom\u003c/span\u003e \u003cspan class=\"k\"\u003ethis\u003c/span\u003e \u003cspan class=\"n\"\u003eoperator\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eQueryableStateClient\u003c/span\u003e \u003cspan class=\"n\"\u003eclient\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eQueryableStateClient\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etmHostname\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eproxyPort\u003c/span\u003e\u003cspan class=\"o\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// the state descriptor of the state to be fetched.\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eValueStateDescriptor\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003edescriptor\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e\n        \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eValueStateDescriptor\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u0026gt;(\u003c/span\u003e\n          \u003cspan class=\"s\"\u003e\u0026#34;average\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n          \u003cspan class=\"n\"\u003eTypeInformation\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eof\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eTypeHint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;()\u003c/span\u003e \u003cspan class=\"o\"\u003e{}));\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eCompletableFuture\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eValueState\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eresultFuture\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eclient\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003egetKvState\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ejobId\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;query-name\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eBasicTypeInfo\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eLONG_TYPE_INFO\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003edescriptor\u003c/span\u003e\u003cspan class=\"o\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// now handle the returned value\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eresultFuture\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ethenAccept\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eresponse\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003etry\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eres\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eresponse\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eget\u003c/span\u003e\u003cspan class=\"o\"\u003e();\u003c/span\u003e\n        \u003cspan class=\"o\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003ecatch\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eException\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eprintStackTrace\u003c/span\u003e\u003cspan class=\"o\"\u003e();\u003c/span\u003e\n        \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"o\"\u003e});\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"配置\"\u003e配置\u003c/h2\u003e\n\u003cp\u003e以下配置参数会影响可查询状态服务器和客户端的行为，它们被定义在 \u003ccode\u003eQueryableStateOptions\u003c/code\u003e 中。\u003c/p\u003e\n\u003ch3 id=\"状态服务器\"\u003e状态服务器\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003equeryable-state.server.ports\u003c/code\u003e：可查询状态服务器的服务器端口范围。如果在同一台机器上运行多个 task manager，这对避免端口冲突很有用。指定的范围可以是：一个端口: \u0026ldquo;9123\u0026rdquo;，一个端口范围: \u0026ldquo;50100-50200\u0026rdquo;，或者一个范围和或点的列表: \u0026ldquo;50100-50200,50300-50400,51234\u0026rdquo;。默认端口为 9067。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003equeryable-state.server.network-threads\u003c/code\u003e: 接收状态服务器传入请求的网络（事件循环）线程数（0 =\u0026gt; #slots）。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003equeryable-state.server.query-threads\u003c/code\u003e: 为状态服务器处理/服务传入请求的线程数（0 =\u0026gt; #slots）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"代理\"\u003e代理\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003equeryable-state.proxy.ports\u003c/code\u003e：可查询状态代理服务器的端口范围。如果在同一台机器上运行多个 task manager，这对避免端口冲突很有用。指定的范围可以是：一个端口: \u0026ldquo;9123\u0026rdquo;，一个端口范围: \u0026ldquo;50100-50200\u0026rdquo;，或者一个范围和或点的列表: \u0026ldquo;50100-50200,50300-50400,51234\u0026rdquo;。默认端口为 9069。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003equeryable-state.proxy.network-threads\u003c/code\u003e：为客户端代理接收传入请求的网络（事件循环）线程数（0 =\u0026gt; #slots）。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003equeryable-state.proxy.query-threads\u003c/code\u003e：为客户端代理处理/服务传入请求的线程数（0 =\u0026gt; #slots）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"限制条件\"\u003e限制条件\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e可查询状态的生命周期与任务的生命周期绑定，例如，任务在启动时注册可查询状态，在处置时取消注册。在未来的版本中，我们希望将其解耦，以便在任务完成后允许查询，并通过状态复制加快恢复速度。\u003c/li\u003e\n\u003cli\u003e关于可用 KvState 的通知是通过一个简单的告诉发生的。将来应该改进这个功能，使其更加强大，包括询问和确认。\u003c/li\u003e\n\u003cli\u003e服务器和客户端会跟踪查询的统计数据。目前默认情况下，这些数据是被禁用的，因为它们不会暴露在任何地方。一旦有更好的支持通过 Metrics 系统发布这些数字，我们应该启用统计。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/queryable_state.html\"\u003ehttps://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/queryable_state.html\u003c/a\u003e\u003c/p\u003e\n","text":"注意：可查询状态的客户端 API 目前处于不断发展的状态，对所提供接口的稳定性不做保证。在即将到来的 Flink 版本中，客户端的 API 很可能会有突破性的变化。\n简而言之，这个功能将 Flink 的 managed keyed (partitioned) state（参见 Working with State）暴露给外界，并允许用户从 Flink 外部查询作业的状态。对于某些场景来说，可查询状态消除了与外部系统（如键值存储）进行分布式操作/交易的需求，而这往往是实践中的瓶颈。此外，该功能对于调试目的可能特别有用。\n注意事项: 当查询一个状态对象时，该对象是在没有任何同步或复制的情况下从一个并发线程访问的。这是一个设计上的选择，因为上述任何一种情况都会导致作业延迟的增加，这是我们想要避免的。因为任何使用 Java 堆空间的状态后端，如 MemoryStateBackend 或 FsStateBackend，在检索值时都不会使用副本，而是直接引用存储的值，所以读-修改-写模式是不安全的，可能会导致可查询状态服务器因并发修改而失败。RocksDBStateBackend 则可以避免这些问题。\n架构 在展示如何使用可查询状态之前，先简单介绍一下构成它的实体。Queryable State 功能由三个主要实体组成。\n QueryableStateClient，它（可能）运行在 Flink 集群之外，并提交用户查询。 QueryableStateClientProxy，它运行在每个 TaskManager 上（即 Flink 集群内部），负责接收客户端的查询，代表他从负责的 TaskManager 中获取所请求的状态，并将其返回给客户端，以及 QueryableStateServer，它运行在每个 TaskManager 上，负责为本地存储的状态提供服务。  客户端连接到其中一个代理，并发送一个与特定键 k 相关联的状态的请求。正如在使用状态中所述，keyed state 被组织在键组(Key Groups)中，每个 TaskManager 都被分配了一些这样的键组(Key Groups)。为了发现哪个 TaskManager 负责持有 k 的键组，代理将询问 JobManager。根据答案，代理将查询运行在该 TaskManager 上的 QueryableStateServer，以获取与 k 相关联的状态，并将响应转发到客户端。\n激活可查询状态 要在 Flink 集群上启用可查询状态，你需要做以下工作。\n 将 flink-queryable-state-runtime_2.11-1.11.0.jar 从 Flink 发行版的 opt/ 文件夹中复制到 lib/ 文件夹中。 设置属性 queryable-state.enable 为 true。请参阅配置文档了解详情和附加参数。  要验证您的群集是否在启用可查询状态后运行，请检查任何 TaskManager 的日志中的行。\u0026ldquo;Started the Queryable State Proxy Server @ \u0026hellip;\u0026quot;。\n使状态可查询 现在你已经在集群上激活了可查询状态，现在是时候看看如何使用它了。为了使一个状态对外界可见，它需要通过使用以下方式明确地成为可查询状态。\n QueryableStateStream, 一个方便的对象，它作为一个接收器(sink)，并把它的传入值作为可查询的状态提供，或者是 stateDescriptor.setQueryable(String queryableStateName) 方法，使得状态描述符所代表的 keyed state，可以查询。  下面的章节将解释这两种方法的使用。\n可查询的状态流 在 KeyedStream 上调用 .asQueryableState(stateName, stateDescriptor) 会返回一个 QueryableStateStream，它将其值作为可查询状态提供。根据状态的类型，asQueryableState() 方法有以下几种变体。\n// ValueState QueryableStateStream asQueryableState( String queryableStateName, ValueStateDescriptor stateDescriptor) // Shortcut for explicit ValueStateDescriptor variant QueryableStateStream asQueryableState(String queryableStateName) // FoldingState QueryableStateStream asQueryableState( String queryableStateName, FoldingStateDescriptor stateDescriptor) // ReducingState QueryableStateStream asQueryableState( String queryableStateName, ReducingStateDescriptor stateDescriptor) 注意：没有可查询的 ListState 接收器，因为这会导致一个不断增长的列表，可能无法清理，因此最终会消耗过多的内存。\n返回的 QueryableStateStream 可以被看作是一个接收器(sink)，不能被进一步转换。在内部，一个 QueryableStateStream 会被翻译成一个操作符，它使用所有传入的记录来更新可查询状态实例。更新逻辑是由 asQueryableState 调用中提供的 StateDescriptor 的类型暗示的。在像下面这样的程序中，keyed stream 的所有记录将通过 ValueState.update(value) 来更新状态实例:\nstream.keyBy(0).asQueryableState(\u0026#34;query-name\u0026#34;) 这就像 Scala API 的 flatMapWithState 一样。\n管理的 Keyed State 通过 StateDescriptor.setQueryable(String queryableStateName) 使相应的状态描述符成为可查询的状态，可以使操作符的托管键控状态(参见使用 Managed Keyed State))成为可查询的状态，如下面的例子。\nValueStateDescriptor\u0026lt;Tuple2\u0026lt;Long, Long\u0026gt;\u0026gt; descriptor = new ValueStateDescriptor\u0026lt;\u0026gt;( \u0026#34;average\u0026#34;, // the state name  TypeInformation.of(new TypeHint\u0026lt;Tuple2\u0026lt;Long, Long\u0026gt;\u0026gt;() {})); // type information  descriptor.setQueryable(\u0026#34;query-name\u0026#34;); // queryable state name 注意：queryableStateName 参数可以任意选择，并且只用于查询。它不一定要与状态本身的名称相同。\n这个变体对于哪种类型的状态可以被查询没有限制。这意味着它可以用于任何 ValueState、ReduceState、ListState、MapState、AggregatingState 以及目前已被废弃的 FoldingState。\n查询状态 到目前为止，你已经设置了你的集群以可查询的状态运行，并且你已经将你的（部分）状态声明为可查询。现在是时候看看如何查询这个状态了。\n为此，你可以使用 QueryableStateClient 辅助类。它可以在 flink-queryable-state-client jar 中找到，它必须和 flink-core 一起被显式地包含在项目的 pom.xml 中作为依赖，如下所示。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.flink\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;flink-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.11.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.flink\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;flink-queryable-state-client-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.11.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 更多的内容，可以查看如何设置 Flink 程序。\nQueryableStateClient 会将你的查询提交给内部代理，然后代理会处理你的查询并返回最终结果。初始化客户端的唯一要求是提供一个有效的 TaskManager 主机名（记住每个 TaskManager 上都有一个可查询状态代理运行）和代理监听的端口。更多关于如何配置代理和状态服务器端口的信息请参见配置部分。\nQueryableStateClient client = new QueryableStateClient(tmHostname, proxyPort) 客户端准备好后，要查询一个类型为 V 的状态，与类型为 K 的键相关联，可以使用该方法。\nCompletableFuture\u0026lt;S\u0026gt; getKvState( JobID jobId, String queryableStateName, K key, TypeInformation\u0026lt;K\u0026gt; keyTypeInfo, StateDescriptor\u0026lt;S, V\u0026gt; stateDescriptor) 以上返回一个 CompletableFuture，最终持有 ID 为 jobID 的作业的 queryableStateName 所标识的可查询状态实例的状态值。key 是你对其状态感兴趣的键，keyTypeInfo 将告诉 Flink 如何序列化/解序列化它。最后，stateDescriptor 包含了关于所请求的状态的必要信息，即它的类型（Value、Reduce 等）和如何序列化/解序列化它的必要信息。\n细心的读者会注意到，返回的 future 包含一个 S 类型的值，即一个包含实际值的 State 对象。这可以是 Flink 支持的任何一种状态类型。ValueState，ReduceState，ListState，MapState，AggregatingState，以及目前已经废弃的 FoldingState。\n注意：这些状态对象不允许对包含的状态进行修改。您可以使用它们来获取状态的实际值，例如使用 valueState.get()，或者迭代包含的 \u0026lt;K，V\u0026gt; 条目，例如使用 mapState.entry()，但您不能修改它们。举个例子，在返回的列表状态上调用 add() 方法会抛出一个 UnsupportedOperationException。\n注意：客户端是异步的，可以被多个线程共享。在未使用时需要通过 QueryableStateClient.shutdown() 来关闭它，以释放资源。\n例子 下面的例子扩展了 CountWindowAverage 的例子(请看使用 Managed Keyed State)，使其可查询，并展示了如何查询这个值。\npublic class CountWindowAverage extends RichFlatMapFunction\u0026lt;Tuple2\u0026lt;Long, Long\u0026gt;, Tuple2\u0026lt;Long, Long\u0026gt;\u0026gt; { private transient ValueState\u0026lt;Tuple2\u0026lt;Long, Long\u0026gt;\u0026gt; sum; // a tuple containing the count and the sum  @Override public void flatMap(Tuple2\u0026lt;Long, Long\u0026gt; input, Collector\u0026lt;Tuple2\u0026lt;Long, Long\u0026gt;\u0026gt; out) throws Exception { Tuple2\u0026lt;Long, Long\u0026gt; currentSum = sum.value(); currentSum.f0 += 1; currentSum.f1 += input.f1; sum.update(currentSum); if (currentSum.f0 \u0026gt;= 2) { out.collect(new Tuple2\u0026lt;\u0026gt;(input.f0, currentSum.f1 / currentSum.f0)); sum.clear(); } } @Override public void open(Configuration config) { ValueStateDescriptor\u0026lt;Tuple2\u0026lt;Long, Long\u0026gt;\u0026gt; descriptor = new ValueStateDescriptor\u0026lt;\u0026gt;( \u0026#34;average\u0026#34;, // the state name  TypeInformation.of(new TypeHint\u0026lt;Tuple2\u0026lt;Long, Long\u0026gt;\u0026gt;() {})); // type information  descriptor.setQueryable(\u0026#34;query-name\u0026#34;); sum = getRuntimeContext().getState(descriptor); } } Once used in a job, you can retrieve the job ID and then query any key’s current state from this operator: QueryableStateClient client = new QueryableStateClient(tmHostname, proxyPort); // the state descriptor of the state to be fetched. ValueStateDescriptor\u0026lt;Tuple2\u0026lt;Long, Long\u0026gt;\u0026gt; descriptor = new ValueStateDescriptor\u0026lt;\u0026gt;( \u0026#34;average\u0026#34;, TypeInformation.of(new TypeHint\u0026lt;Tuple2\u0026lt;Long, Long\u0026gt;\u0026gt;() {})); CompletableFuture\u0026lt;ValueState\u0026lt;Tuple2\u0026lt;Long, Long\u0026gt;\u0026gt;\u0026gt; resultFuture = client.getKvState(jobId, \u0026#34;query-name\u0026#34;, key, BasicTypeInfo.LONG_TYPE_INFO, descriptor); // now handle the returned value resultFuture.thenAccept(response -\u0026gt; { try { Tuple2\u0026lt;Long, Long\u0026gt; res = response.get(); } catch (Exception e) { e.printStackTrace(); } }); 配置 以下配置参数会影响可查询状态服务器和客户端的行为，它们被定义在 QueryableStateOptions 中。\n状态服务器  queryable-state.server.ports：可查询状态服务器的服务器端口范围。如果在同一台机器上运行多个 task manager，这对避免端口冲突很有用。指定的范围可以是：一个端口: \u0026ldquo;9123\u0026rdquo;，一个端口范围: \u0026ldquo;50100-50200\u0026rdquo;，或者一个范围和或点的列表: \u0026ldquo;50100-50200,50300-50400,51234\u0026rdquo;。默认端口为 9067。 queryable-state.server.network-threads: 接收状态服务器传入请求的网络（事件循环）线程数（0 =\u0026gt; #slots）。 queryable-state.server.query-threads: 为状态服务器处理/服务传入请求的线程数（0 =\u0026gt; #slots）。  代理  queryable-state.proxy.ports：可查询状态代理服务器的端口范围。如果在同一台机器上运行多个 task manager，这对避免端口冲突很有用。指定的范围可以是：一个端口: \u0026ldquo;9123\u0026rdquo;，一个端口范围: \u0026ldquo;50100-50200\u0026rdquo;，或者一个范围和或点的列表: \u0026ldquo;50100-50200,50300-50400,51234\u0026rdquo;。默认端口为 9069。 queryable-state.proxy.network-threads：为客户端代理接收传入请求的网络（事件循环）线程数（0 =\u0026gt; #slots）。 queryable-state.proxy.query-threads：为客户端代理处理/服务传入请求的线程数（0 =\u0026gt; #slots）。  限制条件  可查询状态的生命周期与任务的生命周期绑定，例如，任务在启动时注册可查询状态，在处置时取消注册。在未来的版本中，我们希望将其解耦，以便在任务完成后允许查询，并通过状态复制加快恢复速度。 关于可用 KvState 的通知是通过一个简单的告诉发生的。将来应该改进这个功能，使其更加强大，包括询问和确认。 服务器和客户端会跟踪查询的统计数据。目前默认情况下，这些数据是被禁用的，因为它们不会暴露在任何地方。一旦有更好的支持通过 Metrics 系统发布这些数字，我们应该启用统计。  原文链接: https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/queryable_state.html\n"},"name":"可查询状态","published":"2020-08-22T00:00:00+08:00","summary":"Queryable State Beta","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-08-21-queryable-state-beta/"}