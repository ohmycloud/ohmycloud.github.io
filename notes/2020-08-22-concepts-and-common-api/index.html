<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
    
    
    

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    
    <meta name="referrer" content="no-referrer">

    <title>
        
            概念和通用 API ❚ 焉知非鱼
        
    </title>

    
    


    
    
    
    

    
    
    
    

    
    
    

    
    
    
    <style>
     
     
     :root {
         --theme-color: #ac4142;
         --theme-color-light: rgba(172, 65, 66, 0.2);
     }
     
     html {
         line-height: 1.5;
     }
    </style>

    
    

    
    
    
    
    <link rel="stylesheet" href="/css/refined.min.61b1de55623520dab99b70e9e2298001fb97241583a47396e2f10feb789e300d.css">
    
    <link rel="preload" href="/css/refined.min.61b1de55623520dab99b70e9e2298001fb97241583a47396e2f10feb789e300d.css" as="style">

    



    
        <style>
         
         /* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }

         
         /* Overrides on top of the theme and Chroma CSS */
/* Chroma-based lines highlighting in code blocks */
.chroma .hl {
    background-color: #e8e8e8;
    /* Extend highlight up to 100 characters (assuming that the code blocks never have more than 100 characters in a line) */
    min-width: 100ch;
}
/* GenericHeading */ .chroma .gh { color: #999999; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa; font-weight: bold }

         
        </style>
    

    

    
    
    

    
    <script src="/js/responsive-nav-orig.min.355eebd835ac8071d56b337f68ffbbddc0f6487625599895e3e0b0461e791ebb.js"></script>
    
    <link rel="preload" href="/js/responsive-nav-orig.min.355eebd835ac8071d56b337f68ffbbddc0f6487625599895e3e0b0461e791ebb.js" as="script">

    
    
    <script defer src="/js/libs/fa/fontawesome-all.min.78bd3583027f40ce4330d39e1f1df56bda5f4af819aac2d0214ba529918c9e95.js"></script>
    
    <link rel="preload" href="/js/libs/fa/fontawesome-all.min.78bd3583027f40ce4330d39e1f1df56bda5f4af819aac2d0214ba529918c9e95.js" as="script">

    

    

    
    
    

    
    
<!-- rel="me" links for IndieAuth -->







    
 
<meta property="og:title" content="概念和通用 API" />
<meta property="og:description"
      content="Concepts and Common API" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ohmyweekly.github.io/notes/2020-08-22-concepts-and-common-api/" />


    
        <meta property="article:published_time" content="2020-08-22T00:00:00&#43;08:00"/>
    
    
        <meta property="article:modified_time" content="2020-08-22T00:00:00&#43;08:00"/>
    









    




     <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="概念和通用 API"/>
<meta name="twitter:description" content="Concepts and Common API"/>


    
    
    <link rel="alternate" type="application/jf2post+json" href="https://ohmyweekly.github.io/notes/2020-08-22-concepts-and-common-api/jf2post.json" title="Jf2post for 焉知非鱼" />
    
     



    
    
    
        
    


     
        
        <meta name="DC.Creator" content="焉知非鱼"/>
    



    
    
    
    <meta name="hugo-build-date" content=""/>
    <meta name="hugo-commit-hash" content=""/>
    <meta name="generator" content="Hugo 0.63.2" />
</head>


    
        <body lang="en">
    

        
        <div class="border" id="home"></div>

        <div class="wrapper">   
            
<nav id="nav" class="nav-collapse opened" aria-hidden="false">
    <ul class="navbar">
        <li><a class="" href="/">Home</a></li>
        
            
                <li><a class="" href="https://ohmyweekly.github.io/posts/">Posts</a></li>
            
        
            
                <li><a class="" href="https://ohmyweekly.github.io/notes/">Notes</a></li>
            
        
        
            <li><a class="" href="https://ohmyweekly.github.io/search/">Search</a></li>
        
    </ul>
</nav>

            <div class="container">
                <header class="masthead">
                    <div class="masthead-title no-text-decoration">
                        <a href="/">焉知非鱼</a> <span class="blinking-cursor">❚</span>
                    </div>
                    <div class="masthead-tagline">
                        rakulang, dartlang, nimlang, golang, rustlang, lang lang no see
                    </div>
                </header>

                








<article class="post h-entry notes">
    <header>
        <div class="center">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 54 posts categorized in ‘Flink’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/categories/flink/">Flink</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 73 posts tagged with ‘Flink’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/flink/">Flink</a>
                            </li>
                        
                    
                        
                        
                        
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__table-api-sql__"
                                
                                
                                title="See all 25 posts tagged with ‘Table API &amp; SQL’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/table-api-sql/">Table API &amp; SQL</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>

        <h1 class="post-title p-name">概念和通用 API</h1>

        
        <data class="u-url" value="https://ohmyweekly.github.io/notes/2020-08-22-concepts-and-common-api/"></data>

        <div class="date-syndication">
            


    
    
    <div class="post-date">
        
        <time datetime="2020-08-22T00:00:00+0800" class="dt-published">Sat Aug 22, 2020</time>
        
        
    </div>


            




        </div>
         



    
    
    
        
    


    
        
        <span class="hide">
            &mdash; <a href="https://ohmyweekly.github.io" class="u-author">焉知非鱼</a>
        </span>
    


    </header>

    <div class="content">
        
    <div class="description p-summary">
        
        
        
        
        
            
            
        
        <p>Concepts and Common API</p>
    </div>



        





                       


        <div class="e-content">
            




<h2 id="概念和通用-api">概念和通用 API&nbsp;<a class="headline-hash no-text-decoration" href="#概念和通用-api">#</a> </h2>
<p>Table API 和 SQL 被集成在一个联合 API 中。这个 API 的核心概念是一个 Table，作为查询的输入和输出。本文档介绍了具有 Table API 和 SQL 查询的程序的常用结构，如何注册 Table，如何查询 Table，如何发出 Table。</p>
<h2 id="两种-planners-的主要区别">两种 Planners 的主要区别&nbsp;<a class="headline-hash no-text-decoration" href="#两种-planners-的主要区别">#</a> </h2>
<ol>
<li>Blink 将批处理作业视为流式作业的一种特殊情况。因此，也不支持 Table 和 DataSet 之间的转换，批处理作业不会被翻译成 DateSet 程序，而是翻译成 DataStream 程序，和流作业一样。</li>
<li>Blink 计划器不支持 BatchTableSource，请使用有界的 StreamTableSource 代替。</li>
<li>旧计划器和 Blink 计划器的 FilterableTableSource 的实现是不兼容的。旧的规划者会将 PlannerExpressions 推送到 FilterableTableSource 中，而 Blink 规划者会将 Expressions 推送下去。</li>
<li>基于字符串的键值<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/config.html">配置</a>选项(详情请看配置文档)只用于 Blink 规划器。</li>
<li>PlannerConfig 在两个规划器中的实现(CalciteConfig)是不同的。</li>
<li>Blink 规划师将在 TableEnvironment 和 StreamTableEnvironment 上把多个汇优化成一个 DAG。旧的规划器总是会将每个汇优化成一个新的 DAG，其中所有的 DAG 是相互独立的。</li>
<li>现在老的计划器不支持目录统计，而 Blink 计划器支持。</li>
</ol>
<h2 id="table-api-和-sql-程序的结构">Table API 和 SQL 程序的结构&nbsp;<a class="headline-hash no-text-decoration" href="#table-api-和-sql-程序的结构">#</a> </h2>
<p>所有用于批处理和流处理的 Table API 和 SQL 程序都遵循相同的模式。下面的代码示例显示了 Table API 和 SQL 程序的共同结构。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// create a TableEnvironment for specific planner batch or streaming
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span> <span class="c1">// see &#34;Create a TableEnvironment&#34; section
</span><span class="c1"></span>
<span class="c1">// create a Table
</span><span class="c1"></span><span class="n">tableEnv</span><span class="o">.</span><span class="n">connect</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span><span class="o">.</span><span class="n">createTemporaryTable</span><span class="o">(</span><span class="s">&#34;table1&#34;</span><span class="o">)</span>
<span class="c1">// register an output Table
</span><span class="c1"></span><span class="n">tableEnv</span><span class="o">.</span><span class="n">connect</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span><span class="o">.</span><span class="n">createTemporaryTable</span><span class="o">(</span><span class="s">&#34;outputTable&#34;</span><span class="o">)</span>

<span class="c1">// create a Table from a Table API query
</span><span class="c1"></span><span class="k">val</span> <span class="n">tapiResult</span> <span class="k">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="s">&#34;table1&#34;</span><span class="o">)</span><span class="o">.</span><span class="n">select</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span>
<span class="c1">// create a Table from a SQL query
</span><span class="c1"></span><span class="k">val</span> <span class="n">sqlResult</span>  <span class="k">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">sqlQuery</span><span class="o">(</span><span class="s">&#34;SELECT ... FROM table1 ...&#34;</span><span class="o">)</span>

<span class="c1">// emit a Table API result Table to a TableSink, same for SQL result
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableResult</span> <span class="k">=</span> <span class="n">tapiResult</span><span class="o">.</span><span class="n">executeInsert</span><span class="o">(</span><span class="s">&#34;outputTable&#34;</span><span class="o">)</span>
<span class="n">tableResult</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
</code></pre></div><p>注意：表 API 和 SQL 查询可以很容易地与 DataStream 或 DataSet 程序集成并嵌入其中。请查看<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/common.html#integration-with-datastream-and-dataset-api">与 DataStream 和 DataSet API 的集成</a>部分，了解如何将 DataStream 和 DataSets 转换为表，反之亦然。</p>
<h2 id="创建一个-tableenvironment">创建一个 TableEnvironment&nbsp;<a class="headline-hash no-text-decoration" href="#创建一个-tableenvironment">#</a> </h2>
<p>TableEnvironment 是 Table API 和 SQL 集成的核心概念。它负责</p>
<ul>
<li>在内部目录(catalog)中注册一个 Table</li>
<li>登记目录(catalog)</li>
<li>加载可插拔模块</li>
<li>执行 SQL 查询</li>
<li>注册一个用户定义的（标量、表或聚合）函数</li>
<li>将 DataStream 或 DataSet 转换为 Table</li>
<li>持有对 ExecutionEnvironment 或 StreamExecutionEnvironment 的引用。</li>
</ul>
<p>一个 Table 总是绑定在一个特定的 TableEnvironment 上。在同一个查询中，不可能将不同 TableEnvironments 的表组合起来，例如，将它们连接或联合起来。</p>
<p>通过调用静态的 <code>BatchTableEnvironment.create()</code> 或 <code>StreamTableEnvironment.create()</code> 方法创建一个 TableEnvironment，其中包含一个 StreamExecutionEnvironment 或 ExecutionEnvironment 和一个可选的 TableConfig。TableConfig 可以用来配置 TableEnvironment 或自定义查询优化和翻译过程（参见 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/common.html#query-optimization">Query Optimization</a>）。</p>
<p>确保选择与你的编程语言相匹配的特定规划器 BatchTableEnvironment/StreamTableEnvironment。</p>
<p>如果这两个规划器 jar 都在 classpath 上（默认行为），你应该明确设置在当前程序中使用哪个规划器。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// **********************
</span><span class="c1"></span><span class="c1">// FLINK STREAMING QUERY
</span><span class="c1"></span><span class="c1">// **********************
</span><span class="c1"></span><span class="k">import</span> <span class="nn">org.apache.flink.streaming.api.scala.StreamExecutionEnvironment</span>
<span class="k">import</span> <span class="nn">org.apache.flink.table.api.EnvironmentSettings</span>
<span class="k">import</span> <span class="nn">org.apache.flink.table.api.bridge.scala.StreamTableEnvironment</span>

<span class="k">val</span> <span class="n">fsSettings</span> <span class="k">=</span> <span class="nc">EnvironmentSettings</span><span class="o">.</span><span class="n">newInstance</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">useOldPlanner</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">inStreamingMode</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">build</span><span class="o">(</span><span class="o">)</span>
<span class="k">val</span> <span class="n">fsEnv</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>
<span class="k">val</span> <span class="n">fsTableEnv</span> <span class="k">=</span> <span class="nc">StreamTableEnvironment</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">fsEnv</span><span class="o">,</span> <span class="n">fsSettings</span><span class="o">)</span>
<span class="c1">// or val fsTableEnv = TableEnvironment.create(fsSettings)
</span><span class="c1"></span>
<span class="c1">// ******************
</span><span class="c1"></span><span class="c1">// FLINK BATCH QUERY
</span><span class="c1"></span><span class="c1">// ******************
</span><span class="c1"></span><span class="k">import</span> <span class="nn">org.apache.flink.api.scala.ExecutionEnvironment</span>
<span class="k">import</span> <span class="nn">org.apache.flink.table.api.bridge.scala.BatchTableEnvironment</span>

<span class="k">val</span> <span class="n">fbEnv</span> <span class="k">=</span> <span class="nc">ExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>
<span class="k">val</span> <span class="n">fbTableEnv</span> <span class="k">=</span> <span class="nc">BatchTableEnvironment</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">fbEnv</span><span class="o">)</span>

<span class="c1">// **********************
</span><span class="c1"></span><span class="c1">// BLINK STREAMING QUERY
</span><span class="c1"></span><span class="c1">// **********************
</span><span class="c1"></span><span class="k">import</span> <span class="nn">org.apache.flink.streaming.api.scala.StreamExecutionEnvironment</span>
<span class="k">import</span> <span class="nn">org.apache.flink.table.api.EnvironmentSettings</span>
<span class="k">import</span> <span class="nn">org.apache.flink.table.api.bridge.scala.StreamTableEnvironment</span>

<span class="k">val</span> <span class="n">bsEnv</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>
<span class="k">val</span> <span class="n">bsSettings</span> <span class="k">=</span> <span class="nc">EnvironmentSettings</span><span class="o">.</span><span class="n">newInstance</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">useBlinkPlanner</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">inStreamingMode</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">build</span><span class="o">(</span><span class="o">)</span>
<span class="k">val</span> <span class="n">bsTableEnv</span> <span class="k">=</span> <span class="nc">StreamTableEnvironment</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">bsEnv</span><span class="o">,</span> <span class="n">bsSettings</span><span class="o">)</span>
<span class="c1">// or val bsTableEnv = TableEnvironment.create(bsSettings)
</span><span class="c1"></span>
<span class="c1">// ******************
</span><span class="c1"></span><span class="c1">// BLINK BATCH QUERY
</span><span class="c1"></span><span class="c1">// ******************
</span><span class="c1"></span><span class="k">import</span> <span class="nn">org.apache.flink.table.api.</span><span class="o">{</span><span class="nc">EnvironmentSettings</span><span class="o">,</span> <span class="nc">TableEnvironment</span><span class="o">}</span>

<span class="k">val</span> <span class="n">bbSettings</span> <span class="k">=</span> <span class="nc">EnvironmentSettings</span><span class="o">.</span><span class="n">newInstance</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">useBlinkPlanner</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">inBatchMode</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">build</span><span class="o">(</span><span class="o">)</span>
<span class="k">val</span> <span class="n">bbTableEnv</span> <span class="k">=</span> <span class="nc">TableEnvironment</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">bbSettings</span><span class="o">)</span>
</code></pre></div><p>注意：如果在 <code>/lib</code> 目录下只有一个 planner jar，可以使用 <code>AnyPlanner(python 的 use_any_planner)</code> 来创建特定的环境设置。</p>
<h2 id="在目录catalog中创建表">在目录(Catalog)中创建表&nbsp;<a class="headline-hash no-text-decoration" href="#在目录catalog中创建表">#</a> </h2>
<p>一个 TableEnvironment 维护着一个表的目录图，这些表是用一个标识符创建的。每个标识符由 3 部分组成：目录名、数据库名和对象名。如果没有指定目录或数据库，将使用当前的默认值（参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/common.html#table-identifier-expanding">Table 标识符展开</a>部分的例子）。</p>
<p>表可以是虚拟的（VIEWS）或常规的（TABLES）。VIEWS 可以从现有的 Table 对象创建，通常是 Table API 或 SQL 查询的结果。TABLES 描述外部数据，如文件、数据库表或消息队列。</p>
<h3 id="临时表与永久表">临时表与永久表&nbsp;<a class="headline-hash no-text-decoration" href="#临时表与永久表">#</a> </h3>
<p>表可以是临时的，与单个 Flink 会话的生命周期挂钩，也可以是永久的，在多个 Flink 会话和集群中可见。</p>
<p>永久表需要一个<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/catalogs.html">目录</a>（如 Hive Metastore）来维护表的元数据。一旦创建了永久表，它对连接到目录的任何 Flink 会话都是可见的，并将继续存在，直到表被显式放弃。</p>
<p>另一方面，临时表总是存储在内存中，并且只在它们创建的 Flink 会话的持续时间内存在。这些表对其他会话不可见。它们不绑定到任何目录或数据库，但可以在一个目录或数据库的命名空间中创建。如果相应的数据库被删除，临时表不会被删除。</p>
<h3 id="shadowing">Shadowing&nbsp;<a class="headline-hash no-text-decoration" href="#shadowing">#</a> </h3>
<p>可以用与现有永久表相同的标识符登记一个临时表。只要临时表存在，临时表就会对永久表产生遮盖，使永久表无法访问。所有使用该标识符的查询都将针对临时表执行。</p>
<p>这可能对实验很有用。它允许首先对临时表运行完全相同的查询，例如，只有一个数据子集，或者数据被混淆了。一旦验证了查询的正确性，就可以针对真正的生产表运行。</p>
<h2 id="创建一个-table">创建一个 Table&nbsp;<a class="headline-hash no-text-decoration" href="#创建一个-table">#</a> </h2>
<h3 id="虚拟表">虚拟表&nbsp;<a class="headline-hash no-text-decoration" href="#虚拟表">#</a> </h3>
<p>表 API 对象对应于 SQL 术语中的 VIEW（虚拟表）。它封装了一个逻辑查询计划。它可以在一个目录中创建，具体如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get a TableEnvironment
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span> <span class="c1">// see &#34;Create a TableEnvironment&#34; section
</span><span class="c1"></span>
<span class="c1">// table is the result of a simple projection query 
</span><span class="c1"></span><span class="k">val</span> <span class="n">projTable</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="s">&#34;X&#34;</span><span class="o">)</span><span class="o">.</span><span class="n">select</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span>

<span class="c1">// register the Table projTable as table &#34;projectedTable&#34;
</span><span class="c1"></span><span class="n">tableEnv</span><span class="o">.</span><span class="n">createTemporaryView</span><span class="o">(</span><span class="s">&#34;projectedTable&#34;</span><span class="o">,</span> <span class="n">projTable</span><span class="o">)</span>
</code></pre></div><p>注意：Table 对象与关系型数据库系统中的 VIEW 类似，即定义 Table 的查询不进行优化，但当另一个查询引用注册的 Table 时，会被内联。如果多个查询引用同一个注册表，则会对每个引用查询进行内联，并执行多次，即注册表的结果不会被共享。</p>
<h3 id="连接器表">连接器表&nbsp;<a class="headline-hash no-text-decoration" href="#连接器表">#</a> </h3>
<p>也可以从<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/connect.html">连接器</a>声明中创建一个关系型数据库中已知的 TABLE。连接器描述的是存储表数据的外部系统。这里可以声明 Apacha Kafka 或普通文件系统等存储系统。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">DDL</span>
<span class="n">tableEnvironment</span>
  <span class="o">.</span><span class="n">connect</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span>
  <span class="o">.</span><span class="n">withFormat</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span>
  <span class="o">.</span><span class="n">withSchema</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span>
  <span class="o">.</span><span class="n">inAppendMode</span><span class="o">(</span><span class="o">)</span>
  <span class="o">.</span><span class="n">createTemporaryTable</span><span class="o">(</span><span class="s">&#34;MyTable&#34;</span><span class="o">)</span>
</code></pre></div><h3 id="扩展-table-标识符">扩展 Table 标识符&nbsp;<a class="headline-hash no-text-decoration" href="#扩展-table-标识符">#</a> </h3>
<p>表总是用目录(catalog)、数据库、表名三部分组成的标识符进行注册。</p>
<p>用户可以将其中的一个目录和一个数据库设置为&quot;当前目录&quot;和&quot;当前数据库&rdquo;。其中，上述 3 部分标识符中的前两部分可以选择，如果不提供，则引用当前目录和当前数据库。用户可以通过表 API 或 SQL 切换当前目录和当前数据库。</p>
<p>标识符遵循 SQL 的要求，这意味着它们可以用反引号符(`)进行转义。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get a TableEnvironment
</span><span class="c1"></span><span class="k">val</span> <span class="n">tEnv</span><span class="k">:</span> <span class="kt">TableEnvironment</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">;</span>
<span class="n">tEnv</span><span class="o">.</span><span class="n">useCatalog</span><span class="o">(</span><span class="s">&#34;custom_catalog&#34;</span><span class="o">)</span>
<span class="n">tEnv</span><span class="o">.</span><span class="n">useDatabase</span><span class="o">(</span><span class="s">&#34;custom_database&#34;</span><span class="o">)</span>

<span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">;</span>

<span class="c1">// register the view named &#39;exampleView&#39; in the catalog named &#39;custom_catalog&#39;
</span><span class="c1"></span><span class="c1">// in the database named &#39;custom_database&#39; 
</span><span class="c1"></span><span class="n">tableEnv</span><span class="o">.</span><span class="n">createTemporaryView</span><span class="o">(</span><span class="s">&#34;exampleView&#34;</span><span class="o">,</span> <span class="n">table</span><span class="o">)</span>

<span class="c1">// register the view named &#39;exampleView&#39; in the catalog named &#39;custom_catalog&#39;
</span><span class="c1"></span><span class="c1">// in the database named &#39;other_database&#39; 
</span><span class="c1"></span><span class="n">tableEnv</span><span class="o">.</span><span class="n">createTemporaryView</span><span class="o">(</span><span class="s">&#34;other_database.exampleView&#34;</span><span class="o">,</span> <span class="n">table</span><span class="o">)</span>

<span class="c1">// register the view named &#39;example.View&#39; in the catalog named &#39;custom_catalog&#39;
</span><span class="c1"></span><span class="c1">// in the database named &#39;custom_database&#39; 
</span><span class="c1"></span><span class="n">tableEnv</span><span class="o">.</span><span class="n">createTemporaryView</span><span class="o">(</span><span class="s">&#34;`example.View`&#34;</span><span class="o">,</span> <span class="n">table</span><span class="o">)</span>

<span class="c1">// register the view named &#39;exampleView&#39; in the catalog named &#39;other_catalog&#39;
</span><span class="c1"></span><span class="c1">// in the database named &#39;other_database&#39; 
</span><span class="c1"></span><span class="n">tableEnv</span><span class="o">.</span><span class="n">createTemporaryView</span><span class="o">(</span><span class="s">&#34;other_catalog.other_database.exampleView&#34;</span><span class="o">,</span> <span class="n">table</span><span class="o">)</span>
</code></pre></div><h2 id="查询一个-table">查询一个 Table&nbsp;<a class="headline-hash no-text-decoration" href="#查询一个-table">#</a> </h2>
<h3 id="table-api">Table API&nbsp;<a class="headline-hash no-text-decoration" href="#table-api">#</a> </h3>
<p>Table API 是 Scala 和 Java 的语言集成查询 API。与 SQL 不同的是，查询不是指定为 Strings，而是在宿主语言中一步步组成。</p>
<p>该 API 基于 Table 类，它表示一个表（流式或批处理），并提供了应用关系操作的方法。这些方法返回一个新的 Table 对象，该对象表示对输入的 Table 应用关系操作的结果。有些关系操作由多个方法调用组成，如 <code>table.groupBy(...).select()</code>，其中 <code>groupBy(...)</code> 指定表的分组，<code>select(...)</code> 是表的分组上的投影。</p>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/tableApi.html">Table API</a> 文档描述了流式表和批处理表上支持的所有 Table API 操作。</p>
<p>下面的示例显示了一个简单的 Table API 聚合查询。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get a TableEnvironment
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span> <span class="c1">// see &#34;Create a TableEnvironment&#34; section
</span><span class="c1"></span>
<span class="c1">// register Orders table
</span><span class="c1"></span>
<span class="c1">// scan registered Orders table
</span><span class="c1"></span><span class="k">val</span> <span class="n">orders</span> <span class="k">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="s">&#34;Orders&#34;</span><span class="o">)</span>
<span class="c1">// compute revenue for all customers from France
</span><span class="c1"></span><span class="k">val</span> <span class="n">revenue</span> <span class="k">=</span> <span class="n">orders</span>
  <span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">$</span><span class="s">&#34;cCountry&#34;</span> <span class="o">===</span> <span class="s">&#34;FRANCE&#34;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="n">$</span><span class="s">&#34;cID&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;cName&#34;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">select</span><span class="o">(</span><span class="n">$</span><span class="s">&#34;cID&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;cName&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;revenue&#34;</span><span class="o">.</span><span class="n">sum</span> <span class="nc">AS</span> <span class="s">&#34;revSum&#34;</span><span class="o">)</span>

<span class="c1">// emit or convert Table
</span><span class="c1"></span><span class="c1">// execute query
</span></code></pre></div><p>注意：Scala Table API 使用以美元符号（<code>$</code>）开头的 Scala 字符串插值来引用 Table 的属性。Table API 使用 Scala implicits。请确保导入</p>
<ul>
<li><code>org.apache.flink.table.api._</code> - 用于隐式表达式转换</li>
<li><code>org.apache.flink.api.scala._</code> 和 <code>org.apache.flink.table.api.bridge.scala._</code>，如果你想从 DataStream 转换到 DataStream。</li>
</ul>
<h2 id="sql">SQL&nbsp;<a class="headline-hash no-text-decoration" href="#sql">#</a> </h2>
<p>Flink 的 SQL 集成是基于 <a href="https://calcite.apache.org/">Apache Calcite</a>，它实现了 SQL 标准。SQL 查询被指定为常规 Strings。</p>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/sql/index.html">SQL</a> 文档描述了 Flink 对流和批处理表的 SQL 支持。</p>
<p>下面的例子展示了如何指定一个查询并将结果以表的形式返回。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get a TableEnvironment
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span> <span class="c1">// see &#34;Create a TableEnvironment&#34; section
</span><span class="c1"></span>
<span class="c1">// register Orders table
</span><span class="c1"></span>
<span class="c1">// compute revenue for all customers from France
</span><span class="c1"></span><span class="k">val</span> <span class="n">revenue</span> <span class="k">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">sqlQuery</span><span class="o">(</span><span class="s">&#34;&#34;&#34;
</span><span class="s">  |SELECT cID, cName, SUM(revenue) AS revSum
</span><span class="s">  |FROM Orders
</span><span class="s">  |WHERE cCountry = &#39;FRANCE&#39;
</span><span class="s">  |GROUP BY cID, cName
</span><span class="s">  &#34;&#34;&#34;</span><span class="o">.</span><span class="n">stripMargin</span><span class="o">)</span>

<span class="c1">// emit or convert Table
</span><span class="c1"></span><span class="c1">// execute query
</span></code></pre></div><p>下面的示例显示了如何指定一个更新查询，将其结果插入到注册表中。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get a TableEnvironment
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span> <span class="c1">// see &#34;Create a TableEnvironment&#34; section
</span><span class="c1"></span>
<span class="c1">// register &#34;Orders&#34; table
</span><span class="c1"></span><span class="c1">// register &#34;RevenueFrance&#34; output table
</span><span class="c1"></span>
<span class="c1">// compute revenue for all customers from France and emit to &#34;RevenueFrance&#34;
</span><span class="c1"></span><span class="n">tableEnv</span><span class="o">.</span><span class="n">executeSql</span><span class="o">(</span><span class="s">&#34;&#34;&#34;
</span><span class="s">  |INSERT INTO RevenueFrance
</span><span class="s">  |SELECT cID, cName, SUM(revenue) AS revSum
</span><span class="s">  |FROM Orders
</span><span class="s">  |WHERE cCountry = &#39;FRANCE&#39;
</span><span class="s">  |GROUP BY cID, cName
</span><span class="s">  &#34;&#34;&#34;</span><span class="o">.</span><span class="n">stripMargin</span><span class="o">)</span>
</code></pre></div><h3 id="混合-table-api-和-sql">混合 Table API 和 SQL&nbsp;<a class="headline-hash no-text-decoration" href="#混合-table-api-和-sql">#</a> </h3>
<p>表 API 和 SQL 查询可以很容易地混合，因为两者都返回 Table 对象。</p>
<ul>
<li>可以在 SQL 查询返回的 Table 对象上定义 Table API 查询。</li>
<li>通过在 TableEnvironment 中<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/common.html#register-a-table">注册生成的 Table</a>并在 SQL 查询的 FROM 子句中引用它，可以在 Table API 查询的结果上定义一个 SQL 查询。</li>
</ul>
<h3 id="发出一个表">发出一个表&nbsp;<a class="headline-hash no-text-decoration" href="#发出一个表">#</a> </h3>
<p>一个 Table 是通过将其写入 TableSink 而发出的。TableSink 是一个通用接口，它支持多种文件格式（如 CSV、Apache Parquet、Apache Avro）、存储系统（如 JDBC、Apache HBase、Apache Cassandra、Elasticsearch）或消息系统（如 Apache Kafka、RabbitMQ）。</p>
<p>批量表只能写入 BatchTableSink，而流式表则需要 AppendStreamTableSink、RetractStreamTableSink 或 UpsertStreamTableSink。</p>
<p>请参阅有关 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/sourceSinks.html">Table Sources &amp; Sink</a> 的文档，以了解可用的 Sink 的详细信息以及如何实现自定义 TableSink 的说明。</p>
<p><code>Table.executeInsert(String tableName)</code> 方法将 Table 排放到一个注册的 TableSink 中。该方法通过名称从目录中查找 TableSink，并验证 Table 的模式与 TableSink 的模式是否相同。</p>
<p>下面的示例展示了如何发射 Table。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get a TableEnvironment
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span> <span class="c1">// see &#34;Create a TableEnvironment&#34; section
</span><span class="c1"></span>
<span class="c1">// create an output Table
</span><span class="c1"></span><span class="k">val</span> <span class="n">schema</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Schema</span><span class="o">(</span><span class="o">)</span>
    <span class="o">.</span><span class="n">field</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="nc">DataTypes</span><span class="o">.</span><span class="nc">INT</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">field</span><span class="o">(</span><span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="nc">DataTypes</span><span class="o">.</span><span class="nc">STRING</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">field</span><span class="o">(</span><span class="s">&#34;c&#34;</span><span class="o">,</span> <span class="nc">DataTypes</span><span class="o">.</span><span class="nc">LONG</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>

<span class="n">tableEnv</span><span class="o">.</span><span class="n">connect</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileSystem</span><span class="o">(</span><span class="s">&#34;/path/to/file&#34;</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">withFormat</span><span class="o">(</span><span class="k">new</span> <span class="nc">Csv</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">fieldDelimiter</span><span class="o">(</span><span class="sc">&#39;|&#39;</span><span class="o">)</span><span class="o">.</span><span class="n">deriveSchema</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">withSchema</span><span class="o">(</span><span class="n">schema</span><span class="o">)</span>
    <span class="o">.</span><span class="n">createTemporaryTable</span><span class="o">(</span><span class="s">&#34;CsvSinkTable&#34;</span><span class="o">)</span>

<span class="c1">// compute a result Table using Table API operators and/or SQL queries
</span><span class="c1"></span><span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="c1">// emit the result Table to the registered TableSink
</span><span class="c1"></span><span class="n">result</span><span class="o">.</span><span class="n">executeInsert</span><span class="o">(</span><span class="s">&#34;CsvSinkTable&#34;</span><span class="o">)</span>
</code></pre></div><h3 id="翻译和执行查询">翻译和执行查询&nbsp;<a class="headline-hash no-text-decoration" href="#翻译和执行查询">#</a> </h3>
<p>两个规划器翻译和执行查询的行为是不同的。</p>
<ul>
<li>Blink 计划器</li>
</ul>
<p>表 API 和 SQL 查询无论其输入是流式还是批处理，都会被翻译成 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/datastream_api.html">DataStream</a> 程序。一个查询在内部表示为一个逻辑查询计划，并分两个阶段进行翻译。</p>
<ol>
<li>逻辑计划的优化。</li>
<li>翻译成 DataStream 程序。</li>
</ol>
<p>Table API 或 SQL 查询被翻译时:</p>
<ul>
<li><code>TableEnvironment.executeSql()</code> 被调用。这个方法用于执行给定的语句，一旦这个方法被调用，sql 查询就会立即被翻译。</li>
<li><code>Table.executeInsert()</code> 被调用。该方法用于将表的内容插入到给定的 sink 路径中，一旦调用该方法，Table API 立即被翻译。</li>
<li>调用 <code>Table.execute()</code>。该方法用于将表内容收集到本地客户端，一旦调用该方法，Table API 立即被翻译。</li>
<li><code>StatementSet.execute()</code> 被调用。一个 Table（通过 <code>StatementSet.addInsert()</code> 向 sink 发出）或一个 INSERT 语句（通过  <code>StatementSet.addInsertSql()</code> 指定）将首先在 StatementSet 中被缓冲。一旦 <code>StatementSet.execute()</code> 被调用，它们就会被翻译。所有接收器将被优化成一个 DAG。</li>
<li>当一个表被转换为 DataStream 时，它就会被翻译（参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/common.html#integration-with-datastream-and-dataset-api">与 DataStream 和 DataSet API 的集成</a>）。一旦翻译完毕，它就是一个常规的 DataStream 程序，并在调用 StreamExecutionEnvironment.execut()时被执行。
注意: 从 1.11 版本开始，<code>sqlUpdate()</code> 方法和 <code>insertInto()</code> 方法已被废弃。如果 Table 程序是由这两个方法构建的，我们必须使用 <code>StreamTableEnvironment.execution()</code> 方法代替 <code>StreamExecutionEnvironment.execution()</code> 方法来执行。</li>
</ul>
<h2 id="与-datastream-和-dataset-api-的集成">与 DataStream 和 DataSet API 的集成&nbsp;<a class="headline-hash no-text-decoration" href="#与-datastream-和-dataset-api-的集成">#</a> </h2>
<p>两种流上的计划器都可以与 DataStream API 集成，只有老的计划器可以与 DataSet API 集成，批处理的 Blink 计划器不能与两者结合。只有旧的计划器可以与 DataSet API 集成，批处理的 Blink 计划器不能与两者结合。注：下面讨论的 DataSet API 只适用于批处理的旧版规划器。</p>
<p>Table API 和 SQL 查询可以很容易地与 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/datastream_api.html">DataStream</a> 和 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch">DataSet</a> 程序集成并嵌入其中。例如，可以查询一个外部表（例如来自 RDBMS），做一些预处理，如过滤、投影、聚合或加入元数据，然后用 DataStream 或 DataSet API（以及建立在这些 API 之上的任何库，如 CEP 或 Gelly）进一步处理数据。反之，也可以在 DataStream 或 DataSet 程序的结果上应用 Table API 或 SQL 查询。</p>
<p>这种交互可以通过将 DataStream 或 DataSet 转换为表来实现，反之亦然。在本节中，我们将描述这些转换是如何完成的。</p>
<h3 id="scala-隐式转换">Scala 隐式转换&nbsp;<a class="headline-hash no-text-decoration" href="#scala-隐式转换">#</a> </h3>
<p>Scala Table API 为 DataSet、DataStream 和 Table 类提供了隐式转换的功能。这些转换是通过导入包 <code>org.apache.flink.table.api.bridge.scala._</code> 来实现的，此外还可以导入 <code>org.apache.flink.api.scala._</code> 来实现 Scala DataStream API。</p>
<h3 id="从-datastream-或-dataset-创建视图">从 DataStream 或 DataSet 创建视图&nbsp;<a class="headline-hash no-text-decoration" href="#从-datastream-或-dataset-创建视图">#</a> </h3>
<p>DataStream 或 DataSet 可以作为视图在 TableEnvironment 中注册。由此产生的视图的模式取决于注册的 DataStream 或 DataSet 的数据类型。请查看有关<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/common.html#mapping-of-data-types-to-table-schema">数据类型到表模式的映射</a>部分以了解详情。</p>
<p>注意：从 DataStream 或 DataSet 创建的视图只能注册为临时视图。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get TableEnvironment 
</span><span class="c1"></span><span class="c1">// registration of a DataSet is equivalent
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span><span class="k">:</span> <span class="kt">StreamTableEnvironment</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span> <span class="c1">// see &#34;Create a TableEnvironment&#34; section
</span><span class="c1"></span>
<span class="k">val</span> <span class="n">stream</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">Long</span>, <span class="kt">String</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="c1">// register the DataStream as View &#34;myTable&#34; with fields &#34;f0&#34;, &#34;f1&#34;
</span><span class="c1"></span><span class="n">tableEnv</span><span class="o">.</span><span class="n">createTemporaryView</span><span class="o">(</span><span class="s">&#34;myTable&#34;</span><span class="o">,</span> <span class="n">stream</span><span class="o">)</span>

<span class="c1">// register the DataStream as View &#34;myTable2&#34; with fields &#34;myLong&#34;, &#34;myString&#34;
</span><span class="c1"></span><span class="n">tableEnv</span><span class="o">.</span><span class="n">createTemporaryView</span><span class="o">(</span><span class="s">&#34;myTable2&#34;</span><span class="o">,</span> <span class="n">stream</span><span class="o">,</span> &#39;myLong<span class="o">,</span> &#39;myString<span class="o">)</span>
</code></pre></div><h3 id="将-datastream-或-dataset-转换为-table">将 DataStream 或 DataSet 转换为 Table&nbsp;<a class="headline-hash no-text-decoration" href="#将-datastream-或-dataset-转换为-table">#</a> </h3>
<p>不需要在 TableEnvironment 中注册一个 DataStream 或 DataSet，也可以直接将其转换为 Table。如果你想在 Table API 查询中使用 Table，这很方便。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get TableEnvironment
</span><span class="c1"></span><span class="c1">// registration of a DataSet is equivalent
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span> <span class="c1">// see &#34;Create a TableEnvironment&#34; section
</span><span class="c1"></span>
<span class="k">val</span> <span class="n">stream</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">Long</span>, <span class="kt">String</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="c1">// convert the DataStream into a Table with default fields &#34;_1&#34;, &#34;_2&#34;
</span><span class="c1"></span><span class="k">val</span> <span class="n">table1</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">)</span>

<span class="c1">// convert the DataStream into a Table with fields &#34;myLong&#34;, &#34;myString&#34;
</span><span class="c1"></span><span class="k">val</span> <span class="n">table2</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;myLong&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;myString&#34;</span><span class="o">)</span>
</code></pre></div><h3 id="将-table-转换为-datastream-或-dataset">将 Table 转换为 DataStream 或 DataSet&nbsp;<a class="headline-hash no-text-decoration" href="#将-table-转换为-datastream-或-dataset">#</a> </h3>
<p>Table 可以被转换为 DataStream 或 DataSet。通过这种方式，可以在表 API 或 SQL 查询的结果上运行自定义 DataStream 或 DataSet 程序。</p>
<p>当将 Table 转换为 DataStream 或 DataSet 时，您需要指定生成的 DataStream 或 DataSet 的数据类型，即表的行要转换为的数据类型。通常，最方便的转换类型是 Row。下面的列表给出了不同选项的功能概述。</p>
<ul>
<li>Row：字段按位置映射，字段数量任意，支持 null 值，无类型安全访问。</li>
<li>POJO：字段按名称映射（POJO 字段必须与表字段一样命名），任意数量的字段，支持 null 值，类型安全访问。</li>
<li>Case Class：字段按位置映射，不支持 null 值，类型安全访问。</li>
<li>Tuple：字段按位置映射，限制为 22 个（Scala）或 25 个（Java）字段，不支持 null 值，类型安全访问。</li>
<li>原子类型：表必须有一个字段，不支持空值，类型安全访问。表必须有一个字段，不支持 null 值，类型安全访问。</li>
</ul>
<h3 id="将-table-转换为-datastream">将 Table 转换为 DataStream&nbsp;<a class="headline-hash no-text-decoration" href="#将-table-转换为-datastream">#</a> </h3>
<p>作为流式查询结果的表将被动态更新，即随着查询输入流中新记录的到达而变化。因此，将这种动态查询转换成的 DataStream 需要对表的更新进行编码。</p>
<p>有两种模式可以将表转换为 DataStream。</p>
<ol>
<li>Append 模式。只有当动态 Table 只被 INSERT 修改时，才可以使用这种模式，即只进行追加，之前发出的结果永远不会更新。</li>
<li>收回模式。这种模式可以一直使用。它将 INSERT 和 DELETE 更改用布尔标志编码。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get TableEnvironment. 
</span><span class="c1"></span><span class="c1">// registration of a DataSet is equivalent
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span><span class="k">:</span> <span class="kt">StreamTableEnvironment</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span> <span class="c1">// see &#34;Create a TableEnvironment&#34; section
</span><span class="c1"></span>
<span class="c1">// Table with two fields (String name, Integer age)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="c1">// convert the Table into an append DataStream of Row
</span><span class="c1"></span><span class="k">val</span> <span class="n">dsRow</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">Row</span><span class="o">]</span> <span class="k">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">toAppendStream</span><span class="o">[</span><span class="kt">Row</span><span class="o">]</span><span class="o">(</span><span class="n">table</span><span class="o">)</span>

<span class="c1">// convert the Table into an append DataStream of Tuple2[String, Int]
</span><span class="c1"></span><span class="k">val</span> <span class="n">dsTuple</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span> <span class="n">dsTuple</span> <span class="k">=</span> 
  <span class="n">tableEnv</span><span class="o">.</span><span class="n">toAppendStream</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span><span class="o">(</span><span class="n">table</span><span class="o">)</span>

<span class="c1">// convert the Table into a retract DataStream of Row.
</span><span class="c1"></span><span class="c1">//   A retract stream of type X is a DataStream[(Boolean, X)]. 
</span><span class="c1"></span><span class="c1">//   The boolean field indicates the type of the change. 
</span><span class="c1"></span><span class="c1">//   True is INSERT, false is DELETE.
</span><span class="c1"></span><span class="k">val</span> <span class="n">retractStream</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">Boolean</span>, <span class="kt">Row</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">toRetractStream</span><span class="o">[</span><span class="kt">Row</span><span class="o">]</span><span class="o">(</span><span class="n">table</span><span class="o">)</span>
</code></pre></div><p>注意：关于动态表及其属性的详细讨论在<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/streaming/dynamic_tables.html">动态表</a>文档中给出。</p>
<p>注意: 一旦表转换为 DataStream，请使用 <code>StreamExecutionEnvironment.execute()</code> 方法来执行 DataStream 程序。</p>
<h3 id="将-table-转换为-dataset">将 Table 转换为 DataSet&nbsp;<a class="headline-hash no-text-decoration" href="#将-table-转换为-dataset">#</a> </h3>
<p>Table 转换为 DataStream 的过程如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get TableEnvironment 
</span><span class="c1"></span><span class="c1">// registration of a DataSet is equivalent
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span> <span class="k">=</span> <span class="nc">BatchTableEnvironment</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">env</span><span class="o">)</span>

<span class="c1">// Table with two fields (String name, Integer age)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="c1">// convert the Table into a DataSet of Row
</span><span class="c1"></span><span class="k">val</span> <span class="n">dsRow</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Row</span><span class="o">]</span> <span class="k">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">toDataSet</span><span class="o">[</span><span class="kt">Row</span><span class="o">]</span><span class="o">(</span><span class="n">table</span><span class="o">)</span>

<span class="c1">// convert the Table into a DataSet of Tuple2[String, Int]
</span><span class="c1"></span><span class="k">val</span> <span class="n">dsTuple</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">toDataSet</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span><span class="o">(</span><span class="n">table</span><span class="o">)</span>
</code></pre></div><p>注意: 一旦 Table 转换为 DataSet，我们必须使用 <code>ExecutionEnvironment.execute</code> 方法来执行 DataSet 程序。</p>
<h3 id="数据类型到-table-schema-的映射">数据类型到 Table Schema 的映射&nbsp;<a class="headline-hash no-text-decoration" href="#数据类型到-table-schema-的映射">#</a> </h3>
<p>Flink 的 DataStream 和 DataSet API 支持非常多样化的类型。复合类型，如 Tuples（内置的 Scala 和 Flink Java tuples）、POJOs、Scala case 类和 Flink 的 Row 类型，允许嵌套具有多个字段的数据结构，这些字段可以在 Table 表达式中访问。其他类型被视为原子类型。在下文中，我们将描述 Table API 如何将这些类型转换为内部行表示，并展示将 DataStream 转换为 Table 的例子。</p>
<p>数据类型到 Table Schema 的映射可以通过两种方式进行：基于字段位置或基于字段名。</p>
<ul>
<li>基于位置的映射</li>
</ul>
<p>基于位置的映射可以用来给字段一个更有意义的名字，同时保持字段顺序。这种映射可用于具有定义字段顺序的复合数据类型以及原子类型。复合数据类型如元组、行和 case 类都有这样的字段顺序。然而，POJO 的字段必须根据字段名进行映射（见下一节）。字段可以被投影出来，但不能使用别名作为重命名。</p>
<p>当定义基于位置的映射时，指定的名称必须不存在于输入数据类型中，否则 API 将假设映射应该基于字段名发生。如果没有指定字段名，则使用复合类型的默认字段名和字段顺序，对于原子类型则使用 f0。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get a TableEnvironment
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span><span class="k">:</span> <span class="kt">StreamTableEnvironment</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span> <span class="c1">// see &#34;Create a TableEnvironment&#34; section
</span><span class="c1"></span>
<span class="k">val</span> <span class="n">stream</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">Long</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="c1">// convert DataStream into Table with default field names &#34;_1&#34; and &#34;_2&#34;
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with field &#34;myLong&#34; only
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;myLong&#34;</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with field names &#34;myLong&#34; and &#34;myInt&#34;
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;myLong&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;myInt&#34;</span><span class="o">)</span>
</code></pre></div><ul>
<li>基于名称的映射</li>
</ul>
<p>基于名称的映射可以用于任何数据类型，包括 POJO。它是定义表模式映射的最灵活的方式。映射中的所有字段都是通过名称引用的，并可能使用别名重命名为。字段可以重新排序和投影出来。</p>
<p>如果没有指定字段名，则使用复合类型的默认字段名和字段顺序，对于原子类型则使用 f0。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get a TableEnvironment
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span><span class="k">:</span> <span class="kt">StreamTableEnvironment</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span> <span class="c1">// see &#34;Create a TableEnvironment&#34; section
</span><span class="c1"></span>
<span class="k">val</span> <span class="n">stream</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">Long</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="c1">// convert DataStream into Table with default field names &#34;_1&#34; and &#34;_2&#34;
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with field &#34;_2&#34; only
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;_2&#34;</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with swapped fields
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;_2&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;_1&#34;</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with swapped fields and field names &#34;myInt&#34; and &#34;myLong&#34;
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;_2&#34;</span> <span class="n">as</span> <span class="s">&#34;myInt&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;_1&#34;</span> <span class="n">as</span> <span class="s">&#34;myLong&#34;</span><span class="o">)</span>
</code></pre></div><h3 id="原子类型">原子类型&nbsp;<a class="headline-hash no-text-decoration" href="#原子类型">#</a> </h3>
<p>Flink 将原语（Integer、Double、String）或通用类型（不能分析和分解的类型）视为原子类型。原子类型的 DataStream 或 DataSet 会被转换为具有单一属性的 Table。属性的类型是从原子类型推断出来的，可以指定属性的名称。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get a TableEnvironment
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span><span class="k">:</span> <span class="kt">StreamTableEnvironment</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span> <span class="c1">// see &#34;Create a TableEnvironment&#34; section
</span><span class="c1"></span>
<span class="k">val</span> <span class="n">stream</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="c1">// convert DataStream into Table with default field name &#34;f0&#34;
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with field name &#34;myLong&#34;
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;myLong&#34;</span><span class="o">)</span>
</code></pre></div><h3 id="tuplesscala-和-java和-case-类仅-scala">Tuples（Scala 和 Java）和 Case 类（仅 Scala）。&nbsp;<a class="headline-hash no-text-decoration" href="#tuplesscala-和-java和-case-类仅-scala">#</a> </h3>
<p>Flink 支持 Scala 的内置元组，并为 Java 提供了自己的元组类。DataStreams 和 DataSets 这两种元组都可以转换为表。通过为所有字段提供名称（基于位置的映射），可以重命名字段。如果没有指定字段名，则使用默认的字段名。如果引用了原始的字段名（对于 Flink Tuples 来说是 f0, f1, &hellip;，对于 Scala Tuples 来说是 _1, _2, &hellip;），API 会假定映射是基于名称而不是基于位置的。基于名称的映射允许重新排序字段和用别名（as）进行投影。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get a TableEnvironment
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span><span class="k">:</span> <span class="kt">StreamTableEnvironment</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span> <span class="c1">// see &#34;Create a TableEnvironment&#34; section
</span><span class="c1"></span>
<span class="k">val</span> <span class="n">stream</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">Long</span>, <span class="kt">String</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="c1">// convert DataStream into Table with renamed default field names &#39;_1, &#39;_2
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with field names &#34;myLong&#34;, &#34;myString&#34; (position-based)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;myLong&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;myString&#34;</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with reordered fields &#34;_2&#34;, &#34;_1&#34; (name-based)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;_2&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;_1&#34;</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with projected field &#34;_2&#34; (name-based)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;_2&#34;</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with reordered and aliased fields &#34;myString&#34;, &#34;myLong&#34; (name-based)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;_2&#34;</span> <span class="n">as</span> <span class="s">&#34;myString&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;_1&#34;</span> <span class="n">as</span> <span class="s">&#34;myLong&#34;</span><span class="o">)</span>

<span class="c1">// define case class
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="k">val</span> <span class="n">streamCC</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="c1">// convert DataStream into Table with default field names &#39;name, &#39;age
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span> <span class="k">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">streamCC</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with field names &#39;myName, &#39;myAge (position-based)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span> <span class="k">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">streamCC</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;myName&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;myAge&#34;</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with reordered and aliased fields &#34;myAge&#34;, &#34;myName&#34; (name-based)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;age&#34;</span> <span class="n">as</span> <span class="s">&#34;myAge&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;name&#34;</span> <span class="n">as</span> <span class="s">&#34;myName&#34;</span><span class="o">)</span>
</code></pre></div><h3 id="pojojava-和-scala">POJO（Java 和 Scala）&nbsp;<a class="headline-hash no-text-decoration" href="#pojojava-和-scala">#</a> </h3>
<p>Flink 支持 POJO 作为复合类型。<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/types_serialization.html#pojos">这里</a>记录了确定 POJO 的规则。</p>
<p>当将 POJO DataStream 或 DataSet 转换为 Table 而不指定字段名时，会使用原始 POJO 字段的名称。名称映射需要原始名称，不能通过位置来完成。字段可以使用别名（使用 as 关键字）重命名，重新排序，并进行投影。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get a TableEnvironment
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span><span class="k">:</span> <span class="kt">StreamTableEnvironment</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span> <span class="c1">// see &#34;Create a TableEnvironment&#34; section
</span><span class="c1"></span>
<span class="c1">// Person is a POJO with field names &#34;name&#34; and &#34;age&#34;
</span><span class="c1"></span><span class="k">val</span> <span class="n">stream</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="c1">// convert DataStream into Table with default field names &#34;age&#34;, &#34;name&#34; (fields are ordered by name!)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with renamed fields &#34;myAge&#34;, &#34;myName&#34; (name-based)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;age&#34;</span> <span class="n">as</span> <span class="s">&#34;myAge&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;name&#34;</span> <span class="n">as</span> <span class="s">&#34;myName&#34;</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with projected field &#34;name&#34; (name-based)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;name&#34;</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with projected and renamed field &#34;myName&#34; (name-based)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;name&#34;</span> <span class="n">as</span> <span class="s">&#34;myName&#34;</span><span class="o">)</span>
</code></pre></div><h3 id="row">Row&nbsp;<a class="headline-hash no-text-decoration" href="#row">#</a> </h3>
<p>Row 数据类型支持任意数量的字段和具有 null 值的字段。字段名可以通过 RowTypeInfo 来指定，也可以在将 Row DataStream 或 DataSet 转换为 Table 时指定。Row 类型支持通过位置和名称对字段进行映射。可以通过为所有字段提供名称（基于位置的映射）或单独选择字段进行投影/排序/重命名（基于名称的映射）来重命名字段。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// get a TableEnvironment
</span><span class="c1"></span><span class="k">val</span> <span class="n">tableEnv</span><span class="k">:</span> <span class="kt">StreamTableEnvironment</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span> <span class="c1">// see &#34;Create a TableEnvironment&#34; section
</span><span class="c1"></span>
<span class="c1">// DataStream of Row with two fields &#34;name&#34; and &#34;age&#34; specified in `RowTypeInfo`
</span><span class="c1"></span><span class="k">val</span> <span class="n">stream</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">Row</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="c1">// convert DataStream into Table with default field names &#34;name&#34;, &#34;age&#34;
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with renamed field names &#34;myName&#34;, &#34;myAge&#34; (position-based)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;myName&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;myAge&#34;</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with renamed fields &#34;myName&#34;, &#34;myAge&#34; (name-based)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;name&#34;</span> <span class="n">as</span> <span class="s">&#34;myName&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;age&#34;</span> <span class="n">as</span> <span class="s">&#34;myAge&#34;</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with projected field &#34;name&#34; (name-based)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;name&#34;</span><span class="o">)</span>

<span class="c1">// convert DataStream into Table with projected and renamed field &#34;myName&#34; (name-based)
</span><span class="c1"></span><span class="k">val</span> <span class="n">table</span><span class="k">:</span> <span class="kt">Table</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="n">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;name&#34;</span> <span class="n">as</span> <span class="s">&#34;myName&#34;</span><span class="o">)</span>
</code></pre></div><h2 id="查询优化">查询优化&nbsp;<a class="headline-hash no-text-decoration" href="#查询优化">#</a> </h2>
<ul>
<li>Blink 计划器</li>
</ul>
<p>Apache Flink 利用并扩展了 Apache Calcite 来执行复杂的查询优化。这包括一系列基于规则和成本的优化，如：</p>
<ul>
<li>基于 Apache Calcite 的子查询装饰相关。</li>
<li>投影修剪</li>
<li>分区修剪</li>
<li>过滤器下推</li>
<li>子计划重复复制，避免重复计算。</li>
<li>特殊子查询重写，包括两部分。
<ul>
<li>将 IN 和 EXISTS 转换为左半连接。</li>
<li>将 NOT IN 和 NOT EXISTS 转换为左反连接。</li>
</ul>
</li>
<li>可选的 join 重新排序
<ul>
<li>通过 <code>table.optimizer.join-reorder-enabled</code> 启用。</li>
</ul>
</li>
</ul>
<p>注：<code>IN/EXISTS/NOT IN/NOT EXISTS</code> 目前只支持子查询重写中的连词条件。</p>
<p>优化器做出智能决策，不仅基于计划，还基于数据源提供的丰富统计数据，以及每个操作符（如 io、cpu、网络和内存）的细粒度成本。</p>
<p>高级用户可以通过 CalciteConfig 对象提供自定义优化，该对象可以通过调用 <code>TableEnvironment#getConfig#setPlannerConfig</code> 提供给 table 环境。</p>
<h2 id="解释表">解释表&nbsp;<a class="headline-hash no-text-decoration" href="#解释表">#</a> </h2>
<p>Table API 提供了一种机制来解释计算 Table 的逻辑和优化查询计划。这是通过 <code>Table.explain()</code> 方法或 <code>StatementSet.explain()</code> 方法完成的。<code>Table.explain()</code> 返回一个 Table 的计划。<code>StatementSet.explain()</code> 返回多个接收器的计划。它返回一个描述三个计划的字符串。</p>
<ol>
<li>关系查询的抽象语法树，即未优化的逻辑查询计划。</li>
<li>优化的逻辑查询计划，以及</li>
<li>物理执行计划。</li>
</ol>
<p><code>TableEnvironment.explainSql()</code> 和 <code>TableEnvironment.executeSql()</code> 支持执行 EXPLAIN 语句来获取计划，请参考 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/sql/explain.html">EXPLAIN</a> 页面。</p>
<p>下面的代码显示了一个使用 <code>Table.explain()</code> 方法给定 Table 的例子和相应的输出。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>
<span class="k">val</span> <span class="n">tEnv</span> <span class="k">=</span> <span class="nc">StreamTableEnvironment</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">env</span><span class="o">)</span>

<span class="k">val</span> <span class="n">table1</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromElements</span><span class="o">(</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&#34;hello&#34;</span><span class="o">)</span><span class="o">)</span><span class="o">.</span><span class="n">toTable</span><span class="o">(</span><span class="n">tEnv</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;count&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;word&#34;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">table2</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromElements</span><span class="o">(</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&#34;hello&#34;</span><span class="o">)</span><span class="o">)</span><span class="o">.</span><span class="n">toTable</span><span class="o">(</span><span class="n">tEnv</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;count&#34;</span><span class="o">,</span> <span class="n">$</span><span class="s">&#34;word&#34;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">table</span> <span class="k">=</span> <span class="n">table1</span>
  <span class="o">.</span><span class="n">where</span><span class="o">(</span><span class="n">$</span><span class="s">&#34;word&#34;</span><span class="o">.</span><span class="n">like</span><span class="o">(</span><span class="s">&#34;F%&#34;</span><span class="o">)</span><span class="o">)</span>
  <span class="o">.</span><span class="n">unionAll</span><span class="o">(</span><span class="n">table2</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">table</span><span class="o">.</span><span class="n">explain</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
</code></pre></div><p>上述例子的结果是:</p>
<pre><code>== Abstract Syntax Tree ==
LogicalUnion(all=[true])
  LogicalFilter(condition=[LIKE($1, _UTF-16LE'F%')])
    FlinkLogicalDataStreamScan(id=[1], fields=[count, word])
  FlinkLogicalDataStreamScan(id=[2], fields=[count, word])

== Optimized Logical Plan ==
DataStreamUnion(all=[true], union all=[count, word])
  DataStreamCalc(select=[count, word], where=[LIKE(word, _UTF-16LE'F%')])
    DataStreamScan(id=[1], fields=[count, word])
  DataStreamScan(id=[2], fields=[count, word])

== Physical Execution Plan ==
Stage 1 : Data Source
	content : collect elements with CollectionInputFormat

Stage 2 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 3 : Operator
		content : from: (count, word)
		ship_strategy : REBALANCE

		Stage 4 : Operator
			content : where: (LIKE(word, _UTF-16LE'F%')), select: (count, word)
			ship_strategy : FORWARD

			Stage 5 : Operator
				content : from: (count, word)
				ship_strategy : REBALANCE
</code></pre><p>下面的代码显示了使用 <code>StatementSet.explain()</code> 方法进行多重接收器计划的一个例子和相应的输出。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">settings</span> <span class="k">=</span> <span class="nc">EnvironmentSettings</span><span class="o">.</span><span class="n">newInstance</span><span class="o">.</span><span class="n">useBlinkPlanner</span><span class="o">.</span><span class="n">inStreamingMode</span><span class="o">.</span><span class="n">build</span>
<span class="k">val</span> <span class="n">tEnv</span> <span class="k">=</span> <span class="nc">TableEnvironment</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">settings</span><span class="o">)</span>

<span class="k">val</span> <span class="n">schema</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Schema</span><span class="o">(</span><span class="o">)</span>
    <span class="o">.</span><span class="n">field</span><span class="o">(</span><span class="s">&#34;count&#34;</span><span class="o">,</span> <span class="nc">DataTypes</span><span class="o">.</span><span class="nc">INT</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">field</span><span class="o">(</span><span class="s">&#34;word&#34;</span><span class="o">,</span> <span class="nc">DataTypes</span><span class="o">.</span><span class="nc">STRING</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>

<span class="n">tEnv</span><span class="o">.</span><span class="n">connect</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileSystem</span><span class="o">(</span><span class="s">&#34;/source/path1&#34;</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">withFormat</span><span class="o">(</span><span class="k">new</span> <span class="nc">Csv</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">deriveSchema</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">withSchema</span><span class="o">(</span><span class="n">schema</span><span class="o">)</span>
    <span class="o">.</span><span class="n">createTemporaryTable</span><span class="o">(</span><span class="s">&#34;MySource1&#34;</span><span class="o">)</span>
<span class="n">tEnv</span><span class="o">.</span><span class="n">connect</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileSystem</span><span class="o">(</span><span class="s">&#34;/source/path2&#34;</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">withFormat</span><span class="o">(</span><span class="k">new</span> <span class="nc">Csv</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">deriveSchema</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">withSchema</span><span class="o">(</span><span class="n">schema</span><span class="o">)</span>
    <span class="o">.</span><span class="n">createTemporaryTable</span><span class="o">(</span><span class="s">&#34;MySource2&#34;</span><span class="o">)</span>
<span class="n">tEnv</span><span class="o">.</span><span class="n">connect</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileSystem</span><span class="o">(</span><span class="s">&#34;/sink/path1&#34;</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">withFormat</span><span class="o">(</span><span class="k">new</span> <span class="nc">Csv</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">deriveSchema</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">withSchema</span><span class="o">(</span><span class="n">schema</span><span class="o">)</span>
    <span class="o">.</span><span class="n">createTemporaryTable</span><span class="o">(</span><span class="s">&#34;MySink1&#34;</span><span class="o">)</span>
<span class="n">tEnv</span><span class="o">.</span><span class="n">connect</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileSystem</span><span class="o">(</span><span class="s">&#34;/sink/path2&#34;</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">withFormat</span><span class="o">(</span><span class="k">new</span> <span class="nc">Csv</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">deriveSchema</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">withSchema</span><span class="o">(</span><span class="n">schema</span><span class="o">)</span>
    <span class="o">.</span><span class="n">createTemporaryTable</span><span class="o">(</span><span class="s">&#34;MySink2&#34;</span><span class="o">)</span>
    
<span class="k">val</span> <span class="n">stmtSet</span> <span class="k">=</span> <span class="n">tEnv</span><span class="o">.</span><span class="n">createStatementSet</span><span class="o">(</span><span class="o">)</span>

<span class="k">val</span> <span class="n">table1</span> <span class="k">=</span> <span class="n">tEnv</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="s">&#34;MySource1&#34;</span><span class="o">)</span><span class="o">.</span><span class="n">where</span><span class="o">(</span><span class="n">$</span><span class="s">&#34;word&#34;</span><span class="o">.</span><span class="n">like</span><span class="o">(</span><span class="s">&#34;F%&#34;</span><span class="o">)</span><span class="o">)</span>
<span class="n">stmtSet</span><span class="o">.</span><span class="n">addInsert</span><span class="o">(</span><span class="s">&#34;MySink1&#34;</span><span class="o">,</span> <span class="n">table1</span><span class="o">)</span>

<span class="k">val</span> <span class="n">table2</span> <span class="k">=</span> <span class="n">table1</span><span class="o">.</span><span class="n">unionAll</span><span class="o">(</span><span class="n">tEnv</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="s">&#34;MySource2&#34;</span><span class="o">)</span><span class="o">)</span>
<span class="n">stmtSet</span><span class="o">.</span><span class="n">addInsert</span><span class="o">(</span><span class="s">&#34;MySink2&#34;</span><span class="o">,</span> <span class="n">table2</span><span class="o">)</span>

<span class="k">val</span> <span class="n">explanation</span> <span class="k">=</span> <span class="n">stmtSet</span><span class="o">.</span><span class="n">explain</span><span class="o">(</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">explanation</span><span class="o">)</span>
</code></pre></div><p>多重接收器计划的结果是:</p>
<pre><code>== Abstract Syntax Tree ==
LogicalLegacySink(name=[MySink1], fields=[count, word])
+- LogicalFilter(condition=[LIKE($1, _UTF-16LE'F%')])
   +- LogicalTableScan(table=[[default_catalog, default_database, MySource1, source: [CsvTableSource(read fields: count, word)]]])

LogicalLegacySink(name=[MySink2], fields=[count, word])
+- LogicalUnion(all=[true])
   :- LogicalFilter(condition=[LIKE($1, _UTF-16LE'F%')])
   :  +- LogicalTableScan(table=[[default_catalog, default_database, MySource1, source: [CsvTableSource(read fields: count, word)]]])
   +- LogicalTableScan(table=[[default_catalog, default_database, MySource2, source: [CsvTableSource(read fields: count, word)]]])

== Optimized Logical Plan ==
Calc(select=[count, word], where=[LIKE(word, _UTF-16LE'F%')], reuse_id=[1])
+- TableSourceScan(table=[[default_catalog, default_database, MySource1, source: [CsvTableSource(read fields: count, word)]]], fields=[count, word])

LegacySink(name=[MySink1], fields=[count, word])
+- Reused(reference_id=[1])

LegacySink(name=[MySink2], fields=[count, word])
+- Union(all=[true], union=[count, word])
   :- Reused(reference_id=[1])
   +- TableSourceScan(table=[[default_catalog, default_database, MySource2, source: [CsvTableSource(read fields: count, word)]]], fields=[count, word])

== Physical Execution Plan ==
Stage 1 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 2 : Operator
		content : CsvTableSource(read fields: count, word)
		ship_strategy : REBALANCE

		Stage 3 : Operator
			content : SourceConversion(table:Buffer(default_catalog, default_database, MySource1, source: [CsvTableSource(read fields: count, word)]), fields:(count, word))
			ship_strategy : FORWARD

			Stage 4 : Operator
				content : Calc(where: (word LIKE _UTF-16LE'F%'), select: (count, word))
				ship_strategy : FORWARD

				Stage 5 : Operator
					content : SinkConversionToRow
					ship_strategy : FORWARD

					Stage 6 : Operator
						content : Map
						ship_strategy : FORWARD

Stage 8 : Data Source
	content : collect elements with CollectionInputFormat

	Stage 9 : Operator
		content : CsvTableSource(read fields: count, word)
		ship_strategy : REBALANCE

		Stage 10 : Operator
			content : SourceConversion(table:Buffer(default_catalog, default_database, MySource2, source: [CsvTableSource(read fields: count, word)]), fields:(count, word))
			ship_strategy : FORWARD

			Stage 12 : Operator
				content : SinkConversionToRow
				ship_strategy : FORWARD

				Stage 13 : Operator
					content : Map
					ship_strategy : FORWARD

					Stage 7 : Data Sink
						content : Sink: CsvTableSink(count, word)
						ship_strategy : FORWARD

						Stage 14 : Data Sink
							content : Sink: CsvTableSink(count, word)
							ship_strategy : FORWARD
</code></pre><p>原文链接: <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/common.html">https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/common.html</a></p>


        </div>
    </div>
</article>



                <footer>
                    




<div class="no-text-decoration">
    <div class="jump top"><a href="#" title="Top of this page">⮉</a></div>
    <div class="jump bottom"><a href="#bottom" title="Bottom of this page">⮋</a></div>
</div>


 
    
        <div class="hugotoc no-text-decoration">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#概念和通用-api">概念和通用 API</a></li>
    <li><a href="#两种-planners-的主要区别">两种 Planners 的主要区别</a></li>
    <li><a href="#table-api-和-sql-程序的结构">Table API 和 SQL 程序的结构</a></li>
    <li><a href="#创建一个-tableenvironment">创建一个 TableEnvironment</a></li>
    <li><a href="#在目录catalog中创建表">在目录(Catalog)中创建表</a>
      <ul>
        <li><a href="#临时表与永久表">临时表与永久表</a></li>
        <li><a href="#shadowing">Shadowing</a></li>
      </ul>
    </li>
    <li><a href="#创建一个-table">创建一个 Table</a>
      <ul>
        <li><a href="#虚拟表">虚拟表</a></li>
        <li><a href="#连接器表">连接器表</a></li>
        <li><a href="#扩展-table-标识符">扩展 Table 标识符</a></li>
      </ul>
    </li>
    <li><a href="#查询一个-table">查询一个 Table</a>
      <ul>
        <li><a href="#table-api">Table API</a></li>
      </ul>
    </li>
    <li><a href="#sql">SQL</a>
      <ul>
        <li><a href="#混合-table-api-和-sql">混合 Table API 和 SQL</a></li>
        <li><a href="#发出一个表">发出一个表</a></li>
        <li><a href="#翻译和执行查询">翻译和执行查询</a></li>
      </ul>
    </li>
    <li><a href="#与-datastream-和-dataset-api-的集成">与 DataStream 和 DataSet API 的集成</a>
      <ul>
        <li><a href="#scala-隐式转换">Scala 隐式转换</a></li>
        <li><a href="#从-datastream-或-dataset-创建视图">从 DataStream 或 DataSet 创建视图</a></li>
        <li><a href="#将-datastream-或-dataset-转换为-table">将 DataStream 或 DataSet 转换为 Table</a></li>
        <li><a href="#将-table-转换为-datastream-或-dataset">将 Table 转换为 DataStream 或 DataSet</a></li>
        <li><a href="#将-table-转换为-datastream">将 Table 转换为 DataStream</a></li>
        <li><a href="#将-table-转换为-dataset">将 Table 转换为 DataSet</a></li>
        <li><a href="#数据类型到-table-schema-的映射">数据类型到 Table Schema 的映射</a></li>
        <li><a href="#原子类型">原子类型</a></li>
        <li><a href="#tuplesscala-和-java和-case-类仅-scala">Tuples（Scala 和 Java）和 Case 类（仅 Scala）。</a></li>
        <li><a href="#pojojava-和-scala">POJO（Java 和 Scala）</a></li>
        <li><a href="#row">Row</a></li>
      </ul>
    </li>
    <li><a href="#查询优化">查询优化</a></li>
    <li><a href="#解释表">解释表</a></li>
  </ul>
</nav>
            <a href="#" class="back-to-top">Back to top</a>
        </div>
    
    
<script src="/js/libs/jquery/3.3.1/jquery.slim.min.min.528a9ce56371729e50605653bf72b1e933574cdb97519529bf8fab01b63f9703.js"></script>

<link rel="preload" href="/js/libs/jquery/3.3.1/jquery.slim.min.min.528a9ce56371729e50605653bf72b1e933574cdb97519529bf8fab01b63f9703.js" as="script">

<script type="application/javascript">(function() {
     var $window = $(window);
     if ($window.width() >= 1400) { 
         var $toc = $('#TableOfContents');
         if ($toc.length > 0) {
             function onScroll(){
                 var currentScroll = $window.scrollTop();
                 var h = $('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .h-feed h2');
                 var id = "";
                 h.each(function (i, e) {
                     e = $(e);
                     if (e.offset().top - 10 <= currentScroll) {
                         id = e.attr('id');
                     }
                 });
                 var current = $toc.find('a.current');
                 if (current.length == 1 && current.eq(0).attr('href') == '#' + id) return true;

                 current.each(function (i, e) {
                     $(e).removeClass('current').siblings('ul').hide();
                 });
                 $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                     $(e).children('a').addClass('current').siblings('ul').show();
                 });
             }
             $window.on('scroll', onScroll);
             $(document).ready(function() {
                 $toc.find('a').parent('li').find('ul').hide();
                 onScroll();
                 document.getElementsByClassName('hugotoc')[0].style.display = '';
             });}}})();</script>








<div class="backtotop center no-text-decoration">
    <a href="#">back to <span class="top">top</span></a>
</div>


<div class="right">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 54 posts categorized in ‘Flink’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/categories/flink/">Flink</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 73 posts tagged with ‘Flink’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/flink/">Flink</a>
                            </li>
                        
                    
                        
                        
                        
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__table-api-sql__"
                                
                                
                                title="See all 25 posts tagged with ‘Table API &amp; SQL’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/table-api-sql/">Table API &amp; SQL</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>
<div class="clear-float"></div>



<div class="prev-next-navigator clear-float">
    
        <span class="prev-post left no-text-decoration">
            <a href="https://ohmyweekly.github.io/notes/2020-08-22-detecting-patterns-in-tables/" class="nobr">« 检测表中的模式</a>
        </span>
    
    
        <span class="next-post right no-text-decoration">
            <a href="https://ohmyweekly.github.io/notes/2020-08-22-streaming-concepts/" class="nobr">流的概念 »</a>
        </span>
    
</div>


<a id="bottom"></a>









                       







                    <ul class="no-bullets feed right inline">
    
        
        
    
</ul>
<div class="clear-float"></div>

                </footer>
                <hr />
            </div>               

            <footer> 
                

<ul class="social no-text-decoration">
    
</ul>













<p class="generated no-text-decoration">
    Generated using  <a href="https://gitlab.com/kaushalmodi/hugo-theme-refined"><code class="nobr">hugo-theme-refined</code></a> + <span class="nobr">Hugo 0.63.2</span>
</p>

<p>
    
</p>




<div class="badges no-text-decoration">
    
    

    
</div>




<script type="application/javascript">var nav=responsiveNav("#nav");</script>




<script defer src="/js/libs/fragmentions/wrapper.min.4c511209cd3786314b251d891c8da528b47a972669aa4eea416b64d4be01eee2.js"></script>









            </footer>
        </div> 
    </body>
</html>
