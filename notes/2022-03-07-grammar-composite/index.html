<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
    
    
    

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    
    <meta name="referrer" content="no-referrer">

    <title>
        
            Grammar Composite ❚ 焉知非鱼
        
    </title>

    
    


    
    
    
    

    
    
    
    

    
    
    

    
    
    
    <style>
     
     
     :root {
         --theme-color: #ac4142;
         --theme-color-light: rgba(172, 65, 66, 0.2);
     }
     
     html {
         line-height: 1.5;
     }
    </style>

    
    

    
    
    
    
    <link rel="stylesheet" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css">
    
    <link rel="preload" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css" as="style">

    



    
        <style>
         
         /* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }

         
         /* Overrides on top of the theme and Chroma CSS */
/* Chroma-based lines highlighting in code blocks */
.chroma .hl {
    background-color: #e8e8e8;
    /* Extend highlight up to 100 characters (assuming that the code blocks never have more than 100 characters in a line) */
    min-width: 100ch;
}
/* GenericHeading */ .chroma .gh { color: #999999; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa; font-weight: bold }

         
        </style>
    

    

    
    
    

    
    <script src="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js"></script>
    
    <link rel="preload" href="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js" as="script">

    
    
    <script defer src="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js"></script>
    
    <link rel="preload" href="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js" as="script">

    

    

    
    
    

    
    
<!-- rel="me" links for IndieAuth -->







    
 
<meta property="og:title" content="Grammar Composite" />
<meta property="og:description"
      content="Grammar Composite" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ohmycloud.github.io/notes/2022-03-07-grammar-composite/" />


    
        <meta property="article:published_time" content="2022-03-07T00:00:00&#43;00:00"/>
    
    
        <meta property="article:modified_time" content="2022-03-07T00:00:00&#43;00:00"/>
    









    




     <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Grammar Composite"/>
<meta name="twitter:description" content="Grammar Composite"/>


    
    
    <link rel="alternate" type="application/jf2post+json" href="https://ohmycloud.github.io/notes/2022-03-07-grammar-composite/jf2post.json" title="Jf2post for 焉知非鱼" />
    
     



    
    
    
        
    


     
        
        <meta name="DC.Creator" content="焉知非鱼"/>
    



    
    
    
    <meta name="hugo-build-date" content="2024-03-01T16:16:06Z"/>
    <meta name="hugo-commit-hash" content="312735366b20d64bd61bff8627f593749f86c964"/>
    <meta name="generator" content="Hugo 0.123.7">
</head>


    
        <body lang="en">
    

        
        <div class="border" id="home"></div>

        <div class="wrapper">   
            
<nav id="nav" class="nav-collapse opened" aria-hidden="false">
    <ul class="navbar">
        <li><a class="" href="/">Home</a></li>
        
            
                <li><a class="" href="https://ohmycloud.github.io/posts/">Posts</a></li>
            
        
            
                <li><a class="" href="https://ohmycloud.github.io/notes/">Notes</a></li>
            
        
        
            <li><a class="" href="https://ohmycloud.github.io/search/">Search</a></li>
        
    </ul>
</nav>

            <div class="container">
                <header class="masthead">
                    <div class="masthead-title no-text-decoration">
                        <a href="/">焉知非鱼</a> <span class="blinking-cursor">❚</span>
                    </div>
                    <div class="masthead-tagline">
                        Wait the light to fall
                    </div>
                </header>

                








<article class="post h-entry notes">
    <header>
        <div class="center">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__grammar__"
                                
                                
                                title="See all 0 posts tagged with ‘grammar’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/grammar/">grammar</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>

        <h1 class="post-title p-name">Grammar Composite</h1>

        
        <data class="u-url" value="https://ohmycloud.github.io/notes/2022-03-07-grammar-composite/"></data>

        <div class="date-syndication">
            


    
    
    <div class="post-date">
        
        <time datetime="2022-03-07T00:00:00+0000" class="dt-published">Mon Mar 7, 2022</time>
        
        
    </div>


            




        </div>
         



    
    
    
        
    


    
        
        <span class="hide">
            &mdash; <a href="https://ohmycloud.github.io/" class="u-author">焉知非鱼</a>
        </span>
    


    </header>

    <div class="content">
        
    <div class="description p-summary">
        
        
        
        
        
            
            
        
        <p>Grammar Composite</p>
    </div>



        





                       


        <div class="e-content">
            




<h1 id="深入研究-raku-的-regexes-并带回了一个更好的-grammar-协作方式">深入研究 Raku 的 regexes ，并带回了一个更好的 grammar 协作方式</h1>
<p>在我<a href="https://www.codesections.com/blog/grammatical-actions/">上一篇关于在 Raku 中协调多个 grammar 的文章</a>得到一些<a href="https://www.reddit.com/r/rakulang/comments/stpvft/grammatical_actions_further_thoughts_on/">很好的反馈</a>后，我意识到我在 Raku(do) 中对 regexes 心智模式的理解基本上是错误的。这个有缺陷的模式并没有阻止我使用 regexes，但它是错误的 - 它使我无法正确地掌握 grammar 中涉及的一些更复杂的行为。现在我已经纠正了这个误解，一切都变得更有意义了！</p>
<blockquote>
<p>注意：这不是关于实现一个 regexes 引擎的问题（也是非常重要的！）；对有限状态机、NFA 和 DFA 以及所有这些有趣的主题的关注都不在我们的范围之内。当我在这篇文章中提到 Raku 的 regex “实现”时，我指的不是运行 regex 的底层低级实现；相反，我说的是 Raku 如何处理用户提供的 Regexes 的语法和语义，“然后它执行 regex”是一个小步骤。</p>
</blockquote>
<p>在这篇文章中，我会先简要介绍我的错误观点（希望有足够的轮廓，使你能理解我的出发点，但不会陷入和我一样的困惑中），然后再介绍正确的（或至少错误较少）心智模式。对这个模式的探索将使我们对 Raku 的 regexes 工作原理有更深的理解（或者，至少比我一周前的理解更深刻；正如他们所说，YMMV）。接下来，我会解释这种新的理解是如何让我构建一个 trait 的 - 我相信这将使组合多个 grammar 变得更加容易。最后，我会快速带你浏览一下实现该 trait 所涉及到的大约 100 行代码。</p>
<p>让我们一起学习 Raku 吧 <strong>»ö«</strong></p>
<h2 id="为-raku-regexes-建立正确的心智模式">为 Raku regexes 建立正确的心智模式&nbsp;<a class="headline-hash no-text-decoration" href="#为-raku-regexes-建立正确的心智模式">#</a> </h2>
<p>也许我们已经有多年的 Raku regexes 使用经验, 却不了解它们是如何工作的。它们拥有很棒的抽象，像所有好的抽象一样，它们的大部分力量来自于你不需要了解其具体实现。尽管如此，我总是发现，当遇到困难的时候，拥有一个好的抽象下的细节的一般模式是非常有帮助的，我认为 Raku 的 regexes 是这个原则的一个很好的例子。</p>
<blockquote>
<p>从我们讨论实现细节的事实中可以明显看出，这篇文章的大部分内容将集中在 Raku<strong>do</strong> 上 - Raku 作为一个整体是由 <a href="https://github.com/Raku/roast">Roast</a> 定义的，它不致力于具体的实现。也就是说，我们要讨论的大部分 regexes/grammar 行为都是特定的，其余大部分都与 <a href="https://github.com/Raku/nqp/">NQP</a> 有很深的关系。所以我非常确定，这篇文章中的几乎所有内容都将适用于任何未来的 Raku 实现，而不仅仅是 Rakudo。</p>
</blockquote>
<h2 id="regexisamethod好吧这是什么意思">Regex.isa(Method)。好吧，这是什么意思？&nbsp;<a class="headline-hash no-text-decoration" href="#regexisamethod好吧这是什么意思">#</a> </h2>
<p>我很早就知道 <code>Regex</code> 是 <code>Method</code> 了；在这一点上文档也讲得非常清楚，而且我在多个帖子中都提到了这一点。(首先，<a href="https://docs.raku.org/type/Regex">Regex 类型文档</a>中的第一行就是 <code>Class Regex is Method { }</code>！）。但是，即使我已经知道，我也没有深入研究过 - 更不用说深刻理解它的含义了。</p>
<p>具体说来：regex 是方法这一事实在实践中意味着什么？我们可以把 regex 作为子例程来调用吗？如果可以，如何调用？而且，如果它是方法，但是是什么对象上的方法？它的签名是什么？它返回什么？像大多数 rakoons 一样，我总是通过像 <code>'foo' ~~ /&lt;word&gt;/</code> 这样的语法与 regexes 交互，而不是把 regex 当作一个 <code>Routine</code>。而且，为了清楚起见，这绝对是我们在几乎任何时候都应该使用的方式 - 但是，为了更深入地理解 regex 作为例程的结果，让我们研究一下如何以更加 <code>Routine</code> 方式与 regex 互动。</p>
<h2 id="一个糟糕的和错误的心智模式">一个糟糕的和错误的心智模式&nbsp;<a class="headline-hash no-text-decoration" href="#一个糟糕的和错误的心智模式">#</a> </h2>
<p>在没有深思熟虑的情况下，我把 regexes 想象成一个经典的类，这或多或少有点面向对象编程的意义。也就是说，我把 <code>Regex</code> 想象成一个为任何特定搜索创建新对象的类，每个对象根据它所搜索的文本存储和更新内部状态。</p>
<p>为了使这个模式更加具体，我想象 <code>my Regex Rx { foo \s bar}</code> 这一行创造了一些大致如下的伪代码（不过，很遗憾，我没有完全思考过的心智模式没有附带代码样本，所以我几乎没有考虑到这么多细节）。<strong>请注意，下面的写法是完全错误的:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Broken, do not try</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">class</span> <span class="nc">Rx</span> <span class="k">is</span> <span class="kt">Regex</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$rx-body</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1"> foo \s bar </span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">has</span>     <span class="nv">@!input-chars</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Int</span> <span class="nv">$!pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">CALL-ME</span><span class="p">(</span><span class="n">Rx:U:</span> <span class="kt">Str</span><span class="p">()</span> <span class="nv">$input</span>  <span class="o">-</span> <span class="o">&gt;</span> <span class="kt">Match</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">my</span> <span class="nv">$rx</span> <span class="o">=</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="o">:</span> <span class="p">:</span><span class="s">input-chars</span><span class="p">(</span><span class="nv">$input</span><span class="o">.</span><span class="nb">comb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="nv">$rx</span><span class="o">!</span><span class="nb">match</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">!match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="mi">0</span> <span class="o">≤</span> <span class="nv">$!pos</span> <span class="o">≤</span> <span class="nv">@!input-chars</span><span class="o">.</span><span class="nf">elem</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">my</span> <span class="nv">$c</span> <span class="o">:=</span> <span class="nv">@!input-chars</span><span class="o">[</span><span class="nv">$pos</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nf">MATCHER</span><span class="p">(</span><span class="nv">$c</span><span class="o">,</span> <span class="nv">$rx-body</span><span class="p">)</span> <span class="o">===</span> <span class="n">PartMatch</span> <span class="p">{</span> <span class="nv">$pos</span><span class="o">++</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">#  ^^^ somehow handles backtracking?</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nf">MATCHER</span><span class="p">(</span><span class="nv">$c</span><span class="o">,</span> <span class="nv">$rx-body</span><span class="p">)</span> <span class="o">===</span> <span class="n">FullMatch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="kt">Match</span><span class="p">(</span><span class="n">FullMatch</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="p">{</span> <span class="nv">$pos</span> <span class="o">-</span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">return</span> <span class="kt">Match</span><span class="p">(&#39;</span><span class="s1">#&lt;failed match&gt;</span><span class="p">&#39;)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Hypothetical useage:</span>
</span></span><span class="line"><span class="cl"><span class="nf">Rx</span><span class="p">(&#39;</span><span class="s1">foo bar</span><span class="p">&#39;);</span>
</span></span></code></pre></div><p>把这种基于 OOP 的心智模式扩展到 grammar 上感觉非常简单。<code>Grammar</code> 只需要存储多个 <code>%rx-bodies</code>，并能够在它们和该 <code>Grammar</code> 声明中描述的 token/rule 名称之间进行转换（哦，我猜还有一点设置和调用 action 对象的逻辑）。</p>
<p>正如我们会看到的那样，这个模式被证明是完全错误的。但是，我希望你能从上面的轮廓中看到，它错得合情合理。而且，事实上，它貌似是合理的，以至于我能在相当长的一段时间内使用 regexes 和 grammar 而没有意识到它错得有多离谱。</p>
<h2 id="摇摇欲坠的地基">摇摇欲坠的地基&nbsp;<a class="headline-hash no-text-decoration" href="#摇摇欲坠的地基">#</a> </h2>
<p>这个有缺陷的心智模式，无论多么合理，都经不起我上一篇文章后面的讨论。特别是，它经不起我从 Matthew Stuckwisch（<a href="https://raku.org/community/irc">#raku IRC 频道</a>上的 guifa，r/rakulang 和 GitHub 上的 alatennaub；我在这里用 &ldquo;guifa&rdquo;）那里学到的东西。</p>
<p>Guifa 的评论与<a href="http://clarkema.org/lab/2022/2022-02-09-raku-multiple-grammars/">引发整个讨论的帖子</a>有关。在那篇文章中，Mike Clark 介绍了一种 grammar，它可以解析一种主语言，然后使用第二种 gramamr 来解析嵌套在主语言中的类似 lisp 的语言。</p>
<p>下面的代码显示的是删除了 Mike 的注释后的简化版本；如果你想了解更多细节，请看<a href="http://clarkema.org/lab/2022/2022-02-09-raku-multiple-grammars/">原帖</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">InnerLang</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">+</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">[&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">~</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="ni">.</span><span class="o">*</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">MainLang</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">TOP</span>       <span class="p">{</span><span class="sr"> </span><span class="p">[&lt;</span><span class="o">.</span><span class="nf">text-like</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">lisp-like</span><span class="p">&gt;</span><span class="o">*</span><span class="p">]</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">text-like</span> <span class="p">{</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">alpha</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">lisp-like</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$inner</span><span class="p">;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">&lt;</span><span class="o">?</span><span class="p">{</span> <span class="nv">$inner</span>
</span></span><span class="line"><span class="cl">              <span class="o">=</span> <span class="n">InnerLang</span><span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">orig</span><span class="o">,</span> <span class="p">:</span><span class="s">pos</span><span class="p">(</span><span class="nv">$/</span><span class="o">.</span><span class="nb">to</span><span class="p">)</span> <span class="p">}&gt;</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="ni">.</span><span class="o">**</span><span class="p">{</span><span class="nv">$inner</span><span class="o">.</span><span class="nb">to</span> <span class="o">-</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">pos</span><span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    </span><span class="c1">#   ^^^^^^^^^^^^^^^^^^^^^^^ I really dislike this part
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">    </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>正如我在上面的评论中指出的，我真的不喜欢需要在我们的外部 grammar 中这样管理状态的想法 - 在简单的情况下还不算太糟，但随着 grammar 越来越大，它会变得越来越容易出错和棘手。而且，即使做得正确，我仍然会有与并发有关的担忧 - 让代码的两个部分对我们已经解析了多少输入有不同的视图，似乎会招致那种调试起来是噩梦的错误。(也许这是偏执狂，但我以前被坑过）。</p>
<p>但是 <a href="https://www.reddit.com/r/rakulang/comments/stpvft/comment/hx5f750/?utm_source=share&amp;utm_medium=web2x&amp;context=3">guifa 的回答</a>指出了上述代码的一些问题，这确实让我感到惊讶，一旦我想清楚了其中的含义，就立刻推翻了我上面描述的心智模式。Guifa 的评论说得并不完全和这一样，但主要的启示是，我们可以把上面的 <code>lisp-like</code> 的 rule 重写成:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">method</span> <span class="nf">lisp-like</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">InnerLang</span><span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="nv">$.orig</span><span class="o">,</span> <span class="p">:</span><span class="s">pos</span><span class="p">(</span><span class="nv">$.to</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>也就是说，如果我们把 <code>rule lisp-like</code> 改为 <code>method lisp-like</code>，把我们的 <code>$/.</code> 调用改为 <code>$.</code>，那么就可以把我们的代码减少一半，并去掉前一个版本中困扰我的所有记帐。当我意识到这一点时，我立即了有两种反应：“这真是太棒了！”和“等等，但是怎么做呢？”</p>
<p>如果你没有同样的“但是怎么做？”的反应，这里有一些让我很疑惑的问题：</p>
<ul>
<li>如果我们在 <code>MainLang</code> 中更新当前的匹配位置，为什么方法会<a href="http://www.catb.org/jargon/html/A/automagically.html">自动地</a>设置该状态？Raku 通常很好地避免了这种魔法，所以在这里看到它很奇怪。</li>
<li>为什么 rule/token 不会以同样的方式更新状态？<em>rule</em> 是一个方法 - 具体地说，是<a href="https://stackoverflow.com/a/56799018">定义它的</a> <code>Grammar</code> 的<a href="https://stackoverflow.com/a/56799018">一个方法</a>，所以任何适用于 <code>Method</code> 的魔法行为都应该包括 <em>rule</em> 和 <em>token</em>。</li>
<li>即使抛开任何魔法行为，为什么我似乎不能从 rule 的主体中手动更新 <code>MainLang</code> 的状态？我可以用 <code>$.pos</code> 查看当前的位置，而且这个方法似乎也在修改这个状态，但是从 rule 内部看来，它确实是私有的 - 这怎么可能呢？</li>
</ul>
<p>在对着这些问题一通操作之后，我意识到答案就在第一句话里。&ldquo;如果我们更新 <code>MainLang</code> 中的当前匹配位置&hellip;&hellip;&rdquo;  - 好吧，事实证明，我们根本没有更新任何 <code>MainLang</code> 的状态；事实上，从我们的角度来看，<code>MainLang</code> 几乎是无状态的。</p>
<h2 id="范式的转变">范式的转变&nbsp;<a class="headline-hash no-text-decoration" href="#范式的转变">#</a> </h2>
<p>我们没有更新 <code>MainLang</code> 中的位置状态，因为 - 与我的假设相反，尽管有 <code>$.pos</code> 方法的存在 -  <code>MainLang</code> 并没有存储任何（可变的）状态。而这又是因为我上面提出的基于 OOP 的带状态的心智模式是错误的。不仅仅是 grammar，它对 regexes 也是错误的。</p>
<p>关于这方面的第一个线索是，实际上不能用我上面想象的 <code>Rx('some text')</code> 调用语法来调用 <em>regex</em>、<em>token</em> 或 <em>rule</em>。如果我们尝试了，我们会得到以下错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">regex</span> <span class="nf">Rx</span> <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">Rx</span><span class="p">(&#39;</span><span class="s1">some text</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># OUTPUT: «No such method &#39;!cursor_start&#39; for invocant of type &#39;Str&#39;»</span>
</span></span></code></pre></div><p>这条错误信息并不直观；如果 Raku 能达到其通常的令人惊叹的错误信息的标准，它应该得到这样的错误:</p>
<pre><code>Type check failed in binding to parameter 'topic'; expected Match but got Str (&quot;foo&quot;)
</code></pre>
<blockquote>
<p>我相信有 Junction/autothreading 的原因，regexes 需要有一个 <code>Mu</code> 类型约束。但如果能有一个更清晰的错误就更好了。</p>
</blockquote>
<p>好的，所以 <code>Rx('text')</code> 不起作用，因为它不做类型检查；我们需要提供一个 <code>Match</code> 而不是文本。但为什么呢？如果我已经有匹配了，为什么还要把这个匹配传给 regex 呢？难道 regexes 不是搜索字符串并返回匹配吗？</p>
<p>不，事实证明，regexes（或者说 <code>Regex</code>）并不搜索字符串 - 因为要这样做，它们就必须按照我想象的思路来跟踪和改变状态。相反，最佳的方式是把 <code>Regex</code> 想像成一个无状态函数，其签名是 <code>method (Match:D  --&gt; Match:D)</code>：<code>Regex</code> 接收一个 <code>Match</code> 并返回一个 <code>Match</code>，<code>Match</code> 的工作就是包含关于现有状态的数据。</p>
<p>这意味着用 <code>Routine</code> 语法调用 regexes 的实际方式是下面这样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="k">rule</span> <span class="nf">word</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">alpha</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">&amp;word</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>            <span class="c1"># OUTPUT: «(Regex)»</span>
</span></span><span class="line"><span class="cl"><span class="c1">#   ^ &amp; sigil required because it does Callable</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span> <span class="nf">word</span><span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="c1">#        ^^^ Regexes don&#39;t take Str arguments</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$!</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>              <span class="c1"># OUTPUT: «(X::Method::NotFound)»</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$match</span> <span class="o">=</span> <span class="kt">Match</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="p">:</span><span class="s">orig</span><span class="p">(&#39;</span><span class="s1">Raku is -Ofun</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="c1"># call with ^^^^^^ a Match:D with the Str in :orig</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nf">word</span><span class="p">(</span><span class="nv">$match</span><span class="p">);</span>          <span class="c1"># OUTPUT: «｢Raku｣»</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># We can build a non-zero match using :to and :from</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$m2</span> <span class="o">=</span> <span class="kt">Match</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="p">:</span><span class="s">orig</span><span class="p">(&#39;</span><span class="s1">Raku is -Ofun</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">from</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span><span class="s">to</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$m2</span><span class="p">;</span>                   <span class="c1"># OUTPUT: «｢Raku is ｣»</span>
</span></span><span class="line"><span class="cl"><span class="c1"># And we can use that Match normally:</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$m2</span><span class="o">.&amp;</span><span class="p">(/&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\w</span><span class="o">**</span><span class="mi">4</span><span class="p">/);</span>    <span class="c1"># OUTPUT: «｢-Ofun｣»</span>
</span></span><span class="line"><span class="cl"><span class="c1">#         ^^^^^^^^^^^ regex-literal syntax also works</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># A Regex is a Method and a Routine</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">&amp;word</span><span class="o">.^</span><span class="nb">mro</span><span class="o">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="o">]</span><span class="p">;</span>      <span class="c1"># OUTPUT: «((Method) (Routine) (Block) (Code))»</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$match</span><span class="o">.&amp;</span><span class="nf">word</span><span class="p">;</span>          <span class="c1"># OUTPUT: «｢Raku｣»</span>
</span></span><span class="line"><span class="cl"><span class="c1"># so using ^^^^^^ method syntax might be more fitting</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># A regex also returns a Match:</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$res</span> <span class="o">=</span> <span class="n">word</span> <span class="nv">$match</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$res</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>             <span class="c1"># OUTPUT: «(Match)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># But *not* the same Match it got:</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$match</span><span class="o">.</span><span class="nb">WHICH</span><span class="p">;</span>          <span class="c1"># OUTPUT: «Match|94080907590240»</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$res</span><span class="o">.</span><span class="nb">WHICH</span><span class="p">;</span>            <span class="c1"># OUTPUT: «Match|94080907590384»</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$match</span><span class="o">,</span> <span class="nv">$res</span><span class="p">;</span>          <span class="c1"># OUTPUT: «(｢｣ ｢Raku｣)»</span>
</span></span><span class="line"><span class="cl"><span class="c1">#   ^^^^^^ the Match we started with is unchanged</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># The returned Match records where we are in the input string:</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$res</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span> <span class="cm">#`[ OUTPUT: «Match.new( :orig(&#34;Raku is -Ofun&#34;),
</span></span></span><span class="line"><span class="cl"><span class="cm">                                       :from(0), :pos(5) )» ]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Which lets us use it as input for a new match:</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="k">my</span> <span class="nv">$r2</span> <span class="o">=</span> <span class="nv">$res</span><span class="o">.&amp;</span><span class="nf">word</span><span class="p">;</span> <span class="c1"># OUTPUT: «｢is ｣»</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$r2</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>  <span class="cm">#`[ OUTPUT: «Match.new( :orig(&#34;Raku is -Ofun&#34;),
</span></span></span><span class="line"><span class="cl"><span class="cm">                                       :from(5), :pos(8) )» ]</span>
</span></span></code></pre></div><p>上面的代码中值得强调的一点是：不仅 regexes(纯的) 是签名为 <code>Match --&gt; Match</code> 的函数，它们还返回一个与它们所给的不同的 <code>Match</code>。也就是说，regexes 与 <code>Match</code> 交互，就好像后者是不可变的数据容器。</p>
<blockquote>
<p>我不想把这一点扯得太远：在现实中，<code>Match</code> 不是不可变的 - 事实上，上面的代码故意省略了更复杂的匹配，因为复杂的匹配不经过改变(mutation)就无法最终确定。这种改变并不发生在 <code>Regex</code> 代码内部，而且据我所知，并不涉及来自 <code>Match</code> 外部的任何数据 - 从外部来看，它们实际上仍然是不可变的。但是构建我们所习惯的能工作的匹配对象需要改变：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$match</span> <span class="o">=</span> <span class="kt">Match</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="p">:</span><span class="s">orig</span><span class="p">(&#39;</span><span class="s1">The language Raku is -Ofun</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$res</span> <span class="o">=</span> <span class="nv">$match</span><span class="o">.&amp;</span><span class="p">(/:</span><span class="na">s</span><span class="p">[</span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">&lt;(</span><span class="nv">$&lt;name&gt;</span><span class="o">=</span><span class="p">[</span><span class="se">\w</span><span class="o">+</span><span class="p">]</span><span class="sr"> is </span><span class="p">(</span><span class="ni">.</span><span class="o">*</span><span class="p">)/);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$res</span><span class="p">;</span>       <span class="c1"># OUTPUT: «｢The language Raku is -Ofun｣»</span>
</span></span><span class="line"><span class="cl"><span class="c1"># No capture groups, etc   ^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#    vvvvv the `MATCH` method `is implementation-detail`</span>
</span></span><span class="line"><span class="cl"><span class="nv">$res</span><span class="o">.</span><span class="nf">MATCH</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#    ^^^^^ $res is modified in place</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$res</span><span class="p">;</span>       <span class="c1"># OUTPUT: «｢Raku is -Ofun｣</span>
</span></span><span class="line"><span class="cl">                <span class="c1">#           name =&gt; ｢Raku｣</span>
</span></span><span class="line"><span class="cl">                <span class="c1">#           0 =&gt; ｢-Ofun｣»</span>
</span></span></code></pre></div><blockquote>
<p>(我<strong>认为</strong>，<code>Match</code> 的（不）可变性与 <code>Cursor</code> 和 <code>Match</code> 之间的历史区别有关。我相信过去有一个单独的不可变的 <code>Cursor</code> 类，用于进行中的(in-progress)匹配，并被折叠到 <code>Match</code> 中。我怀疑 <code>Match</code> 是不可变的，如果它们以前是 <code>Cursor</code> 的话 - 但是我欢迎对这段历史有更多了解的人进行确认/纠正）。</p>
</blockquote>
<blockquote>
<p>但是 <code>Match</code> 有时是可变的这一事实并不影响我的观点：我从来没有声称 Raku 的 regex 实现 100% 地遵守了一些严格的纯函数概念 - 相关的方法并没有用 <code>is pure</code> 进行标记，而且，无论如何，Raku 的自然舒适区是一个更实用的编程风格。</p>
</blockquote>
<blockquote>
<p>相反，我的观点是，在心理上把 regexes 建模为从一个不可变匹配到另一个不可变匹配的函数是一个（更）有用的模式，而不是把它们想象成具有封装状态的 OOP 对象。像大多数模式一样，它不是在所有情况下都是正确的，但它是一个非常有用的起点。</p>
</blockquote>
<h2 id="新范式解决了老问题">新范式解决了老问题&nbsp;<a class="headline-hash no-text-decoration" href="#新范式解决了老问题">#</a> </h2>
<p>对于 regexes, 现在我们已经有了一个更坚实的基础，让我们回到 grammar 和之前令我困惑的问题上来：为什么我们把 <code>rule lisp-like</code> 改成 <code>method lisp-like</code> 就不需要执行记账(bookkeeping)任务了呢？</p>
<p>让我们在一个稍高的通用水平上回答这个问题：<code>rule</code> 声明会被解语法糖成什么方法？也就是说，我们知道 <em>rule</em>（像所有的 Regexes 那样）在底层确实是方法。这意味着，如果 Raku 没有给我们 <code>rule</code> 声明符，我们本可以多费点力气, 把我们的 <em>rule</em> 写成方法。</p>
<p>而事实上，编写 <em>rule</em> 方法仍然是非常可能的。要把 <em>rule</em> 替换为方法，我们只需要写一个 <code>Regex</code> 的方法；这意味着它需要有我们现在熟悉的 <code>Match --&gt; Match</code> 签名。这个方法只需要完成以下三个任务：</p>
<ol>
<li>声明一个有棘轮的、空格有意义的 <em>Regex</em></li>
<li>以该 grammar 为参数调用这个 regex</li>
<li>(如果已经设置了 action 对象)调用与该 <em>token</em> 同名的 action 方法</li>
</ol>
<p>或者，用代码来说，我们可以把下面的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">G</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">word</span><span class="p">&gt;</span><span class="sr">   </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">word</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">alpha</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>替换为这段代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">G</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">word</span><span class="p">&gt;</span><span class="sr">   </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">word</span><span class="p">(</span> <span class="k">--&gt;</span> <span class="kt">Match:D</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="kt">Match</span> <span class="nv">$new</span> <span class="o">:=</span> <span class="k">regex</span> <span class="p">{:</span><span class="s">r</span><span class="p">:</span><span class="s">s</span> <span class="p">&lt;</span><span class="s">alpha</span><span class="p">&gt;</span><span class="o">+</span> <span class="p">}(</span><span class="nb">self</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$.actions</span><span class="o">.?</span><span class="nf">word</span><span class="p">(</span><span class="nv">$new</span><span class="p">)</span> <span class="k">if</span> <span class="nv">$new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$new</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#   ^^^^ NOTE: returns $new, **not** self. Here, $new is</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># a Grammar (which isa Match), but could be any Match:D</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>你知道为什么我们要返回 <code>$new</code> 而不是 <code>self</code> 吗？我们将 <code>self</code> 传给了 regex，regex 将其视为不可变的。所以关于 <code>self</code> 的任何信息都不会被改变或更新 - 返回它将是一个空操作，所以我们当然会返回新创建的 <code>Match</code>。</p>
<p>这意味着上面声明的 <strong>lisp-like</strong> rule 被去语法糖为这样的东西:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">method</span> <span class="nf">lisp-like</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="kt">Match</span> <span class="nv">$new</span> <span class="o">:=</span> <span class="k">my</span> <span class="k">regex</span> <span class="p">{:</span><span class="s">r</span><span class="p">:</span><span class="s">s</span>
</span></span><span class="line"><span class="cl">        <span class="p">:</span><span class="s">my</span> <span class="nv">$inner</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">&lt;</span><span class="s">?{ $inner
</span></span></span><span class="line"><span class="cl"><span class="s">            = InnerLang.subparse: $/.orig, :pos($/.to) }</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="o">.**</span><span class="p">{</span><span class="nv">$inner</span><span class="o">.</span><span class="nb">to</span> <span class="o">-</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">pos</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$.actions</span><span class="o">.?</span><span class="nf">word</span><span class="p">(</span><span class="nv">$new</span><span class="p">)</span> <span class="k">if</span> <span class="nv">$new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$new</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>而 <strong>lisp-like</strong> 方法则保持原样:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">method</span> <span class="nf">lisp-like</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">InnerLang</span><span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="nv">$.orig</span><span class="o">,</span> <span class="p">:</span><span class="s">pos</span><span class="p">(</span><span class="nv">$.to</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>一旦我们看到这个去语法糖的形式，之前那些令人困惑的问题的答案就非常清楚了。</p>
<ul>
<li>为什么方法要设置 <code>$.pos</code>(<code>$.pos</code>ition) 的状态？它没有 - 它返回了一个新的 Match, 这个新的 <code>Match</code> 带有自己的新位置。</li>
<li>为什么同样的过程不会为 <em>rule</em>(或 <em>token</em>)自动设置 <code>$.pos</code> 呢？因为 <em>rule</em> 的返回值来自于以 Grammar 为调用者调用该 <em>rule</em>（一个 <code>Regex</code>） - 而不是来自于 <em>rule</em> 的 <em>regex</em> 内部的任何代码块的返回值。</li>
<li>为什么我们不能通过 <code>$.pos</code>、<code>$/.pos</code> 或 <code>$¢</code> 手动设置位置？因为我们需要设置的 <code>$.pos</code> 是要从 <em>rule</em> 中返回的新 <code>Match</code> 上的位置，而这些变量都没有指向该 <code>Match</code>（也不可能，因为它还没有被构建）。</li>
</ul>
<p>我不知道你是怎么想的，但是当我从第一个（不正确的）心智模式转向第二个时，我有一种奇妙的感觉，以前一大堆混乱的东西突然变得有意义了。由于这种转变是如此有帮助(至少对我的理解是如此)，所以我在这里重申一次：</p>
<p>拒绝这种（非常不正确的）模式：</p>
<ul>
<li><code>Regex</code> 是一个封装了当前解析状态的类，并在字符串被匹配时更新该状态。</li>
<li><code>Grammar</code> 是一种超级 regex，它为一起工作的多个 regex 管理/更新状态，并代表这些 regex 调用解析后(post-parse)的 action 方法。</li>
<li><code>Match</code> 是用一个 regex 或 grammar 成功解析一个字符串后产生的数据结构，它的存在是为了使这个结果更容易被使用。</li>
</ul>
<p>采用这种（稍微不正确的）模式：</p>
<ul>
<li><code>Match</code> 是一个部分/全部解析过的字符串的不可改变快照。</li>
<li><code>Regex</code> 是一个纯函数，其输入是一个 <code>Match</code>，其输出是一个新的（更多解析的）<code>Match</code>。</li>
<li><code>Grammar</code> 是一个匹配，它提供了局部作用域的 regex 方法并调用相应的 action 方法 - 但它仍然是一个不可变 <code>Match</code>。任何匹配（包括 grammar）都不会被就地更新；相反，它们会被一个新的副本所取代。</li>
</ul>
<h2 id="让心智模式支付租金">让心智模式支付租金&nbsp;<a class="headline-hash no-text-decoration" href="#让心智模式支付租金">#</a> </h2>
<p>这个心智模式当然感觉与我以前从 Raku 的 grammar 和 regexes 中观察到的行为相一致。但是对任何模式的真正测试是它是否能帮助我们对未来有更<a href="https://www.lesswrong.com/tag/making-beliefs-pay-rent">准确的预期</a>。因此，让我们通过考虑如何改进我们在上面看到的 <code>MainLang</code> grammar 来尝试这个模式。这是我们离开代码的地方：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">InnerLang</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">+</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">[&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">~</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="ni">.</span><span class="o">*</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">MainLang</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">[&lt;</span><span class="o">.</span><span class="nf">text-like</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">lisp-like</span><span class="p">&gt;</span><span class="o">*</span><span class="p">]</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">text-like</span> <span class="p">{</span><span class="sr"> </span><span class="p">[&lt;</span><span class="o">.</span><span class="nf">alpha</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">lisp-like</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">InnerLang</span><span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="nv">$.orig</span><span class="o">,</span> <span class="p">:</span><span class="s">pos</span><span class="p">(</span><span class="nv">$.to</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">MainLang</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$input</span><span class="p">);</span>
</span></span></code></pre></div><p>好极了 - 简洁得令人惊叹。但它有一个相当大的遗漏：它没有使用任何 action 对象。部分原因是：我不使用 action 对象是为了使代码更加清晰。在 Mike Clark 的<a href="http://clarkema.org/lab/2022/2022-02-09-raku-multiple-grammars/">原帖</a>中，<code>MainLang.parse</code> 和 <code>InnerLang.parse</code> 的调用都指定了 action 对象。但我认为这不是一个特别令人满意的解决方案。</p>
<p>特别是，把 action 对象传递给 <code>InnerLang.subparse</code> 让我很困扰。在我上一篇文章的 reddit 讨论中，<a href="https://www.reddit.com/r/rakulang/comments/stpvft/comment/hx7fx3y/?utm_source=share&amp;utm_medium=web2x&amp;context=3">P6steve 提出了一个重要的观点</a>：在一个 grammar 中使用多个 action 对象是 grammar 如此强大的一个重要来源。例如，在上面的语言解析用例中，我们可能想要检查语法而不实际执行代码 - 而传递不同的 action 对象可以让我们做到这一点，而不需要对 grammar 的源代码做任何修改（毕竟，这些代码可能在不同的模块中，并且/或者由其他人维护）。</p>
<blockquote>
<p>我会为 OOP 爱好者指出，在运行时传递 action 对象是面向对象设计原则应用的一个绝好例子：用行话说，我们通过使用<a href="https://en.wikipedia.org/wiki/Dependency_injection">依赖注入</a>来确保我们的 grammar 满足<a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">开放-闭合原则</a>。
看，尽管我对 Raku 的 regexes 背后的函数式设计表达了热情，但我还是可以承认多范式的力量！</p>
</blockquote>
<p>然而，我们目前的设计牺牲了一大块我们通常从 action 对象中得到的力量：在 <code>InnerLang.parse</code> 调用的 <code>lisp-like</code> 方法中放入一个特定的 action 对象，实际上已经硬编码了该对象，至少从 <code>MainLang</code> 调用者的角度看是这样。回到语法检查的情况，<code>MainLang</code> 调用者可以传入一个 <strong>CheckMainLangSyntax</strong> action 对象，并获得主语言所需的语法检查行为。但是一旦 grammar 进入内部语言，它就会马上回到使用 <code>lisp-like</code> 方法中列出的 <strong>ExecuteInnerLang</strong>（或其他）action 对象。如果不打开 <code>MainLang</code> 的源代码，<code>MainLang</code> 的调用者就没有办法解决这种情况。让我们来解决这个问题。</p>
<blockquote>
<p>好吧，这完全是个谎言：这是 Raku，所以当然<a href="https://docs.raku.org/language/glossary#TMTOWTDI">有不止一种方法可以做到</a>。他们可以对 <code>MainLang</code> 进行子类化，用一个使用不同 action 对象的等价方法覆盖 <code>lisp-like</code>。或者他们可以把 <code>MainLang.lisp-like</code> 包裹起来。或者使用元对象协议弄乱 <code>MainLang</code> 的方法。或者可能还有其他的一些东西。但是，你知道吗，这不是重点 - 重点是，如果我们的 API 设计得好，用户不应该需要借助这些黑魔法来传递 action 对象。</p>
</blockquote>
<p>那么，我们该如何改变我们的 API 呢？最明显的（但仍然不是很好）的选择是通过 <em>parse</em> 的 <code>:args</code> 参数传递 action 对象。它看起来像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">MainLang</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">TOP</span><span class="p">(</span><span class="o">:</span><span class="nv">$lisp-like-actions</span><span class="p">)</span>  <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">[&lt;</span><span class="o">.</span><span class="nf">text-like</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">lisp-like</span><span class="p">(</span><span class="o">:</span><span class="nv">$lisp-like-actions</span><span class="p">)&gt;</span><span class="o">*</span><span class="p">]</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">text-like</span> <span class="p">{</span><span class="sr">  </span><span class="p">[&lt;</span><span class="o">.</span><span class="nf">alpha</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">lisp-like</span><span class="p">(:</span><span class="s">lisp-like-actions</span><span class="p">(</span><span class="nv">$actions</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">InnerLang</span><span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="nv">$.orig</span><span class="o">,</span> <span class="p">:</span><span class="s">pos</span><span class="p">(</span><span class="nv">$.to</span><span class="p">)</span><span class="o">,</span> <span class="o">:</span><span class="nv">$actions</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">MainLang</span><span class="o">.</span><span class="nb">parse</span><span class="o">:</span> <span class="nv">$input</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="p">:</span><span class="s">args</span><span class="p">(</span>\<span class="p">(:</span><span class="s">lisp-like-actions</span><span class="p">(</span><span class="n">CheckLispSyntax</span><span class="p">)))</span><span class="err">;
</span></span></span></code></pre></div><p>我们已经解决了我们的问题，但我仍然不兴奋。为什么？有两个问题。首先，我们需要把 action 对象先通过 <code>TOP</code>，然后再到 <em>lisp-like</em> - 在这里并不是什么大问题，但如果 <em>lisp-like</em> 被深度嵌套，代码很快就会失控。这个问题广为人知，以至于在官方文档中有它<a href="https://docs.raku.org/language/grammars#Dynamic_variables_in_grammars">自己的小节</a>来解决这个问题。文档里提出的解决方案是使用动态变量，它会是调用上下文作用域的；这是一个好的解决方案，也是我们要使用的。</p>
<blockquote>
<p>我们更好的心智模式让我们理解为什么（如<a href="https://docs.raku.org/language/grammars#Attributes_in_grammars">文档中的下一小节</a>所述）在 grammar 中使用属性不是一个好主意（尽管这将是使一个变量在多个方法中可用的标准方式）。有趣的是，这并不是因为文档中所说的原因 - &ldquo;<em>token</em> 是 Match 的方法，而不是 grammar 本身&rdquo;。正如我们已经看到的，<em>token</em> 是 <em>grammar</em> 本身的方法；该 grammar 继承自 <code>Match</code>，但 <em>token</em> 不是 <code>Match</code> 的方法。(Rakudo 在其 <code>X::Attribute::Regex</code> 异常中重复了这个不正确的理由）。</p>
</blockquote>
<blockquote>
<p>相反，对属性 grammar 持怀疑态度的原因是，正如我们所看到的，grammar 不会被就地修改 - 这意味着它们被频繁复制。当 grammar 被复制时，其所有的属性都被克隆到新的 grammar 中。然而，动态变量不需要被克隆：新的 grammar 将从当前的动态作用域内被调用，因此必然会访问相同的动态变量。</p>
</blockquote>
<blockquote>
<p>所有这些拷贝使属性在两个方面不适合 grammar：首先，属性经常会产生性能损失，特别是当它们存储大型数据结构时。第二，拷贝会让使用（可变）属性更容易出错 - 特别是对于那些不完全了解 grammar 被拷贝的频率以及这些拷贝被嵌套的（以时间复杂度）顺序的用户。例如，如果一个 <em>token</em> 修改了一个属性，而另一个 <em>token</em> 读取了“相同”的属性，那么第二个 <em>token</em> 就有可能得到一个意想不到的不同的值。这种情况可能发生，正如我们新的心智模式所帮助澄清的那样，因为第二个 <em>token</em> 实际上不是在读取同一个属性，而是一个不再与原始属性相联系的独立副本。</p>
</blockquote>
<blockquote>
<p>总而言之，除非我们有非常好的理由选择 grammar 属性（这里我们没有），否则最好避免 grammar 属性。但我确实怀疑目前的异常（和文档）在提供的解释中是否有点不正确或过时。</p>
</blockquote>
<p>我们的 <code>MainLang</code> 代码的第二个问题是，我们使用了 <code>:args</code>，而 <code>:args</code> 感觉像是用来定制特定 <em>rule</em> 的行为的东西。但我们用它来设置 action 对象 - 这似乎更适合作为解析时的配置。为了解决这个问题，我们可以覆盖 <code>MainLang</code> 从 <code>Grammar</code> 继承的 <code>parse</code> 方法，该方法接受一个额外的参数，用于内部 action 对象。</p>
<p>下面是我们的代码在这两种解决方案中的样子。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">MainLang</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">parse</span><span class="p">(</span><span class="o">:</span><span class="nv">$lisp-like-actions</span><span class="o">,</span> <span class="o">|</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="vg">$*lisp-like-actions</span> <span class="o">=</span> <span class="nv">$lisp-like-actions</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">nextsame</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">TOP</span>       <span class="p">{</span><span class="sr"> </span><span class="p">[&lt;</span><span class="o">.</span><span class="nf">text-like</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">lisp-like</span><span class="p">&gt;</span><span class="o">*</span><span class="p">]</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">text-like</span> <span class="p">{</span><span class="sr">  </span><span class="p">[&lt;</span><span class="o">.</span><span class="nf">alpha</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">lisp-like</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">InnerLang</span><span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="nv">$.orig</span><span class="o">,</span> <span class="p">:</span><span class="s">pos</span><span class="p">(</span><span class="nv">$.to</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                    <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="vg">$*lisp-like-actions</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意在 <code>parse</code> 方法中使用了 <code>nextsame</code> - 这使得插入我们的方法并抓取 <code>$lisp-like-actions</code> 参数变得微不足道，而不需要重新实现 <code>Grammar</code> 的 <code>parse</code> 方法或以其他方式打破我们对 <code>Grammar</code> 的依赖性。</p>
<blockquote>
<p>事实上，这种分派模式提供了一个很好的例子，说明为什么 Raku 的方法会自动接受 <code>*%</code>。前几天我回答了一个 <a href="https://stackoverflow.com/questions/71071390/and-detecting-unwanted-named-arguments-to-a-method">StackOverflow 关于 <code>*%</code> 如何有用的问题</a>，我希望我有这段代码可以指出来。因为有了自动的 <code>*%</code>，插入我们的包装方法几乎是微不足道的：我们的 API 可以让用户传入新的命名参数，我们可以在我们的方法中处理这些命名参数，然后在我们继续分派过程中把它们传下去。这样做，我们不会破坏任何不期望这些命名参数的方法 - 那些方法只会吞下我们在 <code>*%</code> 中的参数，并继续正常工作。</p>
</blockquote>
<blockquote>
<p>如果没有 <code>*%</code>（以及对所有方法都有 <code>*%</code> 的期望），试图实现这种包装而不破坏 MRO 中更多的方法将是一项更多的工作 - 我们必须放弃 <code>nextsame</code>，遍历所有的参数，以弄清哪些参数应该传递下去。更糟糕的是，从任何更高级的类的角度来看，摆脱那些“意外”的参数也会让其他类摆脱这些参数 - 包括那些可能想要使用这些参数的类。因此，无论我们做出什么选择，我们都会冒着破坏别人代码的风险。因此，缺少 <code>*%</code> 会使一个微不足道的包装方法变成一个很难做到的方法，而且完全不可能做到 100% 正确。</p>
</blockquote>
<p>在这一点上，我对我们的代码非常满意：<code>MainLang</code> 的调用者可以通过 API 为 <code>InnerLang</code> 传递 action，这个 API 与他们用于传递 <code>MainLang</code> action 的 API 非常相似 - 唯一的区别是，命名参数是 <code>:lisp-lang-actions</code> 而不是 <code>:actions</code>。回想一下语法检查的用例，用户现在可以传入一个检查 Lisp 语法的 action 对象，得到他们想要的主语言和嵌套语言的行为。我们已经完成了我们要做的事情。</p>
<p>但为什么要就此打住呢？</p>
<p>考虑到我们正在处理的用例 - 一种内部编程语言嵌套在一种外部语言中 - 我们似乎很有可能要支持在我们的外部语言中嵌套 Lisp 以外的语言。我们已经增加了很多的灵活性 - 要增加这些灵活性需要什么呢？</p>
<p>事实证明，不需要太多：我们只需微调我们的 API，让调用者传入一个哈希而不是一个 action 对象，然后存储该哈希的内容。我们甚至可以把它设置成 <code>InnerLang</code> 和 <code>InnerLangActions</code> 是默认的 grammar 和 action 对象，假设我们希望这些是最常用的。</p>
<p>还有什么我们应该添加的吗？哦，好吧，我们一直在关注 <code>parse</code> 方法，但 grammar 也有 <code>subparse</code> 和 <code>parsefile</code> 方法。我想我们应该把它们也包装起来，以提供一个一致的 API。这样做是很容易的，尽管它确实需要比我更多的复制和粘贴。</p>
<p>有了所有这些变化，这就是我们最终的 MainLang 类，以及一个调用的例子。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">MainLang</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">parse</span><span class="p">(</span><span class="o">:</span><span class="nv">%nested-lang</span><span class="o">,</span> <span class="o">|</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="vg">%*nested-lang</span> <span class="o">=</span> <span class="p">(:</span><span class="s">grammar</span><span class="p">(</span><span class="n">InnerLang</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                            <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="n">InnerLangActions</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                            <span class="o">|</span><span class="nv">%nested-lang</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nb">nextsame</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">subparse</span><span class="p">(</span><span class="o">:</span><span class="nv">%nested-lang</span><span class="o">,</span> <span class="o">|</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="vg">%*nested-lang</span> <span class="o">=</span> <span class="p">(:</span><span class="s">grammar</span><span class="p">(</span><span class="n">InnerLang</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                            <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="n">InnerLangActions</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                            <span class="o">|</span><span class="nv">%nested-lang</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nb">nextsame</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">parsefile</span><span class="p">(</span><span class="o">:</span><span class="nv">%nested-lang</span><span class="o">,</span> <span class="o">|</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="vg">%*nested-lang</span> <span class="o">=</span> <span class="p">(:</span><span class="s">grammar</span><span class="p">(</span><span class="n">InnerLang</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                            <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="n">InnerLangActions</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                            <span class="o">|</span><span class="nv">%nested-lang</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nb">nextsame</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">TOP</span>       <span class="p">{</span><span class="sr"> </span><span class="p">[&lt;</span><span class="nf">text-like</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">nested-lang</span><span class="p">&gt;</span><span class="o">*</span><span class="p">]</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">text-like</span> <span class="p">{</span><span class="sr"> </span><span class="p">[&lt;</span><span class="o">.</span><span class="nf">alpha</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">nested-lang</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="vg">%*nested-lang</span><span class="p">&lt;</span><span class="s">grammar</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="nv">$.orig</span><span class="o">,</span> <span class="p">:</span><span class="s">pos</span><span class="p">(</span><span class="nv">$.to</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                       <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="vg">%*nested-lang</span><span class="p">&lt;</span><span class="s">actions</span><span class="p">&gt;)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">MainLang</span><span class="o">.</span><span class="nb">parse</span><span class="o">:</span> <span class="nv">$input</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                    <span class="p">:</span><span class="s">nested-lang</span><span class="p">{</span> <span class="p">:</span><span class="s">grammar</span><span class="p">(</span><span class="n">OtherLang</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="n">OtherLangActions</span><span class="p">)};</span>
</span></span></code></pre></div><p>看看这个，我认为可以说我们的心智模式正在支付租金 - 我们用这个模式大大增强了 <code>MainLang</code>，使它同时变得更强大和更灵活。</p>
<h2 id="从思维模式到生产模块">从思维模式到生产模块&nbsp;<a class="headline-hash no-text-decoration" href="#从思维模式到生产模块">#</a> </h2>
<p>我们的 <code>MainLang</code> grammar 增加了相当多的功能，而且，至少在我看来，对于调用者来说会更容易使用。但是，这种增加的功能在声明方面是有代价的：我们已经把一个简单的 8 行 grammar 增加到 32 行 - 其中有 15 行基本上是模板，不能帮助读者理解 grammar 的目的。这似乎是一个完美的机会，可以将一些模板抽象为一个模块。</p>
<p>让我们做一个模块，让我们更简洁地写一个像 <code>MainLang</code> 这样的语法。具体来说，我们的模块将让一个 grammar 委托给不同的 grammar，该 grammar 知道如何处理这些调用，并允许用户在运行时传入适当的 action 对象。</p>
<p>正如这个框架所暗示的，我们的模块基本上是 Raku 的 handles trait 的 Grammar 版本。如果你以前没有接触过它，handles 可以让你把一个方法调用委托给另一个对象（就像我们要委托给另一个 grammar 一样）。从调用你的代码的人的角度来看，一个委托的方法就像你在你的类中手动定义的方法一样；唯一的区别是，实际的执行是，呃，由你委托的对象处理的 - 同样，这也是我们的 grammar 想要的行为。事实上，由于我们所构建的功能与 handles 的功能如此相似，但对于 grammar 来说，这就是我们的模块的名称: Grammar::Handles。</p>
<p>为了实现我们的功能，Raku 很有帮助地将 handles trait 定义为一个 <code>multi</code>，所以我们可以通过给现有的 handles trait 添加一个新的候选者来实现 <code>Grammar::Handles</code>。这样做将给我们的用户提供一个与 Raku 其他部分自然匹配的 API，而且就我个人而言，我非常喜欢这样的 API  - 类似于。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">MainLang</span> <span class="nb">handles</span><span class="p">(</span><span class="n">OtherLang</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</span></span></code></pre></div><p>我们的候选 handles 需要完成以下三个任务。</p>
<ol>
<li>让用户提供 <em>token</em> 名称和每个 <em>token</em> 应该委托给的 grammar（例如，在 MainLang 中，嵌套语言 token 应该委托给 OtherLang grammar）。</li>
<li>让用户通过 [sub]? parse [file]? 方法为委托给的 grammar 传递 action 对象。</li>
<li>在用户提供的名称下设置实际的委托/安装 token</li>
</ol>
<p>如第1点所述，我们将允许用户提供一个与 grammar 名称不同的 <em>token</em> 名称。但通常他们很可能想使用相同的名字（例如，一个 LispLang grammar，处理对 LispLang token 的调用）。但是 handles API 已经通过接受 Pairs 进行重命名来满足这两种使用情况；我们也将这样做。</p>
<p>&amp;trait_mod:<!-- raw HTML omitted --></p>
<p>我们决定实现一个对 grammar 进行操作的 handles trait，这有几个连锁反应，我们应该在进入代码之前讨论一下。</p>
<p>首先，与对 Subs 或 Variables 进行操作的 trait（也许更熟悉）不同，我们的第一个参数不是一个有定义值 - 事实上，它甚至不是一个完全初始化的未定义值。它是一个仍在创建中的对象，甚至不知道谁是父母(<code>.^parents</code>)。这又意味着它不知道自己是 Grammar，因此我们不能使用类型约束 <code>&amp;trait_mod</code> 的签名。幸运的是，Raku 在这里又救了我们，因为 grammar 有自己的元对象，所以我们可以针对它而不是类型进行测试。</p>
<p>第二，因为我们正在声明一个 handle trait，我们将得到一个稍微不寻常的第二个参数：<code>&amp;thunk</code>。<code>&amp;thunk</code> 是一段尚未执行的代码；我们将需要调用这段代码来访问用户调用 handle 的任何参数。这并不是什么大问题；它只是意味着我们必须稍微努力地工作，以便与调用者可能提供的不同输入相匹配（例如，我们不能根据第二个参数的类型使用多重调度）。</p>
<p>我相当肯定的是，尽管有这个名字，<code>&amp;thunk</code> 在技术上并不是 &ldquo;没有立即执行，但没有独立作用域的代码&quot;意义上的 thunk。例如，下面这一行产生了一个真正的 thunk。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">42</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">??</span> <span class="p">(</span><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!!</span> <span class="mi">1</span><span class="p">;</span> <span class="nb">say</span> <span class="nv">$a</span> <span class="c1"># OUTPUT: «(Any)»`</span>
</span></span><span class="line"><span class="cl"><span class="c1">#          ^^^^^^^^^  THUNK!</span>
</span></span></code></pre></div><p>代码 <code>my $a = 2</code> 是一个 thunk：它没有被求值（<code>$a</code> 不是2），也没有得到它自己的范围（<code>say $a</code> 不是一个编译错误）。相反，我非常肯定，handle 的第二个参数确实有自己的作用域 - 所以我们的 <code>&amp;thunk</code> 不是。我认为。</p>
<p>但是我们会坚持使用 <code>&amp;thunk</code> 这个名字，因为这是其他 handles 候选者使用的名字，而且我不倾向于让迂腐的做法妨碍一个描述性的名字。我只是想分享这些细节，以防你和我一样觉得有趣。</p>
<p>现在我们清楚了为什么我们的签名需要是 <code>(Mu:U $grammar, &amp;thunk)</code>，我们准备好了多 <code>trait_mod:&lt;handles&gt;</code> 代码 - 它实际上非常短，至少如果你忽略了对尚未定义的辅助函数的调用。(所以在这一点上，也许它更像是一个待办事项清单，而不是一个实际的实现&hellip;&hellip;）。总之，它在这里。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">trait_mod</span><span class="o">:</span><span class="p">&lt;</span><span class="s">handles</span><span class="p">&gt;(</span><span class="kt">Mu:U</span> <span class="nv">$grammar</span><span class="o">,</span> <span class="nv">&amp;thunk</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">import</span> <span class="n">Grammar::Handles::Helpers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Ensure we don&#39;t mess w/ non-grammar &amp;handles candidates</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="nv">$grammar</span><span class="o">.</span><span class="nb">HOW</span>
</span></span><span class="line"><span class="cl">           <span class="o">.</span><span class="nf">get_default_parent_type</span> <span class="o">!=:=</span> <span class="kt">Grammar</span> <span class="p">{</span> <span class="nb">nextsame</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                     <span class="c1"># vvv The name for our new token</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="kt">Grammar</span> <span class="nv">%tokens</span><span class="p">{</span><span class="kt">Str</span><span class="p">}</span> <span class="o">=</span> <span class="n">build-token-hash</span> <span class="nv">&amp;thunk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#  ^^^^^^^ the Grammar the token delegates to</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">%delegee-args</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#  ^^^^^^^^^^^^^ where [sub]?parse[file]? methods save</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#  args for the delegee Grammar (keyed by token name)</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$grammar</span><span class="o">.&amp;</span><span class="nf">wrap-parse-methods</span><span class="o">:</span> <span class="o">:</span><span class="nv">%delegee-args</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="p">:</span><span class="s">token-names</span><span class="p">(</span><span class="nv">%tokens</span><span class="o">.</span><span class="nb">keys</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$grammar</span><span class="o">.&amp;</span><span class="nf">install-tokens</span><span class="o">:</span>     <span class="o">:</span><span class="nv">%tokens</span><span class="o">,</span> <span class="o">:</span><span class="nv">%delegee-args</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>基于这段代码，我们只需要实现 <code>&amp;build-token-hash</code>（将用户提供的 <code>&amp;thunk</code> 映射成 <code>$token-name =&gt;Grammar</code> 对），<code>&amp;wrap-parse-methods</code>（覆盖 Grammar 的 <code>parse</code>、<code>subparse</code> 和 <code>parsefile</code> 方法，其版本将存储每个委托 grammar 的 <code>:actions</code> 参数等），以及  <code>&amp;install-tokens</code>（安装具有指定 <code>$token-name</code> 的方法，委托给正确的 grammar）。让我们按顺序一个一个地看。</p>
<h2 id="构建-token-哈希">构建 token 哈希&nbsp;<a class="headline-hash no-text-decoration" href="#构建-token-哈希">#</a> </h2>
<p>正如我们刚刚看到的，这个函数得到了 <code>&amp;thunk</code> 作为它的单一参数，并且需要返回 <code>$token-name =&gt; Grammar</code> 对（或者如果 <code>&amp;thunk</code> 不是一个我们可以建立这样一个对的值，则引发一个错误）。具体来说，我们需要处理 Grammar、Strs（我们希望它是一个 Grammar 的名字）和 Pairs（我们希望它有一个 Str 键来作为我们的 <code>$token-name</code>，以及一个 Grammar 或 Str 的值，它是一个 Grammar 的名字）。</p>
<p>这与其他候选 handles 的 API 略有不同。其他候选者要求任何 Pair 参数的 <code>Str()</code> 值等于一个方法名 - 你不能直接传递一个 Method。这对方法来说是有意义的：直接访问它们有点笨拙，而且方法是非常晚的。但是这两点都不适用于 grammar，所以我们的 API 除了允许 Strs 之外，还允许字面 Grammar 值。</p>
<p>处理每一种情况都是相当直接的，这要再次感谢 Raku 的模式匹配。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">Transforms the &amp;thunk passed to `handles` into a hash
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">#| </span><span class="sd">where the keys provide token names to install and the
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">#| </span><span class="sd">values are the delegee Grammars
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">sub</span> <span class="nf">build-token-hash</span><span class="p">(</span><span class="nv">&amp;thunk</span>  <span class="o">-</span> <span class="o">&gt;</span> <span class="kt">Map</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">proto</span> <span class="nf">thunk-mapper</span><span class="p">(</span><span class="o">|</span>  <span class="o">-</span> <span class="o">&gt;</span> <span class="kt">Pair</span><span class="p">)</span>   <span class="p">{</span><span class="o">*</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="nf">thunk-mapper</span><span class="p">(</span><span class="kt">Grammar</span> <span class="nv">$g</span><span class="p">)</span>   <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$g</span><span class="o">.^</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="nv">$g</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="nf">thunk-mapper</span><span class="p">(</span><span class="kt">Pair</span> <span class="nv">$renamed</span> <span class="p">(</span><span class="kt">Grammar</span> <span class="o">:</span><span class="nv">$value</span><span class="o">,</span> <span class="o">|</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$renamed</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="nf">thunk-mapper</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="kt">Grammar</span> <span class="nv">$gram</span> <span class="o">=</span> <span class="k">try</span> <span class="o">::</span><span class="p">(</span><span class="nv">$name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!</span> <span class="o">??</span> <span class="nf">pick-err</span><span class="p">(</span><span class="nv">$!</span><span class="o">,</span> <span class="o">:</span><span class="nv">$name</span><span class="p">)</span> <span class="o">!!</span> <span class="nv">$name</span> <span class="o">=&gt;</span> <span class="nv">$gram</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="nf">thunk-mapper</span><span class="p">(</span><span class="kt">Mu</span> <span class="nv">$type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pick-err</span> <span class="p">(</span><span class="k">try</span> <span class="k">my</span> <span class="kt">Grammar</span> <span class="nv">$</span> <span class="o">=</span> <span class="nv">$type</span><span class="p">)</span> <span class="o">//</span> <span class="nv">$!</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">thunk</span><span class="p">()</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="nv">&amp;thunk-mapper</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>[图中没有：隐藏在 <code>&amp;pick-err</code> 后面的额外的 ~25 行错误处理代码。<code>&amp;pick-err</code> 所做的就是决定抛出 <code>Grammar::Handles</code> 的哪些自定义异常，并将相关参数传递给它。但是，不幸的是，正如我所期望的那样，错误处理最终会比 Raku 中的快乐路径要冗长得多] 。</p>
<p>除了使用 <code>multis</code> 来处理我们的各种情况外，这段代码唯一有点奇特的特点是它使用了运行时插值来查找 <code>my Grammar $gram = try ::($name)</code> 中的 grammar - 我并不经常需要在源代码中输入类或其他符号来查找，但能有这样的选择也很不错。而且这正是我们在这里需要的，因为它让我们把用户提供的 Str 翻译成我们需要的实际 grammar。</p>
<p>好了，我们现在有了我们的 token 哈希；进入下一个步骤。</p>
<p>&amp;wrap-parse-methods</p>
<p>我们的主要目标之一是为用户提供在调用 <code>.parse</code> 和 friends 时指定动作对象的能力。让我们现在就增加这种能力。</p>
<p>我们的基本方法与我们在给 MainLang 添加 parse 方法时的方法相同：检查我们感兴趣的命名参数，以某种方式保存它，然后使用 nextsame 继续调度过程 - 这种强大的模式只有通过 <code>*%_</code> 才能实现。唯一真正的区别是，这次我们处理的不是单一的、硬编码的命名参数，而是任何与 <code>$token-name</code> 匹配的命名参数。这意味着我们需要把 <code>.parse</code> 得到的所有命名参数放入 <code>%args</code> 哈希中，然后在该哈希中搜索我们关心的任何命名参数。</p>
<p>另一个区别是，我们接受的参数会更全面一些：在 MainLang 中，我们只关心 <code>:actions</code>，但 <code>.parse</code> 也接受 <code>:args</code> 和 <code>:rule</code>（当然，还有 <code>*%_</code>）。为了做到这一点，我们只需将所有适当的对传递给 delegee grammar。一旦我们这样做了，我们就用 <code>nextsame</code> 来恢复调度，这就像我们的封装方法根本没有被调用一样。</p>
<p>下面是代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">Overrides the &amp;parse, &amp;subparse, and &amp;parsefile methods with
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">#| </span><span class="sd">a method that loads %delegee-args with named arguments whose
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">#| </span><span class="sd">name matches a known $token-name
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">my</span> <span class="k">method</span> <span class="nf">wrap-parse-methods</span><span class="p">(</span><span class="n">Mu:</span> <span class="o">:</span><span class="nv">@token-names</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                             <span class="o">:</span><span class="nv">%delegee-args</span><span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># despite the |, without vv, this sig rejects positionals</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="k">multi</span> <span class="k">method</span> <span class="nf">wrapper</span> <span class="p">(</span><span class="nv">$</span><span class="o">?,</span> <span class="o">*</span><span class="nv">%args</span><span class="o">,</span> <span class="o">|</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                             <span class="k">is</span> <span class="k">hidden-from-backtrace</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nv">@token-names</span> <span class="k">-&gt;</span> <span class="nv">$name</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">next</span> <span class="k">unless</span> <span class="nv">%args</span><span class="p">{</span><span class="nv">$name</span><span class="p">}:</span><span class="s">exists</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nv">%args</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span><span class="o">.</span><span class="nb">first</span><span class="p">({</span><span class="nv">$_</span> <span class="o">!~~</span> <span class="kt">Map</span><span class="o">|</span><span class="kt">Pair</span><span class="p">}</span><span class="o">,</span> <span class="p">:</span><span class="s">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nb">die</span> <span class="ne">X::TypeCheck::Binding::Parameter</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">                        <span class="p">:</span><span class="s">symbol</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">expected</span><span class="p">(</span><span class="kt">Hash</span><span class="p">())</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                        <span class="s">got</span> <span class="o">=&gt;</span> <span class="nv">%args</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%delegee-args</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">              <span class="o">=</span> <span class="nv">%args</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span><span class="o">.</span><span class="kt">Hash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nb">nextsame</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">|</span><span class="p">&lt;</span><span class="s">parse subparse parsefile</span><span class="p">&gt;</span> <span class="k">-&gt;</span> <span class="nv">$meth-name</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">self</span><span class="o">.^</span><span class="nf">add_multi_method</span><span class="o">:</span> <span class="nv">$meth-name</span><span class="o">,</span> <span class="nv">&amp;wrapper</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>而留给我们的只有一个函数需要实现。</p>
<p>&amp;install-tokens</p>
<p><code>&amp;install-tokens</code> 与 <code>&amp;wrap-parse-methods</code> 很像，但正好相反。就像在 <code>&amp;wrap-parse-methods</code> 中，我们将声明一个新的方法，并将该方法添加到我们的 grammar 中。而且，我们将再次依靠我们的 <code>%delege-args</code> 哈希来完成这项工作 - 唯一不同的是，这次我们不是向哈希添加新的条目，而是检查现有的条目以找到正确的参数。当我们在这里时，我们也会给用户在声明他们的 grammar 时定义默认的 <code>:action</code>, <code>:args</code>, 和 <code>:rule</code> values 的选项。这些默认值仍然可以在运行时通过向 <code>.parse</code> 传递值来覆盖，但默认值的存在可以使典型的使用情况明显地更符合人体工程学。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">Install a method for each known token-name that delegates
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">#| </span><span class="sd">to the correct Grammar delegee and passes the arguments
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">#| </span><span class="sd">that the user supplied in their .parse call
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">my</span> <span class="k">method</span> <span class="nf">install-tokens</span><span class="p">(</span><span class="n">Mu:</span> <span class="o">:</span><span class="nv">%tokens</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                   <span class="o">:</span><span class="nv">%delegee-args</span><span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nv">%tokens</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$name</span><span class="o">,</span> <span class="kt">Grammar</span> <span class="nv">$delegee</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="k">method</span> <span class="nf">TOKEN</span><span class="p">(</span><span class="o">:</span><span class="nv">$actions</span><span class="o">,</span> <span class="o">:</span><span class="nv">$rule</span><span class="o">=</span><span class="p">&#39;</span><span class="s1">TOP</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                        <span class="o">:</span><span class="nv">$args</span><span class="p">)</span> <span class="k">is</span> <span class="k">hidden-from-backtrace</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">given</span> <span class="nv">%delegee-args</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="p">&lt;</span><span class="s">actions</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nv">$actions</span> <span class="k">unless</span> <span class="o">.</span><span class="p">&lt;</span><span class="s">actions</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="p">&lt;</span><span class="s">args</span><span class="p">&gt;</span>    <span class="o">=</span> <span class="nv">$args</span>    <span class="k">unless</span> <span class="o">.</span><span class="p">&lt;</span><span class="s">args</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="p">&lt;</span><span class="s">rule</span><span class="p">&gt;</span>    <span class="o">=</span> <span class="nv">$rule</span>    <span class="k">unless</span> <span class="o">.</span><span class="p">&lt;</span><span class="s">rule</span><span class="p">&gt;:</span><span class="s">exists</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$delegee</span><span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="nv">$.orig</span><span class="o">,</span> <span class="p">:</span><span class="s">pos</span><span class="p">(</span><span class="nv">$.to</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                         <span class="p">:</span><span class="s">from</span><span class="p">(</span><span class="nv">$.from</span><span class="p">)</span><span class="o">,</span> <span class="o">|</span><span class="nv">%delegee-args</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nb">self</span><span class="o">.^</span><span class="nb">add_method</span><span class="o">:</span> <span class="nv">$name</span><span class="o">,</span> <span class="nv">&amp;TOKEN</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这一点上，上面的代码并不令人惊讶（或者，至少，我希望不会！）。然而，值得关注的是，这段代码（以及所有 <code>Grammar::Handles</code> 的代码，真的）在多大程度上依赖于我们在本帖第一节中开发的正确的心智模式。我们知道当我们调用 <code>$delegee.subparse</code> 时，我们可以安装一个 <em>token</em> 来做正确的事情，唯一的原因是我们理解了 Raku 在引擎盖下做什么，以及支撑 Raku 的 Regex 和 Grammar 类的奇妙功能设计。</p>
<p>好了，回顾够了 - 我们已经实现了我们所有的功能，所以是时候看看我们的 trait 在行动了</p>
<h2 id="比较性演示和结论">比较性演示和结论&nbsp;<a class="headline-hash no-text-decoration" href="#比较性演示和结论">#</a> </h2>
<p>为了避免你滚动起来，这里是没有 <code>Grammar::Handles</code> 的 MainLang grammar 的定义和使用情况（在屏幕外定义了 OtherLang、OtherLangActions 和 <code>$input</code>）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">MainLang</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">parse</span><span class="p">(</span><span class="o">:</span><span class="nv">%nested-lang</span><span class="o">,</span> <span class="o">|</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="vg">%*nested-lang</span> <span class="o">=</span> <span class="p">(:</span><span class="s">grammar</span><span class="p">(</span><span class="n">InnerLang</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                            <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="n">InnerLangActions</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                            <span class="o">|</span><span class="nv">%nested-lang</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nb">nextsame</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">subparse</span><span class="p">(</span><span class="o">:</span><span class="nv">%nested-lang</span><span class="o">,</span> <span class="o">|</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="vg">%*nested-lang</span> <span class="o">=</span> <span class="p">(:</span><span class="s">grammar</span><span class="p">(</span><span class="n">InnerLang</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                            <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="n">InnerLangActions</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                            <span class="o">|</span><span class="nv">%nested-lang</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nb">nextsame</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">parsefile</span><span class="p">(</span><span class="o">:</span><span class="nv">%nested-lang</span><span class="o">,</span> <span class="o">|</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="vg">%*nested-lang</span> <span class="o">=</span> <span class="p">(:</span><span class="s">grammar</span><span class="p">(</span><span class="n">InnerLang</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                            <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="n">InnerLangActions</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                            <span class="o">|</span><span class="nv">%nested-lang</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nb">nextsame</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">TOP</span>       <span class="p">{</span><span class="sr"> </span><span class="p">[&lt;</span><span class="nf">text-like</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">nested-lang</span><span class="p">&gt;</span><span class="o">*</span><span class="p">]</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">text-like</span> <span class="p">{</span><span class="sr"> </span><span class="p">[&lt;</span><span class="o">.</span><span class="nf">alpha</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">nested-lang</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="vg">%*nested-lang</span><span class="p">&lt;</span><span class="s">grammar</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="nv">$.orig</span><span class="o">,</span> <span class="p">:</span><span class="s">pos</span><span class="p">(</span><span class="nv">$.to</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                       <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="vg">%*nested-lang</span><span class="p">&lt;</span><span class="s">actions</span><span class="p">&gt;)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">MainLang</span><span class="o">.</span><span class="nb">parse</span><span class="o">:</span> <span class="nv">$input</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                    <span class="p">:</span><span class="s">nested-lang</span><span class="p">{</span> <span class="p">:</span><span class="s">grammar</span><span class="p">(</span><span class="n">OtherLang</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="n">OtherLangActions</span><span class="p">)};</span>
</span></span></code></pre></div><p>而这里是 <code>Grammar::Handles</code> 的等效定义和用法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">MainLang</span> <span class="nb">handles</span><span class="p">(:</span><span class="s">nested-lang</span><span class="p">(</span><span class="n">OtherLang</span><span class="p">))</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">TOP</span>       <span class="p">{</span><span class="sr"> </span><span class="p">[&lt;</span><span class="nf">text-like</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">nested-lang</span><span class="p">&gt;</span><span class="o">*</span><span class="p">]</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">rule</span> <span class="nf">text-like</span> <span class="p">{</span><span class="sr"> </span><span class="p">[&lt;</span><span class="o">.</span><span class="nf">alpha</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">MainLang</span><span class="o">.</span><span class="nb">parse</span><span class="o">:</span> <span class="nv">$input</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                    <span class="p">:</span><span class="s">nested-lang</span><span class="p">{:</span><span class="s">actions</span><span class="p">(</span><span class="n">OtherLangActions</span><span class="p">)};</span>
</span></span></code></pre></div><p>从 32 行到 4 行 - 大约减少了 87%。我认为，这可以说是一次成功的去样板化。而且，更重要的是，我希望那些走到这一步的人至少学到了一些关于 Raku 的东西，而且，也许是带着一个稍微改进的心智模式离开。</p>
<p><code>Grammar::Handles</code> 的完整代码在下面和 gist 中。我还计划在几天内将其作为一个模块发布，一旦我有机会添加一些额外的测试，并纳入围绕这篇文章的讨论中出现的任何建议。我期待着听到你的任何想法/问题 - 特别是，我期待着将 <code>Grammar::Handles</code> 中的方法与 guifa 的 Token::Foreign 中的方法进行比较，后者从不同的角度（呃，或者说是三个不同的角度）来解决同一个问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Grammar::Handles</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="k">module</span> <span class="nn">Grammar::Handles::Helpers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="ne">X::Grammar::Can&#39;tHandle</span> <span class="k">is</span> <span class="kt">Exception</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># extra &#39; to fix my blog’s syntax highlighter (aka hlfix)</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.type</span> <span class="k">is</span> <span class="k">required</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nb">CALL-ME</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="nb">die</span> <span class="nb">self</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">message</span> <span class="p">{</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/§err/.</span><span class="s">trim.indent(2);
</span></span></span><span class="line"><span class="cl"><span class="s">      The `handles` grammar trait expects a Grammar, the name
</span></span></span><span class="line"><span class="cl"><span class="s">      of a Grammar, a Pair with a Grammar value, or a list of
</span></span></span><span class="line"><span class="cl"><span class="s">      any of those types.  But `handles` was called with:
</span></span></span><span class="line"><span class="cl"><span class="s">          </span><span class="se">\qq</span><span class="p">[{</span><span class="nv">$!type</span><span class="o">.</span><span class="nb">raku</span><span class="p">}</span><span class="s2"> of type (</span><span class="p">{</span><span class="nv">$!type</span><span class="o">.</span><span class="nb">WHAT</span><span class="o">.</span><span class="nb">raku</span><span class="p">}</span><span class="s2">)</span><span class="p">]</span><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">      </span><span class="p">§err</span>
</span></span><span class="line"><span class="cl"><span class="p">}}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="ne">X::Grammar::NotFound</span> <span class="k">is</span> <span class="kt">Exception</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nb">CALL-ME</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="nb">die</span> <span class="nb">self</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">message</span> <span class="p">{</span> <span class="k">qq</span><span class="sa">:to</span><span class="p">/§err/.</span><span class="s2">trim.indent(2);
</span></span></span><span class="line"><span class="cl"><span class="s2">      The `handles` grammar trait tried to handle a grammar
</span></span></span><span class="line"><span class="cl"><span class="s2">      named &#39;</span><span class="nv">$!name&#39;</span><span class="s2"> but couldn&#39;t find a grammar by that name
</span></span></span><span class="line"><span class="cl"><span class="s2">      </span><span class="p">§err</span>
</span></span><span class="line"><span class="cl"><span class="p">}}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">A helper select the right error more concisely on the happy path
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">sub</span> <span class="nf">pick-err</span><span class="p">(</span><span class="nv">$_</span><span class="o">,</span> <span class="o">:</span><span class="nv">$name</span><span class="o">,</span> <span class="o">|</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="ne">X::TypeCheck::Assignment</span> <span class="p">{</span> <span class="ne">X::Grammar::Can&#39;tHandle</span><span class="p">(:</span><span class="s">type</span><span class="p">(</span><span class="o">.</span><span class="nb">got</span><span class="p">))</span>  <span class="p">}</span> <span class="c1"># hlfix &#39;</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="ne">X::NoSuchSymbol</span>          <span class="p">{</span> <span class="ne">X::Grammar::NotFound</span><span class="p">(</span><span class="o">:</span><span class="nv">$name</span><span class="p">)</span> <span class="p">}}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">Install a method for each known token-name that delegates
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">#| </span><span class="sd">to the correct Grammar delegee and passes the arguments
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">#| </span><span class="sd">that the user supplied in their .parse call
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">my</span> <span class="k">method</span> <span class="nf">install-tokens</span><span class="p">(</span><span class="n">Mu:</span> <span class="o">:</span><span class="nv">%tokens</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                   <span class="o">:</span><span class="nv">%delegee-args</span><span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nv">%tokens</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$name</span><span class="o">,</span> <span class="kt">Grammar</span> <span class="nv">$delegee</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="k">method</span> <span class="nf">TOKEN</span><span class="p">(</span><span class="o">:</span><span class="nv">$actions</span><span class="o">,</span> <span class="o">:</span><span class="nv">$rule</span><span class="o">=</span><span class="p">&#39;</span><span class="s1">TOP</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                        <span class="o">:</span><span class="nv">$args</span><span class="p">)</span> <span class="k">is</span> <span class="k">hidden-from-backtrace</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">given</span> <span class="nv">%delegee-args</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="p">&lt;</span><span class="s">actions</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nv">$actions</span> <span class="k">unless</span> <span class="o">.</span><span class="p">&lt;</span><span class="s">actions</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="p">&lt;</span><span class="s">args</span><span class="p">&gt;</span>    <span class="o">=</span> <span class="nv">$args</span>    <span class="k">unless</span> <span class="o">.</span><span class="p">&lt;</span><span class="s">args</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="p">&lt;</span><span class="s">rule</span><span class="p">&gt;</span>    <span class="o">=</span> <span class="nv">$rule</span>    <span class="k">unless</span> <span class="o">.</span><span class="p">&lt;</span><span class="s">rule</span><span class="p">&gt;:</span><span class="s">exists</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$delegee</span><span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="nv">$.orig</span><span class="o">,</span> <span class="p">:</span><span class="s">pos</span><span class="p">(</span><span class="nv">$.to</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                         <span class="p">:</span><span class="s">from</span><span class="p">(</span><span class="nv">$.from</span><span class="p">)</span><span class="o">,</span> <span class="o">|</span><span class="nv">%delegee-args</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nb">self</span><span class="o">.^</span><span class="nb">add_method</span><span class="o">:</span> <span class="nv">$name</span><span class="o">,</span> <span class="nv">&amp;TOKEN</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">Transforms the &amp;thunk passed to `handles` into a hash
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">#| </span><span class="sd">where the keys provide token names to install and the
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">#| </span><span class="sd">values are the delegee Grammars
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">sub</span> <span class="nf">build-token-hash</span><span class="p">(</span><span class="nv">&amp;thunk</span>  <span class="o">-</span> <span class="o">&gt;</span> <span class="kt">Map</span><span class="p">())</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">proto</span> <span class="nf">thunk-mapper</span><span class="p">(</span><span class="o">|</span>  <span class="o">-</span> <span class="o">&gt;</span> <span class="kt">Pair</span><span class="p">)</span>   <span class="p">{</span><span class="o">*</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="nf">thunk-mapper</span><span class="p">(</span><span class="kt">Grammar</span> <span class="nv">$g</span><span class="p">)</span>   <span class="p">{</span> <span class="nv">$g</span><span class="o">.^</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="nv">$g</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="nf">thunk-mapper</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="kt">Grammar</span> <span class="nv">$gram</span> <span class="o">=</span> <span class="k">try</span> <span class="o">::</span><span class="p">(</span><span class="nv">$name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!</span> <span class="o">??</span> <span class="nf">pick-err</span><span class="p">(</span><span class="nv">$!</span><span class="o">,</span> <span class="o">:</span><span class="nv">$name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">           <span class="o">!!</span> <span class="nv">$name</span> <span class="o">=&gt;</span> <span class="nv">$gram</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="nf">thunk-mapper</span><span class="p">(</span><span class="kt">Pair</span> <span class="p">(:</span><span class="s">key</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">value</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span><span class="o">,</span> <span class="o">|</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="kt">Grammar</span> <span class="p">{</span> <span class="nv">$name</span> <span class="o">=&gt;</span> <span class="nv">$_</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="kt">Str</span>     <span class="p">{</span> <span class="nv">$name</span> <span class="o">=&gt;</span> <span class="nf">thunk-mapper</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span><span class="o">.</span><span class="nb">value</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span>      <span class="p">{</span> <span class="cm">#`[type err]</span> <span class="n">thunk-mapper</span> <span class="nv">$_</span> <span class="p">}}</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="nf">thunk-mapper</span><span class="p">(</span><span class="kt">Mu</span> <span class="nv">$invalid-type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pick-err</span> <span class="p">(</span><span class="k">try</span> <span class="k">my</span> <span class="kt">Grammar</span> <span class="nv">$</span> <span class="o">=</span> <span class="nv">$invalid-type</span><span class="p">)</span> <span class="o">//</span> <span class="nv">$!</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">thunk</span><span class="p">()</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="nv">&amp;thunk-mapper</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">Overrides the &amp;parse, &amp;subparse, and &amp;parsefile methods with
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">#| </span><span class="sd">a method that loads %delegee-args with named arguments whose
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">#| </span><span class="sd">name matches a known $token-name
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">my</span> <span class="k">method</span> <span class="nf">wrap-parse-methods</span><span class="p">(</span><span class="n">Mu:</span> <span class="o">:</span><span class="nv">@token-names</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                             <span class="o">:</span><span class="nv">%delegee-args</span><span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># despite the |, without vv, this sig rejects positionals</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="k">multi</span> <span class="k">method</span> <span class="nf">wrapper</span> <span class="p">(</span><span class="nv">$</span><span class="o">?,</span> <span class="o">*</span><span class="nv">%args</span><span class="o">,</span> <span class="o">|</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                             <span class="k">is</span> <span class="k">hidden-from-backtrace</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nv">@token-names</span> <span class="k">-&gt;</span> <span class="nv">$name</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">next</span> <span class="k">unless</span> <span class="nv">%args</span><span class="p">{</span><span class="nv">$name</span><span class="p">}:</span><span class="s">exists</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nv">%args</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span><span class="o">.</span><span class="nb">first</span><span class="p">({</span><span class="nv">$_</span> <span class="o">!~~</span> <span class="kt">Map</span><span class="o">|</span><span class="kt">Pair</span><span class="p">}</span><span class="o">,</span> <span class="p">:</span><span class="s">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nb">die</span> <span class="ne">X::TypeCheck::Binding::Parameter</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">                        <span class="p">:</span><span class="s">symbol</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">expected</span><span class="p">(</span><span class="kt">Hash</span><span class="p">())</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                        <span class="s">got</span> <span class="o">=&gt;</span> <span class="nv">%args</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%delegee-args</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">              <span class="o">=</span> <span class="nv">%args</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span><span class="o">.</span><span class="kt">Hash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nb">nextsame</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">|</span><span class="p">&lt;</span><span class="s">parse subparse parsefile</span><span class="p">&gt;</span> <span class="k">-&gt;</span> <span class="nv">$meth-name</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">self</span><span class="o">.^</span><span class="nf">add_multi_method</span><span class="o">:</span> <span class="nv">$meth-name</span><span class="o">,</span> <span class="nv">&amp;wrapper</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">#`[end module Grammar::Handles::Helpers]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="nb">trait_mod</span><span class="o">:</span><span class="p">&lt;</span><span class="s">handles</span><span class="p">&gt;(</span><span class="kt">Mu:U</span> <span class="nv">$grammar</span><span class="o">,</span> <span class="nv">&amp;thunk</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">import</span> <span class="n">Grammar::Handles::Helpers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Ensure we don&#39;t mess w/ non-grammar &amp;handles candidates</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="nv">$grammar</span><span class="o">.</span><span class="nb">HOW</span>
</span></span><span class="line"><span class="cl">           <span class="o">.</span><span class="nf">get_default_parent_type</span> <span class="o">!=:=</span> <span class="kt">Grammar</span> <span class="p">{</span> <span class="nb">nextsame</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                     <span class="c1"># vvv The name for our new token</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="kt">Grammar</span> <span class="nv">%tokens</span><span class="p">{</span><span class="kt">Str</span><span class="p">}</span> <span class="o">=</span> <span class="n">build-token-hash</span> <span class="nv">&amp;thunk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#  ^^^^^^^ the Grammar the token delegates to</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">%delegee-args</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#  ^^^^^^^^^^^^^ where [sub]?parse[file]? methods save</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#  args for the delegee Grammar (keyed by token name)</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$grammar</span><span class="o">.&amp;</span><span class="nf">wrap-parse-methods</span><span class="o">:</span> <span class="o">:</span><span class="nv">%delegee-args</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="p">:</span><span class="s">token-names</span><span class="p">(</span><span class="nv">%tokens</span><span class="o">.</span><span class="nb">keys</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$grammar</span><span class="o">.&amp;</span><span class="nf">install-tokens</span><span class="o">:</span>     <span class="o">:</span><span class="nv">%tokens</span><span class="o">,</span> <span class="o">:</span><span class="nv">%delegee-args</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

        </div>
    </div>
</article>



                <footer>
                    




<div class="no-text-decoration">
    <div class="jump top"><a href="#" title="Top of this page">⮉</a></div>
    <div class="jump bottom"><a href="#bottom" title="Bottom of this page">⮋</a></div>
</div>


 
    
        <div class="hugotoc no-text-decoration">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#为-raku-regexes-建立正确的心智模式">为 Raku regexes 建立正确的心智模式</a></li>
    <li><a href="#regexisamethod好吧这是什么意思">Regex.isa(Method)。好吧，这是什么意思？</a></li>
    <li><a href="#一个糟糕的和错误的心智模式">一个糟糕的和错误的心智模式</a></li>
    <li><a href="#摇摇欲坠的地基">摇摇欲坠的地基</a></li>
    <li><a href="#范式的转变">范式的转变</a></li>
    <li><a href="#新范式解决了老问题">新范式解决了老问题</a></li>
    <li><a href="#让心智模式支付租金">让心智模式支付租金</a></li>
    <li><a href="#从思维模式到生产模块">从思维模式到生产模块</a></li>
    <li><a href="#构建-token-哈希">构建 token 哈希</a></li>
    <li><a href="#比较性演示和结论">比较性演示和结论</a></li>
  </ul>
</nav>
            <a href="#" class="back-to-top">Back to top</a>
        </div>
    
    
<script src="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js"></script>

<link rel="preload" href="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js" as="script">

<script type="application/javascript">(function() {
     var $window = $(window);
     if ($window.width() >= 1400) { 
         var $toc = $('#TableOfContents');
         if ($toc.length > 0) {
             function onScroll(){
                 var currentScroll = $window.scrollTop();
                 var h = $('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .h-feed h2');
                 var id = "";
                 h.each(function (i, e) {
                     e = $(e);
                     if (e.offset().top - 10 <= currentScroll) {
                         id = e.attr('id');
                     }
                 });
                 var current = $toc.find('a.current');
                 if (current.length == 1 && current.eq(0).attr('href') == '#' + id) return true;

                 current.each(function (i, e) {
                     $(e).removeClass('current').siblings('ul').hide();
                 });
                 $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                     $(e).children('a').addClass('current').siblings('ul').show();
                 });
             }
             $window.on('scroll', onScroll);
             $(document).ready(function() {
                 $toc.find('a').parent('li').find('ul').hide();
                 onScroll();
                 document.getElementsByClassName('hugotoc')[0].style.display = '';
             });}}})();</script>








<div class="backtotop center no-text-decoration">
    <a href="#">back to <span class="top">top</span></a>
</div>


<div class="right">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__grammar__"
                                
                                
                                title="See all 0 posts tagged with ‘grammar’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/grammar/">grammar</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>
<div class="clear-float"></div>



<div class="prev-next-navigator clear-float">
    
        <span class="prev-post left no-text-decoration">
            <a href="https://ohmycloud.github.io/notes/2022-03-22-stupid-rust-question/" class="nobr">« Stupid Rust Question</a>
        </span>
    
    
        <span class="next-post right no-text-decoration">
            <a href="https://ohmycloud.github.io/notes/2022-empty-in-raku/" class="nobr">Raku 中的 Empty »</a>
        </span>
    
</div>


<a id="bottom"></a>









                       







                    <ul class="no-bullets feed right inline">
    
        
        
    
</ul>
<div class="clear-float"></div>

                </footer>
                <hr />
            </div>               

            <footer> 
                

<ul class="social no-text-decoration">
    
</ul>










 
    
    



<p class="generated no-text-decoration">
    Generated using  <a href="https://gitlab.com/kaushalmodi/hugo-theme-refined"><code class="nobr">hugo-theme-refined</code></a> + <span class="nobr">Hugo <a href="https://github.com/gohugoio/hugo/commit/312735366b20d64bd61bff8627f593749f86c964">0.123.7</a></span>
</p>

<p>
    
</p>




<div class="badges no-text-decoration">
    
    

    
</div>




<script type="application/javascript">var nav=responsiveNav("#nav");</script>




<script defer src="/js/libs/fragmentions/wrapper.min.e8c468c89edc4f5dccaa8c720c6b220b3088a16cd7b1e4a1e3345985788260c9.js"></script>









            </footer>
        </div> 
    </body>
</html>
