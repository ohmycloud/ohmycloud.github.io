<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
    
    
    

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    
    <meta name="referrer" content="no-referrer">

    <title>
        
            Dataset 变换 ❚ 焉知非鱼
        
    </title>

    
    


    
    
    
    

    
    
    
    

    
    
    

    
    
    
    <style>
     
     
     :root {
         --theme-color: #ac4142;
         --theme-color-light: rgba(172, 65, 66, 0.2);
     }
     
     html {
         line-height: 1.5;
     }
    </style>

    
    

    
    
    
    
    <link rel="stylesheet" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css">
    
    <link rel="preload" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css" as="style">

    



    
        <style>
         
         /* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }

         
         /* Overrides on top of the theme and Chroma CSS */
/* Chroma-based lines highlighting in code blocks */
.chroma .hl {
    background-color: #e8e8e8;
    /* Extend highlight up to 100 characters (assuming that the code blocks never have more than 100 characters in a line) */
    min-width: 100ch;
}
/* GenericHeading */ .chroma .gh { color: #999999; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa; font-weight: bold }

         
        </style>
    

    

    
    
    

    
    <script src="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js"></script>
    
    <link rel="preload" href="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js" as="script">

    
    
    <script defer src="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js"></script>
    
    <link rel="preload" href="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js" as="script">

    

    

    
    
    

    
    
<!-- rel="me" links for IndieAuth -->







    
 
<meta property="og:title" content="Dataset 变换" />
<meta property="og:description"
      content="Dataset Transformations" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ohmyweekly.github.io/notes/2020-08-22-dataset-transformations/" />


    
        <meta property="article:published_time" content="2020-08-22T00:00:00&#43;00:00"/>
    
    
        <meta property="article:modified_time" content="2020-08-22T00:00:00&#43;00:00"/>
    









    




     <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Dataset 变换"/>
<meta name="twitter:description" content="Dataset Transformations"/>


    
    
    <link rel="alternate" type="application/jf2post+json" href="https://ohmyweekly.github.io/notes/2020-08-22-dataset-transformations/jf2post.json" title="Jf2post for 焉知非鱼" />
    
     



    
    
    
        
    


     
        
        <meta name="DC.Creator" content="焉知非鱼"/>
    



    
    
    
    <meta name="hugo-build-date" content="2024-03-01T16:16:06Z"/>
    <meta name="hugo-commit-hash" content="312735366b20d64bd61bff8627f593749f86c964"/>
    <meta name="generator" content="Hugo 0.123.7">
</head>


    
        <body lang="en">
    

        
        <div class="border" id="home"></div>

        <div class="wrapper">   
            
<nav id="nav" class="nav-collapse opened" aria-hidden="false">
    <ul class="navbar">
        <li><a class="" href="/">Home</a></li>
        
            
                <li><a class="" href="https://ohmyweekly.github.io/posts/">Posts</a></li>
            
        
            
                <li><a class="" href="https://ohmyweekly.github.io/notes/">Notes</a></li>
            
        
        
            <li><a class="" href="https://ohmyweekly.github.io/search/">Search</a></li>
        
    </ul>
</nav>

            <div class="container">
                <header class="masthead">
                    <div class="masthead-title no-text-decoration">
                        <a href="/">焉知非鱼</a> <span class="blinking-cursor">❚</span>
                    </div>
                    <div class="masthead-tagline">
                        rakulang, dartlang, nimlang, golang, rustlang, lang lang no see
                    </div>
                </header>

                








<article class="post h-entry notes">
    <header>
        <div class="center">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 0 posts categorized in ‘Flink’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/categories/flink/">Flink</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 0 posts tagged with ‘Flink’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/flink/">Flink</a>
                            </li>
                        
                    
                        
                        
                        
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__dataset-api__"
                                
                                
                                title="See all 0 posts tagged with ‘DataSet API’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/dataset-api/">DataSet API</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>

        <h1 class="post-title p-name">Dataset 变换</h1>

        
        <data class="u-url" value="https://ohmyweekly.github.io/notes/2020-08-22-dataset-transformations/"></data>

        <div class="date-syndication">
            


    
    
    <div class="post-date">
        
        <time datetime="2020-08-22T00:00:00+0000" class="dt-published">Sat Aug 22, 2020</time>
        
        
    </div>


            




        </div>
         



    
    
    
        
    


    
        
        <span class="hide">
            &mdash; <a href="https://ohmyweekly.github.io/" class="u-author">焉知非鱼</a>
        </span>
    


    </header>

    <div class="content">
        
    <div class="description p-summary">
        
        
        
        
        
            
            
        
        <p>Dataset Transformations</p>
    </div>



        





                       


        <div class="e-content">
            




<h1 id="dataset-转换">DataSet 转换</h1>
<p>本文档深入介绍了 DataSets 上可用的转换。关于 Flink Java API 的一般介绍，请参考<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/index.html">编程指南</a>。</p>
<p>对于密集索引的数据集中的压缩元素，请参考<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/zip_elements_guide.html">压缩元素指南</a>。</p>
<h2 id="map">Map&nbsp;<a class="headline-hash no-text-decoration" href="#map">#</a> </h2>
<p>Map 转换将用户定义的映射函数应用于 DataSet 的每个元素。它实现了一对一的映射，也就是说，函数必须准确地返回一个元素。</p>
<p>下面的代码将一个由整数对组成的 DataSet 转化为一个由整数组成的 DataSet。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">intPairs</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">intSums</span> <span class="k">=</span> <span class="n">intPairs</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">pair</span> <span class="k">=&gt;</span> <span class="n">pair</span><span class="o">.</span><span class="n">_1</span> <span class="o">+</span> <span class="n">pair</span><span class="o">.</span><span class="n">_2</span> <span class="o">}</span>
</span></span></code></pre></div><h2 id="flatmap">FlatMap&nbsp;<a class="headline-hash no-text-decoration" href="#flatmap">#</a> </h2>
<p>FlatMap 转换在 DataSet 的每个元素上应用了一个用户定义的 <code>flat-map</code> 函数。这种映射函数的变体可以为每个输入元素返回任意多个结果元素（包括没有）。</p>
<p>下面的代码将一个文本行的 DataSet 转换为一个单词的 DataSet。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">textLines</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">words</span> <span class="k">=</span> <span class="n">textLines</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&#34; &#34;</span><span class="o">)</span> <span class="o">}</span>
</span></span></code></pre></div><h2 id="mappartition">MapPartition&nbsp;<a class="headline-hash no-text-decoration" href="#mappartition">#</a> </h2>
<p>MapPartition 在一次函数调用中转换一个并行分区。map-partition 函数以 Iterable 的形式获取分区，并可以产生任意数量的结果值。每个分区中元素的数量取决于平行度和之前的操作。</p>
<p>下面的代码将文本行的 DataSet 转换为每个分区的计数 DataSet。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">textLines</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1">// Some is required because the return value must be a Collection.
</span></span></span><span class="line"><span class="cl"><span class="c1">// There is an implicit conversion from Option to a Collection.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">counts</span> <span class="k">=</span> <span class="n">texLines</span><span class="o">.</span><span class="n">mapPartition</span> <span class="o">{</span> <span class="n">in</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">size</span><span class="o">)</span> <span class="o">}</span>
</span></span></code></pre></div><h2 id="filter">Filter&nbsp;<a class="headline-hash no-text-decoration" href="#filter">#</a> </h2>
<p>过滤器转换将用户定义的过滤器函数应用于 DataSet 的每个元素，并且只保留那些函数返回为真的元素。</p>
<p>以下代码从数据集中删除所有小于零的整数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">intNumbers</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">naturalNumbers</span> <span class="k">=</span> <span class="n">intNumbers</span><span class="o">.</span><span class="n">filter</span> <span class="o">{</span> <span class="k">_</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">}</span>
</span></span></code></pre></div><p>重要：系统假设函数不会修改应用谓词的元素。违反这个假设会导致错误的结果。</p>
<h2 id="元组数据集的投影projection">元组数据集的投影(Projection)&nbsp;<a class="headline-hash no-text-decoration" href="#元组数据集的投影projection">#</a> </h2>
<p><code>Project</code> 转换删除或移动 Tuple DataSet 的 Tuple 字段。<code>project(int...)</code> 方法通过其索引选择应该保留的 Tuple 字段，并定义它们在输出 Tuple 中的顺序。</p>
<p>投影(Projection)不需要定义用户函数。</p>
<p>下面的代码显示了在 DataSet 上应用 <code>Project</code> 转换的不同方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">Double</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">// [...]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// converts Tuple3&lt;Integer, Double, String&gt; into Tuple2&lt;String, Integer&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="na">project</span><span class="p">(</span><span class="n">2</span><span class="p">,</span><span class="n">0</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">#</span> <span class="n">scala</span>
</span></span><span class="line"><span class="cl"><span class="nc">Not</span> <span class="n">supported</span><span class="o">.</span>
</span></span></code></pre></div><h3 id="分组数据集上的变换">分组数据集上的变换&nbsp;<a class="headline-hash no-text-decoration" href="#分组数据集上的变换">#</a> </h3>
<p><code>reduce</code> 操作可以对分组的数据集进行操作。指定用于分组的键可以通过多种方式进行。</p>
<ul>
<li>键表达式</li>
<li>键选择器函数</li>
<li>一个或多个字段位置键（仅限元组数据集）。</li>
<li>case 类字段(仅 case 类)</li>
</ul>
<p>请看一下 <code>reduce</code> 的例子，看看如何指定分组键。</p>
<h3 id="换算分组数据集">换算分组数据集&nbsp;<a class="headline-hash no-text-decoration" href="#换算分组数据集">#</a> </h3>
<p>应用于分组数据集的 <code>Reduce</code> 转换，使用用户定义的 <code>Reduce</code> 函数将每个分组换算为一个元素。对于每一组输入元素，一个 Reduce 函数将成对的元素连续组合成一个元素，直到每组只剩下一个元素。</p>
<p>请注意，对于一个 <code>ReduceFunction</code>，返回对象的键字段应该与输入值相匹配。这是因为 <code>reduce</code> 是隐式可组合的，当传递给 <code>reduce</code> 运算符时，从 <code>combine</code> 运算符发出的对象又是按键分组的。</p>
<h4 id="在按键表达式分组的数据集上进行-reduce-操作">在按键表达式分组的数据集上进行 Reduce 操作&nbsp;<a class="headline-hash no-text-decoration" href="#在按键表达式分组的数据集上进行-reduce-操作">#</a> </h4>
<p>键表达式指定了 DataSet 中每个元素的一个或多个字段。每个键表达式都是一个公共字段的名称或一个 getter 方法。点号可以用来深入到对象中。键表达式 <code>&quot;*&quot;</code> 可以选择所有字段。下面的代码展示了如何使用键表达式对 POJO 数据集进行分组，并使用 <code>reduce</code> 函数对其进行换算。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="c1">// some ordinary POJO
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">WC</span><span class="o">(</span><span class="k">val</span> <span class="n">word</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">val</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="k">this</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">words</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">WC</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">wordCounts</span> <span class="k">=</span> <span class="n">words</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="s">&#34;word&#34;</span><span class="o">).</span><span class="n">reduce</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">w1</span><span class="o">,</span> <span class="n">w2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">WC</span><span class="o">(</span><span class="n">w1</span><span class="o">.</span><span class="n">word</span><span class="o">,</span> <span class="n">w1</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="n">w2</span><span class="o">.</span><span class="n">count</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h4 id="对按键选择器分组的数据集进行换算">对按键选择器分组的数据集进行换算&nbsp;<a class="headline-hash no-text-decoration" href="#对按键选择器分组的数据集进行换算">#</a> </h4>
<p>键选择器函数从数据集的每个元素中提取一个键值。提取的键值用于对 DataSet 进行分组。下面的代码展示了如何使用键选择器函数对 POJO 数据集进行分组，并使用 reduce 函数对其进行换算。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="c1">// some ordinary POJO
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">WC</span><span class="o">(</span><span class="k">val</span> <span class="n">word</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">val</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="k">this</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">words</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">WC</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">wordCounts</span> <span class="k">=</span> <span class="n">words</span><span class="o">.</span><span class="n">groupBy</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">word</span> <span class="o">}</span> <span class="n">reduce</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">w1</span><span class="o">,</span> <span class="n">w2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">WC</span><span class="o">(</span><span class="n">w1</span><span class="o">.</span><span class="n">word</span><span class="o">,</span> <span class="n">w1</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="n">w2</span><span class="o">.</span><span class="n">count</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h4 id="对按字段位置键分组的数据集进行换算仅元组数据集">对按字段位置键分组的数据集进行换算（仅元组数据集）&nbsp;<a class="headline-hash no-text-decoration" href="#对按字段位置键分组的数据集进行换算仅元组数据集">#</a> </h4>
<p>字段位置键指定了一个 Tuple DataSet 的一个或多个字段，这些字段被用作分组键。下面的代码显示了如何使用字段位置键和应用 reduce 函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">tuples</span> <span class="k">=</span> <span class="nc">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1">// group on the first and second Tuple field
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">reducedTuples</span> <span class="k">=</span> <span class="n">tuples</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">).</span><span class="n">reduce</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span></code></pre></div><h4 id="对按-case-类字段分组的数据集进行换算">对按 case 类字段分组的数据集进行换算&nbsp;<a class="headline-hash no-text-decoration" href="#对按-case-类字段分组的数据集进行换算">#</a> </h4>
<p>当使用 Case Classes 时，你也可以使用字段的名称来指定分组键。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">case</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="o">(</span><span class="k">val</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">tuples</span> <span class="k">=</span> <span class="nc">DataSet</span><span class="o">[</span><span class="kt">MyClass</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1">// group on the first and second field
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">reducedTuples</span> <span class="k">=</span> <span class="n">tuples</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">).</span><span class="n">reduce</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span></code></pre></div><h3 id="在分组数据集上进行分组换算">在分组数据集上进行分组换算&nbsp;<a class="headline-hash no-text-decoration" href="#在分组数据集上进行分组换算">#</a> </h3>
<p>应用在分组 DataSet 上的 GroupReduce 转换，会对每个组调用用户定义的 <code>group-reduce</code> 函数。这与 Reduce 之间的区别在于，用户定义的函数可以一次性获得整个组。该函数是在一个组的所有元素上用一个 <code>Iterable</code> 调用的，并且可以返回任意数量的结果元素。</p>
<h4 id="在按字段位置键分组的数据集上进行分组-reduce只适用于元组数据集">在按字段位置键分组的数据集上进行分组 Reduce(只适用于元组数据集)&nbsp;<a class="headline-hash no-text-decoration" href="#在按字段位置键分组的数据集上进行分组-reduce只适用于元组数据集">#</a> </h4>
<p>下面的代码显示了如何从一个按 Integer 分组的 DataSet 中删除重复的字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">output</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">reduceGroup</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)])</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="n">in</span><span class="o">.</span><span class="n">toSet</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">out</span><span class="o">.</span><span class="n">collect</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span></code></pre></div><h4 id="对按键表达式键选择器函数或-case-类字段分组的数据集进行分组换算">对按键表达式、键选择器函数或 case 类字段分组的数据集进行分组换算&nbsp;<a class="headline-hash no-text-decoration" href="#对按键表达式键选择器函数或-case-类字段分组的数据集进行分组换算">#</a> </h4>
<p>类似于 Reduce 变换中的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/dataset_transformations.html#reduce-on-dataset-grouped-by-key-expression">键表达式</a>、<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/dataset_transformations.html#reduce-on-dataset-grouped-by-keyselector-function">键选择器函数</a>和 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/dataset_transformations.html#reduce-on-dataset-grouped-by-case-class-fields">case 类字段</a>的工作。</p>
<h4 id="对排序组进行-groupreduce">对排序组进行 GroupReduce&nbsp;<a class="headline-hash no-text-decoration" href="#对排序组进行-groupreduce">#</a> </h4>
<p>一个 <code>group-reduce</code> 函数使用一个 Iterable 访问一个组的元素。可选地，Iterable 可以按照指定的顺序输出一个组的元素。在许多情况下，这有助于降低用户定义的 <code>group-reduce</code> 函数的复杂性，并提高其效率。</p>
<p>下面的代码显示了另一个例子，如何在一个由整数分组并按 String 排序的 DataSet 中删除重复的 String。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">output</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">sortGroup</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Order</span><span class="o">.</span><span class="nc">ASCENDING</span><span class="o">).</span><span class="n">reduceGroup</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)])</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="k">var</span> <span class="n">prev</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="kc">null</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">t</span> <span class="k">&lt;-</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">prev</span> <span class="o">!=</span> <span class="n">t</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">out</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">prev</span> <span class="k">=</span> <span class="n">t</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span></code></pre></div><p>注意：如果在 <code>reduce</code> 操作之前，使用运算符的基于排序的执行策略建立了分组，那么 GroupSort 通常是免费的。</p>
<h4 id="可组合的-groupreducefunctions">可组合的 GroupReduceFunctions&nbsp;<a class="headline-hash no-text-decoration" href="#可组合的-groupreducefunctions">#</a> </h4>
<p>与 reduce 函数不同，<code>group-reduce</code> 函数是不可隐式组合的。为了使一个分组换算函数可以组合，它必须实现 <code>GroupCombineFunction</code> 接口。</p>
<p>重要：<code>GroupCombineFunction</code> 接口的通用输入和输出类型必须等于 <code>GroupReduceFunction</code> 的通用输入类型，如下例所示。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="c1">// Combinable GroupReduceFunction that computes two sums.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">MyCombinableGroupReducer</span>
</span></span><span class="line"><span class="cl">  <span class="k">extends</span> <span class="nc">GroupReduceFunction</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span>, <span class="kt">String</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="k">with</span> <span class="nc">GroupCombineFunction</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span>
</span></span><span class="line"><span class="cl"><span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">override</span> <span class="k">def</span> <span class="n">reduce</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">in</span><span class="k">:</span> <span class="kt">java.lang.Iterable</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)],</span>
</span></span><span class="line"><span class="cl">    <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">r</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">in</span><span class="o">.</span><span class="n">iterator</span><span class="o">.</span><span class="n">asScala</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_2</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span> <span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// concat key and sum and emit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">out</span><span class="o">.</span><span class="n">collect</span> <span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="n">_1</span> <span class="o">+</span> <span class="s">&#34;-&#34;</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">override</span> <span class="k">def</span> <span class="n">combine</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">in</span><span class="k">:</span> <span class="kt">java.lang.Iterable</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)],</span>
</span></span><span class="line"><span class="cl">    <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">r</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">in</span><span class="o">.</span><span class="n">iterator</span><span class="o">.</span><span class="n">asScala</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_2</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span> <span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// emit tuple with key and sum
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">out</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="n">r</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="在分组数据集上进行分组合并">在分组数据集上进行分组合并&nbsp;<a class="headline-hash no-text-decoration" href="#在分组数据集上进行分组合并">#</a> </h3>
<p><code>GroupCombine</code> 变换是可组合的 <code>GroupReduceFunction</code> 中 <code>combine</code> 步骤的泛化形式。与此相反，<code>GroupReduce</code> 函数中的 <code>combine</code> 步骤只允许从输入类型 I 到输出类型 I 的组合。这是因为 <code>GroupReduce</code> 函数中的 <code>reduce</code> 步骤期望输入类型 I。</p>
<p>在某些应用中，希望在执行额外的转换（例如减少数据大小）之前，将一个数据集合并成中间格式。这可以通过一个 <code>CombineGroup</code> 转换来实现，而且成本很低。</p>
<p>注意：对分组数据集的 <code>GroupCombine</code> 是在内存中以贪婪的策略执行的，它可能不会一次处理所有数据，而是分多个步骤进行。它也是在各个分区上执行的，而不像 <code>GroupReduce</code> 变换那样进行数据交换。这可能会导致部分结果。</p>
<p>下面的例子演示了如何使用 <code>CombineGroup</code> 变换来实现另一种 <code>WordCount</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">..</span><span class="o">]</span> <span class="c1">// The words received as input
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">combinedWords</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="n">input</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="n">combineGroup</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">(</span><span class="n">words</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)])</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="k">var</span> <span class="n">key</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span>
</span></span><span class="line"><span class="cl">        <span class="k">var</span> <span class="n">count</span> <span class="k">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="n">word</span> <span class="k">&lt;-</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">key</span> <span class="k">=</span> <span class="n">word</span>
</span></span><span class="line"><span class="cl">            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">out</span><span class="o">.</span><span class="n">collect</span><span class="o">((</span><span class="n">key</span><span class="o">,</span> <span class="n">count</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">output</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="n">combinedWords</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">.</span><span class="n">reduceGroup</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">(</span><span class="n">words</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)])</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="k">var</span> <span class="n">key</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span>
</span></span><span class="line"><span class="cl">        <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">((</span><span class="n">word</span><span class="o">,</span> <span class="n">sum</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">key</span> <span class="k">=</span> <span class="n">word</span>
</span></span><span class="line"><span class="cl">            <span class="n">sum</span> <span class="o">+=</span> <span class="n">count</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">out</span><span class="o">.</span><span class="n">collect</span><span class="o">((</span><span class="n">key</span><span class="o">,</span> <span class="n">sum</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>上面的另一种 <code>WordCount</code> 实现演示了 <code>GroupCombine</code> 如何在执行 <code>GroupReduce</code> 转换之前组合单词。上面的例子只是一个概念证明。请注意，组合步骤如何改变 DataSet 的类型，通常在执行 <code>GroupReduce</code> 之前需要进行额外的 Map 转换。</p>
<h4 id="在分组元组数据集上进行聚合">在分组元组数据集上进行聚合&nbsp;<a class="headline-hash no-text-decoration" href="#在分组元组数据集上进行聚合">#</a> </h4>
<p>有一些常用的聚合操作是经常使用的。Aggregate 转换提供了以下内置的聚合函数。</p>
<ul>
<li>Sum,</li>
<li>Min,</li>
<li>Max.</li>
</ul>
<p>Aggregate 变换只能应用在 Tuple 数据集上，并且只支持字段位置键进行分组。</p>
<p>下面的代码显示了如何在按字段位置键分组的数据集上应用&quot;聚合&quot;变换。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">output</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">aggregate</span><span class="o">(</span><span class="nc">SUM</span><span class="o">,</span> <span class="mi">0</span><span class="o">).</span><span class="n">and</span><span class="o">(</span><span class="nc">MIN</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</span></span></code></pre></div><p>要在一个 DataSet 上应用多个聚合，必须在第一个聚合之后使用 <code>.and()</code> 函数，也就是说 <code>.aggregary(SUM, 0).and(MIN, 2)</code> 会产生原始 DataSet 的字段 0 和字段 2 的最小值之和。与此相反，<code>.aggregary(SUM，0).aggregary(MIN，2)</code> 将在一个聚合上应用一个聚合。在给定的示例中，它将在计算字段 0 与字段 1 分组后产生字段 2 的最小值。</p>
<p>注意：聚合函数集将在未来得到扩展。</p>
<h4 id="对分组元组数据集的-minby--maxby-函数">对分组元组数据集的 MinBy / MaxBy 函数&nbsp;<a class="headline-hash no-text-decoration" href="#对分组元组数据集的-minby--maxby-函数">#</a> </h4>
<p><code>MinBy (MaxBy)</code> 转换为每组元组选择一个元组。被选择的元组是一个或多个指定字段的值是最小（最大）的元组。用于比较的字段必须是有效的关键字段，即可比较的字段。如果多个元组具有最小（最大）字段值，则返回这些元组的任意元组。</p>
<p>下面的代码显示了如何从 <code>DataSet&lt;Tuple3&lt;Integer, String, Double&gt;&gt;</code> 中选择具有相同 String 值的每组元组的 Integer 和 Double 字段最小值的元组。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">output</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="n">input</span>
</span></span><span class="line"><span class="cl">                                   <span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>  <span class="c1">// group DataSet on second field
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                                   <span class="o">.</span><span class="n">minBy</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// select tuple with minimum values for first and third field.
</span></span></span></code></pre></div><h3 id="换算整个数据集">换算整个数据集&nbsp;<a class="headline-hash no-text-decoration" href="#换算整个数据集">#</a> </h3>
<p>Reduce 转换将用户定义的 <code>reduce</code> 函数应用于一个数据集的所有元素。随后，<code>reduce</code> 函数将元素对组合成一个元素，直到只剩下一个元素。</p>
<p>下面的代码显示了如何对一个整数数据集的所有元素进行求和。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">intNumbers</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromElements</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">sum</span> <span class="k">=</span> <span class="n">intNumbers</span><span class="o">.</span><span class="n">reduce</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</span></span></code></pre></div><p>使用 Reduce 转换换算一个完整的 DataSet 意味着最后的 Reduce 操作不能并行完成。然而，<code>reduce</code> 函数是可以自动组合的，因此 Reduce 转换不会限制大多数用例的可扩展性。</p>
<h3 id="对整个数据集进行分组换算">对整个数据集进行分组换算&nbsp;<a class="headline-hash no-text-decoration" href="#对整个数据集进行分组换算">#</a> </h3>
<p><code>GroupReduce</code> 转换将用户定义的 <code>group-reduce</code> 函数应用于 DataSet 的所有元素。<code>group-reduce</code> 可以遍历 DataSet 的所有元素，并返回任意数量的结果元素。</p>
<p>下面的示例展示了如何在一个完整的 DataSet 上应用 <code>GroupReduce</code> 转换。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">output</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">reduceGroup</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyGroupReducer</span><span class="o">())</span>
</span></span></code></pre></div><p>注意：如果 <code>group-reduce</code> 函数不可组合，那么在一个完整的 DataSet 上的 <code>GroupReduce</code> 转换不能并行完成。因此，这可能是一个非常耗费计算的操作。请参阅上面的&quot;可组合的 GroupReduceFunctions&quot; 部分，了解如何实现可组合的 <code>group-reduce</code> 函数。</p>
<h3 id="在完整的数据集上进行分组合并groupcombine">在完整的数据集上进行分组合并(GroupCombine)&nbsp;<a class="headline-hash no-text-decoration" href="#在完整的数据集上进行分组合并groupcombine">#</a> </h3>
<p>在一个完整的 DataSet 上的 GroupCombine 的工作原理类似于在一个分组的 DataSet 上的 GroupCombine。在所有节点上对数据进行分区，然后以贪婪的方式进行合并（即只有适合内存的数据才会一次性合并）。</p>
<h3 id="在完整的-tuple-数据集上进行聚合">在完整的 Tuple 数据集上进行聚合&nbsp;<a class="headline-hash no-text-decoration" href="#在完整的-tuple-数据集上进行聚合">#</a> </h3>
<p>有一些常用的聚合操作是经常使用的。Aggregate 转换提供了以下内置的聚合函数。</p>
<ul>
<li>Sum,</li>
<li>Min, 和</li>
<li>Max.</li>
</ul>
<p>Aggregate 变换只能应用于 Tuple 数据集。</p>
<p>下面的代码显示了如何在一个完整的数据集上应用聚合转换。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">output</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">aggregate</span><span class="o">(</span><span class="nc">SUM</span><span class="o">,</span> <span class="mi">0</span><span class="o">).</span><span class="n">and</span><span class="o">(</span><span class="nc">MIN</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</span></span></code></pre></div><p>注意：扩展支持的聚合函数集是我们的路线图。</p>
<h3 id="在完整的元组数据集上实现-minby--maxby">在完整的元组数据集上实现 MinBy / MaxBy&nbsp;<a class="headline-hash no-text-decoration" href="#在完整的元组数据集上实现-minby--maxby">#</a> </h3>
<p><code>MinBy (MaxBy)</code> 转换从一个元组数据集中选择一个元组。被选择的元组是一个或多个指定字段的值是最小（最大）的元组。用于比较的字段必须是有效的键字段，即可比较的字段。如果多个元组具有最小（最大）字段值，则返回这些元组的任意元组。</p>
<p>以下代码显示了如何从 <code>DataSet&lt;Tuple3&lt;Integer, String, Double&gt;&gt;</code> 中选择具有 Integer 和 Double 字段最大值的元组。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">output</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="n">input</span>                          
</span></span><span class="line"><span class="cl">                                   <span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// select tuple with maximum values for first and third field.
</span></span></span></code></pre></div><h3 id="distinct">Distinct&nbsp;<a class="headline-hash no-text-decoration" href="#distinct">#</a> </h3>
<p>Distinct 转换计算源 DataSet 中不同元素的 DataSet。下面的代码从 DataSet 中删除所有重复的元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">output</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">distinct</span><span class="o">()</span>
</span></span></code></pre></div><p>也可以使用以下方法改变 DataSet 中元素的区分方式。</p>
<ul>
<li>一个或多个字段位置键（仅元组数据集）。</li>
<li>一个键选择器函数，或</li>
<li>一个键表达式</li>
</ul>
<h4 id="用字段位置键去重distinct">用字段位置键去重(Distinct)&nbsp;<a class="headline-hash no-text-decoration" href="#用字段位置键去重distinct">#</a> </h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Double</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">output</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">distinct</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>
</span></span></code></pre></div><h4 id="用-keyselector-函数去重distinct">用 KeySelector 函数去重(Distinct)&nbsp;<a class="headline-hash no-text-decoration" href="#用-keyselector-函数去重distinct">#</a> </h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">output</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">distinct</span> <span class="o">{</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nc">Math</span><span class="o">.</span><span class="n">abs</span><span class="o">(</span><span class="n">x</span><span class="o">)}</span>
</span></span></code></pre></div><h4 id="用键表达式去重distinct">用键表达式去重(Distinct)&nbsp;<a class="headline-hash no-text-decoration" href="#用键表达式去重distinct">#</a> </h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="c1">// some ordinary POJO
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">CustomType</span><span class="o">(</span><span class="n">aName</span> <span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">aNumber</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">CustomType</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">output</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">distinct</span><span class="o">(</span><span class="s">&#34;aName&#34;</span><span class="o">,</span> <span class="s">&#34;aNumber&#34;</span><span class="o">)</span>
</span></span></code></pre></div><p>也可以用通配符表示使用所有字段:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="c1">// some ordinary POJO
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">CustomType</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">output</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">distinct</span><span class="o">(</span><span class="s">&#34;_&#34;</span><span class="o">)</span>
</span></span></code></pre></div><h3 id="join">Join&nbsp;<a class="headline-hash no-text-decoration" href="#join">#</a> </h3>
<p>Join 转换将两个 DataSets 连接成一个 DataSet。两个数据集的元素在一个或多个键上进行连接(join)，这些键可以通过使用</p>
<ul>
<li>键选择器函数</li>
<li>一个或多个字段位置键（仅限 Tuple DataSet）。</li>
<li>case 类字段</li>
</ul>
<p>有几种不同的方法来执行 Join 转换，如下所示。</p>
<h4 id="默认的-join-join-into-tuple2">默认的 Join (Join into Tuple2)&nbsp;<a class="headline-hash no-text-decoration" href="#默认的-join-join-into-tuple2">#</a> </h4>
<p>默认的 Join 变换会产生一个新的 Tuple DataSet，它有两个字段。每个元组在第一个元组字段中持有第一个输入 DataSet 的 join 元素，在第二个字段中持有第二个输入 DataSet 的匹配元素。</p>
<p>下面的代码显示了一个使用字段位置键的默认 Join 转换。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input1</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">input2</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Double</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">input1</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">input2</span><span class="o">).</span><span class="n">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</span></span></code></pre></div><h4 id="用-join-函数连接">用 Join 函数连接&nbsp;<a class="headline-hash no-text-decoration" href="#用-join-函数连接">#</a> </h4>
<p>Join 转换也可以调用用户定义的 <code>join</code> 函数来处理连接(joining)元组。<code>join</code> 函数接收第一个输入 DataSet 的一个元素和第二个输入 DataSet 的一个元素，并准确返回一个元素。</p>
<p>下面的代码使用键选择器函数执行了一个带有自定义 java 对象的 DataSet 和一个 Tuple DataSet 的连接，并展示了如何使用用户定义的连接(join)函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">case</span> <span class="k">class</span> <span class="nc">Rating</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">category</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">points</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">ratings</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Ratings</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">weights</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">weightedRatings</span> <span class="k">=</span> <span class="n">ratings</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">weights</span><span class="o">).</span><span class="n">where</span><span class="o">(</span><span class="s">&#34;category&#34;</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">rating</span><span class="o">,</span> <span class="n">weight</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">rating</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">rating</span><span class="o">.</span><span class="n">points</span> <span class="o">*</span> <span class="n">weight</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h4 id="用-flat-join-函数连接">用 Flat-Join 函数连接&nbsp;<a class="headline-hash no-text-decoration" href="#用-flat-join-函数连接">#</a> </h4>
<p>类似于 Map 和 FlatMap，<code>FlatJoin</code> 的行为方式与 Join 相同，但它不是返回一个元素，而是可以返回（收集）、零个、一个或多个元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">case</span> <span class="k">class</span> <span class="nc">Rating</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">category</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">points</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">ratings</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Ratings</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">weights</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">weightedRatings</span> <span class="k">=</span> <span class="n">ratings</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">weights</span><span class="o">).</span><span class="n">where</span><span class="o">(</span><span class="s">&#34;category&#34;</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">rating</span><span class="o">,</span> <span class="n">weight</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Double</span><span class="o">)])</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">weight</span><span class="o">.</span><span class="n">_2</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="o">)</span> <span class="n">out</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="n">rating</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">rating</span><span class="o">.</span><span class="n">points</span> <span class="o">*</span> <span class="n">weight</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h4 id="用-projection-java-only-连接">用 Projection (Java Only) 连接&nbsp;<a class="headline-hash no-text-decoration" href="#用-projection-java-only-连接">#</a> </h4>
<p>Join 变换可以使用投影(projection)构造结果元组，如下所示:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">Byte</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">input1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">// [...]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">Double</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">input2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">// [...]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">DataSet</span><span class="o">&lt;</span><span class="n">Tuple4</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Double</span><span class="p">,</span><span class="w"> </span><span class="n">Byte</span><span class="o">&gt;&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">input1</span><span class="p">.</span><span class="na">join</span><span class="p">(</span><span class="n">input2</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="c1">// key definition on first DataSet using a field position key</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="p">.</span><span class="na">where</span><span class="p">(</span><span class="n">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="c1">// key definition of second DataSet using a field position key</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="p">.</span><span class="na">equalTo</span><span class="p">(</span><span class="n">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="c1">// select and reorder fields of matching tuples</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="p">.</span><span class="na">projectFirst</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="n">2</span><span class="p">).</span><span class="na">projectSecond</span><span class="p">(</span><span class="n">1</span><span class="p">).</span><span class="na">projectFirst</span><span class="p">(</span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="c1">// scala
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nc">Not</span> <span class="n">supported</span><span class="o">.</span>
</span></span></code></pre></div><h4 id="用数据集大小提示-join">用数据集大小提示 Join&nbsp;<a class="headline-hash no-text-decoration" href="#用数据集大小提示-join">#</a> </h4>
<p>为了引导优化器选择正确的执行策略，你可以提示要连接(join)的 DataSet 的大小，如下所示:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input1</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">input2</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// hint that the second DataSet is very small
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">result1</span> <span class="k">=</span> <span class="n">input1</span><span class="o">.</span><span class="n">joinWithTiny</span><span class="o">(</span><span class="n">input2</span><span class="o">).</span><span class="n">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// hint that the second DataSet is very large
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">result1</span> <span class="k">=</span> <span class="n">input1</span><span class="o">.</span><span class="n">joinWithHuge</span><span class="o">(</span><span class="n">input2</span><span class="o">).</span><span class="n">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</span></span></code></pre></div><h4 id="join-算法提示">Join 算法提示&nbsp;<a class="headline-hash no-text-decoration" href="#join-算法提示">#</a> </h4>
<p>Flink 运行时可以以各种方式执行连接(join)。每一种可能的方式在不同的情况下都会优于其他方式。系统会尝试自动选择一种合理的方式，但也允许你手动选择一种策略，以防你想强制执行特定的连接(join)方式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input1</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">SomeType</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">input2</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">AnotherType</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// hint that the second DataSet is very small
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">result1</span> <span class="k">=</span> <span class="n">input1</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">input2</span><span class="o">,</span> <span class="nc">JoinHint</span><span class="o">.</span><span class="nc">BROADCAST_HASH_FIRST</span><span class="o">).</span><span class="n">where</span><span class="o">(</span><span class="s">&#34;id&#34;</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="s">&#34;key&#34;</span><span class="o">)</span>
</span></span></code></pre></div><p>有以下提示:</p>
<ul>
<li>
<p>OPTIMIZER_CHOOSES: 相当于完全不给提示，让系统来选择。</p>
</li>
<li>
<p>BROADCAST_HASH_FIRST：广播第一个输入，并据此建立一个哈希表，由第二个输入探测。如果第一个输入的数据非常小，这是一个很好的策略。</p>
</li>
<li>
<p>BROADCAST_HASH_SECOND: 广播第二个输入，并从中建立一个哈希表，由第一个输入探测。如果第二个输入非常小，是一个很好的策略。</p>
</li>
<li>
<p>REPARTITION_HASH_FIRST：系统对每个输入进行分区（洗牌）（除非输入已经被分区），并从第一个输入建立一个哈希表。如果第一个输入比第二个输入小，但两个输入都很大，这个策略就很好。注意：如果无法估计大小，也无法重新使用已有的分区和排序，系统就会使用这个默认的后备策略。</p>
</li>
<li>
<p>REPARTITION_HASH_SECOND：系统对每个输入进行分区（洗牌）（除非输入已经被分区），并从第二个输入建立一个哈希表。如果第二个输入比第一个输入小，但两个输入仍然很大，这个策略就很好。</p>
</li>
<li>
<p>REPARTITION_SORT_MERGE：系统对每个输入进行分区（洗牌）（除非输入已经分区），并对每个输入进行排序（除非已经排序）。通过对排序后的输入进行流式合并来连接(join)这些输入。如果一个或两个输入都已经被排序，这个策略就很好。</p>
</li>
</ul>
<h3 id="外连接">外连接&nbsp;<a class="headline-hash no-text-decoration" href="#外连接">#</a> </h3>
<p><code>OuterJoin</code> 转换在两个数据集上执行左、右或全外连接。外连接与常规（内连接）类似，创建所有键值相等的元素对。此外，如果在另一侧没有找到匹配的键，&ldquo;外侧&quot;的记录（左、右，或者在完全的情况下两者都有）将被保留。匹配的一对元素（或一个元素和另一个输入的空值）被交给 JoinFunction 将这对元素变成一个元素，或交给 FlatJoinFunction 将这对元素变成任意多个（包括无）元素。</p>
<p>两个 DataSets 的元素都是在一个或多个键上连接的，这些键可以通过使用</p>
<ul>
<li>键选择器函数</li>
<li>一个或多个字段位置键（仅限 Tuple DataSet）。</li>
<li>case 类字段</li>
</ul>
<p>OuterJoins 只支持 Java 和 Scala DataSet API。</p>
<h4 id="用-join-函数进行外连接">用 Join 函数进行外连接&nbsp;<a class="headline-hash no-text-decoration" href="#用-join-函数进行外连接">#</a> </h4>
<p><code>OuterJoin</code> 转换调用一个用户定义的 <code>join</code> 函数来处理连接元组。<code>join</code> 函数接收第一个输入 DataSet 的一个元素和第二个输入 DataSet 的一个元素，并准确地返回一个元素。根据外连接的类型（左、右、全），连接函数的两个输入元素中可以有一个是空的。</p>
<p>下面的代码使用键选择器函数执行 DataSet 与自定义 java 对象和 Tuple DataSet 的左外连接，并展示了如何使用用户定义的连接函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">case</span> <span class="k">class</span> <span class="nc">Rating</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">category</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">points</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">movies</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">ratings</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Ratings</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">moviesWithPoints</span> <span class="k">=</span> <span class="n">movies</span><span class="o">.</span><span class="n">leftOuterJoin</span><span class="o">(</span><span class="n">ratings</span><span class="o">).</span><span class="n">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">movie</span><span class="o">,</span> <span class="n">rating</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">movie</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="k">if</span> <span class="o">(</span><span class="n">rating</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">rating</span><span class="o">.</span><span class="n">points</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h4 id="使用-flat-join-函数进行外连接">使用 Flat-Join 函数进行外连接&nbsp;<a class="headline-hash no-text-decoration" href="#使用-flat-join-函数进行外连接">#</a> </h4>
<p>类似于 Map 和 FlatMap，一个带有 <code>flat-join</code> 函数的 OuterJoin 的行为与带有 <code>join</code> 函数的 OuterJoin 相同，但它不是返回一个元素，而是可以返回（收集）、零个、一个或多个元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="nc">Not</span> <span class="n">supported</span><span class="o">.</span>
</span></span></code></pre></div><h4 id="join-算法提示-1">Join 算法提示&nbsp;<a class="headline-hash no-text-decoration" href="#join-算法提示-1">#</a> </h4>
<p>Flink 运行时可以以各种方式执行外连接。每一种可能的方式在不同的情况下都会优于其他方式。系统试图自动选择一种合理的方式，但允许你手动选择一种策略，以防你想强制执行特定的外连接方式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input1</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">SomeType</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">input2</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">AnotherType</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// hint that the second DataSet is very small
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">result1</span> <span class="k">=</span> <span class="n">input1</span><span class="o">.</span><span class="n">leftOuterJoin</span><span class="o">(</span><span class="n">input2</span><span class="o">,</span> <span class="nc">JoinHint</span><span class="o">.</span><span class="nc">REPARTITION_SORT_MERGE</span><span class="o">).</span><span class="n">where</span><span class="o">(</span><span class="s">&#34;id&#34;</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="s">&#34;key&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">result2</span> <span class="k">=</span> <span class="n">input1</span><span class="o">.</span><span class="n">rightOuterJoin</span><span class="o">(</span><span class="n">input2</span><span class="o">,</span> <span class="nc">JoinHint</span><span class="o">.</span><span class="nc">BROADCAST_HASH_FIRST</span><span class="o">).</span><span class="n">where</span><span class="o">(</span><span class="s">&#34;id&#34;</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="s">&#34;key&#34;</span><span class="o">)</span>
</span></span></code></pre></div><p>有以下提示:</p>
<ul>
<li>
<p>OPTIMIZER_CHOOSES: 相当于完全不给提示，让系统来选择。</p>
</li>
<li>
<p>BROADCAST_HASH_FIRST：广播第一个输入，并据此建立一个哈希表，由第二个输入探测。如果第一个输入的数据非常小，这是一个很好的策略。</p>
</li>
<li>
<p>BROADCAST_HASH_SECOND: 广播第二个输入，并从中建立一个哈希表，由第一个输入探测。如果第二个输入非常小，是一个很好的策略。</p>
</li>
<li>
<p>REPARTITION_HASH_FIRST：系统对每个输入进行分区（洗牌）（除非输入已经被分区），并从第一个输入建立一个哈希表。如果第一个输入比第二个输入小，但两个输入仍然很大，这个策略就很好。</p>
</li>
<li>
<p>REPARTITION_HASH_SECOND：系统对每个输入进行分区（洗牌）（除非输入已经被分区），并从第二个输入建立一个哈希表。如果第二个输入比第一个输入小，但两个输入仍然很大，这个策略就很好。</p>
</li>
<li>
<p>REPARTITION_SORT_MERGE：系统对每个输入进行分区（洗牌）（除非输入已经分区），并对每个输入进行排序（除非已经排序）。通过对排序后的输入进行流式合并来连接(join)这些输入。如果一个或两个输入都已经被排序，这个策略就很好。</p>
</li>
</ul>
<p>注意：目前还不是所有的外连接类型都支持所有的执行策略。</p>
<ul>
<li>
<p>LeftOuterJoin 支持:</p>
<ul>
<li>OPTIMIZER_CHOOSES</li>
<li>BROADCAST_HASH_SECOND</li>
<li>REPARTITION_HASH_SECOND</li>
<li>REPARTITION_SORT_MERGE</li>
</ul>
</li>
<li>
<p>RightOuterJoin 支持:</p>
<ul>
<li>OPTIMIZER_CHOOSES</li>
<li>BROADCAST_HASH_FIRST</li>
<li>REPARTITION_HASH_FIRST</li>
<li>REPARTITION_SORT_MERGE</li>
</ul>
</li>
<li>
<p>FullOuterJoin 支持:</p>
<ul>
<li>OPTIMIZER_CHOOSES</li>
<li>REPARTITION_SORT_MERGE</li>
</ul>
</li>
</ul>
<h3 id="cross">Cross&nbsp;<a class="headline-hash no-text-decoration" href="#cross">#</a> </h3>
<p>Cross 变换将两个 DataSets 组合成一个 DataSet。它建立了两个输入数据集元素的所有 pairwise 组合，即建立了一个笛卡尔积。Cross 变换要么在每对元素上调用用户定义的 <code>cross</code> 函数，要么输出一个 Tuple2。这两种模式如下所示。</p>
<p>注意：Cross 是一个潜在的计算密集型操作，甚至可以挑战大型计算集群。</p>
<h4 id="使用用户定义函数进行交叉运算">使用用户定义函数进行交叉运算&nbsp;<a class="headline-hash no-text-decoration" href="#使用用户定义函数进行交叉运算">#</a> </h4>
<p>Cross 变换可以调用一个用户定义的 <code>cross</code> 函数。<code>cross</code> 函数接收第一个输入的一个元素和第二个输入的一个元素，并正好返回一个结果元素。</p>
<p>下面的代码展示了如何使用 <code>cross</code> 函数对两个 DataSets 进行交叉变换。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">case</span> <span class="k">class</span> <span class="nc">Coord</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">coords1</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Coord</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">coords2</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">Coord</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">distances</span> <span class="k">=</span> <span class="n">coords1</span><span class="o">.</span><span class="n">cross</span><span class="o">(</span><span class="n">coords2</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">c1</span><span class="o">,</span> <span class="n">c2</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">dist</span> <span class="k">=</span> <span class="n">sqrt</span><span class="o">(</span><span class="n">pow</span><span class="o">(</span><span class="n">c1</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">c2</span><span class="o">.</span><span class="n">x</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="n">pow</span><span class="o">(</span><span class="n">c1</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">c2</span><span class="o">.</span><span class="n">y</span><span class="o">,</span> <span class="mi">2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="o">(</span><span class="n">c1</span><span class="o">.</span><span class="n">id</span><span class="o">,</span> <span class="n">c2</span><span class="o">.</span><span class="n">id</span><span class="o">,</span> <span class="n">dist</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h4 id="用数据集大小提示交叉">用数据集大小提示交叉&nbsp;<a class="headline-hash no-text-decoration" href="#用数据集大小提示交叉">#</a> </h4>
<p>为了引导优化器选择正确的执行策略，你可以提示要交叉的 DataSet 的大小，如下所示。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">input1</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">input2</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// hint that the second DataSet is very small
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">result1</span> <span class="k">=</span> <span class="n">input1</span><span class="o">.</span><span class="n">crossWithTiny</span><span class="o">(</span><span class="n">input2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// hint that the second DataSet is very large
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">result1</span> <span class="k">=</span> <span class="n">input1</span><span class="o">.</span><span class="n">crossWithHuge</span><span class="o">(</span><span class="n">input2</span><span class="o">)</span>
</span></span></code></pre></div><h3 id="cogroup">CoGroup&nbsp;<a class="headline-hash no-text-decoration" href="#cogroup">#</a> </h3>
<p>CoGroup 转换联合(jointly)处理两个 DataSets 的组。两个 DataSets 根据定义的键进行分组，共享同一键的两个 DataSets 的组被一起交给用户定义的共组(co-group)函数。如果对于一个特定的键来说，只有一个 DataSet 有一个组，那么 <code>co-group</code> 函数就会和这个组以及一个空组一起被调用。共组(co-group)函数可以分别迭代两个组的元素，并返回任意数量的结果元素。</p>
<p>与 Reduce、GroupReduce 和 Join 类似，可以使用不同的键选择器方法来定义键。</p>
<h4 id="数据集上的-cogroup">数据集上的 CoGroup&nbsp;<a class="headline-hash no-text-decoration" href="#数据集上的-cogroup">#</a> </h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">iVals</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">dVals</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">output</span> <span class="k">=</span> <span class="n">iVals</span><span class="o">.</span><span class="n">coGroup</span><span class="o">(</span><span class="n">dVals</span><span class="o">).</span><span class="n">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">iVals</span><span class="o">,</span> <span class="n">dVals</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">ints</span> <span class="k">=</span> <span class="n">iVals</span> <span class="n">map</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">_2</span> <span class="o">}</span> <span class="n">toSet</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">(</span><span class="n">dVal</span> <span class="k">&lt;-</span> <span class="n">dVals</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="n">ints</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">out</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="n">dVal</span><span class="o">.</span><span class="n">_2</span> <span class="o">*</span> <span class="n">i</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h3 id="union">Union&nbsp;<a class="headline-hash no-text-decoration" href="#union">#</a> </h3>
<p>产生两个 DataSets 的联合(union)，这两个 DataSets 必须是同一类型。两个以上 DataSets 的联合(union)可以通过多个联合(union)调用来实现，如下所示。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">vals1</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">vals2</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">vals3</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">unioned</span> <span class="k">=</span> <span class="n">vals1</span><span class="o">.</span><span class="n">union</span><span class="o">(</span><span class="n">vals2</span><span class="o">).</span><span class="n">union</span><span class="o">(</span><span class="n">vals3</span><span class="o">)</span>
</span></span></code></pre></div><h3 id="rebalance">Rebalance&nbsp;<a class="headline-hash no-text-decoration" href="#rebalance">#</a> </h3>
<p>均匀地重新平衡 DataSet 的并行分区，以消除数据倾斜。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">in</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1">// rebalance DataSet and apply a Map transformation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">out</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">rebalance</span><span class="o">().</span><span class="n">map</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span></code></pre></div><h3 id="hash-partition">Hash-Partition&nbsp;<a class="headline-hash no-text-decoration" href="#hash-partition">#</a> </h3>
<p>在给定的键上对 DataSet 进行散列分割。键可以被指定为位置键、表达式键和键选择器函数（关于如何指定键，请参见 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/dataset_transformations.html#reduce-on-grouped-dataset">Reduce 示例</a>）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">in</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1">// hash-partition DataSet by String value and apply a MapPartition transformation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">out</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">partitionByHash</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">mapPartition</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span></code></pre></div><h3 id="range-partition">Range-Partition&nbsp;<a class="headline-hash no-text-decoration" href="#range-partition">#</a> </h3>
<p>在给定的键上 Range-partitions 一个 DataSet。键可以被指定为位置键、表达式键和键选择器函数（关于如何指定键，请参见 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/dataset_transformations.html#reduce-on-grouped-dataset">Reduce 示例</a>）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">in</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1">// range-partition DataSet by String value and apply a MapPartition transformation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">out</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">partitionByRange</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">mapPartition</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span></code></pre></div><h3 id="sort-partition">Sort Partition&nbsp;<a class="headline-hash no-text-decoration" href="#sort-partition">#</a> </h3>
<p>按照指定的顺序，在指定的字段上对 DataSet 的所有分区进行本地排序。字段可以被指定为字段表达式或字段位置（关于如何指定键，请参阅 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/dataset_transformations.html#reduce-on-grouped-dataset">Reduce 示例</a>）。通过链式 <code>sortPartition()</code> 调用，可以在多个字段上对分区进行排序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">in</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1">// Locally sort partitions in ascending order on the second String field and
</span></span></span><span class="line"><span class="cl"><span class="c1">// in descending order on the first String field.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Apply a MapPartition transformation on the sorted partitions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">out</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">sortPartition</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Order</span><span class="o">.</span><span class="nc">ASCENDING</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="n">sortPartition</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nc">Order</span><span class="o">.</span><span class="nc">DESCENDING</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="n">mapPartition</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span></code></pre></div><h3 id="first-n">First-n&nbsp;<a class="headline-hash no-text-decoration" href="#first-n">#</a> </h3>
<p>返回一个 DataSet 的前 n 个（任意）元素。First-n 可以应用于一个常规的 DataSet、一个分组的 DataSet 或一个分组排序的 DataSet。分组键可以被指定为键选择器函数或字段位置键（关于如何指定键，请参见 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/dataset_transformations.html#reduce-on-grouped-dataset">Reduce 示例</a>）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">in</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span></span></span><span class="line"><span class="cl"><span class="c1">// Return the first five (arbitrary) elements of the DataSet
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">out1</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">first</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Return the first two (arbitrary) elements of each String group
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">out2</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">first</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Return the first three elements of each String group ordered by the Integer field
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">out3</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">sortGroup</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Order</span><span class="o">.</span><span class="nc">ASCENDING</span><span class="o">).</span><span class="n">first</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
</span></span></code></pre></div><p>原文链接: <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/dataset_transformations.html">https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/dataset_transformations.html</a></p>


        </div>
    </div>
</article>



                <footer>
                    




<div class="no-text-decoration">
    <div class="jump top"><a href="#" title="Top of this page">⮉</a></div>
    <div class="jump bottom"><a href="#bottom" title="Bottom of this page">⮋</a></div>
</div>


 
    
        <div class="hugotoc no-text-decoration">
            <nav id="TableOfContents">
  <ul>
    <li><a href="#map">Map</a></li>
    <li><a href="#flatmap">FlatMap</a></li>
    <li><a href="#mappartition">MapPartition</a></li>
    <li><a href="#filter">Filter</a></li>
    <li><a href="#元组数据集的投影projection">元组数据集的投影(Projection)</a>
      <ul>
        <li><a href="#分组数据集上的变换">分组数据集上的变换</a></li>
        <li><a href="#换算分组数据集">换算分组数据集</a></li>
        <li><a href="#在分组数据集上进行分组换算">在分组数据集上进行分组换算</a></li>
        <li><a href="#在分组数据集上进行分组合并">在分组数据集上进行分组合并</a></li>
        <li><a href="#换算整个数据集">换算整个数据集</a></li>
        <li><a href="#对整个数据集进行分组换算">对整个数据集进行分组换算</a></li>
        <li><a href="#在完整的数据集上进行分组合并groupcombine">在完整的数据集上进行分组合并(GroupCombine)</a></li>
        <li><a href="#在完整的-tuple-数据集上进行聚合">在完整的 Tuple 数据集上进行聚合</a></li>
        <li><a href="#在完整的元组数据集上实现-minby--maxby">在完整的元组数据集上实现 MinBy / MaxBy</a></li>
        <li><a href="#distinct">Distinct</a></li>
        <li><a href="#join">Join</a></li>
        <li><a href="#外连接">外连接</a></li>
        <li><a href="#cross">Cross</a></li>
        <li><a href="#cogroup">CoGroup</a></li>
        <li><a href="#union">Union</a></li>
        <li><a href="#rebalance">Rebalance</a></li>
        <li><a href="#hash-partition">Hash-Partition</a></li>
        <li><a href="#range-partition">Range-Partition</a></li>
        <li><a href="#sort-partition">Sort Partition</a></li>
        <li><a href="#first-n">First-n</a></li>
      </ul>
    </li>
  </ul>
</nav>
            <a href="#" class="back-to-top">Back to top</a>
        </div>
    
    
<script src="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js"></script>

<link rel="preload" href="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js" as="script">

<script type="application/javascript">(function() {
     var $window = $(window);
     if ($window.width() >= 1400) { 
         var $toc = $('#TableOfContents');
         if ($toc.length > 0) {
             function onScroll(){
                 var currentScroll = $window.scrollTop();
                 var h = $('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .h-feed h2');
                 var id = "";
                 h.each(function (i, e) {
                     e = $(e);
                     if (e.offset().top - 10 <= currentScroll) {
                         id = e.attr('id');
                     }
                 });
                 var current = $toc.find('a.current');
                 if (current.length == 1 && current.eq(0).attr('href') == '#' + id) return true;

                 current.each(function (i, e) {
                     $(e).removeClass('current').siblings('ul').hide();
                 });
                 $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                     $(e).children('a').addClass('current').siblings('ul').show();
                 });
             }
             $window.on('scroll', onScroll);
             $(document).ready(function() {
                 $toc.find('a').parent('li').find('ul').hide();
                 onScroll();
                 document.getElementsByClassName('hugotoc')[0].style.display = '';
             });}}})();</script>








<div class="backtotop center no-text-decoration">
    <a href="#">back to <span class="top">top</span></a>
</div>


<div class="right">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 0 posts categorized in ‘Flink’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/categories/flink/">Flink</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__flink__"
                                
                                
                                title="See all 0 posts tagged with ‘Flink’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/flink/">Flink</a>
                            </li>
                        
                    
                        
                        
                        
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__dataset-api__"
                                
                                
                                title="See all 0 posts tagged with ‘DataSet API’"
                                
                            >
                                <a class="p-category" href="https://ohmyweekly.github.io/tags/dataset-api/">DataSet API</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>
<div class="clear-float"></div>



<div class="prev-next-navigator clear-float">
    
        <span class="prev-post left no-text-decoration">
            <a href="https://ohmyweekly.github.io/notes/2020-08-22-create-statements/" class="nobr">« Create 语句</a>
        </span>
    
    
        <span class="next-post right no-text-decoration">
            <a href="https://ohmyweekly.github.io/notes/2020-08-22-drop-statements/" class="nobr">Drop 语句 »</a>
        </span>
    
</div>


<a id="bottom"></a>









                       







                    <ul class="no-bullets feed right inline">
    
        
        
    
</ul>
<div class="clear-float"></div>

                </footer>
                <hr />
            </div>               

            <footer> 
                

<ul class="social no-text-decoration">
    
</ul>










 
    
    



<p class="generated no-text-decoration">
    Generated using  <a href="https://gitlab.com/kaushalmodi/hugo-theme-refined"><code class="nobr">hugo-theme-refined</code></a> + <span class="nobr">Hugo <a href="https://github.com/gohugoio/hugo/commit/312735366b20d64bd61bff8627f593749f86c964">0.123.7</a></span>
</p>

<p>
    
</p>




<div class="badges no-text-decoration">
    
    

    
</div>




<script type="application/javascript">var nav=responsiveNav("#nav");</script>




<script defer src="/js/libs/fragmentions/wrapper.min.e8c468c89edc4f5dccaa8c720c6b220b3088a16cd7b1e4a1e3345985788260c9.js"></script>









            </footer>
        </div> 
    </body>
</html>
