<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
    
    
    

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    
    <meta name="referrer" content="no-referrer">

    <title>
        
            越简单越好 ❚ 焉知非鱼
        
    </title>

    
    


    
    
    
    

    
    
    
    

    
    
    

    
    
    
    <style>
     
     
     :root {
         --theme-color: #ac4142;
         --theme-color-light: rgba(172, 65, 66, 0.2);
     }
     
     html {
         line-height: 1.5;
     }
    </style>

    
    

    
    
    
    
    <link rel="stylesheet" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css">
    
    <link rel="preload" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css" as="style">

    



    
        <style>
         
         /* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }

         
         /* Overrides on top of the theme and Chroma CSS */
/* Chroma-based lines highlighting in code blocks */
.chroma .hl {
    background-color: #e8e8e8;
    /* Extend highlight up to 100 characters (assuming that the code blocks never have more than 100 characters in a line) */
    min-width: 100ch;
}
/* GenericHeading */ .chroma .gh { color: #999999; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa; font-weight: bold }

         
        </style>
    

    

    
    
    

    
    <script src="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js"></script>
    
    <link rel="preload" href="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js" as="script">

    
    
    <script defer src="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js"></script>
    
    <link rel="preload" href="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js" as="script">

    

    

    
    
    

    
    
<!-- rel="me" links for IndieAuth -->







    
 
<meta property="og:title" content="越简单越好" />
<meta property="og:description"
      content=" " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ohmycloud.github.io/notes/as-simple-as-possible-but-no-simper/" />


    
        <meta property="article:published_time" content="2020-07-03T17:24:52&#43;00:00"/>
    
    
        <meta property="article:modified_time" content="2020-07-03T17:24:52&#43;00:00"/>
    









    




     <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="越简单越好"/>
<meta name="twitter:description" content=" "/>


    
    
    <link rel="alternate" type="application/jf2post+json" href="https://ohmycloud.github.io/notes/as-simple-as-possible-but-no-simper/jf2post.json" title="Jf2post for 焉知非鱼" />
    
     



    
    
    
        
    


     
        
        <meta name="DC.Creator" content="焉知非鱼"/>
    



    
    
    
    <meta name="hugo-build-date" content="2024-03-01T16:16:06Z"/>
    <meta name="hugo-commit-hash" content="312735366b20d64bd61bff8627f593749f86c964"/>
    <meta name="generator" content="Hugo 0.123.7">
</head>


    
        <body lang="en">
    

        
        <div class="border" id="home"></div>

        <div class="wrapper">   
            
<nav id="nav" class="nav-collapse opened" aria-hidden="false">
    <ul class="navbar">
        <li><a class="" href="/">Home</a></li>
        
            
                <li><a class="" href="https://ohmycloud.github.io/posts/">Posts</a></li>
            
        
            
                <li><a class="" href="https://ohmycloud.github.io/notes/">Notes</a></li>
            
        
        
            <li><a class="" href="https://ohmycloud.github.io/search/">Search</a></li>
        
    </ul>
</nav>

            <div class="container">
                <header class="masthead">
                    <div class="masthead-title no-text-decoration">
                        <a href="/">焉知非鱼</a> <span class="blinking-cursor">❚</span>
                    </div>
                    <div class="masthead-tagline">
                        Wait the light to fall
                    </div>
                </header>

                








<article class="post h-entry notes">
    <header>
        <div class="center">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>

        <h1 class="post-title p-name">越简单越好</h1>

        
        <data class="u-url" value="https://ohmycloud.github.io/notes/as-simple-as-possible-but-no-simper/"></data>

        <div class="date-syndication">
            


    
    
    <div class="post-date">
        
        <time datetime="2020-07-03T17:24:52+0000" class="dt-published">Fri Jul 3, 2020</time>
        
        
    </div>


            




        </div>
         



    
    
    
        
    


    
        
        <span class="hide">
            &mdash; <a href="https://ohmycloud.github.io/" class="u-author">焉知非鱼</a>
        </span>
    


    </header>

    <div class="content">
        


        





                       


        <div class="e-content">
            




<p><a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-014/">上周每周挑战</a>的第一个任务是生成范埃克序列:</p>
<pre><code>0, 0, 1, 0, 2, 0, 2, 2, 1, 6, 0, 5, 0, 2, 6, 5, 4, 0,...
</code></pre>
<p>第一个挑战是要理解什么是范埃克序列，因为网上的各种解释都没有即时的帮助。</p>
<p>范埃克序列是一个从零开始的整数列表，序列中的下一个数字由当前数字与该数字最近的前一个出现的距离给出。</p>
<p>例如，如果当前指数N处的数字（我们称它为：Aₙ）是7，那么为了计算指数N+1处的数字，我们通过序列回溯7的最近一次出现（在某个较早的指数M处）。那么序列中的下一个数字就是这两个7的出现之间的距离: N - M</p>
<p>唯一复杂的是，如果当前数字在前面的序列中没有出现，那么下一个数字就是零。这并不像你想象的那样武断：我们可以把这个零值看作是 Aₙ 到自身的距离。也就是说，如果没有前面的出现，那么&quot;前面&quot;出现的唯一可能的候选者只是 Aₙ 本身，所以这种情况下的距离是 N - N，也就是零。</p>
<p>好了，这就是范埃克序列。现在我们如何在 Raku 中生成它？</p>
<p>如果你一直在关注我最近的博客文章，那么了解到 Raku 有一个适当的内置工具，它将让我们通过一个单一的语句来完成整个任务，可能不会有太多的惊喜。这个工具就是<a href="https://docs.raku.org/language/operators#index-entry-..._operators">序列运算符</a>。</p>
<p><code>...</code> 序列操作符接受一个初始值列表，然后是一个代码对象（即一个块或子例程），接着是一个终止条件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@sequence</span> <span class="o">=</span> <span class="nv">@initial-list</span><span class="o">,</span> <span class="nv">&amp;code-obj</span> <span class="o">...</span> <span class="nv">$termination</span><span class="p">;</span>
</span></span></code></pre></div><p>它从初始值开始建立一个序列（字面意思是 <code>Seq</code> 类的对象），然后通过在初始列表的最后元素上反复调用代码对象，在初始列表之后生成额外的值。每次调用代码对象时，它返回的值都会被追加到序列中，直到返回一个与终止条件智能匹配的值，这时序列就完成了。例如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1">#                initial    code-obj       termination</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@odd-nums</span>   <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span>  <span class="p">{</span><span class="nv">$^n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">}</span>   <span class="o">...</span> <span class="mi">999</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@N-powers</span>   <span class="o">=</span> <span class="nv">$N</span><span class="o">,</span> <span class="nv">$N</span>²<span class="o">,</span>  <span class="p">{</span><span class="nv">$^x</span> <span class="o">*</span> <span class="nv">$N</span><span class="p">}</span>  <span class="o">...</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">1_000_000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@fibonacci</span>  <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span>  <span class="p">{</span><span class="nv">$^a</span> <span class="o">+</span> <span class="nv">$^b</span><span class="p">}</span> <span class="o">...</span> <span class="no">∞</span><span class="p">;</span>
</span></span></code></pre></div><p>这些例子与范埃克的序列有一个重要的不同。每个例子都只使用一个前值（或者在Fibonacci的情况下，使用两个前值）来计算下一个数字。但范埃克序列中的下一个数字既取决于紧接的前一个值(Aₙ)，也取决于前一个值之前的整个序列&hellip;它必须被搜索以找到 Aₙ 的适当的前一个出现。</p>
<p>当然，Raku 也支持这种序列：如果你的代码对象使用了特殊的数组参数 <code>@_</code>（或者实际上，任何其他的<a href="http://docs.raku.org/type/Signature#index-entry-slurpy_argument">变量数组参数</a>），那么它每次都会被传递整个前面的序列。</p>
<p>所以现在我们需要做的就是建立一个代码对象(在本例中：一个子例程)，当传递给 <code>@_</code> 中的整个前一个序列时，计算下一个范埃克的数字。它可能看起来像这样:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">next-vanEck&#39;s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$N</span> <span class="o">=</span> <span class="nv">@_</span><span class="o">.</span><span class="nb">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$M</span> <span class="o">=</span> <span class="k">try</span> <span class="p">(</span><span class="nv">$N-1</span><span class="o">...</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="nb">first</span><span class="o">:</span> <span class="p">{</span><span class="nv">@_</span><span class="o">[</span><span class="nv">$^m</span><span class="o">]</span> <span class="o">==</span> <span class="nv">@_</span><span class="o">[</span><span class="nv">$N</span><span class="o">]</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">with</span> <span class="nv">$M</span> <span class="p">{</span> <span class="k">return</span> <span class="nv">$N</span> <span class="o">-</span> <span class="nv">$M</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>    <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span>       <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>当前序列中的最终索引由 <code>@_.end</code> 给出(就像 Perl 中的 <code>$#_</code>)，所以这就是我们当前的N个位置。为了找到最近的前一个相同的数字，我们从索引 N-1 向后走到零，寻找第一个索引 (<code>$^m</code>)，其中该索引的值 (即 <code>@_[$^m]</code>) 等于索引 N 的值 (即 <code>@_[$N]</code>)。如果找到 M，则返回 N-M，否则返回0。</p>
<p>顺便说一下:</p>
<ul>
<li><code>with $M {... }</code> 块只是一个方便的速记: <code>if $M.defined { my $_ := $M; ...}</code>。</li>
<li>搜索 M 的 <code>try</code> 前缀是为了处理 <code>$N</code> 为0的边缘情况，在这种情况下，<code>$N-1...0</code> 会产生一个负数组索引，从而引发异常。</li>
<li>是的，在 Raku 中，在子例程名（或任何其他标识符）中使用撇号或连字符是完全可以的，只要它被正常的标识符包围，所以它不会与字符串的开始相混淆。</li>
</ul>
<p>一旦我们有了一个计算下一个范埃克数的代码对象,那么整个范埃克序列就是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">constant</span> <span class="no">vanEck&#39;s</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">&amp;next-vanEck&#39;s</span> <span class="o">...</span> <span class="no">∞</span><span class="p">;</span>
</span></span></code></pre></div><p>让序列运行到无穷大是没有问题的，因为 <code>...</code> 会惰性地生成它的值：只计算满足给定请求所需的元素数量。</p>
<p>一旦我们有了我们的常数序列，我们就可以请求任何特定的索引，这时下一个范埃克数将被调用尽可能多的次数来计算请求的值:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">vanEck&#39;s</span><span class="o">[</span><span class="mi">100</span><span class="o">]</span><span class="p">;</span>      <span class="c1"># prints: 23</span>
</span></span></code></pre></div><p>这固然是一个干净、紧凑、不乱的解决方案，但并没有达到宣传的目的：&ldquo;一句话&rdquo;。</p>
<p>然而，上面的版本只是一个起点，我们还可以对它进行许多改进&hellip;通过更 Raku 风格的思考和编码。</p>
<p>首先，当一段代码通过索引迭代，然后查找相应的数组元素时，这往往是一个危险的信号。尤其是 Raku，它可以直接迭代那些数组元素，然后在我们需要的时候找到相应的索引（就像我们在这里做的那样）:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Version 2...</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">next-vanEck&#39;s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$N</span> <span class="o">=</span> <span class="nv">@_</span><span class="o">.</span><span class="nb">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$M</span> <span class="o">=</span> <span class="nv">@_</span><span class="o">.</span><span class="nb">head</span><span class="p">(</span><span class="o">*-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nb">first</span><span class="p">(</span><span class="nv">@_</span><span class="o">.</span><span class="nb">tail</span><span class="p">):</span><span class="s">end</span><span class="p">:</span><span class="s">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">with</span> <span class="nv">$M</span> <span class="p">{</span> <span class="k">return</span> <span class="nv">$N</span> <span class="o">-</span> <span class="nv">$M</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>    <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span>       <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这个版本中，我们通过取列表中最后一个元素之前的所有元素(<code>@_.head(*-1)</code>)，然后搜索第一个与最后一个元素相等的元素(<code>.first(@_.tail)</code>)来查找索引 M。</p>
<p>但是，由于我们需要最接近前面的匹配，我们需要在前面的元素中向后搜索，所以我们添加了一个 <code>:end</code> 副词来告诉 <code>.first</code> 从最后搜索。然后，当我们找到一个匹配时，我们需要找到该匹配的位置（而不是在那里找到的值），所以我们添加一个 <code>:k</code> 副词，告诉 <code>.first</code> 返回匹配的 &ldquo;key&rdquo;（即匹配发生的索引），而不是匹配的值。</p>
<p>这种新的定位M索引的方式所需的代码略少，而且不容易出现逐个错误，但真正的好处是它的速度也明显快了。因为它是在迭代数组元素而不是数组索引，所以它不必为了比较每一个之前的元素和最后的元素而进行两次显式数组查找。</p>
<p>这里还有一个小的代码优化可能。正如我们在这个探索的开始时看到的那样，如果没有M索引就返回0的特殊情况，相当于在这种情况下将M设置为N。如果我们这样做，那么我们就可以直接返回 N-M，而不需要对特殊情况进行测试。就像这样:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Version 3...</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">next-vanEck&#39;s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$N</span> <span class="o">=</span> <span class="nv">@_</span><span class="o">.</span><span class="nb">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$M</span> <span class="o">=</span> <span class="nv">@_</span><span class="o">.</span><span class="nb">head</span><span class="p">(</span><span class="o">*-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nb">first</span><span class="p">(</span><span class="nv">@_</span><span class="o">.</span><span class="nb">tail</span><span class="p">):</span><span class="s">end</span><span class="p">:</span><span class="s">k</span> <span class="o">//</span> <span class="nv">$N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nv">$N</span> <span class="o">-</span> <span class="nv">$M</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果 <code>.first</code> 搜索没有找到前面的匹配，它将返回一个未定义的值来代替，所以后面的定义&ndash;或者干脆使用 N 值来代替，在这种情况下，N-M 将按要求为零。</p>
<p>当然，在已经减少了这么多代码之后，坚持使用$N和$M变量的唯一原因是为了自我记录.否则，我们可以简单地将 <code>$N</code> 用 <code>@_.end</code> 代替，将 <code>$M</code> 用新的 <code>head-first-tail</code> 搜索表达式代替，产生:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Version 4...</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">next-vanEck&#39;s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">@_</span><span class="o">.</span><span class="nb">end</span> <span class="o">-</span> <span class="p">(</span><span class="nv">@_</span><span class="o">.</span><span class="nb">head</span><span class="p">(</span><span class="o">*-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nb">first</span><span class="p">(</span><span class="nv">@_</span><span class="o">.</span><span class="nb">tail</span><span class="p">):</span><span class="s">end</span><span class="p">:</span><span class="s">k</span> <span class="o">//</span> <span class="nv">@_</span><span class="o">.</span><span class="nb">end</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这时，我们也几乎不需要命名的子例程。代替:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">constant</span> <span class="no">vanEck&#39;s</span>
</span></span><span class="line"><span class="cl">    <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">&amp;next-vanEck&#39;s</span> <span class="o">...</span> <span class="no">∞</span><span class="p">;</span>
</span></span></code></pre></div><p>我们可以简单地将子例程体 &ldquo;内联&quot;为一个代码块，产生一个真正的单语句解决方案:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">  <span class="k">constant</span> <span class="no">vanEck&#39;s</span>
</span></span><span class="line"><span class="cl">    <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="p">{</span><span class="nv">@_</span><span class="o">.</span><span class="nf">end-</span><span class="p">(</span><span class="nv">@_</span><span class="o">.</span><span class="nb">head</span><span class="p">(</span><span class="o">*-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nb">first</span><span class="p">(</span><span class="nv">@_</span><span class="o">.</span><span class="nb">tail</span><span class="p">):</span><span class="s">end</span><span class="p">:</span><span class="s">k</span><span class="o">//</span><span class="nv">@_</span><span class="o">.</span><span class="nb">end</span><span class="p">)}</span><span class="o">...</span><span class="no">∞</span><span class="p">;</span>
</span></span></code></pre></div><p>工作完成了！</p>
<p>或者是吗？当然，如果我们现在写:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">vanEck&#39;s</span><span class="o">[</span><span class="mi">100</span><span class="o">]</span><span class="p">;</span>       <span class="c1"># Should print: 23</span>
</span></span></code></pre></div><p>&hellip;&hellip;我们打印出了 23，正如预期的那样。</p>
<p>但如果我们写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">vanEck&#39;s</span><span class="o">[</span><span class="mi">10_000</span><span class="o">]</span><span class="p">;</span>    <span class="c1"># Should print: 14</span>
</span></span></code></pre></div><p>好吧，我们确实打印出了14个&hellip;最终。大约一分钟后。 :-(</p>
<p>如果我们想尝试 <code>vanEck's[100_000]</code>，我们就有时间在一个小时外的餐馆里&hellip;&hellip;悠闲地吃午饭。如果我们想尝试 <code>vanEck's[1_000_000]</code>，我们就必须下周再来吃。</p>
<p>所以&hellip;我们设法让我们的解决方案尽可能的简单，但代价是非常糟糕的，完全不可扩展的运行时性能。</p>
<p>而且，当你停下来想一想，它运行得如此糟糕也就不足为奇了。为了生成下一个范埃克数字，我们的代码必须查看（可能）N-1 个早期数字中的每一个，将它们中的每一个与序列中最近的数字进行比较。换句话说，计算一个范埃克的数字需要 <code>O(N)</code> 次操作，所以计算其中的N个数字必须是 <code>O(N²)</code> 次。因此，找到序列中仅有的1万个数需要1分多钟，找到前10万个数需要几个小时，找到前100万个数需要近7天。</p>
<p>很显然，在我们能从无限供应的范埃克数中获得无数好处之前，我们需要找到一种方法来消除代码对象内部的那种重复的 <code>O(N)</code> 搜索。</p>
<p>可喜的是，这并不难。有一种算法上的<a href="https://en.wikipedia.org/wiki/Lorentz_contraction">洛伦兹收缩</a>，我们可以经常应用于这类情况：我们可以通过扩大空间维度来缩小时间维度&hellip;。更简单地说，我们可以用更多的内存来换取额外的速度。</p>
<p>在这种情况下，我们的诀窍是永久地跟踪（在一个静态变量中）序列中每个数字的最近的前例的索引 M。 然后，当我们再次遇到这个数字时，我们可以在我们的变量上执行一次查找，以找到这个数字的最近的先前索引。那么我们要做的就是每次更新我们记忆中的 M 值（因为我们刚刚在后面的索引中又看到了同一个数字：N）。</p>
<p>基于这种方法的 <code>next-vanEck</code> 的子例程是这样的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl">  <span class="c1"># Version 4...</span>
</span></span><span class="line"><span class="cl">  <span class="k">sub</span> <span class="nf">next-vanEck&#39;s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">state</span> <span class="nv">@M</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">my</span> <span class="nv">$N</span> <span class="o">=</span> <span class="nv">@_</span><span class="o">.</span><span class="nb">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">my</span> <span class="nv">$M</span> <span class="o">=</span> <span class="nv">@M</span><span class="o">[</span><span class="nv">@_</span><span class="o">.</span><span class="nb">tail</span><span class="o">]</span> <span class="o">//</span> <span class="nv">$N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nv">@M</span><span class="o">[</span><span class="nv">@_</span><span class="o">.</span><span class="nb">tail</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nv">$N</span> <span class="o">-</span> <span class="nv">$M</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><p><code>@M</code> 数组会跟踪每个前一个值的最近的前一个索引。所以，当我们需要该 M 值来计算下一个数字时，现在我们只需直接向上查找它的位置即可: <code>@M[@_.tail]</code>。</p>
<p>然后我们用当前值的最新位置更新 <code>@M</code> 数组: <code>@M[@_.tail] = $N</code>。</p>
<p>用这个版本的子例程运行序列操作，我们可以在大约15秒内计算出 <code>vanEck's[10_000]</code>，而不是60秒。性能的四倍提升总是令人欣喜的，但我们可以做得更好。</p>
<p>我们只是将前面的整个序列传递进来（作为 <code>@_</code>），这样我们就可以访问最终的值（<code>@_.tail</code>）和它发生时的 N 的当前值（<code>@.end</code>）。但是，我们可以，直接传入那个最终值。而且 N 的值只是在每次调用时递增，所以我们可以在另一个状态变量中琐碎地跟踪它。</p>
<p>这看起来像这样:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Version 5...</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">next-vanEck&#39;s</span> <span class="p">(</span><span class="nv">$Aₙ</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">state</span> <span class="p">(</span><span class="nv">$N</span><span class="o">,</span> <span class="nv">@M</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$N</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$M</span> <span class="o">=</span> <span class="nv">@M</span><span class="o">[</span><span class="nv">$Aₙ</span><span class="o">]</span> <span class="o">//</span> <span class="nv">$N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">@M</span><span class="o">[</span><span class="nv">$Aₙ</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nv">$N</span> <span class="o">-</span> <span class="nv">$M</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>因为子例程现在只接受一个参数 <code>$Aₙ</code>（是的，Raku 允许在标识符中使用下标字母数字）。每次序列操作符产生新的值时，它现在只向代码对象传递到目前为止序列的最终值。</p>
<p>我们还通过每次调用子例程时递增$N来跟踪当前索引。</p>
<p>和以前一样，我们确定M值（现在是：<code>@M[$Aₙ]</code>），然后更新它，然后返回新计算的下一个值。</p>
<p>但是，由于序列运算符不再需要为它产生的每一个新数字将整个 <code>sequence-so-far </code> 传入子例程，因此每次调用 <code>next-vanEck's</code> 的成本明显下降。有了这个版本的子例程，我们计算 <code>vanEck's[10_000]</code> 的速度比之前快了大约100倍，大约0.15秒。或者在大约1.5秒内找到 <code>vanEck's[100_000]</code>。或者在大约15秒内找到 <code>vanEck's[1_000_000]</code>。这不仅比之前的方法快了一大截，现在的复杂度完全不同了：显然是 <code>O(N)</code> 线性时间，而不是 <code>O(N²)</code> 二次元。</p>
<p>然而，这种性能上的巨大改进并不是免费的。<code>@M</code> 数组的长度始终和序列本身一样长，约为 97%，虽然略显稀疏，但它可能只需要约 85% 的空间。尽管如此，这意味着这个解决方案的内存占用量与版本1相比实际上增加了一倍。在大多数情况下，这是一个完全可以接受的权衡：内存相对便宜；时间是无价的。</p>
<p>但我们是否也可以用一条语句来编写这个版本的代码呢？当然，我们可以。</p>
<p>再一次，我们只需将子例程的代码块内联:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">constant</span> <span class="no">vanEck&#39;s</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="p">{</span> <span class="k">state</span> <span class="p">(</span><span class="nv">$N</span><span class="o">,</span> <span class="nv">@M</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                           <span class="nv">$N</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                           <span class="k">my</span> <span class="nv">$M</span> <span class="o">=</span> <span class="nv">@M</span><span class="o">[</span><span class="nv">$^Aₙ</span><span class="o">]</span> <span class="o">//</span> <span class="nv">$N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                           <span class="nv">@M</span><span class="o">[</span><span class="nv">$^Aₙ</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                           <span class="nv">$N</span> <span class="o">-</span> <span class="nv">$M</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                         <span class="p">}</span> <span class="o">...</span> <span class="no">∞</span><span class="p">;</span>
</span></span></code></pre></div><p>当然，如果我一开始就这么说，只是在没有任何警告和解释的情况下突然告诉你，那么你就会很有理由抱怨它的可怕和不可理解，而且（喘气！）与众不同。新概念、新方法、新工具和新语法总是充满挑战。尤其是同时使用这四种方法。</p>
<p>但是，当你了解了乐乐的强大和表现力，那么也许这样的解决方案就没那么可怕了，你开始明白，如何能用很像问题原始描述的东西，用很像问题原始符号的东西，写出看起来很像问题原始描述的代码，因此，对于任何已经熟悉任务域的人来说，其实更容易理解。</p>
<p>而且，因为在 Raku 中总是有不止一种方法，所以把那个最终版本写成还是完全可以的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">constant</span> <span class="no">vanEck&#39;s</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">&amp;next-vanEck&#39;s</span> <span class="o">...</span> <span class="no">∞</span><span class="p">;</span>
</span></span></code></pre></div><p>&hellip;将算法和优化隐藏在该子例程中。当你发现一个更聪明的方法，一个更好的算法，或者一个更有效的洛伦兹权衡时，再在子例程中改变它们。</p>
<p>Perl 和 Raku 都因为他们不折不扣的&quot;不止一种方法&quot;的理念而受到了很多抨击。但是，对我来说，这两种语言的灵活性和透明性意味着，我永远不会被不恰当的概念、低效的算法、不方便的软件工具、或者别人硬生生植入他们的&quot;唯一正确的方法&quot;中的固有性能限制所困扰。</p>
<p>而对我来说，这就使得选择 Raku 的原因&hellip;尽可能的简单。</p>
<p>By <a href="http://blogs.perl.org/users/damian_conway/2019/07/as-simple-as-possiblebut-no-simpler.html">Damian Conway</a></p>


        </div>
    </div>
</article>



                <footer>
                    




<div class="no-text-decoration">
    <div class="jump top"><a href="#" title="Top of this page">⮉</a></div>
    <div class="jump bottom"><a href="#bottom" title="Bottom of this page">⮋</a></div>
</div>


 
    
        <div class="hugotoc no-text-decoration">
            <nav id="TableOfContents"></nav>
            <a href="#" class="back-to-top">Back to top</a>
        </div>
    
    
<script src="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js"></script>

<link rel="preload" href="/js/libs/jquery/3.3.1/jquery.slim.min.min.22ee3db0c0e99fd0fbce3aee19672bd53d25469daf734bd4c165649f6eaf7d7f.js" as="script">

<script type="application/javascript">(function() {
     var $window = $(window);
     if ($window.width() >= 1400) { 
         var $toc = $('#TableOfContents');
         if ($toc.length > 0) {
             function onScroll(){
                 var currentScroll = $window.scrollTop();
                 var h = $('.content h1, .content h2, .content h3, .content h4, .content h5, .content h6, .h-feed h2');
                 var id = "";
                 h.each(function (i, e) {
                     e = $(e);
                     if (e.offset().top - 10 <= currentScroll) {
                         id = e.attr('id');
                     }
                 });
                 var current = $toc.find('a.current');
                 if (current.length == 1 && current.eq(0).attr('href') == '#' + id) return true;

                 current.each(function (i, e) {
                     $(e).removeClass('current').siblings('ul').hide();
                 });
                 $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                     $(e).children('a').addClass('current').siblings('ul').show();
                 });
             }
             $window.on('scroll', onScroll);
             $(document).ready(function() {
                 $toc.find('a').parent('li').find('ul').hide();
                 onScroll();
                 document.getElementsByClassName('hugotoc')[0].style.display = '';
             });}}})();</script>








<div class="backtotop center no-text-decoration">
    <a href="#">back to <span class="top">top</span></a>
</div>


<div class="right">
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>

</div>
<div class="clear-float"></div>



<div class="prev-next-navigator clear-float">
    
        <span class="prev-post left no-text-decoration">
            <a href="https://ohmycloud.github.io/notes/infinite-work-is-lesss-work/" class="nobr">« 工欲善其事必先利其器</a>
        </span>
    
    
        <span class="next-post right no-text-decoration">
            <a href="https://ohmycloud.github.io/posts/2020-06-30-sequence/" class="nobr">数列 »</a>
        </span>
    
</div>


<a id="bottom"></a>









                       







                    <ul class="no-bullets feed right inline">
    
        
        
    
</ul>
<div class="clear-float"></div>

                </footer>
                <hr />
            </div>               

            <footer> 
                

<ul class="social no-text-decoration">
    
</ul>










 
    
    



<p class="generated no-text-decoration">
    Generated using  <a href="https://gitlab.com/kaushalmodi/hugo-theme-refined"><code class="nobr">hugo-theme-refined</code></a> + <span class="nobr">Hugo <a href="https://github.com/gohugoio/hugo/commit/312735366b20d64bd61bff8627f593749f86c964">0.123.7</a></span>
</p>

<p>
    
</p>




<div class="badges no-text-decoration">
    
    

    
</div>




<script type="application/javascript">var nav=responsiveNav("#nav");</script>




<script defer src="/js/libs/fragmentions/wrapper.min.e8c468c89edc4f5dccaa8c720c6b220b3088a16cd7b1e4a1e3345985788260c9.js"></script>









            </footer>
        </div> 
    </body>
</html>
