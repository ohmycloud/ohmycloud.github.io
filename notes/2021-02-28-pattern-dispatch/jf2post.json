{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"content":{"html":"\u003cp\u003e一直以来乐于助人的 \u003ca href=\"https://stackoverflow.com/users/1077672/raiph\"\u003eraiph\u003c/a\u003e 在回答一个关于模式匹配的\u003ca href=\"https://stackoverflow.com/questions/66233465/haskell-like-pattern-matching-in-raku\"\u003e问题\u003c/a\u003e时希望得到 RakuAST，就像在 Haskell 中一样。有人提出用 MMD 来解决这个问题。这样做，得到一个贯穿的默认路径是无解的。由于 dispatch 简单来说就是模式匹配，我们只需要做一些额外的工作。简而言之，dispatcher 得到一个函数列表和一个带参数的列表。第一个接受所有参数的函数获胜。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eclass Hold { has $.key; }\nclass Press { has $.key; }\nclass Err { has $.msg; }\n\nsub else(\u0026amp;code) { \u0026amp;code }\n\nsub match($needle, *@tests) {\n    for @tests.head(*-1) -\u0026gt; \u0026amp;f {\n        if \u0026amp;f.cando(\\($needle)) {\n            return f($needle);\n        }\n    }\n    @tests.tail.();\n}\n\nmatch Hold.new(:key\u0026lt;a\u0026gt;),\n    -\u0026gt; Hold (:$key) { put „holding $key“; },\n    -\u0026gt; Press (:$key) { put „pressing $key“; },\n    -\u0026gt; Err (:$msg) { warn „ERR: $msg“ },\n    else { fail ‚unsopported‘ };\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e方法 \u003ccode\u003e.cando\u003c/code\u003e 需要一个 \u003ca href=\"https://docs.raku.org/type/Capture\"\u003eCapture\u003c/a\u003e 来告诉我们一个 Routine 是否可以用一个给定的参数列表来调用。为了创建这样一个捕获，我们使用字面的 \u003ccode\u003e\\($arguments, $go, $here)\u003c/code\u003e。我们不在最后测试默认值。相反，当没有其他函数匹配时，我们会调用该函数。声明 sub \u003ccode\u003eelse\u003c/code\u003e 只是为了美化。\u003c/p\u003e\n\u003cp\u003e由于我们是在函数式的土地上，我们可以使用 Raku 提供给我们的所有方便的功能。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \u0026amp;key-matcher = \u0026amp;match.assuming(*,[\n        -\u0026gt; Hold (:$key) { put „holding $key“; },\n        -\u0026gt; Press (:$key) { put „pressing $key“; },\n        -\u0026gt; Err (:$msg) { warn „ERR: $msg“ },\n        else { fail ‚unsopported‘ };\n]);\n\nsub key-source {\n    gather loop {\n        sleep 1;\n        take (Hold.new(:key\u0026lt;a\u0026gt;), Press.new(:key\u0026lt;b\u0026gt;), Err.new(:msg\u0026lt;WELP!\u0026gt;), 'unsupported').pick;\n    }\n}\n\n.\u0026amp;key-matcher for key-source;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们要帮助 \u003ccode\u003e.assuming\u003c/code\u003e 有点理解 slurpies，把函数列表放在一个显式 Array 中。\u003c/p\u003e\n\u003cp\u003e总有一种函数式的方法来解决一个问题。有时我们甚至可以从中得到一个整齐的语法。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://gfldex.wordpress.com/2021/02/24/pattern-dispatch/\"\u003ehttps://gfldex.wordpress.com/2021/02/24/pattern-dispatch/\u003c/a\u003e\u003c/p\u003e\n","text":"一直以来乐于助人的 raiph 在回答一个关于模式匹配的问题时希望得到 RakuAST，就像在 Haskell 中一样。有人提出用 MMD 来解决这个问题。这样做，得到一个贯穿的默认路径是无解的。由于 dispatch 简单来说就是模式匹配，我们只需要做一些额外的工作。简而言之，dispatcher 得到一个函数列表和一个带参数的列表。第一个接受所有参数的函数获胜。\nclass Hold { has $.key; } class Press { has $.key; } class Err { has $.msg; } sub else(\u0026amp;code) { \u0026amp;code } sub match($needle, *@tests) { for @tests.head(*-1) -\u0026gt; \u0026amp;f { if \u0026amp;f.cando(\\($needle)) { return f($needle); } } @tests.tail.(); } match Hold.new(:key\u0026lt;a\u0026gt;), -\u0026gt; Hold (:$key) { put „holding $key“; }, -\u0026gt; Press (:$key) { put „pressing $key“; }, -\u0026gt; Err (:$msg) { warn „ERR: $msg“ }, else { fail ‚unsopported‘ }; 方法 .cando 需要一个 Capture 来告诉我们一个 Routine 是否可以用一个给定的参数列表来调用。为了创建这样一个捕获，我们使用字面的 \\($arguments, $go, $here)。我们不在最后测试默认值。相反，当没有其他函数匹配时，我们会调用该函数。声明 sub else 只是为了美化。\n由于我们是在函数式的土地上，我们可以使用 Raku 提供给我们的所有方便的功能。\nmy \u0026amp;key-matcher = \u0026amp;match.assuming(*,[ -\u0026gt; Hold (:$key) { put „holding $key“; }, -\u0026gt; Press (:$key) { put „pressing $key“; }, -\u0026gt; Err (:$msg) { warn „ERR: $msg“ }, else { fail ‚unsopported‘ }; ]); sub key-source { gather loop { sleep 1; take (Hold.new(:key\u0026lt;a\u0026gt;), Press.new(:key\u0026lt;b\u0026gt;), Err.new(:msg\u0026lt;WELP!\u0026gt;), 'unsupported').pick; } } .\u0026amp;key-matcher for key-source; 我们要帮助 .assuming 有点理解 slurpies，把函数列表放在一个显式 Array 中。\n总有一种函数式的方法来解决一个问题。有时我们甚至可以从中得到一个整齐的语法。\n原文链接: https://gfldex.wordpress.com/2021/02/24/pattern-dispatch/\n"},"name":"模式分派","published":"2021-02-28T00:00:00+08:00","summary":"Pattern Dispatch","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/"}