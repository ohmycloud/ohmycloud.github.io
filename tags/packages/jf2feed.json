{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"children":[{"content":{"html":"\u003cp\u003eDart 生态系统使用\u003ca href=\"https://dart.dev/guides/packages\"\u003e包\u003c/a\u003e来共享软件，如库和工具。本页告诉你如何创建一个包，重点是最常见的一种包，\u003ca href=\"https://dart.dev/tools/pub/glossary#library-package\"\u003e库包\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"是什么造就了一个库包\"\u003e是什么造就了一个库包\u003c/h2\u003e\n\u003cp\u003e下图是最简单的库包的布局:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://dart.dev/assets/libraries/simple-lib2-81ebdc20fdb53d3abbc4364956141eb0f6f8f275d1636064fc3e1db959b93c1a.png\" alt=\"img\"\u003e\u003c/p\u003e\n\u003cp\u003e一个库的最低要求是\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003epubspec 文件\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e库的 \u003ccode\u003epubspec.yaml\u003c/code\u003e 文件和应用程序包的文件是一样的-没有特别的名称来表示这个包是一个库。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003elib 目录\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e正如你所期望的那样，库代码存在于 \u003ccode\u003elib\u003c/code\u003e 目录下，对其他包是公开的。你可以根据需要在 \u003ccode\u003elib\u003c/code\u003e 下创建任何层次结构。按照惯例，实现代码被放在 \u003ccode\u003elib/src\u003c/code\u003e 下。\u003ccode\u003elib/src\u003c/code\u003e 下的代码被认为是私有的；其他包不应该需要导入 \u003ccode\u003esrc/...\u003c/code\u003e。要使 \u003ccode\u003elib/src\u003c/code\u003e 下的 API 公开，您可以从直接位于 \u003ccode\u003elib\u003c/code\u003e 下的文件导出 \u003ccode\u003elib/src\u003c/code\u003e 文件。\u003c/p\u003e\n\u003cp\u003e注意：当没有指定 \u003ccode\u003elibrary\u003c/code\u003e 指令时，会根据每个库的路径和文件名为其生成一个唯一的标签。因此，我们建议您从代码中省略 \u003ccode\u003elibrary\u003c/code\u003e 指令，除非您计划\u003ca href=\"https://dart.dev/guides/libraries/create-library-packages#documenting-a-library\"\u003e生成库级文档\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"组织一个库包\"\u003e组织一个库包\u003c/h2\u003e\n\u003cp\u003e当你创建小的、单独的库（称为迷你库）时，库包的维护、扩展和测试是最容易的。在大多数情况下，每个类都应该在自己的迷你库中，除非你有两个类是紧密耦合的情况。\u003c/p\u003e\n\u003cp\u003e注意：你可能听说过 \u003ccode\u003epart\u003c/code\u003e 指令，它允许你将一个库分割成多个 Dart 文件。我们建议你避免使用 \u003ccode\u003epart\u003c/code\u003e 指令，而是创建迷你库。\u003c/p\u003e\n\u003cp\u003e直接在 \u003ccode\u003elib\u003c/code\u003e 下创建一个\u0026quot;主\u0026quot;库文件，\u003ccode\u003elib/\u0026lt;package-name\u0026gt;.dart\u003c/code\u003e，导出所有的公共 API。这样用户就可以通过导入一个文件来获得一个库的所有功能。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003elib\u003c/code\u003e 目录也可能包含其他可导入的、非src的库。例如，也许你的主库可以跨平台使用，但是你创建了单独的库，这些库依赖于 \u003ccode\u003edart:io\u003c/code\u003e 或者 \u003ccode\u003edart:html\u003c/code\u003e。有些包有单独的库，这些库是要用前缀导入的，而主库不是。\u003c/p\u003e\n\u003cp\u003e让我们来看看一个现实世界中的库包的组织： shelf。\u003ca href=\"https://github.com/dart-lang/shelf\"\u003eshelf\u003c/a\u003e 包提供了一种使用 Dart 创建 web 服务器的简单方法，它的布局结构是 Dart 库包常用的:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://dart.dev/assets/libraries/shelf-02e5fd43b660fcef7dbe6a883c40159e0379c8ee2088288ca60ed7dc8781bafd.png\" alt=\"img\"\u003e\u003c/p\u003e\n\u003cp\u003e直接在 \u003ccode\u003elib\u003c/code\u003e 下，主库文件 \u003ccode\u003eshelf.dart\u003c/code\u003e 从 \u003ccode\u003elib/src\u003c/code\u003e 导出几个文件:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;src/cascade.dart\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;src/handler.dart\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;src/handlers/logger.dart\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;src/hijack_exception.dart\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;src/middleware.dart\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;src/pipeline.dart\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;src/request.dart\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;src/response.dart\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;src/server.dart\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;src/server_handler.dart\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eshelf 包还包含一个迷你库： \u003ccode\u003eshelf_io\u003c/code\u003e。这个适配器处理来自 \u003ccode\u003edart:io\u003c/code\u003e 的 \u003ccode\u003eHttpRequest\u003c/code\u003e 对象。\u003c/p\u003e\n\u003cp\u003e对网络应用的提示: 为了在使用 \u003ca href=\"https://dart.dev/tools/dartdevc\"\u003edartdevc\u003c/a\u003e 开发时获得最佳性能，请将\u003ca href=\"https://dart.dev/tools/pub/package-layout#implementation-files\"\u003e实现文件\u003c/a\u003e放在 \u003ccode\u003e/lib/src\u003c/code\u003e 下，而不是放在 \u003ccode\u003e/lib\u003c/code\u003e 下的其他地方。同时，避免导入 \u003ccode\u003epackage:package_name/src/...\u003c/code\u003e 的文件。\u003c/p\u003e\n\u003ch2 id=\"导入库文件\"\u003e导入库文件\u003c/h2\u003e\n\u003cp\u003e当从其他包中导入一个库文件时，使用 \u003ccode\u003epackage:\u003c/code\u003e 指令来指定该文件的 URI。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"k\"\u003eimport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;package:utilities/utilities.dart\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e当从自己的包中导入一个库文件时，当两个文件都在 lib 内，或者两个文件都在 lib 外时，使用相对路径。使用 \u003ccode\u003e:package\u003c/code\u003e 当导入的文件在 lib 内，而导入者在 lib 外时。\u003c/p\u003e\n\u003cp\u003e下图显示了如何从 lib 和 web 中导入 \u003ccode\u003elib/foo/a.dart\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://dart.dev/assets/libraries/import-lib-rules-e1777e235dd56aa23f770babcccedb6a12be80af2c3e63065640b889d78be595.png\" alt=\"img\"\u003e\u003c/p\u003e\n\u003ch2 id=\"有条件地导入和导出库文件\"\u003e有条件地导入和导出库文件\u003c/h2\u003e\n\u003cp\u003e如果你的库支持多个平台，那么你可能需要有条件地导入或导出库文件。一个常见的用例是一个同时支持 web 和原生平台的库。\u003c/p\u003e\n\u003cp\u003e要有条件的导入或导出，你需要检查 \u003ccode\u003edart:*\u003c/code\u003e 库的存在。下面是一个有条件导出代码的例子，它检查 \u003ccode\u003edart:io\u003c/code\u003e 和 \u003ccode\u003edart:html\u003c/code\u003e 的存在:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;src/hw_none.dart\u0026#39;\u003c/span\u003e \u003cspan class=\"err\"\u003e//\u003c/span\u003e \u003cspan class=\"n\"\u003eStub\u003c/span\u003e \u003cspan class=\"n\"\u003eimplementation\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eif\u003c/span\u003e \u003cspan class=\"err\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edart\u003c/span\u003e\u003cspan class=\"err\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elibrary\u003c/span\u003e\u003cspan class=\"err\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eio\u003c/span\u003e\u003cspan class=\"err\"\u003e)\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;src/hw_io.dart\u0026#39;\u003c/span\u003e \u003cspan class=\"err\"\u003e//\u003c/span\u003e \u003cspan class=\"n\"\u003edart\u003c/span\u003e\u003cspan class=\"err\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003eio\u003c/span\u003e \u003cspan class=\"n\"\u003eimplementation\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eif\u003c/span\u003e \u003cspan class=\"err\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edart\u003c/span\u003e\u003cspan class=\"err\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elibrary\u003c/span\u003e\u003cspan class=\"err\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ehtml\u003c/span\u003e\u003cspan class=\"err\"\u003e)\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;src/hw_html.dart\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// dart:html implementation\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e下面是这段代码的作用。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在一个可以使用 \u003ccode\u003edart:io\u003c/code\u003e 的应用程序中(例如，一个命令行应用程序)，导出 \u003ccode\u003esrc/hw_io.dart\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e在一个可以使用 \u003ccode\u003edart:html\u003c/code\u003e 的应用程序中(一个 web 应用程序)，导出 \u003ccode\u003esrc/hw_html.dart\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e否则，导出 \u003ccode\u003esrc/hw_none.dart\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e要有条件地导入一个文件，使用与上面相同的代码，但将 \u003ccode\u003eexporrt\u003c/code\u003e 改为 \u003ccode\u003eimport\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e注意：有条件的导入或导出只检查库在当前平台上是否可用，而不是检查是否实际导入或使用。\u003c/p\u003e\n\u003cp\u003e所有有条件导出的库都必须实现相同的 API。例如，这里是 \u003ccode\u003edart:io\u003c/code\u003e 的实现:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"k\"\u003eimport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;dart:io\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003ealarm\u003c/span\u003e\u003cspan class=\"p\"\u003e([\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e \u003cspan class=\"n\"\u003etext\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"n\"\u003estderr\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewriteln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etext\u003c/span\u003e \u003cspan class=\"o\"\u003e??\u003c/span\u003e \u003cspan class=\"n\"\u003emessage\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003eString\u003c/span\u003e \u003cspan class=\"kd\"\u003eget\u003c/span\u003e \u003cspan class=\"n\"\u003emessage\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;Hello World from the VM!\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这里是默认的实现，它是一个抛出 UnsupportedErrors 的 stub。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003ealarm\u003c/span\u003e\u003cspan class=\"p\"\u003e([\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e \u003cspan class=\"n\"\u003etext\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003ethrow\u003c/span\u003e \u003cspan class=\"n\"\u003eUnsupportedError\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;hw_none alarm\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003eString\u003c/span\u003e \u003cspan class=\"kd\"\u003eget\u003c/span\u003e \u003cspan class=\"n\"\u003emessage\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003ethrow\u003c/span\u003e \u003cspan class=\"n\"\u003eUnsupportedError\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;hw_none message\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在任何平台上，你都可以导入有条件导出代码的库。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"k\"\u003eimport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;package:hw_mp/hw_mp.dart\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"n\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emessage\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"提供补充文件\"\u003e提供补充文件\u003c/h2\u003e\n\u003cp\u003e一个设计良好的库包是很容易测试的。我们建议你使用 \u003ca href=\"https://github.com/dart-lang/test\"\u003etest\u003c/a\u003e 包来编写测试，将测试代码放在测试包顶部的 \u003ccode\u003etest\u003c/code\u003e 目录中。\u003c/p\u003e\n\u003cp\u003e如果你创建了任何旨在供公众使用的命令行工具，请将这些工具放在 \u003ccode\u003ebin\u003c/code\u003e 目录下，这是公共的。启用从命令行运行工具，使用 \u003ca href=\"https://dart.dev/tools/pub/cmd/pub-global#activating-a-package\"\u003epub global activate\u003c/a\u003e。将工具列在 pubspec 的\u003ca href=\"https://dart.dev/tools/pub/pubspec#executables\"\u003e可执行文件部分\u003c/a\u003e，允许用户直接运行它，而无需调用 \u003ca href=\"https://dart.dev/tools/pub/cmd/pub-global#running-a-script-using-pub-global-run\"\u003epub global run\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e如果你包含了一个如何使用你的库的例子，这将会很有帮助。这将被放入软件包顶部的 \u003ccode\u003eexample\u003c/code\u003e 目录中。\u003c/p\u003e\n\u003cp\u003e你在开发过程中创建的任何工具或可执行文件，如果不是公开使用的，都会进入 \u003ccode\u003etool\u003c/code\u003e 目录。\u003c/p\u003e\n\u003cp\u003e如果你把你的库发布到 pub.dev 站点，其他需要的文件，如 \u003ccode\u003eREADME.md\u003c/code\u003e 和 \u003ccode\u003eCHANGELOG.md\u003c/code\u003e，将在\u003ca href=\"https://dart.dev/tools/pub/publishing\"\u003e发布软件包\u003c/a\u003e中描述。有关如何组织包目录的更多信息，请参见 \u003ca href=\"https://dart.dev/tools/pub/package-layout\"\u003epub 包布局惯例\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"编写库文档\"\u003e编写库文档\u003c/h2\u003e\n\u003cp\u003e你可以使用 \u003ca href=\"https://github.com/dart-lang/dartdoc#dartdoc\"\u003edartdoc\u003c/a\u003e 工具为你的库生成 API 文档。Dartdoc 解析源码寻找\u003ca href=\"https://dart.dev/guides/language/effective-dart/documentation#doc-comments\"\u003e文档注释\u003c/a\u003e，其中使用了 \u003ccode\u003e///\u003c/code\u003e 语法:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"c1\"\u003e/// The event handler responsible for updating the badge in the UI.\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eupdateBadge\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e关于生成文档的例子，请看 \u003ca href=\"https://pub.dev/documentation/shelf/latest\"\u003eshelf 文档\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e注意：要在生成的文档中包含任何库级文档，你必须指定 \u003ccode\u003elibrary\u003c/code\u003e 指令。请参阅 \u003ca href=\"https://github.com/dart-lang/dartdoc/issues/1082\"\u003e问题 1082\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"分发一个开源库\"\u003e分发一个开源库\u003c/h2\u003e\n\u003cp\u003e如果你的库是开源的，我们建议在 \u003ca href=\"https://pub.dev/\"\u003epub.dev\u003c/a\u003e 站点上分享它。要发布或更新库，请使用 \u003ca href=\"https://dart.dev/tools/pub/cmd/pub-lish\"\u003epub publish\u003c/a\u003e，它可以上传您的包并创建或更新其页面。例如，请看 \u003ca href=\"https://pub.dev/packages/shelf\"\u003eshelf 包\u003c/a\u003e的页面。有关如何准备发布软件包的详细信息，请参见\u003ca href=\"https://dart.dev/tools/pub/publishing\"\u003e发布包\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003epub.dev 站点不仅托管您的软件包，而且还生成和托管您软件包的 API 参考文档。最新生成的文档的链接在软件包的 \u003cstrong\u003eAbout\u003c/strong\u003e 框中；例如，请看 shelf 包的 \u003ca href=\"https://pub.dev/documentation/shelf\"\u003eAPI 文档\u003c/a\u003e。到以前版本的文档的链接在软件包页面的版本选项卡中。\u003c/p\u003e\n\u003cp\u003e要确保你的软件包的 API 文档在 pub.dev 网站上看起来不错，请按照以下步骤进行。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在发布你的软件包之前，运行 \u003ca href=\"https://github.com/dart-lang/dartdoc#dartdoc\"\u003edartdoc\u003c/a\u003e 工具，以确保你的 docs 成功生成，并且看起来符合预期。\u003c/li\u003e\n\u003cli\u003e发布软件包后，检查 \u003cstrong\u003eVersions\u003c/strong\u003e 选项卡以确保文档成功生成。\u003c/li\u003e\n\u003cli\u003e如果文档根本没有生成，点击 \u003cstrong\u003eVerrsions\u003c/strong\u003e 选项卡中的 \u003cstrong\u003efailed\u003c/strong\u003e，查看 dartdoc 的输出。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"资源\"\u003e资源\u003c/h2\u003e\n\u003cp\u003e使用以下资源了解更多关于库包的信息。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/guides/language/language-tour\"\u003e语言之旅\u003c/a\u003e中的\u003ca href=\"https://dart.dev/guides/language/language-tour#libraries-and-visibility\"\u003e库和可见性\u003c/a\u003e包括使用库文件。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/guides/packages\"\u003e包\u003c/a\u003e文档很有用，特别是\u003ca href=\"https://dart.dev/tools/pub/package-layout\"\u003e包的布局约定\u003c/a\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/guides/libraries/private-files\"\u003e不应提交的内容\u003c/a\u003e涵盖了哪些不应该被检查到源代码库中。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/dart-lang\"\u003edart-lang\u003c/a\u003e 组织下的较新的库包倾向于展示最佳实践。可以考虑研究这些例子：\u003ca href=\"https://github.com/dart-lang/dart_style\"\u003edart_style\u003c/a\u003e、\u003ca href=\"https://github.com/dart-lang/path\"\u003epath\u003c/a\u003e、\u003ca href=\"https://github.com/dart-lang/shelf\"\u003eshelf\u003c/a\u003e、\u003ca href=\"https://github.com/dart-lang/source_gen\"\u003esource_gen\u003c/a\u003e 和 \u003ca href=\"https://github.com/dart-lang/test\"\u003etest\u003c/a\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n","text":"Dart 生态系统使用包来共享软件，如库和工具。本页告诉你如何创建一个包，重点是最常见的一种包，库包。\n是什么造就了一个库包 下图是最简单的库包的布局:\n一个库的最低要求是\npubspec 文件\n库的 pubspec.yaml 文件和应用程序包的文件是一样的-没有特别的名称来表示这个包是一个库。\nlib 目录\n正如你所期望的那样，库代码存在于 lib 目录下，对其他包是公开的。你可以根据需要在 lib 下创建任何层次结构。按照惯例，实现代码被放在 lib/src 下。lib/src 下的代码被认为是私有的；其他包不应该需要导入 src/...。要使 lib/src 下的 API 公开，您可以从直接位于 lib 下的文件导出 lib/src 文件。\n注意：当没有指定 library 指令时，会根据每个库的路径和文件名为其生成一个唯一的标签。因此，我们建议您从代码中省略 library 指令，除非您计划生成库级文档。\n组织一个库包 当你创建小的、单独的库（称为迷你库）时，库包的维护、扩展和测试是最容易的。在大多数情况下，每个类都应该在自己的迷你库中，除非你有两个类是紧密耦合的情况。\n注意：你可能听说过 part 指令，它允许你将一个库分割成多个 Dart 文件。我们建议你避免使用 part 指令，而是创建迷你库。\n直接在 lib 下创建一个\u0026quot;主\u0026quot;库文件，lib/\u0026lt;package-name\u0026gt;.dart，导出所有的公共 API。这样用户就可以通过导入一个文件来获得一个库的所有功能。\nlib 目录也可能包含其他可导入的、非src的库。例如，也许你的主库可以跨平台使用，但是你创建了单独的库，这些库依赖于 dart:io 或者 dart:html。有些包有单独的库，这些库是要用前缀导入的，而主库不是。\n让我们来看看一个现实世界中的库包的组织： shelf。shelf 包提供了一种使用 Dart 创建 web 服务器的简单方法，它的布局结构是 Dart 库包常用的:\n直接在 lib 下，主库文件 shelf.dart 从 lib/src 导出几个文件:\nexport \u0026#39;src/cascade.dart\u0026#39;; export \u0026#39;src/handler.dart\u0026#39;; export \u0026#39;src/handlers/logger.dart\u0026#39;; export \u0026#39;src/hijack_exception.dart\u0026#39;; export \u0026#39;src/middleware.dart\u0026#39;; export \u0026#39;src/pipeline.dart\u0026#39;; export \u0026#39;src/request.dart\u0026#39;; export \u0026#39;src/response.dart\u0026#39;; export \u0026#39;src/server.dart\u0026#39;; export \u0026#39;src/server_handler.dart\u0026#39;; shelf 包还包含一个迷你库： shelf_io。这个适配器处理来自 dart:io 的 HttpRequest 对象。\n对网络应用的提示: 为了在使用 dartdevc 开发时获得最佳性能，请将实现文件放在 /lib/src 下，而不是放在 /lib 下的其他地方。同时，避免导入 package:package_name/src/... 的文件。\n导入库文件 当从其他包中导入一个库文件时，使用 package: 指令来指定该文件的 URI。\nimport \u0026#39;package:utilities/utilities.dart\u0026#39;; 当从自己的包中导入一个库文件时，当两个文件都在 lib 内，或者两个文件都在 lib 外时，使用相对路径。使用 :package 当导入的文件在 lib 内，而导入者在 lib 外时。\n下图显示了如何从 lib 和 web 中导入 lib/foo/a.dart。\n有条件地导入和导出库文件 如果你的库支持多个平台，那么你可能需要有条件地导入或导出库文件。一个常见的用例是一个同时支持 web 和原生平台的库。\n要有条件的导入或导出，你需要检查 dart:* 库的存在。下面是一个有条件导出代码的例子，它检查 dart:io 和 dart:html 的存在:\nexport \u0026#39;src/hw_none.dart\u0026#39; // Stub implementation if (dart.library.io) \u0026#39;src/hw_io.dart\u0026#39; // dart:io implementation if (dart.library.html) \u0026#39;src/hw_html.dart\u0026#39;; // dart:html implementation 下面是这段代码的作用。\n 在一个可以使用 dart:io 的应用程序中(例如，一个命令行应用程序)，导出 src/hw_io.dart 在一个可以使用 dart:html 的应用程序中(一个 web 应用程序)，导出 src/hw_html.dart 否则，导出 src/hw_none.dart  要有条件地导入一个文件，使用与上面相同的代码，但将 exporrt 改为 import。\n注意：有条件的导入或导出只检查库在当前平台上是否可用，而不是检查是否实际导入或使用。\n所有有条件导出的库都必须实现相同的 API。例如，这里是 dart:io 的实现:\nimport \u0026#39;dart:io\u0026#39;; void alarm([String text]) { stderr.writeln(text ?? message); } String get message =\u0026gt; \u0026#39;Hello World from the VM!\u0026#39;; 这里是默认的实现，它是一个抛出 UnsupportedErrors 的 stub。\nvoid alarm([String text]) =\u0026gt; throw UnsupportedError(\u0026#39;hw_none alarm\u0026#39;); String get message =\u0026gt; throw UnsupportedError(\u0026#39;hw_none message\u0026#39;); 在任何平台上，你都可以导入有条件导出代码的库。\nimport \u0026#39;package:hw_mp/hw_mp.dart\u0026#39;; void main() { print(message); } 提供补充文件 一个设计良好的库包是很容易测试的。我们建议你使用 test 包来编写测试，将测试代码放在测试包顶部的 test 目录中。\n如果你创建了任何旨在供公众使用的命令行工具，请将这些工具放在 bin 目录下，这是公共的。启用从命令行运行工具，使用 pub global activate。将工具列在 pubspec 的可执行文件部分，允许用户直接运行它，而无需调用 pub global run。\n如果你包含了一个如何使用你的库的例子，这将会很有帮助。这将被放入软件包顶部的 example 目录中。\n你在开发过程中创建的任何工具或可执行文件，如果不是公开使用的，都会进入 tool 目录。\n如果你把你的库发布到 pub.dev 站点，其他需要的文件，如 README.md 和 CHANGELOG.md，将在发布软件包中描述。有关如何组织包目录的更多信息，请参见 pub 包布局惯例。\n编写库文档 你可以使用 dartdoc 工具为你的库生成 API 文档。Dartdoc 解析源码寻找文档注释，其中使用了 /// 语法:\n/// The event handler responsible for updating the badge in the UI. void updateBadge() { ... } 关于生成文档的例子，请看 shelf 文档。\n注意：要在生成的文档中包含任何库级文档，你必须指定 library 指令。请参阅 问题 1082。\n分发一个开源库 如果你的库是开源的，我们建议在 pub.dev 站点上分享它。要发布或更新库，请使用 pub publish，它可以上传您的包并创建或更新其页面。例如，请看 shelf 包的页面。有关如何准备发布软件包的详细信息，请参见发布包。\npub.dev 站点不仅托管您的软件包，而且还生成和托管您软件包的 API 参考文档。最新生成的文档的链接在软件包的 About 框中；例如，请看 shelf 包的 API 文档。到以前版本的文档的链接在软件包页面的版本选项卡中。\n要确保你的软件包的 API 文档在 pub.dev 网站上看起来不错，请按照以下步骤进行。\n 在发布你的软件包之前，运行 dartdoc 工具，以确保你的 docs 成功生成，并且看起来符合预期。 发布软件包后，检查 Versions 选项卡以确保文档成功生成。 如果文档根本没有生成，点击 Verrsions 选项卡中的 failed，查看 dartdoc 的输出。  资源 使用以下资源了解更多关于库包的信息。\n 语言之旅中的库和可见性包括使用库文件。 包文档很有用，特别是包的布局约定。 不应提交的内容涵盖了哪些不应该被检查到源代码库中。 dart-lang 组织下的较新的库包倾向于展示最佳实践。可以考虑研究这些例子：dart_style、path、shelf、source_gen 和 test。  "},"name":"创建包","published":"2020-06-30T00:00:00Z","summary":"Creating packages","type":"entry","url":"https://ohmyweekly.github.io/notes/creating-packages/"},{"content":{"html":"\u003cp\u003e\u003ca href=\"https://dart.dev/guides/packages\"\u003epub 软件包管理器\u003c/a\u003e不仅仅是用来使用别人的软件包。它还允许你与世界分享你的软件包。如果您有一个有用的项目，并且您希望其他人能够使用它，请使用 \u003ccode\u003epub publish\u003c/code\u003e 命令。\u003c/p\u003e\n\u003cp\u003e注意: 如果要发布到 pub.dev 以外的其他位置，或者要防止在任何地方发布，请使用 \u003ca href=\"https://dart.dev/tools/pub/pubspec\"\u003epubspec\u003c/a\u003e 中定义的  \u003ccode\u003epublish_to\u003c/code\u003e 字段。\u003c/p\u003e\n\u003ch2 id=\"发布是永远的\"\u003e发布是永远的\u003c/h2\u003e\n\u003cp\u003e请记住，发布是永远的。只要你发布你的包，用户就可以依赖它。一旦他们开始这样做，删除包就会破坏他们的包。为了避免这种情况，\u003ca href=\"https://pub.dev/policy\"\u003epub.dev 政策\u003c/a\u003e不允许取消发布软件包，除非是极少数情况。\u003c/p\u003e\n\u003cp\u003e你可以随时上传你的包的新版本，但旧的包将继续为那些还没有准备好升级的用户提供服务。\u003c/p\u003e\n\u003cp\u003e对于已经发布的包，如果不再相关或正在维护，你可以\u003ca href=\"https://dart.dev/tools/pub/publishing#discontinue\"\u003e将其标记为停止发布\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"准备发布\"\u003e准备发布\u003c/h2\u003e\n\u003cp\u003e当发布一个软件包时，遵循 \u003ca href=\"https://dart.dev/tools/pub/pubspec\"\u003epubspec 格式\u003c/a\u003e和\u003ca href=\"https://dart.dev/tools/pub/package-layout\"\u003e包布局惯例\u003c/a\u003e是很重要的。其中有些是必须的，以便其他人能够使用你的软件包。另一些则是为了帮助用户更容易理解和使用您的软件包而提出的建议。在这两种情况下，pub 都会尝试帮助你，指出哪些改变会帮助你的软件包在 Dart 生态系统中发挥得更好。上传包有一些额外的要求:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e你必须包含一个包含\u003ca href=\"https://opensource.org/\"\u003e开源许可证\u003c/a\u003e的 \u003ccode\u003eLICENSE\u003c/code\u003e 文件。我们推荐 \u003ca href=\"https://opensource.org/licenses/BSD-3-Clause\"\u003eBSD 许可证\u003c/a\u003e，这是 Dart 自己使用的。你也必须有合法的权利来重新发布你上传的任何东西作为你的包的一部分。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e你的软件包在经过 gzip 压缩后必须小于 10 MB。如果太大，可以考虑将其分割成多个包，或者减少包含的资源或例子的数量。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e你的包应该只依赖托管的依赖项(来自默认的 pub 包服务器)和 SDK 依赖项(\u003ccode\u003esdk: flutter\u003c/code\u003e)。这些限制确保了你的包的依赖性不会在未来变得不可用。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e您必须有一个 \u003ca href=\"https://support.google.com/accounts/answer/27441\"\u003eGoogle 帐户\u003c/a\u003e，pub 用来管理包的上传权限。您的 Google 账户可以与 Gmail 地址或任何其他电子邮件地址关联。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e注意：除非您使用\u003ca href=\"https://dart.dev/tools/pub/verified-publishers\"\u003e已验证的发布者\u003c/a\u003e发布，否则 pub.dev 会显示与您的 Google 帐户关联的电子邮件地址。\u003c/p\u003e\n\u003ch3 id=\"重要文件\"\u003e重要文件\u003c/h3\u003e\n\u003cp\u003ePub 使用一些文件的内容为你的包创建一个页面，地址是 \u003ccode\u003epub.dev/packages/\u0026lt;your_package\u0026gt;\u003c/code\u003e。以下是影响你的包的页面外观的文件。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eREADME.md: \u003ccode\u003eREADME.md\u003c/code\u003e 文件是你的包页面中的主要内容。该文件的内容以 \u003ca href=\"https://pub.dev/packages/markdown\"\u003eMarkdown\u003c/a\u003e 的形式呈现。\u003c/li\u003e\n\u003cli\u003eCHANGELOG.md：\u003ccode\u003eCHANGELOG.md\u003c/code\u003e 文件是你的包页面中的主要内容。你的包的 \u003ccode\u003eCHANGELOG.md\u003c/code\u003e 文件，如果找到的话，也会在你的包页面的一个标签中显示，这样开发者就可以直接从 pub.dev 中读取它。该文件的内容会以 \u003ca href=\"https://pub.dev/packages/markdown\"\u003eMarkdown\u003c/a\u003e 的形式呈现。\u003c/li\u003e\n\u003cli\u003epubspec: 你的包的 \u003ccode\u003epubspec.yaml\u003c/code\u003e 文件用来在你的包的页面右侧填写关于你的包的详细信息，比如它的描述、主页等。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"使用经过验证的发布者的优势\"\u003e使用经过验证的发布者的优势\u003c/h3\u003e\n\u003cp\u003e您可以使用已验证的发布者（推荐）或独立的谷歌账户发布软件包。使用经过验证的发布者有以下优势。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e您的包的消费者知道发布者的域名已经被验证。\u003c/li\u003e\n\u003cli\u003e您可以避免让 pub.dev 显示您的个人电子邮件地址。取而代之的是，pub.dev会显示发布者的域名和联系地址。\u003c/li\u003e\n\u003cli\u003e经验证的发布者徽章 pub.dev 经验证的发布者标识会在搜索页面和单个软件包页面上显示在您的软件包名称旁边。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"创建一个验证过的发布者\"\u003e创建一个验证过的发布者\u003c/h3\u003e\n\u003cp\u003e要创建一个已验证的发布者，请按照以下步骤进行。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e进入 \u003ca href=\"https://pub.dev/\"\u003epub.dev\u003c/a\u003e。\u003c/li\u003e\n\u003cli\u003e使用 Google 账户登录 pub.dev。\u003c/li\u003e\n\u003cli\u003e在右上角的用户菜单中，选择创建发布者。\u003c/li\u003e\n\u003cli\u003e输入您要与您的发布者相关联的域名(例如，\u003ccode\u003edart.dev\u003c/code\u003e)，然后单击\u0026quot;创建发布者\u0026quot;。\u003c/li\u003e\n\u003cli\u003e在确认对话框中，选择\u0026quot;确定\u0026quot;。\u003c/li\u003e\n\u003cli\u003e如果提示，完成验证流程，这将打开 \u003ca href=\"https://search.google.com/search-console/about\"\u003eGoogle 搜索控制台\u003c/a\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e在添加 DNS 记录时，可能需要几个小时后，搜索控制台才会反映出变化。\u003c/li\u003e\n\u003cli\u003e验证流程完成后，返回步骤4。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"发布你的包\"\u003e发布你的包\u003c/h2\u003e\n\u003cp\u003e使用 \u003ca href=\"https://dart.dev/tools/pub/cmd/pub-lish\"\u003epub publish\u003c/a\u003e 命令来首次发布您的软件包，或将其更新到新版本。\u003c/p\u003e\n\u003ch3 id=\"执行-dry-run\"\u003e执行 dry run\u003c/h3\u003e\n\u003cp\u003e为了测试 \u003ccode\u003epub publish\u003c/code\u003e 的工作情况，你可以进行一次 dry run:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e$ pub publish --dry-run\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ePub 会确保你的软件包遵循 \u003ca href=\"https://dart.dev/tools/pub/pubspec\"\u003epubspec 格式\u003c/a\u003e和\u003ca href=\"https://dart.dev/tools/pub/package-layout\"\u003e包布局约定\u003c/a\u003e，然后将你的软件包上传到 \u003ca href=\"https://pub.dev/\"\u003epub.dev\u003c/a\u003e。Pub 还会向你展示它打算发布的所有文件。下面是一个发布名为 \u003ccode\u003etransmogrify\u003c/code\u003e 的软件包的例子:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan class=\"l\"\u003ePublishing transmogrify 1.0.0\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"l\"\u003e.gitignore\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"l\"\u003eCHANGELOG.md\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"l\"\u003eREADME.md\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"l\"\u003elib\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"l\"\u003etransmogrify.dart\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"l\"\u003esrc\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"l\"\u003etransmogrifier.dart\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"l\"\u003etransmogrification.dart\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"l\"\u003epubspec.yaml\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"l\"\u003etest\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"l\"\u003etransmogrify_test.dart\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"l\"\u003ePackage has 0 warnings.\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"发布\"\u003e发布\u003c/h3\u003e\n\u003cp\u003e当你准备好发布你的包时，请删除 \u003ccode\u003e--dry-run\u003c/code\u003e 参数:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e$ pub publish\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e注意: pub 命令目前不支持直接将新软件包发布到已验证的发布者。作为一个临时的变通方法，可以将新的软件包发布到Google账户，然后将包\u003ca href=\"https://dart.dev/tools/pub/publishing#transferring-a-package-to-a-verified-publisher\"\u003e转移到发布者\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e一旦软件包被转移到发布者，你就可以使用 \u003ccode\u003epub publish\u003c/code\u003e 更新软件包。\u003c/p\u003e\n\u003cp\u003e当你的包成功上传到 pub.dev 后，任何 pub 用户都可以下载它或在他们的项目中依赖它。例如，如果你刚刚发布了 1.0.0 版本的 \u003ccode\u003etransmogrify\u003c/code\u003e 包，那么另一个 Dart 开发者可以在他们的 \u003ccode\u003epubspec.yaml\u003c/code\u003e 中添加它作为依赖:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan class=\"nt\"\u003edependencies\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003etransmogrify\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003e^1.0.0\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"将软件包传输给已验证的发布者\"\u003e将软件包传输给已验证的发布者\u003c/h3\u003e\n\u003cp\u003e要将一个软件包转移到已验证的发布者，您必须是该软件包的\u003ca href=\"https://dart.dev/tools/pub/publishing#uploaders\"\u003e上传者\u003c/a\u003e和已验证发布者的管理员。\u003c/p\u003e\n\u003cp\u003e注意：这个过程是不可逆的。一旦你将一个软件包转移到一个发布者，你不能将它转移回个人账户。\u003c/p\u003e\n\u003cp\u003e以下是如何将软件包转移到已验证的发布者:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e用一个被列为软件包上传者的 Google 账户登录到 \u003ca href=\"https://pub.dev/\"\u003epub.dev\u003c/a\u003e。\u003c/li\u003e\n\u003cli\u003e进入软件包的详细信息页面(例如，\u003ccode\u003ehttps://pub.dev/packages/http\u003c/code\u003e)。\u003c/li\u003e\n\u003cli\u003e选择\u0026quot;管理\u0026quot;选项卡。\u003c/li\u003e\n\u003cli\u003e输入发布者的名称，然后单击\u0026quot;传输到发布者\u0026quot;。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"哪些文件会被发布\"\u003e哪些文件会被发布？\u003c/h3\u003e\n\u003cp\u003e您的软件包中的\u003cstrong\u003e所有\u003c/strong\u003e文件都包含在已发布的软件包中，但有以下例外:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e任何包的目录。\u003c/li\u003e\n\u003cli\u003e您的软件包的 \u003ca href=\"https://dart.dev/tools/pub/glossary#lockfile\"\u003elockfile\u003c/a\u003e 文件。\u003c/li\u003e\n\u003cli\u003e如果你没有使用 Git，所有隐藏的文件（也就是名字以 \u003ccode\u003e.\u003c/code\u003e 开头的文件）。\u003c/li\u003e\n\u003cli\u003e如果使用 Git，则是所有被 \u003ccode\u003e.gitignore\u003c/code\u003e 文件忽略的文件。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e请确保删除任何你不想包含的文件(或将它们添加到 \u003ccode\u003e.gitignore\u003c/code\u003e 中)。 \u003ccode\u003epub publish\u003c/code\u003e 在上传你的包之前列出了它要发布的所有文件，所以在完成上传之前要仔细检查列表。\u003c/p\u003e\n\u003ch2 id=\"上传者\"\u003e上传者\u003c/h2\u003e\n\u003cp\u003e谁发布了软件包的第一个版本，谁就会自动成为第一个也是唯一一个被授权上传该软件包其他版本的人。要允许或不允许其他人上传版本，请使用 \u003ca href=\"https://dart.dev/tools/pub/cmd/pub-uploader\"\u003epub uploader\u003c/a\u003e 命令或将软件包转移到\u003ca href=\"https://dart.dev/tools/pub/verified-publishers\"\u003e已验证的发布者\u003c/a\u003e那里。\u003c/p\u003e\n\u003cp\u003e如果一个软件包有一个经过验证的发布者，那么该软件包的 pub.dev 页面会显示发布者的域名。否则，该页面将显示该软件包的授权上传者的电子邮件地址。\u003c/p\u003e\n\u003ch2 id=\"发布预发包\"\u003e发布预发包\u003c/h2\u003e\n\u003cp\u003e当你在做一个包的时候，考虑把它作为一个预发布。当以下任何一种情况发生时，预发布都是有用的。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e你正在积极开发软件包的下一个主要版本。\u003c/li\u003e\n\u003cli\u003e你想为软件包的下一个发行候选版本招募测试者。\u003c/li\u003e\n\u003cli\u003e该包依赖于 Dart 或 Flutter SDK 的不稳定版本。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e正如在\u003ca href=\"https://semver.org/spec/v2.0.0-rc.1.html\"\u003e语义版本化\u003c/a\u003e中所描述的那样，为了使一个版本的预发布，你要给版本附加一个后缀。例如，要对 \u003ccode\u003e2.0.0\u003c/code\u003e 版本进行预发布，你可以使用 \u003ccode\u003e2.0.0-dev.1\u003c/code\u003e 版本。以后，当你发布 \u003ccode\u003e2.0.0\u003c/code\u003e 版本时，它将优先于所有 \u003ccode\u003e2.0.0-XXX\u003c/code\u003e 预发布版本。\u003c/p\u003e\n\u003cp\u003e因为 pub 更倾向于在可用的时候发布稳定版，所以一个预发布包的用户可能需要改变他们的依赖约束。例如，如果用户想要测试 2.1 版本的预发布包，那么他们可以指定 \u003ccode\u003e^2.1.0-dev.1\u003c/code\u003e，而不是 \u003ccode\u003e^2.0.0\u003c/code\u003e 或 \u003ccode\u003e^2.1.0\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e注意: 如果依赖关系图中的稳定包依赖于一个 prerelease，那么 pub 会选择那个 prerelease 而不是稳定版本。\u003c/p\u003e\n\u003cp\u003e当一个 prerelease 被发布到 pub.dev 时，软件包页面会同时显示到 prerelease 和稳定版的链接。prerelease 不会影响分析得分，不会出现在搜索结果中，也不会替换包的 \u003ccode\u003eREADME.md\u003c/code\u003e 和文档。\u003c/p\u003e\n\u003ch2 id=\"将软件包标记为已停产的软件包\"\u003e将软件包标记为已停产的软件包\u003c/h2\u003e\n\u003cp\u003e尽管软件包总是保持发布，但向开发者发出信号，表明一个软件包不再被积极维护，是很有用的。为此，您可以将一个软件包标记为 \u003ccode\u003ediscontinued\u003c/code\u003e。一个已停用的软件包仍然可以在 pub.dev 上发布和查看，但它有一个清晰的 DISCONTINUED 徽章，并且不会出现在 pub.dev 的搜索结果中。\u003c/p\u003e\n\u003cp\u003e要将软件包标记为已停用，请使用该软件包的上传者或已验证的发布者管理员的 Google 帐户登录 pub.dev。然后使用单个软件包的管理选项卡将该软件包标记为已停用。\u003c/p\u003e\n\u003ch2 id=\"资源\"\u003e资源\u003c/h2\u003e\n\u003cp\u003e有关更多信息，请参见以下 pub 命令的参考页面。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-lish\"\u003epub publish\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-uploader\"\u003epub uploader\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n","text":"pub 软件包管理器不仅仅是用来使用别人的软件包。它还允许你与世界分享你的软件包。如果您有一个有用的项目，并且您希望其他人能够使用它，请使用 pub publish 命令。\n注意: 如果要发布到 pub.dev 以外的其他位置，或者要防止在任何地方发布，请使用 pubspec 中定义的 publish_to 字段。\n发布是永远的 请记住，发布是永远的。只要你发布你的包，用户就可以依赖它。一旦他们开始这样做，删除包就会破坏他们的包。为了避免这种情况，pub.dev 政策不允许取消发布软件包，除非是极少数情况。\n你可以随时上传你的包的新版本，但旧的包将继续为那些还没有准备好升级的用户提供服务。\n对于已经发布的包，如果不再相关或正在维护，你可以将其标记为停止发布。\n准备发布 当发布一个软件包时，遵循 pubspec 格式和包布局惯例是很重要的。其中有些是必须的，以便其他人能够使用你的软件包。另一些则是为了帮助用户更容易理解和使用您的软件包而提出的建议。在这两种情况下，pub 都会尝试帮助你，指出哪些改变会帮助你的软件包在 Dart 生态系统中发挥得更好。上传包有一些额外的要求:\n  你必须包含一个包含开源许可证的 LICENSE 文件。我们推荐 BSD 许可证，这是 Dart 自己使用的。你也必须有合法的权利来重新发布你上传的任何东西作为你的包的一部分。\n  你的软件包在经过 gzip 压缩后必须小于 10 MB。如果太大，可以考虑将其分割成多个包，或者减少包含的资源或例子的数量。\n  你的包应该只依赖托管的依赖项(来自默认的 pub 包服务器)和 SDK 依赖项(sdk: flutter)。这些限制确保了你的包的依赖性不会在未来变得不可用。\n  您必须有一个 Google 帐户，pub 用来管理包的上传权限。您的 Google 账户可以与 Gmail 地址或任何其他电子邮件地址关联。\n  注意：除非您使用已验证的发布者发布，否则 pub.dev 会显示与您的 Google 帐户关联的电子邮件地址。\n重要文件 Pub 使用一些文件的内容为你的包创建一个页面，地址是 pub.dev/packages/\u0026lt;your_package\u0026gt;。以下是影响你的包的页面外观的文件。\n README.md: README.md 文件是你的包页面中的主要内容。该文件的内容以 Markdown 的形式呈现。 CHANGELOG.md：CHANGELOG.md 文件是你的包页面中的主要内容。你的包的 CHANGELOG.md 文件，如果找到的话，也会在你的包页面的一个标签中显示，这样开发者就可以直接从 pub.dev 中读取它。该文件的内容会以 Markdown 的形式呈现。 pubspec: 你的包的 pubspec.yaml 文件用来在你的包的页面右侧填写关于你的包的详细信息，比如它的描述、主页等。  使用经过验证的发布者的优势 您可以使用已验证的发布者（推荐）或独立的谷歌账户发布软件包。使用经过验证的发布者有以下优势。\n 您的包的消费者知道发布者的域名已经被验证。 您可以避免让 pub.dev 显示您的个人电子邮件地址。取而代之的是，pub.dev会显示发布者的域名和联系地址。 经验证的发布者徽章 pub.dev 经验证的发布者标识会在搜索页面和单个软件包页面上显示在您的软件包名称旁边。  创建一个验证过的发布者 要创建一个已验证的发布者，请按照以下步骤进行。\n 进入 pub.dev。 使用 Google 账户登录 pub.dev。 在右上角的用户菜单中，选择创建发布者。 输入您要与您的发布者相关联的域名(例如，dart.dev)，然后单击\u0026quot;创建发布者\u0026quot;。 在确认对话框中，选择\u0026quot;确定\u0026quot;。 如果提示，完成验证流程，这将打开 Google 搜索控制台。   在添加 DNS 记录时，可能需要几个小时后，搜索控制台才会反映出变化。 验证流程完成后，返回步骤4。  发布你的包 使用 pub publish 命令来首次发布您的软件包，或将其更新到新版本。\n执行 dry run 为了测试 pub publish 的工作情况，你可以进行一次 dry run:\n$ pub publish --dry-run Pub 会确保你的软件包遵循 pubspec 格式和包布局约定，然后将你的软件包上传到 pub.dev。Pub 还会向你展示它打算发布的所有文件。下面是一个发布名为 transmogrify 的软件包的例子:\nPublishing transmogrify 1.0.0.gitignoreCHANGELOG.mdREADME.mdlibtransmogrify.dartsrctransmogrifier.darttransmogrification.dartpubspec.yamltesttransmogrify_test.dartPackage has 0 warnings.发布 当你准备好发布你的包时，请删除 --dry-run 参数:\n$ pub publish 注意: pub 命令目前不支持直接将新软件包发布到已验证的发布者。作为一个临时的变通方法，可以将新的软件包发布到Google账户，然后将包转移到发布者。\n一旦软件包被转移到发布者，你就可以使用 pub publish 更新软件包。\n当你的包成功上传到 pub.dev 后，任何 pub 用户都可以下载它或在他们的项目中依赖它。例如，如果你刚刚发布了 1.0.0 版本的 transmogrify 包，那么另一个 Dart 开发者可以在他们的 pubspec.yaml 中添加它作为依赖:\ndependencies:transmogrify:^1.0.0将软件包传输给已验证的发布者 要将一个软件包转移到已验证的发布者，您必须是该软件包的上传者和已验证发布者的管理员。\n注意：这个过程是不可逆的。一旦你将一个软件包转移到一个发布者，你不能将它转移回个人账户。\n以下是如何将软件包转移到已验证的发布者:\n 用一个被列为软件包上传者的 Google 账户登录到 pub.dev。 进入软件包的详细信息页面(例如，https://pub.dev/packages/http)。 选择\u0026quot;管理\u0026quot;选项卡。 输入发布者的名称，然后单击\u0026quot;传输到发布者\u0026quot;。  哪些文件会被发布？ 您的软件包中的所有文件都包含在已发布的软件包中，但有以下例外:\n 任何包的目录。 您的软件包的 lockfile 文件。 如果你没有使用 Git，所有隐藏的文件（也就是名字以 . 开头的文件）。 如果使用 Git，则是所有被 .gitignore 文件忽略的文件。  请确保删除任何你不想包含的文件(或将它们添加到 .gitignore 中)。 pub publish 在上传你的包之前列出了它要发布的所有文件，所以在完成上传之前要仔细检查列表。\n上传者 谁发布了软件包的第一个版本，谁就会自动成为第一个也是唯一一个被授权上传该软件包其他版本的人。要允许或不允许其他人上传版本，请使用 pub uploader 命令或将软件包转移到已验证的发布者那里。\n如果一个软件包有一个经过验证的发布者，那么该软件包的 pub.dev 页面会显示发布者的域名。否则，该页面将显示该软件包的授权上传者的电子邮件地址。\n发布预发包 当你在做一个包的时候，考虑把它作为一个预发布。当以下任何一种情况发生时，预发布都是有用的。\n 你正在积极开发软件包的下一个主要版本。 你想为软件包的下一个发行候选版本招募测试者。 该包依赖于 Dart 或 Flutter SDK 的不稳定版本。  正如在语义版本化中所描述的那样，为了使一个版本的预发布，你要给版本附加一个后缀。例如，要对 2.0.0 版本进行预发布，你可以使用 2.0.0-dev.1 版本。以后，当你发布 2.0.0 版本时，它将优先于所有 2.0.0-XXX 预发布版本。\n因为 pub 更倾向于在可用的时候发布稳定版，所以一个预发布包的用户可能需要改变他们的依赖约束。例如，如果用户想要测试 2.1 版本的预发布包，那么他们可以指定 ^2.1.0-dev.1，而不是 ^2.0.0 或 ^2.1.0。\n注意: 如果依赖关系图中的稳定包依赖于一个 prerelease，那么 pub 会选择那个 prerelease 而不是稳定版本。\n当一个 prerelease 被发布到 pub.dev 时，软件包页面会同时显示到 prerelease 和稳定版的链接。prerelease 不会影响分析得分，不会出现在搜索结果中，也不会替换包的 README.md 和文档。\n将软件包标记为已停产的软件包 尽管软件包总是保持发布，但向开发者发出信号，表明一个软件包不再被积极维护，是很有用的。为此，您可以将一个软件包标记为 discontinued。一个已停用的软件包仍然可以在 pub.dev 上发布和查看，但它有一个清晰的 DISCONTINUED 徽章，并且不会出现在 pub.dev 的搜索结果中。\n要将软件包标记为已停用，请使用该软件包的上传者或已验证的发布者管理员的 Google 帐户登录 pub.dev。然后使用单个软件包的管理选项卡将该软件包标记为已停用。\n资源 有关更多信息，请参见以下 pub 命令的参考页面。\n pub publish pub uploader  "},"name":"发布包","published":"2020-06-30T00:00:00Z","summary":"Publishing packages","type":"entry","url":"https://ohmyweekly.github.io/notes/publishing-packages/"},{"content":{"html":"\u003cp\u003eDart 生态系统使用包来管理共享软件，如库和工具。要获得 Dart 包，你可以使用 \u003ccode\u003epub\u003c/code\u003e 包管理器。你可以在 \u003ca href=\"https://pub.dev/\"\u003epub.dev\u003c/a\u003e 网站上找到公开的包，也可以从本地文件系统或其他地方加载包，比如 Git 仓库。无论你的包来自哪里，pub 都会管理版本依赖关系，帮助你获得相互之间以及与 SDK 版本兼容的包版本。\u003c/p\u003e\n\u003cp\u003e大多数精通 Dart 的 \u003ca href=\"https://dart.dev/tools#ides-and-editors\"\u003eIDE\u003c/a\u003e 都提供了对 pub 的支持，包括创建、下载、更新和发布包。或者你可以\u003ca href=\"https://dart.dev/tools/pub/cmd\"\u003e在命令行中使用 pub\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e至少，一个 Dart 包是一个包含 \u003ca href=\"https://dart.dev/tools/pub/pubspec\"\u003epubspec 文件\u003c/a\u003e的目录。pubspec 包含一些关于包的元数据。此外，一个包可以包含依赖关系(在 pubspec 中列出)，Dart 库，应用程序，资源，测试，图像和例子。\u003c/p\u003e\n\u003cp\u003e要使用一个包，请执行以下操作:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e创建一个 pubspec(一个名为 \u003ccode\u003epubspec.yaml\u003c/code\u003e 的文件，它列出了软件包的依赖关系，并包含其他元数据，如版本号)。\u003c/li\u003e\n\u003cli\u003e使用 \u003ccode\u003epub\u003c/code\u003e 来获取你的包的依赖关系。\u003c/li\u003e\n\u003cli\u003e如果你的 Dart 代码依赖于软件包中的一个库，则导入该库。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"创建一个-pubspec\"\u003e创建一个 pubspec\u003c/h2\u003e\n\u003cp\u003epubspec 是一个名为 \u003ccode\u003epubspec.yaml\u003c/code\u003e 的文件，它位于你的应用程序的顶级目录中。最简单的 pubspec 只列出了包名:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"nl\"\u003ename:\u003c/span\u003e \u003cspan class=\"n\"\u003emy_app\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e下面是一个 pubspec 的例子，它声明了两个包(\u003ccode\u003ejs\u003c/code\u003e 和 \u003ccode\u003eintl\u003c/code\u003e)的依赖关系，这两个包都托管在 pub.dev 站点上:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"nl\"\u003ename:\u003c/span\u003e \u003cspan class=\"n\"\u003emy_app\u003c/span\u003e\n\u003cspan class=\"nl\"\u003edependencies:\u003c/span\u003e\n  \u003cspan class=\"nl\"\u003ejs:\u003c/span\u003e \u003cspan class=\"o\"\u003e^\u003c/span\u003e\u003cspan class=\"m\"\u003e0.6\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"m\"\u003e0\u003c/span\u003e\n  \u003cspan class=\"nl\"\u003eintl:\u003c/span\u003e \u003cspan class=\"o\"\u003e^\u003c/span\u003e\u003cspan class=\"m\"\u003e0.15\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"m\"\u003e8\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e关于创建 pubspec 的详细信息，请参见 \u003ca href=\"https://dart.dev/tools/pub/pubspec\"\u003epubspec 文档\u003c/a\u003e和你要使用的包的文档。\u003c/p\u003e\n\u003ch2 id=\"获取软件包\"\u003e获取软件包\u003c/h2\u003e\n\u003cp\u003e一旦你有了 pubspec，你就可以从你的应用程序的顶级目录中运行 \u003ccode\u003epub get\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e$ \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e \u0026lt;path-to-my_app\u0026gt;\n$ pub get\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个过程被称为获取依赖关系。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epub get\u003c/code\u003e 命令可以确定您的应用程序依赖于哪些软件包，并将它们放在中央\u003ca href=\"https://dart.dev/tools/pub/glossary#system-cache\"\u003e系统缓存\u003c/a\u003e中。如果您的应用程序依赖于已发布的包，pub 会从 \u003ca href=\"https://pub.dev/\"\u003epub.dev\u003c/a\u003e 站点下载该包。对于  \u003ca href=\"https://dart.dev/tools/pub/dependencies#git-packages\"\u003eGit 依赖\u003c/a\u003e，pub 会克隆 Git 仓库。还包括了过渡性依赖。例如，如果 \u003ccode\u003ejs\u003c/code\u003e 包依赖于 \u003ccode\u003etest\u003c/code\u003e 包，\u003ccode\u003epub\u003c/code\u003e 会同时抓取 \u003ccode\u003ejs\u003c/code\u003e 包和 \u003ccode\u003etest\u003c/code\u003e 包。\u003c/p\u003e\n\u003cp\u003ePub 会创建一个 \u003ccode\u003e.packages\u003c/code\u003e 文件(在你的应用程序的顶层目录下)，将你的应用程序所依赖的每个包名映射到系统缓存中的对应包。\u003c/p\u003e\n\u003ch2 id=\"从包中导入库\"\u003e从包中导入库\u003c/h2\u003e\n\u003cp\u003e要导入在包中找到的库，使用 \u003ccode\u003epackage:\u003c/code\u003e 前缀:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"k\"\u003eimport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;package:js/js.dart\u0026#39;\u003c/span\u003e \u003cspan class=\"k\"\u003eas\u003c/span\u003e \u003cspan class=\"n\"\u003ejs\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eimport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;package:intl/intl.dart\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eDart 运行时在 \u003ccode\u003epackage:\u003c/code\u003e 之后的所有内容都会在应用程序的 \u003ccode\u003e.package\u003c/code\u003e 文件中进行查找。\u003c/p\u003e\n\u003cp\u003e你也可以使用这种风格从你自己的包中导入库。比方说，\u003ccode\u003etransmogrify\u003c/code\u003e 包的布局如下:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-txt\" data-lang=\"txt\"\u003etransmogrify/\n  lib/\n    transmogrify.dart\n    parser.dart\n  test/\n    parser/\n      parser_test.dart\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003eparser_test.dart\u003c/code\u003e 文件可以这样导入 \u003ccode\u003eparser.dart\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"k\"\u003eimport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;package:transmogrify/parser.dart\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"升级依赖关系\"\u003e升级依赖关系\u003c/h2\u003e\n\u003cp\u003e当你第一次为你的软件包获取一个新的依赖关系时，pub 会下载与你的其他依赖关系兼容的最新版本。然后，它通过创建一个 \u003cstrong\u003elockfile\u003c/strong\u003e 锁文件来锁定您的软件包，使其始终使用该版本。这是一个名为 \u003ccode\u003epubspec.lock\u003c/code\u003e 的文件，由 pub 创建并存储在 pubspec 的旁边。它列出了您的软件包所使用的每个依赖关系的特定版本 (即时的和过渡的)。\u003c/p\u003e\n\u003cp\u003e如果你的包是一个应用程序包，你应该把这个文件检查到\u003ca href=\"https://dart.dev/guides/libraries/private-files\"\u003e源代码控制\u003c/a\u003e中。这样，在你的应用程序上工作的每个人都会使用所有包的相同版本。在 lockfile 文件中检查也可以确保你部署的应用使用相同版本的代码。\u003c/p\u003e\n\u003cp\u003e当你准备好将你的依赖项升级到最新版本时，使用 \u003ca href=\"https://dart.dev/tools/pub/cmd/pub-upgrade\"\u003epub upgrade\u003c/a\u003e 命令:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"n\"\u003e$\u003c/span\u003e \u003cspan class=\"n\"\u003epub\u003c/span\u003e \u003cspan class=\"n\"\u003eupgrade\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003epub upgrade\u003c/code\u003e 命令告诉 pub 使用你的包的依赖关系的最新版本来重新生成 lockfile 文件。如果你只想升级一个依赖关系，你可以指定要升级的软件包:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"n\"\u003e$\u003c/span\u003e \u003cspan class=\"n\"\u003epub\u003c/span\u003e \u003cspan class=\"n\"\u003eupgrade\u003c/span\u003e \u003cspan class=\"n\"\u003etransmogrify\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e该命令将 \u003ccode\u003etransmogrify\u003c/code\u003e 升级到最新版本，但其他一切都保持不变。\u003c/p\u003e\n\u003cp\u003e由于 pubspec 中有冲突的版本限制，\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-upgrade\"\u003epub upgrade\u003c/a\u003e 命令并不能总是将每个软件包升级到最新版本。要识别需要编辑 pubspec 的过期软件包，请使用 \u003ca href=\"https://dart.dev/tools/pub/cmd/pub-outdated\"\u003epub outdated\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"更多信息\"\u003e更多信息\u003c/h2\u003e\n\u003cp\u003e下面的页面有更多关于软件包和 pub 包管理器的信息。\u003c/p\u003e\n\u003cp\u003e如何使用\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/guides/libraries/create-library-packages\"\u003e创建包\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/publishing\"\u003e发布包\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e参考\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/dependencies\"\u003ePub 依赖\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/environment-variables\"\u003ePub 环境变量\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/glossary\"\u003ePub 词汇表\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/package-layout\"\u003ePub 包布局约定\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/versioning\"\u003ePub 版本哲学\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/pubspec\"\u003ePubspec 格式化\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePub 命令\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epub\u003c/code\u003e 工具提供了以下命令:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-cache\"\u003epub cache\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-deps\"\u003epub deps\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-downgrade\"\u003epub downgrade\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-get\"\u003epub get\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-global\"\u003epub global\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-outdated\"\u003epub outdated\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-lish\"\u003epub publish\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-run\"\u003epub run\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-upgrade\"\u003epub upgrade\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-uploader\"\u003epub uploader\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e有关所有 pub 命令的概述，请参阅 \u003ca href=\"https://dart.dev/tools/pub/cmd\"\u003epub 工具文档\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e疑难解答\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://dart.dev/tools/pub/troubleshoot\"\u003e故障排除 pub\u003c/a\u003e 提供了使用 pub 时可能遇到的问题的解决方案。\u003c/p\u003e\n","text":"Dart 生态系统使用包来管理共享软件，如库和工具。要获得 Dart 包，你可以使用 pub 包管理器。你可以在 pub.dev 网站上找到公开的包，也可以从本地文件系统或其他地方加载包，比如 Git 仓库。无论你的包来自哪里，pub 都会管理版本依赖关系，帮助你获得相互之间以及与 SDK 版本兼容的包版本。\n大多数精通 Dart 的 IDE 都提供了对 pub 的支持，包括创建、下载、更新和发布包。或者你可以在命令行中使用 pub。\n至少，一个 Dart 包是一个包含 pubspec 文件的目录。pubspec 包含一些关于包的元数据。此外，一个包可以包含依赖关系(在 pubspec 中列出)，Dart 库，应用程序，资源，测试，图像和例子。\n要使用一个包，请执行以下操作:\n 创建一个 pubspec(一个名为 pubspec.yaml 的文件，它列出了软件包的依赖关系，并包含其他元数据，如版本号)。 使用 pub 来获取你的包的依赖关系。 如果你的 Dart 代码依赖于软件包中的一个库，则导入该库。  创建一个 pubspec pubspec 是一个名为 pubspec.yaml 的文件，它位于你的应用程序的顶级目录中。最简单的 pubspec 只列出了包名:\nname: my_app 下面是一个 pubspec 的例子，它声明了两个包(js 和 intl)的依赖关系，这两个包都托管在 pub.dev 站点上:\nname: my_app dependencies: js: ^0.6.0 intl: ^0.15.8 关于创建 pubspec 的详细信息，请参见 pubspec 文档和你要使用的包的文档。\n获取软件包 一旦你有了 pubspec，你就可以从你的应用程序的顶级目录中运行 pub get:\n$ cd \u0026lt;path-to-my_app\u0026gt; $ pub get 这个过程被称为获取依赖关系。\npub get 命令可以确定您的应用程序依赖于哪些软件包，并将它们放在中央系统缓存中。如果您的应用程序依赖于已发布的包，pub 会从 pub.dev 站点下载该包。对于 Git 依赖，pub 会克隆 Git 仓库。还包括了过渡性依赖。例如，如果 js 包依赖于 test 包，pub 会同时抓取 js 包和 test 包。\nPub 会创建一个 .packages 文件(在你的应用程序的顶层目录下)，将你的应用程序所依赖的每个包名映射到系统缓存中的对应包。\n从包中导入库 要导入在包中找到的库，使用 package: 前缀:\nimport \u0026#39;package:js/js.dart\u0026#39; as js; import \u0026#39;package:intl/intl.dart\u0026#39;; Dart 运行时在 package: 之后的所有内容都会在应用程序的 .package 文件中进行查找。\n你也可以使用这种风格从你自己的包中导入库。比方说，transmogrify 包的布局如下:\ntransmogrify/ lib/ transmogrify.dart parser.dart test/ parser/ parser_test.dart parser_test.dart 文件可以这样导入 parser.dart:\nimport \u0026#39;package:transmogrify/parser.dart\u0026#39;; 升级依赖关系 当你第一次为你的软件包获取一个新的依赖关系时，pub 会下载与你的其他依赖关系兼容的最新版本。然后，它通过创建一个 lockfile 锁文件来锁定您的软件包，使其始终使用该版本。这是一个名为 pubspec.lock 的文件，由 pub 创建并存储在 pubspec 的旁边。它列出了您的软件包所使用的每个依赖关系的特定版本 (即时的和过渡的)。\n如果你的包是一个应用程序包，你应该把这个文件检查到源代码控制中。这样，在你的应用程序上工作的每个人都会使用所有包的相同版本。在 lockfile 文件中检查也可以确保你部署的应用使用相同版本的代码。\n当你准备好将你的依赖项升级到最新版本时，使用 pub upgrade 命令:\n$ pub upgrade pub upgrade 命令告诉 pub 使用你的包的依赖关系的最新版本来重新生成 lockfile 文件。如果你只想升级一个依赖关系，你可以指定要升级的软件包:\n$ pub upgrade transmogrify 该命令将 transmogrify 升级到最新版本，但其他一切都保持不变。\n由于 pubspec 中有冲突的版本限制，pub upgrade 命令并不能总是将每个软件包升级到最新版本。要识别需要编辑 pubspec 的过期软件包，请使用 pub outdated。\n更多信息 下面的页面有更多关于软件包和 pub 包管理器的信息。\n如何使用\n 创建包 发布包  参考\n Pub 依赖 Pub 环境变量 Pub 词汇表 Pub 包布局约定 Pub 版本哲学 Pubspec 格式化  Pub 命令\npub 工具提供了以下命令:\n pub cache pub deps pub downgrade pub get pub global pub outdated pub publish pub run pub upgrade pub uploader  有关所有 pub 命令的概述，请参阅 pub 工具文档。\n疑难解答\n故障排除 pub 提供了使用 pub 时可能遇到的问题的解决方案。\n"},"name":"如何使用包","published":"2020-06-29T00:00:00Z","summary":"Dart 包管理工具 - pub","type":"entry","url":"https://ohmyweekly.github.io/notes/how-to-use-packages/"},{"content":{"html":"\u003cp\u003e本页列出了一些  Dart 开发者发布的最流行和最有用的\u003ca href=\"https://dart.dev/guides/packages\"\u003e包\u003c/a\u003e。要找到更多的软件包\u0026ndash;也可以搜索\u003ca href=\"https://dart.dev/guides/libraries\"\u003e核心库\u003c/a\u003e\u0026ndash;请使用 \u003ca href=\"https://pub.dev/\"\u003epub.dev\u003c/a\u003e 网站。\u003c/p\u003e\n\u003cp\u003e常用的软件包可分为三类:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/guides/libraries/useful-libraries#general-purpose-packages\"\u003e通用包\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/guides/libraries/useful-libraries#packages-that-correspond-to-sdk-libraries\"\u003e扩展 Dart 核心库的包\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/guides/libraries/useful-libraries#specialized-packages\"\u003e特定的包\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"通用包\"\u003e通用包\u003c/h2\u003e\n\u003cp\u003e以下包对各种项目都很有用:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e包\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e描述\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e常用的 API\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/archive\"\u003earchive\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e对各种档案和压缩格式进行编码和解码。\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eArchive, ArchiveFile, TarEncoder, TarDecoder, ZipEncoder, ZipDecoder\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/characters\"\u003echaracters\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e对用户感知的字符进行字符串操作(Unicode 字符簇)\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eString.characters, Characters, CharacterRange\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/http\"\u003ehttp\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e一组高级的函数和类，使其易于消费 HTTP 资源\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003edelete(), get(), post(), read()\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/intl\"\u003eintl\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e国际化和本地化设施，支持复数和性别、日期和数字格式化和解析以及双向文本\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eBidi, DateFormat, MicroMoney, TextDirection\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/json_serializable\"\u003ejson_serializable\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e一个易于使用的代码生成包。更多信息，请参阅 \u003ca href=\"https://dart.dev/guides/json\"\u003eJSON 支持\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e@JsonSerializable\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/logging\"\u003elogging\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e一个可配置的机制，为你的应用程序添加消息记录\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eLoggerHandler, Level, LogRecord\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/mockito\"\u003emockito\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e一个在测试中模拟对象的流行框架。如果你正在编写依赖注入的测试，特别有用。与 \u003ca href=\"https://pub.dev/packages/test\"\u003etest\u003c/a\u003e 包一起使用\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eAnswering, Expectation, Verification\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/path\"\u003epath\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e操作不同类型路径的常用操作。更多信息，请参见\u003ca href=\"https://news.dartlang.org/2016/06/unboxing-packages-path.html\"\u003e拆包: path\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eabsolute(), basename(), extension(), join(), normalize(), relative(), split()\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/quiver\"\u003equiver\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e实用工具，使 Dart 核心库的使用更加方便。Quiver 提供额外支持的一些库包括 async、cache、collection、core、iterables、pattern 和 测试\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eCountdownTimer (quiver.async); MapCache (quiver.cache); MultiMap, TreeSet (quiver.collection); EnumerateIterable (quiver.iterables); center(), compareIgnoreCase(), isWhiteSpace() (quiver.strings)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/shelf\"\u003eshelf\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eDart 的 Web 服务器中间件。Shelf 使它能轻松地创建和组成 Web 服务器，以及 Web 服务器的一部分\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eCascade, Pipeline, Request, Response, Server\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/stack_trace\"\u003estack_trace\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用于解析、检查和处理由底层 Dart 实现产生的堆栈痕迹的方法。还提供了以比原生 StackTrace 实现更可读的格式生成堆栈跟踪的字符串表示的函数,  更多信息，请参见\u003ca href=\"https://news.dartlang.org/2016/01/unboxing-packages-stacktrace.html\"\u003e拆包: stack_trace\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eTrace.current(), Trace.format(), Trace.from()\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/stagehand\"\u003estagehand\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e一个 Dart 项目生成器。当你创建一个新的应用程序时，WebStorm 和 IntelliJ 使用 Stagehand 模板，但你也可以从命令行使用模板\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e一般通过 IDE 或 \u003ccode\u003estagehand\u003c/code\u003e 命令来使用\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/test\"\u003etest\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e在 Dart 中编写和运行测试的标准方法\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eexpect(), group(), test()\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/yaml\"\u003eyaml\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eYAML 解析器\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eloadYaml(), loadYamlStream()\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"扩展-dart-核心库的包\"\u003e扩展 Dart 核心库的包\u003c/h2\u003e\n\u003cp\u003e以下每个包都建立在一个\u003ca href=\"https://dart.dev/guides/libraries\"\u003e核心库\u003c/a\u003e的基础上，增加了功能并填补了缺失的功能:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e包\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e描述\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e常用的 API\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/async\"\u003easync\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e在 dart:async 的基础上进行了扩展，增加了实用类来处理异步计算。更多信息，请参见\u003ca href=\"https://news.dartlang.org/2016/03/unboxing-packages-async-part-1.html\"\u003e拆包: async 第1部分\u003c/a\u003e、\u003ca href=\"https://news.dartlang.org/2016/03/unboxing-packages-async-part-2.html\"\u003e第2部分\u003c/a\u003e和\u003ca href=\"https://news.dartlang.org/2016/04/unboxing-packages-async-part-3.html\"\u003e第3部分\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eAsyncMemoizer, CancelableOperation, FutureGroup, LazyStream, Result, StreamCompleter, StreamGroup, StreamSplitter\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/collection\"\u003ecollection\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e在 dart:collection 的基础上进行了扩展，增加了实用函数和类，使处理集合的工作变得更加容易。更多信息，请看\u003ca href=\"https://news.dartlang.org/2016/01/unboxing-packages-collection.html\"\u003e拆包：collection\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eEquality, CanonicalizedMap, MapKeySet, MapValueSet, PriorityQueue, QueueList\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/convert\"\u003econvert\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e在 dart:convert 的基础上，增加了编码器和解码器，用于在不同的数据表现形式之间进行转换。其中一种数据表示方式是百分比编码，也被称为 URL 编码\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eHexDecoder, PercentDecoder\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ca href=\"https://pub.dev/packages/io\"\u003eio\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e包含两个库，ansi和io，以简化对文件、标准流和进程的处理。使用 ansi 库可以自定义终端输出。io 库有处理进程、stdin 和文件复制的 API\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003ecopyPath(), isExecutable(), ExitCode, ProcessManager, sharedStdIn\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"专用包\"\u003e专用包\u003c/h2\u003e\n\u003cp\u003e下面是一些寻找比较专业的包的技巧，比如手机的包(Flutter)和网页开发的包。\u003c/p\u003e\n\u003ch3 id=\"flutter-包\"\u003eFlutter 包\u003c/h3\u003e\n\u003cp\u003e请看 Flutter 网站上的\u003ca href=\"https://flutter.dev/docs/development/packages-and-plugins/using-packages\"\u003e使用包\u003c/a\u003e。或者使用 pub.dev 网站\u003ca href=\"https://pub.dev/flutter\"\u003e搜索 Flutter 包\u003c/a\u003e。\u003c/p\u003e\n\u003ch3 id=\"网络包\"\u003e网络包\u003c/h3\u003e\n\u003cp\u003e参见\u003ca href=\"https://dart.dev/web/libraries\"\u003e网络库和包\u003c/a\u003e。或者使用 pub.dev 站点\u003ca href=\"https://pub.dev/web\"\u003e搜索 web 包\u003c/a\u003e。\u003c/p\u003e\n\u003ch3 id=\"命令行和服务器软件包\"\u003e命令行和服务器软件包\u003c/h3\u003e\n\u003cp\u003e参见\u003ca href=\"https://dart.dev/server/libraries\"\u003e命令行和服务器库和包\u003c/a\u003e。或者使用 pub.dev 站点\u003ca href=\"https://pub.dev/\"\u003e搜索其他包\u003c/a\u003e。\u003c/p\u003e\n","text":"本页列出了一些 Dart 开发者发布的最流行和最有用的包。要找到更多的软件包\u0026ndash;也可以搜索核心库\u0026ndash;请使用 pub.dev 网站。\n常用的软件包可分为三类:\n 通用包 扩展 Dart 核心库的包 特定的包  通用包 以下包对各种项目都很有用:\n   包 描述 常用的 API     archive 对各种档案和压缩格式进行编码和解码。 Archive, ArchiveFile, TarEncoder, TarDecoder, ZipEncoder, ZipDecoder   characters 对用户感知的字符进行字符串操作(Unicode 字符簇) String.characters, Characters, CharacterRange   http 一组高级的函数和类，使其易于消费 HTTP 资源 delete(), get(), post(), read()   intl 国际化和本地化设施，支持复数和性别、日期和数字格式化和解析以及双向文本 Bidi, DateFormat, MicroMoney, TextDirection   json_serializable 一个易于使用的代码生成包。更多信息，请参阅 JSON 支持 @JsonSerializable   logging 一个可配置的机制，为你的应用程序添加消息记录 LoggerHandler, Level, LogRecord   mockito 一个在测试中模拟对象的流行框架。如果你正在编写依赖注入的测试，特别有用。与 test 包一起使用 Answering, Expectation, Verification   path 操作不同类型路径的常用操作。更多信息，请参见拆包: path absolute(), basename(), extension(), join(), normalize(), relative(), split()   quiver 实用工具，使 Dart 核心库的使用更加方便。Quiver 提供额外支持的一些库包括 async、cache、collection、core、iterables、pattern 和 测试 CountdownTimer (quiver.async); MapCache (quiver.cache); MultiMap, TreeSet (quiver.collection); EnumerateIterable (quiver.iterables); center(), compareIgnoreCase(), isWhiteSpace() (quiver.strings)   shelf Dart 的 Web 服务器中间件。Shelf 使它能轻松地创建和组成 Web 服务器，以及 Web 服务器的一部分 Cascade, Pipeline, Request, Response, Server   stack_trace 用于解析、检查和处理由底层 Dart 实现产生的堆栈痕迹的方法。还提供了以比原生 StackTrace 实现更可读的格式生成堆栈跟踪的字符串表示的函数, 更多信息，请参见拆包: stack_trace Trace.current(), Trace.format(), Trace.from()   stagehand 一个 Dart 项目生成器。当你创建一个新的应用程序时，WebStorm 和 IntelliJ 使用 Stagehand 模板，但你也可以从命令行使用模板 一般通过 IDE 或 stagehand 命令来使用   test 在 Dart 中编写和运行测试的标准方法 expect(), group(), test()   yaml YAML 解析器 loadYaml(), loadYamlStream()    扩展 Dart 核心库的包 以下每个包都建立在一个核心库的基础上，增加了功能并填补了缺失的功能:\n   包 描述 常用的 API     async 在 dart:async 的基础上进行了扩展，增加了实用类来处理异步计算。更多信息，请参见拆包: async 第1部分、第2部分和第3部分 AsyncMemoizer, CancelableOperation, FutureGroup, LazyStream, Result, StreamCompleter, StreamGroup, StreamSplitter   collection 在 dart:collection 的基础上进行了扩展，增加了实用函数和类，使处理集合的工作变得更加容易。更多信息，请看拆包：collection Equality, CanonicalizedMap, MapKeySet, MapValueSet, PriorityQueue, QueueList   convert 在 dart:convert 的基础上，增加了编码器和解码器，用于在不同的数据表现形式之间进行转换。其中一种数据表示方式是百分比编码，也被称为 URL 编码 HexDecoder, PercentDecoder   io 包含两个库，ansi和io，以简化对文件、标准流和进程的处理。使用 ansi 库可以自定义终端输出。io 库有处理进程、stdin 和文件复制的 API copyPath(), isExecutable(), ExitCode, ProcessManager, sharedStdIn    专用包 下面是一些寻找比较专业的包的技巧，比如手机的包(Flutter)和网页开发的包。\nFlutter 包 请看 Flutter 网站上的使用包。或者使用 pub.dev 网站搜索 Flutter 包。\n网络包 参见网络库和包。或者使用 pub.dev 站点搜索 web 包。\n命令行和服务器软件包 参见命令行和服务器库和包。或者使用 pub.dev 站点搜索其他包。\n"},"name":"常用的包","published":"2020-06-29T00:00:00Z","summary":"Commonly used packages","type":"entry","url":"https://ohmyweekly.github.io/notes/commonly-used-packages/"}],"name":"packages","type":"feed","url":"https://ohmyweekly.github.io/tags/packages/"}