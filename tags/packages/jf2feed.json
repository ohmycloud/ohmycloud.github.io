{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"children":[{"content":{"html":"\u003cp\u003eDart 生态系统使用包来管理共享软件，如库和工具。要获得 Dart 包，你可以使用 \u003ccode\u003epub\u003c/code\u003e 包管理器。你可以在 \u003ca href=\"https://pub.dev/\"\u003epub.dev\u003c/a\u003e 网站上找到公开的包，也可以从本地文件系统或其他地方加载包，比如 Git 仓库。无论你的包来自哪里，pub 都会管理版本依赖关系，帮助你获得相互之间以及与 SDK 版本兼容的包版本。\u003c/p\u003e\n\u003cp\u003e大多数精通 Dart 的 \u003ca href=\"https://dart.dev/tools#ides-and-editors\"\u003eIDE\u003c/a\u003e 都提供了对 pub 的支持，包括创建、下载、更新和发布包。或者你可以\u003ca href=\"https://dart.dev/tools/pub/cmd\"\u003e在命令行中使用 pub\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e至少，一个 Dart 包是一个包含 \u003ca href=\"https://dart.dev/tools/pub/pubspec\"\u003epubspec 文件\u003c/a\u003e的目录。pubspec 包含一些关于包的元数据。此外，一个包可以包含依赖关系(在 pubspec 中列出)，Dart 库，应用程序，资源，测试，图像和例子。\u003c/p\u003e\n\u003cp\u003e要使用一个包，请执行以下操作:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e创建一个 pubspec(一个名为 \u003ccode\u003epubspec.yaml\u003c/code\u003e 的文件，它列出了软件包的依赖关系，并包含其他元数据，如版本号)。\u003c/li\u003e\n\u003cli\u003e使用 \u003ccode\u003epub\u003c/code\u003e 来获取你的包的依赖关系。\u003c/li\u003e\n\u003cli\u003e如果你的 Dart 代码依赖于软件包中的一个库，则导入该库。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"创建一个-pubspec\"\u003e创建一个 pubspec\u003c/h2\u003e\n\u003cp\u003epubspec 是一个名为 \u003ccode\u003epubspec.yaml\u003c/code\u003e 的文件，它位于你的应用程序的顶级目录中。最简单的 pubspec 只列出了包名:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"nl\"\u003ename:\u003c/span\u003e \u003cspan class=\"n\"\u003emy_app\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e下面是一个 pubspec 的例子，它声明了两个包(\u003ccode\u003ejs\u003c/code\u003e 和 \u003ccode\u003eintl\u003c/code\u003e)的依赖关系，这两个包都托管在 pub.dev 站点上:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"nl\"\u003ename:\u003c/span\u003e \u003cspan class=\"n\"\u003emy_app\u003c/span\u003e\n\u003cspan class=\"nl\"\u003edependencies:\u003c/span\u003e\n  \u003cspan class=\"nl\"\u003ejs:\u003c/span\u003e \u003cspan class=\"o\"\u003e^\u003c/span\u003e\u003cspan class=\"m\"\u003e0.6\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"m\"\u003e0\u003c/span\u003e\n  \u003cspan class=\"nl\"\u003eintl:\u003c/span\u003e \u003cspan class=\"o\"\u003e^\u003c/span\u003e\u003cspan class=\"m\"\u003e0.15\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"m\"\u003e8\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e关于创建 pubspec 的详细信息，请参见 \u003ca href=\"https://dart.dev/tools/pub/pubspec\"\u003epubspec 文档\u003c/a\u003e和你要使用的包的文档。\u003c/p\u003e\n\u003ch2 id=\"获取软件包\"\u003e获取软件包\u003c/h2\u003e\n\u003cp\u003e一旦你有了 pubspec，你就可以从你的应用程序的顶级目录中运行 \u003ccode\u003epub get\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e$ \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e \u0026lt;path-to-my_app\u0026gt;\n$ pub get\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个过程被称为获取依赖关系。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epub get\u003c/code\u003e 命令可以确定您的应用程序依赖于哪些软件包，并将它们放在中央\u003ca href=\"https://dart.dev/tools/pub/glossary#system-cache\"\u003e系统缓存\u003c/a\u003e中。如果您的应用程序依赖于已发布的包，pub 会从 \u003ca href=\"https://pub.dev/\"\u003epub.dev\u003c/a\u003e 站点下载该包。对于  \u003ca href=\"https://dart.dev/tools/pub/dependencies#git-packages\"\u003eGit 依赖\u003c/a\u003e，pub 会克隆 Git 仓库。还包括了过渡性依赖。例如，如果 \u003ccode\u003ejs\u003c/code\u003e 包依赖于 \u003ccode\u003etest\u003c/code\u003e 包，\u003ccode\u003epub\u003c/code\u003e 会同时抓取 \u003ccode\u003ejs\u003c/code\u003e 包和 \u003ccode\u003etest\u003c/code\u003e 包。\u003c/p\u003e\n\u003cp\u003ePub 会创建一个 \u003ccode\u003e.packages\u003c/code\u003e 文件(在你的应用程序的顶层目录下)，将你的应用程序所依赖的每个包名映射到系统缓存中的对应包。\u003c/p\u003e\n\u003ch2 id=\"从包中导入库\"\u003e从包中导入库\u003c/h2\u003e\n\u003cp\u003e要导入在包中找到的库，使用 \u003ccode\u003epackage:\u003c/code\u003e 前缀:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"k\"\u003eimport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003epackage:js/js.dart\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e \u003cspan class=\"k\"\u003eas\u003c/span\u003e \u003cspan class=\"n\"\u003ejs\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eimport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003epackage:intl/intl.dart\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eDart 运行时在 \u003ccode\u003epackage:\u003c/code\u003e 之后的所有内容都会在应用程序的 \u003ccode\u003e.package\u003c/code\u003e 文件中进行查找。\u003c/p\u003e\n\u003cp\u003e你也可以使用这种风格从你自己的包中导入库。比方说，\u003ccode\u003etransmogrify\u003c/code\u003e 包的布局如下:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-txt\" data-lang=\"txt\"\u003etransmogrify/\n  lib/\n    transmogrify.dart\n    parser.dart\n  test/\n    parser/\n      parser_test.dart\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003eparser_test.dart\u003c/code\u003e 文件可以这样导入 \u003ccode\u003eparser.dart\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"k\"\u003eimport\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003epackage:transmogrify/parser.dart\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"升级依赖关系\"\u003e升级依赖关系\u003c/h2\u003e\n\u003cp\u003e当你第一次为你的软件包获取一个新的依赖关系时，pub 会下载与你的其他依赖关系兼容的最新版本。然后，它通过创建一个 \u003cstrong\u003elockfile\u003c/strong\u003e 锁文件来锁定您的软件包，使其始终使用该版本。这是一个名为 \u003ccode\u003epubspec.lock\u003c/code\u003e 的文件，由 pub 创建并存储在 pubspec 的旁边。它列出了您的软件包所使用的每个依赖关系的特定版本 (即时的和过渡的)。\u003c/p\u003e\n\u003cp\u003e如果你的包是一个应用程序包，你应该把这个文件检查到\u003ca href=\"https://dart.dev/guides/libraries/private-files\"\u003e源代码控制\u003c/a\u003e中。这样，在你的应用程序上工作的每个人都会使用所有包的相同版本。在 lockfile 文件中检查也可以确保你部署的应用使用相同版本的代码。\u003c/p\u003e\n\u003cp\u003e当你准备好将你的依赖项升级到最新版本时，使用 \u003ca href=\"https://dart.dev/tools/pub/cmd/pub-upgrade\"\u003epub upgrade\u003c/a\u003e 命令:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"n\"\u003e$\u003c/span\u003e \u003cspan class=\"n\"\u003epub\u003c/span\u003e \u003cspan class=\"n\"\u003eupgrade\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003epub upgrade\u003c/code\u003e 命令告诉 pub 使用你的包的依赖关系的最新版本来重新生成 lockfile 文件。如果你只想升级一个依赖关系，你可以指定要升级的软件包:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-dart\" data-lang=\"dart\"\u003e\u003cspan class=\"n\"\u003e$\u003c/span\u003e \u003cspan class=\"n\"\u003epub\u003c/span\u003e \u003cspan class=\"n\"\u003eupgrade\u003c/span\u003e \u003cspan class=\"n\"\u003etransmogrify\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e该命令将 \u003ccode\u003etransmogrify\u003c/code\u003e 升级到最新版本，但其他一切都保持不变。\u003c/p\u003e\n\u003cp\u003e由于 pubspec 中有冲突的版本限制，\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-upgrade\"\u003epub upgrade\u003c/a\u003e 命令并不能总是将每个软件包升级到最新版本。要识别需要编辑 pubspec 的过期软件包，请使用 \u003ca href=\"https://dart.dev/tools/pub/cmd/pub-outdated\"\u003epub outdated\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"更多信息\"\u003e更多信息\u003c/h2\u003e\n\u003cp\u003e下面的页面有更多关于软件包和 pub 包管理器的信息。\u003c/p\u003e\n\u003cp\u003e如何使用\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/guides/libraries/create-library-packages\"\u003e创建包\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/publishing\"\u003e发布包\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e参考\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/dependencies\"\u003ePub 依赖\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/environment-variables\"\u003ePub 环境变量\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/glossary\"\u003ePub 词汇表\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/package-layout\"\u003ePub 包布局约定\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/versioning\"\u003ePub 版本哲学\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/pubspec\"\u003ePubspec 格式化\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePub 命令\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epub\u003c/code\u003e 工具提供了以下命令:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-cache\"\u003epub cache\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-deps\"\u003epub deps\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-downgrade\"\u003epub downgrade\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-get\"\u003epub get\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-global\"\u003epub global\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-outdated\"\u003epub outdated\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-lish\"\u003epub publish\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-run\"\u003epub run\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-upgrade\"\u003epub upgrade\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/tools/pub/cmd/pub-uploader\"\u003epub uploader\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e有关所有 pub 命令的概述，请参阅 \u003ca href=\"https://dart.dev/tools/pub/cmd\"\u003epub 工具文档\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e疑难解答\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://dart.dev/tools/pub/troubleshoot\"\u003e故障排除 pub\u003c/a\u003e 提供了使用 pub 时可能遇到的问题的解决方案。\u003c/p\u003e\n","text":"Dart 生态系统使用包来管理共享软件，如库和工具。要获得 Dart 包，你可以使用 pub 包管理器。你可以在 pub.dev 网站上找到公开的包，也可以从本地文件系统或其他地方加载包，比如 Git 仓库。无论你的包来自哪里，pub 都会管理版本依赖关系，帮助你获得相互之间以及与 SDK 版本兼容的包版本。\n大多数精通 Dart 的 IDE 都提供了对 pub 的支持，包括创建、下载、更新和发布包。或者你可以在命令行中使用 pub。\n至少，一个 Dart 包是一个包含 pubspec 文件的目录。pubspec 包含一些关于包的元数据。此外，一个包可以包含依赖关系(在 pubspec 中列出)，Dart 库，应用程序，资源，测试，图像和例子。\n要使用一个包，请执行以下操作:\n 创建一个 pubspec(一个名为 pubspec.yaml 的文件，它列出了软件包的依赖关系，并包含其他元数据，如版本号)。 使用 pub 来获取你的包的依赖关系。 如果你的 Dart 代码依赖于软件包中的一个库，则导入该库。  创建一个 pubspec pubspec 是一个名为 pubspec.yaml 的文件，它位于你的应用程序的顶级目录中。最简单的 pubspec 只列出了包名:\nname: my_app 下面是一个 pubspec 的例子，它声明了两个包(js 和 intl)的依赖关系，这两个包都托管在 pub.dev 站点上:\nname: my_app dependencies: js: ^0.6.0 intl: ^0.15.8 关于创建 pubspec 的详细信息，请参见 pubspec 文档和你要使用的包的文档。\n获取软件包 一旦你有了 pubspec，你就可以从你的应用程序的顶级目录中运行 pub get:\n$ cd \u0026lt;path-to-my_app\u0026gt; $ pub get 这个过程被称为获取依赖关系。\npub get 命令可以确定您的应用程序依赖于哪些软件包，并将它们放在中央系统缓存中。如果您的应用程序依赖于已发布的包，pub 会从 pub.dev 站点下载该包。对于 Git 依赖，pub 会克隆 Git 仓库。还包括了过渡性依赖。例如，如果 js 包依赖于 test 包，pub 会同时抓取 js 包和 test 包。\nPub 会创建一个 .packages 文件(在你的应用程序的顶层目录下)，将你的应用程序所依赖的每个包名映射到系统缓存中的对应包。\n从包中导入库 要导入在包中找到的库，使用 package: 前缀:\nimport \u0026#39;package:js/js.dart\u0026#39; as js; import \u0026#39;package:intl/intl.dart\u0026#39;; Dart 运行时在 package: 之后的所有内容都会在应用程序的 .package 文件中进行查找。\n你也可以使用这种风格从你自己的包中导入库。比方说，transmogrify 包的布局如下:\ntransmogrify/ lib/ transmogrify.dart parser.dart test/ parser/ parser_test.dart parser_test.dart 文件可以这样导入 parser.dart:\nimport \u0026#39;package:transmogrify/parser.dart\u0026#39;; 升级依赖关系 当你第一次为你的软件包获取一个新的依赖关系时，pub 会下载与你的其他依赖关系兼容的最新版本。然后，它通过创建一个 lockfile 锁文件来锁定您的软件包，使其始终使用该版本。这是一个名为 pubspec.lock 的文件，由 pub 创建并存储在 pubspec 的旁边。它列出了您的软件包所使用的每个依赖关系的特定版本 (即时的和过渡的)。\n如果你的包是一个应用程序包，你应该把这个文件检查到源代码控制中。这样，在你的应用程序上工作的每个人都会使用所有包的相同版本。在 lockfile 文件中检查也可以确保你部署的应用使用相同版本的代码。\n当你准备好将你的依赖项升级到最新版本时，使用 pub upgrade 命令:\n$ pub upgrade pub upgrade 命令告诉 pub 使用你的包的依赖关系的最新版本来重新生成 lockfile 文件。如果你只想升级一个依赖关系，你可以指定要升级的软件包:\n$ pub upgrade transmogrify 该命令将 transmogrify 升级到最新版本，但其他一切都保持不变。\n由于 pubspec 中有冲突的版本限制，pub upgrade 命令并不能总是将每个软件包升级到最新版本。要识别需要编辑 pubspec 的过期软件包，请使用 pub outdated。\n更多信息 下面的页面有更多关于软件包和 pub 包管理器的信息。\n如何使用\n 创建包 发布包  参考\n Pub 依赖 Pub 环境变量 Pub 词汇表 Pub 包布局约定 Pub 版本哲学 Pubspec 格式化  Pub 命令\npub 工具提供了以下命令:\n pub cache pub deps pub downgrade pub get pub global pub outdated pub publish pub run pub upgrade pub uploader  有关所有 pub 命令的概述，请参阅 pub 工具文档。\n疑难解答\n故障排除 pub 提供了使用 pub 时可能遇到的问题的解决方案。\n"},"name":"如何使用包","published":"2020-06-29T00:00:00+08:00","summary":"Dart 包管理工具 - pub","type":"entry","url":"https://ohmyweekly.github.io/notes/how-to-use-packages/"},{"content":{"html":"\u003cp\u003e本页列出了一些  Dart 开发者发布的最流行和最有用的\u003ca href=\"https://dart.dev/guides/packages\"\u003e包\u003c/a\u003e。要找到更多的软件包\u0026ndash;也可以搜索\u003ca href=\"https://dart.dev/guides/libraries\"\u003e核心库\u003c/a\u003e\u0026ndash;请使用 \u003ca href=\"https://pub.dev/\"\u003epub.dev\u003c/a\u003e 网站。\u003c/p\u003e\n\u003cp\u003e常用的软件包可分为三类:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/guides/libraries/useful-libraries#general-purpose-packages\"\u003e通用包\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/guides/libraries/useful-libraries#packages-that-correspond-to-sdk-libraries\"\u003e扩展 Dart 核心库的包\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/guides/libraries/useful-libraries#specialized-packages\"\u003e特定的包\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"通用包\"\u003e通用包\u003c/h2\u003e\n\u003cp\u003e以下包对各种项目都很有用:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth align=\"left\"\u003e包\u003c/th\u003e\n\u003cth align=\"left\"\u003e描述\u003c/th\u003e\n\u003cth align=\"left\"\u003e常用的 API\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/archive\"\u003earchive\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e对各种档案和压缩格式进行编码和解码。\u003c/td\u003e\n\u003ctd align=\"left\"\u003eArchive, ArchiveFile, TarEncoder, TarDecoder, ZipEncoder, ZipDecoder\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/characters\"\u003echaracters\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e对用户感知的字符进行字符串操作(Unicode 字符簇)\u003c/td\u003e\n\u003ctd align=\"left\"\u003eString.characters, Characters, CharacterRange\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/http\"\u003ehttp\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e一组高级的函数和类，使其易于消费 HTTP 资源\u003c/td\u003e\n\u003ctd align=\"left\"\u003edelete(), get(), post(), read()\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/intl\"\u003eintl\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e国际化和本地化设施，支持复数和性别、日期和数字格式化和解析以及双向文本\u003c/td\u003e\n\u003ctd align=\"left\"\u003eBidi, DateFormat, MicroMoney, TextDirection\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/json_serializable\"\u003ejson_serializable\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e一个易于使用的代码生成包。更多信息，请参阅 \u003ca href=\"https://dart.dev/guides/json\"\u003eJSON 支持\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e@JsonSerializable\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/logging\"\u003elogging\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e一个可配置的机制，为你的应用程序添加消息记录\u003c/td\u003e\n\u003ctd align=\"left\"\u003eLoggerHandler, Level, LogRecord\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/mockito\"\u003emockito\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e一个在测试中模拟对象的流行框架。如果你正在编写依赖注入的测试，特别有用。与 \u003ca href=\"https://pub.dev/packages/test\"\u003etest\u003c/a\u003e 包一起使用\u003c/td\u003e\n\u003ctd align=\"left\"\u003eAnswering, Expectation, Verification\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/path\"\u003epath\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e操作不同类型路径的常用操作。更多信息，请参见\u003ca href=\"https://news.dartlang.org/2016/06/unboxing-packages-path.html\"\u003e拆包: path\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eabsolute(), basename(), extension(), join(), normalize(), relative(), split()\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/quiver\"\u003equiver\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e实用工具，使 Dart 核心库的使用更加方便。Quiver 提供额外支持的一些库包括 async、cache、collection、core、iterables、pattern 和 测试\u003c/td\u003e\n\u003ctd align=\"left\"\u003eCountdownTimer (quiver.async); MapCache (quiver.cache); MultiMap, TreeSet (quiver.collection); EnumerateIterable (quiver.iterables); center(), compareIgnoreCase(), isWhiteSpace() (quiver.strings)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/shelf\"\u003eshelf\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eDart 的 Web 服务器中间件。Shelf 使它能轻松地创建和组成 Web 服务器，以及 Web 服务器的一部分\u003c/td\u003e\n\u003ctd align=\"left\"\u003eCascade, Pipeline, Request, Response, Server\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/stack_trace\"\u003estack_trace\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e用于解析、检查和处理由底层 Dart 实现产生的堆栈痕迹的方法。还提供了以比原生 StackTrace 实现更可读的格式生成堆栈跟踪的字符串表示的函数,  更多信息，请参见\u003ca href=\"https://news.dartlang.org/2016/01/unboxing-packages-stacktrace.html\"\u003e拆包: stack_trace\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eTrace.current(), Trace.format(), Trace.from()\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/stagehand\"\u003estagehand\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e一个 Dart 项目生成器。当你创建一个新的应用程序时，WebStorm 和 IntelliJ 使用 Stagehand 模板，但你也可以从命令行使用模板\u003c/td\u003e\n\u003ctd align=\"left\"\u003e一般通过 IDE 或 \u003ccode\u003estagehand\u003c/code\u003e 命令来使用\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/test\"\u003etest\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e在 Dart 中编写和运行测试的标准方法\u003c/td\u003e\n\u003ctd align=\"left\"\u003eexpect(), group(), test()\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/yaml\"\u003eyaml\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eYAML 解析器\u003c/td\u003e\n\u003ctd align=\"left\"\u003eloadYaml(), loadYamlStream()\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"扩展-dart-核心库的包\"\u003e扩展 Dart 核心库的包\u003c/h2\u003e\n\u003cp\u003e以下每个包都建立在一个\u003ca href=\"https://dart.dev/guides/libraries\"\u003e核心库\u003c/a\u003e的基础上，增加了功能并填补了缺失的功能:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth align=\"left\"\u003e包\u003c/th\u003e\n\u003cth align=\"left\"\u003e描述\u003c/th\u003e\n\u003cth align=\"left\"\u003e常用的 API\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/async\"\u003easync\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e在 dart:async 的基础上进行了扩展，增加了实用类来处理异步计算。更多信息，请参见\u003ca href=\"https://news.dartlang.org/2016/03/unboxing-packages-async-part-1.html\"\u003e拆包: async 第1部分\u003c/a\u003e、\u003ca href=\"https://news.dartlang.org/2016/03/unboxing-packages-async-part-2.html\"\u003e第2部分\u003c/a\u003e和\u003ca href=\"https://news.dartlang.org/2016/04/unboxing-packages-async-part-3.html\"\u003e第3部分\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eAsyncMemoizer, CancelableOperation, FutureGroup, LazyStream, Result, StreamCompleter, StreamGroup, StreamSplitter\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/collection\"\u003ecollection\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e在 dart:collection 的基础上进行了扩展，增加了实用函数和类，使处理集合的工作变得更加容易。更多信息，请看\u003ca href=\"https://news.dartlang.org/2016/01/unboxing-packages-collection.html\"\u003e拆包：collection\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eEquality, CanonicalizedMap, MapKeySet, MapValueSet, PriorityQueue, QueueList\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/convert\"\u003econvert\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e在 dart:convert 的基础上，增加了编码器和解码器，用于在不同的数据表现形式之间进行转换。其中一种数据表示方式是百分比编码，也被称为 URL 编码\u003c/td\u003e\n\u003ctd align=\"left\"\u003eHexDecoder, PercentDecoder\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca href=\"https://pub.dev/packages/io\"\u003eio\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e包含两个库，ansi和io，以简化对文件、标准流和进程的处理。使用 ansi 库可以自定义终端输出。io 库有处理进程、stdin 和文件复制的 API\u003c/td\u003e\n\u003ctd align=\"left\"\u003ecopyPath(), isExecutable(), ExitCode, ProcessManager, sharedStdIn\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"专用包\"\u003e专用包\u003c/h2\u003e\n\u003cp\u003e下面是一些寻找比较专业的包的技巧，比如手机的包(Flutter)和网页开发的包。\u003c/p\u003e\n\u003ch3 id=\"flutter-包\"\u003eFlutter 包\u003c/h3\u003e\n\u003cp\u003e请看 Flutter 网站上的\u003ca href=\"https://flutter.dev/docs/development/packages-and-plugins/using-packages\"\u003e使用包\u003c/a\u003e。或者使用 pub.dev 网站\u003ca href=\"https://pub.dev/flutter\"\u003e搜索 Flutter 包\u003c/a\u003e。\u003c/p\u003e\n\u003ch3 id=\"网络包\"\u003e网络包\u003c/h3\u003e\n\u003cp\u003e参见\u003ca href=\"https://dart.dev/web/libraries\"\u003e网络库和包\u003c/a\u003e。或者使用 pub.dev 站点\u003ca href=\"https://pub.dev/web\"\u003e搜索 web 包\u003c/a\u003e。\u003c/p\u003e\n\u003ch3 id=\"命令行和服务器软件包\"\u003e命令行和服务器软件包\u003c/h3\u003e\n\u003cp\u003e参见\u003ca href=\"https://dart.dev/server/libraries\"\u003e命令行和服务器库和包\u003c/a\u003e。或者使用 pub.dev 站点\u003ca href=\"https://pub.dev/\"\u003e搜索其他包\u003c/a\u003e。\u003c/p\u003e\n","text":"本页列出了一些 Dart 开发者发布的最流行和最有用的包。要找到更多的软件包\u0026ndash;也可以搜索核心库\u0026ndash;请使用 pub.dev 网站。\n常用的软件包可分为三类:\n 通用包 扩展 Dart 核心库的包 特定的包  通用包 以下包对各种项目都很有用:\n   包 描述 常用的 API     archive 对各种档案和压缩格式进行编码和解码。 Archive, ArchiveFile, TarEncoder, TarDecoder, ZipEncoder, ZipDecoder   characters 对用户感知的字符进行字符串操作(Unicode 字符簇) String.characters, Characters, CharacterRange   http 一组高级的函数和类，使其易于消费 HTTP 资源 delete(), get(), post(), read()   intl 国际化和本地化设施，支持复数和性别、日期和数字格式化和解析以及双向文本 Bidi, DateFormat, MicroMoney, TextDirection   json_serializable 一个易于使用的代码生成包。更多信息，请参阅 JSON 支持 @JsonSerializable   logging 一个可配置的机制，为你的应用程序添加消息记录 LoggerHandler, Level, LogRecord   mockito 一个在测试中模拟对象的流行框架。如果你正在编写依赖注入的测试，特别有用。与 test 包一起使用 Answering, Expectation, Verification   path 操作不同类型路径的常用操作。更多信息，请参见拆包: path absolute(), basename(), extension(), join(), normalize(), relative(), split()   quiver 实用工具，使 Dart 核心库的使用更加方便。Quiver 提供额外支持的一些库包括 async、cache、collection、core、iterables、pattern 和 测试 CountdownTimer (quiver.async); MapCache (quiver.cache); MultiMap, TreeSet (quiver.collection); EnumerateIterable (quiver.iterables); center(), compareIgnoreCase(), isWhiteSpace() (quiver.strings)   shelf Dart 的 Web 服务器中间件。Shelf 使它能轻松地创建和组成 Web 服务器，以及 Web 服务器的一部分 Cascade, Pipeline, Request, Response, Server   stack_trace 用于解析、检查和处理由底层 Dart 实现产生的堆栈痕迹的方法。还提供了以比原生 StackTrace 实现更可读的格式生成堆栈跟踪的字符串表示的函数, 更多信息，请参见拆包: stack_trace Trace.current(), Trace.format(), Trace.from()   stagehand 一个 Dart 项目生成器。当你创建一个新的应用程序时，WebStorm 和 IntelliJ 使用 Stagehand 模板，但你也可以从命令行使用模板 一般通过 IDE 或 stagehand 命令来使用   test 在 Dart 中编写和运行测试的标准方法 expect(), group(), test()   yaml YAML 解析器 loadYaml(), loadYamlStream()    扩展 Dart 核心库的包 以下每个包都建立在一个核心库的基础上，增加了功能并填补了缺失的功能:\n   包 描述 常用的 API     async 在 dart:async 的基础上进行了扩展，增加了实用类来处理异步计算。更多信息，请参见拆包: async 第1部分、第2部分和第3部分 AsyncMemoizer, CancelableOperation, FutureGroup, LazyStream, Result, StreamCompleter, StreamGroup, StreamSplitter   collection 在 dart:collection 的基础上进行了扩展，增加了实用函数和类，使处理集合的工作变得更加容易。更多信息，请看拆包：collection Equality, CanonicalizedMap, MapKeySet, MapValueSet, PriorityQueue, QueueList   convert 在 dart:convert 的基础上，增加了编码器和解码器，用于在不同的数据表现形式之间进行转换。其中一种数据表示方式是百分比编码，也被称为 URL 编码 HexDecoder, PercentDecoder   io 包含两个库，ansi和io，以简化对文件、标准流和进程的处理。使用 ansi 库可以自定义终端输出。io 库有处理进程、stdin 和文件复制的 API copyPath(), isExecutable(), ExitCode, ProcessManager, sharedStdIn    专用包 下面是一些寻找比较专业的包的技巧，比如手机的包(Flutter)和网页开发的包。\nFlutter 包 请看 Flutter 网站上的使用包。或者使用 pub.dev 网站搜索 Flutter 包。\n网络包 参见网络库和包。或者使用 pub.dev 站点搜索 web 包。\n命令行和服务器软件包 参见命令行和服务器库和包。或者使用 pub.dev 站点搜索其他包。\n"},"name":"常用的包","published":"2020-06-29T00:00:00+08:00","summary":"Commonly used packages","type":"entry","url":"https://ohmyweekly.github.io/notes/commonly-used-packages/"}],"name":"packages","type":"feed","url":"https://ohmyweekly.github.io/tags/packages/"}