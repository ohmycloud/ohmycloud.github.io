<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.79.0">Hugo</generator><title type="html"><![CDATA[Dart on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/dart/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/dart/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/dart/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/dart/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2021-04-05T19:55:25+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/dart/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Understanding Null Safety]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-03-05-understanding-null-safety/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2021-03-05-understanding-null-safety/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-03-05T00:00:00+08:00</published>
            <updated>2021-03-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Understanding Null Safety</blockquote><p>空值安全是我们在 Dart 2.0 中用<a href="https://dart.dev/guides/language/type-system">健全的静态类型系统</a>取代了原来的不健全的可选类型系统后，对 Dart 做出的最大改变。当 Dart 刚推出的时候，编译时空安全是一个罕见的功能，需要长时间的介绍。今天，Kotlin、Swift、Rust 和其他语言都有自己的答案，这已经成为一个非常<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">熟悉的问题</a>。下面是一个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Without null safety:
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">isEmpty</span><span class="p">(</span><span class="kt">String</span> <span class="n">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">string</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="m">0</span><span class="p">;</span>

<span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">isEmpty</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>如果你在没有 null 安全的情况下运行这个 Dart 程序，它就会在调用.length 时抛出一个 NoSuchMethodError 异常。<code>null</code> 值是 <code>Null</code> 类的一个实例，而 Null 没有 &ldquo;length&rdquo; getter。运行时的失败很糟糕。这在像 Dart 这样的语言中尤其如此，因为它被设计成在终端用户的设备上运行。如果一个服务器应用程序失败了，你通常可以在任何人注意到之前重新启动它。但是当一个 Flutter 应用在用户的手机上崩溃时，他们并不高兴。当你的用户不高兴时，你也不高兴。</p>
<p>开发者喜欢像 Dart 这样的静态类型语言，因为它们可以让类型检查器在编译时发现代码中的错误，通常就在 IDE 中。越早发现错误，就能越早修复它。当语言设计者谈论 &ldquo;修复空值引用错误&quot;时，他们的意思是丰富静态类型检查器，使语言能够检测到像上面试图在一个可能是空的值上调用 <code>.length</code> 这样的错误。</p>
<p>对于这个问题，没有一个真正的解决方案。Rust 和 Kotlin 都有自己的方法，在这些语言的上下文中是有意义的。这个文档详细介绍了我们对 Dart 的答案。它包括对静态类型系统的修改，以及一系列其他的修改和新的语言特性，让你不仅能写出空值安全的代码，而且希望能享受这样做的乐趣。</p>
<p>这个文档很长。如果你想看一些较短的文件，它只涵盖了你需要知道的东西，以便开始运行，请从<a href="https://dart.dev/null-safety">概述</a>开始。当你准备好了更深入的理解，并且有时间的时候，请回到这里，这样你就可以理解这个语言是如何处理 <code>null</code> 的，为什么我们要这样设计它，以及如何写出习惯的，现代的，空值安全的 Dart。(Spoiler alert: 它最终会出人意料地接近你今天写 Dart 的方式。)</p>
<p>语言处理空值引用错误的各种方法各有优缺点。这些原则指导了我们的选择。</p>
<ul>
<li>代码默认情况下应该是安全的。如果你写了新的 Dart 代码，并且没有使用任何显式的不安全特性，它永远不会在运行时抛出一个空值引用错误。所有可能的空值引用错误都会被静态地捕获。如果你想将一些检查推迟到运行时以获得更大的灵活性，你可以，但你必须通过使用一些在代码中文本可见的功能来选择。</li>
</ul>
<p>换句话说，我们并不是给你一件救生衣，让你每次出海时都记得穿上它。相反，我们给你一艘不沉的船。除非你跳海，否则你会保持干燥。</p>
<ul>
<li>空值安全代码应该很容易写。大多数现有的 Dart 代码都是动态正确的，不会出现空值引用错误。你喜欢你的 Dart 程序现在的样子，我们希望你能够继续这样写代码。安全性不应该要求牺牲可用性，对类型检查器进行忏悔，或者必须显著改变你的思维方式。</li>
</ul>
<p>由此产生的空安全代码应该是完全健全的。在静态检查的上下文中，&ldquo;健全&quot;对不同的人意味着不同的东西。对我们来说，在空值安全的上下文中，这意味着如果一个表达式的静态类型不允许空，那么该表达式的任何可能的执行都不可能评估为空。语言主要通过静态检查来提供这种保证，但也可以涉及一些运行时检查。虽然，注意第一个原则：任何发生这些运行时检查的地方都将是你的选择）。</p>
<p>健全性对于用户的信心很重要。一艘大部分时间都保持漂浮的船，并不是你热衷于在公海上冒险的船。但它对我们无畏的编译器黑客来说也很重要。当语言对程序的语义属性做出硬性保证时，意味着编译器可以执行假设这些属性为真的优化。当涉及到 <code>null</code> 时，这意味着我们可以生成更小的代码，消除不需要的 <code>null</code> 检查，以及更快的代码，不需要在调用方法之前验证接收器是非 null。</p>
<p>有一个注意事项：我们只保证完全空值安全的 Dart 程序的健全性。Dart 支持包含新的空值安全代码和旧的遗留代码混合的程序。在这些混合版本的程序中，仍然可能发生空值引用错误。在一个混合版本的程序中，你可以在空值安全的部分获得所有的静态安全优势，但是在整个应用程序是空安全的之前，你不能获得完整的运行时健全性。</p>
<p>请注意，消除 <code>null</code> 并不是一个目标。<code>null</code> 没有什么不好。相反，能够表示一个值的缺失真的很有用。直接在语言中构建对特殊的 &ldquo;absence&rdquo; 值的支持，使得处理缺失的工作变得灵活和可用。它是可选参数、方便的 <code>?.</code> null-aware 操作符和默认初始化的基础。并不是 null 不好，而是让 null 去了你想不到的地方才会引起问题。</p>
<p>因此，有了 null 安全，我们的目标是让你控制和洞察 null 可以流经你的程序的地方，并确定它不能流到某个地方，从而导致崩溃。</p>
<h2 id="类型系统中的空值">类型系统中的空值</h2>
<p>空值安全始于静态类型系统，因为其他一切都建立在静态类型系统之上。你的 Dart 程序中有一个完整的类型宇宙：像 int 和 String 这样的基元类型，像 List 这样的集合类型，以及所有你和你使用的包所定义的类和类型。在 null 安全之前，静态类型系统允许值 null 流入任何这些类型的表达式中。</p>
<p>在类型理论的行话中，Null 类型被视为所有类型的一个子类型。</p>
<p><img src="https://dart.dev/null-safety/understanding-null-safety/hierarchy-before.png" alt="img"></p>
<p>在某些表达式上允许的操作集 - getters、setters、methods 和 operator - 由其类型定义。如果类型是 List，你可以对它调用. <code>add()</code> 或 <code>[]</code>。如果它是 int，你可以调用 <code>+</code>。但是空值并没有定义任何这些方法。允许 null 流入其他类型的表达式意味着任何这些操作都可能失败。这就是 null 引用错误的真正症结所在 - 每一次失败都来自于试图在 null 上查找一个它没有的方法或属性。</p>
<h2 id="非可空类型和可空类型">非可空类型和可空类型</h2>
<p>Null 安全通过改变类型层次结构，从根本上消除了这个问题。Null 类型仍然存在，但它不再是所有类型的子类型。取而代之的是，类型层次结构是这样的。</p>
<p><img src="https://dart.dev/null-safety/understanding-null-safety/hierarchy-after.png" alt="img"></p>
<p>由于 Null 不再是子类型, 除了特殊的 <code>Null</code> 类之外，没有任何类型允许值为 null。我们已经将所有类型默认为不可空值。如果你有一个 String 类型的变量，它将总是包含一个字符串。在那里，我们已经修复了所有的空值引用错误。</p>
<p>如果我们认为 null 根本没有用，我们可以在这里停止。但是 null 是有用的，所以我们仍然需要一种方法来处理它。可选参数就是一个很好的说明性案例。考虑一下这个 null 安全的 Dart 代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="n">makeCoffee</span><span class="p">(</span><span class="kt">String</span> <span class="n">coffee</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="o">?</span> <span class="n">dairy</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dairy</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">$</span><span class="n">coffee</span><span class="s1"> with </span><span class="si">$</span><span class="n">dairy</span><span class="s1">&#39;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Black </span><span class="si">$</span><span class="n">coffee</span><span class="s1">&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在这里，我们希望允许 dairy 参数接受任何字符串，或者接受 null 值，而不接受其他任何值。为了表达这一点，我们在底层基类型 String 的结尾处加上 <code>?</code>。 从本质上讲，这就是定义了一个底层类型和 Null 类型的<a href="https://en.wikipedia.org/wiki/Union_type">联合</a>。所以，如果 Dart 有全功能的联合类型，那么 <code>String?</code> 将是 <code>String|Null</code> 的简写。</p>
<h2 id="使用可空类型">使用可空类型</h2>
<p>如果你有一个可空类型的表达式，你可以用这个结果做什么？由于我们的原则默认是安全的，所以答案是不多，我们不能让你对它调用底层类型的方法，因为如果值是空的，这些方法可能会失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Hypothetical unsound null safety:
</span><span class="c1"></span><span class="n">bad</span><span class="p">(</span><span class="kt">String</span><span class="o">?</span> <span class="n">maybeString</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">maybeString</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">bad</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>如果我们让你运行它，就会崩溃。我们唯一可以安全地让你访问的方法和属性是由底层类型和 Null 类定义的。那就是 <code>toString()</code>、<code>==</code> 和 <code>hashCode</code>。因此，你可以使用可空类型作为映射键，将它们存储在集合中，将它们与其他值进行比较，并在字符串插值中使用它们，但仅此而已。</p>
<p>它们如何与非可空类型交互？将一个不可空值类型传递给期望空值类型的东西总是安全的。如果一个函数接受 String 吗，那么传递一个 String 是允许的，因为它不会引起任何问题。我们通过使每个可空类型成为其底层类型的超类型来建立模型。你也可以安全地把 null 传给期望是可空类型的东西，所以 Null 也是每个可空类型的一个子类型。</p>
<p><img src="https://dart.dev/null-safety/understanding-null-safety/nullable-hierarchy.png" alt="img"></p>
<p>但是反过来说，把一个可空类型传递给期待底层非可空类型的东西是不安全的。期待一个 String 的代码可以在值上调用 String 方法。如果你把一个 <code>String?</code> 传给它，null 可能会流进来，这可能会失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Hypothetical unsound null safety:
</span><span class="c1"></span><span class="n">requireStringNotNull</span><span class="p">(</span><span class="kt">String</span> <span class="n">definitelyString</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">definitelyString</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">String</span><span class="o">?</span> <span class="n">maybeString</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// Or not!
</span><span class="c1"></span>  <span class="n">requireStringNotNull</span><span class="p">(</span><span class="n">maybeString</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>这个程序不安全，我们不应该允许它。然而，Dart 一直有这个东西，叫做隐式下传。例如，如果你把一个 Object 类型的值传递给一个期望为 String 的函数，类型检查器就会允许它。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Without null safety:
</span><span class="c1"></span><span class="n">requireStringNotObject</span><span class="p">(</span><span class="kt">String</span> <span class="n">definitelyString</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">definitelyString</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">Object</span> <span class="n">maybeString</span> <span class="o">=</span> <span class="s1">&#39;it is&#39;</span><span class="p">;</span>
  <span class="n">requireStringNotObject</span><span class="p">(</span><span class="n">maybeString</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>为了保持合理性，编译器在 requireStringNotObject() 的参数上默默地插入了一个 <code>as String</code> cast。这个转码可能会在运行时失败并抛出一个异常，但在编译时，Dart 说这是确定的。由于非可空类型被建模为可空类型的子类型，所以隐式下投会让你把一个 <code>String?</code> 传递给期待一个 String 的东西。允许这样做会违反我们默认安全的目标。所以，有了空值安全，我们就完全取消了隐式下传。</p>
<p>这使得对 requireStringNotNull() 的调用会产生一个编译错误，这是你想要的。但这也意味着所有的隐式下包都会成为编译错误，包括对 requireStringNotObject() 的调用。你必须自己添加显式下传。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="n">requireStringNotObject</span><span class="p">(</span><span class="kt">String</span> <span class="n">definitelyString</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">definitelyString</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">Object</span> <span class="n">maybeString</span> <span class="o">=</span> <span class="s1">&#39;it is&#39;</span><span class="p">;</span>
  <span class="n">requireStringNotObject</span><span class="p">(</span><span class="n">maybeString</span> <span class="o">as</span> <span class="kt">String</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>我们认为这总体上是一个好的变化。在我们的印象中，大多数用户从来都不喜欢隐性降频。尤其是，你可能之前就被这个烧过。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Without null safety:
</span><span class="c1"></span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">filterEvens</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">ints</span><span class="p">.</span><span class="n">where</span><span class="p">((</span><span class="n">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">n</span><span class="p">.</span><span class="n">isEven</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>发现错误了吗？<code>.where()</code> 方法是懒惰的，所以它返回的是一个 Iterable，而不是 List。这个程序在编译时，当它试图将 Iterable 投射到 filterEvens 声明它返回的 List 类型时，会在运行时抛出一个异常。移除隐式下投后，这就变成了一个编译错误。</p>
<p>我们说到哪里了？对了，好吧，就好像我们把你程序中的类型宇宙分成了两半。</p>
<p><img src="https://dart.dev/null-safety/understanding-null-safety/bifurcate.png" alt="img"></p>
<p>有一个非空值类型的区域。这些类型让你可以访问所有有趣的方法，但永远不能包含 null。然后是一个由所有相应的可空类型组成的平行家族。这些类型允许 null，但你不能对它们做太多事情。我们让值从非可空侧流向可空侧，因为这样做是安全的，但不是其他方向。</p>
<p>这样看来，可空类型基本上是无用的。它们没有方法，你无法摆脱它们。别担心，我们有一整套的功能来帮助你把值从可空型的一半移到另一边，我们很快就会讲到。</p>
<p>顶部和底部
这一部分有点深奥。你可以跳过它，除了最后的两个子弹，除非你对类型系统感兴趣。想象一下，在你的程序中，所有的类型之间都有边缘，它们是彼此的子类型和超类型。如果你把它画出来，就像这个文档中的图一样，它将形成一个巨大的有向图，上面有像 Object 这样的超类型，下面有像你自己的类型这样的叶子类。</p>
<p>如果这个有向图到了顶部，有一个单一的类型是超类型（直接或间接），这个类型就被称为顶部类型。同样，如果在那个底部有一个奇怪的类型是每个类型的子类型，你就有一个底部类型。在这种情况下，你的有向图是一个网格）。</p>
<p>如果你的类型系统有顶层和底层类型，那是很方便的，因为这意味着像最小上界这样的类型级操作（类型推理使用它来根据一个条件表达式的两个分支的类型找出它的类型）总是可以产生一个类型。在 null 安全之前，Object 是 Dart 的顶层类型，Null 是其底层类型。</p>
<p>由于现在 Object 是不可空的，所以它不再是顶类型。Null 不是它的子类型。Dart 没有命名的顶类型。如果你需要一个顶类型，你要 Object? 同样，Null 也不再是底层类型。如果是的话，一切都还会是 null。相反，我们添加了一个新的底层类型，名为 Never。</p>
<p><img src="https://dart.dev/null-safety/understanding-null-safety/top-and-bottom.png" alt="img"></p>
<p>在实践中，这意味着。</p>
<p>如果你想表明你允许任何类型的值，就用 Object? 而不是 Object. 事实上，使用 Object 就变得很不寻常了，因为该类型意味着 &ldquo;可能是任何可能的值，除了这个奇怪的禁止值 null&rdquo;。</p>
<p>在极少数情况下，你需要一个底层类型，用 Never 代替 Null。如果你不知道是否需要底层类型，你可能不需要。</p>
<h2 id="确保正确性">确保正确性</h2>
<p>我们将类型的宇宙分为可空和不可空的两半。为了保持健全性和我们的原则，即除非你要求，否则你永远不会在运行时得到一个 null 引用错误，我们需要保证 null 永远不会出现在非 nullable 端的任何类型中。</p>
<p>摆脱隐式下传，去掉 Null 这个底层类型，涵盖了类型在程序中跨赋值流转和在函数调用中从参数流转到参数的所有主要地方。剩下的主要的 null 可以潜入的地方是当一个变量第一次出现和离开一个函数的时候。所以会出现一些额外的编译错误。</p>
<h3 id="无效返回">无效返回</h3>
<p>如果一个函数的返回类型是非空的，那么通过该函数的每一条路径都必须到达一个返回值的返回语句。在 null 安全之前，Dart 对于缺失返回的情况非常宽松。比如说</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Without null safety:
</span><span class="c1"></span><span class="kt">String</span> <span class="n">missingReturn</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// No return.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>如果你分析这个，你就会得到一个温柔的提示，也许你忘了一个返回，但如果没有，也没什么大不了的。这是因为如果执行到了函数体的末端，那么 Dart 就会隐式返回 null。由于每个类型都是可空的，所以从技术上讲，这个函数是安全的，尽管它可能不是你想要的。</p>
<p>对于健全的非可空类型，这个程序是完全错误的，不安全的。在空值安全下，如果一个具有非可空值返回类型的函数不能可靠地返回一个值，你会得到一个编译错误。所谓 &ldquo;可靠&rdquo;，是指语言分析了所有通过函数的控制流路径。只要它们都能返回一些东西，它就满足了。这个分析是相当聪明的，所以即使这个函数也是可以的。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kt">String</span> <span class="n">alwaysReturns</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;zero&#39;</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="n">ArgumentError</span><span class="p">(</span><span class="s1">&#39;Negative values not allowed.&#39;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="m">1000</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s1">&#39;big&#39;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">n</span><span class="p">.</span><span class="n">toString</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>我们将在下一节更深入地研究新的流程分析。</p>
<h3 id="未初始化的变量">未初始化的变量</h3>
<p>当你声明一个变量时，如果你没有给它一个显式的初始化器，Dart 默认用 null 初始化变量。这很方便，但如果变量的类型是不可空的，显然是完全不安全的。所以我们必须对不可空值的变量进行严格的规定。</p>
<ul>
<li>顶级变量和静态字段的声明必须有一个初始化器。由于这些变量可以在程序中的任何地方被访问和赋值，编译器不可能保证变量在被使用之前就已经被赋予了一个值。唯一安全的选择是要求声明本身有一个初始化表达式，产生一个正确类型的值。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kt">int</span> <span class="n">topLevel</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">SomeClass</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kt">int</span> <span class="n">staticField</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>实例字段必须在声明时有一个初始化器，使用初始化形式，或者在构造函数的初始化列表中初始化。这有很多行话。下面是例子。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">SomeClass</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">atDeclaration</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">initializingFormal</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">initializationList</span><span class="p">;</span>

  <span class="n">SomeClass</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">initializingFormal</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">initializationList</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>换句话说，只要字段在到达构造函数体之前就有一个值，就可以了。</p>
<ul>
<li>局部变量是最灵活的情况。一个不可空的局部变量不需要有一个初始化器。这完全可以。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kt">int</span> <span class="n">tracingFibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="m">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">tracingFibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="m">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">tracingFibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="m">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">print</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>规则只是局部变量在使用前必须肯定分配。我们也可以依靠我所提到的新流分析来实现。只要每个通往变量使用的路径都先初始化它，使用就可以了。</p>
<ul>
<li>可选参数必须有一个默认值。如果你没有为一个可选的位置参数或命名参数传递一个参数，那么语言就会用默认值来填充它。如果你不指定默认值，那么默认的默认值就是 null，如果参数的类型是不可空的，那就飞不起来了。</li>
</ul>
<p>所以，如果你想让一个参数是可选的，你需要让它变成 null，或者指定一个有效的非空的默认值。</p>
<p>这些限制听起来很繁琐，但在实践中并不太坏。它们与现有的围绕最终变量的限制非常相似，而且你可能已经使用这些限制多年，甚至没有真正注意到。另外，请记住，这些限制只适用于不可空值的变量。你总是可以让类型可空，然后让默认初始化为空。</p>
<p>即便如此，这些规则也会造成摩擦。幸运的是，我们有一套新的语言特性来润滑最常见的模式，在这些新的限制下，你的速度变慢了。不过，首先，是时候谈谈流分析了。</p>
<h2 id="流程分析">流程分析</h2>
<p><a href="https://en.wikipedia.org/wiki/Control_flow_analysis">控制流分析</a>在编译器中已经存在多年。它大多被用户隐藏起来，在编译器优化过程中使用，但一些新的语言已经开始使用同样的技术来实现可见的语言功能。Dart 已经在类型推广的形式下有了一抹流分析。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// With (or without) null safety:
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">isEmptyList</span><span class="p">(</span><span class="kt">Object</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="k">is</span> <span class="n">List</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">object</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">;</span> <span class="c1">// &lt;-- OK!
</span><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>请注意，在标记行中，我们可以在对象上调用 isEmpty。该方法定义在 List 上，而不是 Object 上。这是因为类型检查器会查看程序中所有的 is 表达式和控制流路径。如果某个控制流构造体只有在变量上的某个 is 表达式为真时才会执行，那么在这个构造体里面，变量的类型就会被 &ldquo;推广 &ldquo;到测试类型。</p>
<p>在这里的例子中，if 语句的 then 分支只有在 object 实际包含一个 list 时才会运行。因此，Dart 将对象推广到 List 类型，而不是其声明的 Object 类型。这是一个方便的功能，但它是相当有限的。在 null 安全之前，下面的功能相同的程序无法工作。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Without null safety:
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">isEmptyList</span><span class="p">(</span><span class="kt">Object</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="k">is</span><span class="o">!</span> <span class="n">List</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">object</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">;</span> <span class="c1">// &lt;-- Error!
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>同样，只有当对象包含一个 list 时，才能达到.isEmpty 的调用，所以这个程序是动态正确的。但是类型推广规则不够聪明，没有看到返回语句意味着只有当对象是一个 list 时才能到达第二个语句。</p>
<p>对于空安全，我们把这种有限的分析方法，在几个方面做得更加强大。</p>
<h3 id="可到达性分析">可到达性分析</h3>
<p>首先，我们修复了<a href="https://github.com/dart-lang/sdk/issues/18921">长期以来的抱怨</a>，即类型推广对早期返回和其他无法到达的代码路径并不聪明。当分析一个函数时，它现在会考虑到返回、break、抛出以及函数中任何其他可能提前终止执行的方式。在空安全下，这个函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">isEmptyList</span><span class="p">(</span><span class="kt">Object</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="k">is</span><span class="o">!</span> <span class="n">List</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">object</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>现在是完全有效的。因为 if 语句会在对象不是 List 时退出函数，所以 Dart 会在第二条语句中促进对象成为 List。这是一个非常好的改进，它帮助了很多 Dart 代码，甚至是与 nullability 无关的东西。</p>
<h3 id="never---不可达到的代码">Never - 不可达到的代码</h3>
<p>您也可以对这种可达到性分析进行编程。新的底类型 Never 没有值。(什么样的值同时是 String、bool 和 int 呢？)那么一个表达式具有 Never 类型意味着什么呢？意味着该表达式永远不能成功完成评估。它必须抛出一个异常，中止，或者以其他方式确保期望表达式结果的周围代码永远不会运行。</p>
<p>事实上，根据语言的规定，抛出表达式的静态类型是 Never。Never 类型在核心库中被声明，你可以将其作为类型注释。也许你有一个帮助函数，以方便抛出某种异常。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="n">Never</span> <span class="n">wrongType</span><span class="p">(</span><span class="kt">String</span> <span class="n">type</span><span class="p">,</span> <span class="kt">Object</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="n">ArgumentError</span><span class="p">(</span><span class="s1">&#39;Expected </span><span class="si">$</span><span class="n">type</span><span class="s1">, but was </span><span class="si">${</span><span class="n">value</span><span class="p">.</span><span class="n">runtimeType</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>你可以这样使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Point</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="kd">operator</span> <span class="o">==</span><span class="p">(</span><span class="kt">Object</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">other</span> <span class="k">is</span><span class="o">!</span> <span class="n">Point</span><span class="p">)</span> <span class="n">wrongType</span><span class="p">(</span><span class="s1">&#39;Point&#39;</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Constructor and hashCode...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>这个程序分析起来没有错误。请注意，==方法的最后一行访问了其他的.x 和.y。尽管函数没有任何返回或抛出，但它已经被提升为 Point。控制流分析知道，wrongType()的声明类型是 Never，这意味着 if 语句的 then 分支必须以某种方式中止。由于第二条语句只有在 other 是 Point 时才能到达，所以 Dart 提倡使用它。</p>
<p>换句话说，在你自己的 API 中使用 Never 可以让你扩展 Dart 的可达性分析。</p>
<h3 id="确定赋值分析">确定赋值分析</h3>
<p>这个我简单的提到了局部变量。Dart 需要确保一个不可空的局部变量在读取之前总是被初始化。我们使用确定赋值分析来尽可能灵活地处理这个问题。该语言分析每个函数体，并通过所有控制流路径跟踪局部变量和参数的赋值。只要在每一条到达某个使用变量的路径上都对变量进行了赋值，就认为该变量已经初始化。这让你可以在没有初始化器的情况下声明一个变量，然后在之后使用复杂的控制流对其进行初始化，即使该变量具有不可空值的类型。</p>
<p>我们还使用确定赋值分析来使最终变量更加灵活。在空安全之前，如果你需要以任何一种有趣的方式对局部变量进行初始化，那么使用 final 是很困难的。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kt">int</span> <span class="n">tracingFibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="m">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">tracingFibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="m">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">tracingFibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="m">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">print</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这将是一个错误，因为结果变量是 final，但没有初始化器。在空安全下进行更智能的流分析，这个程序是没有问题的。分析可以知道，在每条控制流路径上，result 肯定是精确地初始化了一次，所以标记变量 final 的约束条件是满足的。</p>
<h3 id="对空检查的类型提升">对空检查的类型提升</h3>
<p>更加智能的流程分析帮助了很多 Dart 代码，甚至是与空性无关的代码。但我们现在做这些改变并不是偶然的。我们把类型分为可空性和非可空性集。如果你有一个可空类型的值，你就不能真正对它做任何有用的事情。在值为空的情况下，这种限制是好的。它可以防止你崩溃。</p>
<p>但如果值不是空的，能够把它移到非可空的一面，这样你就可以对它调用方法，这将是一件好事。对于局部变量和参数来说，流程分析是实现这一点的主要方法之一。我们已经扩展了类型提升，还可以查看 <code>== null</code> 和 <code>!= null</code> 表达式。</p>
<p>如果你检查一个可空类型的变量，看看它是不是空的，Dart 就会把这个变量推广到底层的非可空类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kt">String</span> <span class="n">makeCommand</span><span class="p">(</span><span class="kt">String</span> <span class="n">executable</span><span class="p">,</span> <span class="p">[</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;?</span> <span class="n">arguments</span><span class="p">])</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">result</span> <span class="o">=</span> <span class="n">executable</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">arguments</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">arguments</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这里，arguments 有一个可空的类型。通常，这禁止你对它调用.join()。但是由于我们在 if 语句中对该调用进行了保护，检查以确保该值不是空的，所以 Dart 将其从  <code>List&lt;String&gt;</code> 提升为 <code>List&lt;String&gt;</code>，并允许你在其上调用方法或将其传递给期望非空值列表的函数。</p>
<p>这听起来是一件相当小的事情，但这种基于流程的对 null 检查的推广是使大多数现有 Dart 代码在 null 安全下工作的原因。大多数 Dart 代码都是动态正确的，并且确实通过在调用方法之前检查空值来避免抛出空值引用错误。新的关于 null 检查的流程分析将这种动态正确性变成了可证明的静态正确性。</p>
<p>当然，它也能配合我们对可到达性的更智能的分析。上面的函数也可以写成一样。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kt">String</span> <span class="n">makeCommand</span><span class="p">(</span><span class="kt">String</span> <span class="n">executable</span><span class="p">,</span> <span class="p">[</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;?</span> <span class="n">arguments</span><span class="p">])</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">result</span> <span class="o">=</span> <span class="n">executable</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">arguments</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">arguments</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>语言也比较聪明，什么样的表达方式会引起推广。显式 <code>== null</code> 或 <code>!= null</code> 当然可以。但是，使用 as、assignments 或我们即将提到的后缀 <code>!</code> 操作符的显式投掷也会导致提升。总的目标是，如果代码是动态正确的，而且静态地找出这一点是合理的，分析应该足够聪明。</p>
<h3 id="不必要的代码警告">不必要的代码警告</h3>
<p>拥有更智能的可达性分析，并知道 null 可能流经你的程序的地方，有助于确保你添加代码来处理 null。但我们也可以用同样的分析来检测你不需要的代码。在 null 安全之前，如果你写了这样的东西。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kt">String</span> <span class="n">checkList</span><span class="p">(</span><span class="n">List</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">?</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;Got nothing&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="s1">&#39;Got something&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Dart 没有办法知道那个 <code>null-aware?</code> 操作符是否有用。它只知道，你可以把 null 传给函数。但是在 null safe Dart 中，如果你用现在不可空的 List 类型注释了那个函数，那么它知道 list 永远不会是 null。这就意味着这个 <code>?.</code> 永远不会做任何有用的事情，你可以而且应该只使用 <code>.</code> 类型。</p>
<p>为了帮助你简化你的代码，我们已经为这样的不必要的代码添加了警告，现在静态分析已经精确到可以检测到它了。在一个不可空类型上使用一个 null-aware 操作符，甚至是像<code>== null</code> 或 <code>!= null</code> 这样的检查，都会被报告为一个警告。</p>
<p>当然，这也与非空类型的晋升有关。一旦一个变量被推广到一个不可空类型，如果你再次对它进行多余的 null 检查，你会得到一个警告。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="n">checkList</span><span class="p">(</span><span class="n">List</span><span class="o">?</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">list</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="s1">&#39;No list&#39;</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">?</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;Empty list&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="s1">&#39;Got something&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>你在这里得到了一个警告，因为在它执行的时候，我们已经知道 list 不能为空。这些警告的目的不仅仅是清理无意义的代码。通过删除不需要的 null 检查，我们确保剩下的有意义的检查能够脱颖而出。我们希望您能够查看您的代码，并看到 null 可以在哪里流动。</p>
<h2 id="使用可空类型-1">使用可空类型</h2>
<p>我们现在已经把 null 收进了可空类型的集合。通过流程分析，我们可以安全地让一些非空值越过栅栏跳到非可空类型的一边，在那里我们可以使用它们。这是一个很大的进步，但如果我们在这里停下来，所产生的系统仍然是痛苦的限制。流程分析只对局部和参数有帮助。</p>
<p>为了尽量恢复 Dart 在 null 安全之前的灵活性&ndash;并且在某些地方超越它，我们有一些其他的新特性。</p>
<h3 id="更加智能的空感知方法">更加智能的空感知方法</h3>
<p>Dart 的 null aware 操作符 <code>?.</code> 比 null safety 更早。运行时语义规定，如果接收者为空，那么右侧的属性访问将被跳过，表达式评价为空。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Without null safety:
</span><span class="c1"></span><span class="kt">String</span> <span class="n">notAString</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">notAString</span><span class="o">?</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
</code></pre></div><p>这不是抛出一个异常，而是打印 &ldquo;null&rdquo;。null-aware 操作符是一个很好的工具，它使可空类型在 Dart 中可用。虽然我们不能让你在可空类型上调用方法，但我们可以也确实让你在它们上使用 null-aware 操作符。空值后安全版本的程序是。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kt">String</span><span class="o">?</span> <span class="n">notAString</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">notAString</span><span class="o">?</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
</code></pre></div><p>它的工作原理和之前的一样。</p>
<p>然而，如果你曾经在 Dart 中使用过 null-aware 操作符，当你在方法链中使用它们时，你可能会遇到一个烦恼。比方说，你想看看一个可能不存在的字符串的长度是否是一个偶数（不是一个特别现实的问题，我知道，但请和我一起工作）。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kt">String</span><span class="o">?</span> <span class="n">notAString</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">notAString</span><span class="o">?</span><span class="p">.</span><span class="n">length</span><span class="p">.</span><span class="n">isEven</span><span class="p">);</span>
</code></pre></div><p>即使这个程序使用了?，但在运行时还是会抛出一个异常。问题在于.isEven 表达式的接收者是它左边的整个 notAString?.length 表达式的结果。该表达式的值为 null，所以我们在尝试调用.isEven 时得到一个空值引用错误。如果你曾经在 Dart 中使用过?.，你可能学到了一个苦涩的方法，那就是在你使用过一次之后，你必须将 null-aware 操作符应用到链中的每个属性或方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">String</span><span class="o">?</span> <span class="n">notAString</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">notAString</span><span class="o">?</span><span class="p">.</span><span class="n">length</span><span class="o">?</span><span class="p">.</span><span class="n">isEven</span><span class="p">);</span>
</code></pre></div><p>这很烦人，但更糟糕的是，它掩盖了重要信息。考虑一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="n">showGizmo</span><span class="p">(</span><span class="n">Thing</span><span class="o">?</span> <span class="n">thing</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">thing</span><span class="o">?</span><span class="p">.</span><span class="n">doohickey</span><span class="o">?</span><span class="p">.</span><span class="n">gizmo</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>我有个问题要问你。Thing 上的 doohickey getter 可以返回 null 吗？看起来可以，因为你在结果上使用了?。但可能只是第二个?.只是为了处理 thing 为 null 的情况，而不是 doohickey 的结果。你无法判断。</p>
<p>为了解决这个问题，我们借鉴了 C#设计相同功能的一个聪明的想法。当你在一个方法链中使用一个 null-aware 操作符时，如果接收者评估为 null，那么整个方法链的其余部分都会被短路并跳过。这意味着如果 doohickey 有一个不可空的返回类型，那么你可以也应该写。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="n">showGizmo</span><span class="p">(</span><span class="n">Thing</span><span class="o">?</span> <span class="n">thing</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">thing</span><span class="o">?</span><span class="p">.</span><span class="n">doohickey</span><span class="p">.</span><span class="n">gizmo</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>事实上，如果你不这样做，你会在第二个?上得到一个不必要的代码警告。如果你看到这样的代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="n">showGizmo</span><span class="p">(</span><span class="n">Thing</span><span class="o">?</span> <span class="n">thing</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">thing</span><span class="o">?</span><span class="p">.</span><span class="n">doohickey</span><span class="o">?</span><span class="p">.</span><span class="n">gizmo</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>那么你就可以肯定地知道，这意味着 doohickey 本身有一个可空的返回类型。每一个?对应一个可以导致 null 流入方法链的唯一路径。这使得方法链中的 null-aware 操作符既更简洁又更精确。</p>
<p>在这时，我们又增加了几个其他的空感知操作符。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span>
<span class="c1">// Null-aware cascade:
</span><span class="c1"></span><span class="n">receiver</span><span class="o">?</span><span class="p">..</span><span class="n">method</span><span class="p">();</span>

<span class="c1">// Null-aware index operator:
</span><span class="c1"></span><span class="n">receiver</span><span class="o">?</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</code></pre></div><p>没有一个 null-aware 函数调用操作符，但你可以写。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Allowed with or without null safety:
</span><span class="c1"></span><span class="n">function</span><span class="o">?</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">);</span>
</code></pre></div><h3 id="null-断言运算符">Null 断言运算符</h3>
<p>使用流式分析将一个可空型变量移到非可空型变量的伟大之处在于，这样做被证明是安全的。你可以在之前的可空型变量上调用方法，而不会放弃非可空型的任何安全或性能。</p>
<p>但是，可空类型的许多有效用途无法以取悦静态分析的方式证明其安全性。比如说</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety, incorrectly:
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">HttpResponse</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">code</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">String</span><span class="o">?</span> <span class="n">error</span><span class="p">;</span>

  <span class="n">HttpResponse</span><span class="p">.</span><span class="n">ok</span><span class="p">()</span> <span class="o">:</span> <span class="n">code</span> <span class="o">=</span> <span class="m">200</span><span class="p">;</span>
  <span class="n">HttpResponse</span><span class="p">.</span><span class="n">notFound</span><span class="p">()</span>
      <span class="o">:</span> <span class="n">code</span> <span class="o">=</span> <span class="m">404</span><span class="p">,</span>
        <span class="n">error</span> <span class="o">=</span> <span class="s1">&#39;Not found&#39;</span><span class="p">;</span>

  <span class="kt">String</span> <span class="n">toString</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">==</span> <span class="m">200</span><span class="p">)</span> <span class="k">return</span> <span class="s1">&#39;OK&#39;</span><span class="p">;</span>
    <span class="k">return</span> <span class="s1">&#39;ERROR </span><span class="si">$</span><span class="n">code</span><span class="s1"> </span><span class="si">${</span><span class="n">error</span><span class="p">.</span><span class="n">toUpperCase</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>如果你尝试运行这个，你在调用 toUpperCase()时得到一个编译错误。错误字段是可空的，因为它在成功的响应中不会有一个值。我们通过检查类可以看到，当错误信息为空时，我们永远不会访问它。但这需要理解代码的值和错误的可空性之间的关系。类型检查器是看不到这种联系的。</p>
<p>换句话说，我们这些代码的人类维护者知道错误在我们使用它的时候不会是空的，我们需要一种方法来断言这一点。通常情况下，你使用 as cast 来断言类型，在这里你也可以做同样的事情。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kt">String</span> <span class="n">toString</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">==</span> <span class="m">200</span><span class="p">)</span> <span class="k">return</span> <span class="s1">&#39;OK&#39;</span><span class="p">;</span>
  <span class="k">return</span> <span class="s1">&#39;ERROR </span><span class="si">$</span><span class="n">code</span><span class="s1"> </span><span class="si">${</span><span class="p">(</span><span class="n">error</span> <span class="o">as</span> <span class="kt">String</span><span class="p">).</span><span class="n">toUpperCase</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>如果投递失败，将错误地投递到不可空的 String 类型，会抛出一个运行时异常。否则，它将为我们提供一个非空值字符串，我们可以在其上调用方法。</p>
<p>&ldquo;投弃可空性 &ldquo;经常出现，以至于我们有了一种新的速记语法。一个后缀的感叹号 (!) 将左边的表达式并将其投射到其底层的不可空类型上。所以上面的函数相当于</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kt">String</span> <span class="n">toString</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">==</span> <span class="m">200</span><span class="p">)</span> <span class="k">return</span> <span class="s1">&#39;OK&#39;</span><span class="p">;</span>
  <span class="k">return</span> <span class="s1">&#39;ERROR </span><span class="si">$</span><span class="n">code</span><span class="s1"> </span><span class="si">${</span><span class="n">error</span><span class="o">!</span><span class="p">.</span><span class="n">toUpperCase</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>当底层类型是啰嗦的时候，这个单字符的 &ldquo;bang 操作符 &ldquo;特别方便。如果仅仅为了从某个类型中投弃一个单一的?，而不得不写成 Map&lt;TransactionProviderFactory, List&lt;Set<!-- raw HTML omitted -->&gt;，那就真的很烦人了。</p>
<p>当然，就像任何投射一样，使用 !的同时也会损失静态安全。必须在运行时检查投射以保持合理性，而且可能会失败并抛出一个异常。但是你可以控制这些转码被插入的位置，你可以通过查看你的代码随时看到它们。</p>
<h3 id="late-变量">Late 变量</h3>
<p>类型检查器不能证明代码安全的最常见的地方是围绕顶层变量和字段。下面是一个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety, incorrectly:
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Coffee</span> <span class="p">{</span>
  <span class="kt">String</span> <span class="n">_temperature</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">heat</span><span class="p">()</span> <span class="p">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s1">&#39;hot&#39;</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">chill</span><span class="p">()</span> <span class="p">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s1">&#39;iced&#39;</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">String</span> <span class="n">serve</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">_temperature</span> <span class="o">+</span> <span class="s1">&#39; coffee&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">coffee</span> <span class="o">=</span> <span class="n">Coffee</span><span class="p">();</span>
  <span class="n">coffee</span><span class="p">.</span><span class="n">heat</span><span class="p">();</span>
  <span class="n">coffee</span><span class="p">.</span><span class="n">serve</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><p>这里，heat()方法是在服务()之前调用的。这意味着 _temperature 在使用之前会被初始化为一个非空值。但是静态分析来确定这一点是不可行的。(对于像这个微不足道的例子来说可能是可行的，但是一般情况下，试图跟踪一个类的每一个实例的状态是难以解决的。)。</p>
<p>因为类型检查器不能分析字段和顶层变量的用途，它有一个保守的规则，即不可空值字段必须在声明时初始化（或者在实例字段的构造函数初始化列表中）。所以 Dart 在这个类上报告了一个编译错误。</p>
<p>你可以通过使字段可空，然后在用途上使用 null 断言操作符来修复这个错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Coffee</span> <span class="p">{</span>
  <span class="kt">String</span><span class="o">?</span> <span class="n">_temperature</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">heat</span><span class="p">()</span> <span class="p">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s1">&#39;hot&#39;</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">chill</span><span class="p">()</span> <span class="p">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s1">&#39;iced&#39;</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">String</span> <span class="n">serve</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">_temperature</span><span class="o">!</span> <span class="o">+</span> <span class="s1">&#39; coffee&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这样做很好，但它给类的维护者发出了一个混乱的信号。但它给类的维护者发出了一个混乱的信号。通过标记 _temperature 为 nullable，你暗示 null 对于该字段来说是一个有用的、有意义的值。但这不是我们的目的。_temperature 字段永远不应该在其 null 状态下被观察到。</p>
<p>为了处理常见的延迟初始化的状态模式，我们添加了一个新的修饰符 late。你可以像这样使用它。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Coffee</span> <span class="p">{</span>
  <span class="n">late</span> <span class="kt">String</span> <span class="n">_temperature</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">heat</span><span class="p">()</span> <span class="p">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s1">&#39;hot&#39;</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">chill</span><span class="p">()</span> <span class="p">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s1">&#39;iced&#39;</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">String</span> <span class="n">serve</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">_temperature</span> <span class="o">+</span> <span class="s1">&#39; coffee&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>请注意，_temperature 字段的类型不可空，但没有初始化。另外，在使用它的时候也没有明确的空断言。有一些模型可以应用到迟到的语义中，但我是这样想的。晚期修饰符的意思是 &ldquo;在运行时执行这个变量的约束，而不是在编译时执行&rdquo;。这几乎就像 &ldquo;late &ldquo;这个词描述的是什么时候执行变量的保证。</p>
<p>在这种情况下，由于该字段还没有确定初始化，所以每次读取该字段时，都会插入一个运行时检查，以确保它已经被分配了一个值。如果没有，就会抛出一个异常。给变量类型为 String 意味着 &ldquo;你应该永远不会看到我的值不是字符串&rdquo;，而后期修饰符意味着 &ldquo;在运行时验证&rdquo;。</p>
<p>在某些方面，迟到修饰符比使用? &ldquo;神奇&rdquo;，因为对字段的任何使用都可能失败，而且在使用现场没有任何文字可见。但你确实必须在声明处写晚期才能得到这种行为，我们的信念是，在那里看到修饰符已经足够明确，这一点是可以维护的。</p>
<p>作为回报，你可以得到比使用可空类型更好的静态安全。因为现在字段的类型是非可空的，所以试图将 null 或可空的 String 分配给字段是一个编译错误。晚期修饰符可以让你推迟初始化，但仍然禁止你把它当作一个可空变量来处理。</p>
<h3 id="惰性初始化">惰性初始化</h3>
<p><code>late</code> 修饰符也有一些其他的特殊能力。这可能看起来很矛盾，但你可以在一个有初始化器的字段上使用 late。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Weather</span> <span class="p">{</span>
  <span class="n">late</span> <span class="kt">int</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="n">_readThermometer</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><p>当你这样做的时候，初始化器会变得懒惰。它不是在实例构造完成后立即运行，而是在第一次访问该字段时就延迟并缓慢运行。换句话说，它的工作方式与顶层变量或静态字段的初始化器完全一样。当初始化表达式的成本很高且可能不需要时，这可以很方便。</p>
<p>当你在实例字段上使用后期，懒惰地运行初始化器会给你一个额外的奖励。通常实例字段初始化器不能访问这个，因为在所有字段初始化器完成之前，你不能访问新对象。但有了迟来的字段，就不再是这样了，所以你可以访问这个，调用方法，或者访问实例上的字段。</p>
<h3 id="late-final-变量">late final 变量</h3>
<p>你也可以把 <code>late</code> 和 <code>final</code> 结合起来。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Coffee</span> <span class="p">{</span>
  <span class="n">late</span> <span class="kd">final</span> <span class="kt">String</span> <span class="n">_temperature</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">heat</span><span class="p">()</span> <span class="p">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s1">&#39;hot&#39;</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">chill</span><span class="p">()</span> <span class="p">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s1">&#39;iced&#39;</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">String</span> <span class="n">serve</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">_temperature</span> <span class="o">+</span> <span class="s1">&#39; coffee&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>与普通的 final 字段不同，您不必在声明中或在构造函数初始化列表中初始化该字段。你可以在以后的运行时对它进行赋值。但是你只能对它赋值一次，而且这个事实会在运行时被检查。如果你试图对它进行不止一次的赋值，就像这里同时调用 heat() 和 chill() 一样，第二次赋值就会抛出一个异常。这是对最终被初始化且之后不可改变的状态进行建模的好方法。</p>
<p>换句话说，新的 late 修饰符结合 Dart 的其他变量修饰符，覆盖了 Kotlin 中 lateinit 和 Swift 中 lazy 的大部分功能空间。如果你想在局部变量上使用它，你甚至可以在局部变量上使用它，如果你想进行一点局部的懒惰评估。</p>
<h3 id="所需的命名参数">所需的命名参数</h3>
<p>为了保证你永远不会看到一个具有不可空类型的空参数，类型检查器要求所有可选参数要么具有可空类型，要么具有默认值。如果你想让一个命名的参数有一个可空的类型而没有默认值呢？那就意味着你想要求调用者总是传递它。换句话说，你想要一个命名的参数，但不是可选的。</p>
<p>我用这个表直观地展示了 Dart 参数的各种类型。</p>
<pre><code>             mandatory    optional
            +------------+------------+
positional  | f(int x)   | f([int x]) |
            +------------+------------+
named       | ???        | f({int x}) |
            +------------+------------+
</code></pre><p>由于不清楚的原因，Dart 长期以来一直支持这个表的三个角，但把 named+mandatory 的组合空了。在空安全的情况下，我们填补了这一点。你在参数前放上 required，就可以声明一个必要的命名参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="n">function</span><span class="p">({</span><span class="kt">int</span><span class="o">?</span> <span class="n">a</span><span class="p">,</span> <span class="n">required</span> <span class="kt">int</span><span class="o">?</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span><span class="o">?</span> <span class="n">c</span><span class="p">,</span> <span class="n">required</span> <span class="kt">int</span><span class="o">?</span> <span class="n">d</span><span class="p">})</span> <span class="p">{}</span>
</code></pre></div><p>在这里，所有的参数都必须以名字传递。参数 a 和 c 是可选的，可以省略。参数 b 和 d 是必填的，必须传递。注意，要求性与可空性无关。可空类型的命名参数可以是必需的，不可空类型的命名参数可以是可选的（如果它们有一个默认值）。</p>
<p>这是另一个我认为无论空值安全性如何都能让 Dart 变得更好的特性之一。它只是让我觉得这个语言更加完整。</p>
<h3 id="抽象字段">抽象字段</h3>
<p>Dart 的一个特点是它坚持了一个叫做统一访问原则的东西。用人话说就是字段与 getter 和 setter 是没有区别的。在某个 Dart 类中的 &ldquo;属性 &ldquo;是计算还是存储，这是一个实现细节。正因为如此，在使用抽象类定义接口的时候，一般都会使用字段声明。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Cup</span> <span class="p">{</span>
  <span class="n">Beverage</span> <span class="n">contents</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>其目的是让用户只实现该类，而不要扩展它。字段语法只是写一个 getter/setter 对的较短方式。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Cup</span> <span class="p">{</span>
  <span class="n">Beverage</span> <span class="kd">get</span> <span class="n">contents</span><span class="p">;</span>
  <span class="kd">set</span> <span class="n">contents</span><span class="p">(</span><span class="n">Beverage</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>但 Dart 不知道这个类永远不会被用作具体类型。它把那个内容声明看作是一个真实的字段。而且，不幸的是，这个字段是不可空的，也没有初始化器，所以你得到一个编译错误。</p>
<p>一个解决方法是使用显式的抽象 getter/setter 声明，就像第二个例子中那样。但这有点啰嗦，所以在 null 安全的情况下，我们还增加了对显式抽象字段声明的支持。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Cup</span> <span class="p">{</span>
  <span class="kd">abstract</span> <span class="n">Beverage</span> <span class="n">contents</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这和第二个例子的行为完全一样。它只是用给定的名称和类型声明了一个抽象的 getter 和 setter。</p>
<h3 id="使用可空字段">使用可空字段</h3>
<p>这些新特性涵盖了许多常见的模式，并且在大多数时间里，让处理 null 的工作变得相当轻松。但即便如此，我们的经验是，可空字段仍然是困难的。在你能让字段迟到且不可空的情况下，你是金子般的存在。但在很多情况下，你需要检查字段是否有值，这就需要让它可空，这样你就可以观察到空。</p>
<p>你可能会期望这样做是可行的。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety, incorrectly:
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Coffee</span> <span class="p">{</span>
  <span class="kt">String</span><span class="o">?</span> <span class="n">_temperature</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">heat</span><span class="p">()</span> <span class="p">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s1">&#39;hot&#39;</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">chill</span><span class="p">()</span> <span class="p">{</span> <span class="n">_temperature</span> <span class="o">=</span> <span class="s1">&#39;iced&#39;</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">checkTemp</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_temperature</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Ready to serve &#39;</span> <span class="o">+</span> <span class="n">_temperature</span> <span class="o">+</span> <span class="s1">&#39;!&#39;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">String</span> <span class="n">serve</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">_temperature</span><span class="o">!</span> <span class="o">+</span> <span class="s1">&#39; coffee&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>在 checkTemp()里面，我们检查 _temperature 是否为空。如果不是，我们访问它，并最终调用+。不幸的是，这是不允许的。基于流式的类型推广并不适用于字段，因为静态分析无法证明字段的值在你检查 null 和你使用它的点之间没有变化。考虑到在病理情况下，字段本身可能会被子类中的 getter 覆盖，在第二次调用时返回 null）。</p>
<p>所以，既然我们关心健全性，那么字段就不会推广，上面的方法就不会编译。这是很烦人的。在像这里这样简单的情况下，你最好的选择是在字段的使用上打上一个! 这似乎是多余的，但这多少是 Dart 如今的行为方式。</p>
<p>另一个有用的模式是先把字段复制到一个本地变量中，然后再使用它。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kt">void</span> <span class="n">checkTemp</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">temperature</span> <span class="o">=</span> <span class="n">_temperature</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">temperature</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Ready to serve &#39;</span> <span class="o">+</span> <span class="n">temperature</span> <span class="o">+</span> <span class="s1">&#39;!&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>由于类型推广确实适用于本地人，所以现在可以正常使用。如果你需要改变值，只要记得存储回字段，而不仅仅是本地。</p>
<h3 id="无效性和属性">无效性和属性</h3>
<p>像大多数现代静态类型的语言一样，Dart 有通用类和通用方法。它们与可空性的交互方式有一些看似反直觉的地方，但一旦你想清楚了其中的含义，就会明白。首先是 &ldquo;这个类型是可空性的吗？&ldquo;不再是一个简单的是或否的问题。考虑一下。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">T</span> <span class="n">object</span><span class="p">;</span>
  <span class="n">Box</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">object</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Box</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">(</span><span class="s1">&#39;a string&#39;</span><span class="p">);</span>
  <span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">?&gt;</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>在 Box 的定义中，T 是一个可空类型还是一个不可空类型？正如你所看到的，它可以被实例化为任何一种类型。答案是 T 是一个潜在的可空类型。在一个通用类或方法的主体中，潜在可空类型具有可空类型和不可空类型的所有限制。</p>
<p>前者意味着除了在 Object 上定义的少量方法外，你不能调用它的任何方法。后者意味着你必须在使用该类型的任何字段或变量之前初始化它们。这可能会使类型参数变得相当难处理。</p>
<p>在实践中，有几种模式表现出来。在类似集合的类中，类型参数可以用任何类型实例化，你只需要处理这些限制。在大多数情况下，就像这里的例子一样，这意味着只要你需要处理一个类型参数的值，就必须确保你确实可以访问这个类型参数的值。幸运的是，集合类很少对其元素调用方法。</p>
<p>在你无法访问一个值的地方，你可以使类型参数的使用是可空的。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">T</span><span class="o">?</span> <span class="n">object</span><span class="p">;</span>
  <span class="n">Box</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
  <span class="n">Box</span><span class="p">.</span><span class="n">full</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">object</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>注意对象声明上的? 现在这个字段有一个显式可空的类型，所以可以不初始化它。</p>
<p>当你使一个类型参数类型像这里的 T? 一样可空的时候，你可能需要把可空性抛掉。正确的方法是使用显式为 T 的转写，而不是使用 !操作符。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">T</span><span class="o">?</span> <span class="n">object</span><span class="p">;</span>
  <span class="n">Box</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
  <span class="n">Box</span><span class="p">.</span><span class="n">full</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">object</span><span class="p">);</span>

  <span class="n">T</span> <span class="n">unbox</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">object</span> <span class="o">as</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>!操作符总是在值为 null 时抛出。但是如果类型参数已经被实例化为一个可空类型，那么 null 对于 T 来说是一个完全有效的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">box</span> <span class="o">=</span> <span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">?&gt;</span><span class="p">.</span><span class="n">full</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">unbox</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div><p>这个程序应该无误地运行。使用 T 就可以实现这一点。使用 !会抛出一个异常。</p>
<p>其他通用类型有一些约束，限制了可以应用的类型参数的种类。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Interval</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="kt">num</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>

  <span class="n">Interval</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">min</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">max</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="kd">get</span> <span class="n">isEmpty</span> <span class="o">=&gt;</span> <span class="n">max</span> <span class="o">&lt;=</span> <span class="n">min</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>如果绑定是不可空的，那么类型参数也是不可空的，这意味着你有不可空类型的限制&ndash;你不能让字段和变量不初始化。这意味着你有不可空值类型的限制&ndash;你不能让字段和变量不初始化。这里的示例类必须有一个初始化字段的构造函数。</p>
<p>作为这种限制的回报，你可以调用在其绑定上声明的参数类型的值的任何方法。然而，拥有一个不可空的绑定确实会阻止你的通用类的用户用一个可空的类型参数来实例化它。对于大多数类来说，这可能是一个合理的限制。</p>
<p>你也可以使用一个可空的绑定。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Interval</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="kt">num</span><span class="o">?&gt;</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="kd">get</span> <span class="n">isEmpty</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="n">localMin</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>
    <span class="kd">var</span> <span class="n">localMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>

    <span class="c1">// No min or max means an open-ended interval.
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">localMin</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">localMax</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">localMax</span> <span class="o">&lt;=</span> <span class="n">localMin</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这意味着在类的主体中，你可以灵活地将类型参数处理为 nullable。请注意，这次我们没有构造函数，这也没关系。字段将被隐式初始化为 null。你可以声明类型参数类型的未初始化变量。</p>
<p>但是你也有 nullability 的限制&ndash;你不能在该类型的变量上调用任何东西，除非你先处理好 nullability。在这里的例子中，我们复制局部变量中的字段，并检查这些局部变量是否为空，以便在使用&lt;=之前，流分析将它们推广到非可空性类型。</p>
<p>请注意，可空性绑定并不妨碍用户用非空类型实例化类。一个可空的边界意味着类型参数可以是可空的，而不是说它必须是可空的。事实上，如果你不写扩展子句，类型参数的默认约束是可空值约束 Object? 没有办法要求类型参数是可空的。如果你想让类型参数的使用可靠地是可空的，你可以在类的主体里面使用 T?</p>
<h2 id="核心库的变化">核心库的变化</h2>
<p>语言中还有一些其他的调整，但都是次要的。例如，没有 on 子句的 catch 的默认类型现在是 Object 而不是动态的。开关语句中的跌穿分析使用了新的流分析。</p>
<p>剩下的真正对你有意义的变化是在核心库中。在我们开始进行空值安全大冒险之前，我们担心原来没有办法在不大规模破坏世界的情况下让我们的核心库实现空值安全。结果并没有那么可怕。有一些重大的变化，但大多数情况下，迁移很顺利。大多数核心库要么不接受 null，自然而然地迁移到非可空类型，要么接受并优雅地用可空类型接受它。</p>
<p>不过有几个重要的角落。</p>
<h3 id="map-索引操作符是可空的">Map 索引操作符是可空的</h3>
<p>这并不是真正的改变，更多的是一个需要知道的事情。Map 类的 index [] 操作符如果键不存在，则返回 null。这意味着该操作符的返回类型必须是可空的。V?</p>
<p>我们可以将该方法改为当键不存在时抛出一个异常，然后给它一个更容易使用的非空值返回类型。但是，使用索引操作符并检查 null 以查看键是否不存在的代码是非常常见的，根据我们的分析，约占所有使用的一半。打破所有这些代码会让 Dart 生态系统燃起熊熊大火。</p>
<p>相反，运行时的行为是一样的，因此返回类型必须是可空的。这意味着你一般不能立即使用 map 查询的结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety, incorrectly:
</span><span class="c1"></span><span class="kd">var</span> <span class="n">map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="o">:</span> <span class="s1">&#39;value&#39;</span><span class="p">};</span>
<span class="n">print</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">].</span><span class="n">length</span><span class="p">);</span> <span class="c1">// Error.
</span></code></pre></div><p>当你试图在一个可空字符串上调用.length 时，会出现编译错误。在你知道键存在的情况下，你可以通过使用！.length 来教导类型检查器。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Using null safety:
</span><span class="c1"></span><span class="kd">var</span> <span class="n">map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="o">:</span> <span class="s1">&#39;value&#39;</span><span class="p">};</span>
<span class="n">print</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span><span class="o">!</span><span class="p">.</span><span class="n">length</span><span class="p">);</span> <span class="c1">// OK.
</span></code></pre></div><p>我们考虑过在 Map 中添加另一个方法来为你做这件事：查找 key，如果没有找到就抛出，否则就返回一个非空值。但是该怎么称呼它呢？没有一个名字比单字符的 !更短，也没有一个方法的名字比在调用现场看到一个内置语义的 !更清晰。所以，在地图中访问一个已知存在元素的习惯性方式是使用[]! 你会习惯的。</p>
<h3 id="没有未命名的-list-构造函数">没有未命名的 List 构造函数</h3>
<p>List 上的未命名构造函数创建了一个给定大小的新列表，但没有初始化任何元素。如果你创建了一个非可空类型的 list，然后访问一个元素，这将会在健全性保证中留下一个非常大的漏洞。</p>
<p>为了避免这种情况，我们完全删除了构造函数。在空安全代码中调用 List()是一个错误，即使是可空类型。这听起来很吓人，但实际上，大多数代码都是使用 list literals、List.filled()、List.generate()或者作为转换其他集合的结果来创建列表的。对于想要创建某种类型的空列表的边缘情况，我们添加了一个新的 List.empty()构造函数。</p>
<p>在 Dart 中，创建一个完全未初始化的列表的模式一直让人觉得格格不入，现在更是如此。如果你的代码被这一点破坏了，你可以随时通过使用许多其他的方法来产生一个列表来修复它。</p>
<h3 id="不能在不可空的列表上设置较大的长度">不能在不可空的列表上设置较大的长度</h3>
<p>这一点鲜为人知，但 List 上的 length getter 也有一个相应的 setter。你可以将长度设置为一个较短的值来截断列表。你也可以将它设置为一个较长的长度，以便用未初始化的元素填充列表。</p>
<p>如果你对一个非空值类型的列表这样做，当你以后访问那些未写入的元素时，你会违反健全性。为了防止这种情况发生，如果（也只有当）列表的元素类型是不可空的，而你又将其设置为较长的长度时，长度设置器会抛出一个运行时异常。截断所有类型的列表仍然是可以的，你可以增长可空类型的列表。</p>
<p>如果你定义了自己的列表类型，扩展了 ListBase 或应用了 ListMixin，那么这有一个重要的后果。这两种类型都提供了 insert()的实现，之前通过设置长度为插入的元素腾出空间。这样做会因空安全而失败，所以我们将 ListMixin（ListBase 共享）中 insert()的实现改为调用 add()。如果你想能够使用继承的 insert()方法，你的自定义列表类应该提供 add()的定义。</p>
<h3 id="不能在迭代之前或之后访问-iteratorcurrent">不能在迭代之前或之后访问 Iterator.current</h3>
<p>Iterator 类是一个可变的 &ldquo;游标 &ldquo;类，用于遍历实现 Iterable 的类型的元素。在访问任何元素之前，你应该调用 moveNext()来前进到第一个元素。当该方法返回 false 时，你已经到达了终点，没有更多的元素。</p>
<p>过去，如果你在第一次调用 moveNext()之前或在迭代结束后调用它，current 会返回 null。有了 null 安全，那就要求 current 的返回类型是 E? 而不是 E。这又意味着每个元素的访问都需要进行运行时空检查。</p>
<p>鉴于几乎没有人以那种错误的方式访问当前元素，这些检查将毫无用处。由于在迭代之前或之后可能会有一个该类型的值，所以我们让迭代器的行为没有被定义，如果你在不应该调用它的时候调用它。大多数 Iterator 的实现都会抛出一个 StateError。</p>
<h2 id="总结">总结</h2>
<p>这是一个非常详细的关于 null 安全的语言和库变化的介绍。这是一个很大的东西，但这是一个相当大的语言变化。更重要的是，我们希望达到一个点，让 Dart 仍然感觉到凝聚力和可用性。这不仅需要改变类型系统，还需要改变其他一些围绕它的可用性功能。我们不希望它让人感觉像被栓上了 null safety。</p>
<p>要带走的核心点是。</p>
<ul>
<li>
<p>类型在默认情况下是不可空值的，而通过添加 <code>?.</code> 来实现空值化。</p>
</li>
<li>
<p>可选参数必须是可空的，或者有一个默认值。可以使用 required 使命名参数成为非可选参数。不可空值的顶层变量和静态字段必须有初始化器。不可空值的实例字段必须在构造函数主体开始之前初始化。</p>
</li>
<li>
<p>如果接收者为空，则空感知操作符后的方法链会短路。有新的空感知级联(<code>?..</code>)和索引(<code>?[]</code>)运算符。后缀的空断言 &ldquo;bang&rdquo; 运算符(!)将其可空操作数投射到底层的非可空类型。</p>
</li>
<li>
<p>流程分析让你可以安全地将可空的局部变量和参数转化为可用的非可空变量。新的流分析还对类型提升、缺失返回、不可达代码和变量初始化有更智能的规则。</p>
</li>
<li>
<p>late 修饰符让你可以在其他地方使用不可空类型和 final，否则你可能无法使用，但会牺牲运行时检查。它还为你提供了惰性初始化的字段。</p>
</li>
<li>
<p>List 类被修改为防止未初始化元素。</p>
</li>
</ul>
<p>最后，一旦你吸收了所有这些，并让你的代码进入 null 安全的世界，你就会得到一个健全的程序，编译器可以优化，并且在你的代码中可以看到每一个可能发生运行时错误的地方。我们希望你觉得这样的努力是值得的。</p>
<p>原文链接: <a href="https://dart.dev/null-safety/understanding-null-safety">https://dart.dev/null-safety/understanding-null-safety</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/dart" term="dart" label="Dart" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/dart" term="dart" label="Dart" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/dart-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" term="dart-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" label="Dart 官方文档" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[异步编程：futures、async、await。]]></title>
            <link href="https://ohmyweekly.github.io/notes/futures-async-await/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/dart/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 入门" />
                <link href="https://ohmyweekly.github.io/notes/dart-iterable-collections/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 可迭代集合" />
                <link href="https://ohmyweekly.github.io/notes/dart-cheatsheet-codelab/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 语言速查表" />
            
                <id>https://ohmyweekly.github.io/notes/futures-async-await/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-27T00:00:00+08:00</published>
            <updated>2020-06-27T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>这个 codelab 教你如何使用 <code>futures</code>、<code>async</code> 和 <code>await</code> 关键字编写异步代码。使用内嵌的 DartPad 编辑器，你可以通过运行示例代码和完成练习来测试你的知识。</blockquote><p><a href="https://dart.dev/codelabs/async-await">async-await</a></p>
<p>这个 codelab 教你如何使用 <code>futures</code>、<code>async</code> 和 <code>await</code> 关键字编写异步代码。使用内嵌的 DartPad 编辑器，你可以通过运行示例代码和完成练习来测试你的知识。</p>
<p>要想从这个 codelab 中获得最大的收获，你应该具备以下条件。</p>
<ul>
<li>掌握<a href="https://dart.dev/samples">基本的 Dart 语法</a></li>
<li>有用其他语言编写异步代码的经验。</li>
</ul>
<p>这个 codelab 包括以下材料。</p>
<ul>
<li>如何以及何时使用 <code>async</code> 和 <code>await</code> 关键字。</li>
<li>使用 <code>async</code> 和 <code>await</code> 如何影响执行顺序。</li>
<li>如何在 <code>async</code> 函数中使用 <code>try-catch</code> 表达式处理异步调用中的错误。</li>
</ul>
<p>估计完成这个代码实验的时间。40-60分钟</p>
<p>注意：本页面使用嵌入式 DartPads 来显示示例和练习。如果你看到的是空框而不是 DartPads，请转到 <a href="https://dart.dev/tools/dartpad/troubleshoot">DartPad 故障排除页面</a>。</p>
<h2 id="为什么异步代码很重要">为什么异步代码很重要</h2>
<p>异步操作让你的程序在等待另一个操作完成时完成工作。下面是一些常见的异步操作。</p>
<ul>
<li>通过网络获取数据。</li>
<li>写入数据库。</li>
<li>从文件中读取数据。</li>
</ul>
<p>要在 Dart 中执行异步操作，你可以使用 <code>Future</code> 类以及 <code>async</code> 和 <code>await</code> 关键字。</p>
<h3 id="例子-错误地使用异步函数">例子: 错误地使用异步函数</h3>
<p>下面的例子显示了使用异步函数(<code>fetchUserOrder()</code>)的错误方法。稍后你将使用 <code>async</code> 和 <code>await</code> 来修复这个例子。在运行这个例子之前，试着发现这个问题-你认为输出会是什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// This example shows how *not* to write asynchronous Dart code.
</span><span class="c1"></span>
<span class="kt">String</span> <span class="n">createOrderMessage</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">order</span> <span class="o">=</span> <span class="n">fetchUserOrder</span><span class="p">();</span>
  <span class="k">return</span> <span class="s1">&#39;Your order is: </span><span class="si">$</span><span class="n">order</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">fetchUserOrder</span><span class="p">()</span> <span class="o">=&gt;</span>
    <span class="c1">// Imagine that this function is more complex and slow.
</span><span class="c1"></span>    <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span>
      <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">),</span>
      <span class="p">()</span> <span class="o">=&gt;</span> <span class="s1">&#39;Large Latte&#39;</span><span class="p">,</span>
    <span class="p">);</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">createOrderMessage</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div><p>下面是这个例子为什么不能打印 <code>fetchUserOrder()</code> 最终产生的值。</p>
<ul>
<li><code>fetchUserOrder()</code> 是一个异步函数，在延迟之后，提供一个描述用户订单的字符串：&ldquo;Large Latte&rdquo;。</li>
<li>为了得到用户的订单，<code>createOrderMessage()</code> 应该调用 <code>fetchUserOrder()</code>，并等待其完成。由于 <code>createOrderMessage()</code> 没有等待 <code>fetchUserOrder()</code> 完成，<code>createOrderMessage()</code> 无法获得 <code>fetchUserOrder()</code> 最终提供的字符串值。</li>
<li>取而代之的是，<code>createOrderMessage()</code> 得到的是待完成工作的表示：一个未完成的未来。您将在下一节了解更多关于未来的信息。</li>
<li>因为 <code>createOrderMessage()</code> 没有得到描述用户订单的值，所以这个例子没有打印 &ldquo;Large Latte&rdquo; 到控制台，而是打印 &ldquo;Your order is: Instance of &lsquo;_Future&rsquo;&quot;。</li>
</ul>
<p>在接下来的章节中，你将学习关于 futures 和关于使用 futures 的工作（使用 <code>async</code> 和 <code>await</code>），这样你就能编写必要的代码，使 <code>fetchUserOrder()</code> 向控制台打印所需的值(&ldquo;Large Latte&rdquo;)。</p>
<p>关键术语:</p>
<ul>
<li>同步操作: 同步操作会阻止其他操作的执行，直到它完成。</li>
<li>同步函数：同步函数只执行同步操作。</li>
<li>异步操作：异步操作一旦启动，就允许其他操作在它完成之前执行。</li>
<li>异步函数：异步函数至少执行一个异步操作，也可以执行同步操作。</li>
</ul>
<h2 id="什么是未来">什么是未来？</h2>
<p>future(小写 &ldquo;f&rdquo;)是 <a href="https://api.dart.dev/stable/dart-async/Future-class.html">Future</a>（大写 &ldquo;F&rdquo;）类的一个实例。一个 future 代表异步操作的结果，可以有两种状态：未完成或完成。</p>
<p>注意：未完成是一个 Dart 术语，指的是一个未来的状态，在它产生一个值之前。</p>
<h3 id="未完成的">未完成的</h3>
<p>当你调用一个异步函数时，它会返回一个未完成的未来。这个未来正在等待函数的异步操作完成或抛出一个错误。</p>
<h3 id="已完成的">已完成的</h3>
<p>如果异步操作成功，未来就以一个值完成。否则它将以一个错误完成。</p>
<h3 id="用一个值来完成">用一个值来完成</h3>
<p>类型为 <code>Future&lt;T&gt;</code> 的 future 用一个类型为 <code>T</code> 的值来完成。例如，一个类型为 <code>Future&lt;String&gt;</code> 的 future 会产生一个字符串值。如果一个 future 没有产生一个可用的值，那么 future 的类型是 <code>Future&lt;void&gt;</code>。</p>
<h3 id="用一个错误来完成">用一个错误来完成</h3>
<p>如果函数执行的异步操作因为任何原因而失败，future 就会以错误的方式完成。</p>
<h3 id="例子-介绍-future">例子: 介绍 future</h3>
<p>在下面的例子中，<code>fetchUserOrder()</code> 返回一个在打印到控制台后完成的 future。因为它没有返回一个可用的值，<code>fetchUserOrder()</code> 的类型是 <code>Future&lt;void&gt;</code>。在运行这个例子之前，试着预测一下哪个会先打印：&ldquo;Large Latte&rdquo; 或 &ldquo;Fetching user order&hellip;&quot;。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">fetchUserOrder</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Imagine that this function is fetching user info from another service or database.
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">),</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Large Latte&#39;</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">fetchUserOrder</span><span class="p">();</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Fetching user order...&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>在前面的例子中，尽管 <code>fetchUserOrder()</code> 在第8行的 <code>print()</code> 调用之前执行，控制台还是在 <code>fetchUserOrder()</code> 的输出 (&ldquo;Large Latte&rdquo;) 之前显示了第8行的输出 (&ldquo;Fetching user order&hellip;&quot;)。这是因为 <code>fetchUserOrder()</code> 在打印 &ldquo;Large Latte&rdquo; 之前会有延迟。</p>
<h3 id="例子-完成时出现错误">例子: 完成时出现错误</h3>
<p>运行下面的例子，看看未来如何完成一个错误。稍后你将学习如何处理错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">fetchUserOrder</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">// Imagine that this function is fetching user info but encounters a bug
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">),</span>
      <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">throw</span> <span class="n">Exception</span><span class="p">(</span><span class="s1">&#39;Logout failed: user ID is invalid&#39;</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">fetchUserOrder</span><span class="p">();</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Fetching user order...&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>在这个例子中，<code>fetchUserOrder()</code> 完成时出现错误，表明用户ID无效。</p>
<p>你已经学习了 future 和它们如何完成，但你如何使用异步函数的结果呢？在下一节中，你将学习如何使用 <code>async</code> 和 <code>await</code> 关键字来获取结果。</p>
<p>快速回顾:</p>
<ul>
<li>一个 <code>Future&lt;T&gt;</code> 实例会产生一个 <code>T</code> 类型的值。</li>
<li>如果一个 future 没有产生一个可用的值，那么 future 的类型是 <code>Future&lt;void&gt;</code>。</li>
<li>一个 future 可以处于两种状态之一：未完成或完成。</li>
<li>当你调用一个返回 future 的函数时，函数会把要做的工作排队，并返回一个未完成的 future。</li>
<li>当一个 future 的操作完成时，future 以一个值或以一个错误完成。</li>
</ul>
<p>关键术语:</p>
<ul>
<li>Future: Dart <a href="https://api.dart.dev/stable/dart-async/Future-class.html">Future</a> 类。</li>
<li>future：Dart <code>Future</code> 类的一个实例。</li>
</ul>
<h2 id="使用-futureasync-和-await">使用 future：async 和 await</h2>
<p><code>async</code> 和 <code>await</code> 关键字提供了一种声明式的方式来定义异步函数并使用它们的结果。在使用 <code>async</code> 和 <code>await</code> 时，请记住以下两个基本准则。</p>
<ul>
<li>要定义一个异步函数，请在函数主体前添加 <code>async</code>。</li>
<li><code>await</code> 关键字只能在 <code>async</code> 函数中使用。</li>
</ul>
<p>下面是一个将 <code>main()</code> 从同步函数转换为异步函数的例子。</p>
<p>首先，在函数体前添加 <code>async</code> 关键字:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="kd">async</span> <span class="p">{</span> <span class="err">···</span> <span class="p">}</span>
</code></pre></div><p>如果函数有声明的返回类型，那么更新类型为 <code>Future&lt;T&gt;</code>，其中 T 是函数返回的值的类型。如果函数没有明确返回值，那么返回类型为 <code>Future&lt;void&gt;</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">main</span><span class="p">()</span> <span class="kd">async</span> <span class="p">{</span> <span class="err">···</span> <span class="p">}</span>
</code></pre></div><p>现在你已经有了一个 <code>async</code> 函数，你可以使用 <code>await</code> 关键字来等待一个 future 的完成:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">print</span><span class="p">(</span><span class="kd">await</span> <span class="n">createOrderMessage</span><span class="p">());</span>
</code></pre></div><p>正如下面两个例子所显示的，<code>async</code> 和a <code>wait</code> 关键字导致异步代码看起来很像同步代码。唯一的区别在异步示例中突出显示，如果你的窗口足够宽，它就在同步示例的右边。</p>
<p>示例：同步函数</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">String</span> <span class="n">createOrderMessage</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">order</span> <span class="o">=</span> <span class="n">fetchUserOrder</span><span class="p">();</span>
  <span class="k">return</span> <span class="s1">&#39;Your order is: </span><span class="si">$</span><span class="n">order</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">fetchUserOrder</span><span class="p">()</span> <span class="o">=&gt;</span>
    <span class="c1">// Imagine that this function is
</span><span class="c1"></span>    <span class="c1">// more complex and slow.
</span><span class="c1"></span>    <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span>
      <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">),</span>
      <span class="p">()</span> <span class="o">=&gt;</span> <span class="s1">&#39;Large Latte&#39;</span><span class="p">,</span>
    <span class="p">);</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Fetching user order...&#39;</span><span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="n">createOrderMessage</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Fetching user order...
Your order is: Instance of _Future&lt;String&gt;
</code></pre></div><p>例子：异步函数</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">createOrderMessage</span><span class="p">()</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">order</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchUserOrder</span><span class="p">();</span>
  <span class="k">return</span> <span class="s1">&#39;Your order is: </span><span class="si">$</span><span class="n">order</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">fetchUserOrder</span><span class="p">()</span> <span class="o">=&gt;</span>
    <span class="c1">// Imagine that this function is
</span><span class="c1"></span>    <span class="c1">// more complex and slow.
</span><span class="c1"></span>    <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span>
      <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">),</span>
      <span class="p">()</span> <span class="o">=&gt;</span> <span class="s1">&#39;Large Latte&#39;</span><span class="p">,</span>
    <span class="p">);</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">main</span><span class="p">()</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Fetching user order...&#39;</span><span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="kd">await</span> <span class="n">createOrderMessage</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Fetching user order...
Your order is: Large Latte
</code></pre></div><p>异步示例在三个方面有所不同。</p>
<ul>
<li><code>createOrderMessage()</code> 的返回类型从 <code>String</code> 变为 <code>Future&lt;String&gt;</code>。</li>
<li><code>async</code> 关键字出现在 <code>createOrderMessage()</code> 和 <code>main()</code> 的函数体之前。</li>
<li><code>await</code> 关键字出现在调用异步函数 <code>fetchUserOrder()</code> 和 <code>createOrderMessage()</code> 之前。</li>
</ul>
<p>关键术语:</p>
<ul>
<li>async: 你可以在一个函数的主体前使用 <code>async</code> 关键字来标记它为异步函数。</li>
<li>async 函数: <code>async</code> 函数是一个标有 <code>async</code> 关键字的函数。</li>
<li>await：可以使用 <code>await</code> 关键字来获取异步表达式的完成结果。<code>await</code> 关键字只在 <code>async</code> 函数中起作用。</li>
</ul>
<h3 id="使用-async-和-await-的执行流程">使用 async 和 await 的执行流程</h3>
<p>一个异步函数在第一个 <code>await</code> 关键字之前是同步运行的。这意味着在一个 <code>async</code> 函数体中，第一个 <code>await</code> 关键字之前的所有同步代码都会立即执行。</p>
<p>版本说明：在 Dart 2.0 之前，一个异步函数立即返回，而不会在异步函数体中执行任何代码。</p>
<h3 id="例子在异步函数内执行在异步函数中执行">例子：在异步函数内执行。在异步函数中执行</h3>
<p>运行下面的例子，看看如何在异步函数体中执行。你认为输出会是什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">printOrderMessage</span><span class="p">()</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Awaiting user order...&#39;</span><span class="p">);</span>
  <span class="kd">var</span> <span class="n">order</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchUserOrder</span><span class="p">();</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Your order is: </span><span class="si">$</span><span class="n">order</span><span class="s1">&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">fetchUserOrder</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Imagine that this function is more complex and slow.
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">4</span><span class="p">),</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="s1">&#39;Large Latte&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">main</span><span class="p">()</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="n">countSeconds</span><span class="p">(</span><span class="m">4</span><span class="p">);</span>
  <span class="kd">await</span> <span class="n">printOrderMessage</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// You can ignore this function - it&#39;s here to visualize delay time in this example.
</span><span class="c1"></span><span class="kt">void</span> <span class="n">countSeconds</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">i</span> <span class="o">=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="n">i</span><span class="p">),</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>运行上例中的代码后，尝试将第2行和第3行反过来。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">var</span> <span class="n">order</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchUserOrder</span><span class="p">();</span>
<span class="n">print</span><span class="p">(</span><span class="s1">&#39;Awaiting user order...&#39;</span><span class="p">);</span>
</code></pre></div><p>注意到输出的时间发生了变化，现在 <code>print('Awaiting user order')</code> 出现在 <code>printOrderMessage()</code> 中第一个 <code>await</code> 关键字之后。</p>
<h3 id="练习-练习使用-async-和-await">练习: 练习使用 async 和 await</h3>
<p>下面的练习是一个失败的单元测试，其中包含部分完成的代码片段。你的任务是通过编写代码使测试通过来完成练习。你不需要实现 <code>main()</code>。</p>
<p>为了模拟异步操作，调用以下函数，这些函数是为你提供的。</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">类型签名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">fetchRole()</td>
<td style="text-align:left">Future<!-- raw HTML omitted --> fetchRole()</td>
<td style="text-align:left">获取用户角色的简短描述。</td>
</tr>
<tr>
<td style="text-align:left">fetchLoginAmount()</td>
<td style="text-align:left">Future<!-- raw HTML omitted --> fetchLoginAmount()</td>
<td style="text-align:left">获取用户的登录次数。</td>
</tr>
</tbody>
</table>
<p>第1部分：<code>reportUserRole()</code></p>
<p>为 <code>reportUserRole()</code> 函数添加代码，使其执行以下操作。</p>
<ul>
<li>返回一个以下列字符串完成的 future： <code>&quot;User role: &lt;user role&gt;&quot;</code>。
<ul>
<li>注意：你必须使用 <code>fetchRole()</code> 返回的实际值；复制和粘贴示例返回值不会使测试通过。</li>
<li>示例返回值: &ldquo;User role: tester&rdquo;</li>
</ul>
</li>
<li>通过调用提供的函数 <code>fetchRole()</code> 获取用户角色。</li>
</ul>
<p>第二部分：<code>reportLogins()</code></p>
<p>实现一个异步函数 <code>reportLogins()</code>，使其执行以下操作。</p>
<ul>
<li>返回字符串 &ldquo;Total number of logins: &lt;# of logins&gt;&quot;。
<ul>
<li>注意：你必须使用 <code>fetchLoginAmount()</code> 返回的实际值；复制和粘贴示例返回值不会使测试通过。</li>
<li><code>reportLogins()</code> 的返回值示例: <code>&quot;Total number of logins: 57&quot;</code>。</li>
</ul>
</li>
<li>通过调用提供的函数 <code>fetchLoginAmount()</code> 来获取登录次数。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">reportUserRole</span><span class="p">()</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">username</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchRole</span><span class="p">();</span>
  <span class="k">return</span> <span class="s1">&#39;User role: </span><span class="si">$</span><span class="n">username</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">reportLogins</span><span class="p">()</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">logins</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchLoginAmount</span><span class="p">();</span>
  <span class="k">return</span> <span class="s1">&#39;Total number of logins: </span><span class="si">$</span><span class="n">logins</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>注意：如果你的代码通过了测试，你可以忽略信息级的消息。</p>
<h2 id="处理错误">处理错误</h2>
<p>要处理 <code>async</code> 函数中的错误，使用 <code>try-catch</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">try</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">order</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchUserOrder</span><span class="p">();</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Awaiting user order...&#39;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Caught error: </span><span class="si">$</span><span class="n">err</span><span class="s1">&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>在一个 <code>async</code> 函数中，你可以像在同步代码中一样编写 <code>try-catch</code> 子句。</p>
<h3 id="例子async-和-await-的-try-catch-子句">例子：<code>async</code> 和 <code>await</code> 的 <code>try-catch</code> 子句</h3>
<p>运行下面的例子，看看如何处理一个异步函数的错误。你认为输出会是什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">printOrderMessage</span><span class="p">()</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="n">order</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchUserOrder</span><span class="p">();</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Awaiting user order...&#39;</span><span class="p">);</span>
    <span class="n">print</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Caught error: </span><span class="si">$</span><span class="n">err</span><span class="s1">&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">fetchUserOrder</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Imagine that this function is more complex.
</span><span class="c1"></span>  <span class="kd">var</span> <span class="n">str</span> <span class="o">=</span> <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span>
      <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">4</span><span class="p">),</span>
      <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">throw</span> <span class="s1">&#39;Cannot locate user order&#39;</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">main</span><span class="p">()</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">await</span> <span class="n">printOrderMessage</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><h3 id="练习-练习处理错误">练习: 练习处理错误</h3>
<p>下面的练习提供了使用异步代码处理错误的练习，使用上一节中描述的方法。为了模拟异步操作，你的代码将调用以下函数，该函数为你提供。</p>
<p>| 函数                | 类型签名 | 描述 |
| fetchNewUsername() | Future<!-- raw HTML omitted --> fetchNewUsername() |	返回你可以用来替换旧用户名的新用户名。|</p>
<p>使用 <code>async</code> 和 <code>await</code> 来实现一个异步的 <code>changeUsername()</code> 函数，该函数执行以下操作。</p>
<ul>
<li>调用提供的异步函数 <code>fetchNewUsername()</code> 并返回其结果。
<ul>
<li><code>changeUsername()</code> 的返回值示例: &ldquo;jane_smith_92&rdquo;</li>
</ul>
</li>
<li>捕获任何发生的错误并返回错误的字符串值。
<ul>
<li>你可以使用 <a href="https://api.dart.dev/stable/dart-core/ArgumentError/toString.html">toString()</a> 方法对 <a href="https://api.dart.dev/stable/dart-core/Exception-class.html">Exceptions</a> 和<a href="https://api.dart.dev/stable/dart-core/Error-class.html">Errors</a> 进行字符串化。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">changeUsername</span> <span class="p">()</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">await</span> <span class="n">fetchNewUsername</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">.</span><span class="n">toString</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="练习-把所有的东西放在一起">练习: 把所有的东西放在一起</h3>
<p>现在是时候在最后一个练习中练习所学的知识了。为了模拟异步操作，本练习提供了异步函数 <code>fetchUsername()</code> 和 <code>logoutUser()</code>:</p>
<p>| 函数             | 类型签名                        | 描述 |
| fetchUsername() |	Future<!-- raw HTML omitted --> fetchUsername() | 返回与当前用户相关联的名称。 |
| logoutUser()	  | Future<!-- raw HTML omitted --> logoutUser()	   | 执行当前用户的注销，并返回被注销的用户名。 |</p>
<p>编写以下内容。</p>
<p>第一部分：<code>addHello()</code></p>
<ul>
<li>编写一个函数 <code>addHello()</code>，它接受一个单一的 <code>String</code> 参数。</li>
<li><code>addHello()</code> 返回它的 <code>String</code> 参数，前面加 &lsquo;Hello&rsquo;。
例如：<code>addHello('Jon')</code> 返回 &lsquo;Hello Jon&rsquo;。</li>
</ul>
<p>第二部分：<code>greetUser()</code></p>
<ul>
<li>编写一个不接受参数的函数 <code>greetUser()</code>。</li>
<li>为了得到用户名，<code>greetUser()</code> 调用提供的异步函数 <code>fetchUsername()</code>。</li>
<li><code>greetUser()</code> 通过调用 <code>addHello()</code> 为用户创建一个问候语，传递用户名，并返回结果。
例子: 如果 <code>fetchUsername()</code> 返回 &lsquo;Jenny&rsquo;, 那么 <code>greetUser()</code> 返回 &lsquo;Hello Jenny&rsquo;.</li>
</ul>
<p>第三部分：<code>sayGoodbye()</code></p>
<ul>
<li>
<p>编写一个函数 <code>sayGoodbye()</code>，它的功能如下。</p>
<ul>
<li>不接受任何参数</li>
<li>捕获任何错误。</li>
<li>调用所提供的异步函数 logoutUser().</li>
</ul>
</li>
<li>
<p>如果 <code>logoutUser()</code> 失败，<code>sayGoodbye()</code> 返回任何你喜欢的字符串。</p>
</li>
<li>
<p>如果 <code>logoutUser()</code> 成功，<code>sayGoodbye()</code> 返回字符串 <code>'&lt;result&gt; Thanks, see you next time'</code>，其中 <code>&lt;result&gt;</code> 是调用 <code>logoutUser()</code> 返回的字符串值。</p>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">String</span> <span class="n">addHello</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s1">&#39;Hello </span><span class="si">$</span><span class="n">user</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">greetUser</span><span class="p">()</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">username</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchUsername</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">addHello</span><span class="p">(</span><span class="n">username</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">sayGoodbye</span><span class="p">()</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="n">result</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">logoutUser</span><span class="p">();</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">$</span><span class="n">result</span><span class="s1"> Thanks, see you next time&#39;</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;Failed to logout user: </span><span class="si">$</span><span class="n">e</span><span class="s1">&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="下一步是什么">下一步是什么？</h2>
<p>恭喜你，你已经完成了 codelab 的学习！如果你还想了解更多，这里有一些下一步的建议。</p>
<ul>
<li>玩玩 <a href="https://dartpad.dev/">DartPad</a>。</li>
<li>尝试另一个 <a href="https://dart.dev/codelabs">codelab</a>。</li>
<li>学习更多关于 futures 和异步的知识。
<ul>
<li><a href="https://dart.dev/tutorials/language/streams">Streams tutorial</a>: 学习如何使用异步事件的序列。</li>
<li><a href="https://www.youtube.com/playlist?list=PLjxrf2q8roU0Net_g1NT5_vOO3s_FR02J">来自 Google 的 Dart视频</a>: 观看一个或多个关于异步编码的视频。或者，如果你喜欢，阅读基于这些视频的文章。(从<a href="https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a">隔离和事件循环</a>开始。)</li>
</ul>
</li>
<li><a href="https://dart.dev/get-dart">获取 Dart SDK</a>。</li>
</ul>
<p>如果你对使用嵌入式 DartPads 感兴趣，就像这个 codelab 一样，请看<a href="https://dart.dev/resources/dartpad-best-practices">教程中使用 DartPad 的最佳实践</a>。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/async" term="async" label="async" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/futures" term="futures" label="futures" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/await" term="await" label="await" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/dart" term="dart" label="dart" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Dart 入门]]></title>
            <link href="https://ohmyweekly.github.io/notes/dart/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/dart-iterable-collections/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 可迭代集合" />
                <link href="https://ohmyweekly.github.io/notes/dart-cheatsheet-codelab/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 语言速查表" />
            
                <id>https://ohmyweekly.github.io/notes/dart/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-25T00:00:00+08:00</published>
            <updated>2020-06-25T16:02:46-04:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote><a href="https://www.dartcn.com/">Dart</a>入门指南。</blockquote><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="dart-help">重要的概念</h2>
<p>与 Java 不同，Dart 没有关键字 &ldquo;public&rdquo;, &ldquo;protected&rdquo; 和 &ldquo;private&rdquo;。 如果标识符以下划线（<code>_</code>）开头，则它相对于库是私有的。 有关更多信息，参考<a href="https://www.dartcn.com/guides/language/language-tour#%E5%BA%93%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7">库和可见性</a>。</p>
<h2 id="变量">变量</h2>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">var</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Bob&#39;</span><span class="p">;</span>     <span class="c1">// 类型推断
</span><span class="c1"></span>
<span class="kt">dynamic</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Bob&#39;</span><span class="p">;</span> <span class="c1">// 动态类型
</span><span class="c1"></span><span class="kt">String</span>  <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Bob&#39;</span><span class="p">;</span> <span class="c1">// 显式声明
</span></code></pre></div><h3 id="默认值">默认值</h3>
<p>未初始化的变量默认值是 <code>null</code>。即使变量是数字, 类型默认值也是 null, 因为在 Dart 中一切都是对象，数字类型也不例外。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">int</span> <span class="n">lineCount</span><span class="p">;</span>
<span class="k">assert</span><span class="p">(</span><span class="n">lineCount</span> <span class="o">==</span> <span class="kc">null</span><span class="p">);</span>
</code></pre></div><h3 id="final-和-const">final 和 const</h3>
<p>使用 <code>final</code> 关键字声明的变量, 其值只能被设置一次, 使用 <code>const</code> 关键字声明的变量, 其值在编译时就已固定:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">final</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Bob&#39;</span><span class="p">;</span> <span class="c1">// 不使用类型注解
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">String</span> <span class="n">nickname</span> <span class="o">=</span> <span class="s1">&#39;Bobby&#39;</span><span class="p">;</span>

<span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Alice&#39;</span><span class="p">;</span>     <span class="c1">// Error: final 变量只能被设置一次
</span></code></pre></div><p><code>const</code> 声明一个在<strong>编译</strong>时就固定不变的值, 例如数字字面量、字符串字面量:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">const</span> <span class="n">bar</span> <span class="o">=</span> <span class="m">1000000</span><span class="p">;</span>              <span class="c1">// 压力单位(dynes/cm2)
</span><span class="c1"></span><span class="kd">const</span> <span class="kt">double</span> <span class="n">atm</span> <span class="o">=</span> <span class="m">1.01325</span> <span class="o">*</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">// 一个标准大气压强
</span></code></pre></div><h2 id="内置类型">内置类型</h2>
<p>Dart 语言支持以下内置类型:</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">字面量</th>
<th style="text-align:left">对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Number</td>
<td style="text-align:left">2⁶³ -1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">String</td>
<td style="text-align:left">&lsquo;Hello&rsquo;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">true,false</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">List</td>
<td style="text-align:left">[1,2,3]</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Set</td>
<td style="text-align:left">{&lsquo;raku&rsquo;,&lsquo;perl&rsquo;}</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Map</td>
<td style="text-align:left">{&lsquo;lan&rsquo;: &lsquo;raku&rsquo;}</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Rune</td>
<td style="text-align:left">\u2665, \u{1f600}</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Symbol</td>
<td style="text-align:left">#dadix, #bar</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/dart" term="dart" label="dart" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/examples" term="examples" label="examples" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Dart 可迭代集合]]></title>
            <link href="https://ohmyweekly.github.io/notes/dart-iterable-collections/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/dart/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 入门" />
                <link href="https://ohmyweekly.github.io/notes/dart-cheatsheet-codelab/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 语言速查表" />
            
                <id>https://ohmyweekly.github.io/notes/dart-iterable-collections/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-25T00:00:00+08:00</published>
            <updated>2020-06-25T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote><a href="https://dart.dev/codelabs/iterables">Dart</a>可迭代集合。</blockquote><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>这个代码实验室教你如何使用实现 <a href="https://api.dart.dev/stable/dart-core/Iterable-class.html">Iterable</a>类的集合-例如 <a href="https://api.dart.dev/stable/dart-core/List-class.html">List</a>和 <a href="https://api.dart.dev/stable/dart-core/Set-class.html">Set</a>。迭代类是各种 Dart 应用程序的基本构建模块，你可能已经在使用它们，甚至没有注意到。这个代码实验室将帮助你充分利用它们。</p>
<p>使用嵌入式 DartPad 编辑器，你可以通过运行示例代码和完成练习来测试你的知识。</p>
<p>要想从这个 codelab 中获得最大的收获，你应该具备基本的 <a href="https://dart.dev/samples">Dart 语法知识</a>。</p>
<p>本课程包括以下内容。</p>
<ul>
<li>如何读取一个 Iterable 的元素。</li>
<li>如何检查一个 Iterable 的元素是否满足一个条件。</li>
<li>如何过滤一个 Iterable 的内容。</li>
<li>如何将一个 Iterable 的内容映射到不同的值。</li>
</ul>
<p>估计完成这个代码实验所需的时间: 60分钟。</p>
<h2 id="什么是集合">什么是集合?</h2>
<p>集合是代表一组对象的对象，这些对象称为元素。迭代元素是集合的一种。</p>
<p>集合可以是空的，也可以包含许多元素。根据不同的目的，集合可以有不同的结构和实现。这些是一些最常见的集合类型:</p>
<ul>
<li><a href="https://api.dart.dev/stable/dart-core/List-class.html">List</a>: 用来通过索引读取元素。</li>
<li><a href="https://api.dart.dev/stable/dart-core/Set-class.html">Set</a>: 用于包含只能出现一次的元素。</li>
<li><a href="https://api.dart.dev/stable/dart-core/Map-class.html">Map</a>：用于通过键来读取元素。</li>
</ul>
<h2 id="什么是iterable">什么是Iterable?</h2>
<p><code>Iterable</code> 是一个元素的集合，它可以被依次访问。</p>
<p>在 Dart 中，<code>Iterable</code> 是一个抽象类，这意味着你不能直接实例化它。然而，你可以通过创建一个新的 <code>List</code> 或 <code>Set</code> 来创建一个新的 <code>Iterable</code>。</p>
<p><code>List</code> 和 <code>Set</code> 都是 <code>Iterable</code>，所以它们和 <code>Iterable</code> 类有相同的方法和属性。</p>
<p><code>Map</code> 在内部使用不同的数据结构，这取决于它的实现。例如，<a href="https://api.dart.dev/stable/dart-collection/HashMap-class.html">HashMap</a> 使用了一个哈希表，其中的元素(也称为值)是通过一个键获得的。通过使用 <code>Map</code> 的 <code>entries</code> 或 <code>values</code> 属性，<code>Map</code> 的元素也可以作为 <code>Iterable</code> 对象读取。</p>
<p>这个例子显示了一个 <code>int</code> 的 <code>List</code>，它也是一个 <code>int</code> 的 <code>Iterable</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">iterable</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">];</span>
</code></pre></div><p>与 <code>List</code> 的区别在于，使用 <code>Iterable</code>，你无法保证按索引读取元素的效率。<code>Iterable</code> 与 <code>List</code> 相比，没有 <code>[]</code> 操作符。</p>
<p>例如，考虑以下代码，这是<strong>无效的</strong>:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">iterable</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">iterable</span><span class="p">[</span><span class="m">1</span><span class="p">];</span>
</code></pre></div><p>如果你用 <code>[]</code> 读取元素，编译器会告诉你 <code>'[]'</code> 这个运算符没有为 <code>Iterable</code> 类定义，这意味着在这种情况下你不能使用 <code>[index]</code>。</p>
<p>你可以用 <code>elementAt()</code> 来读取元素，它可以遍历迭代的元素，直到它到达那个位置。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">iterable</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">iterable</span><span class="p">.</span><span class="n">elementAt</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
</code></pre></div><p>继续下一节，了解更多关于如何访问 <code>Iterable</code> 的元素。</p>
<h2 id="读取元素">读取元素</h2>
<p>你可以使用 <code>for-in</code> 循环，依次读取一个迭代元素。</p>
<h3 id="例子-使用-for-in-循环">例子: 使用 for-in 循环</h3>
<p>下面的例子展示了如何使用 <code>for-in</code> 循环读取元素。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">iterable</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Salad&#39;</span><span class="p">,</span> <span class="s1">&#39;Popcorn&#39;</span><span class="p">,</span> <span class="s1">&#39;Toast&#39;</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">element</span> <span class="k">in</span> <span class="n">iterable</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在幕后，<code>for-in</code> 循环使用了一个迭代器。然而，你很少看到直接使用迭代器 API，因为 <code>for-in</code> 更容易阅读和理解，而且不容易出错。</p>
<p>关键术语:</p>
<ul>
<li><strong>Iterable</strong>: Dart <a href="https://api.dart.dev/stable/dart-core/Iterable-class.html">Iterable</a> 类。</li>
<li><strong>Iterator</strong>: <code>for-in</code> 用来从一个 Iterable 对象中读取元素的对象。</li>
<li><code>for-in</code> 循环: 从一个 Iterable 对象中依次读取元素的简单方法。</li>
</ul>
<h3 id="例子使用第一个和最后一个元素">例子：使用第一个和最后一个元素</h3>
<p>在某些情况下，你只想访问一个 <code>Iterable</code> 的第一个或最后一个元素。</p>
<p>在 <code>Iterable</code> 类中，你不能直接访问元素，所以你不能调用 <code>iterable[0]</code> 来访问第一个元素。相反，你可以使用 <code>first</code>，它可以获取第一个元素。</p>
<p>另外，使用 Iterable 类，你不能使用操作符 <code>[]</code> 来访问最后一个元素，但是你可以使用 <code>last</code> 属性。</p>
<p>因为访问一个 Iterable 的最后一个元素需要踏过所有其他元素，所以 <code>last</code> 可能会很慢。在一个空的 <code>Iterable</code> 上使用 <code>first</code> 或 <code>last</code> 会导致一个 <a href="https://api.dart.dev/stable/dart-core/StateError-class.html">StateError</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Iterable</span> <span class="n">iterable</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Salad&#39;</span><span class="p">,</span> <span class="s1">&#39;Popcorn&#39;</span><span class="p">,</span> <span class="s1">&#39;Toast&#39;</span><span class="p">];</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;The first element is </span><span class="si">${</span><span class="n">iterable</span><span class="p">.</span><span class="n">first</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;The last element is </span><span class="si">${</span><span class="n">iterable</span><span class="p">.</span><span class="n">last</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>在这个例子中，你看到了如何使用 <code>first</code> 和 <code>last</code> 来获得一个 <code>Iterable</code> 的第一个和最后一个元素。也可以找到满足条件的第一个元素。下一节将展示如何使用名为 <code>firstWhere()</code> 的方法来实现这一目标。</p>
<h3 id="例子-使用-firstwhere">例子: 使用 firstWhere()</h3>
<p>你已经看到，你可以依次访问一个 <code>Iterable</code> 的元素，你可以很容易地得到第一个或最后一个元素。</p>
<p>现在，你要学习如何使用 <code>firstWhere()</code> 来寻找满足某些条件的第一个元素。这个方法需要你传递一个谓词，它是一个函数，如果输入满足一定的条件就返回 true。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">String</span> <span class="n">element</span> <span class="o">=</span> <span class="n">iterable</span><span class="p">.</span><span class="n">firstWhere</span><span class="p">((</span><span class="n">element</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="m">5</span><span class="p">);</span>
</code></pre></div><p>例如，如果你想找到第一个超过 5 个字符的 <code>String</code>，你必须传递一个当元素大小大于 5 时返回 true 的谓词。</p>
<p>运行下面的例子，看看 <code>firstWhere()</code> 是如何工作的。你认为所有的函数都会给出相同的结果吗？</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">bool</span> <span class="n">predicate</span><span class="p">(</span><span class="kt">String</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">element</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="m">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Salad&#39;</span><span class="p">,</span> <span class="s1">&#39;Popcorn&#39;</span><span class="p">,</span> <span class="s1">&#39;Toast&#39;</span><span class="p">,</span> <span class="s1">&#39;Lasagne&#39;</span><span class="p">];</span>

  <span class="c1">// You can find with a simple expression:
</span><span class="c1"></span>  <span class="kd">var</span> <span class="n">element1</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">firstWhere</span><span class="p">((</span><span class="n">element</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="m">5</span><span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="n">element1</span><span class="p">);</span>

  <span class="c1">// Or try using a function block:
</span><span class="c1"></span>  <span class="kd">var</span> <span class="n">element2</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">firstWhere</span><span class="p">((</span><span class="n">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">element</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="m">5</span><span class="p">;</span>
  <span class="p">});</span>
  <span class="n">print</span><span class="p">(</span><span class="n">element2</span><span class="p">);</span>

  <span class="c1">// Or even pass in a function reference:
</span><span class="c1"></span>  <span class="kd">var</span> <span class="n">element3</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">firstWhere</span><span class="p">(</span><span class="n">predicate</span><span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="n">element3</span><span class="p">);</span>

  <span class="c1">// You can also use an `orElse` function in case no value is found!
</span><span class="c1"></span>  <span class="kd">var</span> <span class="n">element4</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">firstWhere</span><span class="p">(</span>
    <span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="m">10</span><span class="p">,</span>
    <span class="nl">orElse:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="s1">&#39;None!&#39;</span><span class="p">,</span>
  <span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="n">element4</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>在这个例子中，你可以看到三种不同的方式来写一个谓词。</p>
<ul>
<li><strong>作为一个表达式</strong>: 测试代码中有一行使用了箭头语法(<code>=&gt;</code>)。</li>
<li><strong>作为一个块</strong>: 测试代码在括号和返回语句之间有多行。</li>
<li><strong>作为一个函数</strong>: 测试代码在一个外部函数中，作为参数传递给 <code>firstWhere()</code> 方法。</li>
</ul>
<p>没有正确或错误的方式。使用最适合你的方式，并且让你的代码更容易阅读和理解。</p>
<p>在这个例子中，<code>firstWhereWithOrElse()</code> 调用 <code>firstWhere()</code> 时，使用了可选的命名参数 <code>orElse</code>，它在没有找到元素时提供了一个替代方案。在这种情况下，返回文本 &ldquo;None!&quot;，因为没有元素满足提供的条件。</p>
<p>注意：如果没有元素满足测试谓词，并且没有提供 <code>orElse</code> 参数，那么 <code>firstWhere()</code> 会抛出一个 <a href="https://api.dart.dev/stable/dart-core/StateError-class.html">StateError</a>。</p>
<p>快速回顾。</p>
<ul>
<li><code>Iterable</code> 的元素必须按顺序访问。</li>
<li>迭代所有元素的最简单方法是使用 <code>for-in</code> 循环。</li>
<li>你可以使用 <code>first</code> 和 <code>last</code> getters 来获取第一个和最后一个元素。</li>
<li>你也可以用 <code>firstWhere()</code> 找到满足条件的第一个元素。</li>
<li>你可以把测试谓词写成表达式、块或函数。</li>
</ul>
<p>关键术语。</p>
<p>谓词: 当某个条件被满足时，返回 <code>true</code> 的函数。</p>
<h3 id="练习-练习写一个测试谓词">练习: 练习写一个测试谓词</h3>
<p>下面的练习是一个失败的单元测试，其中包含一个部分完整的代码片段。你的任务是通过编写代码使测试通过来完成练习。你不需要实现 <code>main()</code>。</p>
<p>这个练习介绍了 <code>singleWhere()</code> 这个方法的工作原理类似于 <code>firstWhere()</code>，但在这种情况下，它只期望 <code>Iterable</code> 中的一个元素满足谓词。如果 <code>Iterable</code> 中超过一个或没有元素满足谓词条件，那么该方法会抛出一个 <a href="https://api.dart.dev/stable/dart-core/StateError-class.html">StateError</a> 异常。</p>
<p><code>singleWhere()</code> 对整个 <code>Iterable</code> 进行步进，直到最后一个元素，如果  <code>Iterable</code> 是无限的或包含一个大的元素集合，这可能会引起问题。</p>
<p>你的目标是实现满足以下条件的 <code>singleWhere()</code> 谓词。</p>
<ul>
<li>元素包含字符 &lsquo;a&rsquo;。</li>
<li>该元素以字符 &lsquo;M&rsquo; 开头。</li>
</ul>
<p>测试数据中的所有元素都是<a href="https://api.dart.dev/stable/dart-core/String-class.html">字符串</a>，你可以查看类文档以获得帮助。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">String</span> <span class="n">singleWhere</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">items</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="n">singleWhere</span><span class="p">((</span><span class="n">element</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">startsWith</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">element</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div><h2 id="检查条件">检查条件</h2>
<p>在使用 <code>Iterable</code> 时，有时你需要验证一个集合的所有元素是否满足某些条件。</p>
<p>你可能会想用 <code>for-in</code> 循环来写一个解决方案，比如这个:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">items</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</code></pre></div><p>然而，你可以使用 <code>every()</code> 方法实现同样的目的:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="n">every</span><span class="p">((</span><span class="n">element</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="m">5</span><span class="p">);</span>
</code></pre></div><p>使用 <code>every()</code> 方法可以使代码更易读、更紧凑、更不容易出错。</p>
<h3 id="例子-使用-any-和-every">例子: 使用 any() 和 every()</h3>
<p><code>Iterable</code> 类提供了两个可以用来验证条件的方法。</p>
<ul>
<li><code>any()</code>: 如果至少有一个元素满足条件，则返回 true。</li>
<li><code>every()</code>: 如果所有元素都满足条件，则返回 true。</li>
</ul>
<p>运行这个练习来看看它们的作用。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Salad&#39;</span><span class="p">,</span> <span class="s1">&#39;Popcorn&#39;</span><span class="p">,</span> <span class="s1">&#39;Toast&#39;</span><span class="p">];</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">any</span><span class="p">((</span><span class="n">element</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)))</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;At least one element contains &#34;a&#34;&#39;</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">every</span><span class="p">((</span><span class="n">element</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="m">5</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;All elements have length &gt;= 5&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在这个例子中，<code>any()</code> 验证了至少一个元素包含字符 a，<code>every()</code> 验证了所有元素的长度等于或大于 5。</p>
<p>运行代码后，尝试更改 <code>any()</code> 的谓词，使其返回 false:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">if</span> <span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">any</span><span class="p">((</span><span class="n">element</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">)))</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;At least one element contains &#34;Z&#34;&#39;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;No element contains &#34;Z&#34;&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>你也可以使用 <code>any()</code> 来验证一个 <code>Iterable</code> 中没有元素满足某个条件。</p>
<h3 id="练习-验证一个-iterable-是否满足一个条件">练习： 验证一个 Iterable 是否满足一个条件</h3>
<p>下面的练习提供了使用前面例子中描述的 <code>any()</code> 和 <code>every()</code> 方法的练习。在本例中，你的工作对象是一组用户，由具有成员字段 <code>age</code> 的 <code>User</code> 对象表示。</p>
<p>使用 <code>any()</code> 和 <code>every()</code> 实现两个函数。</p>
<ul>
<li>第1部分：实现 <code>anyUserUnder18()</code>。
<ul>
<li>如果至少有一个用户是17岁或更小，则返回 true。</li>
</ul>
</li>
<li>第2部分：实现 <code>everyUserOver13()</code>。
<ul>
<li>如果所有用户都是14岁或以上，则返回 true。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">bool</span> <span class="n">anyUserUnder18</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">users</span><span class="p">.</span><span class="n">any</span><span class="p">((</span><span class="n">user</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">user</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;</span> <span class="m">18</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">everyUserOver13</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">users</span><span class="p">.</span><span class="n">every</span><span class="p">((</span><span class="n">user</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">user</span><span class="p">.</span><span class="n">age</span> <span class="o">&gt;</span> <span class="m">13</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">User</span> <span class="p">{</span>
  <span class="kt">String</span> <span class="n">name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>

  <span class="n">User</span><span class="p">(</span>
    <span class="k">this</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
    <span class="k">this</span><span class="p">.</span><span class="n">age</span><span class="p">,</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>快速回顾:</p>
<ul>
<li>虽然你可以使用 <code>for-in</code> 循环来检查条件，但还有更好的方法。</li>
<li>方法 <code>any()</code> 可以让你检查任何元素是否满足条件。</li>
<li>方法 <code>every()</code> 可以让你验证所有元素是否满足条件。</li>
</ul>
<h2 id="过滤">过滤</h2>
<p>前面的章节介绍了 <code>firstWhere()</code> 或 <code>singleWhere()</code> 等方法，这些方法可以帮助你找到满足某个谓词的元素。</p>
<p>但是如果你想找到满足某个条件的所有元素呢？你可以使用 <code>where()</code> 方法来实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">var</span> <span class="n">evenNumbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">where</span><span class="p">((</span><span class="n">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">number</span><span class="p">.</span><span class="n">isEven</span><span class="p">);</span>
</code></pre></div><p>在这个例子中，<code>numbers</code> 包含一个有多个 <code>int</code> 值的 <code>Iterable</code>，<code>where()</code> 可以找到所有偶数的数字。</p>
<p><code>where()</code> 的输出是另一个 <code>Iterable</code>，你可以用它来迭代它或应用其他 <code>Iterable</code> 方法。在下一个例子中，<code>where()</code> 的输出直接在 <code>for-in</code> 循环中使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">var</span> <span class="n">evenNumbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">where</span><span class="p">((</span><span class="n">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">number</span><span class="p">.</span><span class="n">isEven</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">number</span> <span class="k">in</span> <span class="n">evenNumbers</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">$</span><span class="n">number</span><span class="s1"> is even&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h3 id="例子-使用-where">例子: 使用 where()</h3>
<p>运行这个例子，看看如何将 <code>where()</code> 与其他方法如 <code>any()</code> 一起使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">evenNumbers</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="o">-</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">42</span><span class="p">].</span><span class="n">where</span><span class="p">((</span><span class="n">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">number</span><span class="p">.</span><span class="n">isEven</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">number</span> <span class="k">in</span> <span class="n">evenNumbers</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">$</span><span class="n">number</span><span class="s1"> is even.&#39;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">evenNumbers</span><span class="p">.</span><span class="n">any</span><span class="p">((</span><span class="n">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">number</span><span class="p">.</span><span class="n">isNegative</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;evenNumbers contains negative numbers.&#39;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// If no element satisfies the predicate, the output is empty.
</span><span class="c1"></span>  <span class="kd">var</span> <span class="n">largeNumbers</span> <span class="o">=</span> <span class="n">evenNumbers</span><span class="p">.</span><span class="n">where</span><span class="p">((</span><span class="n">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">number</span> <span class="o">&gt;</span> <span class="m">1000</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">largeNumbers</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;largeNumbers is empty!&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在这个例子中，<code>where()</code> 用于查找所有偶数，然后用 <code>any()</code> 检查结果是否包含负数。</p>
<p>在本例的后面，再次使用 <code>where()</code> 来查找所有大于1000的数字，由于没有，结果是一个空的 <code>Iterable</code>。</p>
<p>注意：如果没有元素满足 <code>where()</code> 中的谓词，那么该方法返回一个空的 <code>Iterable</code>。与 <code>singleWhere()</code> 或 <code>firstWhere()</code> 不同，<code>where()</code> 不会抛出 <a href="https://api.dart.dev/stable/dart-core/StateError-class.html">StateError</a> 异常。</p>
<h3 id="例子-使用-takewhile">例子: 使用 takeWhile</h3>
<p>方法 <code>takeWhile()</code> 和 <code>skipWhile()</code> 也可以帮助你从一个 <code>Iterable</code> 中过滤元素。</p>
<p>运行这个例子，看看 <code>takeWhile()</code> 和 <code>skipWhile()</code> 如何分割一个包含数字的 <code>Iterable</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="o">-</span><span class="m">2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">];</span>

  <span class="kd">var</span> <span class="n">numbersUntilZero</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">takeWhile</span><span class="p">((</span><span class="n">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">number</span> <span class="o">!=</span> <span class="m">0</span><span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Numbers until 0: </span><span class="si">$</span><span class="n">numbersUntilZero</span><span class="s1">&#39;</span><span class="p">);</span>

  <span class="kd">var</span> <span class="n">numbersAfterZero</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">skipWhile</span><span class="p">((</span><span class="n">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">number</span> <span class="o">!=</span> <span class="m">0</span><span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Numbers after 0: </span><span class="si">$</span><span class="n">numbersAfterZero</span><span class="s1">&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>输出如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Numbers until 0: (1, 3, -2)
Numbers after 0: (0, 4, 5)
</code></pre></div><p>在这个例子中，<code>takeWhile()</code> 返回一个 <code>Iterable</code>，它包含了通往满足谓词的元素的所有元素。另一方面， <code>skipWhile()</code> 返回一个 <code>Iterable</code>，同时跳过满足谓词的元素之前的所有元素。请注意，满足谓词的元素也会被包含在内。</p>
<p>运行该示例后，将 <code>takeWhile()</code> 改为取元素，直到到达第一个负数。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">var</span> <span class="n">numbersUntilNegative</span> <span class="o">=</span>
    <span class="n">numbers</span><span class="p">.</span><span class="n">takeWhile</span><span class="p">((</span><span class="n">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="n">number</span><span class="p">.</span><span class="n">isNegative</span><span class="p">);</span>
</code></pre></div><p>注意，条件 <code>number.isNegative</code> 是用 <code>!</code> 否定的。</p>
<h3 id="练习-从列表中过滤元素">练习: 从列表中过滤元素</h3>
<p>下面的练习提供了使用上一练习中的 <code>User</code> 类的 <code>where()</code> 方法的练习。</p>
<p>使用 <code>where()</code> 实现两个函数。</p>
<ul>
<li>第1部分：实现 <code>filterUnder21()</code>。
<ul>
<li>返回一个包含所有21岁以上用户的 <code>Iterable</code>。</li>
</ul>
</li>
<li>第2部分：实现 <code>findShortNamed()</code>。
<ul>
<li>返回一个包含所有名字长度为 3 或更少的用户的 <code>Iterable</code>。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">filterUnder21</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">users</span><span class="p">.</span><span class="n">where</span><span class="p">((</span><span class="n">user</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">user</span><span class="p">.</span><span class="n">age</span> <span class="o">&gt;=</span> <span class="m">21</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Iterable</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">findShortNamed</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">users</span><span class="p">.</span><span class="n">where</span><span class="p">((</span><span class="n">user</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">user</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="m">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">User</span> <span class="p">{</span>
  <span class="kt">String</span> <span class="n">name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>

  <span class="n">User</span><span class="p">(</span>
    <span class="k">this</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
    <span class="k">this</span><span class="p">.</span><span class="n">age</span><span class="p">,</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>快速回顾:</p>
<ul>
<li>用 <code>where()</code> 过滤一个 <code>Iterable</code> 的元素。</li>
<li><code>where()</code> 的输出是另一个 <code>Iterable</code>。</li>
<li>使用 <code>takeWhile()</code> 和 <code>skipWhile()</code> 来获取元素，直到满足一个条件或之后。</li>
<li>这些方法的输出可以是一个空的 <code>Iterable</code>。</li>
</ul>
<h2 id="map">Map</h2>
<p>通过 <code>map()</code> 方法映射 <code>Iterables</code>，你可以在每个元素上应用一个函数，用一个新的元素替换每个元素。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">map</span><span class="p">((</span><span class="n">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">number</span> <span class="o">*</span> <span class="m">10</span><span class="p">);</span>
</code></pre></div><p>在这个例子中，<code>Iterable</code> 数字的每个元素都被乘以 10。</p>
<p>你也可以使用 <code>map()</code> 将一个元素转换为不同的对象-例如，将所有 <code>int</code> 转换为 <code>String</code>，在下面的例子中可以看到。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">map</span><span class="p">((</span><span class="n">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">number</span><span class="p">.</span><span class="n">toString</span><span class="p">());</span>
</code></pre></div><p>注意：<code>map()</code> 返回一个懒惰的 <code>Iterable</code>，这意味着只有在元素被迭代时才会调用所提供的函数。</p>
<h3 id="例子-使用-map-改变元素">例子: 使用 map 改变元素</h3>
<p>运行这个例子，看看如何使用 <code>map()</code> 将一个 <code>Iterable</code> 中的所有元素乘以2，你认为输出会是什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">numbersByTwo</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="o">-</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">42</span><span class="p">].</span><span class="n">map</span><span class="p">((</span><span class="n">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">number</span> <span class="o">*</span> <span class="m">2</span><span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Numbers: </span><span class="si">$</span><span class="n">numbersByTwo</span><span class="s1">.&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h3 id="练习-映射到不同类型">练习: 映射到不同类型</h3>
<p>在前面的例子中，你把一个 <code>Iterable</code> 的元素乘以2，输入和输出都是 <code>int</code> 的 <code>Iterable</code>。</p>
<p>在这个练习中，你的代码接收一个 <code>User</code>的 <code>Iterable</code>，你需要返回一个包含用户名和年龄的字符串的 <code>Iterable</code>。</p>
<p><code>Iterable</code> 中的每个字符串必须遵循这样的格式。<code>'{name} is {age}'</code>-例如 <code>'Alice is 21'</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">getNameAndAges</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">users</span><span class="p">.</span><span class="n">map</span><span class="p">((</span><span class="n">user</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s1">&#39;</span><span class="si">${</span><span class="n">user</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> is </span><span class="si">${</span><span class="n">user</span><span class="p">.</span><span class="n">age</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">User</span> <span class="p">{</span>
  <span class="kt">String</span> <span class="n">name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>

  <span class="n">User</span><span class="p">(</span>
    <span class="k">this</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
    <span class="k">this</span><span class="p">.</span><span class="n">age</span><span class="p">,</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>快速回顾:</p>
<ul>
<li><code>map()</code> 将一个函数应用于一个 <code>Iterable</code> 的所有元素。</li>
<li><code>map()</code> 的输出是另一个 <code>Iterable</code>。</li>
<li>在 <code>Iterable</code> 被迭代之前，函数不会被计算。</li>
</ul>
<h2 id="练习-把所有的东西放在一起">练习: 把所有的东西放在一起</h2>
<p>现在是练习所学知识的时候了，在最后一个练习中。</p>
<p>这个练习提供了类 <code>EmailAddress</code>，它有一个构造函数，接收一个字符串。另一个提供的函数是 <code>isValidEmailAddress()</code>，它测试一个电子邮件地址是否有效。</p>
<table>
<thead>
<tr>
<th style="text-align:left">构造函数/函数</th>
<th>类型签名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">EmailAddress()</td>
<td>EmailAddress(String address)</td>
<td style="text-align:left">为指定的地址创建一个 EmailAddress。</td>
</tr>
<tr>
<td style="text-align:left">isValidEmailAddress()</td>
<td>bool isValidEmailAddress(EmailAddress)</td>
<td style="text-align:left">如果提供的 EmailAddress 有效，返回 true。</td>
</tr>
</tbody>
</table>
<p>编写以下代码。</p>
<p>第1部分：实现 <code>parseEmailAddresses()</code>。</p>
<ul>
<li>编写函数 <code>parseEmailAddresses()</code>，它接收一个包含电子邮件地址的 <code>Iterable&lt;String&gt;</code>，并返回一个 <code>Iterable&lt;EmailAddress&gt;</code>。</li>
<li>使用方法 <code>map()</code> 从 <code>String</code> 映射到 <code>EmailAddress</code>。</li>
<li>使用构造函数 <code>EmailAddress(String)</code> 创建 <code>EmailAddress</code> 对象。</li>
</ul>
<p>第二部分：实现 <code>anyInvalidEmailAddress()</code>。</p>
<ul>
<li>编写函数 <code>anyInvalidEmailAddress()</code>，它接收一个 <code>Iterable&lt;EmailAddress&gt;</code>，并在 <code>Iterable</code> 中的任何 <code>EmailAddress</code> 无效时返回 true。</li>
<li>使用方法 <code>any()</code> 和提供的函 <code>isValidEmailAddress()</code>。</li>
</ul>
<p>第3部分：实现 <code>validEmailAddresses()</code>。</p>
<ul>
<li>编写函数 <code>validEmailAddresses()</code>，它接收一个 <code>Iterable&lt;EmailAddress&gt;</code> 并返回另一个只包含有效地址的 <code>Iterable&lt;EmailAddress&gt;</code>。</li>
<li>使用方法 <code>where()</code> 来过滤 <code>Iterable&lt;EmailAddress&gt;</code>。</li>
<li>使用提供的函数 <code>isValidEmailAddress()</code> 来评估一个 <code>EmailAddress</code> 是否有效。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">EmailAddress</span><span class="o">&gt;</span> <span class="n">parseEmailAddresses</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">strings</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">strings</span><span class="p">.</span><span class="n">map</span><span class="p">((</span><span class="n">s</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">EmailAddress</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">anyInvalidEmailAddress</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">EmailAddress</span><span class="o">&gt;</span> <span class="n">emails</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">emails</span><span class="p">.</span><span class="n">any</span><span class="p">((</span><span class="n">email</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="n">isValidEmailAddress</span><span class="p">(</span><span class="n">email</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">Iterable</span><span class="o">&lt;</span><span class="n">EmailAddress</span><span class="o">&gt;</span> <span class="n">validEmailAddresses</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">EmailAddress</span><span class="o">&gt;</span> <span class="n">emails</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">emails</span><span class="p">.</span><span class="n">where</span><span class="p">((</span><span class="n">email</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">isValidEmailAddress</span><span class="p">(</span><span class="n">email</span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">EmailAddress</span> <span class="p">{</span>
  <span class="kt">String</span> <span class="n">address</span><span class="p">;</span>

  <span class="n">EmailAddress</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">address</span><span class="p">);</span>

  <span class="err">@</span><span class="n">override</span>
  <span class="kt">bool</span> <span class="kd">operator</span> <span class="o">==</span><span class="p">(</span><span class="kt">Object</span> <span class="n">other</span><span class="p">)</span> <span class="o">=&gt;</span>
      <span class="n">identical</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">||</span>
          <span class="n">other</span> <span class="k">is</span> <span class="n">EmailAddress</span> <span class="o">&amp;&amp;</span>
              <span class="n">runtimeType</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">runtimeType</span> <span class="o">&amp;&amp;</span>
              <span class="n">address</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">address</span><span class="p">;</span>

  <span class="err">@</span><span class="n">override</span>
  <span class="kt">int</span> <span class="kd">get</span> <span class="n">hashCode</span> <span class="o">=&gt;</span> <span class="n">address</span><span class="p">.</span><span class="n">hashCode</span><span class="p">;</span>

  <span class="err">@</span><span class="n">override</span>
  <span class="kt">String</span> <span class="n">toString</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;EmailAddress{address: </span><span class="si">$</span><span class="n">address</span><span class="s1">}&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="下一步是什么">下一步是什么?</h2>
<p>恭喜你，你完成了 codelab 的学习! 如果你想了解更多，这里有一些下一步的建议。</p>
<ul>
<li>玩玩 <a href="https://dartpad.dev/">DartPad</a>。</li>
<li>试试另一个<a href="https://dart.dev/codelabs">代码实验</a>。</li>
<li>阅读 <a href="https://api.dart.dev/stable/dart-core/Iterable-class.html">Iterable API</a> 参考资料，了解本 codelab 未涉及的方法。</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/iterable" term="iterable" label="iterable" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/collection" term="collection" label="collection" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/dart" term="dart" label="dart" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Dart 语言速查表]]></title>
            <link href="https://ohmyweekly.github.io/notes/dart-cheatsheet-codelab/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/dart/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 入门" />
                <link href="https://ohmyweekly.github.io/notes/dart-iterable-collections/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 可迭代集合" />
            
                <id>https://ohmyweekly.github.io/notes/dart-cheatsheet-codelab/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-25T00:00:00+08:00</published>
            <updated>2020-06-25T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote><a href="https://www.dartcn.com/">Dart</a>速查表。</blockquote><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="字符串插值">字符串插值</h2>
<p>使用 <code>${expression}</code> 将表达式的值放到字符串里面。如果表达式是一个标识符, 就可以省略 <code>{}</code>。</p>
<p>下面是字符串插值的例子:</p>
<table>
<thead>
<tr>
<th style="text-align:left">字符串</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lsquo;${3 + 2}&rsquo;</td>
<td style="text-align:left">&lsquo;5&rsquo;</td>
</tr>
<tr>
<td style="text-align:left">&lsquo;${&ldquo;word&rdquo;.toUpperCase()}&rsquo;</td>
<td style="text-align:left">&lsquo;WORD&rsquo;</td>
</tr>
<tr>
<td style="text-align:left">&lsquo;$myObject&rsquo;</td>
<td style="text-align:left">The value of myObject.toString()</td>
</tr>
</tbody>
</table>
<h3 id="代码示例">代码示例</h3>
<p>下面的函数接收两个整数作为参数。使其返回一个包含两个整数的字符串，并以空格分隔。例如 <code>stringify(2, 3)</code> 应该返回 &lsquo;2 3&rsquo;。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">String</span> <span class="n">stringify</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">$</span><span class="n">x</span><span class="s1"> </span><span class="si">$</span><span class="n">y</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="null-无感知操作符">Null 无感知操作符</h2>
<p>Dart 提供了一些方便的操作符来处理可能为空的值。其中一个是 <code>??=</code> 赋值运算符，只有当一个变量当前为空时，它才会给这个变量赋值:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>    <span class="c1">// a 的初始值为 null
</span><span class="c1"></span><span class="n">a</span> <span class="o">??=</span> <span class="m">3</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// 打印 3
</span><span class="c1"></span>
<span class="n">a</span> <span class="o">??=</span> <span class="m">5</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// 仍然打印 3
</span></code></pre></div><p>另一个 null-aware 操作符是 <code>??</code>，它返回其左边的表达式，除非该表达式的值为 null，在这种情况下，它计算并返回其右边的表达式:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">print</span><span class="p">(</span><span class="m">1</span> <span class="o">??</span> <span class="m">3</span><span class="p">);</span>     <span class="c1">// 打印 1
</span><span class="c1"></span><span class="n">print</span><span class="p">(</span><span class="kc">null</span> <span class="o">??</span> <span class="m">12</span><span class="p">);</span> <span class="c1">// 打印 12 
</span></code></pre></div><h3 id="代码示例-1">代码示例</h3>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">String</span> <span class="n">foo</span> <span class="o">=</span> <span class="s1">&#39;a string&#39;</span><span class="p">;</span>
<span class="kt">String</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">// Unassigned objects are null by default.
</span><span class="c1"></span>
<span class="c1">// makes &#39;a string&#39; be assigned to baz.
</span><span class="c1"></span><span class="kt">String</span> <span class="n">baz</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">??</span> <span class="n">bar</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">updateSomeVars</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// makes &#39;a string&#39; be assigned to bar.
</span><span class="c1"></span>  <span class="n">bar</span> <span class="o">??=</span> <span class="s1">&#39;a string&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="有条件的属性访问">有条件的属性访问</h2>
<p>要保护对对象的一个可能为空的属性或方法的访问，请在点(.)前加上一个问号(?):</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">myObject</span><span class="o">?</span><span class="p">.</span><span class="n">someProperty</span>
</code></pre></div><p>上述代码等同于以下代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="p">(</span><span class="n">myObject</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="o">?</span> <span class="n">myObject</span><span class="p">.</span><span class="n">someProperty</span> <span class="o">:</span> <span class="kc">null</span>
</code></pre></div><p>你可以在一个表达式中把 <code>?.</code> 的多个使用链接在一起:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">myObject</span><span class="o">?</span><span class="p">.</span><span class="n">someProperty</span><span class="o">?</span><span class="p">.</span><span class="n">someMethod</span><span class="p">()</span>
</code></pre></div><p>如果 <code>myObject</code> 或 <code>myObject.someProperty</code> 为 null，前面的代码将返回 null(并且从不调用 <code>someMethod()</code>)。</p>
<h3 id="代码示例-2">代码示例</h3>
<p>尝试使用条件属性访问来完成下面的代码片段。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// This method should return the uppercase version of `str`
</span><span class="c1">// or null if `str` is null.
</span><span class="c1"></span><span class="kt">String</span> <span class="n">upperCaseIt</span><span class="p">(</span><span class="kt">String</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Try conditionally accessing the `toUpperCase` method here.
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">str</span><span class="o">?</span><span class="p">.</span><span class="n">toUpperCase</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><h2 id="集合字面量">集合字面量</h2>
<p>Dart 内置了对列表、映射和集合的支持。你可以使用字面量创建它们:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">final</span> <span class="n">aListOfStrings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">];</span>
<span class="kd">final</span> <span class="n">aSetOfStrings</span>  <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">};</span>
<span class="kd">final</span> <span class="n">aMapOfStringsToInts</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">&#39;one&#39;</span><span class="o">:</span> <span class="m">1</span><span class="p">,</span>
  <span class="s1">&#39;two&#39;</span><span class="o">:</span> <span class="m">2</span><span class="p">,</span>
  <span class="s1">&#39;three&#39;</span><span class="o">:</span> <span class="m">3</span><span class="p">,</span>  
<span class="p">}</span>
</code></pre></div><p>Dart 的类型推理可以为你分配类型给这些变量。在本例中，推断的类型是 <code>List&lt;String&gt;</code>、<code>Set&lt;String&gt;</code> 和 <code>Map&lt;String, int&gt;</code>。</p>
<p>或者你可以自己指定类型:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">final</span> <span class="n">aListOfInts</span> <span class="o">=</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">[];</span>
<span class="kd">final</span> <span class="n">aSetOfInts</span>  <span class="o">=</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="kd">final</span> <span class="n">aMapOfIntToDouble</span> <span class="o">=</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">{};</span>
</code></pre></div><p>当你用子类型的内容初始化一个列表，但仍然希望列表是 <code>List&lt;BaseType&gt;</code> 时，指定类型是很方便的:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">final</span> <span class="n">aListOfBaseType</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">BaseType</span><span class="o">&gt;</span><span class="p">[</span><span class="n">SubType</span><span class="p">(),</span> <span class="n">SubType</span><span class="p">()];</span>
</code></pre></div><h3 id="代码示例-3">代码示例</h3>
<p>尝试将以下变量设置为指定的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Assign this a list containing &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; in that order:
</span><span class="c1"></span><span class="kd">final</span> <span class="n">aListOfStrings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">];</span>

<span class="c1">// Assign this a set containing 3, 4, and 5:
</span><span class="c1"></span><span class="kd">final</span> <span class="n">aSetOfInts</span> <span class="o">=</span> <span class="p">{</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">};</span>

<span class="c1">// Assign this a map of String to int so that aMapOfStringsToInts[&#39;myKey&#39;] returns 12:
</span><span class="c1"></span><span class="kd">final</span> <span class="n">aMapOfStringsToInts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;myKey&#39;</span><span class="o">:</span> <span class="m">12</span><span class="p">};</span>

<span class="c1">// Assign this an empty List&lt;double&gt;:
</span><span class="c1"></span><span class="kd">final</span> <span class="n">anEmptyListOfDouble</span> <span class="o">=</span> <span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">[];</span>

<span class="c1">// Assign this an empty Set&lt;String&gt;:
</span><span class="c1"></span><span class="kd">final</span> <span class="n">anEmptySetOfString</span> <span class="o">=</span> <span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">{};</span>

<span class="c1">// Assign this an empty Map of double to int:
</span><span class="c1"></span><span class="kd">final</span> <span class="n">anEmptyMapOfDoublesToInts</span> <span class="o">=</span> <span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">{};</span>
</code></pre></div><h2 id="箭头语法">箭头语法</h2>
<p>你可能在 Dart 代码中看到过 <code>=&gt;</code> 符号。这种箭头语法是一种定义函数的方式，该函数执行其右边的表达式并返回其值。</p>
<p>例如，考虑这个对 <code>List</code> 类的 <code>any()</code> 方法的调用:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">bool</span> <span class="n">hasEmpty</span> <span class="o">=</span> <span class="n">aListOfStrings</span><span class="p">.</span><span class="n">any</span><span class="p">((</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div><p>这里有一个更简单的方法来写这个代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">bool</span> <span class="n">hasEmpty</span> <span class="o">=</span> <span class="n">aListOfStrings</span><span class="p">.</span><span class="n">any</span><span class="p">((</span><span class="n">s</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">);</span>
</code></pre></div><h3 id="代码示例-4">代码示例</h3>
<p>试着完成以下使用箭头语法的语句:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">_value1</span> <span class="o">=</span> <span class="m">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_value2</span> <span class="o">=</span> <span class="m">3</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_value3</span> <span class="o">=</span> <span class="m">5</span><span class="p">;</span>

  <span class="c1">// Returns the product of the above values:
</span><span class="c1"></span>  <span class="kt">int</span> <span class="kd">get</span> <span class="n">product</span> <span class="o">=&gt;</span> <span class="n">_value1</span> <span class="o">*</span> <span class="n">_value2</span> <span class="o">*</span> <span class="n">_value3</span><span class="p">;</span>
  
  <span class="c1">// Adds one to _value1:
</span><span class="c1"></span>  <span class="kt">void</span> <span class="n">incrementValue1</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">_value1</span><span class="o">++</span><span class="p">;</span> 
  
  <span class="c1">// Returns a string containing each item in the
</span><span class="c1"></span>  <span class="c1">// list, separated by commas (e.g. &#39;a,b,c&#39;): 
</span><span class="c1"></span>  <span class="kt">String</span> <span class="n">joinWithCommas</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">strings</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">strings</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="级联">级联</h2>
<p>要对同一对象进行一系列操作，可以使用级联(<code>...</code>)。我们都见过这样的表达式:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">myObject</span><span class="p">.</span><span class="n">someMethod</span><span class="p">()</span>
</code></pre></div><p>它在 <code>myObject</code> 上调用 <code>someMethod()</code>，表达式的结果是 <code>someMethod()</code> 的返回值。</p>
<p>下面是同样的表达式，有一个级联:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">myObject</span><span class="p">..</span><span class="n">someMethod</span><span class="p">()</span>
</code></pre></div><p>虽然它仍然在 <code>myObject</code> 上调用 <code>someMethod()</code>，但表达式的结果并不是返回值-它是对 <code>myObject</code> 的引用! 使用级联，你可以将原本需要单独语句的操作串联起来。例如，请看以下代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">var</span> <span class="n">button</span> <span class="o">=</span> <span class="n">querySelector</span><span class="p">(</span><span class="s1">&#39;#confirm&#39;</span><span class="p">);</span>
<span class="n">button</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Confirm&#39;</span><span class="p">;</span>
<span class="n">button</span><span class="p">.</span><span class="n">classes</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;important&#39;</span><span class="p">);</span>
<span class="n">button</span><span class="p">.</span><span class="n">onClick</span><span class="p">.</span><span class="n">listen</span><span class="p">((</span><span class="n">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">window</span><span class="p">.</span><span class="n">alert</span><span class="p">(</span><span class="s1">&#39;Confirmed!&#39;</span><span class="p">));</span>
</code></pre></div><p>有了级联，代码就会变得短得多，而且你也不需要 <code>button</code> 变量:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">querySelector</span><span class="p">(</span><span class="s1">&#39;#confirm&#39;</span><span class="p">)</span>
<span class="p">..</span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Confirm&#39;</span>
<span class="p">..</span><span class="n">class</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;important&#39;</span><span class="p">)</span>
<span class="p">..</span><span class="n">onClick</span><span class="p">.</span><span class="n">listen</span><span class="p">((</span><span class="n">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">window</span><span class="p">.</span><span class="n">alert</span><span class="p">(</span><span class="s1">&#39;Confirmed!&#39;</span><span class="p">));</span>
</code></pre></div><h3 id="代码示例-5">代码示例</h3>
<p>使用级联来创建一个单一的语句，将一个 <code>BigObject</code> 的 <code>anInt</code>、<code>aString</code> 和 <code>aList</code> 属性设置为 1、&lsquo;String!&rsquo; 和 <code>[3.0]</code>(分别地)，然后调用 <code>allDone()</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">BigObject</span><span class="p">{</span>
  <span class="kt">int</span> <span class="n">anInt</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
  <span class="kt">String</span> <span class="n">aString</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">aList</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kt">bool</span> <span class="n">_done</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">allDone</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">_done</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>    
<span class="p">}</span>

<span class="n">BigObject</span> <span class="n">fillBigObject</span><span class="p">(</span><span class="n">BigObject</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">obj</span>
      <span class="p">..</span><span class="n">anInt</span> <span class="o">=</span> <span class="m">1</span>
      <span class="p">..</span><span class="n">aString</span> <span class="o">=</span> <span class="s1">&#39;String!&#39;</span>
      <span class="p">..</span><span class="n">aList</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
      <span class="p">..</span><span class="n">allDone</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><h2 id="getters-和-setters">getters 和 setters</h2>
<p>当你需要对一个属性进行更多的控制时，你可以定义 getter 和 setter，而不是简单的字段。</p>
<p>例如，你可以确保一个属性的值是有效的:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">_aProperty</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>

  <span class="kt">int</span> <span class="kd">get</span> <span class="n">aProperty</span> <span class="o">=&gt;</span> <span class="n">_aProperty</span><span class="p">;</span>

  <span class="kd">set</span> <span class="n">aProperty</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">_aProperty</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>    
    <span class="p">}</span>    
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>你也可以使用 getter 来定义计算属性:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">_values</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="kt">void</span> <span class="n">addValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_values</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>    
  <span class="p">}</span>

  <span class="c1">// 一个计算属性
</span><span class="c1"></span>  <span class="kt">int</span> <span class="kd">get</span> <span class="n">count</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_values</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="代码示例-6">代码示例</h3>
<p>想象一下，你有一个购物车类，它保存了一个私有的 <code>List&lt;double&gt;</code> 的价格。添加以下内容:</p>
<ul>
<li>一个叫做 <code>total</code> 的 getter，返回价格的总和。</li>
<li>用一个新的列表替换列表的 setter，只要新的列表不包含任何负价格(在这种情况下，setter 应该抛出一个 <code>InvalidPriceException</code>)。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">InvalidPriceException</span> <span class="p">{}</span>

<span class="kd">class</span> <span class="nc">ShoppingCart</span> <span class="p">{</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">_prices</span> <span class="o">=</span> <span class="p">[];</span>
  
  <span class="kt">double</span> <span class="kd">get</span> <span class="n">total</span> <span class="o">=&gt;</span> <span class="n">_prices</span><span class="p">.</span><span class="n">fold</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">e</span> <span class="o">+</span> <span class="n">t</span><span class="p">);</span>
  
  <span class="kd">set</span> <span class="n">prices</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">any</span><span class="p">((</span><span class="n">p</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="m">0</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="n">InvalidPriceException</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="n">_prices</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="可选位置参数">可选位置参数</h2>
<p>Dart 有两种函数参数：位置参数和命名参数。位置参数是你可能熟悉的那种:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">int</span> <span class="n">sumUp</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>  <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...
</span><span class="c1"></span><span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">sumUp</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">);</span>
</code></pre></div><p>在 Dart 中，你可以将这些位置参数用括号包裹起来，使其成为可选的参数:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">int</span> <span class="n">sumUpToFive</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">])</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">e</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...
</span><span class="c1"></span><span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">sumUpToFive</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">otherTotal</span> <span class="o">=</span> <span class="n">sumUpToFive</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">);</span>
</code></pre></div><p>可选的位置参数在函数的参数列表中总是最后一个。它们的默认值是空的，除非你提供了另一个默认值:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">int</span> <span class="n">sumUpToFive</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="m">2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="m">3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="m">4</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="m">5</span><span class="p">])</span> <span class="p">{</span>
<span class="c1">// ···
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// ···
</span><span class="c1"></span><span class="kt">int</span> <span class="n">newTotal</span> <span class="o">=</span> <span class="n">sumUpToFive</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
<span class="n">print</span><span class="p">(</span><span class="n">newTotal</span><span class="p">);</span> <span class="c1">// &lt;-- prints 15
</span></code></pre></div><h3 id="代码示例-7">代码示例</h3>
<p>实现一个名为 <code>joinWithCommas()</code> 的函数，接受 1 到 5 个整数，然后返回一个用逗号分隔的数字字符串。下面是一些函数调用和返回值的例子:</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数调用</th>
<th style="text-align:left">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">joinWithCommas(1)</td>
<td style="text-align:left">&lsquo;1&rsquo;</td>
</tr>
<tr>
<td style="text-align:left">joinWithCommas(1, 2, 3)</td>
<td style="text-align:left">&lsquo;1,2,3&rsquo;</td>
</tr>
<tr>
<td style="text-align:left">joinWithCommas(1, 1, 1, 1, 1)</td>
<td style="text-align:left">&lsquo;1,1,1,1,1&rsquo;</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">res</span> <span class="o">=</span> <span class="n">joinWithCommas</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">);</span>
  <span class="n">print</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">String</span> <span class="n">joinWithCommas</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">])</span> <span class="p">{</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="n">sum</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">sum</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="可选命名参数">可选命名参数</h2>
<p>使用大括号语法，你可以定义有名称的可选参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">printName</span><span class="p">(</span><span class="kt">String</span> <span class="n">firstName</span><span class="p">,</span> <span class="kt">String</span> <span class="n">lastName</span><span class="p">,</span> <span class="p">{</span><span class="kt">String</span> <span class="n">suffix</span><span class="p">})</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">$</span><span class="n">firstName</span><span class="s1"> </span><span class="si">$</span><span class="n">lastName</span><span class="s1"> </span><span class="si">${</span><span class="n">suffix</span> <span class="o">??</span> <span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// ···
</span><span class="c1"></span><span class="n">printName</span><span class="p">(</span><span class="s1">&#39;Avinash&#39;</span><span class="p">,</span> <span class="s1">&#39;Gupta&#39;</span><span class="p">);</span>
<span class="n">printName</span><span class="p">(</span><span class="s1">&#39;Poshmeister&#39;</span><span class="p">,</span> <span class="s1">&#39;Moneybuckets&#39;</span><span class="p">,</span> <span class="nl">suffix:</span> <span class="s1">&#39;IV&#39;</span><span class="p">);</span>
</code></pre></div><p>正如你所期望的，这些参数的值默认为空，但你可以提供默认值。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">printName</span><span class="p">(</span><span class="kt">String</span> <span class="n">firstName</span><span class="p">,</span> <span class="kt">String</span> <span class="n">lastName</span><span class="p">,</span> <span class="p">{</span><span class="kt">String</span> <span class="n">suffix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">})</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">$</span><span class="n">firstName</span><span class="s1"> </span><span class="si">$</span><span class="n">lastName</span><span class="s1"> </span><span class="si">$</span><span class="n">suffix</span><span class="s1">&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>一个函数不能同时拥有可选的位置参数和可选的命名参数。</p>
<h3 id="代码示例-8">代码示例</h3>
<p>为 <code>MyDataObject</code> 类添加一个 <code>copyWith()</code> 实例方法。它应该接受三个命名参数:</p>
<ul>
<li>int newInt</li>
<li>String newString</li>
<li>double newDouble</li>
</ul>
<p>当调用时，<code>copyWith()</code> 应该基于当前实例返回一个新的 <code>MyDataObject</code>，并将前面参数（如果有的话）的数据复制到对象的属性中。例如，如果 <code>newInt</code> 是非空的，那么将其值复制到 <code>anInt</code> 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyDataObject</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">anInt</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">String</span> <span class="n">aString</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">double</span> <span class="n">aDouble</span><span class="p">;</span>

  <span class="n">MyDataObject</span><span class="p">({</span>
     <span class="k">this</span><span class="p">.</span><span class="n">anInt</span> <span class="o">=</span> <span class="m">1</span><span class="p">,</span>
     <span class="k">this</span><span class="p">.</span><span class="n">aString</span> <span class="o">=</span> <span class="s1">&#39;Old!&#39;</span><span class="p">,</span>
     <span class="k">this</span><span class="p">.</span><span class="n">aDouble</span> <span class="o">=</span> <span class="m">2.0</span><span class="p">,</span>
  <span class="p">});</span>

  <span class="n">MyDataObject</span> <span class="n">copyWith</span><span class="p">({</span><span class="kt">int</span> <span class="n">newInt</span><span class="p">,</span> <span class="kt">String</span> <span class="n">newString</span><span class="p">,</span> <span class="kt">double</span> <span class="n">newDouble</span><span class="p">})</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MyDataObject</span><span class="p">(</span>
      <span class="nl">anInt:</span>      <span class="n">newInt</span> <span class="o">??</span> <span class="k">this</span><span class="p">.</span><span class="n">anInt</span><span class="p">,</span>
      <span class="nl">aString:</span> <span class="n">newString</span> <span class="o">??</span> <span class="k">this</span><span class="p">.</span><span class="n">aString</span><span class="p">,</span>
      <span class="nl">aDouble:</span> <span class="n">newDouble</span> <span class="o">??</span> <span class="k">this</span><span class="p">.</span><span class="n">aDouble</span><span class="p">,</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="异常">异常</h2>
<p>Dart 代码可以抛出和捕获异常。与 Java 相比，Dart 的所有异常都是未检查的异常。方法不声明它们可能会抛出哪些异常，你也不需要捕捉任何异常。</p>
<p>Dart 提供了 <code>Exception</code> 和 <code>Error</code> 类型，但你可以抛出任何非空对象:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">throw</span> <span class="n">Exception</span><span class="p">(</span><span class="s1">&#39;Something bad happened.&#39;</span><span class="p">);</span>
<span class="k">throw</span> <span class="s1">&#39;Waaaaaaah!&#39;</span><span class="p">;</span>
</code></pre></div><p>在处理异常时使用 <code>try</code>、<code>on</code> 和 <code>catch</code> 关键字:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">try</span> <span class="p">{</span>
  <span class="n">breedMoreLlamas</span><span class="p">();</span>
<span class="p">}</span> <span class="n">on</span> <span class="n">OutOfLlamasException</span> <span class="p">{</span>
  <span class="c1">// A specific exception
</span><span class="c1"></span>  <span class="n">buyMoreLlamas</span><span class="p">();</span>
<span class="p">}</span> <span class="n">on</span> <span class="n">Exception</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Anything else that is an exception
</span><span class="c1"></span>  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Unknown exception: </span><span class="si">$</span><span class="n">e</span><span class="s1">&#39;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// No specified type, handles all
</span><span class="c1"></span>  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;Something really unknown: </span><span class="si">$</span><span class="n">e</span><span class="s1">&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p><code>try</code> 关键字的工作原理和其他大多数语言一样。使用 <code>on</code> 关键字按类型过滤特定的异常，使用 <code>catch</code> 关键字获取异常对象的引用。</p>
<p>如果不能完全处理异常，可以使用 <code>rethrow</code> 关键字来传播异常:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">try</span> <span class="p">{</span>
  <span class="n">breedMoreLlamas</span><span class="p">();</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;I was just trying to breed llamas!.&#39;</span><span class="p">);</span>
  <span class="n">rethrow</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>无论是否抛出异常，都要执行代码，使用 <code>final</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">try</span> <span class="p">{</span>
  <span class="n">breedMoreLlamas</span><span class="p">();</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... handle exception ...
</span><span class="c1"></span><span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
  <span class="c1">// Always clean up, even if an exception is thrown.
</span><span class="c1"></span>  <span class="n">cleanLlamaStalls</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><h3 id="代码示例-9">代码示例</h3>
<p>实现下面的 <code>tryFunction()</code>。它应该执行一个不可信的方法，然后做如下操作:</p>
<ul>
<li>如果 <code>untrustworthy()</code> 抛出一个 <code>ExceptionWithMessage</code>，调用 <code>logger.logException</code>，并提供异常类型和消息(尝试使用 <code>on</code> 和 <code>catch</code>)。</li>
<li>如果 <code>untrustworthy()</code> 抛出一个 <code>Exceptio</code>n，调用 <code>logger.logException</code>，并注明异常类型(尝试使用 <code>on</code>)。</li>
<li>如果 <code>untrustworthy()</code> 抛出任何其他对象，不要捕获异常。</li>
<li>当所有的东西都被捕获和处理后，调用 <code>logger.doneLogging</code>(尝试使用 <code>finally</code>)。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">typedef</span> <span class="n">VoidFunction</span> <span class="o">=</span> <span class="kt">void</span> <span class="n">Function</span><span class="p">();</span>

<span class="kd">class</span> <span class="nc">ExceptionWithMessage</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">String</span> <span class="n">message</span><span class="p">;</span>
  <span class="kd">const</span> <span class="n">ExceptionWithMessage</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Logger</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">logException</span><span class="p">(</span><span class="n">Type</span> <span class="n">t</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span> <span class="n">msg</span><span class="p">]);</span>
  <span class="kt">void</span> <span class="n">doneLogging</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">tryFunction</span><span class="p">(</span><span class="n">VoidFunction</span> <span class="n">untrustworthy</span><span class="p">,</span> <span class="n">Logger</span> <span class="n">logger</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="n">untrustworthy</span><span class="p">();</span>
  <span class="p">}</span> <span class="n">on</span> <span class="n">ExceptionWithMessage</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">logger</span><span class="p">.</span><span class="n">logException</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">runtimeType</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">message</span><span class="p">);</span>
  <span class="p">}</span> <span class="n">on</span> <span class="n">Exception</span> <span class="p">{</span>
    <span class="n">logger</span><span class="p">.</span><span class="n">logException</span><span class="p">(</span><span class="n">Exception</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
    <span class="n">logger</span><span class="p">.</span><span class="n">doneLogging</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="在构造函数中使用-this">在构造函数中使用 <code>this</code></h2>
<p>Dart 提供了一个方便的快捷方式来为构造函数中的属性赋值：在声明构造函数时使用 <code>this.propertyName</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyColor</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">red</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">green</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">blue</span><span class="p">;</span>

  <span class="n">MyColor</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">red</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">green</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">blue</span><span class="p">)</span>    
<span class="p">}</span>

<span class="kd">final</span> <span class="n">color</span> <span class="o">=</span> <span class="n">MyColor</span><span class="p">(</span><span class="m">80</span><span class="p">,</span> <span class="m">80</span><span class="p">,</span> <span class="m">128</span><span class="p">);</span>
</code></pre></div><p>这种技术也适用于命名参数。属性名成为参数的名称:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyColor</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">MyColor</span><span class="p">({</span><span class="k">this</span><span class="p">.</span><span class="n">red</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">green</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">blue</span><span class="p">});</span>    
<span class="p">}</span>
<span class="kd">final</span> <span class="n">color</span> <span class="o">=</span> <span class="n">MyColor</span><span class="p">(</span><span class="nl">red:</span> <span class="m">80</span><span class="p">,</span> <span class="nl">green:</span> <span class="m">80</span><span class="p">,</span> <span class="nl">blue:</span> <span class="m">80</span><span class="p">);</span>
</code></pre></div><p>对于可选参数，默认值按预期工作:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">MyColor</span><span class="p">([</span><span class="k">this</span><span class="p">.</span><span class="n">red</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">green</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">blue</span> <span class="o">=</span> <span class="m">0</span><span class="p">]);</span>
<span class="c1">// or
</span><span class="c1"></span><span class="n">MyColor</span><span class="p">({</span><span class="k">this</span><span class="p">.</span><span class="n">red</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">green</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">blue</span> <span class="o">=</span> <span class="m">0</span><span class="p">});</span>
</code></pre></div><h3 id="代码示例-10">代码示例</h3>
<p>为 <code>MyClass</code> 添加一个单行构造函数，使用 <code>this.</code> 语法来接收和分配类的三个属性的值:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">anInt</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">String</span> <span class="n">aString</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">double</span> <span class="n">aDouble</span><span class="p">;</span>
  
  <span class="n">MyClass</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">anInt</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">aString</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">aDouble</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="初始化器列表">初始化器列表</h2>
<p>有时候，当你实现一个构造函数时，你需要在构造函数体执行之前做一些设置。例如，在构造函数体执行之前，<code>final</code> 字段必须有值。在一个初始化器列表中做这些工作，它位于构造函数的签名和它的主体之间。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Point</span><span class="p">.</span><span class="n">fromJson</span><span class="p">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">num</span><span class="o">&gt;</span> <span class="n">json</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">x</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span>
      <span class="n">y</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;In Point.fromJson(): (</span><span class="si">$</span><span class="n">x</span><span class="s1">, </span><span class="si">$</span><span class="n">y</span><span class="s1">)&#39;</span><span class="p">);</span>  
<span class="p">}</span>
</code></pre></div><p>初始化器列表也是一个方便放置断言的地方，它只在开发过程中运行:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">NonNegativePoint</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
    <span class="o">:</span> <span class="k">assert</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="m">0</span><span class="p">),</span>
      <span class="k">assert</span><span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;I just made a NonNegativePoint: (</span><span class="si">$</span><span class="n">x</span><span class="s1">, </span><span class="si">$</span><span class="n">y</span><span class="s1">)&#39;</span><span class="p">);</span>        
<span class="p">}</span>
</code></pre></div><h3 id="代码示例-11">代码示例</h3>
<p>完成下面的 <code>FirstTwoLetters</code> 构造函数。使用初始化器列表将 <code>word</code> 中的前两个字符分配给 <code>letterOne</code> 和 <code>LetterTwo</code> 属性。为了获得额外的积分，可以添加一个断言来捕获少于两个字符的单词。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">FirstTwoLetters</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">String</span> <span class="n">letterOne</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">String</span> <span class="n">letterTwo</span><span class="p">;</span>

  <span class="c1">// Create a constructor with an initializer list here:
</span><span class="c1"></span>  <span class="n">FirstTwoLetters</span><span class="p">(</span><span class="kt">String</span> <span class="n">word</span><span class="p">)</span>
    <span class="o">:</span> <span class="k">assert</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;=</span><span class="m">2</span><span class="p">),</span>
      <span class="n">letterOne</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="m">0</span><span class="p">],</span>
      <span class="n">letterTwo</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="m">1</span><span class="p">];</span> 
<span class="p">}</span>
</code></pre></div><h2 id="命名构造器">命名构造器</h2>
<p>为了允许类有多个构造函数，Dart 支持命名构造函数:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">Point</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

  <span class="n">Point</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>

  <span class="n">Point</span><span class="p">.</span><span class="n">origin</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>    
  <span class="p">}</span>    
<span class="p">}</span>
</code></pre></div><p>要使用命名构造函数，请使用它的全名来调用它:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">final</span> <span class="n">myPoint</span> <span class="o">=</span> <span class="n">Point</span><span class="p">.</span><span class="n">origin</span><span class="p">();</span>
</code></pre></div><h3 id="代码示例-12">代码示例</h3>
<p>给 <code>Color</code> 类一个名为 <code>Color.black</code> 的构造函数，将三个属性都设置为 0。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">Color</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">red</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">green</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">blue</span><span class="p">;</span>
  
  <span class="n">Color</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">red</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">green</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">blue</span><span class="p">);</span>

  <span class="n">Color</span><span class="p">.</span><span class="n">black</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">red</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="n">green</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="n">blue</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
  <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div><h2 id="工厂构造函数">工厂构造函数</h2>
<p>Dart 支持工厂构造函数，它可以返回子类型甚至 null。要创建一个工厂构造函数，请使用 <code>factory</code> 关键字:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">Square</span> <span class="kd">extends</span> <span class="n">Shape</span> <span class="p">{}</span>

<span class="kd">class</span> <span class="nc">Circle</span> <span class="kd">extends</span> <span class="n">Shape</span> <span class="p">{}</span>

<span class="kd">class</span> <span class="nc">Shape</span> <span class="p">{</span>
  <span class="n">Shape</span><span class="p">();</span>

  <span class="kd">factory</span> <span class="n">Shape</span><span class="p">.</span><span class="n">fromTypeName</span><span class="p">(</span><span class="kt">String</span> <span class="n">typeName</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">typeName</span> <span class="o">==</span> <span class="s1">&#39;square&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="n">Square</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">typeName</span> <span class="o">==</span> <span class="s1">&#39;circle&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="n">Circle</span><span class="p">();</span>

    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;I don</span><span class="se">\&#39;</span><span class="s1">t recognize </span><span class="si">$</span><span class="n">typeName</span><span class="s1">&#39;</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">null</span>
  <span class="p">}</span>    
<span class="p">}</span>
</code></pre></div><h3 id="代码示例-13">代码示例</h3>
<p>填入名为 <code>IntegerHolder.fromList</code> 的工厂构造函数，使其做以下工作:</p>
<ul>
<li>如果列表有一个值，就用这个值创建一个 <code>IntegerSingle</code>。</li>
<li>如果列表有两个值，则用该值依次创建一个 <code>IntegerDouble</code>。</li>
<li>如果列表有三个值，则按顺序创建一个 <code>IntegerTriple</code>。</li>
<li>否则，返回 null。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">IntegerHolder</span> <span class="p">{</span>
  <span class="n">IntegerHolder</span><span class="p">();</span>
  
  <span class="kd">factory</span> <span class="n">IntegerHolder</span><span class="p">.</span><span class="n">fromList</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">?</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">IntegerSingle</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">?</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="m">2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">IntegerDouble</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">list</span><span class="p">[</span><span class="m">1</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">?</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="m">3</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">IntegerTriple</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">list</span><span class="p">[</span><span class="m">1</span><span class="p">],</span> <span class="n">list</span><span class="p">[</span><span class="m">2</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span> 
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">IntegerSingle</span> <span class="kd">extends</span> <span class="n">IntegerHolder</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">IntegerSingle</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">a</span><span class="p">);</span> 
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">IntegerDouble</span> <span class="kd">extends</span> <span class="n">IntegerHolder</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">IntegerDouble</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">b</span><span class="p">);</span> 
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">IntegerTriple</span> <span class="kd">extends</span> <span class="n">IntegerHolder</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">IntegerTriple</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">c</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div><h2 id="重定向构造函数">重定向构造函数</h2>
<p>有时，一个构造函数的唯一目的是重定向到同一类中的另一个构造函数。重定向构造函数的主体是空的，构造函数调用出现在冒号(:)之后。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">Automobile</span> <span class="p">{</span>
  <span class="kt">String</span> <span class="n">make</span><span class="p">;</span>
  <span class="kt">String</span> <span class="n">model</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">mpg</span><span class="p">;</span>

  <span class="c1">// 这个类的主构造函数
</span><span class="c1"></span>  <span class="n">Automobile</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">make</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">model</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">mpg</span><span class="p">);</span>

  <span class="c1">// 代理到主构造函数
</span><span class="c1"></span>  <span class="n">Automobile</span><span class="p">.</span><span class="n">hybrid</span><span class="p">(</span><span class="kt">String</span> <span class="n">make</span><span class="p">,</span> <span class="kt">String</span> <span class="n">model</span><span class="p">)</span> <span class="o">:</span> <span class="k">this</span><span class="p">(</span><span class="n">make</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="m">60</span><span class="p">);</span>

  <span class="c1">// 代理到命名构造函数
</span><span class="c1"></span>  <span class="n">Automobile</span><span class="p">.</span><span class="n">fancyHybrid</span><span class="p">()</span> <span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="n">hybrid</span><span class="p">(</span><span class="s1">&#39;Futurecar&#39;</span><span class="p">,</span> <span class="s1">&#39;Mark 2&#39;</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div><h3 id="代码示例-14">代码示例</h3>
<p>还记得上面的 <code>Color</code> 类吗？创建一个名为 <code>black</code> 的命名构造函数，但不是手动分配属性，而是将其重定向到默认构造函数，参数为 0。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">Color</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">red</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">green</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">blue</span><span class="p">;</span>
  
  <span class="n">Color</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">red</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">green</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">blue</span><span class="p">);</span>

  <span class="n">Color</span><span class="p">.</span><span class="n">black</span><span class="p">()</span> <span class="o">:</span> <span class="k">this</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="常量构造函数">常量构造函数</h2>
<p>如果你的类产生的对象永远不会改变，你可以让这些对象成为编译时常量。要做到这一点，请定义一个 <code>const</code> 构造函数，并确保所有的实例变量都是最终变量。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">ImmutablePoint</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="n">ImmutablePoint</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>

  <span class="kd">final</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>

  <span class="kd">static</span> <span class="kd">const</span> <span class="n">ImmutablePoint</span> <span class="n">origin</span> <span class="o">=</span> <span class="n">ImmutablePoint</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h3 id="代码示例-15">代码示例</h3>
<p>修改 <code>Recipe</code> 类，使它的实例可以是常量，并创建一个常量构造函数，执行以下操作。</p>
<ul>
<li>有三个参数： <code>ingredients</code>, <code>calories</code> 和 <code>milligramsOfSodium</code>(按顺序)。</li>
<li>使用 <code>this.</code> 语法，自动将参数值分配给同名的对象属性。</li>
<li>是常量，在构造函数声明中，<code>const</code> 关键字就在 <code>Recipe</code> 前面。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">Recipe</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">ingredients</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">calories</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">double</span> <span class="n">milligramsOfSodium</span><span class="p">;</span>

  <span class="kd">const</span> <span class="n">Recipe</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">ingredients</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">calories</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">milligramsOfSodium</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="下一步是什么">下一步是什么？</h2>
<p>我们希望你喜欢使用这个 codelab 来学习或测试你对 Dart 语言一些最有趣的功能的知识。这里有一些关于现在要做什么的建议。</p>
<ul>
<li>试试<a href="https://dart.dev/codelabs">其他的 Dart 代码实验室</a>.</li>
<li>阅读 <a href="https://dart.dev/guides/language/language-tour">Dart 语言之旅</a>。</li>
<li>玩 <a href="https://dartpad.dev/">DartPad</a>。</li>
<li>获取 <a href="https://dart.dev/get-dart">Dart SDK</a>。</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/string" term="string" label="string" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/cheatsheet" term="cheatsheet" label="cheatsheet" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/dart" term="dart" label="dart" />
                            
                        
                    
                
            
        </entry>
    
</feed>
