<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>
            
                    6.d on
                
            
            焉知非鱼</title>
        <link>https://ohmyweekly.github.io/tags/6.d/</link>
        <description>Recent content  in 6.d
            on 焉知非鱼</description>
        <language>en-us</language>
        <lastBuildDate>Fri, 04 Sep 2020 12:45:40 +0800</lastBuildDate>
        <generator>Hugo -- gohugo.io</generator>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
            <atom:link href="https://ohmyweekly.github.io/tags/6.d/index.xml" rel="self" type="application/rss&#43;xml" />
        
            
            <item>
                <title>Checklist for Raku 6.d</title>
                <link>https://ohmyweekly.github.io/notes/2020-07-21-checklist-for-6-dot-d/</link>
                
                
                <description>&lt;blockquote&gt;Checklist for 6.d&lt;/blockquote&gt;&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;p&gt;在 6.d 版本中, 很多东西都发生了变化, 我们至少需要发布一个版本。&lt;a href=&#34;https://github.com/perl6/roast/blob/master/docs/announce/6.d.md&#34;&gt;这里有个列表&lt;/a&gt;。然而, 覆盖面是不完整的。弃用通知采取了不同的形式, 一些新的类型和方法在那里, 一些则没有&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;#2632&lt;/code&gt; 引用这个问题, 并检查项目, 当你的工作, 无论是通过改变后的文档, 看到没有变化, 需要做它。在这种情况下, 请通过评论或如何解释为什么是这种情况。&lt;/p&gt;
&lt;h2 id=&#34;版本控制的变更&#34;&gt;版本控制的变更&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[6.d]&lt;/strong&gt; &lt;code&gt;&amp;amp;await&lt;/code&gt; 在等待的时候不再阻塞线程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[6.d]&lt;/strong&gt; &lt;code&gt;whenever&lt;/code&gt; 不在 &lt;code&gt;react&lt;/code&gt; 抛出的词法作用域内&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[6.d]&lt;/strong&gt; 在 &lt;code&gt;sub MAIN&lt;/code&gt; 里面的 &lt;code&gt;$*ARGFILES&lt;/code&gt; 总是由 &lt;code&gt;$*IN&lt;/code&gt; 馈入&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[6.d]&lt;/strong&gt; 结构(字面上的) &lt;code&gt;$()&lt;/code&gt;、&lt;code&gt;@()&lt;/code&gt; 和 &lt;code&gt;%()&lt;/code&gt; 不复存在&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[6.d]&lt;/strong&gt; 带有 &lt;code&gt;:D&lt;/code&gt;/&lt;code&gt;:U&lt;/code&gt; 类型约束的变量默认为约束类型的类型对象(例如, 你可以在它们身上使用 &lt;code&gt;.new&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[6.d]&lt;/strong&gt; &lt;code&gt;start&lt;/code&gt; 块在 sink 上下文中附加异常处理程序&lt;/li&gt;
&lt;li&gt;~~**[6.d]** 例程必须使用 &lt;code&gt;return-rw&lt;/code&gt; 来返回一个 &lt;code&gt;Proxy&lt;/code&gt;, 即使例程被标记为 &lt;code&gt;is raw&lt;/code&gt; 或 &lt;code&gt;is rw&lt;/code&gt;~~&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[6.d]&lt;/strong&gt; 原生的 &lt;code&gt;num&lt;/code&gt; 类型默认为 &lt;code&gt;0e0&lt;/code&gt; 而不是 &lt;code&gt;NaN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[6.d]&lt;/strong&gt; 在子程序名中, 保留了键名为 &lt;code&gt;sym&lt;/code&gt; 的冒号对（如&lt;code&gt;:sym&amp;lt;foo&amp;gt;&lt;/code&gt;）, 以备将来使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;废弃&#34;&gt;废弃&lt;/h2&gt;
&lt;p&gt;这些方法在 6.d 语言中已被废弃, 并将在 6.e 中被删除。实现者可以选择发出弃用警告, 或者在 6.e 版本发布后更长的时间内提供这些方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;&#39;-&#39;&lt;/code&gt; (单连字符)作为 &lt;code&gt;&amp;amp;open&lt;/code&gt; 的特殊路径, 表示特殊的句柄(使用 &lt;code&gt;IO::Special&lt;/code&gt; 对象代替)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Handle.slurp-rest&lt;/code&gt; (使用 &lt;code&gt;.slurp&lt;/code&gt; 代替)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Any.flatmap&lt;/code&gt; (使用&lt;code&gt;.flat&lt;/code&gt; 和 &lt;code&gt;.map&lt;/code&gt; 方法的组合来代替)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cool.path&lt;/code&gt; (使用 &lt;code&gt;.IO&lt;/code&gt; 代替)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pair.freeze&lt;/code&gt; (使用去容器化的参数的 &lt;code&gt;Pair.new&lt;/code&gt; 来代替)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Str.subst-mutate&lt;/code&gt; (使用带有 &lt;code&gt;.=&lt;/code&gt; 方法调用赋值元运算符的 &lt;code&gt;Str.subst&lt;/code&gt; 代替)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Rational.norm&lt;/code&gt; (现在 &lt;code&gt;Rational&lt;/code&gt; 类型必须在创建时标准化)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Path.child&lt;/code&gt; (使用 &lt;code&gt;.add&lt;/code&gt; 代替)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;undefine&lt;/code&gt; (直接分配 &lt;code&gt;Empty&lt;/code&gt;/&lt;code&gt;Nil&lt;/code&gt; 代替)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:count&lt;/code&gt; &lt;code&gt;&amp;amp;lines&lt;/code&gt;/&lt;code&gt;Str.lines&lt;/code&gt; 例程上的参数(使用所返回的 &lt;code&gt;Seq&lt;/code&gt; 上的 &lt;code&gt;.elems&lt;/code&gt; 代替)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;is_approx&lt;/code&gt; in Test.pm6 (使用与 &lt;code&gt;&amp;amp;is-approx&lt;/code&gt; 非常相似的行为来代替)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;新的行为&#34;&gt;新的行为&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过新的可定义的 &lt;code&gt;&amp;amp;RUN-MAIN&lt;/code&gt;、&lt;code&gt;&amp;amp;ARGS-TO-CAPTURE&lt;/code&gt; 和 &lt;code&gt;&amp;amp;GENERATE-USAGE&lt;/code&gt; 子例程改善 &lt;code&gt;sub MAIN&lt;/code&gt; 的自定义处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt; 变量中的 &lt;code&gt;QuantHash&lt;/code&gt;/&lt;code&gt;Map&lt;/code&gt; 和 &lt;code&gt;@&lt;/code&gt; 变量中的 &lt;code&gt;List&lt;/code&gt; 可以用 &lt;code&gt;is&lt;/code&gt; 特性来声明（例如，&lt;code&gt;my %h is Set&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;新的 &lt;code&gt;&amp;lt;ww&amp;gt;&lt;/code&gt; regex 规则: 只在单词内匹配&lt;/li&gt;
&lt;li&gt;循环可以从上一条语句的值中产生一个值的列表&lt;/li&gt;
&lt;li&gt;循环中的 &lt;code&gt;next&lt;/code&gt;/&lt;code&gt;last&lt;/code&gt; 收集其最后的语句值, 对它们运行的迭代返回 &lt;code&gt;Empty&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.perl&lt;/code&gt; 可以在消耗过的 &lt;code&gt;Seq&lt;/code&gt;、多维数组、&lt;code&gt;Date&lt;/code&gt; 和 &lt;code&gt;CallFrame&lt;/code&gt; 上调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gist&lt;/code&gt; 可以在 &lt;code&gt;Attribute&lt;/code&gt; 上调用&lt;/li&gt;
&lt;li&gt;对自动生成的 &lt;code&gt;USAGE&lt;/code&gt; 信息进行了大量改进&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is hidden-from-USAGE&lt;/code&gt; 特性，从自动生成的 &lt;code&gt;USAGE&lt;/code&gt; 消息中隐藏 &lt;code&gt;sub MAIN&lt;/code&gt; 候选者&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Parameter.perl&lt;/code&gt; 包括可内省的默认值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%*ENV&lt;/code&gt; 值是同素异形的&lt;/li&gt;
&lt;li&gt;尝试使用变量 &lt;code&gt;$;&lt;/code&gt;、&lt;code&gt;$,&lt;/code&gt;、&lt;code&gt;$.&lt;/code&gt;、&lt;code&gt;$\&lt;/code&gt;、&lt;code&gt;$(&lt;/code&gt;、&lt;code&gt;$)&lt;/code&gt;、&lt;code&gt;$&amp;lt;&lt;/code&gt;、&lt;code&gt;$&amp;gt;&lt;/code&gt;、&lt;code&gt;$/&lt;/code&gt;、&lt;code&gt;$\&lt;/code&gt;、&lt;code&gt;$[&lt;/code&gt;、&lt;code&gt;$-&lt;/code&gt;、&lt;code&gt;$+&lt;/code&gt; 和 &lt;code&gt;$@&lt;/code&gt; 会抛出 &lt;code&gt;X::Syntax::Perl5Var&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;默认的 &lt;code&gt;Hash.keyof&lt;/code&gt; 返回一个 &lt;code&gt;Str(Any)&lt;/code&gt; 强转类型对象&lt;/li&gt;
&lt;li&gt;非 ASCII 数字可以在 &lt;code&gt;:42foo&lt;/code&gt; 冒号对快捷方式中使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StrDistance&lt;/code&gt; 字符串化为 &lt;code&gt;.after&lt;/code&gt; 字符串&lt;/li&gt;
&lt;li&gt;更明确的 Pod 表格格式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Enumeration.enums&lt;/code&gt; 返回一个 &lt;code&gt;Map&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;各种整数类型的 &lt;code&gt;.Range&lt;/code&gt; 返回它们支持的值的范围&lt;/li&gt;
&lt;li&gt;&lt;code&gt;min&lt;/code&gt;/&lt;code&gt;max&lt;/code&gt;  例程也适用于 &lt;code&gt;Hash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Signature&lt;/code&gt; 字面值可以包含字符串/数字字面值以及调用者标记&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List.invert&lt;/code&gt; 通过所需的 &lt;code&gt;Pair&lt;/code&gt; 绑定映射, 导致潜在的类型检查失败&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:exists&lt;/code&gt; 可以与多维关联下标一起使用&lt;/li&gt;
&lt;li&gt;动态创建的列表可以用来定义一个枚举&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;.first&lt;/code&gt; 中, Junction 可以作为匹配器使用&lt;/li&gt;
&lt;li&gt;原生属性可以作为参数中的绑定目标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Proc&lt;/code&gt; 可以与其他 &lt;code&gt;Proc&lt;/code&gt; 中的 &lt;code&gt;IO::Pipe&lt;/code&gt; 一起工作&lt;/li&gt;
&lt;li&gt;类型数组可以用 &lt;code&gt;my SomeType @array&lt;/code&gt; 和 &lt;code&gt;my @array of SomeType&lt;/code&gt; 创建&lt;/li&gt;
&lt;li&gt;当把 &lt;code&gt;Mixy&lt;/code&gt; 强转为 &lt;code&gt;Setty&lt;/code&gt;/&lt;code&gt;Baggy &lt;/code&gt; 时, 负数权重的项将被删除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:nth&lt;/code&gt; 副词在 &lt;code&gt;m//&lt;/code&gt; 上接受一个 &lt;code&gt;Junction&lt;/code&gt; 作为参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CX::Warn&#39; 和 &lt;/code&gt;CX::Done&lt;code&gt;可以在&lt;/code&gt;CONTROL` phaser 中捕获&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next&lt;/code&gt; 可用于 &lt;code&gt;whenever&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;require&lt;/code&gt; 符号不再过境性地暴露出来&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;{...}&lt;/code&gt; 进行多维访问, 类似于 &lt;code&gt;[...]&lt;/code&gt; 的工作方式&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;END&lt;/code&gt; 时间打开的任何手柄都会自动关闭&lt;/li&gt;
&lt;li&gt;在缓存的 &lt;code&gt;Seq&lt;/code&gt; 上, 当 &lt;code&gt;&amp;amp;infix:&amp;lt;eqv&amp;gt;&lt;/code&gt;、&lt;code&gt;.Slip&lt;/code&gt;、&lt;code&gt;.join&lt;/code&gt;、&lt;code&gt;.List&lt;/code&gt;、&lt;code&gt;.list&lt;/code&gt;、&lt;code&gt;.eager&lt;/code&gt;、&lt;code&gt;.Array&lt;/code&gt; 和 &lt;code&gt;.is-lazy&lt;/code&gt; 被调用时, 就会使用缓存列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Handle.encoding&lt;/code&gt; 以 &lt;code&gt;Nil&lt;/code&gt; 表示切换到二进制模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is default&lt;/code&gt; 特质与属性一起工作&lt;/li&gt;
&lt;li&gt;在多重分派中, 带有 &lt;code&gt;is rw&lt;/code&gt; 特性的参数被认为比没有特性的参数窄&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;Blob&lt;/code&gt; 和 &lt;code&gt;Map&lt;/code&gt; 的 &lt;code&gt;.gist&lt;/code&gt; 被裁剪成100个元素&lt;/li&gt;
&lt;li&gt;新的 &lt;code&gt;for&lt;/code&gt; 语句修饰符 &lt;code&gt;hyper for&lt;/code&gt;、&lt;code&gt;race for&lt;/code&gt; 和 &lt;code&gt;lazy for&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for&lt;/code&gt; 循环自动序列化 &lt;code&gt;RaceSeq&lt;/code&gt;/&lt;code&gt;HyperSeq&lt;/code&gt;；使用新的 &lt;code&gt;for&lt;/code&gt; 语句修饰符&lt;code&gt;hyper for&lt;/code&gt;/&lt;code&gt;race for&lt;/code&gt;避免&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;infix:&amp;lt;does&amp;gt;&lt;/code&gt; 可用于 RHS 上的非组合实例&lt;/li&gt;
&lt;li&gt;数值比较器可以与 &lt;code&gt;DateTime &lt;/code&gt; 对象一起使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pod&lt;/code&gt; 保留空白类型&lt;/li&gt;
&lt;li&gt;定义了带 &lt;code&gt;@&lt;/code&gt;、&lt;code&gt;%&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 魔符常数的语义&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;math&#34;&gt;Math&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Rational&lt;/code&gt; 总是在创建时被化简, 并在其一生中保持不变&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Inf&lt;/code&gt;、&lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; 可以分别用 &lt;code&gt;&amp;lt;-1/0&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;1/0&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;0/0&lt;/code&gt;&amp;gt; 表示, 通过&lt;code&gt;Rational&lt;/code&gt; 类型进行舍去。零分母 &lt;code&gt;Rational&lt;/code&gt; 被标准化为这三个值之一&lt;/li&gt;
&lt;li&gt;在 ±&lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; 上调用 &lt;code&gt;.Int&lt;/code&gt;, 会抛出异常&lt;/li&gt;
&lt;li&gt;改进了 &lt;code&gt;Num&lt;/code&gt; 运算符和数学函数的 IEEE 754-2008 合规性&lt;/li&gt;
&lt;li&gt;负零 &lt;code&gt;Num&lt;/code&gt;(&lt;code&gt;-0e0&lt;/code&gt;)被所有例程和语法结构正确处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Num&lt;/code&gt; 类型的字符串化必须是可舍弃到原始 &lt;code&gt;Num&lt;/code&gt; 的&lt;/li&gt;
&lt;li&gt;定义了涉及零的 &lt;code&gt;Complex &lt;/code&gt; 指数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.expmod&lt;/code&gt; 中的负数幂有效&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;setsbagsmixesaka-quanthashes和集合运算符&#34;&gt;Sets、Bags、Mixes(aka QuantHashes)和集合运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Set 运算符可以用在任何对象上, 在需要的时候会被强转
&lt;ul&gt;
&lt;li&gt;所以, 不需要也不希望有任何预先的强转&lt;/li&gt;
&lt;li&gt;如果没有 QuantHash 就能实现所需的功能, 那么 Set 运算符可以自由地不创建任何 QuantHash&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对不同类型的 QuantHashes 的 Set 操作将强转到最自由的形式（Set -&amp;gt; Bag -&amp;gt; Mix）&lt;/li&gt;
&lt;li&gt;集合运算符的 set_precedes 家族( &lt;code&gt;(&amp;lt;+)&lt;/code&gt;、&lt;code&gt;≼&lt;/code&gt;、&lt;code&gt;(&amp;gt;+)&lt;/code&gt;、&lt;code&gt;≽&lt;/code&gt;) 已被移除
&lt;ul&gt;
&lt;li&gt;曾经是子集运算符的 Baggy 形式&lt;/li&gt;
&lt;li&gt;QuantHash 升级为最自由的形式, 所以 &lt;code&gt;(&amp;lt;=)&lt;/code&gt;、&lt;code&gt;⊆&lt;/code&gt;、&lt;code&gt;(&amp;gt;=)&lt;/code&gt;、&lt;code&gt;⊇&lt;/code&gt; 做正确的事情&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.classify-list&lt;/code&gt; 方法可用于 &lt;code&gt;Baggy&lt;/code&gt; 类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.categorize-list&lt;/code&gt; 方法可用于 &lt;code&gt;Baggy&lt;/code&gt; 类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.invert&lt;/code&gt; 方法可用于核心 &lt;code&gt;QuantHash&lt;/code&gt; 类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.antipairs&lt;/code&gt; 方法可用于 &lt;code&gt;QuantHash&lt;/code&gt; 类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QuantHash&lt;/code&gt; 类型有 &lt;code&gt;.new-from-pairs&lt;/code&gt; 和将一个 &lt;code&gt;QuantHash&lt;/code&gt; 类型转换为另一个 &lt;code&gt;QuantHash&lt;/code&gt; 类型的方法(例如 &lt;code&gt;Set&lt;/code&gt; 类型的 &lt;code&gt;.Bag&lt;/code&gt; 方法)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QuantHash&lt;/code&gt; 类型上的 &lt;code&gt;.hash&lt;/code&gt; 对键值进行了字符串化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;新的形参和实参&#34;&gt;新的形参和实参&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Date.new&lt;/code&gt; 接受一个 &lt;code&gt;:&amp;amp;formatter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.first&lt;/code&gt; 可以接受 &lt;code&gt;:kv&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unique&lt;/code&gt; 和 &lt;code&gt;.repeated&lt;/code&gt; 可以接受 &lt;code&gt;:&amp;amp;as&lt;/code&gt; 和 &lt;code&gt;:&amp;amp;with&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Test.pm6 中的 &lt;code&gt;&amp;amp;plan&lt;/code&gt; 可以接受 &lt;code&gt;:skip-all&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;run&lt;/code&gt;/&lt;code&gt;&amp;amp;shell&lt;/code&gt; 可以接受 &lt;code&gt;:merge&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;note&lt;/code&gt; 可以在没有参数的情况下调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;open&lt;/code&gt; 接受 &lt;code&gt;:$out-buffer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Path.resolve&lt;/code&gt; 可以接受 &lt;code&gt;:completely&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Path.parent&lt;/code&gt; 可以接受一个 &lt;code&gt;Int&lt;/code&gt; 表示父级&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Proc::Async.new&lt;/code&gt; 吞噬位置参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Signature.ACCEPTS&lt;/code&gt; 接受非 &lt;code&gt;Signature&lt;/code&gt;/&lt;code&gt;Capture&lt;/code&gt; 参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;EVAL&lt;/code&gt; 可以接受一个 &lt;code&gt;Blob&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Promise.keep&lt;/code&gt;/&lt;code&gt;.break&lt;/code&gt; 可以在没有参数的情况下调用&lt;/li&gt;
&lt;li&gt;原生数组上的 &lt;code&gt;.sum&lt;/code&gt; 可以接受 &lt;code&gt;:wrap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is required&lt;/code&gt; 现在可以接受一个表示理由的参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Socket::Async.listen&lt;/code&gt; 可以绑定到端口 &lt;code&gt;0&lt;/code&gt; 以向操作系统申请免费端口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.encode&lt;/code&gt; 可以接受 &lt;code&gt;:translate-nl&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;新的例程和运算符&#34;&gt;新的例程和运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;新的 &lt;code&gt;atomicint&lt;/code&gt; Unicode 运算符和 ASCII 等价物, 保证线程安全, 原子操作:
&lt;code&gt;&amp;amp;infix:&amp;lt;⚛=&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;amp;atomic-assign&lt;/code&gt;、&lt;code&gt;&amp;amp;prefix:&amp;lt;⚛&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;amp;atomic-fetch&lt;/code&gt;、
&lt;code&gt;&amp;amp;prefix:&amp;lt;++⚛&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;amp;atomic-inc-fetch&lt;/code&gt;、&lt;code&gt;&amp;amp;postfix:&amp;lt;⚛++&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;amp;atomic-fetch-inc&lt;/code&gt;、
&lt;code&gt;&amp;amp;prefix:&amp;lt;--⚛&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;amp;atomic-dec-fetch&lt;/code&gt;、&lt;code&gt;&amp;amp;postfix:&amp;lt;⚛--&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;amp;atomic-fetch-dec&lt;/code&gt;、
&lt;code&gt;&amp;amp;infix:&amp;lt;⚛-=&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;amp;infix:&amp;lt;⚛−=&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;amp;atomic-fetch-sub&lt;/code&gt; 和 &lt;code&gt;&amp;amp;infix:&amp;lt;⚛+=&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;amp;atomic-fetch-add&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;cas&lt;/code&gt;: 原子比较与交换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;≤&lt;/code&gt;、&lt;code&gt;≥&lt;/code&gt; 和 &lt;code&gt;≠&lt;/code&gt; 运算符是 Unicode 运算符, 分别等价于 &lt;code&gt;&amp;lt;=&lt;/code&gt;、&lt;code&gt;&amp;gt;=&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;infix:&amp;lt;unicmp&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;amp;infix:&amp;lt;coll&amp;gt;&lt;/code&gt;: &lt;code&gt;&amp;amp;infix:&amp;lt;cmp&amp;gt;&lt;/code&gt; 的替代行为&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TR///&lt;/code&gt;: &lt;code&gt;tr///&lt;/code&gt; 的非变异版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;submethod TWEAK&lt;/code&gt;: 与 &lt;code&gt;BUILD&lt;/code&gt; 类似, 除了它与属性默认值兼容之外&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;duckmap&lt;/code&gt;: 应用 &lt;code&gt;&amp;amp;callable&lt;/code&gt; 到每个元素上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;deepmap&lt;/code&gt;: 应用 &lt;code&gt;&amp;amp;callable&lt;/code&gt; 到每个元素上, 下降到 &lt;code&gt;Iterable&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;take-rw&lt;/code&gt;: 像 &lt;code&gt;&amp;amp;take&lt;/code&gt; 一样, 但有一个可写的容器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;indir&lt;/code&gt;: 在给定的 &lt;code&gt;$*CWD&lt;/code&gt; 中执行代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;spurt&lt;/code&gt;: 参见 &lt;code&gt;IO::Path.spurt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;prompt&lt;/code&gt;: 提示用户输入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uniprops&lt;/code&gt;: &lt;code&gt;uniprop&lt;/code&gt; 的多字符版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;symlink&lt;/code&gt;: 建立文件符号链接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;link&lt;/code&gt;: 创建文件硬连接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.hyper&lt;/code&gt;/&lt;code&gt;.race&lt;/code&gt;: 并行处理值的列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Seq.from-loop&lt;/code&gt;: 从 &lt;code&gt;Callable&lt;/code&gt; 生产一个 &lt;code&gt;Seq&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Str.uniparse&lt;/code&gt;: 将一个或多个 Unicode 字符名解析为实际字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Str.parse-base&lt;/code&gt;: &lt;code&gt;Int.base&lt;/code&gt; 操作的反转&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Path&lt;/code&gt; 提供了 &lt;code&gt;.ACCEPTS&lt;/code&gt;、&lt;code&gt;.SPEC&lt;/code&gt;、&lt;code&gt;.CWD&lt;/code&gt;、&lt;code&gt;.Numeric&lt;/code&gt;、&lt;code&gt;.add&lt;/code&gt;、&lt;code&gt;.extension&lt;/code&gt;、&lt;code&gt;.mode&lt;/code&gt; 和各种文件测试、&lt;code&gt;.parts&lt;/code&gt;、&lt;code&gt;.sibling&lt;/code&gt; 和 &lt;code&gt;.spurt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Handle&lt;/code&gt; 提供了 &lt;code&gt;.READ&lt;/code&gt;、&lt;code&gt;.WRITE&lt;/code&gt;、&lt;code&gt;.EOF&lt;/code&gt;、&lt;code&gt;.DESTROY&lt;/code&gt;,
&lt;code&gt;.readchars&lt;/code&gt;、&lt;code&gt;.flush&lt;/code&gt;、&lt;code&gt;.lock&lt;/code&gt;、&lt;code&gt;.unlock&lt;/code&gt;、&lt;code&gt;.out-buffer&lt;/code&gt;、&lt;code&gt;.tell&lt;/code&gt;,
&lt;code&gt;.say&lt;/code&gt;、&lt;code&gt;.slurp&lt;/code&gt;、&lt;code&gt;.seek&lt;/code&gt;、&lt;code&gt;.printf&lt;/code&gt;、&lt;code&gt;.print-nl&lt;/code&gt; 和 &lt;code&gt;.watch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Pipe&lt;/code&gt; 提供了 &lt;code&gt;.proc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Iterator&lt;/code&gt; 提供了 &lt;code&gt;.skip-one&lt;/code&gt;、&lt;code&gt;.skip-at-least&lt;/code&gt; 和 &lt;code&gt;.skip-at-least-pull-one&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mu.emit&lt;/code&gt;: &lt;code&gt;&amp;amp;emit&lt;/code&gt; 的方法形式&lt;/li&gt;
&lt;li&gt;Test.pm6 模块中的 &lt;code&gt;&amp;amp;fails-like&lt;/code&gt;: 允许测试失败&lt;/li&gt;
&lt;li&gt;Test.pm6 模块中的 &lt;code&gt;&amp;amp;bail-out&lt;/code&gt;: 退出失败的测试套件&lt;/li&gt;
&lt;li&gt;Test.pm6 模块中的 &lt;code&gt;&amp;amp;is-approx&lt;/code&gt;: 测试一个数字近似于另一个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Buf&lt;/code&gt; 拥有 &lt;code&gt;.allocate&lt;/code&gt;、&lt;code&gt;.reallocate&lt;/code&gt;、&lt;code&gt;.append&lt;/code&gt;、&lt;code&gt;.push&lt;/code&gt;、&lt;code&gt;.pop&lt;/code&gt;、&lt;code&gt;.splice&lt;/code&gt;、&lt;code&gt;.subbuf-rw&lt;/code&gt;、&lt;code&gt;.prepend&lt;/code&gt; 和 &lt;code&gt;.unshift&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Range&lt;/code&gt; 支持了 &lt;code&gt;.rand&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Backtrace&lt;/code&gt; 拥有方法 &lt;code&gt;.map&lt;/code&gt;、&lt;code&gt;.flat&lt;/code&gt;、&lt;code&gt;.concise&lt;/code&gt; 和 &lt;code&gt;.summary&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.classify-list&lt;/code&gt; 方法可用于 &lt;code&gt;Hash&lt;/code&gt; 类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.categorize-list&lt;/code&gt; 方法可用于 &lt;code&gt;Hash&lt;/code&gt; 类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Code.of&lt;/code&gt;: 返回返回类型约束&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Code.line&lt;/code&gt;/&lt;code&gt;.file&lt;/code&gt;: 返回定义的行/文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Proc::Async&lt;/code&gt; 提供了 &lt;code&gt;.Supply&lt;/code&gt;、&lt;code&gt;.ready&lt;/code&gt;、&lt;code&gt;.pid&lt;/code&gt;、&lt;code&gt;.bind-stdin&lt;/code&gt;、&lt;code&gt;.bind-stdout&lt;/code&gt; 和 &lt;code&gt;.bind-stderr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Proc.command&lt;/code&gt;/&lt;code&gt;Proc::Async.command&lt;/code&gt;: 我们要执行的命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Proc&lt;/code&gt; 提供了 &lt;code&gt;.signal&lt;/code&gt;、&lt;code&gt;.pid&lt;/code&gt; 和 &lt;del&gt;&lt;code&gt;.encoding&lt;/code&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Complex&lt;/code&gt; 提供了 &lt;code&gt;.cis&lt;/code&gt;、&lt;code&gt;.reals&lt;/code&gt;、&lt;code&gt;.ceiling&lt;/code&gt;、&lt;code&gt;.floor&lt;/code&gt;、&lt;code&gt;.round&lt;/code&gt;、&lt;code&gt;.truncate&lt;/code&gt; 和 &lt;code&gt;.abs&lt;/code&gt; 方法, 并可以使用 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 进行比较(只要虚部可以忽略不计)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DateTime&lt;/code&gt; 提供了 &lt;code&gt;.offset-in-hours&lt;/code&gt;、&lt;code&gt;.hh-mm-ss&lt;/code&gt; 和 &lt;code&gt;.Date&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DateTime&lt;/code&gt; 可以使用 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 运算符和其它 &lt;code&gt;DateTime&lt;/code&gt; 对象进行比较&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Date&lt;/code&gt; 提供了 &lt;code&gt;.DateTime&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;infix:&amp;lt;+&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;amp;infix:&amp;lt;-&amp;gt;&lt;/code&gt; 可以被 &lt;code&gt;Duration&lt;/code&gt;、&lt;code&gt;DateTime&lt;/code&gt; 和 &lt;code&gt;Real&lt;/code&gt; 类型调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Enumeration&lt;/code&gt; 提供了 &lt;code&gt;.Int&lt;/code&gt;、&lt;code&gt;.pred&lt;/code&gt;、&lt;code&gt;.succ&lt;/code&gt;、&lt;code&gt;.kv&lt;/code&gt; 和 &lt;code&gt;.pair&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.Date&lt;/code&gt; 可以在 &lt;code&gt;Instant&lt;/code&gt; 上调用&lt;/li&gt;
&lt;li&gt;Junction 能使用 &lt;code&gt;Junction.new&lt;/code&gt; 调用来创建&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&lt;/code&gt; 类型拥有 &lt;code&gt;.to&lt;/code&gt; 和 &lt;code&gt;.from&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map&lt;/code&gt; type 提供了 &lt;code&gt;Int&lt;/code&gt; 方法, 返回 pair 的数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Any.skip&lt;/code&gt;: 跳过列表中的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Any.batch&lt;/code&gt;: &lt;code&gt;.rotor&lt;/code&gt; 的更基本的表兄弟&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mu.iterator&lt;/code&gt;: 为一个列表中的值生成一个 &lt;code&gt;Iterator&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Spec::*&lt;/code&gt; 类型提供了 &lt;code&gt;.tmpdir&lt;/code&gt;、&lt;code&gt;.extension&lt;/code&gt; 和 &lt;code&gt;.path&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pair&lt;/code&gt; 提供了 &lt;code&gt;.ACCEPTS&lt;/code&gt;、&lt;code&gt;.Pair&lt;/code&gt; 和 &lt;code&gt;.invert&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.Capture&lt;/code&gt; 方法对所有核心类型都有明确定义&lt;/li&gt;
&lt;li&gt;定义了 &lt;code&gt;.ACCEPTS&lt;/code&gt; 在同素异形体上的语义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Failure.self&lt;/code&gt; 使未处理的 &lt;code&gt;Failure&lt;/code&gt; 爆发&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread.is-initial-thread&lt;/code&gt;: 我们是在初始线程中运行吗&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Match&lt;/code&gt; 提供了 &lt;code&gt;.Int&lt;/code&gt; 和 &lt;code&gt;.actions&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Socket::Async&lt;/code&gt; 提供了 &lt;code&gt;.socket-port&lt;/code&gt; 和 &lt;code&gt;.peer-port&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Promise&lt;/code&gt; 提供了另一种构造函器 &lt;code&gt;.kept&lt;/code&gt; 和 &lt;code&gt;.broken&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WhateverCode&lt;/code&gt; 提供了 &lt;code&gt;.assuming&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WhateverCode&lt;/code&gt; 和 &lt;code&gt;Block&lt;/code&gt; 提供了 &lt;code&gt;.cando&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.:&amp;lt;…&amp;gt;&lt;/code&gt; 语法用于调用前缀运算符作为后缀&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$*KERNEL&lt;/code&gt; 提供了 &lt;code&gt;.hostname&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Nil&lt;/code&gt; 拥有定义的 &lt;code&gt;.FALLBACK&lt;/code&gt; 特殊方法来返回 &lt;code&gt;Nil&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;新类型&#34;&gt;新类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;atomicint&lt;/code&gt;: 原生的 &lt;code&gt;int&lt;/code&gt;, 大小可用于新的原子运算符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lock::Async&lt;/code&gt;: 互斥的非阻塞机制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Encoding::Registry&lt;/code&gt;: 管理可用的编码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Encoding::Encoder&lt;/code&gt;: 编码器, 用于特定的编码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Encoding::Decoder&lt;/code&gt;: 解码器, 用于特定的编码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::CatHandle&lt;/code&gt;: 将多个只读的 &lt;code&gt;IO::Handle&lt;/code&gt; 视同一个&lt;/li&gt;
&lt;li&gt;原生的 &lt;code&gt;str&lt;/code&gt; 数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Supplier::Preserving&lt;/code&gt;: 缓存的实时 &lt;code&gt;Supply&lt;/code&gt; 工厂&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Semaphore&lt;/code&gt;: 控制多线程对共享资源的访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Special&lt;/code&gt;: 特殊I/O设备的路径 (例如 &lt;code&gt;STDOUT&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Exceptions::JSON&lt;/code&gt; 自定义异常处理程序的实现(可与&lt;code&gt;PERL6_EXCEPTIONS_HANDLER&lt;/code&gt; 环境变量一起使用)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SeekType&lt;/code&gt; 枚举: &lt;code&gt;IO::Handle.seek&lt;/code&gt; 中使用的值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;新的变量&#34;&gt;新的变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$*USAGE&lt;/code&gt;: 可在 &lt;code&gt;MAIN&lt;/code&gt; 子例程中使用, 包含自动生成的 &lt;code&gt;USAGE&lt;/code&gt; 信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;%*SUB-MAIN-OPTS: 设置 &lt;code&gt;sub MAIN&lt;/code&gt; 的行为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%*SUB-MAIN-OPTS&amp;lt;named-anywhere&amp;gt;&lt;/code&gt; 允许将命名参数放在命令行的任何位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$*COLLATION&lt;/code&gt;: 配置四个 Unicode 校对级别&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$*INIT-INSTANT&lt;/code&gt;: 代表程序启动时间的 &lt;code&gt;Instant&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$*HOME&lt;/code&gt;: 用户的主目录, 如果存在的话&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;*chdir&lt;/code&gt;: &lt;code&gt;Callable&lt;/code&gt; 包含 &lt;code&gt;IO::Path.chdir&lt;/code&gt; 的变体, 也设置进程的当前目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PERL6_TEST_DIE_ON_FAIL&lt;/code&gt; 环境变量: 在第一次失败时停止测试套件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PERL6_EXCEPTIONS_HANDLER&lt;/code&gt; 环境变量: 指定自定义异常处理类&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;对边缘情况强转行为的澄清&#34;&gt;对边缘情况/强转行为的澄清&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UInt&lt;/code&gt; 与 &lt;code&gt;Int&lt;/code&gt; 类型对象智能匹配为 &lt;code&gt;True&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sink&lt;/code&gt; 语句前缀爆炸 &lt;code&gt;Failure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义了1项和0项列表以及负参数和非整数参数的 &lt;code&gt;permutations&lt;/code&gt;/&lt;code&gt;combinations&lt;/code&gt; 的行为&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;val&lt;/code&gt;、&lt;code&gt;Str.Numeric&lt;/code&gt; 和其他 &lt;code&gt;Str&lt;/code&gt; 数字转换方法在试图转换 Unicode &lt;code&gt;No&lt;/code&gt; 字符组或合成数字时会 &lt;code&gt;fail&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:42foo&lt;/code&gt; 冒号对快捷方式中不能使用合成数字&lt;/li&gt;
&lt;li&gt;现在、&lt;code&gt;Enumeration&lt;/code&gt; 可以作为一个数组形状指定器使用&lt;/li&gt;
&lt;li&gt;含有空格的 &lt;code&gt;Str&lt;/code&gt; 的数值转换现在返回 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;带空的模式参数的 &lt;code&gt;samark&lt;/code&gt;, 简单地返回调用者&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.polymod&lt;/code&gt; 可用于 &lt;code&gt;lazy&lt;/code&gt; 但有限的除数列表&lt;/li&gt;
&lt;li&gt;定义了 &lt;code&gt;.[*-0]&lt;/code&gt; 索引&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.rotor&lt;/code&gt; 中大于子列表的负数空隙抛出异常&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.rotor&lt;/code&gt; 的非 &lt;code&gt;Int&lt;/code&gt; 参数被强转为 &lt;code&gt;Int&lt;/code&gt; 参数&lt;/li&gt;
&lt;li&gt;读取 &lt;code&gt;/proc&lt;/code&gt; 文件时定义了 &lt;code&gt;.lines&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义了字符串上后缀/前缀  &lt;code&gt;++&lt;/code&gt;/&lt;code&gt;--&lt;/code&gt; 中泰语数字的行为&lt;/li&gt;
&lt;li&gt;sunk &lt;code&gt;for&lt;/code&gt; 里面的 &lt;code&gt;map&lt;/code&gt; 被视为 sunk&lt;/li&gt;
&lt;li&gt;Sunk &lt;code&gt;for&lt;/code&gt; 循环将上一条语句的方法调用值下沉&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bool&lt;/code&gt; 对象上的 &lt;code&gt;.Int&lt;/code&gt; 返回一个 &lt;code&gt;Int&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;splice&lt;/code&gt; 可用于扩展数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;classify&lt;/code&gt; 可以与 &lt;code&gt;Junction&lt;/code&gt; 配合使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pairup&lt;/code&gt; on a type object returns an empty &lt;code&gt;Seq&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pairup&lt;/code&gt; 总是返回一个 &lt;code&gt;Seq&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;拒绝接受  &lt;code&gt;Date&lt;/code&gt;/&lt;code&gt;DateTime&lt;/code&gt; 构造函数中的合成代码点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;⸨&lt;/code&gt;/&lt;code&gt;⸩&lt;/code&gt; 对儿现在可以作为引号结构中的匹配字符使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array&lt;/code&gt; 类型对象上的 &lt;code&gt;.flat&lt;/code&gt; 简单地返回该类型对象&lt;/li&gt;
&lt;li&gt;混合级 &lt;code&gt;classify&lt;/code&gt; 在 &lt;code&gt;Hash&lt;/code&gt; 上抛出异常&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Junction&lt;/code&gt; 可以用于给 &lt;code&gt;Hash&lt;/code&gt; 指定多个键&lt;/li&gt;
&lt;li&gt;给 &lt;code&gt;.classify-list&lt;/code&gt; 的 &lt;code&gt;Callable&lt;/code&gt; 现在保证每项只执行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:delete&lt;/code&gt; 对 &lt;code&gt;Hash&lt;/code&gt; 类型对象进行关联查找时返回 &lt;code&gt;Nil&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Test.pm6 中的 &lt;code&gt;&amp;amp;is-deeply&lt;/code&gt; 会自动 &lt;code&gt;.cache&lt;/code&gt; 作为参数的 &lt;code&gt;Seq&lt;/code&gt;, 并使用返回的 &lt;code&gt;List&lt;/code&gt; 进行测试&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Complex.new()&lt;/code&gt; 给出 &lt;code&gt;&amp;lt;0+0i&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Int.new&lt;/code&gt; 现在可以保证构建一个新的 &lt;code&gt;Int&lt;/code&gt; (而不是, 比如说, 从常量缓存中重用一个)&lt;/li&gt;
&lt;li&gt;定义了一个参数(1-arg)版本的 &lt;code&gt;&amp;amp;infix:&amp;lt;=:=&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;infix:&amp;lt;eqv&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果直接或间接地调用 &lt;code&gt;.BIND-POS&lt;/code&gt;、&lt;code&gt;.BIND-KEY&lt;/code&gt;、&lt;code&gt;.ASSIGN-POS&lt;/code&gt;、&lt;code&gt;.ASSIGN-KEY&lt;/code&gt;、&lt;code&gt;.STORE&lt;/code&gt;、&lt;code&gt;.push&lt;/code&gt;、&lt;code&gt;.append&lt;/code&gt;、&lt;code&gt;.unshift&lt;/code&gt;、&lt;code&gt;.prepend&lt;/code&gt;、&lt;code&gt;Nil&lt;/code&gt; 类型现在抛出异常&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Nil.ord&lt;/code&gt; 返回一个空的 &lt;code&gt;Seq&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Nil.chrs&lt;/code&gt; 返回一个 &lt;code&gt;&amp;quot;\0&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Num.new&lt;/code&gt; 强转参数为 &lt;code&gt;Num&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;infix:&amp;lt;Z&amp;gt;()&lt;/code&gt; 返回一个空的 &lt;code&gt;Seq&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.comb&lt;/code&gt; 总是返回一个 &lt;code&gt;Seq&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;&amp;amp;infix:&amp;lt;+&amp;gt;&lt;/code&gt; 化简一个项, 简单地返回该项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;()[0]&lt;/code&gt; 返回 &lt;code&gt;Nil&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;允许在(可能是无限的) &lt;code&gt;Seq&lt;/code&gt; 上使用 Regex 智能匹配&lt;/li&gt;
&lt;li&gt;定义了 &lt;code&gt;Range&lt;/code&gt; 对象的智能匹配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set&lt;/code&gt; 转换为&lt;code&gt;Mix&lt;/code&gt;/&lt;code&gt;Bag&lt;/code&gt; 不再有 &lt;code&gt;Bool&lt;/code&gt; 权重&lt;/li&gt;
&lt;li&gt;当一个或多个操作数为 &lt;code&gt;0&lt;/code&gt; 时、&lt;code&gt;gcd&lt;/code&gt; 是有定义的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;defined&lt;/code&gt; 例程中的 &lt;code&gt;Junction&lt;/code&gt; 自动线程化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sum&lt;/code&gt; 可以处理含有 &lt;code&gt;Junction&lt;/code&gt; 的列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Grammar.parse&lt;/code&gt; 让顶级 &lt;code&gt;regex&lt;/code&gt; 回溯&lt;/li&gt;
&lt;li&gt;&lt;code&gt;U+2212 MINUS SIGN [Sm] (-)&lt;/code&gt; 现在得到更多结构的支持, 如 &lt;code&gt;Str.Numeric&lt;/code&gt; 和 &lt;code&gt;&amp;amp;val&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Arity-1 &lt;code&gt;&amp;amp;infix:&amp;lt;~&amp;gt;&lt;/code&gt; 与 &lt;code&gt;Blob&lt;/code&gt; 可以一起工作&lt;/li&gt;
&lt;li&gt;在签名中, 所有的 &lt;code&gt;Numeric&lt;/code&gt; 字面值都支持作为值字面值&lt;/li&gt;
&lt;li&gt;正则表达式中的 &lt;code&gt;\b&lt;/code&gt; 和 &lt;code&gt;\B&lt;/code&gt; 抛出 &lt;code&gt;X::Obsolete&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;True&lt;/code&gt; 和 &lt;code&gt;False&lt;/code&gt; 作为签名中的值字面量发出警告&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.sort&lt;/code&gt; 和 &lt;code&gt;IO::Spec::Unix.path&lt;/code&gt; 的返回值总是 &lt;code&gt;Seq&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Range&lt;/code&gt; 对象上的 Out-of-range &lt;code&gt;.AT-POS&lt;/code&gt; 返回 &lt;code&gt;Nil&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对于不存在的键、&lt;code&gt;Pair.AT-KEY&lt;/code&gt; 返回 &lt;code&gt;Nil&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所有的 &lt;code&gt;Cool&lt;/code&gt; 类型都提供了 &lt;code&gt;.Rat&lt;/code&gt;/&lt;code&gt;.FatRat&lt;/code&gt; 强转器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Path&lt;/code&gt; 文件测试不缓存先前测试执行的结果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Seq&lt;/code&gt; eqv &lt;code&gt;List&lt;/code&gt; 仅根据类型不匹配就定为 &lt;code&gt;False&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;在 &lt;code&gt;Hash &lt;/code&gt;、&lt;code&gt;Hash &lt;/code&gt; 和 &lt;code&gt;QuantHash&lt;/code&gt; 上, 来自 &lt;code&gt;.kv&lt;/code&gt;、&lt;code&gt;.values&lt;/code&gt; 和 &lt;code&gt;.pair&lt;/code&gt; 序列的值是可写的&lt;/del&gt; 参见 &lt;a href=&#34;https://github.com/Raku/roast/issues/614&#34;&gt;Raku/roast#614&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/Raku/doc/issues/3519&#34;&gt;#3519&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;infix:&amp;lt;∘&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;amp;infix:&amp;lt;o&amp;gt;&lt;/code&gt; 保留 LHF 的 &lt;code&gt;.of&lt;/code&gt; 和 RHS 的 &lt;code&gt;.arity&lt;/code&gt; 和 &lt;code&gt;.count&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;完善了 regex 运算符副词中的可接受参数(例如:&lt;code&gt;:in(…)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;完善了 &lt;code&gt;IO::Handle.open&lt;/code&gt; 中可接受的参数组合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Path.Str&lt;/code&gt; 不包含 &lt;code&gt;.CWD&lt;/code&gt; 属性的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Path&lt;/code&gt; 类型拒绝带有  &lt;code&gt;nul&lt;/code&gt; 字节 (&lt;code&gt;&amp;quot;\0&amp;quot;&lt;/code&gt;) 的路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Pipe&lt;/code&gt; 的 &lt;code&gt;.path&lt;/code&gt;/&lt;code&gt;.IO&lt;/code&gt; 返回一个 &lt;code&gt;IO::Path&lt;/code&gt; 类型对象&lt;/li&gt;
&lt;li&gt;如果目的路径和源路径是一样的 &lt;code&gt;IO::Path&lt;/code&gt; 的 &lt;code&gt;.copy&lt;/code&gt;/&lt;code&gt;.move&lt;/code&gt; 会 &lt;code&gt;fail&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dir&lt;/code&gt; 创建的 &lt;code&gt;IO::Path&lt;/code&gt; 绝对性由调用者控制&lt;/li&gt;
&lt;li&gt;更多定义的边缘行为、&lt;code&gt;Callable &lt;/code&gt; 处理、&lt;code&gt;. defined&lt;/code&gt; 调用, 以及 &lt;code&gt;&amp;amp;infix:&amp;lt;andthen&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;amp;infix:&amp;lt;orelse&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;infix:&amp;lt;notandthen&amp;gt;&lt;/code&gt; 操作符的链接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Seq&lt;/code&gt; 的禅切不缓存它们&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List.Capture&lt;/code&gt; 将任何包含的 &lt;code&gt;Pair&lt;/code&gt; 对象的键字符串化&lt;/li&gt;
&lt;li&gt;带处理的 &lt;code&gt;Failure&lt;/code&gt; 参数的 &lt;code&gt;&amp;amp;fail&lt;/code&gt; 把它标记为是未处理的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;use lib&lt;/code&gt; 接受 &lt;code&gt;IO::Path&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;锚点 &lt;code&gt;^&lt;/code&gt;、&lt;code&gt;^^&lt;/code&gt;、&lt;code&gt;$&lt;/code&gt; 和 &lt;code&gt;$$&lt;/code&gt; 在环视中有效&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Grammar.made&lt;/code&gt; 支持类型对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.isa&lt;/code&gt; 支持 &lt;code&gt;subset &lt;/code&gt; 类型对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:delete&lt;/code&gt; 可用于惰性数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;infix:&amp;lt;eqv&amp;gt;&lt;/code&gt; 可以在某些情况下对惰性参数起作用&lt;/li&gt;
&lt;li&gt;动态查询(&lt;code&gt;::(...)&lt;/code&gt;) 是限制性的 regex 语法, 并且需要 &lt;code&gt;use MONKEY-SEE-NO-EVAL&lt;/code&gt; 的许可&lt;/li&gt;
&lt;li&gt;定义了带孔数组的 &lt;code&gt;.Slip&lt;/code&gt; 和 &lt;code&gt;.List&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Promise.in&lt;/code&gt;/&lt;code&gt;.at&lt;/code&gt; 和 &lt;code&gt;Supply.interval&lt;/code&gt; 可以用零值和负值工作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Supply.interval&lt;/code&gt; 最小值为 &lt;code&gt;0.001&lt;/code&gt;；较低值被处理为 &lt;code&gt;0.001&lt;/code&gt;, 并发出警告#, 参见 &lt;a href=&#34;https://github.com/Raku/doc/pull/2649&#34;&gt;https://docs.perl6.org/type/Supply#method_interval PR [#2649]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Supply&lt;/code&gt; 提供了 &lt;code&gt;.Seq&lt;/code&gt;、&lt;code&gt;.list&lt;/code&gt; 和 &lt;code&gt;.zip&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可以在构建方法中绑定到原生类型属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WhateverCode&lt;/code&gt; 传播 &lt;code&gt;use fatal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;say&lt;/code&gt;、&lt;code&gt;note&lt;/code&gt;、&lt;code&gt;put&lt;/code&gt;、&lt;code&gt;print&lt;/code&gt; 和 &lt;code&gt;printf&lt;/code&gt; 例程自动线程化 &lt;code&gt;Junction&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO::Handle.eof&lt;/code&gt; 值在 &lt;code&gt;.seek&lt;/code&gt; 过终点后再返回时也会相应改变&lt;/li&gt;
&lt;li&gt;定义了 &lt;code&gt;.succ&#39;、&lt;/code&gt;.pred&lt;code&gt;和&lt;/code&gt;.Bool` 的同质异形体&lt;/li&gt;
&lt;li&gt;在核心 &lt;code&gt;Numeric&lt;/code&gt; 上定义了 &lt;code&gt;.Bridge&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt;在核心 &lt;code&gt;Numeric&lt;/code&gt; 的类型对象上定义了 &lt;code&gt;.Numeric&lt;/code&gt;/&lt;code&gt;.Real&lt;/code&gt;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;定义了关于零分母有理数的 &lt;code&gt;Rational.Bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;say&lt;/code&gt;/&lt;code&gt;note&lt;/code&gt; 保证在 &lt;code&gt;Str&lt;/code&gt; 的子类上调用 &lt;code&gt;.gist&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义了 &lt;code&gt;Junction.Str&lt;/code&gt; 返回 &lt;code&gt;Junction&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义了 &lt;code&gt;Junction.gist&lt;/code&gt;/&lt;code&gt;.perl&lt;/code&gt; 返回一个 &lt;code&gt;Str&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map&lt;/code&gt;/&lt;code&gt;Hash&lt;/code&gt; 的 &lt;code&gt;.list&lt;/code&gt;/&lt;code&gt;.cache&lt;/code&gt; 返回一个 &lt;code&gt;List&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义了 &lt;code&gt;.round&lt;/code&gt; 的返回类型&lt;/li&gt;
&lt;li&gt;定义了 &lt;code&gt;Enumeration:D&lt;/code&gt;  不  &lt;code&gt;.ACCEPT&lt;/code&gt; 一个 &lt;code&gt;Enumeration:U&lt;/code&gt; , 参见 &lt;a href=&#34;https://github.com/rakudo/rakudo/issues/2073&#34;&gt;rakudo/rakudo#2073&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;杂项&#34;&gt;杂项&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IO::ArgFiles&lt;/code&gt; 类型只是 &lt;code&gt;IO::CatHandle&lt;/code&gt; 的一个空的子类&lt;/li&gt;
&lt;li&gt;对常量的约束
&lt;ul&gt;
&lt;li&gt;约束是完全强制的&lt;/li&gt;
&lt;li&gt;试图在常量上使用参数化类型约束(例如使用 &lt;code&gt;my Foo constant @int&lt;/code&gt;) 会引发 &lt;code&gt;X::ParametricConstant&lt;/code&gt; 异常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pod&lt;/code&gt; &lt;code&gt;=defn&lt;/code&gt;(定义列表)指令可用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pod&lt;/code&gt; 提供了 &lt;code&gt;:numbered&lt;/code&gt; 配置键&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.^ver&lt;/code&gt;、&lt;code&gt;.^auth&lt;/code&gt; 和 &lt;code&gt;.^name&lt;/code&gt; 元方法在 &lt;code&gt;module&lt;/code&gt; 中可用, 而在 &lt;code&gt;package&lt;/code&gt; 中则没有, 这是设计上的原因&lt;/li&gt;
&lt;li&gt;&lt;code&gt;qww&amp;lt;…&amp;gt;&lt;/code&gt; 中支持花哨的引号(&lt;code&gt;’…’&lt;/code&gt;、&lt;code&gt;“…”&lt;/code&gt;、&lt;code&gt;｢…｣&lt;/code&gt; 和变体)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;infix:&amp;lt; &amp;gt;&lt;/code&gt; 支持查找自动生成的 &lt;code&gt;Callables&lt;/code&gt; (例如: &lt;code&gt;&amp;amp;infix:&amp;lt;XX&amp;gt;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;使用命名的 &lt;code&gt;anon&lt;/code&gt; 子例程不再产生重声明警告&lt;/li&gt;
&lt;li&gt;&lt;code&gt;::?MODULE&lt;/code&gt;/&lt;code&gt;$?MODULE&lt;/code&gt; 变量的扩展规范&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sub MAIN&lt;/code&gt; 可以接受一个参数上的 &lt;code&gt;Enumeration&lt;/code&gt; 类型约束和 &lt;code&gt;where&lt;/code&gt; 子句&lt;/li&gt;
&lt;li&gt;笑脸型约束可以用在子集上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start&lt;/code&gt; 块和 thunks 得到新的 &lt;code&gt;$/&lt;/code&gt; 和 &lt;code&gt;$!&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义了与列表关联运算符一起使用的 &lt;code&gt;R&lt;/code&gt; 元运算符&lt;/li&gt;
&lt;li&gt;类型强转可以用在签名返回类型约束中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;infix:&amp;lt;x&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;amp;infix:&amp;lt;x&amp;gt;&lt;/code&gt; 抛出了 &lt;code&gt;-Inf&lt;/code&gt;/&lt;code&gt;NaN&lt;/code&gt; 重复参数&lt;/li&gt;
&lt;li&gt;字面结构 &lt;code&gt;put&lt;/code&gt; 和 &lt;code&gt;put for&lt;/code&gt; 抛出, 需要使用括号&lt;/li&gt;
&lt;li&gt;扩大了 Unicode 例程和功能的规范覆盖面-将覆盖面升级到 Unicode 第11版&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$.&lt;/code&gt; 方法调用语法能用在元方法中了&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/programming">programming</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/6.d">6.d</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2020-07-21-checklist-for-6-dot-d/</guid>
                <pubDate>Tue, 21 Jul 2020 00:00:00 +0800</pubDate>
            </item>
        
    </channel>
</rss>


