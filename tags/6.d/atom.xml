<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.79.0">Hugo</generator><title type="html"><![CDATA[6.d on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/6.d/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/6.d/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/6.d/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/6.d/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2020-12-23T22:59:30+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/6.d/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Checklist for Raku 6.d]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-07-21-checklist-for-6-dot-d/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2020-07-21-checklist-for-6-dot-d/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-21T00:00:00+08:00</published>
            <updated>2020-07-21T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Checklist for 6.d</blockquote><h2 id="问题">问题</h2>
<p>在 6.d 版本中, 很多东西都发生了变化, 我们至少需要发布一个版本。<a href="https://github.com/perl6/roast/blob/master/docs/announce/6.d.md">这里有个列表</a>。然而, 覆盖面是不完整的。弃用通知采取了不同的形式, 一些新的类型和方法在那里, 一些则没有&hellip;&hellip;</p>
<p>用 <code>#2632</code> 引用这个问题, 并检查项目, 当你的工作, 无论是通过改变后的文档, 看到没有变化, 需要做它。在这种情况下, 请通过评论或如何解释为什么是这种情况。</p>
<h2 id="版本控制的变更">版本控制的变更</h2>
<ul>
<li><strong>[6.d]</strong> <code>&amp;await</code> 在等待的时候不再阻塞线程</li>
<li><strong>[6.d]</strong> <code>whenever</code> 不在 <code>react</code> 抛出的词法作用域内</li>
<li><strong>[6.d]</strong> 在 <code>sub MAIN</code> 里面的 <code>$*ARGFILES</code> 总是由 <code>$*IN</code> 馈入</li>
<li><strong>[6.d]</strong> 结构(字面上的) <code>$()</code>、<code>@()</code> 和 <code>%()</code> 不复存在</li>
<li><strong>[6.d]</strong> 带有 <code>:D</code>/<code>:U</code> 类型约束的变量默认为约束类型的类型对象(例如, 你可以在它们身上使用 <code>.new</code>)</li>
<li><strong>[6.d]</strong> <code>start</code> 块在 sink 上下文中附加异常处理程序</li>
<li><del><strong>[6.d]</strong> 例程必须使用 <code>return-rw</code> 来返回一个 <code>Proxy</code>, 即使例程被标记为 <code>is raw</code> 或 <code>is rw</code></del></li>
<li><strong>[6.d]</strong> 原生的 <code>num</code> 类型默认为 <code>0e0</code> 而不是 <code>NaN</code></li>
<li><strong>[6.d]</strong> 在子程序名中, 保留了键名为 <code>sym</code> 的冒号对（如<code>:sym&lt;foo&gt;</code>）, 以备将来使用</li>
</ul>
<h2 id="废弃">废弃</h2>
<p>这些方法在 6.d 语言中已被废弃, 并将在 6.e 中被删除。实现者可以选择发出弃用警告, 或者在 6.e 版本发布后更长的时间内提供这些方法。</p>
<ul>
<li>使用 <code>'-'</code> (单连字符)作为 <code>&amp;open</code> 的特殊路径, 表示特殊的句柄(使用 <code>IO::Special</code> 对象代替)</li>
<li><code>IO::Handle.slurp-rest</code> (使用 <code>.slurp</code> 代替)</li>
<li><code>Any.flatmap</code> (使用<code>.flat</code> 和 <code>.map</code> 方法的组合来代替)</li>
<li><code>Cool.path</code> (使用 <code>.IO</code> 代替)</li>
<li><code>Pair.freeze</code> (使用去容器化的参数的 <code>Pair.new</code> 来代替)</li>
<li><code>Str.subst-mutate</code> (使用带有 <code>.=</code> 方法调用赋值元运算符的 <code>Str.subst</code> 代替)</li>
<li><code>Rational.norm</code> (现在 <code>Rational</code> 类型必须在创建时标准化)</li>
<li><code>IO::Path.child</code> (使用 <code>.add</code> 代替)</li>
<li><code>&amp;undefine</code> (直接分配 <code>Empty</code>/<code>Nil</code> 代替)</li>
<li><code>:count</code> <code>&amp;lines</code>/<code>Str.lines</code> 例程上的参数(使用所返回的 <code>Seq</code> 上的 <code>.elems</code> 代替)</li>
<li><code>&amp;is_approx</code> in Test.pm6 (使用与 <code>&amp;is-approx</code> 非常相似的行为来代替)</li>
</ul>
<h2 id="新的行为">新的行为</h2>
<ul>
<li>通过新的可定义的 <code>&amp;RUN-MAIN</code>、<code>&amp;ARGS-TO-CAPTURE</code> 和 <code>&amp;GENERATE-USAGE</code> 子例程改善 <code>sub MAIN</code> 的自定义处理</li>
<li><code>%</code> 变量中的 <code>QuantHash</code>/<code>Map</code> 和 <code>@</code> 变量中的 <code>List</code> 可以用 <code>is</code> 特性来声明（例如，<code>my %h is Set</code>）</li>
<li>新的 <code>&lt;ww&gt;</code> regex 规则: 只在单词内匹配</li>
<li>循环可以从上一条语句的值中产生一个值的列表</li>
<li>循环中的 <code>next</code>/<code>last</code> 收集其最后的语句值, 对它们运行的迭代返回 <code>Empty</code></li>
<li><code>.perl</code> 可以在消耗过的 <code>Seq</code>、多维数组、<code>Date</code> 和 <code>CallFrame</code> 上调用</li>
<li><code>.gist</code> 可以在 <code>Attribute</code> 上调用</li>
<li>对自动生成的 <code>USAGE</code> 信息进行了大量改进</li>
<li><code>is hidden-from-USAGE</code> 特性，从自动生成的 <code>USAGE</code> 消息中隐藏 <code>sub MAIN</code> 候选者</li>
<li><code>Parameter.perl</code> 包括可内省的默认值</li>
<li><code>%*ENV</code> 值是同素异形的</li>
<li>尝试使用变量 <code>$;</code>、<code>$,</code>、<code>$.</code>、<code>$\</code>、<code>$(</code>、<code>$)</code>、<code>$&lt;</code>、<code>$&gt;</code>、<code>$/</code>、<code>$\</code>、<code>$[</code>、<code>$-</code>、<code>$+</code> 和 <code>$@</code> 会抛出 <code>X::Syntax::Perl5Var</code></li>
<li>默认的 <code>Hash.keyof</code> 返回一个 <code>Str(Any)</code> 强转类型对象</li>
<li>非 ASCII 数字可以在 <code>:42foo</code> 冒号对快捷方式中使用</li>
<li><code>StrDistance</code> 字符串化为 <code>.after</code> 字符串</li>
<li>更明确的 Pod 表格格式</li>
<li><code>Enumeration.enums</code> 返回一个 <code>Map</code></li>
<li>各种整数类型的 <code>.Range</code> 返回它们支持的值的范围</li>
<li><code>min</code>/<code>max</code>  例程也适用于 <code>Hash</code></li>
<li><code>Signature</code> 字面值可以包含字符串/数字字面值以及调用者标记</li>
<li><code>List.invert</code> 通过所需的 <code>Pair</code> 绑定映射, 导致潜在的类型检查失败</li>
<li><code>:exists</code> 可以与多维关联下标一起使用</li>
<li>动态创建的列表可以用来定义一个枚举</li>
<li>在 <code>.first</code> 中, Junction 可以作为匹配器使用</li>
<li>原生属性可以作为参数中的绑定目标</li>
<li><code>Proc</code> 可以与其他 <code>Proc</code> 中的 <code>IO::Pipe</code> 一起工作</li>
<li>类型数组可以用 <code>my SomeType @array</code> 和 <code>my @array of SomeType</code> 创建</li>
<li>当把 <code>Mixy</code> 强转为 <code>Setty</code>/<code>Baggy </code> 时, 负数权重的项将被删除</li>
<li><code>:nth</code> 副词在 <code>m//</code> 上接受一个 <code>Junction</code> 作为参数</li>
<li><code>CX::Warn' 和 </code>CX::Done<code>可以在</code>CONTROL` phaser 中捕获</li>
<li><code>next</code> 可用于 <code>whenever</code> 中</li>
<li><code>require</code> 符号不再过境性地暴露出来</li>
<li>通过 <code>{...}</code> 进行多维访问, 类似于 <code>[...]</code> 的工作方式</li>
<li>在 <code>END</code> 时间打开的任何手柄都会自动关闭</li>
<li>在缓存的 <code>Seq</code> 上, 当 <code>&amp;infix:&lt;eqv&gt;</code>、<code>.Slip</code>、<code>.join</code>、<code>.List</code>、<code>.list</code>、<code>.eager</code>、<code>.Array</code> 和 <code>.is-lazy</code> 被调用时, 就会使用缓存列表</li>
<li><code>IO::Handle.encoding</code> 以 <code>Nil</code> 表示切换到二进制模式</li>
<li><code>is default</code> 特质与属性一起工作</li>
<li>在多重分派中, 带有 <code>is rw</code> 特性的参数被认为比没有特性的参数窄</li>
<li><code>Array</code>、<code>Blob</code> 和 <code>Map</code> 的 <code>.gist</code> 被裁剪成100个元素</li>
<li>新的 <code>for</code> 语句修饰符 <code>hyper for</code>、<code>race for</code> 和 <code>lazy for</code></li>
<li><code>for</code> 循环自动序列化 <code>RaceSeq</code>/<code>HyperSeq</code>；使用新的 <code>for</code> 语句修饰符<code>hyper for</code>/<code>race for</code>避免</li>
<li><code>&amp;infix:&lt;does&gt;</code> 可用于 RHS 上的非组合实例</li>
<li>数值比较器可以与 <code>DateTime </code> 对象一起使用</li>
<li><code>Pod</code> 保留空白类型</li>
<li>定义了带 <code>@</code>、<code>%</code> 和 <code>&amp;</code> 魔符常数的语义</li>
</ul>
<h2 id="math">Math</h2>
<ul>
<li><code>Rational</code> 总是在创建时被化简, 并在其一生中保持不变</li>
<li><code>Inf</code>、<code>Inf</code> 和 <code>NaN</code> 可以分别用 <code>&lt;-1/0&gt;</code>、<code>&lt;1/0&gt;</code> 和 <code>&lt;0/0</code>&gt; 表示, 通过<code>Rational</code> 类型进行舍去。零分母 <code>Rational</code> 被标准化为这三个值之一</li>
<li>在 ±<code>Inf</code> 和 <code>NaN</code> 上调用 <code>.Int</code>, 会抛出异常</li>
<li>改进了 <code>Num</code> 运算符和数学函数的 IEEE 754-2008 合规性</li>
<li>负零 <code>Num</code>(<code>-0e0</code>)被所有例程和语法结构正确处理</li>
<li><code>Num</code> 类型的字符串化必须是可舍弃到原始 <code>Num</code> 的</li>
<li>定义了涉及零的 <code>Complex </code> 指数</li>
<li><code>.expmod</code> 中的负数幂有效</li>
</ul>
<h2 id="setsbagsmixesaka-quanthashes和集合运算符">Sets、Bags、Mixes(aka QuantHashes)和集合运算符</h2>
<ul>
<li>Set 运算符可以用在任何对象上, 在需要的时候会被强转
<ul>
<li>所以, 不需要也不希望有任何预先的强转</li>
<li>如果没有 QuantHash 就能实现所需的功能, 那么 Set 运算符可以自由地不创建任何 QuantHash</li>
</ul>
</li>
<li>对不同类型的 QuantHashes 的 Set 操作将强转到最自由的形式（Set -&gt; Bag -&gt; Mix）</li>
<li>集合运算符的 set_precedes 家族( <code>(&lt;+)</code>、<code>≼</code>、<code>(&gt;+)</code>、<code>≽</code>) 已被移除
<ul>
<li>曾经是子集运算符的 Baggy 形式</li>
<li>QuantHash 升级为最自由的形式, 所以 <code>(&lt;=)</code>、<code>⊆</code>、<code>(&gt;=)</code>、<code>⊇</code> 做正确的事情</li>
</ul>
</li>
<li><code>.classify-list</code> 方法可用于 <code>Baggy</code> 类型</li>
<li><code>.categorize-list</code> 方法可用于 <code>Baggy</code> 类型</li>
<li><code>.invert</code> 方法可用于核心 <code>QuantHash</code> 类型</li>
<li><code>.antipairs</code> 方法可用于 <code>QuantHash</code> 类型</li>
<li><code>QuantHash</code> 类型有 <code>.new-from-pairs</code> 和将一个 <code>QuantHash</code> 类型转换为另一个 <code>QuantHash</code> 类型的方法(例如 <code>Set</code> 类型的 <code>.Bag</code> 方法)</li>
<li><code>QuantHash</code> 类型上的 <code>.hash</code> 对键值进行了字符串化</li>
</ul>
<h2 id="新的形参和实参">新的形参和实参</h2>
<ul>
<li><code>Date.new</code> 接受一个 <code>:&amp;formatter</code></li>
<li><code>.first</code> 可以接受 <code>:kv</code></li>
<li><code>unique</code> 和 <code>.repeated</code> 可以接受 <code>:&amp;as</code> 和 <code>:&amp;with</code></li>
<li>Test.pm6 中的 <code>&amp;plan</code> 可以接受 <code>:skip-all</code></li>
<li><code>&amp;run</code>/<code>&amp;shell</code> 可以接受 <code>:merge</code></li>
<li><code>&amp;note</code> 可以在没有参数的情况下调用</li>
<li><code>open</code> 接受 <code>:$out-buffer</code></li>
<li><code>IO::Path.resolve</code> 可以接受 <code>:completely</code></li>
<li><code>IO::Path.parent</code> 可以接受一个 <code>Int</code> 表示父级</li>
<li><code>Proc::Async.new</code> 吞噬位置参数</li>
<li><code>Signature.ACCEPTS</code> 接受非 <code>Signature</code>/<code>Capture</code> 参数</li>
<li><code>&amp;EVAL</code> 可以接受一个 <code>Blob</code></li>
<li><code>Promise.keep</code>/<code>.break</code> 可以在没有参数的情况下调用</li>
<li>原生数组上的 <code>.sum</code> 可以接受 <code>:wrap</code></li>
<li><code>is required</code> 现在可以接受一个表示理由的参数</li>
<li><code>IO::Socket::Async.listen</code> 可以绑定到端口 <code>0</code> 以向操作系统申请免费端口</li>
<li><code>.encode</code> 可以接受 <code>:translate-nl</code></li>
</ul>
<h2 id="新的例程和运算符">新的例程和运算符</h2>
<ul>
<li>新的 <code>atomicint</code> Unicode 运算符和 ASCII 等价物, 保证线程安全, 原子操作:
<code>&amp;infix:&lt;⚛=&gt;</code>/<code>&amp;atomic-assign</code>、<code>&amp;prefix:&lt;⚛&gt;</code>/<code>&amp;atomic-fetch</code>、
<code>&amp;prefix:&lt;++⚛&gt;</code>/<code>&amp;atomic-inc-fetch</code>、<code>&amp;postfix:&lt;⚛++&gt;</code>/<code>&amp;atomic-fetch-inc</code>、
<code>&amp;prefix:&lt;--⚛&gt;</code>/<code>&amp;atomic-dec-fetch</code>、<code>&amp;postfix:&lt;⚛--&gt;</code>/<code>&amp;atomic-fetch-dec</code>、
<code>&amp;infix:&lt;⚛-=&gt;</code>/<code>&amp;infix:&lt;⚛−=&gt;</code>/<code>&amp;atomic-fetch-sub</code> 和 <code>&amp;infix:&lt;⚛+=&gt;</code>/<code>&amp;atomic-fetch-add</code></li>
<li><code>&amp;cas</code>: 原子比较与交换</li>
<li><code>≤</code>、<code>≥</code> 和 <code>≠</code> 运算符是 Unicode 运算符, 分别等价于 <code>&lt;=</code>、<code>&gt;=</code> 和 <code>!=</code></li>
<li><code>&amp;infix:&lt;unicmp&gt;</code>/<code>&amp;infix:&lt;coll&gt;</code>: <code>&amp;infix:&lt;cmp&gt;</code> 的替代行为</li>
<li><code>TR///</code>: <code>tr///</code> 的非变异版本</li>
<li><code>submethod TWEAK</code>: 与 <code>BUILD</code> 类似, 除了它与属性默认值兼容之外</li>
<li><code>&amp;duckmap</code>: 应用 <code>&amp;callable</code> 到每个元素上</li>
<li><code>&amp;deepmap</code>: 应用 <code>&amp;callable</code> 到每个元素上, 下降到 <code>Iterable</code> 中</li>
<li><code>&amp;take-rw</code>: 像 <code>&amp;take</code> 一样, 但有一个可写的容器</li>
<li><code>&amp;indir</code>: 在给定的 <code>$*CWD</code> 中执行代码</li>
<li><code>&amp;spurt</code>: 参见 <code>IO::Path.spurt</code></li>
<li><code>&amp;prompt</code>: 提示用户输入</li>
<li><code>uniprops</code>: <code>uniprop</code> 的多字符版本</li>
<li><code>symlink</code>: 建立文件符号链接</li>
<li><code>link</code>: 创建文件硬连接</li>
<li><code>.hyper</code>/<code>.race</code>: 并行处理值的列表</li>
<li><code>Seq.from-loop</code>: 从 <code>Callable</code> 生产一个 <code>Seq</code></li>
<li><code>Str.uniparse</code>: 将一个或多个 Unicode 字符名解析为实际字符</li>
<li><code>Str.parse-base</code>: <code>Int.base</code> 操作的反转</li>
<li><code>IO::Path</code> 提供了 <code>.ACCEPTS</code>、<code>.SPEC</code>、<code>.CWD</code>、<code>.Numeric</code>、<code>.add</code>、<code>.extension</code>、<code>.mode</code> 和各种文件测试、<code>.parts</code>、<code>.sibling</code> 和 <code>.spurt</code></li>
<li><code>IO::Handle</code> 提供了 <code>.READ</code>、<code>.WRITE</code>、<code>.EOF</code>、<code>.DESTROY</code>,
<code>.readchars</code>、<code>.flush</code>、<code>.lock</code>、<code>.unlock</code>、<code>.out-buffer</code>、<code>.tell</code>,
<code>.say</code>、<code>.slurp</code>、<code>.seek</code>、<code>.printf</code>、<code>.print-nl</code> 和 <code>.watch</code></li>
<li><code>IO::Pipe</code> 提供了 <code>.proc</code></li>
<li><code>Iterator</code> 提供了 <code>.skip-one</code>、<code>.skip-at-least</code> 和 <code>.skip-at-least-pull-one</code></li>
<li><code>Mu.emit</code>: <code>&amp;emit</code> 的方法形式</li>
<li>Test.pm6 模块中的 <code>&amp;fails-like</code>: 允许测试失败</li>
<li>Test.pm6 模块中的 <code>&amp;bail-out</code>: 退出失败的测试套件</li>
<li>Test.pm6 模块中的 <code>&amp;is-approx</code>: 测试一个数字近似于另一个</li>
<li><code>Buf</code> 拥有 <code>.allocate</code>、<code>.reallocate</code>、<code>.append</code>、<code>.push</code>、<code>.pop</code>、<code>.splice</code>、<code>.subbuf-rw</code>、<code>.prepend</code> 和 <code>.unshift</code> 方法</li>
<li><code>Range</code> 支持了 <code>.rand</code></li>
<li><code>Backtrace</code> 拥有方法 <code>.map</code>、<code>.flat</code>、<code>.concise</code> 和 <code>.summary</code></li>
<li><code>.classify-list</code> 方法可用于 <code>Hash</code> 类型</li>
<li><code>.categorize-list</code> 方法可用于 <code>Hash</code> 类型</li>
<li><code>Code.of</code>: 返回返回类型约束</li>
<li><code>Code.line</code>/<code>.file</code>: 返回定义的行/文件</li>
<li><code>Proc::Async</code> 提供了 <code>.Supply</code>、<code>.ready</code>、<code>.pid</code>、<code>.bind-stdin</code>、<code>.bind-stdout</code> 和 <code>.bind-stderr</code></li>
<li><code>Proc.command</code>/<code>Proc::Async.command</code>: 我们要执行的命令</li>
<li><code>Proc</code> 提供了 <code>.signal</code>、<code>.pid</code> 和 <del><code>.encoding</code></del></li>
<li><code>Complex</code> 提供了 <code>.cis</code>、<code>.reals</code>、<code>.ceiling</code>、<code>.floor</code>、<code>.round</code>、<code>.truncate</code> 和 <code>.abs</code> 方法, 并可以使用 <code>&lt;=&gt;</code> 进行比较(只要虚部可以忽略不计)</li>
<li><code>DateTime</code> 提供了 <code>.offset-in-hours</code>、<code>.hh-mm-ss</code> 和 <code>.Date</code></li>
<li><code>DateTime</code> 可以使用 <code>&lt;=&gt;</code> 运算符和其它 <code>DateTime</code> 对象进行比较</li>
<li><code>Date</code> 提供了 <code>.DateTime</code> 方法</li>
<li><code>&amp;infix:&lt;+&gt;</code>/<code>&amp;infix:&lt;-&gt;</code> 可以被 <code>Duration</code>、<code>DateTime</code> 和 <code>Real</code> 类型调用</li>
<li><code>Enumeration</code> 提供了 <code>.Int</code>、<code>.pred</code>、<code>.succ</code>、<code>.kv</code> 和 <code>.pair</code></li>
<li><code>.Date</code> 可以在 <code>Instant</code> 上调用</li>
<li>Junction 能使用 <code>Junction.new</code> 调用来创建</li>
<li><code>List</code> 类型拥有 <code>.to</code> 和 <code>.from</code> 方法</li>
<li><code>Map</code> type 提供了 <code>Int</code> 方法, 返回 pair 的数量</li>
<li><code>Any.skip</code>: 跳过列表中的值</li>
<li><code>Any.batch</code>: <code>.rotor</code> 的更基本的表兄弟</li>
<li><code>Mu.iterator</code>: 为一个列表中的值生成一个 <code>Iterator</code></li>
<li><code>IO::Spec::*</code> 类型提供了 <code>.tmpdir</code>、<code>.extension</code> 和 <code>.path</code></li>
<li><code>Pair</code> 提供了 <code>.ACCEPTS</code>、<code>.Pair</code> 和 <code>.invert</code></li>
<li><code>.Capture</code> 方法对所有核心类型都有明确定义</li>
<li>定义了 <code>.ACCEPTS</code> 在同素异形体上的语义</li>
<li><code>Failure.self</code> 使未处理的 <code>Failure</code> 爆发</li>
<li><code>Thread.is-initial-thread</code>: 我们是在初始线程中运行吗</li>
<li><code>Match</code> 提供了 <code>.Int</code> 和 <code>.actions</code></li>
<li><code>IO::Socket::Async</code> 提供了 <code>.socket-port</code> 和 <code>.peer-port</code></li>
<li><code>Promise</code> 提供了另一种构造函器 <code>.kept</code> 和 <code>.broken</code></li>
<li><code>WhateverCode</code> 提供了 <code>.assuming</code></li>
<li><code>WhateverCode</code> 和 <code>Block</code> 提供了 <code>.cando</code></li>
<li><code>.:&lt;…&gt;</code> 语法用于调用前缀运算符作为后缀</li>
<li><code>$*KERNEL</code> 提供了 <code>.hostname</code></li>
<li><code>Nil</code> 拥有定义的 <code>.FALLBACK</code> 特殊方法来返回 <code>Nil</code></li>
</ul>
<h2 id="新类型">新类型</h2>
<ul>
<li><code>atomicint</code>: 原生的 <code>int</code>, 大小可用于新的原子运算符</li>
<li><code>Lock::Async</code>: 互斥的非阻塞机制</li>
<li><code>Encoding::Registry</code>: 管理可用的编码</li>
<li><code>Encoding::Encoder</code>: 编码器, 用于特定的编码</li>
<li><code>Encoding::Decoder</code>: 解码器, 用于特定的编码</li>
<li><code>IO::CatHandle</code>: 将多个只读的 <code>IO::Handle</code> 视同一个</li>
<li>原生的 <code>str</code> 数组</li>
<li><code>Supplier::Preserving</code>: 缓存的实时 <code>Supply</code> 工厂</li>
<li><code>Semaphore</code>: 控制多线程对共享资源的访问</li>
<li><code>IO::Special</code>: 特殊I/O设备的路径 (例如 <code>STDOUT</code>)</li>
<li><code>Exceptions::JSON</code> 自定义异常处理程序的实现(可与<code>PERL6_EXCEPTIONS_HANDLER</code> 环境变量一起使用)</li>
<li><code>SeekType</code> 枚举: <code>IO::Handle.seek</code> 中使用的值</li>
</ul>
<h2 id="新的变量">新的变量</h2>
<ul>
<li>
<p><code>$*USAGE</code>: 可在 <code>MAIN</code> 子例程中使用, 包含自动生成的 <code>USAGE</code> 信息</p>
</li>
<li>
<p>%*SUB-MAIN-OPTS: 设置 <code>sub MAIN</code> 的行为</p>
<ul>
<li><code>%*SUB-MAIN-OPTS&lt;named-anywhere&gt;</code> 允许将命名参数放在命令行的任何位置</li>
</ul>
</li>
<li>
<p><code>$*COLLATION</code>: 配置四个 Unicode 校对级别</p>
</li>
<li>
<p><code>$*INIT-INSTANT</code>: 代表程序启动时间的 <code>Instant</code></p>
</li>
<li>
<p><code>$*HOME</code>: 用户的主目录, 如果存在的话</p>
</li>
<li>
<p><code>&amp;*chdir</code>: <code>Callable</code> 包含 <code>IO::Path.chdir</code> 的变体, 也设置进程的当前目录</p>
</li>
<li>
<p><code>PERL6_TEST_DIE_ON_FAIL</code> 环境变量: 在第一次失败时停止测试套件</p>
</li>
<li>
<p><code>PERL6_EXCEPTIONS_HANDLER</code> 环境变量: 指定自定义异常处理类</p>
</li>
</ul>
<h2 id="对边缘情况强转行为的澄清">对边缘情况/强转行为的澄清</h2>
<ul>
<li><code>UInt</code> 与 <code>Int</code> 类型对象智能匹配为 <code>True</code></li>
<li><code>sink</code> 语句前缀爆炸 <code>Failure</code></li>
<li>定义了1项和0项列表以及负参数和非整数参数的 <code>permutations</code>/<code>combinations</code> 的行为</li>
<li><code>&amp;val</code>、<code>Str.Numeric</code> 和其他 <code>Str</code> 数字转换方法在试图转换 Unicode <code>No</code> 字符组或合成数字时会 <code>fail</code></li>
<li><code>:42foo</code> 冒号对快捷方式中不能使用合成数字</li>
<li>现在、<code>Enumeration</code> 可以作为一个数组形状指定器使用</li>
<li>含有空格的 <code>Str</code> 的数值转换现在返回 <code>0</code></li>
<li>带空的模式参数的 <code>samark</code>, 简单地返回调用者</li>
<li><code>.polymod</code> 可用于 <code>lazy</code> 但有限的除数列表</li>
<li>定义了 <code>.[*-0]</code> 索引</li>
<li><code>.rotor</code> 中大于子列表的负数空隙抛出异常</li>
<li><code>.rotor</code> 的非 <code>Int</code> 参数被强转为 <code>Int</code> 参数</li>
<li>读取 <code>/proc</code> 文件时定义了 <code>.lines</code></li>
<li>定义了字符串上后缀/前缀  <code>++</code>/<code>--</code> 中泰语数字的行为</li>
<li>sunk <code>for</code> 里面的 <code>map</code> 被视为 sunk</li>
<li>Sunk <code>for</code> 循环将上一条语句的方法调用值下沉</li>
<li><code>Bool</code> 对象上的 <code>.Int</code> 返回一个 <code>Int</code> 对象</li>
<li><code>splice</code> 可用于扩展数组</li>
<li><code>classify</code> 可以与 <code>Junction</code> 配合使用</li>
<li><code>.pairup</code> on a type object returns an empty <code>Seq</code></li>
<li><code>.pairup</code> 总是返回一个 <code>Seq</code></li>
<li>拒绝接受  <code>Date</code>/<code>DateTime</code> 构造函数中的合成代码点</li>
<li><code>⸨</code>/<code>⸩</code> 对儿现在可以作为引号结构中的匹配字符使用</li>
<li><code>Array</code> 类型对象上的 <code>.flat</code> 简单地返回该类型对象</li>
<li>混合级 <code>classify</code> 在 <code>Hash</code> 上抛出异常</li>
<li><code>Junction</code> 可以用于给 <code>Hash</code> 指定多个键</li>
<li>给 <code>.classify-list</code> 的 <code>Callable</code> 现在保证每项只执行一次</li>
<li><code>:delete</code> 对 <code>Hash</code> 类型对象进行关联查找时返回 <code>Nil</code></li>
<li>Test.pm6 中的 <code>&amp;is-deeply</code> 会自动 <code>.cache</code> 作为参数的 <code>Seq</code>, 并使用返回的 <code>List</code> 进行测试</li>
<li><code>Complex.new()</code> 给出 <code>&lt;0+0i&gt;</code></li>
<li><code>Int.new</code> 现在可以保证构建一个新的 <code>Int</code> (而不是, 比如说, 从常量缓存中重用一个)</li>
<li>定义了一个参数(1-arg)版本的 <code>&amp;infix:&lt;=:=&gt;</code> 和 <code>&amp;infix:&lt;eqv&gt;</code></li>
<li>如果直接或间接地调用 <code>.BIND-POS</code>、<code>.BIND-KEY</code>、<code>.ASSIGN-POS</code>、<code>.ASSIGN-KEY</code>、<code>.STORE</code>、<code>.push</code>、<code>.append</code>、<code>.unshift</code>、<code>.prepend</code>、<code>Nil</code> 类型现在抛出异常</li>
<li><code>Nil.ord</code> 返回一个空的 <code>Seq</code></li>
<li><code>Nil.chrs</code> 返回一个 <code>&quot;\0&quot;</code></li>
<li><code>Num.new</code> 强转参数为 <code>Num</code></li>
<li><code>infix:&lt;Z&gt;()</code> 返回一个空的 <code>Seq</code></li>
<li><code>.comb</code> 总是返回一个 <code>Seq</code></li>
<li>用 <code>&amp;infix:&lt;+&gt;</code> 化简一个项, 简单地返回该项</li>
<li><code>()[0]</code> 返回 <code>Nil</code></li>
<li>允许在(可能是无限的) <code>Seq</code> 上使用 Regex 智能匹配</li>
<li>定义了 <code>Range</code> 对象的智能匹配</li>
<li><code>Set</code> 转换为<code>Mix</code>/<code>Bag</code> 不再有 <code>Bool</code> 权重</li>
<li>当一个或多个操作数为 <code>0</code> 时、<code>gcd</code> 是有定义的</li>
<li><code>defined</code> 例程中的 <code>Junction</code> 自动线程化</li>
<li><code>sum</code> 可以处理含有 <code>Junction</code> 的列表</li>
<li><code>Grammar.parse</code> 让顶级 <code>regex</code> 回溯</li>
<li><code>U+2212 MINUS SIGN [Sm] (-)</code> 现在得到更多结构的支持, 如 <code>Str.Numeric</code> 和 <code>&amp;val</code></li>
<li>Arity-1 <code>&amp;infix:&lt;~&gt;</code> 与 <code>Blob</code> 可以一起工作</li>
<li>在签名中, 所有的 <code>Numeric</code> 字面值都支持作为值字面值</li>
<li>正则表达式中的 <code>\b</code> 和 <code>\B</code> 抛出 <code>X::Obsolete</code></li>
<li><code>True</code> 和 <code>False</code> 作为签名中的值字面量发出警告</li>
<li><code>.sort</code> 和 <code>IO::Spec::Unix.path</code> 的返回值总是 <code>Seq</code></li>
<li><code>Range</code> 对象上的 Out-of-range <code>.AT-POS</code> 返回 <code>Nil</code></li>
<li>对于不存在的键、<code>Pair.AT-KEY</code> 返回 <code>Nil</code></li>
<li>所有的 <code>Cool</code> 类型都提供了 <code>.Rat</code>/<code>.FatRat</code> 强转器</li>
<li><code>IO::Path</code> 文件测试不缓存先前测试执行的结果</li>
<li><code>Seq</code> eqv <code>List</code> 仅根据类型不匹配就定为 <code>False</code></li>
<li><del><input disabled="" type="checkbox"> 在 <code>Hash </code>、<code>Hash </code> 和 <code>QuantHash</code> 上, 来自 <code>.kv</code>、<code>.values</code> 和 <code>.pair</code> 序列的值是可写的</del> 参见 <a href="https://github.com/Raku/roast/issues/614">Raku/roast#614</a> 和 <a href="https://github.com/Raku/doc/issues/3519">#3519</a></li>
<li><code>&amp;infix:&lt;∘&gt;</code>/<code>&amp;infix:&lt;o&gt;</code> 保留 LHF 的 <code>.of</code> 和 RHS 的 <code>.arity</code> 和 <code>.count</code></li>
<li>完善了 regex 运算符副词中的可接受参数(例如:<code>:in(…)</code>)</li>
<li>完善了 <code>IO::Handle.open</code> 中可接受的参数组合</li>
<li><code>IO::Path.Str</code> 不包含 <code>.CWD</code> 属性的值</li>
<li><code>IO::Path</code> 类型拒绝带有  <code>nul</code> 字节 (<code>&quot;\0&quot;</code>) 的路径</li>
<li><code>IO::Pipe</code> 的 <code>.path</code>/<code>.IO</code> 返回一个 <code>IO::Path</code> 类型对象</li>
<li>如果目的路径和源路径是一样的 <code>IO::Path</code> 的 <code>.copy</code>/<code>.move</code> 会 <code>fail</code></li>
<li><code>dir</code> 创建的 <code>IO::Path</code> 绝对性由调用者控制</li>
<li>更多定义的边缘行为、<code>Callable </code> 处理、<code>. defined</code> 调用, 以及 <code>&amp;infix:&lt;andthen&gt;</code>、<code>&amp;infix:&lt;orelse&gt;</code> 和 <code>&amp;infix:&lt;notandthen&gt;</code> 操作符的链接</li>
<li><code>Seq</code> 的禅切不缓存它们</li>
<li><code>List.Capture</code> 将任何包含的 <code>Pair</code> 对象的键字符串化</li>
<li>带处理的 <code>Failure</code> 参数的 <code>&amp;fail</code> 把它标记为是未处理的</li>
<li><code>use lib</code> 接受 <code>IO::Path</code> 对象</li>
<li>锚点 <code>^</code>、<code>^^</code>、<code>$</code> 和 <code>$$</code> 在环视中有效</li>
<li><code>Grammar.made</code> 支持类型对象</li>
<li><code>.isa</code> 支持 <code>subset </code> 类型对象</li>
<li><code>:delete</code> 可用于惰性数组</li>
<li><code>&amp;infix:&lt;eqv&gt;</code> 可以在某些情况下对惰性参数起作用</li>
<li>动态查询(<code>::(...)</code>) 是限制性的 regex 语法, 并且需要 <code>use MONKEY-SEE-NO-EVAL</code> 的许可</li>
<li>定义了带孔数组的 <code>.Slip</code> 和 <code>.List</code></li>
<li><code>Promise.in</code>/<code>.at</code> 和 <code>Supply.interval</code> 可以用零值和负值工作</li>
<li><code>Supply.interval</code> 最小值为 <code>0.001</code>；较低值被处理为 <code>0.001</code>, 并发出警告#, 参见 <a href="https://github.com/Raku/doc/pull/2649">https://docs.perl6.org/type/Supply#method_interval PR [#2649]</a></li>
<li><code>Supply</code> 提供了 <code>.Seq</code>、<code>.list</code> 和 <code>.zip</code></li>
<li>可以在构建方法中绑定到原生类型属性</li>
<li><code>WhateverCode</code> 传播 <code>use fatal</code></li>
<li><code>say</code>、<code>note</code>、<code>put</code>、<code>print</code> 和 <code>printf</code> 例程自动线程化 <code>Junction</code></li>
<li><code>IO::Handle.eof</code> 值在 <code>.seek</code> 过终点后再返回时也会相应改变</li>
<li>定义了 <code>.succ'、</code>.pred<code>和</code>.Bool` 的同质异形体</li>
<li>在核心 <code>Numeric</code> 上定义了 <code>.Bridge</code></li>
<li><del><input disabled="" type="checkbox"> 在核心 <code>Numeric</code> 的类型对象上定义了 <code>.Numeric</code>/<code>.Real</code></del></li>
<li>定义了关于零分母有理数的 <code>Rational.Bool</code></li>
<li><code>say</code>/<code>note</code> 保证在 <code>Str</code> 的子类上调用 <code>.gist</code></li>
<li>定义了 <code>Junction.Str</code> 返回 <code>Junction</code></li>
<li>定义了 <code>Junction.gist</code>/<code>.perl</code> 返回一个 <code>Str</code></li>
<li><code>Map</code>/<code>Hash</code> 的 <code>.list</code>/<code>.cache</code> 返回一个 <code>List</code></li>
<li>定义了 <code>.round</code> 的返回类型</li>
<li>定义了 <code>Enumeration:D</code>  不  <code>.ACCEPT</code> 一个 <code>Enumeration:U</code> , 参见 <a href="https://github.com/rakudo/rakudo/issues/2073">rakudo/rakudo#2073</a></li>
</ul>
<h2 id="杂项">杂项</h2>
<ul>
<li><code>IO::ArgFiles</code> 类型只是 <code>IO::CatHandle</code> 的一个空的子类</li>
<li>对常量的约束
<ul>
<li>约束是完全强制的</li>
<li>试图在常量上使用参数化类型约束(例如使用 <code>my Foo constant @int</code>) 会引发 <code>X::ParametricConstant</code> 异常</li>
</ul>
</li>
<li><code>Pod</code> <code>=defn</code>(定义列表)指令可用</li>
<li><code>Pod</code> 提供了 <code>:numbered</code> 配置键</li>
<li><code>.^ver</code>、<code>.^auth</code> 和 <code>.^name</code> 元方法在 <code>module</code> 中可用, 而在 <code>package</code> 中则没有, 这是设计上的原因</li>
<li><code>qww&lt;…&gt;</code> 中支持花哨的引号(<code>’…’</code>、<code>“…”</code>、<code>｢…｣</code> 和变体)</li>
<li><code>&amp;infix:&lt; &gt;</code> 支持查找自动生成的 <code>Callables</code> (例如: <code>&amp;infix:&lt;XX&gt;</code>)</li>
<li>使用命名的 <code>anon</code> 子例程不再产生重声明警告</li>
<li><code>::?MODULE</code>/<code>$?MODULE</code> 变量的扩展规范</li>
<li><code>sub MAIN</code> 可以接受一个参数上的 <code>Enumeration</code> 类型约束和 <code>where</code> 子句</li>
<li>笑脸型约束可以用在子集上</li>
<li><code>start</code> 块和 thunks 得到新的 <code>$/</code> 和 <code>$!</code></li>
<li>定义了与列表关联运算符一起使用的 <code>R</code> 元运算符</li>
<li>类型强转可以用在签名返回类型约束中</li>
<li><code>&amp;infix:&lt;x&gt;</code>/<code>&amp;infix:&lt;x&gt;</code> 抛出了 <code>-Inf</code>/<code>NaN</code> 重复参数</li>
<li>字面结构 <code>put</code> 和 <code>put for</code> 抛出, 需要使用括号</li>
<li>扩大了 Unicode 例程和功能的规范覆盖面-将覆盖面升级到 Unicode 第11版</li>
<li><code>$.</code> 方法调用语法能用在元方法中了</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/6.d" term="6.d" label="6.d" />
                            
                        
                    
                
            
        </entry>
    
</feed>
