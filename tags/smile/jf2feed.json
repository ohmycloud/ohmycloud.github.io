{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"children":[{"content":{"html":"\u003cp\u003e一个裸的 \u003cstrong\u003e:D\u003c/strong\u003e、\u003cstrong\u003e:U\u003c/strong\u003e、\u003cstrong\u003e:T\u003c/strong\u003e 或 \u003cstrong\u003e:_\u003c/strong\u003e 是限制默认类型为定义、未定义、类型对象或任何对象的类型约束。所以:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eCon\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nf\"\u003eman\u003c/span\u003e\u003cspan class=\"p\"\u003e(:\u003c/span\u003e\u003cspan class=\"s\"\u003eU\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003eD\u003c/span\u003e \u003cspan class=\"nv\"\u003e$x\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e其签名等价于 \u003ccode\u003e(Con:U: Any:D $x)\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eCon:U\u003c/code\u003e 是调用者, 在调用者后面加上一个冒号。要标记一个显式的调用者, 在它后面放上一个冒号就好了:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nf\"\u003edoit\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$x:\u003c/span\u003e \u003cspan class=\"nv\"\u003e$a\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nv\"\u003e$b\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nv\"\u003e$c\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"abstract-vs-concrete-types\"\u003eAbstract vs Concrete types\u003c/h3\u003e\n\u003cp\u003e　\n对于任何有名字的类型, 某些其它子集类型可以自动地通过在类型的名字后面追加一个合适的状语来派生出来：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eInt:_       允许定义或未定的 Int 值\nInt:D       只允许有定义的(强制的)Int 值\nInt:U       只允许未定义值(抽象或失败)Int 值\nInt:T       允许Int只作为类型对象\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e即, 它们的意思有点像:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eInt:D       Int:_ where DEFINITE($_)\nInt:U       Int:_ where not(DEFINITE($_))\nInt:T       Int:U where none(Failure)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003ewhere DEFINITE\u003c/code\u003e 是一个布尔宏, 它说正处理的对象是否有一个合法的强制表示。(查看下面的自省) .\u003c/p\u003e\n\u003cp\u003e在 Raku 中, \u003cstrong\u003eInt\u003c/strong\u003e 通常假定意为 \u003ccode\u003eInt:_\u003c/code\u003e, 除了调用者, 其中默认为 \u003ccode\u003eInt:D\u003c/code\u003e。（默认的 new 方法有一个原型, 它的调用者是 \u003ccode\u003e:T\u003c/code\u003e, 所以所有的 new 方法都默认允许类型对象。）\u003c/p\u003e\n\u003cp\u003e这些默认可以通过各种编译指令在词法作用域中更改。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"nn\"\u003eparameters\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003eD\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e会让非调用者的参数默认为 \u003ccode\u003e:D\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e作为对比,\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"nb\"\u003evariables\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003eD\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e会对用于变量声明中的类型做同样的事情。\n在这样的词法作用域中, 你可以使用 \u003ccode\u003e:_\u003c/code\u003e 形式回到标准的行为。特别地, 因为调用者默认为定义的:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"nb\"\u003einvocant\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003e_\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e会让调用者允许任何类型的有定义的和未定义的调用者。\u003c/p\u003e\n","text":"一个裸的 :D、:U、:T 或 :_ 是限制默认类型为定义、未定义、类型对象或任何对象的类型约束。所以:\nclass Con { method man(:U: :D $x) } 其签名等价于 (Con:U: Any:D $x)。\nCon:U 是调用者, 在调用者后面加上一个冒号。要标记一个显式的调用者, 在它后面放上一个冒号就好了:\nmethod doit ($x: $a, $b, $c) { ... } Abstract vs Concrete types 　对于任何有名字的类型, 某些其它子集类型可以自动地通过在类型的名字后面追加一个合适的状语来派生出来：\nInt:_ 允许定义或未定的 Int 值 Int:D 只允许有定义的(强制的)Int 值 Int:U 只允许未定义值(抽象或失败)Int 值 Int:T 允许Int只作为类型对象 即, 它们的意思有点像:\nInt:D Int:_ where DEFINITE($_) Int:U Int:_ where not(DEFINITE($_)) Int:T Int:U where none(Failure) where DEFINITE 是一个布尔宏, 它说正处理的对象是否有一个合法的强制表示。(查看下面的自省) .\n在 Raku 中, Int 通常假定意为 Int:_, 除了调用者, 其中默认为 Int:D。（默认的 new 方法有一个原型, 它的调用者是 :T, 所以所有的 new 方法都默认允许类型对象。）\n这些默认可以通过各种编译指令在词法作用域中更改。\nuse parameters :D; 会让非调用者的参数默认为 :D。\n作为对比,\nuse variables :D; 会对用于变量声明中的类型做同样的事情。 在这样的词法作用域中, 你可以使用 :_ 形式回到标准的行为。特别地, 因为调用者默认为定义的:\nuse invocant :_; 会让调用者允许任何类型的有定义的和未定义的调用者。\n"},"name":"Raku 中的 Smile 类型","published":"2021-07-11T00:00:00Z","summary":"Smile Type in Raku","type":"entry","url":"https://ohmyweekly.github.io/notes/2015-11-05-smile-type-in-raku/"}],"name":"smile","type":"feed","url":"https://ohmyweekly.github.io/tags/smile/"}