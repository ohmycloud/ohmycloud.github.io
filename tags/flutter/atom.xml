<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.63.2">Hugo</generator><title type="html"><![CDATA[flutter on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/flutter/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/flutter/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/flutter/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/flutter/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2020-09-04T09:31:44+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/flutter/</id>
    
        
        <entry>
            <title type="html"><![CDATA[创建包]]></title>
            <link href="https://ohmyweekly.github.io/notes/creating-packages/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/publishing-packages/?utm_source=atom_feed" rel="related" type="text/html" title="发布包" />
                <link href="https://ohmyweekly.github.io/notes/how-to-use-packages/?utm_source=atom_feed" rel="related" type="text/html" title="如何使用包" />
                <link href="https://ohmyweekly.github.io/notes/commonly-used-packages/?utm_source=atom_feed" rel="related" type="text/html" title="常用的包" />
                <link href="https://ohmyweekly.github.io/notes/write-http-clients/?utm_source=atom_feed" rel="related" type="text/html" title="编写HTTP客户端和服务器" />
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第一部分" />
            
                <id>https://ohmyweekly.github.io/notes/creating-packages/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-30T00:00:00+08:00</published>
            <updated>2020-06-30T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Creating packages</blockquote><p>Dart 生态系统使用<a href="https://dart.dev/guides/packages">包</a>来共享软件，如库和工具。本页告诉你如何创建一个包，重点是最常见的一种包，<a href="https://dart.dev/tools/pub/glossary#library-package">库包</a>。</p>
<h2 id="是什么造就了一个库包">是什么造就了一个库包</h2>
<p>下图是最简单的库包的布局:</p>
<p><img src="https://dart.dev/assets/libraries/simple-lib2-81ebdc20fdb53d3abbc4364956141eb0f6f8f275d1636064fc3e1db959b93c1a.png" alt="img"></p>
<p>一个库的最低要求是</p>
<p><strong>pubspec 文件</strong></p>
<p>库的 <code>pubspec.yaml</code> 文件和应用程序包的文件是一样的-没有特别的名称来表示这个包是一个库。</p>
<p><strong>lib 目录</strong></p>
<p>正如你所期望的那样，库代码存在于 <code>lib</code> 目录下，对其他包是公开的。你可以根据需要在 <code>lib</code> 下创建任何层次结构。按照惯例，实现代码被放在 <code>lib/src</code> 下。<code>lib/src</code> 下的代码被认为是私有的；其他包不应该需要导入 <code>src/...</code>。要使 <code>lib/src</code> 下的 API 公开，您可以从直接位于 <code>lib</code> 下的文件导出 <code>lib/src</code> 文件。</p>
<p>注意：当没有指定 <code>library</code> 指令时，会根据每个库的路径和文件名为其生成一个唯一的标签。因此，我们建议您从代码中省略 <code>library</code> 指令，除非您计划<a href="https://dart.dev/guides/libraries/create-library-packages#documenting-a-library">生成库级文档</a>。</p>
<h2 id="组织一个库包">组织一个库包</h2>
<p>当你创建小的、单独的库（称为迷你库）时，库包的维护、扩展和测试是最容易的。在大多数情况下，每个类都应该在自己的迷你库中，除非你有两个类是紧密耦合的情况。</p>
<p>注意：你可能听说过 <code>part</code> 指令，它允许你将一个库分割成多个 Dart 文件。我们建议你避免使用 <code>part</code> 指令，而是创建迷你库。</p>
<p>直接在 <code>lib</code> 下创建一个&quot;主&quot;库文件，<code>lib/&lt;package-name&gt;.dart</code>，导出所有的公共 API。这样用户就可以通过导入一个文件来获得一个库的所有功能。</p>
<p><code>lib</code> 目录也可能包含其他可导入的、非src的库。例如，也许你的主库可以跨平台使用，但是你创建了单独的库，这些库依赖于 <code>dart:io</code> 或者 <code>dart:html</code>。有些包有单独的库，这些库是要用前缀导入的，而主库不是。</p>
<p>让我们来看看一个现实世界中的库包的组织： shelf。<a href="https://github.com/dart-lang/shelf">shelf</a> 包提供了一种使用 Dart 创建 web 服务器的简单方法，它的布局结构是 Dart 库包常用的:</p>
<p><img src="https://dart.dev/assets/libraries/shelf-02e5fd43b660fcef7dbe6a883c40159e0379c8ee2088288ca60ed7dc8781bafd.png" alt="img"></p>
<p>直接在 <code>lib</code> 下，主库文件 <code>shelf.dart</code> 从 <code>lib/src</code> 导出几个文件:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/cascade.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/handler.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/handlers/logger.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/hijack_exception.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/middleware.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/pipeline.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/request.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/response.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/server.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/server_handler.dart</span><span class="s1">&#39;</span><span class="p">;</span>
</code></pre></div><p>shelf 包还包含一个迷你库： <code>shelf_io</code>。这个适配器处理来自 <code>dart:io</code> 的 <code>HttpRequest</code> 对象。</p>
<p>对网络应用的提示: 为了在使用 <a href="https://dart.dev/tools/dartdevc">dartdevc</a> 开发时获得最佳性能，请将<a href="https://dart.dev/tools/pub/package-layout#implementation-files">实现文件</a>放在 <code>/lib/src</code> 下，而不是放在 <code>/lib</code> 下的其他地方。同时，避免导入 <code>package:package_name/src/...</code> 的文件。</p>
<h2 id="导入库文件">导入库文件</h2>
<p>当从其他包中导入一个库文件时，使用 <code>package:</code> 指令来指定该文件的 URI。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:utilities/utilities.dart</span><span class="s1">&#39;</span><span class="p">;</span>
</code></pre></div><p>当从自己的包中导入一个库文件时，当两个文件都在 lib 内，或者两个文件都在 lib 外时，使用相对路径。使用 <code>:package</code> 当导入的文件在 lib 内，而导入者在 lib 外时。</p>
<p>下图显示了如何从 lib 和 web 中导入 <code>lib/foo/a.dart</code>。</p>
<p><img src="https://dart.dev/assets/libraries/import-lib-rules-e1777e235dd56aa23f770babcccedb6a12be80af2c3e63065640b889d78be595.png" alt="img"></p>
<h2 id="有条件地导入和导出库文件">有条件地导入和导出库文件</h2>
<p>如果你的库支持多个平台，那么你可能需要有条件地导入或导出库文件。一个常见的用例是一个同时支持 web 和原生平台的库。</p>
<p>要有条件的导入或导出，你需要检查 <code>dart:*</code> 库的存在。下面是一个有条件导出代码的例子，它检查 <code>dart:io</code> 和 <code>dart:html</code> 的存在:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/hw_none.dart</span><span class="s1">&#39;</span> <span class="err">/</span><span class="err">/</span> <span class="n">Stub</span> <span class="n">implementation</span>
    <span class="n">if</span> <span class="err">(</span><span class="n">dart</span><span class="err">.</span><span class="n">library</span><span class="err">.</span><span class="n">io</span><span class="err">)</span> <span class="s1">&#39;</span><span class="s1">src/hw_io.dart</span><span class="s1">&#39;</span> <span class="err">/</span><span class="err">/</span> <span class="n">dart</span><span class="err">:</span><span class="n">io</span> <span class="n">implementation</span>
    <span class="n">if</span> <span class="err">(</span><span class="n">dart</span><span class="err">.</span><span class="n">library</span><span class="err">.</span><span class="n">html</span><span class="err">)</span> <span class="s1">&#39;</span><span class="s1">src/hw_html.dart</span><span class="s1">&#39;</span><span class="p">;</span> <span class="c1">// dart:html implementation
</span></code></pre></div><p>下面是这段代码的作用。</p>
<ul>
<li>在一个可以使用 <code>dart:io</code> 的应用程序中(例如，一个命令行应用程序)，导出 <code>src/hw_io.dart</code></li>
<li>在一个可以使用 <code>dart:html</code> 的应用程序中(一个 web 应用程序)，导出 <code>src/hw_html.dart</code></li>
<li>否则，导出 <code>src/hw_none.dart</code></li>
</ul>
<p>要有条件地导入一个文件，使用与上面相同的代码，但将 <code>exporrt</code> 改为 <code>import</code>。</p>
<p>注意：有条件的导入或导出只检查库在当前平台上是否可用，而不是检查是否实际导入或使用。</p>
<p>所有有条件导出的库都必须实现相同的 API。例如，这里是 <code>dart:io</code> 的实现:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">alarm</span><span class="p">(</span><span class="p">[</span><span class="kt">String</span> <span class="n">text</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">stderr</span><span class="p">.</span><span class="n">writeln</span><span class="p">(</span><span class="n">text</span> <span class="o">?</span><span class="o">?</span> <span class="n">message</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">String</span> <span class="kd">get</span> <span class="n">message</span> <span class="o">=</span><span class="o">&gt;</span> <span class="s1">&#39;</span><span class="s1">Hello World from the VM!</span><span class="s1">&#39;</span><span class="p">;</span>
</code></pre></div><p>这里是默认的实现，它是一个抛出 UnsupportedErrors 的 stub。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">alarm</span><span class="p">(</span><span class="p">[</span><span class="kt">String</span> <span class="n">text</span><span class="p">]</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="k">throw</span> <span class="n">UnsupportedError</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">hw_none alarm</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>

<span class="kt">String</span> <span class="kd">get</span> <span class="n">message</span> <span class="o">=</span><span class="o">&gt;</span> <span class="k">throw</span> <span class="n">UnsupportedError</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">hw_none message</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>在任何平台上，你都可以导入有条件导出代码的库。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:hw_mp/hw_mp.dart</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="提供补充文件">提供补充文件</h2>
<p>一个设计良好的库包是很容易测试的。我们建议你使用 <a href="https://github.com/dart-lang/test">test</a> 包来编写测试，将测试代码放在测试包顶部的 <code>test</code> 目录中。</p>
<p>如果你创建了任何旨在供公众使用的命令行工具，请将这些工具放在 <code>bin</code> 目录下，这是公共的。启用从命令行运行工具，使用 <a href="https://dart.dev/tools/pub/cmd/pub-global#activating-a-package">pub global activate</a>。将工具列在 pubspec 的<a href="https://dart.dev/tools/pub/pubspec#executables">可执行文件部分</a>，允许用户直接运行它，而无需调用 <a href="https://dart.dev/tools/pub/cmd/pub-global#running-a-script-using-pub-global-run">pub global run</a>。</p>
<p>如果你包含了一个如何使用你的库的例子，这将会很有帮助。这将被放入软件包顶部的 <code>example</code> 目录中。</p>
<p>你在开发过程中创建的任何工具或可执行文件，如果不是公开使用的，都会进入 <code>tool</code> 目录。</p>
<p>如果你把你的库发布到 pub.dev 站点，其他需要的文件，如 <code>README.md</code> 和 <code>CHANGELOG.md</code>，将在<a href="https://dart.dev/tools/pub/publishing">发布软件包</a>中描述。有关如何组织包目录的更多信息，请参见 <a href="https://dart.dev/tools/pub/package-layout">pub 包布局惯例</a>。</p>
<h2 id="编写库文档">编写库文档</h2>
<p>你可以使用 <a href="https://github.com/dart-lang/dartdoc#dartdoc">dartdoc</a> 工具为你的库生成 API 文档。Dartdoc 解析源码寻找<a href="https://dart.dev/guides/language/effective-dart/documentation#doc-comments">文档注释</a>，其中使用了 <code>///</code> 语法:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">/// The event handler responsible for updating the badge in the UI.
</span><span class="c1"></span><span class="kt">void</span> <span class="n">updateBadge</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">.</span><span class="p">.</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div><p>关于生成文档的例子，请看 <a href="https://pub.dev/documentation/shelf/latest">shelf 文档</a>。</p>
<p>注意：要在生成的文档中包含任何库级文档，你必须指定 <code>library</code> 指令。请参阅 <a href="https://github.com/dart-lang/dartdoc/issues/1082">问题 1082</a>。</p>
<h2 id="分发一个开源库">分发一个开源库</h2>
<p>如果你的库是开源的，我们建议在 <a href="https://pub.dev/">pub.dev</a> 站点上分享它。要发布或更新库，请使用 <a href="https://dart.dev/tools/pub/cmd/pub-lish">pub publish</a>，它可以上传您的包并创建或更新其页面。例如，请看 <a href="https://pub.dev/packages/shelf">shelf 包</a>的页面。有关如何准备发布软件包的详细信息，请参见<a href="https://dart.dev/tools/pub/publishing">发布包</a>。</p>
<p>pub.dev 站点不仅托管您的软件包，而且还生成和托管您软件包的 API 参考文档。最新生成的文档的链接在软件包的 <strong>About</strong> 框中；例如，请看 shelf 包的 <a href="https://pub.dev/documentation/shelf">API 文档</a>。到以前版本的文档的链接在软件包页面的版本选项卡中。</p>
<p>要确保你的软件包的 API 文档在 pub.dev 网站上看起来不错，请按照以下步骤进行。</p>
<ul>
<li>在发布你的软件包之前，运行 <a href="https://github.com/dart-lang/dartdoc#dartdoc">dartdoc</a> 工具，以确保你的 docs 成功生成，并且看起来符合预期。</li>
<li>发布软件包后，检查 <strong>Versions</strong> 选项卡以确保文档成功生成。</li>
<li>如果文档根本没有生成，点击 <strong>Verrsions</strong> 选项卡中的 <strong>failed</strong>，查看 dartdoc 的输出。</li>
</ul>
<h2 id="资源">资源</h2>
<p>使用以下资源了解更多关于库包的信息。</p>
<ul>
<li><a href="https://dart.dev/guides/language/language-tour">语言之旅</a>中的<a href="https://dart.dev/guides/language/language-tour#libraries-and-visibility">库和可见性</a>包括使用库文件。</li>
<li><a href="https://dart.dev/guides/packages">包</a>文档很有用，特别是<a href="https://dart.dev/tools/pub/package-layout">包的布局约定</a>。</li>
<li><a href="https://dart.dev/guides/libraries/private-files">不应提交的内容</a>涵盖了哪些不应该被检查到源代码库中。</li>
<li><a href="https://github.com/dart-lang">dart-lang</a> 组织下的较新的库包倾向于展示最佳实践。可以考虑研究这些例子：<a href="https://github.com/dart-lang/dart_style">dart_style</a>、<a href="https://github.com/dart-lang/path">path</a>、<a href="https://github.com/dart-lang/shelf">shelf</a>、<a href="https://github.com/dart-lang/source_gen">source_gen</a> 和 <a href="https://github.com/dart-lang/test">test</a>。</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flutter" term="flutter" label="flutter" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/packages" term="packages" label="packages" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[发布包]]></title>
            <link href="https://ohmyweekly.github.io/notes/publishing-packages/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/creating-packages/?utm_source=atom_feed" rel="related" type="text/html" title="创建包" />
                <link href="https://ohmyweekly.github.io/notes/how-to-use-packages/?utm_source=atom_feed" rel="related" type="text/html" title="如何使用包" />
                <link href="https://ohmyweekly.github.io/notes/commonly-used-packages/?utm_source=atom_feed" rel="related" type="text/html" title="常用的包" />
                <link href="https://ohmyweekly.github.io/notes/write-http-clients/?utm_source=atom_feed" rel="related" type="text/html" title="编写HTTP客户端和服务器" />
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第一部分" />
            
                <id>https://ohmyweekly.github.io/notes/publishing-packages/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-30T00:00:00+08:00</published>
            <updated>2020-06-30T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Publishing packages</blockquote><p><a href="https://dart.dev/guides/packages">pub 软件包管理器</a>不仅仅是用来使用别人的软件包。它还允许你与世界分享你的软件包。如果您有一个有用的项目，并且您希望其他人能够使用它，请使用 <code>pub publish</code> 命令。</p>
<p>注意: 如果要发布到 pub.dev 以外的其他位置，或者要防止在任何地方发布，请使用 <a href="https://dart.dev/tools/pub/pubspec">pubspec</a> 中定义的  <code>publish_to</code> 字段。</p>
<h2 id="发布是永远的">发布是永远的</h2>
<p>请记住，发布是永远的。只要你发布你的包，用户就可以依赖它。一旦他们开始这样做，删除包就会破坏他们的包。为了避免这种情况，<a href="https://pub.dev/policy">pub.dev 政策</a>不允许取消发布软件包，除非是极少数情况。</p>
<p>你可以随时上传你的包的新版本，但旧的包将继续为那些还没有准备好升级的用户提供服务。</p>
<p>对于已经发布的包，如果不再相关或正在维护，你可以<a href="https://dart.dev/tools/pub/publishing#discontinue">将其标记为停止发布</a>。</p>
<h2 id="准备发布">准备发布</h2>
<p>当发布一个软件包时，遵循 <a href="https://dart.dev/tools/pub/pubspec">pubspec 格式</a>和<a href="https://dart.dev/tools/pub/package-layout">包布局惯例</a>是很重要的。其中有些是必须的，以便其他人能够使用你的软件包。另一些则是为了帮助用户更容易理解和使用您的软件包而提出的建议。在这两种情况下，pub 都会尝试帮助你，指出哪些改变会帮助你的软件包在 Dart 生态系统中发挥得更好。上传包有一些额外的要求:</p>
<ul>
<li>
<p>你必须包含一个包含<a href="https://opensource.org/">开源许可证</a>的 <code>LICENSE</code> 文件。我们推荐 <a href="https://opensource.org/licenses/BSD-3-Clause">BSD 许可证</a>，这是 Dart 自己使用的。你也必须有合法的权利来重新发布你上传的任何东西作为你的包的一部分。</p>
</li>
<li>
<p>你的软件包在经过 gzip 压缩后必须小于 10 MB。如果太大，可以考虑将其分割成多个包，或者减少包含的资源或例子的数量。</p>
</li>
<li>
<p>你的包应该只依赖托管的依赖项(来自默认的 pub 包服务器)和 SDK 依赖项(<code>sdk: flutter</code>)。这些限制确保了你的包的依赖性不会在未来变得不可用。</p>
</li>
<li>
<p>您必须有一个 <a href="https://support.google.com/accounts/answer/27441">Google 帐户</a>，pub 用来管理包的上传权限。您的 Google 账户可以与 Gmail 地址或任何其他电子邮件地址关联。</p>
</li>
</ul>
<p>注意：除非您使用<a href="https://dart.dev/tools/pub/verified-publishers">已验证的发布者</a>发布，否则 pub.dev 会显示与您的 Google 帐户关联的电子邮件地址。</p>
<h3 id="重要文件">重要文件</h3>
<p>Pub 使用一些文件的内容为你的包创建一个页面，地址是 <code>pub.dev/packages/&lt;your_package&gt;</code>。以下是影响你的包的页面外观的文件。</p>
<ul>
<li>README.md: <code>README.md</code> 文件是你的包页面中的主要内容。该文件的内容以 <a href="https://pub.dev/packages/markdown">Markdown</a> 的形式呈现。</li>
<li>CHANGELOG.md：<code>CHANGELOG.md</code> 文件是你的包页面中的主要内容。你的包的 <code>CHANGELOG.md</code> 文件，如果找到的话，也会在你的包页面的一个标签中显示，这样开发者就可以直接从 pub.dev 中读取它。该文件的内容会以 <a href="https://pub.dev/packages/markdown">Markdown</a> 的形式呈现。</li>
<li>pubspec: 你的包的 <code>pubspec.yaml</code> 文件用来在你的包的页面右侧填写关于你的包的详细信息，比如它的描述、主页等。</li>
</ul>
<h3 id="使用经过验证的发布者的优势">使用经过验证的发布者的优势</h3>
<p>您可以使用已验证的发布者（推荐）或独立的谷歌账户发布软件包。使用经过验证的发布者有以下优势。</p>
<ul>
<li>您的包的消费者知道发布者的域名已经被验证。</li>
<li>您可以避免让 pub.dev 显示您的个人电子邮件地址。取而代之的是，pub.dev会显示发布者的域名和联系地址。</li>
<li>经验证的发布者徽章 pub.dev 经验证的发布者标识会在搜索页面和单个软件包页面上显示在您的软件包名称旁边。</li>
</ul>
<h3 id="创建一个验证过的发布者">创建一个验证过的发布者</h3>
<p>要创建一个已验证的发布者，请按照以下步骤进行。</p>
<ol>
<li>进入 <a href="https://pub.dev/">pub.dev</a>。</li>
<li>使用 Google 账户登录 pub.dev。</li>
<li>在右上角的用户菜单中，选择创建发布者。</li>
<li>输入您要与您的发布者相关联的域名(例如，<code>dart.dev</code>)，然后单击&quot;创建发布者&rdquo;。</li>
<li>在确认对话框中，选择&quot;确定&rdquo;。</li>
<li>如果提示，完成验证流程，这将打开 <a href="https://search.google.com/search-console/about">Google 搜索控制台</a>。</li>
</ol>
<ul>
<li>在添加 DNS 记录时，可能需要几个小时后，搜索控制台才会反映出变化。</li>
<li>验证流程完成后，返回步骤4。</li>
</ul>
<h2 id="发布你的包">发布你的包</h2>
<p>使用 <a href="https://dart.dev/tools/pub/cmd/pub-lish">pub publish</a> 命令来首次发布您的软件包，或将其更新到新版本。</p>
<h3 id="执行-dry-run">执行 dry run</h3>
<p>为了测试 <code>pub publish</code> 的工作情况，你可以进行一次 dry run:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ pub publish --dry-run
</code></pre></div><p>Pub 会确保你的软件包遵循 <a href="https://dart.dev/tools/pub/pubspec">pubspec 格式</a>和<a href="https://dart.dev/tools/pub/package-layout">包布局约定</a>，然后将你的软件包上传到 <a href="https://pub.dev/">pub.dev</a>。Pub 还会向你展示它打算发布的所有文件。下面是一个发布名为 <code>transmogrify</code> 的软件包的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml">Publishing<span class="w"> </span>transmogrify<span class="w"> </span><span class="m">1.0</span><span class="m">.0</span><span class="w">
</span><span class="w">    </span>.gitignore<span class="w">
</span><span class="w">    </span>CHANGELOG.md<span class="w">
</span><span class="w">    </span>README.md<span class="w">
</span><span class="w">    </span>lib<span class="w">
</span><span class="w">        </span>transmogrify.dart<span class="w">
</span><span class="w">        </span>src<span class="w">
</span><span class="w">            </span>transmogrifier.dart<span class="w">
</span><span class="w">            </span>transmogrification.dart<span class="w">
</span><span class="w">    </span>pubspec.yaml<span class="w">
</span><span class="w">    </span>test<span class="w">
</span><span class="w">        </span>transmogrify_test.dart<span class="w">
</span><span class="w">
</span><span class="w"></span>Package<span class="w"> </span>has<span class="w"> </span><span class="m">0</span><span class="w"> </span>warnings.<span class="w">
</span></code></pre></div><h3 id="发布">发布</h3>
<p>当你准备好发布你的包时，请删除 <code>--dry-run</code> 参数:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ pub publish
</code></pre></div><p>注意: pub 命令目前不支持直接将新软件包发布到已验证的发布者。作为一个临时的变通方法，可以将新的软件包发布到Google账户，然后将包<a href="https://dart.dev/tools/pub/publishing#transferring-a-package-to-a-verified-publisher">转移到发布者</a>。</p>
<p>一旦软件包被转移到发布者，你就可以使用 <code>pub publish</code> 更新软件包。</p>
<p>当你的包成功上传到 pub.dev 后，任何 pub 用户都可以下载它或在他们的项目中依赖它。例如，如果你刚刚发布了 1.0.0 版本的 <code>transmogrify</code> 包，那么另一个 Dart 开发者可以在他们的 <code>pubspec.yaml</code> 中添加它作为依赖:</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">dependencies</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="k">transmogrify</span><span class="p">:</span><span class="w"> </span>^<span class="m">1.0</span><span class="m">.0</span><span class="w">
</span></code></pre></div><h3 id="将软件包传输给已验证的发布者">将软件包传输给已验证的发布者</h3>
<p>要将一个软件包转移到已验证的发布者，您必须是该软件包的<a href="https://dart.dev/tools/pub/publishing#uploaders">上传者</a>和已验证发布者的管理员。</p>
<p>注意：这个过程是不可逆的。一旦你将一个软件包转移到一个发布者，你不能将它转移回个人账户。</p>
<p>以下是如何将软件包转移到已验证的发布者:</p>
<ol>
<li>用一个被列为软件包上传者的 Google 账户登录到 <a href="https://pub.dev/">pub.dev</a>。</li>
<li>进入软件包的详细信息页面(例如，<code>https://pub.dev/packages/http</code>)。</li>
<li>选择&quot;管理&quot;选项卡。</li>
<li>输入发布者的名称，然后单击&quot;传输到发布者&rdquo;。</li>
</ol>
<h3 id="哪些文件会被发布">哪些文件会被发布？</h3>
<p>您的软件包中的<strong>所有</strong>文件都包含在已发布的软件包中，但有以下例外:</p>
<ul>
<li>任何包的目录。</li>
<li>您的软件包的 <a href="https://dart.dev/tools/pub/glossary#lockfile">lockfile</a> 文件。</li>
<li>如果你没有使用 Git，所有隐藏的文件（也就是名字以 <code>.</code> 开头的文件）。</li>
<li>如果使用 Git，则是所有被 <code>.gitignore</code> 文件忽略的文件。</li>
</ul>
<p>请确保删除任何你不想包含的文件(或将它们添加到 <code>.gitignore</code> 中)。 <code>pub publish</code> 在上传你的包之前列出了它要发布的所有文件，所以在完成上传之前要仔细检查列表。</p>
<h2 id="上传者">上传者</h2>
<p>谁发布了软件包的第一个版本，谁就会自动成为第一个也是唯一一个被授权上传该软件包其他版本的人。要允许或不允许其他人上传版本，请使用 <a href="https://dart.dev/tools/pub/cmd/pub-uploader">pub uploader</a> 命令或将软件包转移到<a href="https://dart.dev/tools/pub/verified-publishers">已验证的发布者</a>那里。</p>
<p>如果一个软件包有一个经过验证的发布者，那么该软件包的 pub.dev 页面会显示发布者的域名。否则，该页面将显示该软件包的授权上传者的电子邮件地址。</p>
<h2 id="发布预发包">发布预发包</h2>
<p>当你在做一个包的时候，考虑把它作为一个预发布。当以下任何一种情况发生时，预发布都是有用的。</p>
<ul>
<li>你正在积极开发软件包的下一个主要版本。</li>
<li>你想为软件包的下一个发行候选版本招募测试者。</li>
<li>该包依赖于 Dart 或 Flutter SDK 的不稳定版本。</li>
</ul>
<p>正如在<a href="https://semver.org/spec/v2.0.0-rc.1.html">语义版本化</a>中所描述的那样，为了使一个版本的预发布，你要给版本附加一个后缀。例如，要对 <code>2.0.0</code> 版本进行预发布，你可以使用 <code>2.0.0-dev.1</code> 版本。以后，当你发布 <code>2.0.0</code> 版本时，它将优先于所有 <code>2.0.0-XXX</code> 预发布版本。</p>
<p>因为 pub 更倾向于在可用的时候发布稳定版，所以一个预发布包的用户可能需要改变他们的依赖约束。例如，如果用户想要测试 2.1 版本的预发布包，那么他们可以指定 <code>^2.1.0-dev.1</code>，而不是 <code>^2.0.0</code> 或 <code>^2.1.0</code>。</p>
<p>注意: 如果依赖关系图中的稳定包依赖于一个 prerelease，那么 pub 会选择那个 prerelease 而不是稳定版本。</p>
<p>当一个 prerelease 被发布到 pub.dev 时，软件包页面会同时显示到 prerelease 和稳定版的链接。prerelease 不会影响分析得分，不会出现在搜索结果中，也不会替换包的 <code>README.md</code> 和文档。</p>
<h2 id="将软件包标记为已停产的软件包">将软件包标记为已停产的软件包</h2>
<p>尽管软件包总是保持发布，但向开发者发出信号，表明一个软件包不再被积极维护，是很有用的。为此，您可以将一个软件包标记为 <code>discontinued</code>。一个已停用的软件包仍然可以在 pub.dev 上发布和查看，但它有一个清晰的 DISCONTINUED 徽章，并且不会出现在 pub.dev 的搜索结果中。</p>
<p>要将软件包标记为已停用，请使用该软件包的上传者或已验证的发布者管理员的 Google 帐户登录 pub.dev。然后使用单个软件包的管理选项卡将该软件包标记为已停用。</p>
<h2 id="资源">资源</h2>
<p>有关更多信息，请参见以下 pub 命令的参考页面。</p>
<ul>
<li><a href="https://dart.dev/tools/pub/cmd/pub-lish">pub publish</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-uploader">pub uploader</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flutter" term="flutter" label="flutter" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/packages" term="packages" label="packages" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[编写HTTP客户端和服务器]]></title>
            <link href="https://ohmyweekly.github.io/notes/write-http-clients/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/creating-packages/?utm_source=atom_feed" rel="related" type="text/html" title="创建包" />
                <link href="https://ohmyweekly.github.io/notes/publishing-packages/?utm_source=atom_feed" rel="related" type="text/html" title="发布包" />
                <link href="https://ohmyweekly.github.io/notes/how-to-use-packages/?utm_source=atom_feed" rel="related" type="text/html" title="如何使用包" />
                <link href="https://ohmyweekly.github.io/notes/commonly-used-packages/?utm_source=atom_feed" rel="related" type="text/html" title="常用的包" />
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第一部分" />
            
                <id>https://ohmyweekly.github.io/notes/write-http-clients/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-30T00:00:00+08:00</published>
            <updated>2020-06-30T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Write HTTP clients &amp; servers</blockquote><p>有什么意义呢？</p>
<ul>
<li>HTTP 协议允许客户端和服务器进行通信。</li>
<li>dart:io 包有编写 HTTP 程序的类。</li>
<li>服务器监听主机和端口上的请求。</li>
<li>客户端使用 HTTP 方法请求发送请求。</li>
<li>http_server 包提供了更高级别的构件。</li>
</ul>
<p>前提条件: HTTP 服务器和客户端严重依赖 future 和流，本教程中没有解释这些内容。你可以从<a href="https://dart.dev/codelabs/async-await">异步编程 codelab</a>和<a href="https://dart.dev/tutorials/language/streams">流教程</a>中了解它们。</p>
<p>HTTP（超文本传输协议）是一种通信协议，用于通过互联网将数据从一个程序发送到另一个程序。数据传输的一端是服务器，另一端是客户端。客户端通常是基于浏览器的（用户在浏览器中输入或在浏览器中运行的脚本），但也可能是一个独立的程序。</p>
<p>服务器与主机和端口绑定（它与一个IP地址和一个端口号建立专属连接）。然后服务器监听请求。由于 Dart 的异步性，服务器可以同时处理很多请求，具体如下。</p>
<ul>
<li>服务器监听</li>
<li>客户端连接</li>
<li>服务器接受并接收请求(并继续监听)</li>
<li>服务器可以继续接受其他请求</li>
<li>服务器写入请求的响应或几个请求，可能是交错的请求</li>
<li>服务器最终结束(关闭)响应</li>
</ul>
<p>在 Dart 中，<a href="https://api.dart.dev/stable/dart-io/dart-io-library.html">dart:io</a> 库包含了编写 HTTP 客户端和服务器所需的类和函数。此外，<a href="https://pub.dev/packages/http_server">http_server</a> 包包含了一些更高层次的类，使其更容易编写客户端和服务器。</p>
<p>重要：基于浏览器的程序不能使用 dart:io 库。</p>
<p>dart:io 库中的 API 只适用于独立的命令行程序。它们不能在浏览器中工作。要从基于浏览器的客户端发出 HTTP 请求，请参考 <a href="https://api.dart.dev/stable/dart-html/HttpRequest-class.html">dart:html HttpRequest</a> 类。</p>
<p>本教程提供了几个例子，说明编写 Dart HTTP 服务器和客户端是多么容易。从服务器的 <code>hello world</code> 开始，你将学习如何编写服务器的代码，从绑定和监听到响应请求。你还可以学习到客户端：提出不同类型的请求(GET 和 POST)，编写基于浏览器和命令行的客户端。</p>
<h2 id="获取源码">获取源码</h2>
<ul>
<li>获取 Dart 教程的<a href="https://github.com/dart-lang/dart-tutorials-samples/archive/master.zip">示例代码</a>。</li>
<li>查看 <code>httpserver</code> 目录，其中包含本教程所需的源码。</li>
</ul>
<h2 id="运行-hello-world-服务器">运行 hello world 服务器</h2>
<p>本节的示例文件：<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/hello_world_server.dart">hello_world_server.dart</a>。</p>
<p>让我们从一个小型的服务器开始，用字符串 <code>Hello, world</code> 来响应所有的请求。</p>
<p>在命令行中，运行 <code>hello_world_server.dart</code> 脚本:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">$</span> <span class="n">cd</span> <span class="n">httpserver</span>
<span class="n">$</span> <span class="n">dart</span> <span class="n">bin</span><span class="o">/</span><span class="n">hello_world_server</span><span class="p">.</span><span class="n">dart</span>
<span class="n">listening</span> <span class="n">on</span> <span class="n">localhost</span><span class="p">,</span> <span class="n">port</span> <span class="m">4040</span>
</code></pre></div><p>在任何浏览器中，访问 <a href="http://localhost:4040/">localhost:4040</a>。浏览器会显示 <code>Hello, world!</code>。</p>
<p><img src="https://dart.dev/tutorials/server/images/hello_world_response.png" alt="img"></p>
<p>在这种情况下，服务器是一个 Dart 程序，客户端是你使用的浏览器。然而，你可以用 Dart 编写客户端程序-无论是基于浏览器的客户端脚本，还是独立的程序。</p>
<h3 id="快速浏览一下代码">快速浏览一下代码</h3>
<p>在 <code>hello world</code> 服务器的代码中，一个 HTTP 服务器与主机和端口绑定，监听 HTTP 请求，并写入响应。需要注意的是，该程序导入了 <a href="https://api.dart.dev/stable/dart-io/dart-io-library.html">dart:io</a> 库，其中包含了服务器端程序和客户端程序的 HTTP 相关类(但不包含 Web 应用)。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">server</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span>
    <span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">,</span>
    <span class="m">4040</span><span class="p">,</span>
  <span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Listening on localhost:</span><span class="si">${</span><span class="n">server</span><span class="p">.</span><span class="n">port</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>

  <span class="kd">await</span> <span class="k">for</span> <span class="p">(</span><span class="n">HttpRequest</span> <span class="n">request</span> <span class="k">in</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">request</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Hello, world!</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
    <span class="kd">await</span> <span class="n">request</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>接下来的几节内容包括服务器端绑定、发出客户端 GET 请求、监听和响应。</p>
<h2 id="将服务器绑定到主机和端口">将服务器绑定到主机和端口</h2>
<p>本节示例：<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/hello_world_server.dart">hello_world_server.dart</a>。</p>
<p><code>main()</code> 中的第一条语句使用 <code>HttpServer.bind()</code> 创建一个 <a href="https://api.dart.dev/stable/dart-io/HttpServer-class.html">HttpServer</a> 对象，并将其绑定到主机和端口。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">var</span> <span class="n">server</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span>
  <span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">,</span>
  <span class="m">4040</span><span class="p">,</span>
<span class="p">)</span><span class="p">;</span>
</code></pre></div><p>该代码使用 <code>await</code> 异步调用 <code>bind</code> 方法。</p>
<h3 id="主机名">主机名</h3>
<p><code>bind()</code> 的第一个参数是指定主机名。你可以用一个字符串来指定一个特定的主机名或IP地址，也可以用 <a href="https://api.dart.dev/stable/dart-io/InternetAddress-class.html">InternetAddress</a> 类提供的这些预定义的值来指定主机。</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">用例</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">回环 IPv4 或 loopbackIPv6</td>
<td align="left">服务器在 loopback 地址上监听客户端活动，该地址实际上是 localhost。使用IP协议的4或6版本。这些主要用于测试。我们建议您使用这些值而不是 <code>localhost</code> 或 <code>127.0.0.1</code>。</td>
</tr>
<tr>
<td align="left">任何 IPv4 或 anyIPv6</td>
<td align="left">服务器监听任何 IP 地址上指定端口上的客户端活动。使用IP协议的4或6版本。</td>
</tr>
</tbody>
</table>
<p>默认情况下，当使用V6互联网地址时，也会使用V4监听器。</p>
<h3 id="端口">端口</h3>
<p><code>bind()</code> 的第二个参数是指定端口的整数。端口唯一地标识主机上的服务。1024 以下的端口号为标准服务保留(0除外)。例如，FTP 数据传输通常在端口20上运行，每日报价在端口17上运行，HTTP 在端口80上运行。你的程序应该使用1024以上的端口号。如果端口已经在使用中，你的服务器的连接将被拒绝。</p>
<h3 id="侦听请求">侦听请求</h3>
<p>服务器使用 <code>await for</code> 开始监听 HTTP 请求。每收到一个请求，代码就会发送一个 &ldquo;Hello, world!&rdquo; 的响应。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">await</span> <span class="k">for</span> <span class="p">(</span><span class="n">HttpRequest</span> <span class="n">request</span> <span class="k">in</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">request</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Hello, world!</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="kd">await</span> <span class="n">request</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>你将在<a href="https://dart.dev/tutorials/server/httpserver#httprequest-object">监听和处理请求</a>一节中了解更多关于 <a href="https://api.dart.dev/stable/dart-io/HttpRequest-class.html">HttpRequest</a> 对象包含的内容以及如何编写响应。但首先，让我们看看客户端产生请求的一种方式。</p>
<h2 id="使用-html-表单发出-get-请求">使用 HTML 表单发出 GET 请求</h2>
<p>本节的示例文件：<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/number_thinker.dart">number_thinker.dart</a> 和 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/web/make_a_guess.html">make_a_guess.html</a>。</p>
<p>本节介绍了一个命令行服务器，它可以随机选择一个0到9之间的数字。客户端是一个基本的 HTML 网页，<code>make_a_guess.html</code>，你可以用它来猜数字。</p>
<p>试试吧</p>
<ol>
<li>运行数字思考者服务器</li>
</ol>
<p>在命令行，运行 <code>number_thinker.dart</code> server。你应该看到类似下面的东西:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">cd</span> httpserver
$ dart bin/number_thinker.dart
I<span class="err">&#39;</span>m thinking of a number: <span class="m">6</span>
</code></pre></div><ol start="2">
<li>启动网络服务器</li>
</ol>
<p>从应用程序的顶部目录运行 <code>webdev serve</code>。</p>
<p>更多信息：<a href="https://dart.dev/tools/webdev">webdev 文档</a></p>
<ol start="3">
<li>打开 HTML 页面</li>
</ol>
<p>在浏览器中，进入 <a href="http://localhost:8080/make_a_guess.html">localhost:8080/make_a_guess.html</a>。</p>
<ol start="4">
<li>做一个猜测</li>
</ol>
<p>选择一个数字，然后按猜测按钮。</p>
<p><img src="https://dart.dev/tutorials/server/images/guessing.png" alt="img"></p>
<p>在客户端中没有涉及到 Dart 代码。客户端请求是通过浏览器向 Dart 服务器发出的，在 <code>make_a_guess.html</code> 中的 HTML 表单，它提供了一个自动制定和发送客户端 HTTP 请求的方法。该表单包含下拉列表和按钮。该表单还指定了 URL，其中包括端口号，以及请求的种类（请求方法）。它还可能包含建立查询字符串的元素。</p>
<p>下面是 <code>make_a_guess.html</code> 中的表单 HTML。</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">form</span> <span class="na">action</span><span class="o">=</span><span class="s">&#34;http://localhost:4041&#34;</span> <span class="na">method</span><span class="o">=</span><span class="s">&#34;GET&#34;</span><span class="p"></span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">select</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;q&#34;</span><span class="p"></span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;0&#34;</span><span class="p"></span><span class="p">&gt;</span>0<span class="p">&lt;</span><span class="p">/</span><span class="nt">option</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;1&#34;</span><span class="p"></span><span class="p">&gt;</span>1<span class="p">&lt;</span><span class="p">/</span><span class="nt">option</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;2&#34;</span><span class="p"></span><span class="p">&gt;</span>2<span class="p">&lt;</span><span class="p">/</span><span class="nt">option</span><span class="p">&gt;</span>
    <span class="c">&lt;!--</span><span class="c"> ··· </span><span class="c">--&gt;</span>
    <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;9&#34;</span><span class="p"></span><span class="p">&gt;</span>9<span class="p">&lt;</span><span class="p">/</span><span class="nt">option</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="p">/</span><span class="nt">select</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;submit&#34;</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;Guess&#34;</span><span class="p"></span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="p">/</span><span class="nt">form</span><span class="p">&gt;</span>
</code></pre></div><p>下面是表单的工作原理:</p>
<ul>
<li>表单的 <code>action</code> 属性被分配给发送请求的 URL</li>
<li>表单的 <code>method</code> 属性定义了请求的类型，这里是 <code>GET</code>。其他常见的请求类型包括 POST、PUT 和 DELETE。</li>
<li>表单中任何有名称(<code>name</code>)的元素，比如 <code>&lt;select&gt;</code> 元素，都会成为查询字符串中的一个参数。</li>
<li>当按下提交按钮(<code>&lt;input type=&quot;submit&quot;...&gt;</code>)时，提交按钮会根据表单的内容制定请求并发送。</li>
</ul>
<h3 id="一个-restful-get-请求">一个 RESTful GET 请求</h3>
<p>REST(REpresentational State Transfer)是一套设计 Web 服务的原则。乖巧的 HTTP 客户端和服务器遵守为 GET 请求定义的 REST 原则。</p>
<p>一个 GET 请求:</p>
<ul>
<li>只检索数据</li>
<li>不会改变服务器的状态</li>
<li>有长度限制</li>
<li>可以在请求的 URL 中发送查询字符串</li>
</ul>
<p>在这个例子中，客户端发出了一个符合 REST 的 GET 请求。</p>
<h2 id="监听和处理请求">监听和处理请求</h2>
<p>本节的示例文件: <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/number_thinker.dart">number_thinker.dart</a> 和 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/web/make_a_guess.html">make_a_guess.html</a>。</p>
<p>现在你已经看到这个基于浏览器的客户端的例子，让我们看看数字思维服务器的 Dart 代码，从 <code>main()</code> 开始。</p>
<p>再一次，服务器绑定了一个主机和端口。在这里，每收到一个请求都会调用顶层的 <code>handleRequest()</code> 方法。因为 HttpServer 实现了 <a href="https://api.dart.dev/stable/dart-async/Stream-class.html">Stream</a>，所以可以使用 <code>await for</code> 来处理请求。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:math</span><span class="s1">&#39;</span> <span class="k">show</span> <span class="n">Random</span><span class="p">;</span>

<span class="n">Random</span> <span class="n">intGenerator</span> <span class="o">=</span> <span class="n">Random</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">myNumber</span> <span class="o">=</span> <span class="n">intGenerator</span><span class="p">.</span><span class="n">nextInt</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="s2">I&#39;m thinking of a number: </span><span class="si">$</span><span class="n">myNumber</span><span class="s2">&#34;</span><span class="p">)</span><span class="p">;</span>

  <span class="n">HttpServer</span> <span class="n">server</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span>
    <span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">,</span>
    <span class="m">4041</span><span class="p">,</span>
  <span class="p">)</span><span class="p">;</span>
  <span class="kd">await</span> <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">request</span> <span class="k">in</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">handleRequest</span><span class="p">(</span><span class="n">request</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>当一个 <code>GET</code> 请求到达时，<code>handleRequest()</code> 方法会调用 <code>handleGet()</code> 来处理该请求。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">handleRequest</span><span class="p">(</span><span class="n">HttpRequest</span> <span class="n">request</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="o">=</span><span class="o">=</span> <span class="s1">&#39;</span><span class="s1">GET</span><span class="s1">&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">handleGet</span><span class="p">(</span><span class="n">request</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// ···
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Exception in handleRequest: </span><span class="si">$</span><span class="n">e</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Request handled.</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>一个 <a href="https://api.dart.dev/stable/dart-io/HttpRequest-class.html">HttpRequest</a> 对象有很多属性，提供了关于请求的信息。下表列出了一些有用的属性。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">信息</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">method</td>
<td align="left">&lsquo;GET&rsquo;, &lsquo;POST&rsquo;, &lsquo;PUT&rsquo; 等方法中的一个。</td>
</tr>
<tr>
<td align="left">uri</td>
<td align="left">一个 <a href="https://api.dart.dev/stable/dart-core/Uri-class.html">Uri</a> 对象：scheme、host、port、query string 和其他关于请求资源的信息。</td>
</tr>
<tr>
<td align="left">response</td>
<td align="left">一个 <a href="https://api.dart.dev/stable/dart-io/HttpResponse-class.html">HttpResponse</a> 对象：服务器将其响应写入其中。</td>
</tr>
<tr>
<td align="left">headers</td>
<td align="left">一个 <a href="https://api.dart.dev/stable/dart-io/HttpHeaders-class.html">HttpHeaders</a> 对象：请求的头信息，包括 <a href="https://api.dart.dev/stable/dart-io/ContentType-class.html">ContentType</a>、内容长度、日期等。</td>
</tr>
</tbody>
</table>
<h3 id="使用方法属性">使用方法属性</h3>
<p>下面的数想器例子中的代码使用 HttpRequest 的 <code>method</code> 属性来确定收到了什么样的请求。这个服务器只处理 GET 请求。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="o">=</span><span class="o">=</span> <span class="s1">&#39;</span><span class="s1">GET</span><span class="s1">&#39;</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">handleGet</span><span class="p">(</span><span class="n">request</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">request</span><span class="p">.</span><span class="n">response</span>
    <span class="p">.</span><span class="p">.</span><span class="n">statusCode</span> <span class="o">=</span> <span class="n">HttpStatus</span><span class="p">.</span><span class="n">methodNotAllowed</span>
    <span class="p">.</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Unsupported request: </span><span class="si">${</span><span class="n">request</span><span class="p">.</span><span class="n">method</span><span class="si">}</span><span class="s1">.</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="使用-uri-属性">使用 uri 属性</h3>
<p>在浏览器中输入一个 URL 会产生一个 GET 请求，它只是简单地从指定的资源中请求数据。它可以通过附加在 URI 上的查询字符串随请求发送少量数据。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">handleGet</span><span class="p">(</span><span class="n">HttpRequest</span> <span class="n">request</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">guess</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">uri</span><span class="p">.</span><span class="n">queryParameters</span><span class="p">[</span><span class="s1">&#39;</span><span class="s1">q</span><span class="s1">&#39;</span><span class="p">]</span><span class="p">;</span>
  <span class="c1">// ···
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>使用 HttpRequest 对象的 <code>uri</code> 属性来获取一个 <a href="https://api.dart.dev/stable/dart-core/Uri-class.html">Uri</a> 对象，这个 Uri 对象包含了用户输入的 URL 的信息。Uri 对象的 <code>queryParameters</code> 属性是一个 Map，包含查询字符串的组件。通过名称来引用所需的参数。本例使用 <code>q</code> 来标识猜测的数字。</p>
<h3 id="设置响应的状态码">设置响应的状态码</h3>
<p>服务器应该设置状态码来表示请求的成功或失败。前面看到数想家将状态码设置为 <code>methodNotAllowed</code> 来拒绝非 GET 请求。在后面的代码中，为了表示请求成功，响应完成，数想家服务器将 <code>HttpResponse</code> 状态码设置为 <code>HttpStatus.ok</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">handleGet</span><span class="p">(</span><span class="n">HttpRequest</span> <span class="n">request</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">guess</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">uri</span><span class="p">.</span><span class="n">queryParameters</span><span class="p">[</span><span class="s1">&#39;</span><span class="s1">q</span><span class="s1">&#39;</span><span class="p">]</span><span class="p">;</span>
  <span class="kd">final</span> <span class="n">response</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">response</span><span class="p">;</span>
  <span class="n">response</span><span class="p">.</span><span class="n">statusCode</span> <span class="o">=</span> <span class="n">HttpStatus</span><span class="p">.</span><span class="n">ok</span><span class="p">;</span>
  <span class="c1">// ···
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p><code>HttpStatus.ok</code> 和 <code>HttpStatus.methodNotAllowed</code> 是 <a href="https://api.dart.dev/stable/dart-io/HttpStatus-class.html">HttpStatus</a> 类中许多预定义状态码中的两个。另一个有用的预定义状态码是 <code>HttpStatus.notFound</code>(经典的 404）。</p>
<p>除了状态码(<code>statusCode</code>)，HttpResponse 对象还有其他有用的属性:</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">信息</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">contentLength</td>
<td align="left">响应的长度，-1 表示事先不知道长度。</td>
</tr>
<tr>
<td align="left">cookies</td>
<td align="left">要在客户端设置的 <a href="https://api.dart.dev/stable/dart-io/Cookie-class.html">Cookies</a> 列表。</td>
</tr>
<tr>
<td align="left">encoding</td>
<td align="left">编写字符串时使用的<a href="https://api.dart.dev/stable/dart-convert/Encoding-class.html">编码</a>，如 JSON 和 UTF-8。</td>
</tr>
<tr>
<td align="left">headers</td>
<td align="left">响应头，是一个 <a href="https://api.dart.dev/stable/dart-io/HttpHeaders-class.html">HttpHeaders</a> 对象。</td>
</tr>
</tbody>
</table>
<h3 id="将响应写到-httpresponse-对象">将响应写到 HttpResponse 对象</h3>
<p>每个 HttpRequest 对象都有一个对应的 HttpResponse 对象。服务器通过响应对象将数据发回给客户端。</p>
<p>使用 HttpResponse 写方法之一(<code>write()</code>、<code>writeln()</code>、<code>writeAll()</code> 或 <code>writeCharCodes()</code>)将响应数据写入 HttpResponse 对象。或者通过 <code>addStream</code> 将 <code>HttpResponse</code> 对象连接到一个流，并写入流。响应完成后关闭对象。关闭 HttpResponse 对象会将数据发回给客户端。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">handleGet</span><span class="p">(</span><span class="n">HttpRequest</span> <span class="n">request</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ···
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">guess</span> <span class="o">=</span><span class="o">=</span> <span class="n">myNumber</span><span class="p">.</span><span class="n">toString</span><span class="p">(</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">response</span>
      <span class="p">.</span><span class="p">.</span><span class="n">writeln</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">true</span><span class="s1">&#39;</span><span class="p">)</span>
      <span class="p">.</span><span class="p">.</span><span class="n">writeln</span><span class="p">(</span><span class="s2">&#34;</span><span class="s2">I&#39;m thinking of another number.</span><span class="s2">&#34;</span><span class="p">)</span>
      <span class="p">.</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="c1">// ···
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="从独立的客户端进行-post-请求">从独立的客户端进行 POST 请求</h2>
<p>本节的示例文件：<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/basic_writer_server.dart">basic_writer_server.dart</a> 和  <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/basic_writer_client.dart">basic_writer_client.dart</a>。</p>
<p>在 <code>hello world</code> 和 <code>number thinker</code> 的例子中，浏览器生成了简单的 GET 请求，对于更复杂的 GET 请求和其他类型的请求，如 POST、PUT 或 DELETE，你需要写一个客户端程序，其中有两种。</p>
<ul>
<li>一个独立的客户端程序，它使用 <code>dart:io</code> 的 <a href="https://api.dart.dev/stable/dart-io/HttpClient-class.html">HttpClient</a> 类。</li>
<li>基于浏览器的客户端，使用 <a href="https://api.dart.dev/stable/dart-html/dart-html-library.html">dart:html</a> 中的 API。本教程不涉及基于浏览器的客户端。要查看基于浏览器的客户端和相关服务器的代码，请参见 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/web/note_client.dart">note_client.dart</a>、<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/note_server.dart">note_server.dart</a> 和 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/web/note_taker.html">note_taker.html</a>。</li>
</ul>
<p>让我们看看一个独立的客户端，<code>basic_writer_client.dart</code> 和它的服务器 <code>basic_writer_server.dart</code>。客户端发出一个 POST 请求，将 JSON 数据保存到服务器端的文件中。服务器接受请求并保存文件。</p>
<h4 id="试试吧">试试吧</h4>
<p>在命令行上运行服务器和客户端。</p>
<ol>
<li>首先，运行服务器:</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">cd</span> httpserver
$ dart bin/basic_writer_server.dart
</code></pre></div><ol start="2">
<li>在一个新的终端中，运行客户端:</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">cd</span> httpserver
$ dart bin/basic_writer_client.dart
Wrote data <span class="k">for</span> Han Solo.
</code></pre></div><p>看看服务器写入 <code>file.txt</code> 的 JSON 数据:</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span><span class="nt">&#34;name&#34;</span><span class="p">:</span><span class="s2">&#34;Han Solo&#34;</span><span class="p">,</span><span class="nt">&#34;job&#34;</span><span class="p">:</span><span class="s2">&#34;reluctant hero&#34;</span><span class="p">,</span><span class="nt">&#34;BFF&#34;</span><span class="p">:</span><span class="s2">&#34;Chewbacca&#34;</span><span class="p">,</span><span class="nt">&#34;ship&#34;</span><span class="p">:</span><span class="s2">&#34;Millennium Falcon&#34;</span><span class="p">,</span><span class="nt">&#34;weakness&#34;</span><span class="p">:</span><span class="s2">&#34;smuggling debts&#34;</span><span class="p">}</span>
</code></pre></div><p>客户端创建一个 HttpClient 对象，并使用 <code>post()</code> 方法进行请求。发起一个请求涉及两个 Future。</p>
<ul>
<li><code>post()</code> 方法建立与服务器的网络连接并完成第一个 Future，返回一个 HttpClientRequest 对象。</li>
<li>客户端组成请求对象并关闭它。<code>close()</code> 方法将请求发送到服务器并返回第二个 Future，它以一个 HttpClientResponse 对象完成。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:convert</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="kt">String</span> <span class="n">_host</span> <span class="o">=</span> <span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">.</span><span class="n">host</span><span class="p">;</span>
<span class="kt">String</span> <span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">file.txt</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="n">Map</span> <span class="n">jsonData</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">&#39;</span><span class="s1">name</span><span class="s1">&#39;</span><span class="o">:</span> <span class="s1">&#39;</span><span class="s1">Han Solo</span><span class="s1">&#39;</span><span class="p">,</span>
  <span class="s1">&#39;</span><span class="s1">job</span><span class="s1">&#39;</span><span class="o">:</span> <span class="s1">&#39;</span><span class="s1">reluctant hero</span><span class="s1">&#39;</span><span class="p">,</span>
  <span class="s1">&#39;</span><span class="s1">BFF</span><span class="s1">&#39;</span><span class="o">:</span> <span class="s1">&#39;</span><span class="s1">Chewbacca</span><span class="s1">&#39;</span><span class="p">,</span>
  <span class="s1">&#39;</span><span class="s1">ship</span><span class="s1">&#39;</span><span class="o">:</span> <span class="s1">&#39;</span><span class="s1">Millennium Falcon</span><span class="s1">&#39;</span><span class="p">,</span>
  <span class="s1">&#39;</span><span class="s1">weakness</span><span class="s1">&#39;</span><span class="o">:</span> <span class="s1">&#39;</span><span class="s1">smuggling debts</span><span class="s1">&#39;</span>
<span class="p">}</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="n">HttpClientRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpClient</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="n">_host</span><span class="p">,</span> <span class="m">4049</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="cm">/*1*/</span>
    <span class="p">.</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">contentType</span> <span class="o">=</span> <span class="n">ContentType</span><span class="p">.</span><span class="n">json</span> <span class="cm">/*2*/</span>
    <span class="p">.</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">jsonEncode</span><span class="p">(</span><span class="n">jsonData</span><span class="p">)</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*3*/</span>
  <span class="n">HttpClientResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">request</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*4*/</span>
  <span class="kd">await</span> <span class="n">utf8</span><span class="p">.</span><span class="n">decoder</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">response</span> <span class="cm">/*5*/</span><span class="p">)</span><span class="p">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">print</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>/<em>1</em>/ <code>post()</code> 方法需要主机、端口和请求资源的路径。除了 <code>post()</code> 之外，<a href="https://api.dart.dev/stable/dart-io/HttpClient-class.html">HttpClient</a> 类还提供了其他类型的请求函数，包括 <code>postUrl()</code>、<code>get()</code> 和 <code>open()</code>。</p>
<p>/<em>2</em>/ 一个 <a href="https://api.dart.dev/stable/dart-io/HttpClientRequest-class.html">HttpClientRequest</a> 对象有一个 <a href="https://api.dart.dev/stable/dart-io/HttpHeaders-class.html">HttpHeaders</a> 对象，它包含了请求头的信息。对于一些请求头，比如 <code>contentType</code>，HttpHeaders 有一个针对该请求头的属性。对于其他的请求头，使用 <code>set()</code> 方法将该请求头放入 HttpHeaders 对象中。</p>
<p>/<em>3</em>/ 客户端使用 <code>write()</code> 向请求对象写入数据。编码，在这个例子中是 JSON，与 <a href="https://api.dart.dev/stable/dart-io/ContentType-class.html">ContentType</a> 头中指定的类型相匹配。</p>
<p>/<em>4</em>/ <code>close()</code> 方法将请求发送到服务器，完成后返回一个 <a href="https://api.dart.dev/stable/dart-io/HttpClientResponse-class.html">HttpClientResponse</a> 对象。</p>
<p>/<em>5</em>/ 来自服务器的 UTF-8 响应将被解码。使用在 <a href="https://api.dart.dev/stable/dart-convert/dart-convert-library.html">dart:convert</a> 库中定义的转换器将数据转换为常规的 Dart 字符串格式。</p>
<h3 id="一个-restful-post-请求">一个 RESTful POST 请求</h3>
<p>与 GET 请求类似，REST 为 POST 请求提供了指导方针。</p>
<p>一个 POST 请求:</p>
<ul>
<li>创建一个资源(在这个例子中，一个文件)</li>
<li>使用一个 URI，其结构与文件和目录路径名相似；例如，URI 没有查询字符串。</li>
<li>以 JSON 或 XML 格式传输数据</li>
<li>没有状态，也不会改变服务器的状态。</li>
<li>无长度限制</li>
</ul>
<p>这个例子中的客户端发出 REST 兼容的 POST 请求。</p>
<p>要想看到使 REST 兼容的 GET 请求的客户端代码，请看 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/number_guesser.dart">number_guesser.dart</a>。它是一个独立的客户端，用于数字思考者服务器，定期进行猜测，直到猜对为止。</p>
<h2 id="在服务器中处理一个-post-请求">在服务器中处理一个 POST 请求</h2>
<p>本节的示例文件：<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/basic_writer_server.dart">basic_writer_server.dart</a> 和 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/basic_writer_client.dart">basic_writer_client.dart</a>。</p>
<p>一个 HttpRequest 对象是一个字节列表流(<code>Stream&lt;List&lt;int&gt;</code>)。要获得客户端发送的数据，就要监听 HttpRequest 对象上的数据。</p>
<p>如果来自客户端的请求包含了大量的数据，数据可能会以多个分块的形式到达。你可以使用 Stream 中的 <code>join()</code> 方法来连接这些分块的字符串值。</p>
<p><img src="https://dart.dev/tutorials/server/images/flowchart.png" alt="img"></p>
<p><code>basic_writer_server.dart</code> 文件实现了一个遵循这种模式的服务器。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:convert</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="kt">String</span> <span class="n">_host</span> <span class="o">=</span> <span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">.</span><span class="n">host</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">server</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">_host</span><span class="p">,</span> <span class="m">4049</span><span class="p">)</span><span class="p">;</span>
  <span class="kd">await</span> <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">req</span> <span class="k">in</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ContentType</span> <span class="n">contentType</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">contentType</span><span class="p">;</span>
    <span class="n">HttpResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="n">response</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">method</span> <span class="o">=</span><span class="o">=</span> <span class="s1">&#39;</span><span class="s1">POST</span><span class="s1">&#39;</span> <span class="o">&amp;</span><span class="o">&amp;</span>
        <span class="n">contentType</span><span class="o">?</span><span class="p">.</span><span class="n">mimeType</span> <span class="o">=</span><span class="o">=</span> <span class="s1">&#39;</span><span class="s1">application/json</span><span class="s1">&#39;</span> <span class="cm">/*1*/</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="kt">String</span> <span class="n">content</span> <span class="o">=</span>
            <span class="kd">await</span> <span class="n">utf8</span><span class="p">.</span><span class="n">decoder</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*2*/</span>
        <span class="kd">var</span> <span class="n">data</span> <span class="o">=</span> <span class="n">jsonDecode</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="o">as</span> <span class="n">Map</span><span class="p">;</span> <span class="cm">/*3*/</span>
        <span class="kd">var</span> <span class="n">fileName</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="n">uri</span><span class="p">.</span><span class="n">pathSegments</span><span class="p">.</span><span class="n">last</span><span class="p">;</span> <span class="cm">/*4*/</span>
        <span class="kd">await</span> <span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAsString</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="nl">mode:</span> <span class="n">FileMode</span><span class="p">.</span><span class="n">write</span><span class="p">)</span><span class="p">;</span>
        <span class="n">req</span><span class="p">.</span><span class="n">response</span>
          <span class="p">.</span><span class="p">.</span><span class="n">statusCode</span> <span class="o">=</span> <span class="n">HttpStatus</span><span class="p">.</span><span class="n">ok</span>
          <span class="p">.</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Wrote data for </span><span class="si">${</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;</span><span class="s1">name</span><span class="s1">&#39;</span><span class="p">]</span><span class="si">}</span><span class="s1">.</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">response</span>
          <span class="p">.</span><span class="p">.</span><span class="n">statusCode</span> <span class="o">=</span> <span class="n">HttpStatus</span><span class="p">.</span><span class="n">internalServerError</span>
          <span class="p">.</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Exception during file I/O: </span><span class="si">$</span><span class="n">e</span><span class="s1">.</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">response</span>
        <span class="p">.</span><span class="p">.</span><span class="n">statusCode</span> <span class="o">=</span> <span class="n">HttpStatus</span><span class="p">.</span><span class="n">methodNotAllowed</span>
        <span class="p">.</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Unsupported request: </span><span class="si">${</span><span class="n">req</span><span class="p">.</span><span class="n">method</span><span class="si">}</span><span class="s1">.</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">await</span> <span class="n">response</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>/<em>1</em>/ 该请求有一个 HttpHeaders 对象。记得客户端将 <code>contentType</code> 头设置为 JSON(application/json)。该服务器拒绝不是 JSON 编码的请求。</p>
<p>/<em>2</em>/ 一个 POST 请求对它可以发送的数据量没有限制，数据可能会以多块形式发送。此外，JSON 是 UTF-8，而 UTF-8 字符可以在多个字节上进行编码。<code>join()</code> 方法将这些分块放在一起。</p>
<p>/<em>3</em>/ 客户端发送的数据是 JSON 格式的。服务器使用 <a href="https://api.dart.dev/stable/dart-convert/dart-convert-library.html">dart:convert</a> 库中的 JSON 编解码器对其进行解码。</p>
<p>/<em>4</em>/ 请求的 URL 是 <a href="http://localhost:4049/file.txt">localhost:4049/file.txt</a>。代码 <code>req.uri.pathSegments.last</code> 从 URI 中提取文件名: <code>file.txt</code>。</p>
<h3 id="关于-cors-头的说明">关于 CORS 头的说明</h3>
<p>如果你想为运行在不同源头（不同主机或端口）的客户端提供服务，你需要添加 CORS 头。下面的代码，取自 note_server.dart，允许从任何来源的 POST 和 OPTIONS 请求。谨慎使用 CORS 头文件，因为它们会给你的网络带来安全风险。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">addCorsHeaders</span><span class="p">(</span><span class="n">HttpResponse</span> <span class="n">response</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">response</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Access-Control-Allow-Origin</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">*</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="n">response</span><span class="p">.</span><span class="n">headers</span>
      <span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Access-Control-Allow-Methods</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">POST, OPTIONS</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="n">response</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Access-Control-Allow-Headers</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="s1">&#39;</span><span class="s1">Origin, X-Requested-With, Content-Type, Accept</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>更多信息，请参考维基百科的<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">跨源资源共享</a>一文。</p>
<h2 id="使用-http_server-包">使用 http_server 包</h2>
<p>本节的示例文件：<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/mini_file_server.dart">mini_file_server.dart</a> 和 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/static_file_server.dart">static_file_server.dart</a>。</p>
<p>对于一些更高层次的构件，我们推荐你尝试 <a href="https://pub.dev/packages/http_server">http_server</a> pub 包，它包含了一组类，与 <code>dart:io</code> 库中的 HttpServer 类一起，使得实现 HTTP 务器更加容易。</p>
<p>在本节中，我们比较了一个只使用 <code>dart:io</code> 的 API 编写的服务器和一个使用 dart:io 和 http_server 一起编写的具有相同功能的服务器。</p>
<p>你可以在 <code>mini_file_server.dart</code> 中找到第一个服务器。它通过从 <code>web</code> 目录返回 <code>index.html</code> 文件的内容来响应所有请求。</p>
<h3 id="试试吧-1">试试吧</h3>
<p>在命令行中运行服务器:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">cd</span> httpserver
$ dart bin/mini_file_server.dart
</code></pre></div><p>在浏览器中输入 <a href="http://localhost:4044/">localhost:4044</a>。服务器会显示一个 HTML 文件。</p>
<p><img src="https://dart.dev/tutorials/server/images/index_file.png" alt="img"></p>
<p>这是迷你文件服务器的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="n">File</span> <span class="n">targetFile</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">web/index.html</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="n">Stream</span><span class="o">&lt;</span><span class="n">HttpRequest</span><span class="o">&gt;</span> <span class="n">server</span><span class="p">;</span>

  <span class="k">try</span> <span class="p">{</span>
    <span class="n">server</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">,</span> <span class="m">4044</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="s2">Couldn&#39;t bind to port 4044: </span><span class="si">$</span><span class="n">e</span><span class="s2">&#34;</span><span class="p">)</span><span class="p">;</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">await</span> <span class="k">for</span> <span class="p">(</span><span class="n">HttpRequest</span> <span class="n">req</span> <span class="k">in</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="kd">await</span> <span class="n">targetFile</span><span class="p">.</span><span class="n">exists</span><span class="p">(</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="s2">Serving </span><span class="si">${</span><span class="n">targetFile</span><span class="p">.</span><span class="n">path</span><span class="si">}</span><span class="s2">.</span><span class="s2">&#34;</span><span class="p">)</span><span class="p">;</span>
      <span class="n">req</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">contentType</span> <span class="o">=</span> <span class="n">ContentType</span><span class="p">.</span><span class="n">html</span><span class="p">;</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="kd">await</span> <span class="n">req</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">addStream</span><span class="p">(</span><span class="n">targetFile</span><span class="p">.</span><span class="n">openRead</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="s2">Couldn&#39;t read file: </span><span class="si">$</span><span class="n">e</span><span class="s2">&#34;</span><span class="p">)</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="s2">Can&#39;t open </span><span class="si">${</span><span class="n">targetFile</span><span class="p">.</span><span class="n">path</span><span class="si">}</span><span class="s2">.</span><span class="s2">&#34;</span><span class="p">)</span><span class="p">;</span>
      <span class="n">req</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">statusCode</span> <span class="o">=</span> <span class="n">HttpStatus</span><span class="p">.</span><span class="n">notFound</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">await</span> <span class="n">req</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这段代码确定文件是否存在，如果存在，则打开文件，并将文件内容管道化到HttpResponse对象。</p>
<p>第二个服务器，你可以在 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/basic_file_server.dart">basic_file_server.dart</a> 中找到它的代码，使用 <a href="https://pub.dev/packages/http_server">http_server</a> 包。</p>
<h3 id="试试吧-2">试试吧</h3>
<p>在命令行中运行服务器:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">cd</span> httpserver
$ dart bin/basic_file_server.dart
</code></pre></div><p>在浏览器中输入 <a href="http://localhost:4046/">localhost:4046</a>。服务器显示与之前相同的 index.html 文件。</p>
<p><img src="https://dart.dev/tutorials/server/images/index_file_4046.png" alt="img"></p>
<p>在这个服务器中，处理请求的代码要短得多，因为 <a href="https://pub.dev/documentation/http_server/latest/http_server/VirtualDirectory-class.html">VirtualDirectory</a> 类处理服务文件的细节。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:http_server/http_server.dart</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="n">File</span> <span class="n">targetFile</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">web/index.html</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="n">VirtualDirectory</span> <span class="n">staticFiles</span> <span class="o">=</span> <span class="n">VirtualDirectory</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">.</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>

  <span class="kd">var</span> <span class="n">serverRequests</span> <span class="o">=</span>
      <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">,</span> <span class="m">4046</span><span class="p">)</span><span class="p">;</span>
  <span class="kd">await</span> <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">request</span> <span class="k">in</span> <span class="n">serverRequests</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">staticFiles</span><span class="p">.</span><span class="n">serveFile</span><span class="p">(</span><span class="n">targetFile</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这里，请求的资源 index.html 是由 VirtualDirectory 类中的 <code>serviceFile()</code> 方法提供的。你不需要写代码来打开一个文件并将其内容用管道传送到请求中。</p>
<p>另一个文件服务器 <code>static_file_server.dart</code> 也使用 http_server 包。这个服务器可以服务于服务器目录或子目录中的任何文件。</p>
<p>运行 <code>static_file_server.dart</code>，用 <a href="http://localhost:4048/">localhost:4048</a> 这个 URL 进行测试。</p>
<p>下面是 <code>static_file_server.dart</code> 的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:http_server/http_server.dart</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">staticFiles</span> <span class="o">=</span> <span class="n">VirtualDirectory</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">web</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="n">staticFiles</span><span class="p">.</span><span class="n">allowDirectoryListing</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="cm">/*1*/</span>
  <span class="n">staticFiles</span><span class="p">.</span><span class="n">directoryHandler</span> <span class="o">=</span> <span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span> <span class="cm">/*2*/</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="n">indexUri</span> <span class="o">=</span> <span class="n">Uri</span><span class="p">.</span><span class="n">file</span><span class="p">(</span><span class="n">dir</span><span class="p">.</span><span class="n">path</span><span class="p">)</span><span class="p">.</span><span class="n">resolve</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">index.html</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
    <span class="n">staticFiles</span><span class="p">.</span><span class="n">serveFile</span><span class="p">(</span><span class="n">File</span><span class="p">(</span><span class="n">indexUri</span><span class="p">.</span><span class="n">toFilePath</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*3*/</span>
  <span class="p">}</span><span class="p">;</span>

  <span class="kd">var</span> <span class="n">server</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">,</span> <span class="m">4048</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Listening on port 4048</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="kd">await</span> <span class="n">server</span><span class="p">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">staticFiles</span><span class="p">.</span><span class="n">serveRequest</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*4*/</span>
<span class="p">}</span>
</code></pre></div><p>/<em>1</em>/ 允许客户端请求服务器目录内的文件。</p>
<p>/<em>2</em>/ 一个匿名函数，处理对目录本身的请求，即 URL 不包含文件名。该函数将这些请求重定向到 <code>index.html</code>。</p>
<p>/<em>3</em>/ <code>serveFile</code> 方法为一个文件提供服务，在这个例子中，它为目录请求服务index.html。</p>
<p>/<em>4</em>/ VirtualDirectory 类提供的 <code>serviceRequest</code> 方法处理指定文件的请求。</p>
<h2 id="使用-bindsecure-的-https-方法">使用 bindSecure() 的 https 方法</h2>
<p>本节的示例：<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/hello_world_server_secure.dart">hello_world_server_secure.dart</a>。</p>
<p>你可能已经注意到，HttpServer 类定义了一个叫做 <code>bindSecure()</code> 的方法，它使用 HTTPS(Hyper Text Transfer Protocol with Secure Sockets Layer)提供安全连接。要使用 <code>bindSecure()</code> 方法，你需要一个证书，这个证书由证书颁发机构(CA)提供。有关证书的更多信息，请参考<a href="https://www.tldp.org/HOWTO/SSL-Certificates-HOWTO/x64.html">什么是 SSL 和什么是证书</a>？</p>
<p>为了说明问题，下面的服务器 <code>hello_world_server_secure.dart</code> 使用 Dart 团队创建的证书调用 <code>bindSecure()</code> 进行测试。你必须为你的服务器提供自己的证书。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="kt">String</span> <span class="n">certificateChain</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">server_chain.pem</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="kt">String</span> <span class="n">serverKey</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">server_key.pem</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">serverContext</span> <span class="o">=</span> <span class="n">SecurityContext</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*1*/</span>
  <span class="n">serverContext</span><span class="p">.</span><span class="n">useCertificateChain</span><span class="p">(</span><span class="n">certificateChain</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*2*/</span>
  <span class="n">serverContext</span><span class="p">.</span><span class="n">usePrivateKey</span><span class="p">(</span><span class="n">serverKey</span><span class="p">,</span> <span class="nl">password:</span> <span class="s1">&#39;</span><span class="s1">dartdart</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*3*/</span>

  <span class="kd">var</span> <span class="n">server</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bindSecure</span><span class="p">(</span>
    <span class="s1">&#39;</span><span class="s1">localhost</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="m">4047</span><span class="p">,</span>
    <span class="n">serverContext</span><span class="p">,</span> <span class="cm">/*4*/</span>
  <span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Listening on localhost:</span><span class="si">${</span><span class="n">server</span><span class="p">.</span><span class="n">port</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="kd">await</span> <span class="k">for</span> <span class="p">(</span><span class="n">HttpRequest</span> <span class="n">request</span> <span class="k">in</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">request</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Hello, world!</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
    <span class="kd">await</span> <span class="n">request</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>/<em>1</em>/ 安全网络连接的可选设置在 SecurityContext 对象中指定，有一个默认的对象 SecurityContext.defaultContext，包括知名证书机构的可信根证书。</p>
<p>/<em>2</em>/ 一个包含从服务器证书到签名机关根证书链的文件，<a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail">格式为 PEM</a>。</p>
<p>/<em>3</em>/ 一个包含（加密的）服务器证书私钥的文件，<a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail">PEM 格式</a>。</p>
<p>/<em>4</em>/ 在服务器上，上下文参数是必需的，对客户端来说是可选的。如果省略它，则使用默认的内置可信根的上下文。</p>
<h2 id="其他资源">其他资源</h2>
<p>请访问这些 API 文档，了解本教程中讨论的类和库的更多细节。</p>
<table>
<thead>
<tr>
<th align="left">Dart 类</th>
<th align="left">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpServer-class.html">HttpServer</a></td>
<td align="left">一个 HTTP 服务器</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpClient-class.html">HttpClient</a></td>
<td align="left">一个 HTTP 客户端</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpRequest-class.html">HttpRequest</a></td>
<td align="left">一个服务器端请求对象</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpResponse-class.html">HttpResponse</a></td>
<td align="left">一个服务器端响应对象</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpClientRequest-class.html">HttpClientRequest</a></td>
<td align="left">一个客户端请求对象</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpClientResponse-class.html">HttpClientResponse</a></td>
<td align="left">一个客户端响应对象</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpHeaders-class.html">HttpHeaders</a></td>
<td align="left">请求头</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpStatus-class.html">HttpStatus</a></td>
<td align="left">响应的状态</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/InternetAddress-class.html">InternetAddress</a></td>
<td align="left">一个互联网地址</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/SecurityContext-class.html">SecurityContext</a></td>
<td align="left">包含安全连接的证书、密钥和信任信息。</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/http_server">http_server</a> 包</td>
<td align="left">一个具有较高级别的 HTTP 类的包</td>
</tr>
</tbody>
</table>
<h2 id="下一步该怎么做">下一步该怎么做？</h2>
<ul>
<li>如果你还没有尝试过服务器端的 codelab，可以尝试<a href="https://dart-lang.github.io/server/codelab/">编写一个服务器应用程序</a>。</li>
<li><a href="https://dart-lang.github.io/server/">Servers with Dart</a> 链接到编写独立 Dart 应用程序的资源，包括服务器。</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flutter" term="flutter" label="flutter" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/client" term="client" label="client" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[如何使用包]]></title>
            <link href="https://ohmyweekly.github.io/notes/how-to-use-packages/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/commonly-used-packages/?utm_source=atom_feed" rel="related" type="text/html" title="常用的包" />
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第一部分" />
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app-part-two/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第二部分" />
            
                <id>https://ohmyweekly.github.io/notes/how-to-use-packages/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-29T00:00:00+08:00</published>
            <updated>2020-06-29T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Dart 包管理工具 - pub</blockquote><p>Dart 生态系统使用包来管理共享软件，如库和工具。要获得 Dart 包，你可以使用 <code>pub</code> 包管理器。你可以在 <a href="https://pub.dev/">pub.dev</a> 网站上找到公开的包，也可以从本地文件系统或其他地方加载包，比如 Git 仓库。无论你的包来自哪里，pub 都会管理版本依赖关系，帮助你获得相互之间以及与 SDK 版本兼容的包版本。</p>
<p>大多数精通 Dart 的 <a href="https://dart.dev/tools#ides-and-editors">IDE</a> 都提供了对 pub 的支持，包括创建、下载、更新和发布包。或者你可以<a href="https://dart.dev/tools/pub/cmd">在命令行中使用 pub</a>。</p>
<p>至少，一个 Dart 包是一个包含 <a href="https://dart.dev/tools/pub/pubspec">pubspec 文件</a>的目录。pubspec 包含一些关于包的元数据。此外，一个包可以包含依赖关系(在 pubspec 中列出)，Dart 库，应用程序，资源，测试，图像和例子。</p>
<p>要使用一个包，请执行以下操作:</p>
<ul>
<li>创建一个 pubspec(一个名为 <code>pubspec.yaml</code> 的文件，它列出了软件包的依赖关系，并包含其他元数据，如版本号)。</li>
<li>使用 <code>pub</code> 来获取你的包的依赖关系。</li>
<li>如果你的 Dart 代码依赖于软件包中的一个库，则导入该库。</li>
</ul>
<h2 id="创建一个-pubspec">创建一个 pubspec</h2>
<p>pubspec 是一个名为 <code>pubspec.yaml</code> 的文件，它位于你的应用程序的顶级目录中。最简单的 pubspec 只列出了包名:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="nl">name:</span> <span class="n">my_app</span>
</code></pre></div><p>下面是一个 pubspec 的例子，它声明了两个包(<code>js</code> 和 <code>intl</code>)的依赖关系，这两个包都托管在 pub.dev 站点上:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="nl">name:</span> <span class="n">my_app</span>
<span class="nl">dependencies:</span>
  <span class="nl">js:</span> <span class="o">^</span><span class="m">0.6</span><span class="p">.</span><span class="m">0</span>
  <span class="nl">intl:</span> <span class="o">^</span><span class="m">0.15</span><span class="p">.</span><span class="m">8</span>
</code></pre></div><p>关于创建 pubspec 的详细信息，请参见 <a href="https://dart.dev/tools/pub/pubspec">pubspec 文档</a>和你要使用的包的文档。</p>
<h2 id="获取软件包">获取软件包</h2>
<p>一旦你有了 pubspec，你就可以从你的应用程序的顶级目录中运行 <code>pub get</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">cd</span> &lt;path-to-my_app&gt;
$ pub get
</code></pre></div><p>这个过程被称为获取依赖关系。</p>
<p><code>pub get</code> 命令可以确定您的应用程序依赖于哪些软件包，并将它们放在中央<a href="https://dart.dev/tools/pub/glossary#system-cache">系统缓存</a>中。如果您的应用程序依赖于已发布的包，pub 会从 <a href="https://pub.dev/">pub.dev</a> 站点下载该包。对于  <a href="https://dart.dev/tools/pub/dependencies#git-packages">Git 依赖</a>，pub 会克隆 Git 仓库。还包括了过渡性依赖。例如，如果 <code>js</code> 包依赖于 <code>test</code> 包，<code>pub</code> 会同时抓取 <code>js</code> 包和 <code>test</code> 包。</p>
<p>Pub 会创建一个 <code>.packages</code> 文件(在你的应用程序的顶层目录下)，将你的应用程序所依赖的每个包名映射到系统缓存中的对应包。</p>
<h2 id="从包中导入库">从包中导入库</h2>
<p>要导入在包中找到的库，使用 <code>package:</code> 前缀:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:js/js.dart</span><span class="s1">&#39;</span> <span class="k">as</span> <span class="n">js</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:intl/intl.dart</span><span class="s1">&#39;</span><span class="p">;</span>
</code></pre></div><p>Dart 运行时在 <code>package:</code> 之后的所有内容都会在应用程序的 <code>.package</code> 文件中进行查找。</p>
<p>你也可以使用这种风格从你自己的包中导入库。比方说，<code>transmogrify</code> 包的布局如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">transmogrify/
  lib/
    transmogrify.dart
    parser.dart
  test/
    parser/
      parser_test.dart
</code></pre></div><p><code>parser_test.dart</code> 文件可以这样导入 <code>parser.dart</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:transmogrify/parser.dart</span><span class="s1">&#39;</span><span class="p">;</span>
</code></pre></div><h2 id="升级依赖关系">升级依赖关系</h2>
<p>当你第一次为你的软件包获取一个新的依赖关系时，pub 会下载与你的其他依赖关系兼容的最新版本。然后，它通过创建一个 <strong>lockfile</strong> 锁文件来锁定您的软件包，使其始终使用该版本。这是一个名为 <code>pubspec.lock</code> 的文件，由 pub 创建并存储在 pubspec 的旁边。它列出了您的软件包所使用的每个依赖关系的特定版本 (即时的和过渡的)。</p>
<p>如果你的包是一个应用程序包，你应该把这个文件检查到<a href="https://dart.dev/guides/libraries/private-files">源代码控制</a>中。这样，在你的应用程序上工作的每个人都会使用所有包的相同版本。在 lockfile 文件中检查也可以确保你部署的应用使用相同版本的代码。</p>
<p>当你准备好将你的依赖项升级到最新版本时，使用 <a href="https://dart.dev/tools/pub/cmd/pub-upgrade">pub upgrade</a> 命令:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">$</span> <span class="n">pub</span> <span class="n">upgrade</span>
</code></pre></div><p><code>pub upgrade</code> 命令告诉 pub 使用你的包的依赖关系的最新版本来重新生成 lockfile 文件。如果你只想升级一个依赖关系，你可以指定要升级的软件包:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">$</span> <span class="n">pub</span> <span class="n">upgrade</span> <span class="n">transmogrify</span>
</code></pre></div><p>该命令将 <code>transmogrify</code> 升级到最新版本，但其他一切都保持不变。</p>
<p>由于 pubspec 中有冲突的版本限制，<a href="https://dart.dev/tools/pub/cmd/pub-upgrade">pub upgrade</a> 命令并不能总是将每个软件包升级到最新版本。要识别需要编辑 pubspec 的过期软件包，请使用 <a href="https://dart.dev/tools/pub/cmd/pub-outdated">pub outdated</a>。</p>
<h2 id="更多信息">更多信息</h2>
<p>下面的页面有更多关于软件包和 pub 包管理器的信息。</p>
<p>如何使用</p>
<ul>
<li><a href="https://dart.dev/guides/libraries/create-library-packages">创建包</a></li>
<li><a href="https://dart.dev/tools/pub/publishing">发布包</a></li>
</ul>
<p>参考</p>
<ul>
<li><a href="https://dart.dev/tools/pub/dependencies">Pub 依赖</a></li>
<li><a href="https://dart.dev/tools/pub/environment-variables">Pub 环境变量</a></li>
<li><a href="https://dart.dev/tools/pub/glossary">Pub 词汇表</a></li>
<li><a href="https://dart.dev/tools/pub/package-layout">Pub 包布局约定</a></li>
<li><a href="https://dart.dev/tools/pub/versioning">Pub 版本哲学</a></li>
<li><a href="https://dart.dev/tools/pub/pubspec">Pubspec 格式化</a></li>
</ul>
<p>Pub 命令</p>
<p><code>pub</code> 工具提供了以下命令:</p>
<ul>
<li><a href="https://dart.dev/tools/pub/cmd/pub-cache">pub cache</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-deps">pub deps</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-downgrade">pub downgrade</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-get">pub get</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-global">pub global</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-outdated">pub outdated</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-lish">pub publish</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-run">pub run</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-upgrade">pub upgrade</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-uploader">pub uploader</a></li>
</ul>
<p>有关所有 pub 命令的概述，请参阅 <a href="https://dart.dev/tools/pub/cmd">pub 工具文档</a>。</p>
<p>疑难解答</p>
<p><a href="https://dart.dev/tools/pub/troubleshoot">故障排除 pub</a> 提供了使用 pub 时可能遇到的问题的解决方案。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flutter" term="flutter" label="flutter" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/packages" term="packages" label="packages" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[常用的包]]></title>
            <link href="https://ohmyweekly.github.io/notes/commonly-used-packages/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/how-to-use-packages/?utm_source=atom_feed" rel="related" type="text/html" title="如何使用包" />
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第一部分" />
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app-part-two/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第二部分" />
            
                <id>https://ohmyweekly.github.io/notes/commonly-used-packages/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-29T00:00:00+08:00</published>
            <updated>2020-06-29T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Commonly used packages</blockquote><p>本页列出了一些  Dart 开发者发布的最流行和最有用的<a href="https://dart.dev/guides/packages">包</a>。要找到更多的软件包&ndash;也可以搜索<a href="https://dart.dev/guides/libraries">核心库</a>&ndash;请使用 <a href="https://pub.dev/">pub.dev</a> 网站。</p>
<p>常用的软件包可分为三类:</p>
<ul>
<li><a href="https://dart.dev/guides/libraries/useful-libraries#general-purpose-packages">通用包</a></li>
<li><a href="https://dart.dev/guides/libraries/useful-libraries#packages-that-correspond-to-sdk-libraries">扩展 Dart 核心库的包</a></li>
<li><a href="https://dart.dev/guides/libraries/useful-libraries#specialized-packages">特定的包</a></li>
</ul>
<h2 id="通用包">通用包</h2>
<p>以下包对各种项目都很有用:</p>
<table>
<thead>
<tr>
<th align="left">包</th>
<th align="left">描述</th>
<th align="left">常用的 API</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><a href="https://pub.dev/packages/archive">archive</a></td>
<td align="left">对各种档案和压缩格式进行编码和解码。</td>
<td align="left">Archive, ArchiveFile, TarEncoder, TarDecoder, ZipEncoder, ZipDecoder</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/characters">characters</a></td>
<td align="left">对用户感知的字符进行字符串操作(Unicode 字符簇)</td>
<td align="left">String.characters, Characters, CharacterRange</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/http">http</a></td>
<td align="left">一组高级的函数和类，使其易于消费 HTTP 资源</td>
<td align="left">delete(), get(), post(), read()</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/intl">intl</a></td>
<td align="left">国际化和本地化设施，支持复数和性别、日期和数字格式化和解析以及双向文本</td>
<td align="left">Bidi, DateFormat, MicroMoney, TextDirection</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/json_serializable">json_serializable</a></td>
<td align="left">一个易于使用的代码生成包。更多信息，请参阅 <a href="https://dart.dev/guides/json">JSON 支持</a></td>
<td align="left">@JsonSerializable</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/logging">logging</a></td>
<td align="left">一个可配置的机制，为你的应用程序添加消息记录</td>
<td align="left">LoggerHandler, Level, LogRecord</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/mockito">mockito</a></td>
<td align="left">一个在测试中模拟对象的流行框架。如果你正在编写依赖注入的测试，特别有用。与 <a href="https://pub.dev/packages/test">test</a> 包一起使用</td>
<td align="left">Answering, Expectation, Verification</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/path">path</a></td>
<td align="left">操作不同类型路径的常用操作。更多信息，请参见<a href="https://news.dartlang.org/2016/06/unboxing-packages-path.html">拆包: path</a></td>
<td align="left">absolute(), basename(), extension(), join(), normalize(), relative(), split()</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/quiver">quiver</a></td>
<td align="left">实用工具，使 Dart 核心库的使用更加方便。Quiver 提供额外支持的一些库包括 async、cache、collection、core、iterables、pattern 和 测试</td>
<td align="left">CountdownTimer (quiver.async); MapCache (quiver.cache); MultiMap, TreeSet (quiver.collection); EnumerateIterable (quiver.iterables); center(), compareIgnoreCase(), isWhiteSpace() (quiver.strings)</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/shelf">shelf</a></td>
<td align="left">Dart 的 Web 服务器中间件。Shelf 使它能轻松地创建和组成 Web 服务器，以及 Web 服务器的一部分</td>
<td align="left">Cascade, Pipeline, Request, Response, Server</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/stack_trace">stack_trace</a></td>
<td align="left">用于解析、检查和处理由底层 Dart 实现产生的堆栈痕迹的方法。还提供了以比原生 StackTrace 实现更可读的格式生成堆栈跟踪的字符串表示的函数,  更多信息，请参见<a href="https://news.dartlang.org/2016/01/unboxing-packages-stacktrace.html">拆包: stack_trace</a></td>
<td align="left">Trace.current(), Trace.format(), Trace.from()</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/stagehand">stagehand</a></td>
<td align="left">一个 Dart 项目生成器。当你创建一个新的应用程序时，WebStorm 和 IntelliJ 使用 Stagehand 模板，但你也可以从命令行使用模板</td>
<td align="left">一般通过 IDE 或 <code>stagehand</code> 命令来使用</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/test">test</a></td>
<td align="left">在 Dart 中编写和运行测试的标准方法</td>
<td align="left">expect(), group(), test()</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/yaml">yaml</a></td>
<td align="left">YAML 解析器</td>
<td align="left">loadYaml(), loadYamlStream()</td>
</tr>
</tbody>
</table>
<h2 id="扩展-dart-核心库的包">扩展 Dart 核心库的包</h2>
<p>以下每个包都建立在一个<a href="https://dart.dev/guides/libraries">核心库</a>的基础上，增加了功能并填补了缺失的功能:</p>
<table>
<thead>
<tr>
<th align="left">包</th>
<th align="left">描述</th>
<th align="left">常用的 API</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><a href="https://pub.dev/packages/async">async</a></td>
<td align="left">在 dart:async 的基础上进行了扩展，增加了实用类来处理异步计算。更多信息，请参见<a href="https://news.dartlang.org/2016/03/unboxing-packages-async-part-1.html">拆包: async 第1部分</a>、<a href="https://news.dartlang.org/2016/03/unboxing-packages-async-part-2.html">第2部分</a>和<a href="https://news.dartlang.org/2016/04/unboxing-packages-async-part-3.html">第3部分</a></td>
<td align="left">AsyncMemoizer, CancelableOperation, FutureGroup, LazyStream, Result, StreamCompleter, StreamGroup, StreamSplitter</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/collection">collection</a></td>
<td align="left">在 dart:collection 的基础上进行了扩展，增加了实用函数和类，使处理集合的工作变得更加容易。更多信息，请看<a href="https://news.dartlang.org/2016/01/unboxing-packages-collection.html">拆包：collection</a></td>
<td align="left">Equality, CanonicalizedMap, MapKeySet, MapValueSet, PriorityQueue, QueueList</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/convert">convert</a></td>
<td align="left">在 dart:convert 的基础上，增加了编码器和解码器，用于在不同的数据表现形式之间进行转换。其中一种数据表示方式是百分比编码，也被称为 URL 编码</td>
<td align="left">HexDecoder, PercentDecoder</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/io">io</a></td>
<td align="left">包含两个库，ansi和io，以简化对文件、标准流和进程的处理。使用 ansi 库可以自定义终端输出。io 库有处理进程、stdin 和文件复制的 API</td>
<td align="left">copyPath(), isExecutable(), ExitCode, ProcessManager, sharedStdIn</td>
</tr>
</tbody>
</table>
<h2 id="专用包">专用包</h2>
<p>下面是一些寻找比较专业的包的技巧，比如手机的包(Flutter)和网页开发的包。</p>
<h3 id="flutter-包">Flutter 包</h3>
<p>请看 Flutter 网站上的<a href="https://flutter.dev/docs/development/packages-and-plugins/using-packages">使用包</a>。或者使用 pub.dev 网站<a href="https://pub.dev/flutter">搜索 Flutter 包</a>。</p>
<h3 id="网络包">网络包</h3>
<p>参见<a href="https://dart.dev/web/libraries">网络库和包</a>。或者使用 pub.dev 站点<a href="https://pub.dev/web">搜索 web 包</a>。</p>
<h3 id="命令行和服务器软件包">命令行和服务器软件包</h3>
<p>参见<a href="https://dart.dev/server/libraries">命令行和服务器库和包</a>。或者使用 pub.dev 站点<a href="https://pub.dev/">搜索其他包</a>。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flutter" term="flutter" label="flutter" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/packages" term="packages" label="packages" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[编写你的第一个 Flutter 应用，第一部分]]></title>
            <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app-part-two/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第二部分" />
            
                <id>https://ohmyweekly.github.io/notes/write-your-first-flutter-app/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-26T00:00:00+08:00</published>
            <updated>2020-06-26T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Flutter 是 Google 的 UI 工具包，用于从单一代码库中为手机、网页和桌面构建漂亮的、原生编译的应用程序。Flutter 可以与现有的代码一起使用，被世界各地的开发者和组织使用，并且是免费和开源的。</blockquote><h2 id="介绍">介绍</h2>
<p>Flutter 是 Google 的 UI 工具包，用于从单一代码库中为手机、网页和桌面构建漂亮的、原生编译的应用程序。Flutter 可以与现有的代码一起工作，被世界各地的开发者和组织使用，并且是免费和开源的。</p>
<p>在这个代码实验室中，你将创建一个简单的手机 Flutter 应用。如果你熟悉面向对象的代码和基本的编程概念-如变量、循环和条件, 那么你就可以完成这个 codelab。你不需要以前有 Dart、手机或 Web 编程的经验。</p>
<h3 id="你将在第1部分学到什么">你将在第1部分学到什么</h3>
<ul>
<li>如何编写一款在 iOS、Android 和 Web 上看起来很自然的 Flutter 应用？</li>
<li>Flutter 应用程序的基本结构。</li>
<li>寻找和使用包来扩展功能。</li>
<li>使用热重装来加快开发周期。</li>
<li>如何实现一个有状态的小组件。</li>
<li>如何创建一个无限的、懒加载的列表。</li>
</ul>
<p>在这个 codelab 的<a href="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/index.html?index=..%2F..%2Findex#0">第2部分</a>中，你将添加交互性，修改应用程序的主题，并添加导航到新页面的能力(在 Flutter 中称为路由)。</p>
<h3 id="你将在第1部分中构建什么">你将在第1部分中构建什么</h3>
<p>你将实现一个移动应用，为一家创业公司生成建议的名字。用户可以选择和取消选择名字，保存最好的名字。代码一次懒惰地生成10个名字。随着用户的滚动，会生成更多的名字。用户可以滚动的范围没有限制。</p>
<p>下面的 GIF 动画显示了应用程序在完成部分时的工作情况。</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/6556f8b61acd6a89.gif" alt="img"></p>
<h2 id="设置你的-flutter-环境">设置你的 Flutter 环境</h2>
<p>你需要两个软件来完成这个实验室-<a href="https://flutter.io/get-started/install/">Flutter SDK</a>和<a href="https://flutter.io/get-started/editor/">一个编辑器</a>。(codelab 假设你使用 Android Studio，但你可以使用你的首选编辑器。)</p>
<p>你可以通过使用以下任何设备来运行 codelab。</p>
<ul>
<li>一个物理的 <a href="https://flutter.io/setup-macos/#set-up-your-android-device">Android</a> 或 <a href="https://flutter.io/setup-macos/#deploy-to-ios-devices">iOS</a> 设备连接到你的计算机并设置为开发者模式。</li>
<li><a href="https://flutter.io/setup-macos/#set-up-the-ios-simulator">iOS 模拟器</a>(需要安装 Xcode 工具)</li>
<li><a href="https://flutter.io/setup-macos/#set-up-the-android-emulator">安卓模拟器</a>(需要在 Android Studio 中进行设置)</li>
<li>浏览器(调试时需要使用 Chrome 浏览器)</li>
</ul>
<p>如果你想编译你的应用程序以在 web 上运行，你必须启用此功能（目前处于测试阶段）。要启用 web 支持，请使用以下说明。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">flutter channel beta
flutter upgrade
flutter config --enable-web
</code></pre></div><p>你只需要运行一次 <code>config</code> 命令。启用 Web 支持后，你创建的每个 Flutter 应用也会为 Web 编译。在你的 IDE 的<strong>设备</strong>下拉菜单下面，或者在命令行使用 <code>flutter devices</code>，你现在应该看到 Chrome 和 Web 服务器被列出。<strong>Chrome</strong> 设备会自动启动 Chrome。Web 服务器会启动一个托管应用程序的服务器，这样你就可以从任何浏览器加载它。在开发过程中使用 <strong>Chrome</strong> 设备，以便你可以使用 DevTools，而当你要在其他浏览器上进行测试时使用 Web 服务器。有关更多信息，请参阅<a href="https://flutter.dev/docs/get-started/web">使用 Flutter 构建 Web 应用程序</a>和<a href="https://flutter.dev/docs/get-started/codelab-web">在 Web 上编写你的第一个 Flutter 应用程序</a>。</p>
<h2 id="创建-flutter-应用程序的启动器">创建 Flutter 应用程序的启动器</h2>
<p>通过使用<a href="https://flutter.dev/docs/get-started/test-drive#androidstudio">创建应用程序</a>中的说明来创建一个简单的、模板化的 Flutter 应用程序。输入 <code>startup_namer</code>(而不是 <code>flutter_app</code>)作为项目名称。您将修改启动器应用程序来创建完成的应用程序。</p>
<p>提示：如果你在 IDE 中没有看到能够启动一个新的 Flutter 项目作为一个选项，那么请确保你已经<a href="https://flutter.io/get-started/editor/#androidstudio">安装了 Flutter 和 Dart 的插件</a>。</p>
<p>你将主要编辑 <code>lib/main.dart</code>，Dart 的代码就在这里。</p>
<p>替换 <code>lib/main.dart</code> 的内容。
删除 <code>lib/main.dart</code> 中的所有代码，并用下面的代码替换，在屏幕中央显示 &ldquo;Hello World&rdquo;。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:flutter/material.dart</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">runApp</span><span class="p">(</span><span class="n">MyApp</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">MyApp</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="p">{</span>
  <span class="err">@</span><span class="n">override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MaterialApp</span><span class="p">(</span>
      <span class="nl">title:</span> <span class="s1">&#39;</span><span class="s1">Welcome to Flutter</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="nl">home:</span> <span class="n">Scaffold</span><span class="p">(</span>
        <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
          <span class="nl">title:</span> <span class="kd">const</span> <span class="n">Text</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Welcome to Flutter</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">,</span>
        <span class="p">)</span><span class="p">,</span>
        <span class="nl">body:</span> <span class="kd">const</span> <span class="n">Center</span><span class="p">(</span>
          <span class="nl">child:</span> <span class="kd">const</span> <span class="n">Text</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Hello World</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">,</span>
        <span class="p">)</span><span class="p">,</span>
      <span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>提示：当把代码粘贴到你的应用程序中时，缩进会变得歪斜。你可以用以下 Flutter 工具来解决。</p>
<ul>
<li>Android Studio/IntelliJ IDEA: 右键点击 Dart 代码，选择<strong>用 dartfmt 重格式代码</strong>。</li>
<li>VS code: 右键点击并选择<strong>格式化文档</strong>。</li>
<li>终端: 运行 <code>flutter format &lt;文件名&gt;</code>。</li>
</ul>
<p><a href="https://flutter.io/get-started/test-drive/#androidstudio">运行应用程序</a>。您应该看到 Android，iOS 或 Web 输出，取决于您的设备。</p>
<p>安卓系统:</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/f9df7832965ede9f.png" alt="img"></p>
<p>iOS:</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/20374605026d582.png" alt="img"></p>
<p>小贴士：第一次在物理设备上运行时，可能需要一段时间来加载。之后，你可以使用热重载来快速更新。在支持的 IDE 中，如果应用正在运行，<strong>Save</strong> 也会执行热重载。当使用 <code>flutter run</code> 直接从控制台运行应用程序时，输入 <code>r</code> 来执行热重载。</p>
<p>观察:</p>
<ul>
<li>这个例子创建了一个 Material 应用。<a href="https://material.io/guidelines/">Material</a> 是一种视觉设计语言，是移动和 Web 的标准。Flutter 提供了一套丰富的 Material 部件。</li>
<li><code>main</code> 方法使用箭头(<code>=&gt;</code>)符号。对单行函数或方法使用箭头符号。</li>
<li>应用程序扩展了 <code>StatelessWidget</code>，这使得应用程序本身成为一个组件。在 Flutter 中，几乎所有的东西都是组件，包括对齐、填充和布局。</li>
<li><code>Scaffold</code> 组件来自 Material 库，它提供了一个默认的应用栏、一个标题和一个 body 属性，其中存放着主屏幕的组件树。组件子树可以相当复杂。</li>
<li>组件的主要工作是提供一个 <code>build</code> 方法，描述如何用其他低级组件来显示该组件。</li>
<li>本例的主体由包含 <code>Text</code> 子部件的 <code>Center</code> 部件组成。<code>Center</code> 组件将其组件子树对齐到屏幕的中心。</li>
</ul>
<h2 id="使用外部软件包">使用外部软件包</h2>
<p>在这一步中，您将开始使用一个名为 <code>english_words</code> 的开源包，它包含了几千个最常用的英语单词，还有一些实用函数。</p>
<p>你可以在 <a href="https://pub.dev/">pub.dev</a> 找到 <code>english_words</code> 包，以及许多其他开源包。</p>
<p>pubspec 文件管理着 Flutter 应用的资产。在 <code>pubspec.yaml</code> 中，附加 <code>english_words: ^3.1.5</code>(<code>english_words</code> 3.1.5 或更高)到依赖列表中。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">dependencies</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="k">flutter</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">sdk</span><span class="p">:</span><span class="w"> </span>flutter<span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="k">cupertino_icons</span><span class="p">:</span><span class="w"> </span>^<span class="m">0.1</span><span class="m">.2</span><span class="w">
</span><span class="w">  </span><span class="k">english_words</span><span class="p">:</span><span class="w"> </span>^<span class="m">3.1</span><span class="m">.5</span><span class="w">   </span><span class="c"># add this line</span><span class="w">
</span></code></pre></div><p>在 Android Studio 的编辑器视图中查看 pubspec 时，点击 <strong>Packages get</strong>。这将把包拉到你的项目中。你应该在控制台中看到以下内容。</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">flutter packages get
Running &#34;flutter packages get&#34; in startup_namer...
Process finished with exit code 0
</code></pre></div><p>执行 <code>Pub get</code> 也会自动生成 &ldquo;pubspec.lock&rdquo; 文件，其中包含所有拉入项目的包的列表和它们的版本号。</p>
<p>在 <code>lib/main.dart</code> 中，导入新包:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:flutter/material.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:english_words/english_words.dart</span><span class="s1">&#39;</span><span class="p">;</span>  <span class="c1">// Add this line.
</span></code></pre></div><p>当你输入时，Android Studio 会给你建议导入的库。然后，它将导入的字符串渲染成灰色，让你知道导入的库是未使用的（到目前为止）。</p>
<p>接下来，你将使用 <code>english_words</code> 包来生成文本，而不是使用 &ldquo;Hello World&rdquo;。</p>
<p>做以下修改。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:flutter/material.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:english_words/english_words.dart</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">runApp</span><span class="p">(</span><span class="n">MyApp</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">MyApp</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="p">{</span>
  <span class="err">@</span><span class="n">override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">final</span> <span class="n">wordPair</span> <span class="o">=</span> <span class="n">WordPair</span><span class="p">.</span><span class="n">random</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="c1">// Add this line.
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">MaterialApp</span><span class="p">(</span>
      <span class="nl">title:</span> <span class="s1">&#39;</span><span class="s1">Welcome to Flutter</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="nl">home:</span> <span class="n">Scaffold</span><span class="p">(</span>
        <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
          <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Welcome to Flutter</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">,</span>
        <span class="p">)</span><span class="p">,</span>
        <span class="nl">body:</span> <span class="n">Center</span><span class="p">(</span>
          <span class="c1">//child: Text(&#39;Hello World&#39;),   // Replace this text...
</span><span class="c1"></span>          <span class="nl">child:</span> <span class="n">Text</span><span class="p">(</span><span class="n">wordPair</span><span class="p">.</span><span class="n">asPascalCase</span><span class="p">)</span><span class="p">,</span>  <span class="c1">// With this text.
</span><span class="c1"></span>        <span class="p">)</span><span class="p">,</span>
      <span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>提示: Pascal 大小写(也称为上驼形大小写)意味着字符串中的每个单词，包括第一个单词，都以大写字母开头。所以，<code>uppercamelcase</code> 就变成了 <code>UpperCamelCase</code>。</p>
<p>如果应用程序正在运行，热重载来更新正在运行的应用程序。(在命令行中，你可以输入 <code>r</code> 来热重载。)每次点击热重载或保存项目时，你应该会在运行中的应用程序中看到一个不同的单词对，随机选择。这是因为单词对是在 <code>build</code> 方法里面生成的，每次 <code>MaterialApp</code> 需要渲染时，或者在 Flutter Inspector 中切换 <strong>Platform</strong> 时，都会运行该方法。</p>
<p>Android:</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/57cfbac8f2b50e5b.png" alt="img"></p>
<p>iOS:</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/30ed7f83a1500fa9.png" alt="img"></p>
<h3 id="有问题">有问题？</h3>
<p>如果您的应用程序没有正确运行，请查找错别字。如果需要，请使用以下链接中的代码来恢复正常。</p>
<ul>
<li><a href="https://github.com/flutter/codelabs/blob/b3293b5bb0c0187bdbe8112f7759f4d75f4c040a/startup_namer/step2_use_package/pubspec.yaml">pubspec.yaml</a></li>
<li><a href="https://github.com/flutter/codelabs/blob/b3293b5bb0c0187bdbe8112f7759f4d75f4c040a/startup_namer/step2_use_package/lib/main.dart">lib/main.dart</a></li>
</ul>
<h2 id="添加一个有状态的组件">添加一个有状态的组件</h2>
<p>无状态组件是不可改变的，这意味着它们的属性不能改变-所有值都是最终值。</p>
<p>有状态组件维护的状态可能在组件的生命周期内发生变化。实现一个有状态的组件至少需要两个类。1) 一个 <a href="https://docs.flutter.io/flutter/widgets/StatefulWidget-class.html">StatefulWidget</a>，它可以创建一个 <a href="https://docs.flutter.io/flutter/widgets/State-class.html">State</a> 类的实例。<code>StatefulWidget</code> 对象本身是不可变的，可以被丢弃和再生，但 <code>State</code> 对象会在 widget 的生命周期内持久存在。</p>
<p>在这一步骤中，您将添加一个有状态的组件 <code>RandomWords</code>，并创建其 <code>State</code> 类 <code>_RandomWordsState</code>。然后，您将在现有的 MyApp 无状态组件中使用 <code>RandomWords</code> 作为子类。</p>
<p>为有状态组件创建模板代码。</p>
<p>它可以放在 <code>MyApp</code> 以外的文件中的任何位置，但解决方案将其放在文件的底部。在 <code>lib/main.dart</code> 中，将光标定位在所有代码之后，输入回车键几次，重新开始一行。在你的 IDE 中，开始输入 <code>stful</code>。编辑器会询问你是否要创建一个 <code>Stateful</code> 的组件。按回车键接受。两个类的模板代码出现了，光标定位让你输入无状态组件的名称。</p>
<p>输入 <code>RandomWords</code> 作为您的小组件的名称。</p>
<p>正如您在下面的代码中所看到的，<code>RandomWords</code> 组件除了创建它的 <code>State</code> 类之外，几乎没有其他的功能。</p>
<p>一旦您输入 <code>RandomWords</code> 作为有状态组件的名称，IDE 会自动更新相应的 <code>State</code> 类，将其命名为 <code>_RandomWordState</code>。默认情况下，<code>State</code> 类的名称是以下划线为前缀的。在标识符前加上下划线可以加强 Dart 语言的<a href="https://dart.dev/guides/language/language-tour#libraries-and-visibility">隐私性</a>，也是 <code>State</code> 对象的最佳实践。</p>
<p>IDE 也会自动更新 State 类以扩展 <code>State&lt;RandomWords&gt;</code>，表明你正在使用一个专门用于 <code>RandomWords</code> 的通用 <a href="https://api.flutter.dev/flutter/widgets/State-class.html">State</a> 类。应用程序的大部分逻辑都在这里-它为 <code>RandomWords</code> 组件维护状态。这个类保存了生成的词对列表，随着用户的滚动而无限增长，在本实验室的第二部分中，当用户通过切换心形图标从列表中添加或删除这些词对时，该类会对其进行收藏。</p>
<p>现在两个类的外观如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">RandomWords</span> <span class="kd">extends</span> <span class="n">StatefulWidget</span> <span class="p">{</span>
  <span class="err">@</span><span class="n">override</span>
  <span class="n">_RandomWordsState</span> <span class="n">createState</span><span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">_RandomWordsState</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">_RandomWordsState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">RandomWords</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="err">@</span><span class="n">override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Container</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>更新 <code>_RandomWordsState</code> 中的 <code>build()</code> 方法。</p>
<p>用以下两行替换 <code>return Container();</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">_RandomWordsState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">RandomWords</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="err">@</span><span class="n">override</span>                                  
  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">final</span> <span class="n">wordPair</span> <span class="o">=</span> <span class="n">WordPair</span><span class="p">.</span><span class="n">random</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>      <span class="c1">// NEW
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">Text</span><span class="p">(</span><span class="n">wordPair</span><span class="p">.</span><span class="n">asPascalCase</span><span class="p">)</span><span class="p">;</span>      <span class="c1">// NEW
</span><span class="c1"></span>  <span class="p">}</span>                                         
<span class="p">}</span>
</code></pre></div><p>通过以下修改，删除 <code>MyApp</code> 中的文字生成代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyApp</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="p">{</span>
  <span class="err">@</span><span class="n">override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">final</span> <span class="n">wordPair</span> <span class="o">=</span> <span class="n">WordPair</span><span class="p">.</span><span class="n">random</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>  <span class="c1">// DELETE
</span><span class="c1"></span>
    <span class="k">return</span> <span class="n">MaterialApp</span><span class="p">(</span>
      <span class="nl">title:</span> <span class="s1">&#39;</span><span class="s1">Welcome to Flutter</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="nl">home:</span> <span class="n">Scaffold</span><span class="p">(</span>
        <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
          <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Welcome to Flutter</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">,</span>
        <span class="p">)</span><span class="p">,</span>
        <span class="nl">body:</span> <span class="n">Center</span><span class="p">(</span>
          <span class="c1">//child: Text(wordPair.asPascalCase), // REPLACE with... 
</span><span class="c1"></span>          <span class="nl">child:</span> <span class="n">RandomWords</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>                 <span class="c1">// ...this line
</span><span class="c1"></span>        <span class="p">)</span><span class="p">,</span>
      <span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>热重载应用程序。应用程序应该像以前一样，每次热重载或保存应用程序时都会显示一个单词配对。</p>
<p>提示：如果您在热重载时看到警告，表明您可能需要重新启动应用程序，您应该考虑重新启动应用程序。这可能是一个假阳性，但重启可以确保您的更改反映在应用程序的 UI 中。</p>
<h3 id="遇到问题了">遇到问题了？</h3>
<p>如果您的应用程序没有正确运行，您可以使用以下链接中的代码来恢复正常。</p>
<ul>
<li><a href="https://github.com/flutter/codelabs/blob/b3293b5bb0c0187bdbe8112f7759f4d75f4c040a/startup_namer/step3_stateful_widget/lib/main.dart">lib/main.dart</a></li>
</ul>
<h2 id="创建一个无限滚动的-listview">创建一个无限滚动的 ListView</h2>
<p>在这一步中，您将展开 <code>_RandomWordsState</code> 来生成并显示单词配对列表。随着用户的滚动，列表（显示在 ListView 小组件中）会无限增长。ListView 中的构建器工厂构造函数允许你按需懒惰地构建一个列表视图。</p>
<p>在 <code>_RandomWordState</code> 类中添加一些状态变量。</p>
<p>增加一个 <code>_suggestions</code> 列表，用于保存建议的单词配对。另外，添加一个 <code>_biggerFont</code> 变量，用于使字体大小变大。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">_RandomWordsState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">RandomWords</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">WordPair</span><span class="o">&gt;</span> <span class="n">_suggestions</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">WordPair</span><span class="o">&gt;</span><span class="p">[</span><span class="p">]</span><span class="p">;</span>            <span class="c1">// NEW
</span><span class="c1"></span>  <span class="kd">final</span> <span class="n">TextStyle</span> <span class="n">_biggerFont</span> <span class="o">=</span> <span class="kd">const</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">fontSize:</span> <span class="m">18</span><span class="p">)</span><span class="p">;</span> <span class="c1">// NEW
</span><span class="c1"></span>  <span class="p">.</span><span class="p">.</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div><p>接下来，你将在 <code>_RandomWordsState</code> 类中添加一个 <code>_buildSuggestions()</code> 函数。这个方法可以构建显示建议词对的 <code>ListView</code>。</p>
<p><code>ListView</code> 类提供了一个构建器属性 <code>itemBuilder</code>，它是一个工厂构建器和回调函数，指定为一个匿名函数。两个参数被传递给函数&ndash;<code>BuildContext</code> 和行迭代器 <code>i</code>。迭代器从0开始，每次调用函数时递增，每一个建议的单词配对都会递增一次。这个模型允许建议列表在用户滚动时继续增长。</p>
<p>添加整个 <code>_buildSuggestions</code> 函数。</p>
<p>在 <code>_RandomWordsState</code> 类中，添加以下函数，如果你喜欢，请删除注释:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Widget</span> <span class="n">_buildSuggestions</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ListView</span><span class="p">.</span><span class="n">builder</span><span class="p">(</span>
      <span class="nl">padding:</span> <span class="kd">const</span> <span class="n">EdgeInsets</span><span class="p">.</span><span class="n">all</span><span class="p">(</span><span class="m">16</span><span class="p">)</span><span class="p">,</span>
      <span class="c1">// The itemBuilder callback is called once per suggested 
</span><span class="c1"></span>      <span class="c1">// word pairing, and places each suggestion into a ListTile
</span><span class="c1"></span>      <span class="c1">// row. For even rows, the function adds a ListTile row for
</span><span class="c1"></span>      <span class="c1">// the word pairing. For odd rows, the function adds a 
</span><span class="c1"></span>      <span class="c1">// Divider widget to visually separate the entries. Note that
</span><span class="c1"></span>      <span class="c1">// the divider may be difficult to see on smaller devices.
</span><span class="c1"></span>      <span class="nl">itemBuilder:</span> <span class="p">(</span><span class="n">BuildContext</span> <span class="n">_context</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Add a one-pixel-high divider widget before each row 
</span><span class="c1"></span>        <span class="c1">// in the ListView.
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">isOdd</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="n">Divider</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// The syntax &#34;i ~/ 2&#34; divides i by 2 and returns an 
</span><span class="c1"></span>        <span class="c1">// integer result.
</span><span class="c1"></span>        <span class="c1">// For example: 1, 2, 3, 4, 5 becomes 0, 1, 1, 2, 2.
</span><span class="c1"></span>        <span class="c1">// This calculates the actual number of word pairings 
</span><span class="c1"></span>        <span class="c1">// in the ListView,minus the divider widgets.
</span><span class="c1"></span>        <span class="kd">final</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">~</span><span class="o">/</span> <span class="m">2</span><span class="p">;</span>
        <span class="c1">// If you&#39;ve reached the end of the available word
</span><span class="c1"></span>        <span class="c1">// pairings...
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span><span class="o">=</span> <span class="n">_suggestions</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// ...then generate 10 more and add them to the 
</span><span class="c1"></span>          <span class="c1">// suggestions list.
</span><span class="c1"></span>          <span class="n">_suggestions</span><span class="p">.</span><span class="n">addAll</span><span class="p">(</span><span class="n">generateWordPairs</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">_buildRow</span><span class="p">(</span><span class="n">_suggestions</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div><p><code>_buildSuggestions</code> 函数对每个词对调用一次 <code>_buildRow</code>。该函数在 <code>ListTile</code> 中显示每一个新的词对，这使得你可以在<a href="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/index.html?index=..%2F..index#0">第2部分</a>中使行更有吸引力。</p>
<p>在 <code>_RandomWordsState</code> 中添加一个 <code>_buildRow</code> 函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Widget</span> <span class="n">_buildRow</span><span class="p">(</span><span class="n">WordPair</span> <span class="n">pair</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ListTile</span><span class="p">(</span>
      <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span>
        <span class="n">pair</span><span class="p">.</span><span class="n">asPascalCase</span><span class="p">,</span>
        <span class="nl">style:</span> <span class="n">_biggerFont</span><span class="p">,</span>
      <span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div><p>更新 <code>_RandomWordsState</code> 的构建方法。</p>
<p>将其改为使用 <code>_buildSuggestions()</code>，而不是直接调用单词生成库。(<code>Scaffold</code> 实现了基本的 Material Design 视觉布局。)</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="err">@</span><span class="n">override</span>
<span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//final wordPair = WordPair.random(); // Delete these... 
</span><span class="c1"></span>    <span class="c1">//return Text(wordPair.asPascalCase); // ... two lines.
</span><span class="c1"></span>
    <span class="k">return</span> <span class="n">Scaffold</span> <span class="p">(</span>                     <span class="c1">// Add from here... 
</span><span class="c1"></span>      <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
        <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Startup Name Generator</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">,</span>
      <span class="p">)</span><span class="p">,</span>
      <span class="nl">body:</span> <span class="n">_buildSuggestions</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>                                      <span class="c1">// ... to here.
</span><span class="c1"></span>  <span class="p">}</span>
</code></pre></div><p>更新 <code>MyApp</code> 的构建方法，更改标题，删除 <code>AppBar</code>，并将 home 属性改为 <code>RandomWords</code> 部件。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="err">@</span><span class="n">override</span>
<span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MaterialApp</span><span class="p">(</span>
      <span class="nl">title:</span> <span class="s1">&#39;</span><span class="s1">Startup Name Generator</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="nl">home:</span> <span class="n">RandomWords</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div><p>重新启动应用程序。无论你滚动多远，你都应该看到一个单词配对的列表。</p>
<p>Android:</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/df2b3cb779e0020e.png" alt="img"></p>
<p>iOS:</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/ae47ef0ac2f492b8.png" alt="img"></p>
<h3 id="遇到问题了-1">遇到问题了？</h3>
<p>如果你的应用程序不能正常运行，你可以使用下面链接中的代码来回到正轨。</p>
<ul>
<li><a href="https://github.com/flutter/codelabs/blob/b3293b5bb0c0187bdbe8112f7759f4d75f4c040a/startup_namer/step4_infinite_list/lib/main.dart">lib/main.dart</a></li>
</ul>
<h2 id="今后的步骤">今后的步骤</h2>
<p><strong>恭喜你！</strong></p>
<p>你已经完成了这个代码实验室的第一部分! 如果你想扩展这款应用，请进入<a href="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/#0">第二部分</a>，你将对应用进行如下修改。</p>
<ul>
<li>增加互动性</li>
<li>增加导航到新路由的功能。</li>
<li>修改主题颜色。</li>
</ul>
<p>当第2部分完成后，应用程序将是这样的：</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/7fcab088cd22cff7.gif" alt="img"></p>
<h3 id="其他后续步骤">其他后续步骤</h3>
<p>通过以下资源了解更多关于 Flutter SDK 的信息。</p>
<ul>
<li><a href="https://flutter.dev/docs/development/ui/layout">Flutter 中的布局</a></li>
<li><a href="https://flutter.dev/docs/development/ui/interactive">增加互动性教程</a></li>
<li><a href="https://flutter.dev/docs/development/ui/widgets-intro">组件介绍</a></li>
<li><a href="https://flutter.dev/docs/get-started/flutter-for/android-devs">为 Android 开发者提供的 Flutter</a></li>
<li><a href="https://flutter.dev/docs/get-started/flutter-for/react-native-devs">针对 React Native 开发者的 Flutter</a></li>
<li><a href="https://flutter.dev/docs/get-started/flutter-for/web-devs">Web 开发人员的 Flutter</a></li>
<li><a href="https://www.youtube.com/flutterdev">Flutter YouTube 频道</a></li>
</ul>
<p>其他资源包括以下几点:</p>
<ul>
<li><a href="https://www.udacity.com/course/build-native-mobile-apps-with-flutter--ud905">用 Flutter 构建本地移动应用</a></li>
<li><a href="https://codelabs.developers.google.com/codelabs/from-java-to-dart/#1">从 Java 到 Dart codelab</a></li>
<li><a href="https://flutter.dev/cookbook/">Flutter cookbook</a></li>
<li><a href="https://flutter.dev/bootstrap-into-dart/">融入 Dart 的 Bootstrap：了解更多关于这门语言的信息</a></li>
</ul>
<p>同时，<a href="https://flutter.dev/community">与 Flutter 社区联系起来!</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flutter" term="flutter" label="flutter" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/app" term="app" label="app" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[编写你的第一个 Flutter 应用，第二部分]]></title>
            <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app-part-two/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第一部分" />
            
                <id>https://ohmyweekly.github.io/notes/write-your-first-flutter-app-part-two/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-26T00:00:00+08:00</published>
            <updated>2020-06-26T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Flutter 是 Google 的 UI 工具包，用于从单一代码库中为手机、网页和桌面构建漂亮的、原生编译的应用程序。Flutter 可以与现有的代码一起使用，被世界各地的开发者和组织使用，并且是免费和开源的。</blockquote><h2 id="介绍">介绍</h2>
<p>Flutter 是 Google 的 UI 工具包，用于从单一代码库中为移动、Web 和桌面构建漂亮的、原生编译的应用程序。Flutter 可以与现有的代码一起工作，被世界各地的开发者和组织使用，并且是免费和开源的。</p>
<p>在这个代码实验室中，您将扩展一个基本的、移动的 Flutter 应用程序，以包含交互性。您还将创建一个用户可以导航到的第二个页面（称为路由）。最后，您将修改应用程序的主题（颜色）。这个代码实验室扩展了第1部分，在这部分中，你将<a href="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/">创建一个无限的懒惰加载的列表</a>，但如果你想从第2部分开始，我们将提供起始代码。</p>
<h3 id="你将在第二部分学到什么">你将在第二部分学到什么</h3>
<ul>
<li>如何编写一款在 iOS、Android 和 Web 上看起来很自然的 Flutter 应用？</li>
<li>如何使用热重装，加快开发周期？</li>
<li>如何为有状态的 widget 添加交互性？</li>
<li>如何创建并导航到第二个屏幕？</li>
<li>如何使用主题来改变应用程序的外观？</li>
</ul>
<h3 id="你将在第二部分建立什么">你将在第二部分建立什么</h3>
<p>您将从一个简单的移动应用程序开始，为创业公司生成一个无尽的建议名称列表。在代码实验室结束时，您的最终用户可以选择和取消选择名称，保存最好的名称。点击应用栏右上角的列表图标可以导航到一个新的页面（称为路由），该页面只列出了最喜欢的名字。</p>
<p>下面的 GIF 动画显示了完成的应用程序将如何工作。</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/7fcab088cd22cff7.gif" alt="img"></p>
<h2 id="设置您的-flutter-环境">设置您的 Flutter 环境</h2>
<p>如果你还没有完成第1部分，请看<a href="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/#1">设置你的 Flutter 环境</a>，在<a href="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/">编写你的第一个Flutter应用，第1部分</a>，设置你的 Flutter 开发环境。</p>
<h2 id="获取启动应用程序">获取启动应用程序</h2>
<p>如果你已经完成了这个 codelab 的第一部分，你已经有了启动应用程序，<code>startup_namer</code>。你可以进行下一步。</p>
<p>如果你没有 <code>startup_namer</code>，不要害怕，你可以使用下面的说明得到它。</p>
<p>使用<a href="https://flutter.dev/get-started/test-drive/#create-app">创建应用程序</a>中的说明创建一个简单的模板化 Flutter 应用程序。将项目命名为 <code>startup_namer</code>（而不是 <code>flutter_app</code>）。</p>
<p>删除 <code>lib/main.dart</code> 中的所有代码。用这个<a href="https://github.com/flutter/codelabs/blob/b3293b5bb0c0187bdbe8112f7759f4d75f4c040a/startup_namer/step4_infinite_list/lib/main.dart">文件</a>中的代码替换，它显示了一个无限的，懒惰加载的建议启动名称列表。</p>
<p>更新 <code>pubspec.yaml</code>，加入英文单词包。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">dependencies</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="k">flutter</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">sdk</span><span class="p">:</span><span class="w"> </span>flutter<span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="k">cupertino_icons</span><span class="p">:</span><span class="w"> </span>^<span class="m">0.1</span><span class="m">.2</span><span class="w">
</span><span class="w">  </span><span class="k">english_words</span><span class="p">:</span><span class="w"> </span>^<span class="m">3.1</span><span class="m">.5</span><span class="w">    </span>//<span class="w"> </span>NEW<span class="w">
</span></code></pre></div><p>英文单词包会生成一对随机的单词，作为潜在的启动名称。</p>
<p>在 Android Studio 的编辑器视图中查看 pubspec 时，点击右上角的 <strong>Pub get</strong>，这将包拉到你的项目中。你应该在控制台中看到以下内容:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">flutter pub get
Running <span class="s2">&#34;flutter pub get&#34;</span> in startup_namer...
Process finished with <span class="nb">exit</span> code <span class="m">0</span>
</code></pre></div><p>运行该应用。</p>
<p>随意滚动，查看持续供应的拟创业公司名称。</p>
<h2 id="将图标添加到列表中">将图标添加到列表中</h2>
<p>在这一步中，你将为每一行添加心形图标。在下一步中，您将使它们可点击并保存收藏夹。</p>
<p>在 <code>_RandomWordsState</code> 中添加一个 <code>_saved</code> Set。这个 <code>Set</code> 存储了用户收藏的单词配对。<code>Set</code> 比 <code>List</code> 更受欢迎，因为一个正确实现的 <code>Set</code> 不允许重复的条目。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">_RandomWordsState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">RandomWords</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">_suggestions</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">WordPair</span><span class="o">&gt;</span><span class="p">[</span><span class="p">]</span><span class="p">;</span>
  <span class="kd">final</span> <span class="n">_saved</span> <span class="o">=</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">WordPair</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>     <span class="c1">// NEW
</span><span class="c1"></span>  <span class="kd">final</span> <span class="n">_biggerFont</span> <span class="o">=</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">fontSize:</span> <span class="m">18.0</span><span class="p">)</span><span class="p">;</span>
  <span class="p">.</span><span class="p">.</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div><p>在 <code>_buildRow</code> 函数中，添加一个 <code>alreadySaved</code> 检查，以确保一个单词配对还没有被添加到收藏夹中。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Widget</span> <span class="n">_buildRow</span><span class="p">(</span><span class="n">WordPair</span> <span class="n">pair</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">alreadySaved</span> <span class="o">=</span> <span class="n">_saved</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span><span class="p">;</span>  <span class="c1">// NEW
</span><span class="c1"></span>  <span class="p">.</span><span class="p">.</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div><p>在 <code>_buildRow()</code> 中，你还将为 <code>ListTile</code> 对象添加心形图标以实现收藏夹。在下一步中，你将添加与心形图标交互的功能。</p>
<p>在文本之后添加图标，如下图所示。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Widget</span> <span class="n">_buildRow</span><span class="p">(</span><span class="n">WordPair</span> <span class="n">pair</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">alreadySaved</span> <span class="o">=</span> <span class="n">_saved</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">ListTile</span><span class="p">(</span>
    <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span>
      <span class="n">pair</span><span class="p">.</span><span class="n">asPascalCase</span><span class="p">,</span>
      <span class="nl">style:</span> <span class="n">_biggerFont</span><span class="p">,</span>
    <span class="p">)</span><span class="p">,</span>
    <span class="nl">trailing:</span> <span class="n">Icon</span><span class="p">(</span>   <span class="c1">// NEW from here... 
</span><span class="c1"></span>      <span class="n">alreadySaved</span> <span class="o">?</span> <span class="n">Icons</span><span class="p">.</span><span class="n">favorite</span> <span class="o">:</span> <span class="n">Icons</span><span class="p">.</span><span class="n">favorite_border</span><span class="p">,</span>
      <span class="nl">color:</span> <span class="n">alreadySaved</span> <span class="o">?</span> <span class="n">Colors</span><span class="p">.</span><span class="n">red</span> <span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="p">)</span><span class="p">,</span>                <span class="c1">// ... to here.
</span><span class="c1"></span>  <span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>热重新加载应用程序。</p>
<p>你现在应该看到每一行都有空心，但它们还没有互动。</p>
<p>Android</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/819e2ff89da9421a.png" alt="img"></p>
<p>iOS</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/4df48933551e7c48.png" alt="img"></p>
<h3 id="遇到问题了">遇到问题了？</h3>
<p>如果你的应用程序不能正常运行，你可以使用下面链接中的代码来回到正轨。</p>
<ul>
<li><a href="https://github.com/flutter/codelabs/blob/master/startup_namer/step5_add_icons/lib/main.dart">lib/main.dart</a></li>
</ul>
<h2 id="增加互动性">增加互动性</h2>
<p>在这一步中，你将使心形图标可以点击。当用户点击列表中的一个条目，切换其收藏状态时，该词对就会从一组保存的收藏夹中添加或删除。</p>
<p>要做到这一点，你将修改 <code>_buildRow</code> 函数。如果一个词条已经被添加到收藏夹中，再次点击它就会将其从收藏夹中删除。当一个磁贴被点击后，函数会调用 <code>setState()</code> 来通知框架状态已经改变。</p>
<p>在 <code>_buildRow</code> 方法中加入 <code>onTap</code>，如下图所示:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Widget</span> <span class="n">_buildRow</span><span class="p">(</span><span class="n">WordPair</span> <span class="n">pair</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">alreadySaved</span> <span class="o">=</span> <span class="n">_saved</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">ListTile</span><span class="p">(</span>
    <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span>
      <span class="n">pair</span><span class="p">.</span><span class="n">asPascalCase</span><span class="p">,</span>
      <span class="nl">style:</span> <span class="n">_biggerFont</span><span class="p">,</span>
    <span class="p">)</span><span class="p">,</span>
    <span class="nl">trailing:</span> <span class="n">Icon</span><span class="p">(</span>
      <span class="n">alreadySaved</span> <span class="o">?</span> <span class="n">Icons</span><span class="p">.</span><span class="n">favorite</span> <span class="o">:</span> <span class="n">Icons</span><span class="p">.</span><span class="n">favorite_border</span><span class="p">,</span>
      <span class="nl">color:</span> <span class="n">alreadySaved</span> <span class="o">?</span> <span class="n">Colors</span><span class="p">.</span><span class="n">red</span> <span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="p">)</span><span class="p">,</span>
    <span class="nl">onTap:</span> <span class="p">(</span><span class="p">)</span> <span class="p">{</span>      <span class="c1">// NEW lines from here...
</span><span class="c1"></span>      <span class="n">setState</span><span class="p">(</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">alreadySaved</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">_saved</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> 
          <span class="n">_saved</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span><span class="p">;</span> 
        <span class="p">}</span> 
      <span class="p">}</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span><span class="p">,</span>               <span class="c1">// ... to here.
</span><span class="c1"></span>  <span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>提示：在 Flutter 的反应式框架中，调用 <code>setState()</code> 会触发对 <code>State</code> 对象的 <code>build()</code> 方法的调用，导致 UI 的更新。</p>
<p>热重载应用。</p>
<p>你应该能够点击任何磁贴来收藏或不收藏该条目。点击瓷砖会产生一个隐含的从点击点发出的泼墨动画。</p>
<p>Android</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/43dfc7ba5f728e8f.png" alt="img"></p>
<p>iOS</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/e7a99a1b94bea7d4.png" alt="img"></p>
<h3 id="遇到问题了-1">遇到问题了？</h3>
<p>如果你的应用程序不能正常运行，你可以使用下面链接中的代码来回到正轨。</p>
<ul>
<li><a href="https://github.com/flutter/codelabs/blob/master/startup_namer/step6_add_interactivity/lib/main.dart">lib/main.dart</a></li>
</ul>
<h2 id="导航到一个新的屏幕">导航到一个新的屏幕</h2>
<p>在这一步中，您将添加一个新的页面（在 Flutter 中称为路由），显示收藏夹。您将学习如何在主页路线和新路由之间进行导航。</p>
<p>在 Flutter 中，<code>Navigator</code> 管理着一个包含应用程序路由的堆栈。将一个路由推到 <code>Navigator</code> 的堆栈上，会将显示更新到该路由。从 <code>Navigator</code> 的堆栈中弹出一条路由，会将显示返回到之前的路由。</p>
<p>接下来，您将在 <code>_RandomWordsState</code> 的 <code>build</code> 方法中为 <code>AppBar</code> 添加一个列表图标。当用户点击列表图标时，一个包含保存的收藏夹的新路由会被推送到 <code>Navigator</code>，显示图标。</p>
<p>在 <code>build</code> 方法中添加图标及其对应的操作:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">_RandomWordsState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">RandomWords</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="p">.</span><span class="p">.</span><span class="p">.</span>
  <span class="err">@</span><span class="n">override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Scaffold</span><span class="p">(</span>
      <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
        <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Startup Name Generator</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">,</span>
        <span class="nl">actions:</span> <span class="p">[</span>              <span class="c1">// NEW lines from here...
</span><span class="c1"></span>          <span class="n">IconButton</span><span class="p">(</span><span class="nl">icon:</span> <span class="n">Icon</span><span class="p">(</span><span class="n">Icons</span><span class="p">.</span><span class="n">list</span><span class="p">)</span><span class="p">,</span> <span class="nl">onPressed:</span> <span class="n">_pushSaved</span><span class="p">)</span><span class="p">,</span>
        <span class="p">]</span><span class="p">,</span>                      <span class="c1">// ... to here.
</span><span class="c1"></span>      <span class="p">)</span><span class="p">,</span>
      <span class="nl">home:</span> <span class="n">RandomWords</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">.</span><span class="p">.</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div><p>提示：一些小组件属性会取一个小组件(<code>child</code>)，而其他属性，如 <code>action</code>，会取一组小组件(<code>children</code>), 如方括号(<code>[]</code>)所示。</p>
<p>在 <code>_RandomWordsState</code> 类中添加一个 <code>_pushSaved()</code> 函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">_pushSaved</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div><p>热重新加载应用程序。<a href="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/a114478ae13b853.png">列表图标</a>出现在应用栏中。点击它还没有任何作用，因为 <code>_pushSaved</code> 函数是空的。</p>
<p>接下来，你将建立一条路由，并将其推送到 <code>Navigator</code> 的栈中。这个操作会改变屏幕以显示新的路由。新页面的内容是在 <code>MaterialPageRoute</code> 的构建器属性中以匿名函数的方式构建的。</p>
<p>调用 <code>Navigator.push</code>，如下图所示，它将路由推送到 <code>Navigator</code> 的堆栈中。IDE 会抱怨无效代码，但你会在下一节中解决这个问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">_pushSaved</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Navigator</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="n">context</span><span class="p">)</span><span class="p">.</span><span class="n">push</span><span class="p">(</span>
  <span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>接下来，你将添加 <code>MaterialPageRoute</code> 和它的构建器。现在，添加生成 <code>ListTile</code> 行的代码。<code>ListTile</code> 的 <code>divideTiles()</code> 方法在每个 <code>ListTile</code> 之间增加了水平间距。被划分的变量持有通过方便函数 <code>toList()</code> 转换为列表的最终行。</p>
<p>添加代码，如下面的代码片段所示:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">_pushSaved</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Navigator</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="n">context</span><span class="p">)</span><span class="p">.</span><span class="n">push</span><span class="p">(</span>
      <span class="n">MaterialPageRoute</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="c1">// NEW lines from here...
</span><span class="c1"></span>        <span class="nl">builder:</span> <span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">final</span> <span class="n">tiles</span> <span class="o">=</span> <span class="n">_saved</span><span class="p">.</span><span class="n">map</span><span class="p">(</span>
            <span class="p">(</span><span class="n">WordPair</span> <span class="n">pair</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="n">ListTile</span><span class="p">(</span>
                <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span>
                  <span class="n">pair</span><span class="p">.</span><span class="n">asPascalCase</span><span class="p">,</span>
                  <span class="nl">style:</span> <span class="n">_biggerFont</span><span class="p">,</span>
                <span class="p">)</span><span class="p">,</span>
              <span class="p">)</span><span class="p">;</span>
            <span class="p">}</span><span class="p">,</span>
          <span class="p">)</span><span class="p">;</span>
          <span class="kd">final</span> <span class="n">divided</span> <span class="o">=</span> <span class="n">ListTile</span><span class="p">.</span><span class="n">divideTiles</span><span class="p">(</span>
            <span class="nl">context:</span> <span class="n">context</span><span class="p">,</span>
            <span class="nl">tiles:</span> <span class="n">tiles</span><span class="p">,</span>
          <span class="p">)</span><span class="p">.</span><span class="n">toList</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

          <span class="k">return</span> <span class="n">Scaffold</span><span class="p">(</span>
            <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
              <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Saved Suggestions</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">,</span>
            <span class="p">)</span><span class="p">,</span>
            <span class="nl">body:</span> <span class="n">ListView</span><span class="p">(</span><span class="nl">children:</span> <span class="n">divided</span><span class="p">)</span><span class="p">,</span>
          <span class="p">)</span><span class="p">;</span>
        <span class="p">}</span><span class="p">,</span> <span class="c1">// ...to here.
</span><span class="c1"></span>      <span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>builder</code> 属性返回一个 <code>Scaffold</code>，包含名为 <code>SavedSuggestions</code> 的新路由的应用栏。新路由的主体由一个包含 <code>ListTiles</code> 行的 <code>ListView</code> 组成。每一行都由一个分隔符隔开。</p>
<p>热重载应用。将一些选择收藏起来，然后点击应用栏中的列表图标。新的路由出现，包含收藏夹。请注意，Navigator 在应用栏中增加了一个&quot;返回&quot;按钮。你不必明确地实现 <code>Navigator.pop</code>。点击&quot;返回&quot;按钮就可以返回到主路由。</p>
<p>iOS - Main route</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/928693968b8e482a.png" alt="img"></p>
<p>iOS - Saved suggestions route</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/2245376356747d5a.png" alt="img"></p>
<h3 id="遇到问题了-2">遇到问题了？</h3>
<p>如果你的应用程序没有正确运行，那么你可以使用下面链接中的代码来回到正轨。</p>
<ul>
<li><a href="https://github.com/flutter/codelabs/blob/master/startup_namer/step7_navigate_route/lib/main.dart">lib/main.dart</a></li>
</ul>
<h2 id="使用主题改变用户界面">使用主题改变用户界面</h2>
<p>在这一步中，您将修改应用程序的主题。主题控制你的应用程序的外观和感觉。您可以使用默认主题，这取决于物理设备或模拟器，或者自定义主题以反映您的品牌。</p>
<p>您可以通过配置 <a href="https://docs.flutter.io/flutter/material/ThemeData-class.html">ThemeData</a> 类轻松更改应用程序的主题。应用程序使用默认主题，但你会将应用程序的主色调改为白色。</p>
<p>在 <code>MyApp</code> 类中更改颜色:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyApp</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="p">{</span>
  <span class="err">@</span><span class="n">override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MaterialApp</span><span class="p">(</span>
      <span class="nl">title:</span> <span class="s1">&#39;</span><span class="s1">Startup Name Generator</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="nl">theme:</span> <span class="n">ThemeData</span><span class="p">(</span>          <span class="c1">// Add the 3 lines from here... 
</span><span class="c1"></span>        <span class="nl">primaryColor:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">white</span><span class="p">,</span>
      <span class="p">)</span><span class="p">,</span>                         <span class="c1">// ... to here.
</span><span class="c1"></span>      <span class="nl">home:</span> <span class="n">RandomWords</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>热重载应用。现在整个背景都是白色的，甚至应用栏也是白色的。</p>
<p>作为一个练习，使用 <code>ThemeData</code> 来改变 UI 的其他方面。Material 库中的 <a href="https://docs.flutter.io/flutter/material/Colors-class.html">Colors</a> 类提供了许多你可以玩的颜色常量。热重载使得对 UI 的实验变得快速而简单。</p>
<p>Android</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/5d4ed8aeea9e4d0a.png" alt="img"></p>
<p>iOS</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/c325151f1ae4820d.png" alt="img"></p>
<h3 id="遇到问题了-3">遇到问题了？</h3>
<p>如果你已经偏离了轨道，那么使用下面链接中的代码来查看最终应用的代码。</p>
<p>= <a href="https://github.com/flutter/codelabs/blob/master/startup_namer/step8_themes/lib/main.darts">lib/main.dart</a></p>
<h2 id="做得很好">做得很好！</h2>
<p>你写了一个交互式的 Flutter 应用，可以在 iOS 和 Android 上运行，具体做法如下</p>
<ul>
<li>编写 Dart 代码。</li>
<li>使用热重载来加快开发周期。</li>
<li>实现一个有状态的 widget，为你的应用添加交互性。</li>
<li>创建途径并添加在原途径和新途径之间移动的逻辑。</li>
<li>学习如何使用主题改变你的应用程序的 UI 外观。</li>
</ul>
<h2 id="今后的步骤">今后的步骤</h2>
<p>从以下资源中了解更多关于 Flutter SDK 的信息。</p>
<ul>
<li><a href="https://flutter.dev/docs/development/ui/layout">Flutter 中的布局</a></li>
<li><a href="https://flutter.dev/docs/development/ui/interactive">增加互动性教程</a></li>
<li><a href="https://flutter.dev/docs/development/ui/widgets-intro">组件介绍</a></li>
<li><a href="https://flutter.dev/docs/get-started/flutter-for/android-devs">为 Android 开发者提供的 Flutter</a></li>
<li><a href="https://flutter.dev/docs/get-started/flutter-for/react-native-devs">针对 React Native 开发者的 Flutter</a></li>
<li><a href="https://flutter.dev/docs/get-started/flutter-for/web-devs">Web 开发人员的 Flutter</a></li>
<li><a href="https://www.youtube.com/flutterdev">Flutter YouTube 频道</a></li>
</ul>
<p>其他资源包括以下几点:</p>
<ul>
<li><a href="https://www.udacity.com/course/build-native-mobile-apps-with-flutter--ud905">用 Flutter 构建本地移动应用</a></li>
<li><a href="https://codelabs.developers.google.com/codelabs/from-java-to-dart/#1">从 Java 到 Dart codelab</a></li>
<li><a href="https://flutter.dev/cookbook/">Flutter cookbook</a></li>
<li><a href="https://flutter.dev/bootstrap-into-dart/">融入 Dart 的 Bootstrap：了解更多关于这门语言的信息</a></li>
</ul>
<p>同时，<a href="https://flutter.dev/community">与 Flutter 社区联系起来!</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flutter" term="flutter" label="flutter" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/app" term="app" label="app" />
                            
                        
                    
                
            
        </entry>
    
</feed>
