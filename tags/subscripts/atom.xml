<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.85.0">Hugo</generator><title type="html"><![CDATA[subscripts on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/subscripts/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/subscripts/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/subscripts/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/subscripts/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2021-07-15T22:25:29+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/subscripts/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 Subscripts]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-06-01-accessing-data-structure-elements-by-index-or-key/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2016-06-01-accessing-data-structure-elements-by-index-or-key/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-13T00:00:00+08:00</published>
            <updated>2021-07-13T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Accessing Data Structure Elements by Index or Key</blockquote><h1 id="subscriptshttpsdocsrakuorglanguagesubscripts"><a href="https://docs.raku.org/language/subscripts">Subscripts</a></h1>
<p>通过索引或键访问数据结构中的元素。</p>
<p>通常, 人们需要引用集合或数据结构中的一个特定的元素(或特定的元素切片)。从数学标记法中偷学到的, 向量 <code>v</code> 的组成部分用 <em>v₁, v₂, v₃</em> 来引用, 在 Raku 中这个概念叫做 “下标” (或“索引”)。</p>
<h1 id="basics">Basics</h1>
<p>Raku 提供了两个通用的下标接口：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">elements are identified by</th>
<th style="text-align:left">interface name</th>
<th style="text-align:left">supported by</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[ ]</td>
<td style="text-align:left">zero-based indices</td>
<td style="text-align:left">Positional</td>
<td style="text-align:left">Array, List, Buf, Match, &hellip;</td>
</tr>
<tr>
<td style="text-align:left">{ }</td>
<td style="text-align:left">string or object keys</td>
<td style="text-align:left">Associative</td>
<td style="text-align:left">Hash, Bag, Mix, Match, &hellip;</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Positional</strong> 下标 (通过 <a href="http://doc.raku.org/language/operators#postcircumfix_%5B_%5D">postcircumfix <input disabled="" type="checkbox"> </a> 通过元素在有序集合中的位置来寻址元素。)索引 0 引用第一个元素, 索引 1 引用第二个元素, 以此类推：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@chores</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">buy groceries</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">feed dog</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">wash car</span><span class="p">&#34;;</span>

<span class="nb">say</span> <span class="nv">@chores</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># buy groceries</span>
<span class="nb">say</span> <span class="nv">@chores</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># feed dog</span>
<span class="nb">say</span> <span class="nv">@chores</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># wash car</span>
</code></pre></div><ul>
<li><strong>Associative</strong> 下标 (通过 <a href="http://doc.raku.org/language/operators#postcircumfix_%7B_%7D">postcircumfix { }</a>), 不要求集合以任何特定的顺序保存元素 - 相反, 它使用一个唯一的键来寻址每个值。键的种类取决于使用的集合： 举个例子, 一个标准的<a href="http://doc.raku.org/type/Hash">散列</a> 使用字符串作为键, 而一个 <a href="http://doc.raku.org/type/Mix">Mix</a> 能使用任意的对象作为键, 等等:</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%grade</span> <span class="o">=</span> <span class="s">Zoe</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">C</span><span class="p">&#34;</span>, <span class="s">Ben</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">B+</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="nv">%grade</span><span class="p">{&#34;</span><span class="s2">Zoe</span><span class="p">&#34;};</span>  <span class="c1"># C</span>
<span class="nb">say</span> <span class="nv">%grade</span><span class="p">{&#34;</span><span class="s2">Ben</span><span class="p">&#34;};</span>  <span class="c1"># B+</span>

<span class="k">my</span> <span class="nv">$stats</span> <span class="o">=</span> <span class="p">(</span> <span class="nb">Date</span><span class="o">.</span><span class="s">today</span> <span class="o">=&gt;</span> <span class="mf">4.18</span>, <span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">2015</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="mf">17.253</span> <span class="p">)</span><span class="o">.</span><span class="nb">Mix</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$stats</span><span class="p">{</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">2015</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="p">)</span> <span class="p">};</span>  <span class="c1"># 17.253</span>
</code></pre></div><p>相对于传递单个-单词字符串键给 <code>{ }</code>, 你也可以使用<a href="http://doc.raku.org/language/quoting#Word_quoting:_qw">以尖括号引起单词的结构</a>, 就像它们是后缀操作符一样：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">%grade</span><span class="p">&lt;</span><span class="s">Zoe</span><span class="p">&gt;;</span>    <span class="c1"># C</span>
<span class="nb">say</span> <span class="nv">%grade</span><span class="p">&lt;</span><span class="s">Ben</span><span class="p">&gt;;</span>    <span class="c1"># B+</span>
</code></pre></div><p>这实际上仅仅是在编译时被转换为对应 <code>{ }</code> 形式的语法糖：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%hash</span><span class="p">&lt;</span><span class="s">foo bar</span><span class="p">&gt;;</span>     <span class="c1"># same as %hash{ &lt;foo bar&gt; }</span>
<span class="nv">%hash</span><span class="p">«</span><span class="s2">foo </span><span class="nv">$var</span><span class="p">»;</span>    <span class="c1"># same as %hash{ «foo $var» }</span>
<span class="nv">%hash</span><span class="p">&lt;&lt;</span><span class="s2">foo </span><span class="nv">$var</span><span class="p">&gt;&gt;;</span>  <span class="c1"># same as %hash{ &lt;&lt;foo $var&gt;&gt; }</span>
</code></pre></div><p>下标能应用到能返回可下标化对象的任何表达式上, 而不仅仅应用到变量上：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">__Hello__</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">match</span><span class="p">(/</span><span class="sr">__</span><span class="p">(</span><span class="ni">.</span><span class="o">*</span><span class="p">)</span><span class="sr">__</span><span class="p">/)</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>   <span class="c1"># ｢Hello｣</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">__Hello__</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">match</span><span class="p">(/</span><span class="sr">__</span><span class="p">(</span><span class="ni">.</span><span class="o">*</span><span class="p">)</span><span class="sr">__</span><span class="p">/)</span><span class="o">.[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># same, in method notation</span>
</code></pre></div><p>Positional 和 associative 下标并不互相排斥 - 举个例子, <code>Match</code> 对象两个都支持(每个访问不同的数据集)。还有, 为了让列表处理更方便, 类 <code>Any</code> 为位置下标提供了备用的实现, 这会把调用者看作含有一个元素的列表。(但是对于关系下标, 没有这样的备用实现, 所以会抛出一个异常, 当下标被应用到没有实现支持的对象上时。)</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">42</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>    <span class="c1"># 42</span>
<span class="nb">say</span> <span class="mi">42</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1"># ERROR: postcircumfix { } not defined for type Int</span>
</code></pre></div><h1 id="nonexistent-elements">Nonexistent elements</h1>
<p>当通过下标寻址一个不存在的元素所发生的事情取决于正在使用的集合类型。标准的 Array 和 Hash 集合返回它们的<a href="http://doc.raku.org/routine/of">value type constraint</a>  的类型对象(这默认是 <code>Any</code>)。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array1</span><span class="p">;</span>     <span class="nb">say</span> <span class="nv">@array1</span><span class="o">[</span><span class="mi">10</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># (Any)</span>
<span class="k">my</span> <span class="nb">Int</span> <span class="nv">@array2</span><span class="p">;</span> <span class="nb">say</span> <span class="nv">@array2</span><span class="o">[</span><span class="mi">10</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># (Int)</span>

<span class="k">my</span> <span class="nv">%hash1</span><span class="p">;</span>      <span class="nb">say</span> <span class="nv">%hash1</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1"># (Any)</span>
<span class="k">my</span> <span class="nb">Int</span> <span class="nv">%hash2</span><span class="p">;</span>  <span class="nb">say</span> <span class="nv">%hash2</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1"># (Int)</span>
</code></pre></div><p>然而, 其它类型的集合可能在寻址不存在的元素的下标时反应也不用：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="p">)</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">;</span>       <span class="c1"># Nil</span>
<span class="nb">say</span> <span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a b b b</span><span class="p">&gt;)&lt;</span><span class="s">c</span><span class="p">&gt;;</span>  <span class="c1"># 0</span>
</code></pre></div><p>为了在下标操作中默默地跳过不存在的元素, 查看 <a href="http://doc.raku.org/language/subscripts#Truncating_slices">#Truncating slices</a>  和 <a href="http://doc.raku.org/language/subscripts#%3Av"><code>#:v</code></a> 副词。</p>
<h1 id="from-the-end">From the end</h1>
<p>Positional 索引是从集合的开头计数的, 但是也有一种标记法用于, 通过相对于末尾的位置来寻址元素：<code>*-1</code> 引用最后一个元素, <code>*-2</code> 引用倒数第二个元素, 以此类推。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@alphabet</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">A</span><span class="p">&#39;</span> <span class="o">..</span> <span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># Z</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[*-</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># Y</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[*-</span><span class="mi">3</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># X</span>
</code></pre></div><p>注意：星号很重要。在 Raku 中, 如果像在很多其它编程语言中那样传递一个裸的负整数(例如 <code>@alphabet[-1]</code>), 会抛出错误。</p>
<p>这里实际发生的是, <code>*-1</code> 那样的表达式通过 <a href="http://doc.raku.org/type/Whatever">Whatever</a> 柯里化声明了一个代码对象 - <code>[ ]</code> 会把代码对象作为索引, 通过集合的长度作为参数来调用它并使用结果值作为实际的索引。换句话说, <code>@alphabet[*-1]</code> 变成了 <code>@alphabet[@alphabet.elems - 1]</code>。</p>
<p>这意味着你可以使用任何依赖于集合尺寸的表达式：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">@array</span><span class="o">[*</span> <span class="ow">div</span> <span class="mi">2</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># 选择最中间的那个元素</span>
<span class="nb">say</span> <span class="nv">@array</span><span class="o">[</span><span class="nv">$i</span> <span class="nv">%</span> <span class="o">*]</span><span class="p">;</span>   <span class="c1"># wrap around a given index (&#34;模运算&#34;)</span>
<span class="nb">say</span> <span class="nv">@array</span><span class="o">[</span> <span class="k">-&gt;</span> <span class="nv">$size</span> <span class="p">{</span> <span class="nv">$i</span> <span class="nv">%</span> <span class="nv">$size</span> <span class="p">}</span> <span class="o">]</span><span class="p">;</span>  <span class="c1"># same as previous</span>
</code></pre></div><h1 id="slices">Slices</h1>
<p>当需要访问集合中的多个元素时, 有一个快捷方式用于处理多个单独的下标操作：仅仅在下标中指定一个索引/键的列表, 来取回一个元素的列表 - 也被叫做&quot;切片&quot; - 以相同的顺序。</p>
<p>对于 positional 切片, 你可以混合普通切片和 <a href="http://doc.raku.org/language/subscripts#From_the_end">from-the-end</a> 切片：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@alphabet</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">..</span> <span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;;</span>
<span class="n">dd</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">15</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="o">*-</span><span class="mi">9</span><span class="o">,</span> <span class="mi">11</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># (&#34;p&#34;, &#34;e&#34;, &#34;r&#34;, &#34;l&#34;)</span>
</code></pre></div><p>对于 associative 切片, 尖括号形式的切片通常会很方便：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%color</span> <span class="o">=</span> <span class="s">kiwi</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;</span>, <span class="s">banana</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">yellow</span><span class="p">&#34;</span>, <span class="s">cherry</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">red</span><span class="p">&#34;;</span>

<span class="n">dd</span> <span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">cherry</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">kiwi</span><span class="p">&#34;};</span>  <span class="c1"># (&#34;red&#34;, &#34;green&#34;)</span>
<span class="n">dd</span> <span class="nv">%color</span><span class="p">&lt;</span><span class="s">cherry kiwi</span><span class="p">&gt;;</span>       <span class="c1"># (&#34;red&#34;, &#34;green&#34;)</span>
<span class="n">dd</span> <span class="nv">%color</span><span class="p">{</span><span class="o">*</span><span class="p">};</span>                 <span class="c1"># (&#34;green&#34;, &#34;red&#34;, &#34;yellow&#34;)</span>
</code></pre></div><p>要知道切片是由传入 (<a href="http://doc.raku.org/language/subscripts#Multiple_dimensions">one dimension of</a>)下标的类型控制的, 而非它的长度：</p>
<table>
<thead>
<tr>
<th style="text-align:left">subscript</th>
<th style="text-align:left">result</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">any Positional object not covered below</td>
<td style="text-align:left">normal slice</td>
</tr>
<tr>
<td style="text-align:left">a Range or infinite sequence</td>
<td style="text-align:left">truncating slice (only for positional subscripts)</td>
</tr>
<tr>
<td style="text-align:left">* (Whatever-star)</td>
<td style="text-align:left">full slice (as if all keys/indices were specified)</td>
</tr>
<tr>
<td style="text-align:left">any other object</td>
<td style="text-align:left">single-element access rather than a slice</td>
</tr>
<tr>
<td style="text-align:left">empty</td>
<td style="text-align:left">Zen slice</td>
</tr>
</tbody>
</table>
<p>所以, 即使一个单个元素的列表也会返回一个切片, 而一个裸的标量值不会：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">2</span><span class="o">,]</span><span class="p">;</span>  <span class="c1"># (&#34;c&#34;,)</span>
<span class="n">dd</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>   <span class="c1"># &#34;c&#34;</span>
</code></pre></div><p>(尖括号形式的 associative 下标也没有问题, 因为 <a href="http://doc.raku.org/language/quoting#Word_quoting:_qw">word quoting</a> 在单个单词的情况下很方便的返回一个 Str。</p>
<p>对于普通的切片, 下标的内容 (<a href="http://doc.raku.org/language/subscripts#Multiple_dimensions">the current dimension of</a>) 在它的元素被解释为索引/键之前会被展平(flattened)：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="o">,</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="p">)))</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># (&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;)</span>
</code></pre></div><h2 id="truncating-slices">Truncating slices</h2>
<p>通常, 在切片下标中引用不存在的元素会让输出列表包含未定义的值。然而, 如果传递给位置下标的对象是一个 Range 或使用序列操作符构建的无限序列, 它会被自动截断到集合的实际尺寸：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@letters</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e f</span><span class="p">&gt;;</span>
<span class="n">dd</span> <span class="nv">@letters</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># (&#34;d&#34;, &#34;e&#34;, &#34;f&#34;, Any, Any)</span>
<span class="n">dd</span> <span class="nv">@letters</span><span class="o">[</span><span class="mi">3</span> <span class="o">..</span> <span class="mi">7</span><span class="o">]</span><span class="p">;</span>         <span class="c1"># (&#34;d&#34;, &#34;e&#34;, &#34;f&#34;)</span>
</code></pre></div><p><a href="http://doc.raku.org/language/subscripts#From_the_end">From-the-end</a> 索引被允许作为范围的端点, 代表无限的范围和序列：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">@array</span><span class="o">[*-</span><span class="mi">3</span> <span class="o">..</span> <span class="o">*]</span><span class="p">;</span>       <span class="c1"># select the last three elements</span>
<span class="nb">say</span> <span class="nv">@array</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="o">*]</span><span class="p">;</span>  <span class="c1"># select all elements with even indices</span>
</code></pre></div><p>如果你不想把你的切片指定为 <code>range/sequence</code> 但仍旧想默默地跳过不存在的元素, 你可以使用 <a href="http://doc.raku.org/language/subscripts#%3Av">#:v</a> 副词。</p>
<h2 id="zen-slices">Zen slices</h2>
<p>如果你写的下标没有指定任何索引/键, 那它就会返回被脚注的对象自身。因为它是空的但是返回了全部东西, 这就是所谓的 &ldquo;Zen slice&rdquo;。</p>
<p>这和传递一个 Whatever-star, 还有传递一个空的列表都不同(它返回一个空的切片)：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%bag</span> <span class="o">:=</span> <span class="p">(&#34;</span><span class="s2">orange</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">apple</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">Bag</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">%bag</span><span class="o">&lt;&gt;</span><span class="p">;</span>    <span class="c1"># (&#34;orange&#34;=&gt;1,&#34;apple&#34;=&gt;3).Bag</span>
<span class="n">dd</span> <span class="nv">%bag</span><span class="p">{};</span>    <span class="c1"># (&#34;orange&#34;=&gt;1,&#34;apple&#34;=&gt;3).Bag</span>
<span class="n">dd</span> <span class="nv">%bag</span><span class="p">{</span><span class="o">*</span><span class="p">};</span>   <span class="c1"># (1, 3)</span>
<span class="n">dd</span> <span class="nv">%bag</span><span class="p">{()};</span>  <span class="c1"># ()</span>
</code></pre></div><p>这通常被用于把整个数组/散列插值到字符串中：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@words</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">cruel</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">world</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, </span><span class="nv">@words</span><span class="o">[]</span><span class="s2">!</span><span class="p">&#34;</span>  <span class="c1"># Hello, cruel world!</span>
</code></pre></div><h1 id="autovivification">Autovivification</h1>
<p>下标参与 &ldquo;autovivification&rdquo;, 这是一种数组和散列在需要时会自动存在的处理, 以至于你没有必要在每一层级预声明集合的类型来构建嵌套的数据结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$beatles</span><span class="p">;</span>
<span class="nv">$beatles</span><span class="p">{&#34;</span><span class="s2">White Album</span><span class="p">&#34;}</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Back in the U.S.S.R.</span><span class="p">&#34;;</span>  <span class="c1"># autovivification!</span>
<span class="nb">say</span> <span class="nv">$beatles</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>  <span class="c1"># {&#34;White Album&#34; =&gt; [&#34;Back in the U.S.S.R.&#34;]}</span>
</code></pre></div><p><code>$beatles</code> 从未定义开始, 但是它变成了一个 Hash 对象, 因为它在赋值时用 <code>{ }</code> 标注了。类似地, <code>$beatles{&quot;White Album”}</code> 变成一个 Array 对象, 因为它在赋值时用 <code>[ ]</code> 标注了。</p>
<p>注意下标本身不会引起 autovivification, 它只发生在下标链的结果被赋值时(或变化时)。</p>
<h1 id="binding">Binding</h1>
<p>下标表达式也可以用在绑定语句的左侧。如果被标注的集合的类型支持, 这会使用指定的容器替换集合里的插槽的值:</p>
<p>内置的 Array 和 Hash 类型支持这种绑定, 为了允许构建复杂的联动的数据结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">13</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nv">@a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">:=</span> <span class="nv">$x</span><span class="p">;</span>  <span class="c1"># binding! (@a[2] and $x refer to the same container now.)</span>

<span class="nv">$x</span><span class="o">++</span><span class="p">;</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">2</span><span class="o">]++</span><span class="p">;</span>

<span class="n">dd</span> <span class="nv">@a</span><span class="p">;</span>  <span class="c1"># [10, 11, 3, 13]&lt;&gt;</span>
<span class="n">dd</span> <span class="nv">$x</span><span class="p">;</span>  <span class="c1"># 3</span>
</code></pre></div><p>查看 <a href="http://doc.raku.org/language/subscripts#method_BIND-POS">#method BIND-POS</a> 和 <a href="http://doc.raku.org/language/subscripts#method_BIND-KEY">#method BIND-KEY</a> 了解底层机制.</p>
<h1 id="adverbs">Adverbs</h1>
<p>下标操作的返回值和可能存在的副作用能够使用副词来控制。</p>
<p>要知道副词操作符的优先级相对宽松, 这可能需要你在合成表达式中添加括号：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$foo</span> <span class="o">||</span> <span class="nv">%hash</span><span class="p">&lt;</span><span class="s">key</span><span class="p">&gt;:</span><span class="s">exists</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span>    <span class="c1"># WRONG, tries to adverb the || op</span>
<span class="k">if</span> <span class="nv">$foo</span> <span class="o">||</span> <span class="p">(</span><span class="nv">%hash</span><span class="p">&lt;</span><span class="s">key</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span>  <span class="c1"># correct</span>
</code></pre></div><p>支持的副词有:</p>
<h2 id="exists">:exists</h2>
<p>返回请求的元素是否存在, 而不是返回元素实际的值。这能够用于区别未定义值的元素和一点儿也不属于集合部分的元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="nb">Any</span><span class="o">,</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">@foo</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">defined</span><span class="p">;</span>    <span class="c1"># False</span>
<span class="n">dd</span> <span class="nv">@foo</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">:</span><span class="s">exists</span><span class="p">;</span>     <span class="c1"># True</span>
<span class="n">dd</span> <span class="nv">@foo</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">exists</span><span class="p">;</span>     <span class="c1"># False</span>
<span class="n">dd</span> <span class="nv">@foo</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">exists</span><span class="p">;</span>  <span class="c1"># (True, False)</span>

<span class="k">my</span> <span class="nv">%fruit</span> <span class="o">=</span> <span class="s">apple</span> <span class="o">=&gt;</span> <span class="nb">Any</span>, <span class="s">orange</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>       <span class="c1"># False</span>
<span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span>        <span class="c1"># True</span>
<span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">banana</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span>       <span class="c1"># False</span>
<span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple banana</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span> <span class="c1"># (True, False)</span>
</code></pre></div><p>也可以对副词取反来测试不存在：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple banana</span><span class="p">&gt;:!</span><span class="s">exists</span><span class="p">;</span> <span class="c1"># (False, True)</span>
</code></pre></div><p>要检查切片的所有元素是否存在, 使用 <a href="http://doc.raku.org/routine/all">all</a> junction:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nb">all</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple orange banana</span><span class="p">&gt;:</span><span class="s">exists</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p><code>:exists</code> 可以和  <a href="http://doc.raku.org/language/subscripts#%3Adelete">:delete</a> 还有 <code>:p/:kv</code> 副词组合 - 这时表达式的行为就由那些副词决定, 除了使用表明元素存在的对应 Bool 值替换返回的元素值之外。</p>
<p>查看 <a href="http://doc.raku.org/language/subscripts#method_EXISTS-POS">method EXISTS-POS</a> 和 <a href="http://doc.raku.org/language/subscripts#method_EXISTS-KEY">method EXISTS-KEY</a> 了解底层机制.</p>
<h2 id="delete">:delete</h2>
<p>从集合中删除元素, 除了返回它们的值以外。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@tens</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">:</span><span class="s">delete</span><span class="p">;</span>     <span class="c1"># 30</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="p">;</span>               <span class="c1"># [0, 10, 20]&lt;&gt;</span>

<span class="k">my</span> <span class="nv">%fruit</span> <span class="o">=</span> <span class="s">apple</span> <span class="o">=&gt;</span> <span class="mi">5</span>, <span class="s">orange</span> <span class="o">=&gt;</span> <span class="mi">10</span>, <span class="s">banana</span> <span class="o">=&gt;</span> <span class="mi">4</span>, <span class="s">peach</span> <span class="o">=&gt;</span> <span class="mi">17</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple</span><span class="p">&gt;:</span><span class="s">delete</span><span class="p">;</span>         <span class="c1"># 5</span>
<span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">peach orange</span><span class="p">&gt;:</span><span class="s">delete</span><span class="p">;</span>  <span class="c1"># (17, 10)</span>
<span class="n">dd</span> <span class="nv">%fruit</span><span class="p">;</span>                       <span class="c1"># {banana =&gt; 4}&lt;&gt;</span>
</code></pre></div><p>使用否定形式的副词, 元素实际上不会被删除。这意味着你可以传递一个标记, 让它变成有条件的删除：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple</span><span class="p">&gt;</span> <span class="p">:</span><span class="s">delete</span><span class="p">(</span><span class="nv">$flag</span><span class="p">);</span>  <span class="c1"># deletes the element only if $flag is</span>
                                  <span class="c1"># true, but always returns the value.</span>
</code></pre></div><p>能和 <code>:exists</code> 还有 <code>:p/:kv/:k/:v</code> 副词组合 - 这时返回值由那些副词决定, 但是同时元素也会被删除。</p>
<p>查看 <a href="http://doc.raku.org/language/subscripts#method_DELETE-POS">method DELETE-POS</a> and <a href="http://doc.raku.org/language/subscripts#method_DELETE-KEY">method DELETE-KEY</a> 了解底层机制.</p>
<h2 id="p">:p</h2>
<p>以 Pair 的形式, 返回元素的索引/键和元素值, 并默默跳过不存在的元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@tens</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">:</span><span class="s">p</span><span class="p">;</span>        <span class="c1"># 1 =&gt; 10</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">p</span><span class="p">;</span>  <span class="c1"># (0 =&gt; 0, 2 =&gt; 20)</span>

<span class="k">my</span> <span class="nv">%month</span> <span class="o">=</span> <span class="s">Jan</span> <span class="o">=&gt;</span> <span class="mi">1</span>, <span class="s">Feb</span> <span class="o">=&gt;</span> <span class="mi">2</span>, <span class="s">Mar</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Feb</span><span class="p">&gt;:</span><span class="s">p</span><span class="p">;</span>          <span class="c1"># &#34;Feb&#34; =&gt; 2</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="s">p</span><span class="p">;</span>  <span class="c1"># (&#34;Jan&#34; =&gt; 1, &#34;Mar&#34; =&gt; 3)</span>
</code></pre></div><p>如果你不想跳过不存在的元素, 使用否定形式:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:!</span><span class="s">p</span><span class="p">;</span>  <span class="c1"># (&#34;Jan&#34; =&gt; 1, &#34;Foo&#34; =&gt; Any, &#34;Mar&#34; =&gt; 3)</span>
</code></pre></div><p>能和 <code>:exists</code> 还有 <code>:delete</code> 组合。</p>
<p>也可以查看 <a href="http://doc.raku.org/routine/pairs">pairs</a> 子例程.</p>
<h2 id="kv">:kv</h2>
<p>以列表的形式返回元素的索引/键和值, 并默默地跳过不存在的元素。当作用在切片上时, 返回值是一个展平的键和值交叉着的单个列表：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@tens</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">:</span><span class="s">kv</span><span class="p">;</span>        <span class="c1"># (1, 10)</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">kv</span><span class="p">;</span>  <span class="c1"># (0, 0, 2, 20)</span>

<span class="k">my</span> <span class="nv">%month</span> <span class="o">=</span> <span class="s">Jan</span> <span class="o">=&gt;</span> <span class="mi">1</span>, <span class="s">Feb</span> <span class="o">=&gt;</span> <span class="mi">2</span>, <span class="s">Mar</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Feb</span><span class="p">&gt;:</span><span class="s">kv</span><span class="p">;</span>          <span class="c1"># (&#34;Feb&#34;, 2)</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="s">kv</span><span class="p">;</span>  <span class="c1"># (&#34;Jan&#34;, 1, &#34;Mar&#34;, 3)</span>
</code></pre></div><p>如果你不想跳过不存在的元素, 使用否定形式:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:!</span><span class="s">kv</span><span class="p">;</span>  <span class="c1"># (&#34;Jan&#34;, 1, &#34;Foo&#34;, Any, &#34;Mar&#34;, 3)</span>
</code></pre></div><p>这个副词一般用于遍历切片：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Feb Mar</span><span class="p">&gt;:</span><span class="s">kv</span> <span class="k">-&gt;</span> <span class="nv">$month</span><span class="o">,</span> <span class="nv">$i</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$month</span><span class="s2"> had </span><span class="p">{</span><span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">2015</span><span class="o">,</span> <span class="nv">$i</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nb">days-in-month</span><span class="p">}</span><span class="s2"> days in 2015</span><span class="p">&#34;</span>
<span class="p">}</span>
</code></pre></div><p>能和 <code>:exists</code> 还有 <code>:delete</code> 组合。</p>
<p>也可以查看  <a href="http://doc.raku.org/routine/kv">kv</a> 子例程.</p>
<h2 id="k">:k</h2>
<p>只返回元素的索引/键, 而不是它们的值, 并默默地跳过不存在的元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@tens</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">:</span><span class="s">k</span><span class="p">;</span>        <span class="c1"># 1</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">k</span><span class="p">;</span>  <span class="c1"># (0, 2)</span>

<span class="k">my</span> <span class="nv">%month</span> <span class="o">=</span> <span class="s">Jan</span> <span class="o">=&gt;</span> <span class="mi">1</span>, <span class="s">Feb</span> <span class="o">=&gt;</span> <span class="mi">2</span>, <span class="s">Mar</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Feb</span><span class="p">&gt;:</span><span class="s">k</span><span class="p">;</span>          <span class="c1"># &#34;Feb&#34;</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="s">k</span><span class="p">;</span>  <span class="c1"># (&#34;Jan&#34;, &#34;Mar&#34;)</span>
</code></pre></div><p>如果你不想跳过不存在的元素, 使用否定形式:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:!</span><span class="s">k</span><span class="p">;</span>  <span class="c1"># (&#34;Jan&#34;, &#34;Foo&#34;, &#34;Mar&#34;)</span>
</code></pre></div><p>还可以查看 <a href="http://doc.raku.org/routine/keys">keys</a> 子例程.</p>
<h2 id="v">:v</h2>
<p>返回元素的裸值(不是有可能返回一个可变值容器), 并默默跳过不存在的元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@tens</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">:</span><span class="s">v</span><span class="p">;</span>        <span class="c1"># 10</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">v</span><span class="p">;</span>  <span class="c1"># (0, 20)</span>
<span class="nv">@tens</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>        <span class="c1"># OK</span>
<span class="nv">@tens</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">:</span><span class="s">v</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>      <span class="c1"># ERROR, cannot assign to immutable integer value</span>

<span class="k">my</span> <span class="nv">%month</span> <span class="o">=</span> <span class="s">Jan</span> <span class="o">=&gt;</span> <span class="mi">1</span>, <span class="s">Feb</span> <span class="o">=&gt;</span> <span class="mi">2</span>, <span class="s">Mar</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Feb</span><span class="p">&gt;:</span><span class="s">v</span><span class="p">;</span>          <span class="c1"># 2</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="s">v</span><span class="p">;</span>  <span class="c1"># (1, 3)</span>
</code></pre></div><p>如果你不想跳过不存在的元素, 使用否定形式:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:!</span><span class="s">v</span><span class="p">;</span>  <span class="c1"># (1, Any, 3)</span>
</code></pre></div><p>还可以查看  <a href="http://doc.raku.org/routine/values">values</a> 子例程.</p>
<h1 id="custom-types">Custom types</h1>
<p>这页描述的下标接口并不意味着和 Raku 的内置集合类型相排斥 - 你可以(并且应该)为任何想通过索引或键提供数据访问的自定义类型重用它们。</p>
<p>你不必手动重载 <a href="http://doc.raku.org/routine/%5B%20%5D#postcircumfix_%5B_%5D">postcircumfix [ ]</a> 和  <a href="http://doc.raku.org/">postcircumfix { }</a> 操作符并重新实现它们所有的戏法, 为了实现它, 相反, 你可以依赖这个事实, 在幕后, 它们的标准实现分派给了一个定义良好的底层方法集。例如：</p>
<table>
<thead>
<tr>
<th style="text-align:left">当你这样写</th>
<th style="text-align:left">这会在幕后调用如下底层方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%foo<!-- raw HTML omitted --></td>
<td style="text-align:left">%foo.AT-KEY(&ldquo;aa&rdquo;)</td>
</tr>
<tr>
<td style="text-align:left">%foo<!-- raw HTML omitted -->:delete</td>
<td style="text-align:left">%foo.DELETE-KEY(&ldquo;aa&rdquo;)</td>
</tr>
<tr>
<td style="text-align:left">@foo[3,4,5]</td>
<td style="text-align:left">@foo.AT-POS(3), @foo.AT-POS(4), @foo.AT-POS(5)</td>
</tr>
<tr>
<td style="text-align:left">@foo[*-1]</td>
<td style="text-align:left">@foo.AT-POS(@foo.elems - 1)</td>
</tr>
</tbody>
</table>
<p>所以, 为了让你的下标工作, 你只需要为你的自定义类型实现或委托那些底层方法(<a href="http://doc.raku.org/language/subscripts#Methods_to_implement_for_positional_subscripting">下面描述详情</a>)。</p>
<p>如果你这样做了, 你还应该让你的类型各自遵守 <a href="http://doc.raku.org/type/Positional">Positional</a> 或 <a href="http://doc.raku.org/type/Associative">Associative</a> role</p>
<h2 id="custom-type-example">Custom type example</h2>
<p>设想一下 <code>HTTP::Header</code> 类型, 尽管它作为一个有特定行为的自定义类, 却能像散列那样索引：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$request</span> <span class="o">=</span> <span class="n">HTTP::Request</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">GET</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">raku.org</span><span class="p">&#34;);</span>
<span class="nb">say</span> <span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>  <span class="c1"># (HTTP::Header)</span>

<span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="p">&lt;</span><span class="s">Accept</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">text/plain</span><span class="p">&#34;;</span>
<span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="p">{&#39;</span><span class="s1">Accept-</span><span class="p">&#39;</span> <span class="ow">X</span><span class="o">~</span> <span class="p">&lt;</span><span class="s">Charset Encoding Language</span><span class="p">&gt;}</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">utf-8 gzip en</span><span class="p">&gt;;</span>
<span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="o">.</span><span class="nb">push</span><span class="p">(&#39;</span><span class="s1">Accept-Language</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">fr</span><span class="p">&#34;);</span>  <span class="c1"># like .push on a Hash</span>

<span class="nb">say</span> <span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="p">&lt;</span><span class="s">Accept-Language</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>  <span class="c1"># [&#34;en&#34;, &#34;fr&#34;]</span>

<span class="k">my</span> <span class="nv">$rawheader</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="o">.</span><span class="nb">Str</span><span class="p">;</span>  <span class="c1"># stringify according to HTTP spec</span>
</code></pre></div><p>实现这个类的最简单的方法是, 给它一个 Hash 类型的属性, 并把所有的下标和迭代相关功能性委托给那个属性。(使用一个自定义类型约束来确保使用者不会在里面插入任何不合法的值)：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">HTTP::Header</span> <span class="k">does</span> <span class="nb">Associative</span> <span class="k">is</span> <span class="nb">Iterable</span> <span class="p">{</span>
    <span class="k">subset</span> <span class="nc">StrOrArrayOfStr</span> <span class="k">where</span> <span class="nb">Str</span> <span class="o">|</span> <span class="p">(</span> <span class="nb">Array</span> <span class="o">&amp;</span> <span class="p">{</span><span class="o">.</span><span class="nb">all</span> <span class="o">~~</span> <span class="nb">Str</span><span class="p">}</span> <span class="p">);</span>

    <span class="k">has</span> <span class="nv">%!fields</span> <span class="k">of</span> <span class="nc">StrOrArrayOfStr</span>
                 <span class="nb">handles</span> <span class="p">&lt;</span><span class="s">AT-KEY EXISTS-KEY DELETE-KEY push
</span><span class="s">                          iterator list kv keys values</span><span class="p">&gt;;</span>

    <span class="k">method</span> <span class="nb">Str</span> <span class="p">{</span> <span class="cm">#`[not shown, for brevity]</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>然而, HTTP header 字段名被认为是大小写无关的(更偏好驼峰法)。我们可以通过把 <code>*-key</code> 和 <code>push</code> 方法拿到 <code>handles</code> 列表的外面来容纳它, 并像这样各自实现它们：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nb">AT-KEY</span>     <span class="p">(</span><span class="nv">$key</span><span class="p">)</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">}</span>        <span class="p">}</span>
<span class="k">method</span> <span class="nb">EXISTS-KEY</span> <span class="p">(</span><span class="nv">$key</span><span class="p">)</span>       <span class="p">{</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">}:</span><span class="s">exists</span> <span class="p">}</span>
<span class="k">method</span> <span class="nb">DELETE-KEY</span> <span class="p">(</span><span class="nv">$key</span><span class="p">)</span>       <span class="p">{</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">}:</span><span class="s">delete</span> <span class="p">}</span>
<span class="k">method</span> <span class="nb">push</span> <span class="p">(</span><span class="o">*</span><span class="nv">@_</span><span class="p">)</span> <span class="p">{</span> <span class="cm">#`[not shown, for brevity]</span> <span class="p">}</span>

<span class="k">sub</span> <span class="nf">normalize-key</span> <span class="p">(</span><span class="nv">$key</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$key</span><span class="o">.</span><span class="nb">subst</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/</span><span class="o">,</span> <span class="o">*.</span><span class="nb">tc</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>注意下标  <code>%!fields</code> 返回一个适当的 rw 容器, 而我们的 <code>AT-KEY</code> 能够简单地传递。</p>
<p>然而, 我们可能倾向于少一点对用户输入的限制, 相反我们自己关心字段值的消毒。那种情况下, 我们可以移除 <code>%!fields</code> 上的 <code>StrOrArrayOfStr</code> 类型约束, 并在赋值时使用返回自定义的关心消毒值的 Proxy 容器来替换我们的 <code>AT-KEY</code> 实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">AT-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$element</span> <span class="o">:=</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">};</span>

    <span class="nb">Proxy</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
        <span class="s">FETCH</span> <span class="o">=&gt;</span> <span class="k">method</span> <span class="p">()</span> <span class="p">{</span> <span class="nv">$element</span> <span class="p">}</span>,

        <span class="s">STORE</span> <span class="o">=&gt;</span> <span class="k">method</span> <span class="p">(</span><span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
            <span class="nv">$element</span> <span class="o">=</span> <span class="nb">do</span> <span class="k">given</span> <span class="nv">$value</span><span class="o">».</span><span class="nb">split</span><span class="p">(/&#39;</span><span class="s1">,</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">flat</span> <span class="p">{</span>
                <span class="k">when</span> <span class="mi">1</span>  <span class="p">{</span> <span class="o">.[</span><span class="mi">0</span><span class="o">]</span> <span class="p">}</span>    <span class="c1"># a single value is stored as a string</span>
                <span class="k">default</span> <span class="p">{</span> <span class="o">.</span><span class="nb">Array</span> <span class="p">}</span>  <span class="c1"># multiple values are stored as an array</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>注意把方法声明为 <code>multi</code> 并把它限制为 <code>:D</code> (defined invocants) 确保未定义情况被传递给由 Any 提供的默认实现。</p>
<h2 id="methods-to-implement-for-positional-subscripting">Methods to implement for positional subscripting</h2>
<p>为了通过 <a href="http://doc.raku.org/routine/%5B%20%5D#postcircumfix_%5B_%5D">postcircumfix [ ]</a> 让基于索引的下标在你的自定义类型中工作, 你应该至少实现下面的 <code>elems</code>, <code>AT-POS</code> 和 <code>EXISTS-POS-</code> 还有其它可选项。</p>
<h3 id="elems-方法">elems 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">elems</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span><span class="p">)</span>
</code></pre></div><p>预期返回一个数字, 用于表明对象中有多少个可标注的元素。可能被用户直接调用, 并且当从末尾索引元素的时候, 还会被  <code>postcircumfix [ ]</code> 调用, 就像 <code>@foo[*-1]</code> 中那样。</p>
<p>如果没有实现这个方法, 你的类型会从 Any 继承默认的实现, 对定义过的调用者这总是返回 1 - 这最不可能是你想要的。所以, 如果不能从你的位置类型知晓元素的个数, 那就添加一个 fails 或 dies 实现, 以避免沉默地做了错事。</p>
<h3 id="at-pos-方法">AT-POS 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">AT-POS</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$index</span><span class="p">)</span>
</code></pre></div><p>期望返回 <code>$index</code> 位置处的元素。这就是 <code>postcircumfix [ ]</code> 通常调用的方法。
如果你想让元素可变(像它们用于 Array 类型那样), 你就必须确保以 item 容器的形式返回它, 并在被赋值时更新它。(记得使用 <code>return-rw</code> 或 <code>rw</code> 子例程 trait 以使它工作。)</p>
<h3 id="exists-pos-方法">EXISTS-POS 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">EXISTS-POS</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$index</span><span class="p">)</span>
</code></pre></div><p>返回一个布尔值以表明在 <code>$index</code> 位置处是否有元素。这就是引用 <code>@foo[42]:exists</code> 时, <code>postcircumfix [ ]</code> 所调用的方法。</p>
<p>元素&quot;存在&quot;意味着什么, 取决于你的类型。</p>
<p>如果你没有实现它, 你的类型会从 <code>Any</code> 那儿继承默认的实现, 对于索引 0 它会返回 True, 对于 其它索引它会返回 <code>false</code> - 这可能不是你想要的。所以如果你的类型不能做元素存在检测, 那就添加一个 fails 或 die 实现, 以避免静默地做错事情。</p>
<h3 id="delete-pos-方法">DELETE-POS 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">DELETE-POS</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$index</span><span class="p">)</span>
</code></pre></div><p>删除 <code>$index</code> 处的元素, 并返回它所删除的这个元素。这就是引用 <code>@foo[42]:delete</code> 时, <code>postcircumfix [ ]</code> 所调用的方法。</p>
<p>&ldquo;删除&quot;元素的意思是什么, 取决于你的类型。</p>
<p>实现这个方法是可选的; 如果你没有实现它, 那么用户尝试从这种类型的对象中删除元素会得到一个合适的错误信息。</p>
<h3 id="assign-pos-方法">ASSIGN-POS 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">ASSIGN-POS</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$index</span><span class="o">,</span> <span class="nv">$new</span><span class="p">)</span>
</code></pre></div><p>把 <code>$index</code> 位置处的元素设置为 <code>$new</code> 值。实现这个方法完全是可选的; 如果你没有实现这个方法, 那么会使用 <code>self.AT-POS($index) = $new</code> 代替, 如果你确实实现了该方法, 那么确保它拥有相同的效果。</p>
<p>这意味着 opt-in 性能优化, 以至于简单的诸如 <code>@numbers[5] = &quot;five&quot;</code> 的赋值能在不调用 <code>AT-POS</code>(这必须创建并返回一个潜在的昂贵的容器对象) 方法时操作。</p>
<p>注意, 实现 <code>ASSIGN-POS</code> 不能解除让 <code>AT-POS</code> 变成一个 <code>rw</code> 方法, 因为诸如 <code>@numbers[5]++</code> 的不太重要的赋值/修改仍旧会使用 <code>AT-POS</code>。</p>
<h3 id="bind-pos-方法">BIND-POS 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">BIND-POS</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$index</span><span class="o">,</span> \<span class="nb">new</span><span class="p">)</span>
</code></pre></div><p>把值或容器 <code>new</code> 绑定给位置 <code>$index</code> 处的插槽上, 替换那儿能找到的任何容器。这是当你这样写的时候所调用的东西:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nv">@numbers</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="o">:=</span> <span class="nv">$x</span><span class="p">;</span>
</code></pre></div><p>一般的数组类支持这以允许创建复杂的链接数据结构, 但是对于更特定领域类型它可能没有意义, 所以不强求去实现它。如果你没有实现该方法, 用户会获得一个合适的错误信息, 当它们尝试绑定到这种类型的对象的一个位置插槽上时。</p>
<h2 id="methods-to-implement-for-associative-subscripting">Methods to implement for associative subscripting</h2>
<p>为了通过 <code>postcircumfix { }</code> 让基于键的下标能够工作于你的自定义类型中, 你应该至少实现 <code>AT-KEY</code> 和 <code>EXISTS-KEY</code> - 还有可选地实现下面的方法。</p>
<h3 id="at-key-方法">AT-KEY 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">AT-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span>
</code></pre></div><p>返回和 <code>$key</code> 相关联的元素。这正是 <code>postcircumfix { }</code> 通常所调用的方法。</p>
<p>如果你想让元素可变(就像它们是为了内置的 Hash 类型), 你必须确保以 item 容器的形式返回它, 并在被赋值时更新它。(记得使用 <code>return-rw</code> 或 <code>is rw</code> 子例程 trait 以使其有效; 查看例子。)</p>
<p>另一方面, 如果你想让你的集合只读, 请直接返回非容器值。</p>
<h3 id="exists-key-方法">EXISTS-KEY 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">EXISTS-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span>
</code></pre></div><p>返回一个布尔值以表明和 <code>$key</code> 相关联的元素是否存在。这就是引用 <code>%foo&lt;aa&gt;:exists</code> 时, <code>postcircumfix { }</code> 所调用的方法。</p>
<p>元素&quot;存在&quot;意味着什么, 取决于你的类型。</p>
<p>如果你没有实现它, 你的类型会从 <code>Any</code> 那儿继承默认的实现, 这通常返回 False - 这可能不是你想要的。所以如果你的类型不能做元素存在检测, 那就添加一个 fails 或 die 实现, 以避免静默地做错事情</p>
<h3 id="delete-key-方法">DELETE-KEY 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">DELETE-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span>
</code></pre></div><p>删除和 <code>$key</code> 相关联的元素, 并返回它所删除的这个元素。这就是引用 <code>%foo&lt;aa&gt;:delete</code> 时, <code>postcircumfix { }</code> 所调用的方法。</p>
<p>&ldquo;删除&quot;元素的意思是什么, 取决于你的类型 - 尽管它通常让 <code>EXISTS-KEY</code> 因为那个键变为 <code>False</code>。</p>
<p>实现这个方法是可选的; 如果你没有实现它, 那么用户尝试从这种类型的对象中删除元素会得到一个合适的错误信息。</p>
<h3 id="assign-key-方法">ASSIGN-KEY 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">ASSIGN-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="o">,</span> <span class="nv">$new</span><span class="p">)</span>
</code></pre></div><p>把和 <code>$key</code>  相关联的元素设置为 <code>$new</code> 值。实现这个方法完全是可选的; 如果你没有实现这个方法, 那么会使用 <code>self.AT-KEY($key) = $new</code> 代替, 如果你确实实现了该方法, 那么确保它拥有相同的效果。</p>
<p>这意味着 opt-in 性能优化, 以至于简单的诸如 <code>%age&lt;Claire&gt; = 29</code> 的赋值能在不调用 <code>AT-KEY</code>(这必须创建并返回一个潜在的昂贵的容器对象) 方法时操作。</p>
<p>注意, 实现 <code>ASSIGN-KEY</code> 不能解除让 <code>AT-KEY</code> 变成一个 <code>rw</code> 方法, 因为诸如 <code>%age&lt;Claire&gt;++</code> 的不太重要的赋值/修改 仍旧会使用 <code>AT-KEY</code>。</p>
<h3 id="bind-key-方法">BIND-KEY 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">BIND-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="o">,</span> \<span class="nb">new</span><span class="p">)</span>
</code></pre></div><p>把值或容器 <code>new</code> 绑定给跟 <code>$key</code> 相关联的插槽上, 替换那儿能找到的任何容器。这是当你这样写的时候所调用的东西:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nv">%age</span><span class="p">&lt;</span><span class="s">Claire</span><span class="p">&gt;</span> <span class="o">:=</span> <span class="nv">$x</span><span class="p">;</span>
</code></pre></div><p>一般的散列类支持这以允许创建复杂的链接数据结构, 但是对于更特定领域类型它可能没有意义, 所以不强求去实现它。如果你没有实现该方法, 用户会获得一个合适的错误信息, 当它们尝试绑定到这种类型的对象的一个位置插槽上时。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/subscripts" term="subscripts" label="subscripts" />
                            
                        
                    
                
            
        </entry>
    
</feed>
