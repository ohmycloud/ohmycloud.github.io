<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.85.0">Hugo</generator><title type="html"><![CDATA[julia on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/julia/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/julia/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/julia/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/julia/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2021-07-11T22:08:29+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/julia/</id>
    
        
        <entry>
            <title type="html"><![CDATA[元编程]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-12-29-metaprogramming/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-repl-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的 REPL" />
            
                <id>https://ohmyweekly.github.io/notes/2020-12-29-metaprogramming/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-12-29T00:00:00+08:00</published>
            <updated>2020-12-29T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Metaprogramming</blockquote><h1 id="元编程">元编程</h1>
<p>在Julia语言中，Lisp最强的遗产是它对元编程的支持。和Lisp一样，Julia也将自己的代码表示为语言本身的数据结构。由于代码是由可以在语言内部创建和操作的对象来表示的，所以程序可以转换和生成自己的代码。这使得复杂的代码生成不需要额外的构建步骤，也允许真正的Lisp式的宏在<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">抽象语法树</a>的层次上操作。相比之下，预处理器的 &ldquo;宏 &ldquo;系统，就像C和C++一样，在任何实际的解析或解释发生之前，都会进行文本操作和替换。由于Julia中所有的数据类型和代码都是由Julia数据结构来表示的，因此，强大的<a href="https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29">反射</a>功能可以像其他数据一样探索程序及其类型的内部。</p>
<h2 id="程序表示">程序表示</h2>
<p>每个Julia程序都是以字符串的形式开始的。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">prog</span> <span class="o">=</span> <span class="s">&#34;1 + 1&#34;</span>
<span class="s">&#34;1 + 1&#34;</span>
</code></pre></div><p><strong>接下来会发生什么？</strong></p>
<p>下一步是将每个字符串<a href="https://en.wikipedia.org/wiki/Parsing#Computer_languages">解析</a>成一个对象，称为表达式，用Julia类型 <a href="https://docs.julialang.org/en/v1/base/base/#Core.Expr">Expr</a> 表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex1</span> <span class="o">=</span> <span class="n">Meta</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span>
<span class="o">:</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">typeof</span><span class="p">(</span><span class="n">ex1</span><span class="p">)</span>
<span class="kt">Expr</span>
</code></pre></div><p>Expr对象包含两部分。</p>
<p>a 符号标识表达式的种类。符号是一个内嵌的字符串标识符（下文将详细讨论）。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex1</span><span class="o">.</span><span class="n">head</span>
<span class="o">:</span><span class="n">call</span>
</code></pre></div><p>表达式参数，可以是符号、其他表达式或文字值。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex1</span><span class="o">.</span><span class="n">args</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Any</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
  <span class="o">:+</span>
 <span class="mi">1</span>
 <span class="mi">1</span>
</code></pre></div><p>也可以直接用前缀符号构造表达式。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex2</span> <span class="o">=</span> <span class="kt">Expr</span><span class="p">(</span><span class="ss">:call</span><span class="p">,</span> <span class="o">:+</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">:</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div><p>上面构造的两个表达式&ndash;通过解析和直接构造&ndash;是等价的。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex1</span> <span class="o">==</span> <span class="n">ex2</span>
<span class="nb">true</span>
</code></pre></div><p>这里的关键点是，Julia代码在内部被表示为一个数据结构，可以从语言本身访问。</p>
<p>dump函数提供了Expr对象的缩进和注释显示。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">dump</span><span class="p">(</span><span class="n">ex2</span><span class="p">)</span>
<span class="kt">Expr</span>
  <span class="n">head</span><span class="o">:</span> <span class="kt">Symbol</span> <span class="n">call</span>
  <span class="n">args</span><span class="o">:</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Any</span><span class="p">}((</span><span class="mi">3</span><span class="p">,))</span>
    <span class="mi">1</span><span class="o">:</span> <span class="kt">Symbol</span> <span class="o">+</span>
    <span class="mi">2</span><span class="o">:</span> <span class="kt">Int64</span> <span class="mi">1</span>
    <span class="mi">3</span><span class="o">:</span> <span class="kt">Int64</span> <span class="mi">1</span>
</code></pre></div><p>Expr对象也可以被嵌套。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex3</span> <span class="o">=</span> <span class="n">Meta</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#34;(4 + 4) / 2&#34;</span><span class="p">)</span>
<span class="o">:</span><span class="p">((</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div><p>另一种查看表达式的方法是使用Meta.show_sexpr，它可以显示给定Expr的S表达式形式，这对于Lisp的用户来说可能看起来非常熟悉。下面是一个例子，说明如何在嵌套的Expr上显示。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">Meta</span><span class="o">.</span><span class="n">show_sexpr</span><span class="p">(</span><span class="n">ex3</span><span class="p">)</span>
<span class="p">(</span><span class="ss">:call</span><span class="p">,</span> <span class="o">:/</span><span class="p">,</span> <span class="p">(</span><span class="ss">:call</span><span class="p">,</span> <span class="o">:+</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div><p>符号</p>
<p>在Julia中，:字符有两种语法用途。第一种形式是创建一个Symbol，一个内部字符串，作为表达式的一个构件。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="ss">:foo</span>
<span class="ss">:foo</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="kt">Symbol</span>
</code></pre></div><p>符号构造函数接受任何数量的参数，并通过将它们的字符串表示连接在一起来创建一个新的符号。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="ss">:foo</span> <span class="o">==</span> <span class="kt">Symbol</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">)</span>
<span class="nb">true</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="kt">Symbol</span><span class="p">(</span><span class="s">&#34;func&#34;</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="ss">:func10</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="kt">Symbol</span><span class="p">(</span><span class="ss">:var</span><span class="p">,</span><span class="sc">&#39;_&#39;</span><span class="p">,</span><span class="s">&#34;sym&#34;</span><span class="p">)</span>
<span class="ss">:var_sym</span>
</code></pre></div><p>请注意，要使用 : 语法，符号的名称必须是一个有效的标识符。否则必须使用Symbol(str)构造函数。</p>
<p>在表达式的上下文中，符号用于指示对变量的访问；当表达式被评估时，符号会被替换为在适当的作用域中与该符号绑定的值。</p>
<p>有时，为了避免在解析时产生歧义，需要在 : 的参数周围加括号。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="o">:</span><span class="p">(</span><span class="o">:</span><span class="p">)</span>
<span class="o">:</span><span class="p">(</span><span class="o">:</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="o">:</span><span class="p">(</span><span class="o">::</span><span class="p">)</span>
<span class="o">:</span><span class="p">(</span><span class="o">::</span><span class="p">)</span>
</code></pre></div><p>表达式和评价</p>
<dl>
<dt>引用</dt>
<dd>
<p>字符的第二个语法目的是在不使用显式Expr构造函数的情况下创建表达式对象。这就是所谓的引用。在Julia代码的单条语句周围，用成对的括号跟上 : 字符，就可以根据所附的代码生成一个Expr对象。下面是用于引用一个算术表达式的简短形式的例子。</p>
</dd>
</dl>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="o">:</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">typeof</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
<span class="kt">Expr</span>
</code></pre></div><p>(要查看这个表达式的结构，可以试试ex.head和ex.args，或者使用上面的dump或Meta.@dump)</p>
<p>注意，可以使用Meta.parse或直接使用Expr形式构造等价的表达式。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span>      <span class="o">:</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>       <span class="o">==</span>
       <span class="n">Meta</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#34;a + b*c + 1&#34;</span><span class="p">)</span> <span class="o">==</span>
       <span class="kt">Expr</span><span class="p">(</span><span class="ss">:call</span><span class="p">,</span> <span class="o">:+</span><span class="p">,</span> <span class="ss">:a</span><span class="p">,</span> <span class="kt">Expr</span><span class="p">(</span><span class="ss">:call</span><span class="p">,</span> <span class="o">:*</span><span class="p">,</span> <span class="ss">:b</span><span class="p">,</span> <span class="ss">:c</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="nb">true</span>
</code></pre></div><p>解析器提供的表达式一般只有符号、其他表达式和字面值作为其args，而Julia代码构建的表达式可以有任意的运行时值，没有字面形式作为args。在这个具体的例子中，+和a是符号，*(b,c)是一个子表达式，1是一个64位有符号整数的文字形式。</p>
<p>对于多个表达式，还有第二种引用的语法形式：用引号&hellip;&hellip;结尾括起来的代码块。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex</span> <span class="o">=</span> <span class="k">quote</span>
           <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
           <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
           <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
       <span class="k">end</span>
<span class="k">quote</span>
    <span class="cm">#= none:2 =#</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="cm">#= none:3 =#</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="cm">#= none:4 =#</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="k">end</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">typeof</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
<span class="kt">Expr</span>
</code></pre></div><p>插值</p>
<p>用值参数直接构造Expr对象是很强大的，但与 &ldquo;正常的 &ldquo;Julia语法相比，Expr构造函数可能很乏味。作为一种替代方法，Julia允许将字元或表达式插值到引用的表达式中。插值由前缀$表示。</p>
<p>在这个例子中，变量a的值被内插了。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
<span class="o">:</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div><p>不支持向未引用的表达式插值，并会导致编译时错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="o">$</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="n">ERROR</span><span class="o">:</span> <span class="n">syntax</span><span class="o">:</span> <span class="s">&#34;$&#34;</span> <span class="n">expression</span> <span class="n">outside</span> <span class="k">quote</span>
</code></pre></div><p>在这个例子中，元组(1,2,3)作为表达式被内插到一个条件测试中。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="n">a</span> <span class="k">in</span> <span class="o">$:</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="p">)</span>
<span class="o">:</span><span class="p">(</span><span class="n">a</span> <span class="k">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</code></pre></div><p>在表达式插值中使用$是有意让人联想到字符串插值和命令插值。表达式插值可以方便的、可读的程序化构造复杂的Julia表达式。</p>
<p>劈叉插值</p>
<p>请注意，$插值语法只允许在一个包围表达式中插入一个表达式。偶尔，你有一个表达式数组，需要它们全部成为包围表达式的参数。这可以用语法$(xs&hellip;)来完成。例如，下面的代码生成了一个函数调用，其中的参数数是通过编程确定的。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">,</span> <span class="ss">:z</span><span class="p">];</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="o">:</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">$</span><span class="p">(</span><span class="n">args</span><span class="o">...</span><span class="p">)))</span>
<span class="o">:</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>
</code></pre></div><p>嵌套引用</p>
<p>自然，引号表达式有可能包含其他引号表达式。在这些情况下，理解内插是如何工作的可能有点棘手。考虑一下这个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="k">quote</span> <span class="k">quote</span> <span class="o">$</span><span class="n">x</span> <span class="k">end</span> <span class="k">end</span>
<span class="k">quote</span>
    <span class="cm">#= none:1 =#</span>
    <span class="o">$</span><span class="p">(</span><span class="kt">Expr</span><span class="p">(</span><span class="ss">:quote</span><span class="p">,</span> <span class="k">quote</span>
    <span class="cm">#= none:1 =#</span>
    <span class="o">$</span><span class="p">(</span><span class="kt">Expr</span><span class="p">(</span><span class="o">:$</span><span class="p">,</span> <span class="ss">:x</span><span class="p">))</span>
<span class="k">end</span><span class="p">))</span>
<span class="k">end</span>
</code></pre></div><p>注意，结果中包含$x，这意味着x还没有被评估。换句话说，$表达式 &ldquo;属于 &ldquo;内部引号表达式，因此它的参数只有在内部引号表达式时才会被评估。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="k">quote</span>
    <span class="cm">#= none:1 =#</span>
    <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
<span class="k">end</span>
</code></pre></div><p>但是，外引号表达式能够对内引号中的$内的值进行插值。这是用多个$来完成的。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="k">quote</span> <span class="k">quote</span> <span class="o">$$</span><span class="n">x</span> <span class="k">end</span> <span class="k">end</span>
<span class="k">quote</span>
    <span class="cm">#= none:1 =#</span>
    <span class="o">$</span><span class="p">(</span><span class="kt">Expr</span><span class="p">(</span><span class="ss">:quote</span><span class="p">,</span> <span class="k">quote</span>
    <span class="cm">#= none:1 =#</span>
    <span class="o">$</span><span class="p">(</span><span class="kt">Expr</span><span class="p">(</span><span class="o">:$</span><span class="p">,</span> <span class="o">:</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)))</span>
<span class="k">end</span><span class="p">))</span>
<span class="k">end</span>
</code></pre></div><p>注意到(1+2)现在出现在结果中，而不是符号x。对这个表达式进行评估，得到一个内插的3。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="k">quote</span>
    <span class="cm">#= none:1 =#</span>
    <span class="mi">3</span>
<span class="k">end</span>
</code></pre></div><p>这种行为背后的直觉是，x对每个$都会被评估一次：一个$的工作原理类似于eval(:x)，给出x的值，而两个$的工作原理相当于eval(eval(:x))。</p>
<p>QuoteNode</p>
<p>引号形式在AST中的通常表示是一个带头:quote的Expr。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">dump</span><span class="p">(</span><span class="n">Meta</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#34;:(1+2)&#34;</span><span class="p">))</span>
<span class="kt">Expr</span>
  <span class="n">head</span><span class="o">:</span> <span class="kt">Symbol</span> <span class="k">quote</span>
  <span class="n">args</span><span class="o">:</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Any</span><span class="p">}((</span><span class="mi">1</span><span class="p">,))</span>
    <span class="mi">1</span><span class="o">:</span> <span class="kt">Expr</span>
      <span class="n">head</span><span class="o">:</span> <span class="kt">Symbol</span> <span class="n">call</span>
      <span class="n">args</span><span class="o">:</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Any</span><span class="p">}((</span><span class="mi">3</span><span class="p">,))</span>
        <span class="mi">1</span><span class="o">:</span> <span class="kt">Symbol</span> <span class="o">+</span>
        <span class="mi">2</span><span class="o">:</span> <span class="kt">Int64</span> <span class="mi">1</span>
        <span class="mi">3</span><span class="o">:</span> <span class="kt">Int64</span> <span class="mi">2</span>
</code></pre></div><p>正如我们所看到的，这类表达式支持用$进行插值，但是在某些情况下，有必要在不进行插值的情况下引用代码。这种引用还没有语法，但在内部表示为一个类型为QuoteNode的对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">Meta</span><span class="o">.</span><span class="n">quot</span><span class="p">(</span><span class="kt">Expr</span><span class="p">(</span><span class="o">:$</span><span class="p">,</span> <span class="o">:</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">))))</span>
<span class="mi">3</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="kt">QuoteNode</span><span class="p">(</span><span class="kt">Expr</span><span class="p">(</span><span class="o">:$</span><span class="p">,</span> <span class="o">:</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">))))</span>
<span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="p">(</span><span class="kt">Expr</span><span class="p">(</span><span class="o">:$</span><span class="p">,</span> <span class="o">:</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))))</span>
</code></pre></div><p>该解析器产生的QuoteNodes用于简单的引用项目，如符号。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">dump</span><span class="p">(</span><span class="n">Meta</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#34;:x&#34;</span><span class="p">))</span>
<span class="kt">QuoteNode</span>
  <span class="n">value</span><span class="o">:</span> <span class="kt">Symbol</span> <span class="n">x</span>
</code></pre></div><p>QuoteNode还可以用于某些高级元编程任务。</p>
<p>评估表达式</p>
<p>给定一个表达式对象，可以使用eval使Julia在全局范围内对其进行评估（执行）。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="o">:</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">:</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="mi">3</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
<span class="o">:</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
<span class="n">ERROR</span><span class="o">:</span> <span class="kt">UndefVarError</span><span class="o">:</span> <span class="n">b</span> <span class="n">not</span> <span class="n">defined</span>
<span class="p">[</span><span class="o">...</span><span class="p">]</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
<span class="mi">3</span>
</code></pre></div><p>每个模块都有自己的 eval 函数，它可以在全局范围内评估表达式。传递给eval的表达式并不局限于返回值&ndash;它们也可以产生副作用，改变模块环境的状态。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">:</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="n">ERROR</span><span class="o">:</span> <span class="kt">UndefVarError</span><span class="o">:</span> <span class="n">x</span> <span class="n">not</span> <span class="n">defined</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
<span class="mi">1</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="mi">1</span>
</code></pre></div><p>在这里，对表达式对象的评价会导致一个值被分配给全局变量x。</p>
<p>由于表达式只是Expr对象，可以通过编程构造，然后进行评估，因此可以动态生成任意代码，然后使用eval进行运行。下面是一个简单的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex</span> <span class="o">=</span> <span class="kt">Expr</span><span class="p">(</span><span class="ss">:call</span><span class="p">,</span> <span class="o">:+</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="ss">:b</span><span class="p">)</span>
<span class="o">:</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
<span class="mi">3</span>
</code></pre></div><p>a的值用于构造表达式ex，该表达式将+函数应用于值1和变量b，注意a和b的使用方式的重要区别。</p>
<p>变量a的值在表达式构造时被用作表达式中的即时值。因此，当表达式被评估时，a的值不再重要：表达式中的值已经是1，无论a的值是多少，都是独立的。
另一方面，在表达式的构造中使用了符号:b，所以变量b的值在那个时候是无关紧要的&ndash;:b只是一个符号，变量b甚至不需要被定义。但在表达式评估时，符号:b的值是通过查找变量b的值来解决的。
表达式上的函数</p>
<p>如上所述，Julia的一个极其有用的特性是在Julia本身内部生成和操作Julia代码的能力。我们已经看到了一个函数返回Expr对象的例子：parse函数，它接收一串Julia代码并返回相应的Expr。一个函数也可以接受一个或多个Expr对象作为参数，并返回另一个Expr。下面是一个简单的、激励性的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span> <span class="n">math_expr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">)</span>
           <span class="n">expr</span> <span class="o">=</span> <span class="kt">Expr</span><span class="p">(</span><span class="ss">:call</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">)</span>
           <span class="k">return</span> <span class="n">expr</span>
       <span class="k">end</span>
<span class="n">math_expr</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span>  <span class="n">ex</span> <span class="o">=</span> <span class="n">math_expr</span><span class="p">(</span><span class="o">:+</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">Expr</span><span class="p">(</span><span class="ss">:call</span><span class="p">,</span> <span class="o">:*</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="o">:</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
<span class="mi">21</span>
</code></pre></div><p>作为另一个例子，这里有一个函数，它可以将任何数字参数翻倍，但不考虑表达式。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span> <span class="n">make_expr2</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">opr1</span><span class="p">,</span> <span class="n">opr2</span><span class="p">)</span>
           <span class="n">opr1f</span><span class="p">,</span> <span class="n">opr2f</span> <span class="o">=</span> <span class="n">map</span><span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="k">isa</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kt">Number</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">:</span> <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">opr1</span><span class="p">,</span> <span class="n">opr2</span><span class="p">))</span>
           <span class="n">retexpr</span> <span class="o">=</span> <span class="kt">Expr</span><span class="p">(</span><span class="ss">:call</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">opr1f</span><span class="p">,</span> <span class="n">opr2f</span><span class="p">)</span>
           <span class="k">return</span> <span class="n">retexpr</span>
       <span class="k">end</span>
<span class="n">make_expr2</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">make_expr2</span><span class="p">(</span><span class="o">:+</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">:</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">make_expr2</span><span class="p">(</span><span class="o">:+</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">Expr</span><span class="p">(</span><span class="ss">:call</span><span class="p">,</span> <span class="o">:*</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="o">:</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
<span class="mi">42</span>
</code></pre></div><h2 id="宏">宏</h2>
<p>宏提供了一种将生成的代码包含在程序的最后主体中的方法。宏将一个参数元组映射到一个返回的表达式，生成的表达式直接被编译，而不需要运行时 <a href="https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.eval">eval</a> 调用。宏参数可以包括表达式、字面值和符号。</p>
<h3 id="基础知识">基础知识</h3>
<p>这里有一个特别简单的宏。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="k">macro</span> <span class="n">sayhello</span><span class="p">()</span>
           <span class="k">return</span> <span class="o">:</span><span class="p">(</span> <span class="n">println</span><span class="p">(</span><span class="s">&#34;Hello, world!&#34;</span><span class="p">)</span> <span class="p">)</span>
       <span class="k">end</span>
<span class="nd">@sayhello</span> <span class="p">(</span><span class="k">macro</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>
</code></pre></div><p>在 Julia 的语法中，宏有一个专门的字符：<code>@</code>(at 符号)，后面是 <code>macro NAME ... end</code> 块中声明的唯一名称&hellip;.。在这个例子中，编译器将用 <code>@sayhello</code> 替换所有的实例。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="o">:</span><span class="p">(</span> <span class="n">println</span><span class="p">(</span><span class="s">&#34;Hello, world!&#34;</span><span class="p">)</span> <span class="p">)</span>
</code></pre></div><p>当在 REPL 中输入 <code>@sayhello</code> 时，表达式会立即执行，因此我们只看到求值结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@sayhello</span><span class="p">()</span>
<span class="n">Hello</span><span class="p">,</span> <span class="n">world!</span>
</code></pre></div><p>现在，考虑一个稍微复杂的宏。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="k">macro</span> <span class="n">sayhello</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
           <span class="k">return</span> <span class="o">:</span><span class="p">(</span> <span class="n">println</span><span class="p">(</span><span class="s">&#34;Hello, &#34;</span><span class="p">,</span> <span class="o">$</span><span class="n">name</span><span class="p">)</span> <span class="p">)</span>
       <span class="k">end</span>
<span class="nd">@sayhello</span> <span class="p">(</span><span class="k">macro</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>
</code></pre></div><p>这个宏只取一个参数：<code>name</code>。当遇到 <code>@sayhello</code> 时，引用的表达式会被展开，将参数的值内插到最终的表达式中。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@sayhello</span><span class="p">(</span><span class="s">&#34;human&#34;</span><span class="p">)</span>
<span class="n">Hello</span><span class="p">,</span> <span class="n">human</span>
</code></pre></div><p>我们可以使用函数 <a href="https://docs.julialang.org/en/v1/base/base/#Base.macroexpand">macroexpand</a> 查看引用的返回表达式（重要提示：这是调试宏的一个极其有用的工具）。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">macroexpand</span><span class="p">(</span><span class="n">Main</span><span class="p">,</span> <span class="o">:</span><span class="p">(</span><span class="nd">@sayhello</span><span class="p">(</span><span class="s">&#34;human&#34;</span><span class="p">))</span> <span class="p">)</span>
<span class="o">:</span><span class="p">(</span><span class="n">Main</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s">&#34;Hello, &#34;</span><span class="p">,</span> <span class="s">&#34;human&#34;</span><span class="p">))</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">typeof</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
<span class="kt">Expr</span>
</code></pre></div><p>我们可以看到，&ldquo;human&rdquo; 的字面值已经被插进了表达式中。</p>
<p>此外，还存在一个宏 <a href="https://docs.julialang.org/en/v1/base/base/#Base.@macroexpand">@macroexpand</a>，也许比 <code>macroexpand</code> 函数更方便一些。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@macroexpand</span> <span class="nd">@sayhello</span> <span class="s">&#34;human&#34;</span>
<span class="o">:</span><span class="p">(</span><span class="n">println</span><span class="p">(</span><span class="s">&#34;Hello, &#34;</span><span class="p">,</span> <span class="s">&#34;human&#34;</span><span class="p">))</span>
</code></pre></div><h3 id="等等为什么是宏">等等：为什么是宏？</h3>
<p>我们在前一节已经看到了一个函数 <code>f(::Expr...) -&gt; Expr</code>。其实，<a href="https://docs.julialang.org/en/v1/base/base/#Base.macroexpand">macroexpand</a> 也是这样一个函数。那么，为什么要有宏的存在呢？</p>
<p>宏是必要的，因为它们在代码解析时执行，因此，宏允许程序员在完整程序运行之前生成并包含自定义代码的片段。为了说明两者的区别，请考虑下面的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="k">macro</span> <span class="n">twostep</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
           <span class="n">println</span><span class="p">(</span><span class="s">&#34;I execute at parse time. The argument is: &#34;</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
           <span class="k">return</span> <span class="o">:</span><span class="p">(</span><span class="n">println</span><span class="p">(</span><span class="s">&#34;I execute at runtime. The argument is: &#34;</span><span class="p">,</span> <span class="o">$</span><span class="n">arg</span><span class="p">))</span>
       <span class="k">end</span>
<span class="nd">@twostep</span> <span class="p">(</span><span class="k">macro</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">macroexpand</span><span class="p">(</span><span class="n">Main</span><span class="p">,</span> <span class="o">:</span><span class="p">(</span><span class="nd">@twostep</span> <span class="o">:</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">);</span>
<span class="n">I</span> <span class="n">execute</span> <span class="n">at</span> <span class="n">parse</span> <span class="n">time</span><span class="o">.</span> <span class="n">The</span> <span class="n">argument</span> <span class="n">is</span><span class="o">:</span> <span class="o">:</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</code></pre></div><p>当调用 <a href="https://docs.julialang.org/en/v1/base/base/#Base.macroexpand">macroexpand</a> 时，会执行对 <a href="https://docs.julialang.org/en/v1/base/io-network/#Base.println">println</a> 的第一次调用。结果的表达式只包含第二个 <code>println</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">typeof</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
<span class="kt">Expr</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">ex</span>
<span class="o">:</span><span class="p">(</span><span class="n">println</span><span class="p">(</span><span class="s">&#34;I execute at runtime. The argument is: &#34;</span><span class="p">,</span> <span class="o">$</span><span class="p">(</span><span class="kt">Expr</span><span class="p">(</span><span class="ss">:copyast</span><span class="p">,</span> <span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="p">(</span><span class="kt">QuoteNode</span><span class="p">(</span><span class="o">:</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))))))))</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
<span class="n">I</span> <span class="n">execute</span> <span class="n">at</span> <span class="n">runtime</span><span class="o">.</span> <span class="n">The</span> <span class="n">argument</span> <span class="n">is</span><span class="o">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div><h3 id="宏调用">宏调用</h3>
<p>宏的调用有以下一般语法。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="nd">@name</span> <span class="n">expr1</span> <span class="n">expr2</span> <span class="o">...</span>
<span class="nd">@name</span><span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</code></pre></div><p>注意在宏名前有区别的 <code>@</code>，第一种形式的参数表达式之间没有逗号，第二种形式的 <code>@</code> 名后没有空格。两种样式不能混用。例如，下面的语法与上面的例子不同，它将元组 (expr1, expr2, &hellip;) 作为一个参数传递给宏。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="nd">@name</span> <span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</code></pre></div><p>在数组字面量（或解析）上调用宏的另一种方法是将两者并列，而不使用括号。在这种情况下，数组将是唯一输入宏的表达式。下面的语法是等价的（与 <code>@name [a b] * v</code> 不同）。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="nd">@name</span><span class="p">[</span><span class="n">a</span> <span class="n">b</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span>
<span class="nd">@name</span><span class="p">([</span><span class="n">a</span> <span class="n">b</span><span class="p">])</span> <span class="o">*</span> <span class="n">v</span>
</code></pre></div><p>需要强调的是，宏以表达式、字面值或符号的形式接收其参数。探索宏参数的一种方法是在宏体中调用 <a href="https://docs.julialang.org/en/v1/base/io-network/#Base.show-Tuple%7BIO,Any%7D">show</a> 函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="k">macro</span> <span class="n">showarg</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
           <span class="n">show</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
           <span class="c"># ... remainder of macro, returning an expression</span>
       <span class="k">end</span>
<span class="nd">@showarg</span> <span class="p">(</span><span class="k">macro</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@showarg</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="ss">:a</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@showarg</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="o">:</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@showarg</span><span class="p">(</span><span class="n">println</span><span class="p">(</span><span class="s">&#34;Yo!&#34;</span><span class="p">))</span>
<span class="o">:</span><span class="p">(</span><span class="n">println</span><span class="p">(</span><span class="s">&#34;Yo!&#34;</span><span class="p">))</span>
</code></pre></div><p>除了给定的参数列表之外，每个宏都会被传递额外的参数 <code>__source__</code> 和 <code>__module__</code>。</p>
<p>参数 <code>__source__</code> 提供了关于来自宏调用的 <code>@</code> 符号的解析器位置的信息（以 <code>LineNumberNode</code> 对象的形式）。这使得宏能够包含更好的错误诊断信息，并且通常被日志、字符串解析器宏和文档等使用，例如，也被用来实现 <a href="https://docs.julialang.org/en/v1/base/file/#Base.@__LINE__">@<strong>LINE</strong></a>、<a href="https://docs.julialang.org/en/v1/base/file/#Base.@__FILE__">@<strong>FILE</strong></a> 和 <a href="https://docs.julialang.org/en/v1/base/file/#Base.@__DIR__">@<strong>DIR</strong></a> 宏。</p>
<p>位置信息可以通过引用 <code>__source__.line</code> 和 <code>__source__.file</code> 来访问。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="k">macro</span> <span class="n">__LOCATION__</span><span class="p">();</span> <span class="k">return</span> <span class="kt">QuoteNode</span><span class="p">(</span><span class="n">__source__</span><span class="p">);</span> <span class="k">end</span>
<span class="nd">@__LOCATION__</span> <span class="p">(</span><span class="k">macro</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">dump</span><span class="p">(</span>
            <span class="nd">@__LOCATION__</span><span class="p">(</span>
       <span class="p">))</span>
<span class="kt">LineNumberNode</span>
  <span class="n">line</span><span class="o">:</span> <span class="kt">Int64</span> <span class="mi">2</span>
  <span class="n">file</span><span class="o">:</span> <span class="kt">Symbol</span> <span class="n">none</span>
</code></pre></div><p>参数 <code>__module__</code> 提供了关于宏调用的扩展上下文的信息（以 <code>Module</code> 对象的形式）。这允许宏查找上下文信息，如现有的绑定，或者将该值作为额外的参数插入到在当前模块中做自省的运行时函数调用中。</p>
<h3 id="构建一个高级宏">构建一个高级宏</h3>
<p>这里是 Julia 的 <a href="https://docs.julialang.org/en/v1/base/base/#Base.@assert">@assert</a> 宏的简化定义。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="k">macro</span> <span class="n">assert</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
           <span class="k">return</span> <span class="o">:</span><span class="p">(</span> <span class="o">$</span><span class="n">ex</span> <span class="o">?</span> <span class="nb">nothing</span> <span class="o">:</span> <span class="n">throw</span><span class="p">(</span><span class="kt">AssertionError</span><span class="p">(</span><span class="o">$</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">ex</span><span class="p">))))</span> <span class="p">)</span>
       <span class="k">end</span>
<span class="nd">@assert</span> <span class="p">(</span><span class="k">macro</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>
</code></pre></div><p>这个宏可以这样使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="mf">1.0</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span>
<span class="n">ERROR</span><span class="o">:</span> <span class="kt">AssertionError</span><span class="o">:</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div><p>宏调用在解析时扩展到它的返回结果。这就相当于写。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="mi">1</span> <span class="o">==</span> <span class="mf">1.0</span> <span class="o">?</span> <span class="nb">nothing</span> <span class="o">:</span> <span class="n">throw</span><span class="p">(</span><span class="kt">AssertionError</span><span class="p">(</span><span class="s">&#34;1 == 1.0&#34;</span><span class="p">))</span>
<span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="nb">nothing</span> <span class="o">:</span> <span class="n">throw</span><span class="p">(</span><span class="kt">AssertionError</span><span class="p">(</span><span class="s">&#34;1 == 0&#34;</span><span class="p">))</span>
</code></pre></div><p>也就是说，在第一次调用中，表达式 <code>:(1 == 1.0)</code> 被拼接到测试条件槽中，而 <code>string(:(1 == 1.0))</code> 的值被拼接到断言消息槽中。这样构造出来的整个表达式，就被放到了发生 <code>@assert</code> 宏调用的语法树中。然后在执行时，如果测试表达式评估为真，那么返回 <a href="https://docs.julialang.org/en/v1/base/constants/#Core.nothing">nothing</a>，而如果测试为假，则会引发一个错误，表明断言表达式是假的。注意，如果把这个写成函数就不行了，因为只有条件的值，不可能在错误信息中显示计算条件的表达式。</p>
<p>Julia Base 中 <code>@assert</code> 的实际定义比较复杂。它允许用户有选择地指定自己的错误信息，而不是只打印失败的表达式。就像在参数数可变的函数（<a href="https://docs.julialang.org/en/v1/manual/functions/#Varargs-Functions">Varargs Functions</a>）中一样，在最后一个参数后面用省略号来指定。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="k">macro</span> <span class="n">assert</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">msgs</span><span class="o">...</span><span class="p">)</span>
           <span class="n">msg_body</span> <span class="o">=</span> <span class="n">isempty</span><span class="p">(</span><span class="n">msgs</span><span class="p">)</span> <span class="o">?</span> <span class="n">ex</span> <span class="o">:</span> <span class="n">msgs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
           <span class="n">msg</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="n">msg_body</span><span class="p">)</span>
           <span class="k">return</span> <span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="n">ex</span> <span class="o">?</span> <span class="nb">nothing</span> <span class="o">:</span> <span class="n">throw</span><span class="p">(</span><span class="kt">AssertionError</span><span class="p">(</span><span class="o">$</span><span class="n">msg</span><span class="p">)))</span>
       <span class="k">end</span>
<span class="nd">@assert</span> <span class="p">(</span><span class="k">macro</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>
</code></pre></div><p>现在 <code>@assert</code> 有两种操作模式，取决于它接收到的参数数量！如果只有一个参数，那么 <code>msgs</code> 捕获的表达式元组将是空的，它的行为和上面的简单定义一样。如果只有一个参数，msgs 捕获的表达式元组将是空的，它的行为与上面的简单定义相同。但现在如果用户指定了第二个参数，它将被打印在消息正文中，而不是失败的表达式。你可以用 <a href="https://docs.julialang.org/en/v1/base/base/#Base.@macroexpand">@macroexpand</a> 宏来检查宏扩展的结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@macroexpand</span> <span class="nd">@assert</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
<span class="o">:</span><span class="p">(</span><span class="k">if</span> <span class="n">Main</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="n">Main</span><span class="o">.</span><span class="n">b</span>
        <span class="n">Main</span><span class="o">.</span><span class="nb">nothing</span>
    <span class="k">else</span>
        <span class="n">Main</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="n">Main</span><span class="o">.</span><span class="kt">AssertionError</span><span class="p">(</span><span class="s">&#34;a == b&#34;</span><span class="p">))</span>
    <span class="k">end</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@macroexpand</span> <span class="nd">@assert</span> <span class="n">a</span><span class="o">==</span><span class="n">b</span> <span class="s">&#34;a should equal b!&#34;</span>
<span class="o">:</span><span class="p">(</span><span class="k">if</span> <span class="n">Main</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="n">Main</span><span class="o">.</span><span class="n">b</span>
        <span class="n">Main</span><span class="o">.</span><span class="nb">nothing</span>
    <span class="k">else</span>
        <span class="n">Main</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="n">Main</span><span class="o">.</span><span class="kt">AssertionError</span><span class="p">(</span><span class="s">&#34;a should equal b!&#34;</span><span class="p">))</span>
    <span class="k">end</span><span class="p">)</span>
</code></pre></div><p>实际的 <code>@assert</code> 宏还可以处理另一种情况：如果除了打印 &ldquo;a should equal b&rdquo; 之外，我们还想打印它们的值呢？人们可能会天真地尝试在自定义消息中使用字符串插值，例如，<code>@assert a==b &quot;a ($a) should equal b ($b)!&quot;</code>，但这在上面的宏中不会像预期的那样工作。你能明白为什么吗？从<a href="https://docs.julialang.org/en/v1/manual/strings/#string-interpolation">字符串插值</a>回想一下，插值后的字符串会被改写成对<a href="https://docs.julialang.org/en/v1/base/strings/#Base.string">字符串</a>的调用。比较一下。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">typeof</span><span class="p">(</span><span class="o">:</span><span class="p">(</span><span class="s">&#34;a should equal b&#34;</span><span class="p">))</span>
<span class="kt">String</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">typeof</span><span class="p">(</span><span class="o">:</span><span class="p">(</span><span class="s">&#34;a (</span><span class="si">$a</span><span class="s">) should equal b (</span><span class="si">$b</span><span class="s">)!&#34;</span><span class="p">))</span>
<span class="kt">Expr</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">dump</span><span class="p">(</span><span class="o">:</span><span class="p">(</span><span class="s">&#34;a (</span><span class="si">$a</span><span class="s">) should equal b (</span><span class="si">$b</span><span class="s">)!&#34;</span><span class="p">))</span>
<span class="kt">Expr</span>
  <span class="n">head</span><span class="o">:</span> <span class="kt">Symbol</span> <span class="n">string</span>
  <span class="n">args</span><span class="o">:</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Any</span><span class="p">}((</span><span class="mi">5</span><span class="p">,))</span>
    <span class="mi">1</span><span class="o">:</span> <span class="kt">String</span> <span class="s">&#34;a (&#34;</span>
    <span class="mi">2</span><span class="o">:</span> <span class="kt">Symbol</span> <span class="n">a</span>
    <span class="mi">3</span><span class="o">:</span> <span class="kt">String</span> <span class="s">&#34;) should equal b (&#34;</span>
    <span class="mi">4</span><span class="o">:</span> <span class="kt">Symbol</span> <span class="n">b</span>
    <span class="mi">5</span><span class="o">:</span> <span class="kt">String</span> <span class="s">&#34;)!&#34;</span>
</code></pre></div><p>因此，现在宏不是在 <code>msg_body</code> 中得到一个普通的字符串，而是接收一个完整的表达式，这个表达式需要被评估，以便按照预期的方式显示。这可以直接拼接到返回的表达式中，作为<a href="https://docs.julialang.org/en/v1/base/strings/#Base.string">字符串</a>调用的一个参数；完整的实现请参见 <a href="https://github.com/JuliaLang/julia/blob/master/base/error.jl">error.jl</a>。</p>
<p><code>@assert</code> 宏很好地利用了拼接成引号的表达式，简化了宏体内部对表达式的操作。</p>
<h3 id="卫生宏">卫生宏</h3>
<p>在比较复杂的宏中会出现一个问题，那就是<a href="https://en.wikipedia.org/wiki/Hygienic_macro">卫生</a>问题。简而言之，宏必须确保它们在返回的表达式中引入的变量不会意外地与它们扩展到的周围代码中的现有变量发生冲突。相反，作为参数传入宏中的表达式往往要在周围代码的上下文中进行评估，与现有变量进行交互和修改。另一个关注点来自于一个事实，即一个宏可能会在与它被定义的模块不同的地方被调用。在这种情况下，我们需要确保所有的全局变量被解析到正确的模块中。与具有文本宏扩展的语言（如C语言）相比，Julia 已经有了很大的优势，因为它只需要考虑返回的表达式。所有其他的变量（比如上面 <code>@assert</code> 中的 <code>msg</code>）都遵循<a href="https://docs.julialang.org/en/v1/manual/variables-and-scoping/#scope-of-variables">正常的作用域块行为</a>。</p>
<p>为了证明这些问题，让我们考虑写一个 <code>@time</code> 宏，它接受一个表达式作为参数，记录时间，评估表达式，再次记录时间，打印前后时间的差值，然后以表达式的值作为其最终值。这个宏可能是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">macro</span> <span class="n">time</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">quote</span>
        <span class="k">local</span> <span class="n">t0</span> <span class="o">=</span> <span class="n">time_ns</span><span class="p">()</span>
        <span class="k">local</span> <span class="n">val</span> <span class="o">=</span> <span class="o">$</span><span class="n">ex</span>
        <span class="k">local</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">time_ns</span><span class="p">()</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&#34;elapsed time: &#34;</span><span class="p">,</span> <span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">/</span><span class="mf">1e9</span><span class="p">,</span> <span class="s">&#34; seconds&#34;</span><span class="p">)</span>
        <span class="n">val</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>在这里，我们希望 <code>t0</code>、<code>t1</code> 和 <code>val</code> 是私有的临时变量，我们希望 <code>time</code> 引用 Julia Base 中的 <a href="https://docs.julialang.org/en/v1/base/base/#Base.Libc.time-Tuple%7B%7D">time</a> 函数，而不是用户可能拥有的任何 <code>time</code> 变量（同样适用于 <code>println</code>）。想象一下，如果用户表达式 <code>ex</code> 也包含了对一个叫 <code>t0</code> 的变量的赋值，或者定义了自己的 <code>time</code> 变量，可能会出现的问题。我们可能会得到错误，或者神秘的不正确行为。</p>
<p>Julia 的宏扩展器用以下方式解决了这些问题。首先，宏结果中的变量被分为局部或全局。如果一个变量被分配给（而不是声明为全局）、声明为局部，或者被用作函数参数名，那么它被认为是局部的。否则，它被认为是全局变量。局部变量就会被重命名为唯一的（使用 <a href="https://docs.julialang.org/en/v1/base/base/#Base.gensym">gensym</a> 函数，生成新的符号），全局变量则在宏定义环境中解决。因此，上述两个问题都得到了处理；宏的局部变量不会与任何用户变量冲突，<code>time</code> 和 <code>println</code> 将引用 Julia Base 定义。</p>
<p>然而，仍然存在一个问题。考虑下面这个宏的使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">MyModule</span>
<span class="k">import</span> <span class="n">Base</span><span class="o">.</span><span class="nd">@time</span>

<span class="n">time</span><span class="p">()</span> <span class="o">=</span> <span class="o">...</span> <span class="c"># compute something</span>

<span class="nd">@time</span> <span class="n">time</span><span class="p">()</span>
<span class="k">end</span>
</code></pre></div><p>这里的用户表达式 <code>ex</code> 是对 <code>time</code> 的调用，但不是宏使用的那个 <code>time</code> 函数。它显然是指 <code>MyModule.time</code>。因此我们必须安排 <code>ex</code> 中的代码在宏调用环境中进行解析。这可以通过用 <a href="https://docs.julialang.org/en/v1/base/base/#Base.esc">esc</a> 对表达式进行&quot;转义&quot;来实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">macro</span> <span class="n">time</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="k">local</span> <span class="n">val</span> <span class="o">=</span> <span class="o">$</span><span class="p">(</span><span class="n">esc</span><span class="p">(</span><span class="n">ex</span><span class="p">))</span>
    <span class="o">...</span>
<span class="k">end</span>
</code></pre></div><p>以这种方式包装的表达式，宏扩展器不会管它，只需逐字粘贴到输出中即可。因此它将在宏调用环境中被解析。</p>
<p>在必要的时候，可以利用这种转义机制来&quot;违反&quot;卫生，以便引入或操作用户变量。例如，下面的宏在调用环境中将 <code>x</code> 设为零。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="k">macro</span> <span class="n">zerox</span><span class="p">()</span>
           <span class="k">return</span> <span class="n">esc</span><span class="p">(</span><span class="o">:</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">))</span>
       <span class="k">end</span>
<span class="nd">@zerox</span> <span class="p">(</span><span class="k">macro</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span> <span class="n">foo</span><span class="p">()</span>
           <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
           <span class="nd">@zerox</span>
           <span class="k">return</span> <span class="n">x</span> <span class="c"># is zero</span>
       <span class="k">end</span>
<span class="n">foo</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">()</span>
<span class="mi">0</span>
</code></pre></div><p>这种对变量的操作应谨慎使用，但偶尔也很方便。</p>
<p>掌握正确的卫生规则可能是一个艰巨的挑战。在使用宏之前，你可能需要考虑一个函数闭包是否足够。另一个有用的策略是将尽可能多的工作推迟到运行时。例如，许多宏简单地将其参数包裹在 QuoteNode 或其他类似的 <a href="https://docs.julialang.org/en/v1/base/base/#Core.Expr">Expr</a> 中。一些例子包括 <code>@task body</code>，它简单地返回 <code>schedule(Task(()-&gt; $body))</code>，以及 <code>@eval expr</code>，它简单地返回 <code>eval(QuoteNode(expr))</code>。</p>
<p>为了演示，我们可以将上面的 <code>@time</code> 例子重写为。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">macro</span> <span class="n">time</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">:</span><span class="p">(</span><span class="n">timeit</span><span class="p">(()</span> <span class="o">-&gt;</span> <span class="o">$</span><span class="p">(</span><span class="n">esc</span><span class="p">(</span><span class="n">expr</span><span class="p">))))</span>
<span class="k">end</span>
<span class="k">function</span> <span class="n">timeit</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time_ns</span><span class="p">()</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time_ns</span><span class="p">()</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&#34;elapsed time: &#34;</span><span class="p">,</span> <span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span><span class="o">/</span><span class="mf">1e9</span><span class="p">,</span> <span class="s">&#34; seconds&#34;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span>
<span class="k">end</span>
</code></pre></div><p>然而，我们不这样做是有充分的理由的：将 <code>expr</code> 包装在一个新的作用域块中（匿名函数）也会稍微改变表达式的含义（其中任何变量的作用域），同时我们希望 <code>@time</code> 可以使用，而对被包装的代码影响最小。</p>
<h3 id="宏和调度">宏和调度</h3>
<p>宏，就像 Julia 函数一样，是通用的。这意味着它们也可以有多个方法定义，这要归功于多重分派。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="k">macro</span> <span class="n">m</span> <span class="k">end</span>
<span class="nd">@m</span> <span class="p">(</span><span class="k">macro</span> <span class="n">with</span> <span class="mi">0</span> <span class="n">methods</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="k">macro</span> <span class="n">m</span><span class="p">(</span><span class="n">args</span><span class="o">...</span><span class="p">)</span>
           <span class="n">println</span><span class="p">(</span><span class="s">&#34;</span><span class="si">$</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">args</span><span class="p">))</span><span class="s"> arguments&#34;</span><span class="p">)</span>
       <span class="k">end</span>
<span class="nd">@m</span> <span class="p">(</span><span class="k">macro</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="k">macro</span> <span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
           <span class="n">println</span><span class="p">(</span><span class="s">&#34;Two arguments&#34;</span><span class="p">)</span>
       <span class="k">end</span>
<span class="nd">@m</span> <span class="p">(</span><span class="k">macro</span> <span class="n">with</span> <span class="mi">2</span> <span class="n">methods</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@m</span> <span class="s">&#34;asd&#34;</span>
<span class="mi">1</span> <span class="n">arguments</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@m</span> <span class="mi">1</span> <span class="mi">2</span>
<span class="n">Two</span> <span class="n">arguments</span>
</code></pre></div><p>然而我们应该记住，宏调度是基于交给宏的 AST 类型，而不是 AST 在运行时评估的类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="k">macro</span> <span class="n">m</span><span class="p">(</span><span class="o">::</span><span class="kt">Int</span><span class="p">)</span>
           <span class="n">println</span><span class="p">(</span><span class="s">&#34;An Integer&#34;</span><span class="p">)</span>
       <span class="k">end</span>
<span class="nd">@m</span> <span class="p">(</span><span class="k">macro</span> <span class="n">with</span> <span class="mi">3</span> <span class="n">methods</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@m</span> <span class="mi">2</span>
<span class="n">An</span> <span class="kt">Integer</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>
<span class="mi">2</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@m</span> <span class="n">x</span>
<span class="mi">1</span> <span class="n">arguments</span>
</code></pre></div><h2 id="代码生成">代码生成</h2>
<p>当需要大量重复的模板代码时，通常会以编程方式生成，以避免冗余。在大多数语言中，这需要一个额外的构建步骤，以及一个单独的程序来生成重复的代码。在 Julia 中，表达式插值和 <a href="https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.eval">eval</a> 允许这样的代码生成在程序执行的正常过程中进行。例如，考虑以下自定义类型</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">struct</span> <span class="kt">MyNumber</span>
    <span class="n">x</span><span class="o">::</span><span class="kt">Float64</span>
<span class="k">end</span>
<span class="c"># output</span>
</code></pre></div><p>我们想为其添加一些方法。我们可以在下面的循环中以编程的方式进行。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">for</span> <span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="ss">:sin</span><span class="p">,</span> <span class="ss">:cos</span><span class="p">,</span> <span class="ss">:tan</span><span class="p">,</span> <span class="ss">:log</span><span class="p">,</span> <span class="ss">:exp</span><span class="p">)</span>
    <span class="n">eval</span><span class="p">(</span><span class="k">quote</span>
        <span class="n">Base</span><span class="o">.$</span><span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="o">::</span><span class="kt">MyNumber</span><span class="p">)</span> <span class="o">=</span> <span class="n">MyNumber</span><span class="p">(</span><span class="o">$</span><span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
    <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>
<span class="c"># output</span>
</code></pre></div><p>现在我们可以用我们的自定义类型来使用这些函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">MyNumber</span><span class="p">(</span><span class="nb">π</span><span class="p">)</span>
<span class="n">MyNumber</span><span class="p">(</span><span class="mf">3.141592653589793</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">MyNumber</span><span class="p">(</span><span class="mf">1.2246467991473532e-16</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">MyNumber</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
</code></pre></div><p>这样一来，Julia 就像自己的<a href="https://en.wikipedia.org/wiki/Preprocessor">预处理器</a>一样，可以从语言内部生成代码。上面的代码可以使用 <code>:</code> 前缀引号的形式，写得稍显生硬。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">for</span> <span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="ss">:sin</span><span class="p">,</span> <span class="ss">:cos</span><span class="p">,</span> <span class="ss">:tan</span><span class="p">,</span> <span class="ss">:log</span><span class="p">,</span> <span class="ss">:exp</span><span class="p">)</span>
    <span class="n">eval</span><span class="p">(</span><span class="o">:</span><span class="p">(</span><span class="n">Base</span><span class="o">.$</span><span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="o">::</span><span class="kt">MyNumber</span><span class="p">)</span> <span class="o">=</span> <span class="n">MyNumber</span><span class="p">(</span><span class="o">$</span><span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">))))</span>
<span class="k">end</span>
</code></pre></div><p>不过，这种使用 <code>eval(quote(...))</code> 模式生成的语言内代码很常见，所以 Julia 自带了一个宏来缩写这种模式。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">for</span> <span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="ss">:sin</span><span class="p">,</span> <span class="ss">:cos</span><span class="p">,</span> <span class="ss">:tan</span><span class="p">,</span> <span class="ss">:log</span><span class="p">,</span> <span class="ss">:exp</span><span class="p">)</span>
    <span class="nd">@eval</span> <span class="n">Base</span><span class="o">.$</span><span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="o">::</span><span class="kt">MyNumber</span><span class="p">)</span> <span class="o">=</span> <span class="n">MyNumber</span><span class="p">(</span><span class="o">$</span><span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
<span class="k">end</span>
</code></pre></div><p><a href="https://docs.julialang.org/en/v1/base/base/#Base.@eval">@eval</a> 宏重写了这个调用，使之与上述较长版本的调用完全等同。对于较长的生成代码块，给 <a href="https://docs.julialang.org/en/v1/base/base/#Base.@eval">@eval</a> 的表达式参数可以是一个块。</p>
<pre><code class="language-juliaa" data-lang="juliaa">@eval begin
    # multiple lines
end
</code></pre><h2 id="非标准字符串字面值">非标准字符串字面值</h2>
<p>从 <a href="https://docs.julialang.org/en/v1/manual/strings/#non-standard-string-literals">Strings</a> 中回想一下，以标识符为前缀的字符串字元称为非标准字符串字元，其语义可能与未加前缀的字符串字面值不同。例如</p>
<p>r&rdquo;^\s*(?:#|$) &ldquo;产生一个正则表达式对象，而不是一个字符串。
b &ldquo;DATA\xff\u2200 &ldquo;是一个[68,65,84,65,255,226,136,128]的字节数组文字。
也许令人惊讶的是，这些行为并没有被硬编码到Julia解析器或编译器中。相反，它们是由一个通用机制提供的自定义行为，任何人都可以使用：前缀的字符串字元被解析为对特别命名的宏的调用。例如，正则表达式宏就如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">macro</span> <span class="n">r_str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="kt">Regex</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><p>就是这样。这个宏表示应该将字符串字词r&rdquo;^\s*(?:#|$) &ldquo;的字面内容传递给@r_str宏，并将扩展的结果放入字符串字词出现的语法树中。换句话说，表达式r&rdquo;^\s*(?:#|$) &ldquo;相当于将下面的对象直接放入语法树中。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="kt">Regex</span><span class="p">(</span><span class="s">&#34;^</span><span class="se">\\</span><span class="s">s*(?:#|</span><span class="se">\$</span><span class="s">)&#34;</span><span class="p">)</span>
</code></pre></div><p>字符串形式不仅更短、更方便，而且效率更高：由于正则表达式是编译的，而Regex对象实际上是在代码编译时创建的，所以编译只发生一次，而不是每次执行代码时。考虑一下如果正则表达式发生在循环中。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">for</span> <span class="n">line</span> <span class="o">=</span> <span class="n">lines</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="sr">&#34;^</span><span class="err">\</span><span class="sr">s*(?:#|$)&#34;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">===</span> <span class="nb">nothing</span>
        <span class="c"># non-comment</span>
    <span class="k">else</span>
        <span class="c"># comment</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>由于正则表达式r&rdquo;^/ds*(?:#|$) &ldquo;在解析这段代码时被编译并插入语法树中，所以该表达式只被编译一次，而不是每次循环执行时都被编译。为了在不使用宏的情况下实现这个目标，必须这样写这个循环。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">re</span> <span class="o">=</span> <span class="kt">Regex</span><span class="p">(</span><span class="s">&#34;^</span><span class="se">\\</span><span class="s">s*(?:#|</span><span class="se">\$</span><span class="s">)&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="o">=</span> <span class="n">lines</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">match</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">===</span> <span class="nb">nothing</span>
        <span class="c"># non-comment</span>
    <span class="k">else</span>
        <span class="c"># comment</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>此外，如果编译器不能确定regex对象在所有循环中都是恒定的，某些优化可能就无法实现，这就使得这个版本的效率仍然不如上面更方便的文字形式。当然，在有些情况下，非字面形式还是比较方便的：如果需要在正则表达式中插入一个变量，就必须采取这种比较啰嗦的方式；在正则表达式模式本身是动态的，有可能在每次循环迭代时发生变化的情况下，必须在每次迭代时构造一个新的正则表达式对象。然而，在绝大多数用例中，正则表达式并不是基于运行时数据来构造的。在这大多数情况下，将正则表达式写成编译时值的能力是非常宝贵的。</p>
<p>与非标准字符串字元一样，非标准命令字元也是使用命令字元语法的前缀变体存在的。命令字元custom<code>literal</code>被解析为@custom_cmd &ldquo;literal&rdquo;。Julia本身不包含任何非标准的命令字元，但包可以利用这种语法。除了语法不同和用_cmd后缀代替_str后缀外，非标准命令字元的行为与非标准字符串字元完全相同。</p>
<p>如果两个模块提供了名称相同的非标准字符串或命令字元，可以用模块名称来限定字符串或命令字元。例如，如果Foo和Bar都提供了非标准的字符串字元@x_str，那么可以写成Foo.x &ldquo;字元 &ldquo;或Bar.x &ldquo;字元 &ldquo;来区分两者。</p>
<p>用户定义字符串字元的机制是深刻的、强大的。不仅Julia的非标准字元用它来实现，而且命令字元语法（<code>echo &quot;Hello, $person&quot;</code>）也用下面这个看似无害的宏来实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">macro</span> <span class="n">cmd</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
    <span class="o">:</span><span class="p">(</span><span class="n">cmd_gen</span><span class="p">(</span><span class="o">$</span><span class="p">(</span><span class="n">shell_parse</span><span class="p">(</span><span class="n">str</span><span class="p">)[</span><span class="mi">1</span><span class="p">])))</span>
<span class="k">end</span>
</code></pre></div><p>当然，这个宏定义中使用的函数中隐藏着大量的复杂性，但它们只是函数，完全是用Julia编写的。你可以阅读它们的源码，并精确地看到它们的作用&ndash;它们所做的只是构造表达式对象，以便插入到你的程序的语法树中。</p>
<p>生成的函数</p>
<p>一个非常特殊的宏是@generated，它允许你定义所谓的生成函数。这些函数能够根据其参数的类型生成专门的代码，其灵活性和/或代码量比使用多重调度时更少。宏在解析时与表达式一起工作，不能访问其输入的类型，而生成函数在参数类型已知时得到扩展，但函数尚未编译。</p>
<p>生成函数声明不是执行一些计算或动作，而是返回一个引号的表达式，然后形成与参数类型相对应的方法的主体。当一个生成函数被调用时，它返回的表达式会被编译，然后运行。为了提高效率，通常会对结果进行缓存。而为了使之可推断，只有有限的语言子集可以使用。因此，生成函数提供了一种灵活的方式，将工作从运行时转移到编译时，但代价是对允许的构造有更大的限制。</p>
<p>在定义生成函数时，与普通函数有五个主要区别。</p>
<p>你用 @generated 宏来注释函数声明。这在AST中添加了一些信息，让编译器知道这是一个生成函数。
在生成函数的主体中，你只能访问参数的类型，而不能访问它们的值。
你不是计算一些东西或执行一些操作，而是返回一个引号的表达式，当它被评估时，就会执行你想要的东西。
生成函数只允许调用在生成函数定义之前定义的函数。(如果不遵守这一点，可能会得到引用未来世界时代函数的MethodErrors。)
生成的函数不得突变或观察任何非常态的全局状态（包括，例如，IO、锁、非本地字典或使用hasmethod）。这意味着它们只能读取全局常量，不能有任何副作用。换句话说，它们必须是完全纯粹的。由于实现上的限制，这也意味着它们目前不能定义闭包或生成器。
用一个例子来说明这一点是最简单的。我们可以将一个生成函数foo声明为</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@generated</span> <span class="k">function</span> <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
           <span class="n">Core</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
           <span class="k">return</span> <span class="o">:</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
       <span class="k">end</span>
<span class="n">foo</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>
</code></pre></div><p>请注意，函数体返回的是一个引号表达式，即:(x * x)，而不仅仅是x * x的值。</p>
<p>从调用者的角度来看，这和正则函数是一样的；事实上，你不必知道你调用的是正则函数还是生成函数。让我们来看看foo是如何表现的。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c"># note: output is from println() statement in the body</span>
<span class="kt">Int64</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">x</span>           <span class="c"># now we print x</span>
<span class="mi">4</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="s">&#34;bar&#34;</span><span class="p">);</span>
<span class="kt">String</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">y</span>
<span class="s">&#34;barbar&#34;</span>
</code></pre></div><p>所以，我们看到，在生成函数的主体中，x是传递的参数的类型，而生成函数返回的值，是我们从定义中返回的引用表达式的评估结果，现在的值是x。</p>
<p>如果我们用已经使用过的类型再次评估foo，会发生什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="mi">16</span>
</code></pre></div><p>注意，没有打印出Int64的结果。我们可以看到，这里只针对特定的参数类型集执行了一次生成函数的主体，结果被缓存。之后，对于本例来说，第一次调用时生成函数返回的表达式被重新用作方法体。但是，实际的缓存行为是一种实现定义的性能优化，所以过于依赖这种行为是无效的。</p>
<p>生成函数的次数可能只有一次，但也可能更频繁，或者看起来根本没有发生。因此，你永远不应该写一个有副作用的生成函数&ndash;副作用何时发生，多久发生一次，都是没有定义的。(这对宏来说也是如此&ndash;就像对宏一样，在生成函数中使用eval是一个标志，表明你做了一些错误的事情。) 然而，与宏不同的是，运行时系统无法正确处理对eval的调用，所以不允许使用它。</p>
<p>同样重要的是看@生成函数如何与方法重新定义交互。按照正确的@生成函数不能观察任何可突变的状态或引起任何全局状态的突变的原则，我们看到以下行为。观察生成函数不能调用任何在生成函数本身定义之前没有定义的方法。</p>
<p>最初f(x)有一个定义</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;original definition&#34;</span><span class="p">;</span>
</code></pre></div><p>定义其他使用f(x)的操作。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@generated</span> <span class="n">gen1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@generated</span> <span class="n">gen2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</code></pre></div><p>现在我们为f(x)添加一些新的定义。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Int</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;definition for Int&#34;</span><span class="p">;</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Type</span><span class="p">{</span><span class="kt">Int</span><span class="p">})</span> <span class="o">=</span> <span class="s">&#34;definition for Type{Int}&#34;</span><span class="p">;</span>
</code></pre></div><p>并比较这些结果有何不同。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="s">&#34;definition for Int&#34;</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="s">&#34;definition for Int&#34;</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">gen1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="s">&#34;original definition&#34;</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">gen2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="s">&#34;definition for Int&#34;</span>
</code></pre></div><p>生成函数的每个方法都有自己的定义函数视图。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@generated</span> <span class="n">gen1</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Real</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">gen1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="s">&#34;definition for Type{Int}&#34;</span>
</code></pre></div><p>上面的生成函数foo例子并没有做任何普通函数foo(x) = x * x不能做的事情（除了在第一次调用时打印类型，并产生较高的开销）。然而，生成函数的强大之处在于它能够根据传递给它的类型计算不同的引号表达式。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@generated</span> <span class="k">function</span> <span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
           <span class="k">if</span> <span class="kt">x</span> <span class="o">&lt;:</span> <span class="kt">Integer</span>
               <span class="k">return</span> <span class="o">:</span><span class="p">(</span><span class="n">x</span> <span class="o">^</span> <span class="mi">2</span><span class="p">)</span>
           <span class="k">else</span>
               <span class="k">return</span> <span class="o">:</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
           <span class="k">end</span>
       <span class="k">end</span>
<span class="n">bar</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="mi">16</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">(</span><span class="s">&#34;baz&#34;</span><span class="p">)</span>
<span class="s">&#34;baz&#34;</span>
</code></pre></div><p>(当然，这个人为的例子可以更容易地使用多个调度来实现&hellip;)</p>
<p>滥用这一点将破坏运行时系统并导致未定义的行为。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@generated</span> <span class="k">function</span> <span class="n">baz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
           <span class="k">if</span> <span class="n">rand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">.9</span>
               <span class="k">return</span> <span class="o">:</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
           <span class="k">else</span>
               <span class="k">return</span> <span class="o">:</span><span class="p">(</span><span class="s">&#34;boo!&#34;</span><span class="p">)</span>
           <span class="k">end</span>
       <span class="k">end</span>
<span class="n">baz</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>
</code></pre></div><p>由于生成的函数主体是非确定的，所以它的行为以及所有后续代码的行为都是未定义的。</p>
<p>不要抄袭这些例子!</p>
<p>这些例子希望对说明生成函数的工作方式有所帮助，包括在定义端和调用端；但是，不要复制它们，原因如下。</p>
<p>foo函数有副作用 (对Core.println的调用), 而这些副作用究竟何时发生, 多久发生一次, 或发生多少次, 都是没有定义的
bar函数解决了一个问题，而这个问题最好用多重调度来解决&ndash;定义bar(x) = x和bar(x::Integer) = x ^ 2会做同样的事情，但它既简单又快速。
baz函数是病态的
请注意，在生成的函数中不应该尝试的操作集是没有限制的，运行时系统目前只能检测到无效操作的一个子集。还有许多其他的操作会在不通知的情况下简单地破坏运行时系统，通常以微妙的方式与坏定义没有明显的联系。因为函数生成器是在推理过程中运行的，它必须尊重该代码的所有限制。</p>
<p>一些不应该尝试的操作包括。</p>
<p>缓存本地指针
以任何方式与Core.Compiler的内容或方法进行交互。
观察任何可变状态。</p>
<p>对生成的函数的推理可以在任何时候运行，包括在您的代码试图观察或突变此状态时。
占用任何锁。你调用的C代码可以在内部使用锁，（例如，调用malloc是没有问题的，即使大多数实现在内部需要锁），但不要试图在执行Julia代码时持有或获取任何锁。
调用在生成函数主体之后定义的任何函数。对于增量加载的预编译模块，这个条件是放宽的，允许调用模块中的任何函数。
好了，现在我们对生成函数的工作原理有了更好的理解，让我们用它们来构建一些更高级的（有效的）功能&hellip;</p>
<p>一个高级的例子</p>
<p>茱莉亚的基础库有一个内部的sub2ind函数，用来计算一个线性索引到n维数组中，基于n个多线性索引的集合，换句话说，就是计算可以用A[i]来索引到数组A中的索引i，而不是A[x,y,z,&hellip;]。一种可能的实现方式如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span> <span class="n">sub2ind_loop</span><span class="p">(</span><span class="n">dims</span><span class="o">::</span><span class="kt">NTuple</span><span class="p">{</span><span class="kt">N</span><span class="p">},</span> <span class="n">I</span><span class="o">::</span><span class="kt">Integer</span><span class="o">...</span><span class="p">)</span> <span class="k">where</span> <span class="kt">N</span>
           <span class="n">ind</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
           <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="n">👎1</span>
               <span class="n">ind</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">ind</span>
           <span class="k">end</span>
           <span class="k">return</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span>
       <span class="k">end</span>
<span class="n">sub2ind_loop</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">sub2ind_loop</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">4</span>
</code></pre></div><p>同样的事情也可以用递归来完成。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">sub2ind_rec</span><span class="p">(</span><span class="n">dims</span><span class="o">::</span><span class="kt">Tuple</span><span class="p">{})</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">sub2ind_rec</span><span class="p">(</span><span class="n">dims</span><span class="o">::</span><span class="kt">Tuple</span><span class="p">{},</span> <span class="n">i1</span><span class="o">::</span><span class="kt">Integer</span><span class="p">,</span> <span class="n">I</span><span class="o">::</span><span class="kt">Integer</span><span class="o">...</span><span class="p">)</span> <span class="o">=</span>
           <span class="n">i1</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">sub2ind_rec</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">I</span><span class="o">...</span><span class="p">)</span> <span class="o">:</span> <span class="n">throw</span><span class="p">(</span><span class="kt">BoundsError</span><span class="p">());</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">sub2ind_rec</span><span class="p">(</span><span class="n">dims</span><span class="o">::</span><span class="kt">Tuple</span><span class="p">{</span><span class="kt">Integer</span><span class="p">,</span> <span class="kt">Vararg</span><span class="p">{</span><span class="kt">Integer</span><span class="p">}},</span> <span class="n">i1</span><span class="o">::</span><span class="kt">Integer</span><span class="p">)</span> <span class="o">=</span> <span class="n">i1</span><span class="p">;</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">sub2ind_rec</span><span class="p">(</span><span class="n">dims</span><span class="o">::</span><span class="kt">Tuple</span><span class="p">{</span><span class="kt">Integer</span><span class="p">,</span> <span class="kt">Vararg</span><span class="p">{</span><span class="kt">Integer</span><span class="p">}},</span> <span class="n">i1</span><span class="o">::</span><span class="kt">Integer</span><span class="p">,</span> <span class="n">I</span><span class="o">::</span><span class="kt">Integer</span><span class="o">...</span><span class="p">)</span> <span class="o">=</span>
           <span class="n">i1</span> <span class="o">+</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">sub2ind_rec</span><span class="p">(</span><span class="n">Base</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="n">I</span><span class="o">...</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">sub2ind_rec</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">4</span>
</code></pre></div><p>这两种实现虽然不同，但本质上都是一样的：在数组的维度上进行运行时循环，将每个维度的偏移量收集到最后的索引中。</p>
<p>然而，我们在循环中所需要的所有信息都嵌入在参数的类型信息中。因此，我们可以利用生成函数将迭代移动到编译时；用编译器的说法，我们使用生成函数手动展开循环。身体变得几乎相同，但我们不是计算线性指数，而是建立一个计算指数的表达式。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@generated</span> <span class="k">function</span> <span class="n">sub2ind_gen</span><span class="p">(</span><span class="n">dims</span><span class="o">::</span><span class="kt">NTuple</span><span class="p">{</span><span class="kt">N</span><span class="p">},</span> <span class="n">I</span><span class="o">::</span><span class="kt">Integer</span><span class="o">...</span><span class="p">)</span> <span class="k">where</span> <span class="kt">N</span>
           <span class="n">ex</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">$</span><span class="n">N</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
           <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="n">👎1</span>
               <span class="n">ex</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">$</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dims</span><span class="p">[</span><span class="o">$</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="o">$</span><span class="n">ex</span><span class="p">)</span>
           <span class="k">end</span>
           <span class="k">return</span> <span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="n">ex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
       <span class="k">end</span>
<span class="n">sub2ind_gen</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="n">sub2ind_gen</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">4</span>
</code></pre></div><p>这将产生什么代码呢？</p>
<p>一个简单的方法是将主体提取到另一个（常规）函数中。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="nd">@generated</span> <span class="k">function</span> <span class="n">sub2ind_gen</span><span class="p">(</span><span class="n">dims</span><span class="o">::</span><span class="kt">NTuple</span><span class="p">{</span><span class="kt">N</span><span class="p">},</span> <span class="n">I</span><span class="o">::</span><span class="kt">Integer</span><span class="o">...</span><span class="p">)</span> <span class="k">where</span> <span class="kt">N</span>
           <span class="k">return</span> <span class="n">sub2ind_gen_impl</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">I</span><span class="o">...</span><span class="p">)</span>
       <span class="k">end</span>
<span class="n">sub2ind_gen</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>

<span class="n">julia</span><span class="o">&gt;</span> <span class="k">function</span> <span class="n">sub2ind_gen_impl</span><span class="p">(</span><span class="n">dims</span><span class="o">::</span><span class="kt">Type</span><span class="p">{</span><span class="kt">T</span><span class="p">},</span> <span class="n">I</span><span class="o">...</span><span class="p">)</span> <span class="k">where</span> <span class="kt">T</span> <span class="o">&lt;:</span> <span class="kt">NTuple</span><span class="p">{</span><span class="kt">N</span><span class="p">,</span><span class="kt">Any</span><span class="p">}</span> <span class="k">where</span> <span class="kt">N</span>
           <span class="n">length</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">N</span> <span class="o">||</span> <span class="k">return</span> <span class="o">:</span><span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="s">&#34;partial indexing is unsupported&#34;</span><span class="p">))</span>
           <span class="n">ex</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">$</span><span class="n">N</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
           <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="n">👎1</span>
               <span class="n">ex</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">$</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dims</span><span class="p">[</span><span class="o">$</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="o">$</span><span class="n">ex</span><span class="p">)</span>
           <span class="k">end</span>
           <span class="k">return</span> <span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="n">ex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
       <span class="k">end</span>
<span class="n">sub2ind_gen_impl</span> <span class="p">(</span><span class="n">generic</span> <span class="k">function</span> <span class="n">with</span> <span class="mi">1</span> <span class="n">method</span><span class="p">)</span>
</code></pre></div><p>现在我们可以执行sub2ind_gen_impl并检查它返回的表达式。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">julia</span><span class="o">&gt;</span> <span class="n">sub2ind_gen_impl</span><span class="p">(</span><span class="kt">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Int</span><span class="p">},</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
<span class="o">:</span><span class="p">(((</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div><p>所以，这里要用到的方法体根本不包含循环&ndash;只是索引到两个元组，乘法和加/减法。所有的循环都是在编译时进行的，我们完全避免了执行过程中的循环。因此，我们对每个类型只进行一次循环，在本例中，每N个类型只循环一次（除非在函数生成一次以上的边缘情况下&ndash;见上面的免责声明）。</p>
<p>可选生成的函数</p>
<p>生成函数可以在运行时实现高效率，但也有编译时间成本：每一个具体参数类型的组合都必须生成一个新的函数体。通常情况下，Julia能够编译 &ldquo;通用 &ldquo;版本的函数，这些函数将适用于任何参数，但对于生成函数，这是不可能的。这意味着大量使用生成函数的程序可能无法静态编译。</p>
<p>为了解决这个问题，语言提供了编写正常的、非生成函数的替代实现的语法。应用到上面的sub2ind例子中，会是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">function</span> <span class="n">sub2ind_gen</span><span class="p">(</span><span class="n">dims</span><span class="o">::</span><span class="kt">NTuple</span><span class="p">{</span><span class="kt">N</span><span class="p">},</span> <span class="n">I</span><span class="o">::</span><span class="kt">Integer</span><span class="o">...</span><span class="p">)</span> <span class="k">where</span> <span class="kt">N</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">!=</span> <span class="n">length</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
        <span class="n">throw</span><span class="p">(</span><span class="kt">ArgumentError</span><span class="p">(</span><span class="s">&#34;Number of dimensions must match number of indices.&#34;</span><span class="p">))</span>
    <span class="k">end</span>
    <span class="k">if</span> <span class="nd">@generated</span>
        <span class="n">ex</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">$</span><span class="n">N</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="n">👎1</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">$</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dims</span><span class="p">[</span><span class="o">$</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="o">$</span><span class="n">ex</span><span class="p">)</span>
        <span class="k">end</span>
        <span class="k">return</span> <span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="n">ex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="n">👎1</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">ind</span>
        <span class="k">end</span>
        <span class="k">return</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>在内部，这段代码创建了函数的两个实现：一个是生成的，其中使用了if @generated中的第一个块，另一个是正常的，其中使用了 else块。在if @generated块的then部分内部，代码的语义与其他生成函数相同：参数名指的是类型，代码应该返回一个表达式。可能会出现多个if @生成块，在这种情况下，生成的实现使用所有的then块，而备用的实现使用所有的else块。</p>
<p>注意，我们在函数的顶部添加了一个错误检查。这段代码在两个版本中都是通用的，并且在两个版本中都是运行时代码（它将被引用并作为生成版本的表达式返回）。这意味着局部变量的值和类型在代码生成时是不可用的&ndash;代码生成代码只能看到参数的类型。</p>
<p>在这种风格的定义中，代码生成功能本质上是一种可选的优化。编译器在方便的情况下会使用它，但其他情况下可能会选择使用正常的实现来代替。这种风格是首选，因为它允许编译器做出更多的决定，并以更多的方式编译程序，而且正常代码比代码生成代码更易读。但是，使用哪种实现取决于编译器的实现细节，所以两种实现的行为必须完全相同。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/flink" term="flink" label="Flink" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia" term="julia" label="Julia" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" term="julia-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" label="Julia 官方文档" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Julia 中的 REPL]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-21-repl-in-julia/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2020-08-21-repl-in-julia/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-21T00:00:00+08:00</published>
            <updated>2020-08-21T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>REPL in Julia</blockquote><h2 id="julia-repl">Julia REPL</h2>
<p>Julia 在 <code>julia</code> 可执行文件中内置了一个功能齐全的交互式命令行 REPL（read-eval-print loop）。除了允许快速、简单地评估 Julia 语句外，它还具有可搜索的历史记录、tab-补全、许多有用的键绑定以及专门的帮助和 <code>shell</code> 模式。REPL 可以通过简单地调用 <code>julia</code> 而不使用参数或双击可执行文件来启动。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ julia

               _
   _       _ _<span class="o">(</span>_<span class="o">)</span>_     <span class="p">|</span>  Documentation: https://docs.julialang.org
  <span class="o">(</span>_<span class="o">)</span>     <span class="p">|</span> <span class="o">(</span>_<span class="o">)</span> <span class="o">(</span>_<span class="o">)</span>    <span class="p">|</span>
   _ _   _<span class="p">|</span> <span class="p">|</span>_  __ _   <span class="p">|</span>  Type <span class="s2">&#34;?&#34;</span> <span class="k">for</span> help, <span class="s2">&#34;]?&#34;</span> <span class="k">for</span> Pkg help.
  <span class="p">|</span> <span class="p">|</span> <span class="p">|</span> <span class="p">|</span> <span class="p">|</span> <span class="p">|</span> <span class="p">|</span>/ _<span class="sb">`</span> <span class="p">|</span>  <span class="p">|</span>
  <span class="p">|</span> <span class="p">|</span> <span class="p">|</span>_<span class="p">|</span> <span class="p">|</span> <span class="p">|</span> <span class="p">|</span> <span class="o">(</span>_<span class="p">|</span> <span class="p">|</span>  <span class="p">|</span>  Version 1.5.0 <span class="o">(</span>2020-08-01<span class="o">)</span>
 _/ <span class="p">|</span><span class="se">\_</span>_<span class="s1">&#39;_|_|_|\__&#39;</span>_<span class="p">|</span>  <span class="p">|</span>  Official https://julialang.org/ release
<span class="p">|</span>__/                   <span class="p">|</span>


julia&gt;
</code></pre></div><p>要退出交互式会话，请键入 <code>^D</code> - 控制键与 <code>d</code> 键一起在空行上键入，或键入 <code>exit()</code> 后跟回车或回车键。REPL 会用一个横幅和 <code>julia&gt;</code> 提示来欢迎您。</p>
<h3 id="不同的提示模式">不同的提示模式</h3>
<h4 id="朱利安模式">朱利安模式</h4>
<p>REPL 有四种主要的操作模式。第一种也是最常见的是 Julian 提示。这是默认的操作模式；每个新行都以 <code>julia&gt;</code> 开始。在这里您可以输入 Julia 表达式。在输入完整的表达式后点击回车或回车将评估该条目并显示最后一个表达式的结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; string<span class="o">(</span><span class="m">1</span> + 2<span class="o">)</span>
<span class="s2">&#34;3&#34;</span>
</code></pre></div><p>在交互式工作中，有许多独特的有用功能。除了显示结果之外，REPL 还将结果绑定到变量 <code>ans</code> 上。行上的分号可以作为一个标志来抑制显示结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; string<span class="o">(</span><span class="m">3</span> * 4<span class="o">)</span><span class="p">;</span>

julia&gt; ans
<span class="s2">&#34;12&#34;</span>
</code></pre></div><p>在 Julia 模式下，REPL 支持称为提示粘贴(<em>prompt pasting</em>)的东西。当把以 <code>julia&gt;</code> 开头的文本粘贴到 REPL 中时，这个功能会被激活。在这种情况下，只有以 <code>julia&gt;</code> 开头的表达式会被解析，其他表达式会被删除。这使得您可以粘贴从 REPL 会话中复制的代码块，而无需清除提示和输出。这个功能默认是启用的，但可以通过 <code>REPL.enable_promptpaste(::Bool)</code> 来禁用或启用。如果启用了，您可以直接将本段上面的代码块粘贴到 REPL 中试试。这个功能在标准的 Windows 命令提示符上不起作用，因为它在检测粘贴发生时的局限性。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">using REPL
REPL.enable_promptpaste<span class="o">(</span><span class="nb">false</span><span class="o">)</span> <span class="c1"># 禁用 prompt pasting</span>
REPL.enable_promptpaste<span class="o">(</span><span class="nb">true</span><span class="o">)</span>  <span class="c1"># 启用 prompt pasting</span>
</code></pre></div><p>对象在 REPL 中使用带有特定 <a href="https://docs.julialang.org/en/v1/base/io-network/#Base.IOContext">IOContext</a> 的 <a href="https://docs.julialang.org/en/v1/base/io-network/#Base.show-Tuple%7BIO,Any%7D">show</a> 函数进行打印。特别是，<code>:limit</code> 属性被设置为 true。其他属性可以在某些 <code>show</code> 方法中接收一个默认值，如果它还没有被设置，比如 <code>:compact</code>。作为实验性功能，可以通过 <code>Base.active_repl.options.iocontext</code> 字典来指定 REPL 使用的属性（将值关联到属性）。例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; rand<span class="o">(</span>2, 2<span class="o">)</span>
2×2 Array<span class="o">{</span>Float64,2<span class="o">}</span>:
 0.8833    0.329197
 0.719708  0.59114

julia&gt; show<span class="o">(</span>IOContext<span class="o">(</span>stdout, :compact <span class="o">=</span>&gt; <span class="nb">false</span><span class="o">)</span>, <span class="s2">&#34;text/plain&#34;</span>, rand<span class="o">(</span>2, 2<span class="o">))</span>
 0.43540323669187075  0.15759787870609387
 0.2540832269192739   0.4597637838786053
julia&gt; Base.active_repl.options.iocontext<span class="o">[</span>:compact<span class="o">]</span> <span class="o">=</span> false<span class="p">;</span>

julia&gt; rand<span class="o">(</span>2, 2<span class="o">)</span>
2×2 Array<span class="o">{</span>Float64,2<span class="o">}</span>:
 0.2083967319174056  0.13330606013126012
 0.6244375177790158  0.9777957560761545
</code></pre></div><p>为了在启动时自动定义这个字典的值，可以使用 <code>~/.julia/config/startup.jl</code> 文件中的 <a href="https://docs.julialang.org/en/v1/stdlib/REPL/#Base.atreplinit"><code>atreplinit</code></a> 函数，例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">atreplinit</span><span class="p">()</span> <span class="k">do</span> <span class="n">repl</span>
    <span class="n">repl</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">iocontext</span><span class="p">[</span><span class="ss">:compact</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span>
<span class="k">end</span>
</code></pre></div><h4 id="帮助模式">帮助模式</h4>
<p>当光标在行首时，可以通过键入 <code>?</code> 来将提示变为帮助模式。Julia 将尝试打印帮助模式下输入的任何内容的帮助或文档。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; ? <span class="c1"># upon typing ?, the prompt changes (in place) to: help?&gt;</span>

help?&gt; string
search: string String Cstring Cwstring RevString randstring bytestring SubString

  string<span class="o">(</span>xs...<span class="o">)</span>

  Create a string from any values using the print <span class="k">function</span>.
</code></pre></div><p>也可以查询宏、类型和变量:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">help?&gt; @time
  @time

  A macro to execute an expression, printing the <span class="nb">time</span> it took to execute, the number of allocations,
  and the total number of bytes its execution caused to be allocated, before returning the value of the
  expression.

  See also @timev, @timed, @elapsed, and @allocated.

help?&gt; Int32
search: Int32 UInt32

  Int32 &lt;: Signed

  32-bit signed integer type.
</code></pre></div><p>按行首的退格键可以退出帮助模式。</p>
<h4 id="shell-模式">Shell 模式</h4>
<p>就像帮助模式对于快速访问文档很有用一样，另一个常见的任务是使用系统 shell 来执行系统命令。就像 <code>?</code> 进入帮助模式时一样, 在行首按下分号(<code>;</code>)会进入 shell 模式。而且可以在行首按退格键退出。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="p">;</span> <span class="c1"># upon typing ;, the prompt changes (in place) to: shell&gt;</span>

shell&gt; <span class="nb">echo</span> hello
hello
</code></pre></div><p>注意:</p>
<p>对于 Windows 用户来说，Julia 的 shell 模式不暴露 windows shell 命令。因此，这将会失败:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="p">;</span> <span class="c1"># upon typing ;, the prompt changes (in place) to: shell&gt;</span>

shell&gt; dir
ERROR: IOError: could not spawn <span class="sb">`</span>dir<span class="sb">`</span>: no such file or directory <span class="o">(</span>ENOENT<span class="o">)</span>
Stacktrace!
.......
</code></pre></div><p>不过，你可以像这样访问 PowerShell:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="p">;</span> <span class="c1"># upon typing ;, the prompt changes (in place) to: shell&gt;</span>

shell&gt; powershell
Windows PowerShell
Copyright <span class="o">(</span>C<span class="o">)</span> Microsoft Corporation. All rights reserved.
PS C:<span class="se">\U</span>sers<span class="se">\e</span>lm&gt;
</code></pre></div><p>&hellip;而且对 <code>cmd.exe</code> 的访问是这样的（见 <code>dir</code> 命令）:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="p">;</span> <span class="c1"># upon typing ;, the prompt changes (in place) to: shell&gt;</span>

shell&gt; cmd
Microsoft Windows <span class="o">[</span>version 10.0.17763.973<span class="o">]</span>
<span class="o">(</span>c<span class="o">)</span> <span class="m">2018</span> Microsoft Corporation. All rights reserved.
C:<span class="se">\U</span>sers<span class="se">\e</span>lm&gt;dir
 Volume in drive C has no label
 Volume Serial Number is 1643-0CD7
  Directory of C:<span class="se">\U</span>sers<span class="se">\e</span>lm

29/01/2020  22:15    &lt;DIR&gt;          .
29/01/2020  22:15    &lt;DIR&gt;          ..
02/02/2020  08:06    &lt;DIR&gt;          .atom
</code></pre></div><h4 id="搜索模式">搜索模式</h4>
<p>在上述所有模式中，执行的行数都会被保存到历史文件中，可以进行搜索。要在以前的历史记录中进行增量搜索，输入 <code>^R</code>&ndash;控制键和 <code>r</code> 键。提示符将变为(<code>reverse-i-search</code>):，当你输入搜索查询时，搜索查询将出现在引号中。当你输入更多的内容时，与查询相匹配的最新结果会动态地更新到冒号的右边。如果要使用相同的查询找到一个较早的结果，只需再次输入 <code>^R</code>。</p>
<p>就像 <code>^R</code> 是反向搜索一样，<code>^S</code> 是正向搜索，并提示(<code>i-search</code>):。两者可以相互结合使用，分别在上一个或下一个匹配结果中移动。</p>
<h3 id="键绑定">键绑定</h3>
<p>Julia REPL 大量使用了键绑定。上面已经介绍了几个控制键绑定（<code>^D</code> 用于退出，<code>^R</code> 和 <code>^S</code> 用于搜索），但还有更多。除了控制键，还有元键绑定。这些因平台不同而变化较大，但大多数终端默认使用 <code>alt-</code> 或 <code>option-</code> 按住键发送元键（也可以配置成这样），或者按 <code>Esc</code> 键，然后按键。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Keybinding</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Program control</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">^D</td>
<td style="text-align:left">退出(当缓存为空时)</td>
</tr>
<tr>
<td style="text-align:left">^C</td>
<td style="text-align:left">中断或取消</td>
</tr>
<tr>
<td style="text-align:left">^L</td>
<td style="text-align:left">清理控制台屏幕</td>
</tr>
<tr>
<td style="text-align:left">Return/Enter, <code>^J</code></td>
<td style="text-align:left">新行，如果完成了就执行</td>
</tr>
<tr>
<td style="text-align:left">meta-Return/Enter</td>
<td style="text-align:left">插入新行而不执行</td>
</tr>
<tr>
<td style="text-align:left"><code>?</code> 或 <code>;</code></td>
<td style="text-align:left">进入帮助或shell模式(当在行的开头时)</td>
</tr>
<tr>
<td style="text-align:left"><code>^R</code>, <code>^S</code></td>
<td style="text-align:left">递增式历史检索，如上所述</td>
</tr>
</tbody>
</table>
<h3 id="自定义键绑定">自定义键绑定</h3>
<p>Julia 的 REPL 键绑定可以通过向 <code>REPL.setup_interface</code> 传递一个字典来完全定制用户的偏好。这个字典的键可以是字符或字符串。键 &lsquo;*&rsquo; 指的是默认操作。控制加字符x的绑定用&quot;^x&quot;表示。Meta 加x可以写成 &ldquo;\M-x&rdquo; 或 &ldquo;\ex&rdquo;，Control 加 x 可以写成 &ldquo;\C-x&rdquo; 或 &ldquo;^x&rdquo;。自定义 keymap 的值必须是 nothing(表示输入应该被忽略)或接受签名的函数(<code>PromptState</code>, <code>AbstractREPL</code>, <code>Char</code>)。<code>REPL.setup_interface</code> 函数必须在 REPL 初始化之前被调用，通过在 atreplinit 注册操作。例如，要绑定上下方向键来移动历史记录而不需要前缀搜索，可以在 <code>~/.julia/config/startup.jl</code> 中放入以下代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">import</span> <span class="n">REPL</span>
<span class="k">import</span> <span class="n">REPL</span><span class="o">.</span><span class="n">LineEdit</span>

<span class="k">const</span> <span class="n">mykeys</span> <span class="o">=</span> <span class="kt">Dict</span><span class="p">{</span><span class="kt">Any</span><span class="p">,</span><span class="kt">Any</span><span class="p">}(</span>
    <span class="c"># Up Arrow</span>
    <span class="s">&#34;\e[A&#34;</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">o</span><span class="o">...</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">(</span><span class="n">LineEdit</span><span class="o">.</span><span class="n">edit_move_up</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">||</span> <span class="n">LineEdit</span><span class="o">.</span><span class="n">history_prev</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">LineEdit</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span><span class="p">)),</span>
    <span class="c"># Down Arrow</span>
    <span class="s">&#34;\e[B&#34;</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">o</span><span class="o">...</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">(</span><span class="n">LineEdit</span><span class="o">.</span><span class="n">edit_move_down</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">||</span> <span class="n">LineEdit</span><span class="o">.</span><span class="n">history_next</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">LineEdit</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span><span class="p">))</span>
<span class="p">)</span>

<span class="k">function</span> <span class="n">customize_keys</span><span class="p">(</span><span class="n">repl</span><span class="p">)</span>
    <span class="n">repl</span><span class="o">.</span><span class="n">interface</span> <span class="o">=</span> <span class="n">REPL</span><span class="o">.</span><span class="n">setup_interface</span><span class="p">(</span><span class="n">repl</span><span class="p">;</span> <span class="n">extra_repl_keymap</span> <span class="o">=</span> <span class="n">mykeys</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">atreplinit</span><span class="p">(</span><span class="n">customize_keys</span><span class="p">)</span>
</code></pre></div><p>用户应该参考 <code>LineEdit.jl</code> 来发现键输入的可用操作。</p>
<h3 id="tab-补全">Tab 补全</h3>
<p>在 REPL 的 Julian 和帮助模式下，可以输入函数或类型的前几个字符，然后按tab键，得到一个所有匹配的列表:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; stri<span class="o">[</span>TAB<span class="o">]</span>
stride     strides     string      strip

julia&gt; Stri<span class="o">[</span>TAB<span class="o">]</span>
StridedArray    StridedMatrix    StridedVecOrMat  StridedVector    String
</code></pre></div><p>tab 键也可以用来用它们的 Unicode 等价物替代 LaTeX 数学符号，并获得 LaTeX 匹配列表。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="se">\p</span>i<span class="o">[</span>TAB<span class="o">]</span>
julia&gt; π
<span class="nv">π</span> <span class="o">=</span> 3.1415926535897...

julia&gt; e<span class="se">\_</span>1<span class="o">[</span>TAB<span class="o">]</span> <span class="o">=</span> <span class="o">[</span>1,0<span class="o">]</span>
julia&gt; e₁ <span class="o">=</span> <span class="o">[</span>1,0<span class="o">]</span>
2-element Array<span class="o">{</span>Int64,1<span class="o">}</span>:
 <span class="m">1</span>
 <span class="m">0</span>

julia&gt; e<span class="se">\^</span>1<span class="o">[</span>TAB<span class="o">]</span> <span class="o">=</span> <span class="o">[</span><span class="m">1</span> 0<span class="o">]</span>
julia&gt; e¹ <span class="o">=</span> <span class="o">[</span><span class="m">1</span> 0<span class="o">]</span>
1×2 Array<span class="o">{</span>Int64,2<span class="o">}</span>:
 <span class="m">1</span>  <span class="m">0</span>

julia&gt; <span class="se">\s</span>qrt<span class="o">[</span>TAB<span class="o">]</span><span class="m">2</span>     <span class="c1"># √ is equivalent to the sqrt function</span>
julia&gt; √2
1.4142135623730951

julia&gt; <span class="se">\h</span>bar<span class="o">[</span>TAB<span class="o">](</span>h<span class="o">)</span> <span class="o">=</span> h / 2<span class="se">\p</span>i<span class="o">[</span>TAB<span class="o">]</span>
julia&gt; ħ<span class="o">(</span>h<span class="o">)</span> <span class="o">=</span> h / 2π
ħ <span class="o">(</span>generic <span class="k">function</span> with <span class="m">1</span> method<span class="o">)</span>

julia&gt; <span class="se">\h</span><span class="o">[</span>TAB<span class="o">]</span>
<span class="se">\h</span>at              <span class="se">\h</span>ermitconjmatrix  <span class="se">\h</span>kswarow          <span class="se">\h</span>rectangle
<span class="se">\h</span>atapprox        <span class="se">\h</span>exagon           <span class="se">\h</span>ookleftarrow     <span class="se">\h</span>rectangleblack
<span class="se">\h</span>bar             <span class="se">\h</span>exagonblack      <span class="se">\h</span>ookrightarrow    <span class="se">\h</span>slash
<span class="se">\h</span>eartsuit        <span class="se">\h</span>ksearow          <span class="se">\h</span>ouse             <span class="se">\h</span>space

julia&gt; <span class="nv">α</span><span class="o">=</span><span class="s2">&#34;\alpha[TAB]&#34;</span>   <span class="c1"># LaTeX completion also works in strings</span>
julia&gt; <span class="nv">α</span><span class="o">=</span><span class="s2">&#34;α&#34;</span>
</code></pre></div><p>完整的tab-补全列表可以在手册的 <a href="https://docs.julialang.org/en/v1/manual/unicode-input/#Unicode-Input-1">Unicode 输入</a>部分找到。</p>
<p>路径补全适用于字符串和 julia 的 shell 模式:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">path</span><span class="o">=</span><span class="s2">&#34;/[TAB]&#34;</span>
.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/
.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/
shell&gt; /<span class="o">[</span>TAB<span class="o">]</span>
.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/
.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/
</code></pre></div><p>Tab 补全可以帮助调查匹配输入参数的可用方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; max<span class="o">([</span>TAB<span class="o">]</span> <span class="c1"># All methods are displayed, not shown here due to size of the list</span>

julia&gt; max<span class="o">([</span>1, 2<span class="o">]</span>, <span class="o">[</span>TAB<span class="o">]</span> <span class="c1"># All methods where `Vector{Int}` matches as first argument</span>
max<span class="o">(</span>x, y<span class="o">)</span> in Base at operators.jl:215
max<span class="o">(</span>a, b, c, xs...<span class="o">)</span> in Base at operators.jl:281

julia&gt; max<span class="o">([</span>1, 2<span class="o">]</span>, max<span class="o">(</span>1, 2<span class="o">)</span>, <span class="o">[</span>TAB<span class="o">]</span> <span class="c1"># All methods matching the arguments.</span>
max<span class="o">(</span>x, y<span class="o">)</span> in Base at operators.jl:215
max<span class="o">(</span>a, b, c, xs...<span class="o">)</span> in Base at operators.jl:281
</code></pre></div><p>关键词也显示在 <code>;</code> 后面的建议方法中，见下面一行，其中 <code>limit</code> 和 <code>keepempty</code> 是关键词参数:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; split<span class="o">(</span><span class="s2">&#34;1 1 1&#34;</span>, <span class="o">[</span>TAB<span class="o">]</span>
split<span class="o">(</span>str::AbstractString<span class="p">;</span> limit, keepempty<span class="o">)</span> in Base at strings/util.jl:302
split<span class="o">(</span>str::T, splitter<span class="p">;</span> limit, keepempty<span class="o">)</span> where T&lt;:AbstractString in Base at strings/util.jl:277
</code></pre></div><p>方法的补全使用类型推断，因此即使参数是函数输出的，也能看到参数是否匹配。函数需要类型稳定，完成才能够删除不匹配的方法。</p>
<p>Tab 补全也可以帮助补全字段:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; import UUIDs

julia&gt; UUIDs.uuid<span class="o">[</span>TAB<span class="o">]</span>
uuid1        uuid4         uuid_version
</code></pre></div><p>也可以补全函数输出的字段:</p>
<pre><code class="language-sshell" data-lang="sshell">julia&gt; split(&quot;&quot;,&quot;&quot;)[1].[TAB]
lastindex  offset  string
</code></pre><p>函数输出的字段完成采用类型推断，只有在函数类型稳定的情况下，它才能建议字段。</p>
<p>字典键也可以用 tab 补全:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">foo</span> <span class="o">=</span> Dict<span class="o">(</span><span class="s2">&#34;qwer1&#34;</span><span class="o">=</span>&gt;1, <span class="s2">&#34;qwer2&#34;</span><span class="o">=</span>&gt;2, <span class="s2">&#34;asdf&#34;</span><span class="o">=</span>&gt;3<span class="o">)</span>
Dict<span class="o">{</span>String,Int64<span class="o">}</span> with <span class="m">3</span> entries:
  <span class="s2">&#34;qwer2&#34;</span> <span class="o">=</span>&gt; <span class="m">2</span>
  <span class="s2">&#34;asdf&#34;</span>  <span class="o">=</span>&gt; <span class="m">3</span>
  <span class="s2">&#34;qwer1&#34;</span> <span class="o">=</span>&gt; <span class="m">1</span>

julia&gt; foo<span class="o">[</span><span class="s2">&#34;q[TAB]
</span><span class="s2">
</span><span class="s2">&#34;</span>qwer1<span class="s2">&#34; &#34;</span>qwer2<span class="s2">&#34;
</span><span class="s2">julia&gt; foo[&#34;</span>qwer
</code></pre></div><h3 id="自定义颜色">自定义颜色</h3>
<p>Julia 和 REPL 所使用的颜色也是可以自定义的。要改变 Julia 提示符的颜色，您可以在您的 <code>~/.julia/config/startup.jl</code> 文件中添加以下内容，该文件应放在您的主目录中。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">function</span> <span class="n">customize_colors</span><span class="p">(</span><span class="n">repl</span><span class="p">)</span>
    <span class="n">repl</span><span class="o">.</span><span class="n">prompt_color</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">text_colors</span><span class="p">[</span><span class="ss">:cyan</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">atreplinit</span><span class="p">(</span><span class="n">customize_colors</span><span class="p">)</span>
</code></pre></div><p>可用的颜色键可以通过在 REPL 的帮助模式下输入 <code>Base.text_colors</code> 来查看。此外，对于支持 256 色的终端来说，整数 0 到 255 可以用作颜色键。</p>
<p>也可以通过在上面的 <code>customize_colors</code> 函数中设置 <code>repl</code> 的相应字段（分别为 <code>help_color</code>、<code>shell_color</code>、<code>input_color</code> 和 <code>answer_color</code>）来改变帮助和 shell 提示符以及输入和回答文字的颜色。对于后两者，要确保 <code>envcolors</code> 字段也设置为 false。</p>
<p>也可以通过使用 <code>Base.text_colors[:bold]</code> 作为颜色来应用粗体格式。例如，要用粗体字打印答案，可以使用下面的 <code>~/.julia/config/startup.jl</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">function</span> <span class="n">customize_colors</span><span class="p">(</span><span class="n">repl</span><span class="p">)</span>
    <span class="n">repl</span><span class="o">.</span><span class="n">envcolors</span> <span class="o">=</span> <span class="nb">false</span>
    <span class="n">repl</span><span class="o">.</span><span class="n">answer_color</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">text_colors</span><span class="p">[</span><span class="ss">:bold</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">atreplinit</span><span class="p">(</span><span class="n">customize_colors</span><span class="p">)</span>
</code></pre></div><p>你也可以通过设置适当的环境变量来定制用于渲染警告和信息消息的颜色。例如，要分别用洋红色、黄色和青色来渲染错误、警告和信息消息，你可以在 <code>~/.julia/config/startup.jl</code> 文件中添加以下内容:</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="nb">ENV</span><span class="p">[</span><span class="s">&#34;JULIA_ERROR_COLOR&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="ss">:magenta</span>
<span class="nb">ENV</span><span class="p">[</span><span class="s">&#34;JULIA_WARN_COLOR&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="ss">:yellow</span>
<span class="nb">ENV</span><span class="p">[</span><span class="s">&#34;JULIA_INFO_COLOR&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="ss">:cyan</span>
</code></pre></div><h3 id="terminalmenus">TerminalMenus</h3>
<p>TerminalMenus 是 Julia REPL 的一个子模块，可以在终端中实现小型、低配的交互式菜单。</p>
<h4 id="例子">例子</h4>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">import</span> <span class="n">REPL</span>
<span class="k">using</span> <span class="n">REPL</span><span class="o">.</span><span class="n">TerminalMenus</span>

<span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#34;apple&#34;</span><span class="p">,</span> <span class="s">&#34;orange&#34;</span><span class="p">,</span> <span class="s">&#34;grape&#34;</span><span class="p">,</span> <span class="s">&#34;strawberry&#34;</span><span class="p">,</span>
            <span class="s">&#34;blueberry&#34;</span><span class="p">,</span> <span class="s">&#34;peach&#34;</span><span class="p">,</span> <span class="s">&#34;lemon&#34;</span><span class="p">,</span> <span class="s">&#34;lime&#34;</span><span class="p">]</span>
</code></pre></div><h4 id="radiomenu">RadioMenu</h4>
<p>RadioMenu 允许用户从列表中选择一个选项。<code>request</code> 函数显示交互式菜单并返回所选选项的索引。如果用户按 &lsquo;q&rsquo; 或 <code>ctrl-c</code>，<code>request</code> 将返回 <code>-1</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="c"># `pagesize` is the number of items to be displayed at a time.</span>
<span class="c">#  The UI will scroll if the number of options is greater</span>
<span class="c">#   than the `pagesize`</span>
<span class="n">menu</span> <span class="o">=</span> <span class="n">RadioMenu</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">pagesize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

<span class="c"># `request` displays the menu and returns the index after the</span>
<span class="c">#   user has selected a choice</span>
<span class="n">choice</span> <span class="o">=</span> <span class="n">request</span><span class="p">(</span><span class="s">&#34;Choose your favorite fruit:&#34;</span><span class="p">,</span> <span class="n">menu</span><span class="p">)</span>

<span class="k">if</span> <span class="n">choice</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&#34;Your favorite fruit is &#34;</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="n">choice</span><span class="p">],</span> <span class="s">&#34;!&#34;</span><span class="p">)</span>
<span class="k">else</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&#34;Menu canceled.&#34;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><p>输出:</p>
<pre><code>Choose your favorite fruit:
^  grape
   strawberry
 &gt; blueberry
v  peach
Your favorite fruit is blueberry!
</code></pre><h4 id="multiselectmenu">MultiSelectMenu</h4>
<p>多重选择菜单（MultiSelectMenu）允许用户从一个列表中选择许多选择。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="c"># here we use the default `pagesize` 10</span>
<span class="n">menu</span> <span class="o">=</span> <span class="n">MultiSelectMenu</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>

<span class="c"># `request` returns a `Set` of selected indices</span>
<span class="c"># if the menu us canceled (ctrl-c or q), return an empty set</span>
<span class="n">choices</span> <span class="o">=</span> <span class="n">request</span><span class="p">(</span><span class="s">&#34;Select the fruits you like:&#34;</span><span class="p">,</span> <span class="n">menu</span><span class="p">)</span>

<span class="k">if</span> <span class="n">length</span><span class="p">(</span><span class="n">choices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&#34;You like the following fruits:&#34;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">choices</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&#34;  - &#34;</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">end</span>
<span class="k">else</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&#34;Menu canceled.&#34;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><p>输出:</p>
<pre><code>Select the fruits you like:
[press: d=done, a=all, n=none]
   [ ] apple
 &gt; [X] orange
   [X] grape
   [ ] strawberry
   [ ] blueberry
   [X] peach
   [ ] lemon
   [ ] lime
You like the following fruits:
  - orange
  - grape
  - peach
</code></pre><h4 id="customization--configuration">Customization / Configuration</h4>
<p>所有的界面定制都是通过关键字 <code>TerminalMenus.config()</code> 函数完成的。</p>
<h5 id="参数">参数</h5>
<ul>
<li><code>charset::Symbol=:na</code>: 要使用的ui字符(<code>:ascii</code> 或 <code>:unicode</code>); 被其他参数覆盖。</li>
<li><code>cursor::Char='&gt;'|'→'</code>: 光标使用的字符。</li>
<li><code>up_arrow::Char='^'|'↑'</code>: 用于向上箭头的字符。</li>
<li><code>down_arrow::Char='v'|'↓'</code>: 用于向下箭头的字符。</li>
<li><code>checked::String=&quot;[X]&quot;|&quot;✓&quot;</code>：用于检查的字符串。</li>
<li><code>unchecked::String=&quot;[]&quot;|&quot;⬚&quot;)</code>：用于未选中的字符串。</li>
<li><code>scroll::Symbol=:na</code>: 如果 <code>:wrap</code>，则将光标环绕在顶部和底部，如果 <code>:nowrap</code> 则不环绕光标。</li>
<li><code>supress_output::Bool=false</code>。用于测试。如果为真，菜单不会被打印到控制台。</li>
<li><code>ctrl_c_interrupt::Bool=true</code>: 如果为假，在 <code>^C</code> 时返回空，如果为真，在 <code>^C</code> 时抛出 InterruptException()。</li>
</ul>
<h4 id="例子-1">例子</h4>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">menu</span> <span class="o">=</span> MultiSelectMenu<span class="o">(</span>options, <span class="nv">pagesize</span><span class="o">=</span>5<span class="o">)</span><span class="p">;</span>

julia&gt; request<span class="o">(</span>menu<span class="o">)</span> <span class="c1"># ASCII is used by default</span>
<span class="o">[</span>press: <span class="nv">d</span><span class="o">=</span><span class="k">done</span>, <span class="nv">a</span><span class="o">=</span>all, <span class="nv">n</span><span class="o">=</span>none<span class="o">]</span>
   <span class="o">[</span> <span class="o">]</span> apple
   <span class="o">[</span>X<span class="o">]</span> orange
   <span class="o">[</span> <span class="o">]</span> grape
 &gt; <span class="o">[</span>X<span class="o">]</span> strawberry
v  <span class="o">[</span> <span class="o">]</span> blueberry
Set<span class="o">([</span>4, 2<span class="o">])</span>

julia&gt; TerminalMenus.config<span class="o">(</span><span class="nv">charset</span><span class="o">=</span>:unicode<span class="o">)</span>

julia&gt; request<span class="o">(</span>menu<span class="o">)</span>
<span class="o">[</span>press: <span class="nv">d</span><span class="o">=</span><span class="k">done</span>, <span class="nv">a</span><span class="o">=</span>all, <span class="nv">n</span><span class="o">=</span>none<span class="o">]</span>
   ⬚ apple
   ✓ orange
   ⬚ grape
 → ✓ strawberry
↓  ⬚ blueberry
Set<span class="o">([</span>4, 2<span class="o">])</span>

julia&gt; TerminalMenus.config<span class="o">(</span><span class="nv">checked</span><span class="o">=</span><span class="s2">&#34;YEP!&#34;</span>, <span class="nv">unchecked</span><span class="o">=</span><span class="s2">&#34;NOPE&#34;</span>, <span class="nv">cursor</span><span class="o">=</span><span class="s1">&#39;⧐&#39;</span><span class="o">)</span>

julia&gt; request<span class="o">(</span>menu<span class="o">)</span>
<span class="o">[</span>press: <span class="nv">d</span><span class="o">=</span><span class="k">done</span>, <span class="nv">a</span><span class="o">=</span>all, <span class="nv">n</span><span class="o">=</span>none<span class="o">]</span>
   NOPE apple
   YEP! orange
   NOPE grape
 ⧐ YEP! strawberry
↓  NOPE blueberry
Set<span class="o">([</span>4, 2<span class="o">])</span>
</code></pre></div><h3 id="参考">参考</h3>
<p><a href="https://docs.julialang.org/en/v1/stdlib/REPL/#Base.atreplinit">Base.atreplinit</a></p>
<blockquote>
<p>atreplinit(f)</p>
</blockquote>
<p>注册一个单参数函数，在交互式会话中，在 REPL 接口初始化之前被调用；这对自定义接口很有用。f 的参数是 REPL 对象。这个函数应该在 <code>~/.julia/config/startup.jl</code> 初始化文件中调用。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/julia" term="julia" label="Julia" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia" term="julia" label="Julia" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" term="julia-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" label="Julia 官方文档" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Julia 中的 模块]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-05-modules-in-julia/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-04-pkg-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的 Pkg" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-04-dates-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的日期和时间" />
                <link href="https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 语言学习笔记" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-05-modules-in-julia/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-05T00:00:00+08:00</published>
            <updated>2020-08-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Modules</blockquote><h1 id="模块">模块</h1>
<p>Julia 中的模块是独立的变量工作空间，即它们引入了一个新的全局作用域。它们在语法上是有分界的，在 <code>module Name ... end</code> 里面。模块允许您创建顶层定义（也就是全局变量），而不用担心您的代码与别人的代码一起使用时的名称冲突。在一个模块中，你可以控制哪些来自其他模块的名字是可见的（通过导入），并指定哪些名字是要公开的（通过导出）。</p>
<p>下面的例子展示了模块的主要功能。这个例子并不是为了运行，而是为了说明问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">MyModule</span>
<span class="k">using</span> <span class="n">Lib</span>

<span class="k">using</span> <span class="n">BigLib</span><span class="o">:</span> <span class="n">thing1</span><span class="p">,</span> <span class="n">thing2</span>

<span class="k">import</span> <span class="n">Base</span><span class="o">.</span><span class="n">show</span>

<span class="k">export</span> <span class="n">MyType</span><span class="p">,</span> <span class="n">foo</span>

<span class="k">struct</span> <span class="kt">MyType</span>
    <span class="n">x</span>
<span class="k">end</span>

<span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="n">x</span>
<span class="n">foo</span><span class="p">(</span><span class="n">a</span><span class="o">::</span><span class="kt">MyType</span><span class="p">)</span> <span class="o">=</span> <span class="n">bar</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">show</span><span class="p">(</span><span class="n">io</span><span class="o">::</span><span class="kt">IO</span><span class="p">,</span> <span class="n">a</span><span class="o">::</span><span class="kt">MyType</span><span class="p">)</span> <span class="o">=</span> <span class="n">print</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&#34;MyType </span><span class="si">$</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="s">&#34;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><p>需要注意的是，这个样式并不是要在模块的正文中缩进，因为这通常会导致整个文件被缩进。</p>
<p>这个模块定义了一个 <code>MyType</code> 类型和两个函数。函数 <code>foo</code> 和 <code>MyType</code> 类型是导出的，因此可以导入到其他模块中。函数 <code>bar</code> 是 <code>MyModule</code> 的私有函数。</p>
<p><code>using Lib</code> 语句意味着将有一个名为 <code>Lib</code> 的模块可以根据需要解析名称。当遇到一个全局变量在当前模块中没有定义时，系统会在 <code>Lib</code> 导出的变量中搜索它，如果在那里找到了，就会导入它。这意味着在当前模块内对该全局的所有使用都将解析为该变量在 <code>Lib</code> 中的定义。</p>
<p><code>using BigLib: thing1, thing2</code> 语句，只将标识符 <code>thing1</code> 和 <code>thing2</code> 从模块 <code>BigLib</code> 中带入作用域。如果这些名称指的是函数，那么将不允许向它们添加方法（你只能 &ldquo;使用 &ldquo;它们，而不是扩展它们）。</p>
<p><code>import</code> 关键字支持与 <code>using</code> 相同的语法。<code>import</code> 与 <code>using</code> 的不同之处在于，使用 <code>import</code> 导入的函数可以用新的方法进行扩展。</p>
<p>在上面的 <code>MyModule</code> 中，我们想给标准的 <code>show</code> 函数添加一个方法，所以我们必须写 <code>import Base.show</code>。只有通过 <code>using</code> 才能看到名字的函数不能被扩展。</p>
<p>一旦一个变量通过 <code>using</code> 或 <code>import</code> 变得可见，一个模块就不能创建自己的同名变量。导入的变量是只读的，分配给全局变量总是会影响到当前模块所拥有的变量，否则会引发错误。</p>
<h2 id="模块使用情况概述">模块使用情况概述</h2>
<p>要加载一个模块，可以使用两个主要的关键词：<code>using</code> 和 <code>import</code>。要了解它们的区别，请看下面的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">MyModule</span>

<span class="k">export</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

<span class="n">x</span><span class="p">()</span> <span class="o">=</span> <span class="s">&#34;x&#34;</span>
<span class="n">y</span><span class="p">()</span> <span class="o">=</span> <span class="s">&#34;y&#34;</span>
<span class="n">p</span><span class="p">()</span> <span class="o">=</span> <span class="s">&#34;p&#34;</span>

<span class="k">end</span>
</code></pre></div><p>在这个模块中，我们导出了 <code>x</code> 和 <code>y</code> 函数(用关键字 <code>export</code>)，也有非导出的函数 <code>p</code>，有几种不同的方法可以将 <code>Module</code> 及其内部函数加载到当前的工作空间中。</p>
<table>
<thead>
<tr>
<th style="text-align:left">导入命令</th>
<th style="text-align:left">带入带作用域中的东西</th>
<th style="text-align:left">可用于方法扩展</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>using MyModule</code></td>
<td style="text-align:left">所有导出的名字(<code>x</code> 和 <code>y</code>), <code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
<td style="text-align:left"><code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
</tr>
<tr>
<td style="text-align:left"><code>using MyModule: x, p</code></td>
<td style="text-align:left"><code>x</code> 和 <code>p</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>import MyModule</code></td>
<td style="text-align:left"><code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
<td style="text-align:left"><code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
</tr>
<tr>
<td style="text-align:left"><code>import MyModule.x, MyModule.p</code></td>
<td style="text-align:left"><code>x</code> 和 <code>p</code></td>
<td style="text-align:left"><code>x</code> 和 <code>p</code></td>
</tr>
<tr>
<td style="text-align:left"><code>import MyModule: x, p</code></td>
<td style="text-align:left"><code>x</code> 和 <code>p</code></td>
<td style="text-align:left"><code>x</code> 和 <code>p</code></td>
</tr>
</tbody>
</table>
<h2 id="模块和文件">模块和文件</h2>
<p>文件和文件名大多与模块无关，模块只与模块表达式有关。一个模块可以有多个文件，一个文件可以有多个模块。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">Foo</span>

<span class="n">include</span><span class="p">(</span><span class="s">&#34;file1.jl&#34;</span><span class="p">)</span>
<span class="n">include</span><span class="p">(</span><span class="s">&#34;file2.jl&#34;</span><span class="p">)</span>

<span class="k">end</span>
</code></pre></div><p>在不同的模块中包含相同的代码，提供了类似 mixin 的行为。人们可以使用这一点来用不同的基础定义来运行相同的代码，例如，通过使用某些操作符的&quot;安全&quot;版本来测试代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">Normal</span>
<span class="n">include</span><span class="p">(</span><span class="s">&#34;mycode.jl&#34;</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">module</span> <span class="n">Testing</span>
<span class="n">include</span><span class="p">(</span><span class="s">&#34;safe_operators.jl&#34;</span><span class="p">)</span>
<span class="n">include</span><span class="p">(</span><span class="s">&#34;mycode.jl&#34;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><h2 id="标准模块">标准模块</h2>
<p>There are three important standard modules:</p>
<p><a href="https://docs.julialang.org/en/v1/base/base/#Core">Core</a> 包含&quot;内置于&quot;语言中的所有功能。
<a href="https://docs.julialang.org/en/v1/base/base/#Base">Base</a> 包含几乎在所有情况下都有用的基本功能。
<a href="https://docs.julialang.org/en/v1/base/base/#Main">Main</a> 是当 Julia 被启动时的顶级模块和当前模块。</p>
<h2 id="默认的顶层定义和裸模块">默认的顶层定义和裸模块</h2>
<p>除了 <code>using Base</code> 之外，模块还自动包含 <a href="https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.eval">eval</a>和 <a href="https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.include">include</a> 函数的定义，这些函数在该模块的全局作用域内评估表达式/文件。</p>
<p>如果不想要这些默认的定义，可以使用关键字 <a href="https://docs.julialang.org/en/v1/base/base/#baremodule">baremodule</a> 来代替定义模块（注意： <code>Core</code> 仍然是导入的，如上所述）。以 <code>baremodule</code> 来说，一个标准的模块是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">baremodule</span> <span class="n">Mod</span>

<span class="k">using</span> <span class="n">Base</span>

<span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">Core</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">Mod</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">include</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="n">Mod</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="o">...</span>

<span class="k">end</span>
</code></pre></div><h2 id="相对和绝对模块路径">相对和绝对模块路径</h2>
<p>给定 <code>using Foo</code> 语句，系统会查询内部的顶层模块表，寻找一个名为 <code>Foo</code> 的模块。如果该模块不存在，系统会尝试 <code>require(:Foo)</code>，这通常会导致从安装的包中加载代码。</p>
<p>然而，有些模块包含子模块，这意味着你有时需要访问一个非顶层模块。有两种方法可以做到这一点。第一种是使用绝对路径，例如 <code>using Base.Sort</code>。第二种是使用相对路径，这样可以更容易地导入当前模块的子模块或其任何一个外层模块。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">Parent</span>

<span class="k">module</span> <span class="n">Utils</span>
<span class="o">...</span>
<span class="k">end</span>

<span class="k">using</span> <span class="o">.</span><span class="n">Utils</span>

<span class="o">...</span>
<span class="k">end</span>
</code></pre></div><p>这里模块 <code>Parent</code> 包含一个子模块 <code>Utils</code>，<code>Parent</code> 中的代码希望 <code>Utils</code> 的内容可见。这可以通过在 <code>using</code> 路径中使用点号来实现。添加更多的前导点号会使模块的层次结构上升。例如，<code>using ..Utils</code> 会在 <code>Parent</code> 的外层模块中查找<code>Utils</code>，而不是在 <code>Parent</code> 本身中查找。</p>
<p>注意相对导入限定符只在使用和导入语句中有效。</p>
<h2 id="命名空间杂项">命名空间杂项</h2>
<p>如果一个名字是限定的(例如 <code>Base.sin</code>)，那么即使它没有被导出，也可以被访问。这在调试时往往很有用。它也可以通过使用限定名作为函数名来添加方法。但是，由于会产生语法上的歧义，如果你想给不同模块中的一个函数添加方法，而这个函数的名称只包含符号，例如一个运算符，<code>Base.+</code>，你必须使用 <code>Base.:+</code> 来引用它。如果运算符的长度超过一个字符，你必须用括号把它括起来，比如 <code>Base.:(==)</code>。</p>
<p>在导入和导出语句中，宏的名称用 <code>@</code> 书写，例如 <code>import Mod.@mac</code>。其他模块中的宏可以用 <code>Mod.@mac</code> 或 <code>@Mod.mac</code> 来调用。</p>
<p>语法 <code>M.x = y</code> 不能用于分配其他模块中的全局，全局分配总是模块-局部的。</p>
<p>变量名可以通过声明为 <code>global x</code> 来 &ldquo;保留&quot;而不分配给它，这样可以防止加载后初始化的 globals 的名称冲突。</p>
<h2 id="模块初始化和预编译">模块初始化和预编译</h2>
<p>大型模块可能需要几秒钟的时间来加载，因为执行一个模块中的所有语句往往需要编译大量的代码。Julia 创建了模块的预编译缓存来减少这个时间。</p>
<p>当使用 <code>import</code> 或 <code>using</code> 加载模块时，会自动创建并使用增量的预编译模块文件。这将导致它在第一次导入时自动编译。另外，您也可以手动调用 <a href="https://docs.julialang.org/en/v1/base/base/#Base.compilecache">Base.compilecache(modulename)</a>。由此产生的缓存文件将存储在 <code>DEPOT_PATH[1]/compiled/</code> 中。随后，只要模块的任何依赖关系发生变化，模块就会在 <code>using</code> 或 <code>import</code> 时自动重新编译；依赖关系是指导入的模块、Julia 构建的模块、包含的文件，或者模块文件中 <a href="https://docs.julialang.org/en/v1/base/base/#Base.include_dependency">include_dependency(path)</a> 声明的显式依赖关系。</p>
<p>对于文件依赖，通过检查由 <code>include</code> 加载的文件或由 <code>include_dependency</code> 显式添加的文件的修改时间(mtime)是否保持不变，或者是否等于被截断到最接近秒的修改时间(以适应无法以亚秒级精度复制 mtime 的系统)来确定变化。它还考虑到在 <code>require</code> 中搜索逻辑选择的文件路径是否与创建预编译文件的路径匹配。它还会考虑到已经加载到当前进程中的一组依赖关系，即使这些模块的文件发生变化或消失，也不会重新编译这些模块，以避免在运行系统和预编译缓存之间产生不兼容的情况。</p>
<p>如果你知道某个模块预编译你的模块是不安全的（例如，出于下面描述的原因之一），你应该在模块文件中加上 <code>__precompile__(false)</code>（通常放在顶部）。这将导致 <code>Base.compilecache</code> 抛出一个错误，并将导致 <code>using</code> / <code>import</code> 直接将其加载到当前进程中而跳过预编译和缓存。这也因此阻止了该模块被任何其他预编译模块导入。</p>
<p>您可能需要注意创建增量共享库时固有的某些行为，在编写模块时可能需要注意。例如，外部状态不会被保存。为了适应这一点，明确地将任何必须在运行时发生的初始化步骤与可以在编译时发生的步骤分开。为此，Julia 允许您在您的模块中定义一个 <code>__init__()</code> 函数来执行任何必须在运行时发生的初始化步骤。这个函数在编译时不会被调用（<code>--output-*</code>）。实际上，你可以假设它在代码的生命周期中只运行一次。当然，如果有必要的话，你可以手动调用它，但是默认情况下，你可以假设这个函数处理的是本地机器的计算状态，它不需要&ndash;甚至不应该&ndash;在编译后的镜像中捕获。它将在模块被加载到一个进程后被调用，包括如果它被加载到增量编译中(<code>--output-incremental=yes</code>)，但如果它被加载到一个完整的编译进程中，则不会被调用。</p>
<p>特别是，如果你在一个模块中定义了一个 <code>function __init__()</code>，那么 Julia 将在模块被加载后（例如通过 <code>import</code>、<code>using</code> 或 <code>require</code>）在运行时第一次立即调用 <code>__init__()</code>（也就是说，<code>__init__</code> 只被调用一次，而且是在模块中的所有语句被执行后才被调用）。因为它是在模块完全导入之后被调用的，所以任何子模块或其它导入的模块都会在外层模块的 <code>__init__</code> 之前调用它们的 <code>__init__</code> 函数。</p>
<p><code>__init__</code> 的两个典型用途是调用外部 C 库的运行时初始化函数和初始化涉及外部库返回指针的全局常量。例如，假设我们正在调用一个 C 库 <code>libfoo</code>，它要求我们在运行时调用 <code>foo_init()</code> 初始化函数。假设我们还想定义一个全局常量 <code>foo_data_ptr</code>，用来存放 <code>libfoo</code> 定义的 <code>void *foo_data()</code> 函数的返回值&ndash;这个常量必须在运行时（而不是在编译时）初始化，因为指针地址会随着运行而改变。你可以通过在你的模块中定义下面的 <code>__init__</code> 函数来实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">const</span> <span class="n">foo_data_ptr</span> <span class="o">=</span> <span class="kt">Ref</span><span class="p">{</span><span class="kt">Ptr</span><span class="p">{</span><span class="kt">Cvoid</span><span class="p">}}(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">function</span> <span class="n">__init__</span><span class="p">()</span>
    <span class="k">ccall</span><span class="p">((</span><span class="ss">:foo_init</span><span class="p">,</span> <span class="ss">:libfoo</span><span class="p">),</span> <span class="kt">Cvoid</span><span class="p">,</span> <span class="p">())</span>
    <span class="n">foo_data_ptr</span><span class="p">[]</span> <span class="o">=</span> <span class="k">ccall</span><span class="p">((</span><span class="ss">:foo_data</span><span class="p">,</span> <span class="ss">:libfoo</span><span class="p">),</span> <span class="kt">Ptr</span><span class="p">{</span><span class="kt">Cvoid</span><span class="p">},</span> <span class="p">())</span>
    <span class="nb">nothing</span>
<span class="k">end</span>
</code></pre></div><p>请注意，我们完全可以在函数内部定义一个全局，比如 <code>__init__</code>；这是使用动态语言的优势之一。但是通过在全局作用域内定义一个常量，我们可以确保编译器知道这个类型，并允许它生成更好的优化代码。显然，你的模块中任何其他依赖于 <code>foo_data_ptr</code> 的 globals 也必须在 <code>__init__</code> 中初始化。</p>
<p>涉及大多数不是由 <a href="https://docs.julialang.org/en/v1/base/c/#ccall">ccall</a> 产生的 Julia 对象的常量不需要放在 <code>__init__</code> 中：它们的定义可以被预编译并从缓存的模块映像中加载。这包括像数组这样复杂的堆分配对象。然而，任何返回原始指针值的例程都必须在运行时调用，以便预编译工作（<a href="https://docs.julialang.org/en/v1/base/c/#Core.Ptr">Ptr</a> 对象将变成空指针，除非它们被隐藏在 <a href="https://docs.julialang.org/en/v1/base/base/#Base.isbits">isbits</a> 对象中）。这包括 Julia 函数 <code>cfunction</code> 和 <a href="https://docs.julialang.org/en/v1/base/c/#Base.pointer">pointer</a> 的返回值。</p>
<p>字典和集合类型，或者一般来说任何依赖于 <code>hash(key)</code> 方法输出的东西，都是比较棘手的情况。在常见的情况下，键是数字、字符串、符号、范围、<code>Expr</code> 或这些类型的组合（通过数组、元组、集合、对等），它们可以安全地进行预编译。然而，对于其他一些关键类型，如 <code>Function</code> 或 <code>DataType</code> 和通用的用户定义类型，在这些类型中，你没有定义 <code>hash</code> 方法，回退 <code>hash</code> 方法取决于对象的内存地址（通过它的 <code>objectid</code>），因此可能会在运行时改变。如果你有这些键类型之一，或者如果你不确定，为了安全起见，你可以在你的 <code>__init__</code> 函数中初始化这个字典。或者，你也可以使用 <a href="https://docs.julialang.org/en/v1/base/collections/#Base.IdDict">IdDict</a> 字典类型，它由预编译特别处理，所以在编译时初始化是安全的。</p>
<p>在使用预编译时，保持对编译阶段和执行阶段的清晰认识很重要。在这种模式下，往往会更清楚地认识到 Julia 是一个允许执行任意 Julia 代码的编译器，而不是一个同时生成编译代码的独立解释器。</p>
<p>其他已知的潜在故障情况包括。</p>
<ol>
<li>全局计数器（例如，用于试图唯一识别对象）。考虑以下代码片段。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">mutable struct</span> <span class="kt">UniquedById</span>
    <span class="n">myid</span><span class="o">::</span><span class="kt">Int</span>
    <span class="k">let</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">UniquedById</span><span class="p">()</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>虽然这段代码的目的是给每个实例一个唯一的 id，但计数器的值是在编译结束时记录的。这个增量编译模块的所有后续使用将从同一个计数器值开始。</p>
<p>请注意，<code>objectid</code>（通过哈希内存指针工作）也有类似的问题（参见下面关于 <code>Dict</code> 用法的说明）。</p>
<p>一种替代方法是使用宏来捕获 <a href="https://docs.julialang.org/en/v1/base/base/#Base.@__MODULE__">@<strong>MODULE</strong></a>，并将其与当前的计数器值一起单独存储，然而，重新设计代码使其不依赖于这个全局状态可能会更好。</p>
<ol start="2">
<li>
<p>关联集合(比如 <code>Dict</code> 和 <code>Set</code>)需要在 <code>__init__</code> 中重新洗牌(将来可能会提供一个机制来注册一个初始化函数)。</p>
</li>
<li>
<p>根据编译时的副作用在加载时持续存在。例如：修改其他 Julia 模块中的数组或其他变量；维护打开的文件或设备的句柄；存储其他系统资源（包括内存）的指针。</p>
</li>
<li>
<p>通过直接引用而不是通过它的查找路径，从另一个模块创建意外的全局状态&quot;副本&rdquo;。例如，（在全局作用域内）。</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="c">#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#</span>
<span class="c"># instead use accessor functions:</span>
<span class="n">getstdout</span><span class="p">()</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="nb">stdout</span> <span class="cm">#= best option =#</span>
<span class="c"># or move the assignment into the runtime:</span>
<span class="n">__init__</span><span class="p">()</span> <span class="o">=</span> <span class="k">global</span> <span class="n">mystdout</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="nb">stdout</span> <span class="cm">#= also works =#</span>
</code></pre></div><p>对预编译代码时可以进行的操作进行了一些额外的限制，以帮助用户避免其他错误行为的情况。</p>
<ol>
<li>
<p>调用 <a href="https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.eval">eval</a> 引起另一个模块的副作用。当增量预编译标志被设置时，这也会导致发出警告。</p>
</li>
<li>
<p>在 <code>__init__()</code> 被启动后，从本地作用域调用 <code>global const</code> 语句(参见问题 <code>#12010</code>，计划为此增加一个错误)</p>
</li>
<li>
<p>在进行增量预编译时，替换一个模块是一个运行时错误。</p>
</li>
</ol>
<p>还有几点需要注意。</p>
<ol>
<li>
<p>在对源文件本身进行修改之后，不会进行代码重载/缓存无效化（包括通过 <code>Pkg.update</code>），而且在 <code>Pkg.rm</code> 之后也不会进行清理。</p>
</li>
<li>
<p>预编译不考虑重塑数组的内存共享行为 (每个视图都有自己的副本)</p>
</li>
<li>
<p>期待文件系统在编译时和运行时之间保持不变，例如 <a href="https://docs.julialang.org/en/v1/base/file/#Base.@__FILE__">@<strong>FILE</strong></a>/<code>source_path()</code> 在运行时查找资源，或者 BinDeps 的 <code>@checked_lib</code> 宏。有时这是不可避免的。然而，在可能的情况下，在编译时将资源复制到模块中是一个很好的做法，这样它们就不需要在运行时被找到。</p>
</li>
<li>
<p><code>WeakRef</code> 对象和 finalizers 目前还没有被序列化器正确处理（这将在即将发布的版本中得到修正）。</p>
</li>
<li>
<p>通常最好避免捕获对内部元数据对象实例的引用，如 <code>Method</code>、<code>MethodInstance</code>、<code>MethodTable</code>、<code>TypeMapLevel</code>、<code>TypeMapEntry</code> 以及这些对象的字段，因为这可能会混淆序列化器，可能不会导致你想要的结果。这样做不一定会出错，但你只需要做好准备，系统会尝试复制其中的一些对象，并为其他对象创建一个唯一的实例。</p>
</li>
</ol>
<p>在模块开发过程中，有时关闭增量预编译是很有帮助的。命令行标志 <code>--compiled-modules={yes|no}</code> 可以让你开启或关闭模块预编译。当 Julia 以 <code>--compiled-modules=no</code> 启动时，当加载模块和模块依赖时，编译缓存中的序列化模块会被忽略。<code>Base.compilecache</code> 仍然可以被手动调用。这个命令行标志的状态被传递给 <code>Pkg.build</code>，以便在安装、更新和显式构建包时禁用自动预编译触发。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia" term="julia" label="julia" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/module" term="module" label="module" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Julia 中的 Pkg]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-04-pkg-in-julia/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-04-dates-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的日期和时间" />
                <link href="https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 语言学习笔记" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-04-pkg-in-julia/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-04T00:00:00+08:00</published>
            <updated>2020-08-04T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Pkg</blockquote><h2 id="进入-pkg-模式">进入 Pkg 模式</h2>
<p>Pkg 是 Julia 中包管理工具。Pkg 来自于 REPL, 在 Julia 的 REPL 中按下 <code>]</code> 就进入 Pkg REPL 了。要回到 Julia REPL, 按退格键或 <code>^C</code>。</p>
<h2 id="使用-pkg">使用 Pkg</h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">add JSON              <span class="c1"># 添加一个 package</span>
add JSON StaticArrays <span class="c1"># 添加多个 package</span>
rm JSON               <span class="c1"># 移除一个 package</span>
rm JSON StaticArrays  <span class="c1"># 移除多个 package</span>
add https://github.com/JuliaLang/Example.jl <span class="c1"># 添加一个未注册的 package</span>
rm Example            <span class="c1"># 按名字移除 package</span>
update Example        <span class="c1"># 升级一个已安装的 package</span>
update                <span class="c1"># 升级所有已安装的 package</span>
</code></pre></div><h2 id="environments">environments</h2>
<p>你可能已经注意到 Pkg REPL 提示符前面的 <code>(@v1.5)</code> 字符串了。这里的  <code>(@v1.5)</code> 就是激活环境(<strong>active environment</strong>)。激活环境是能被诸如 <code>add</code>、<code>rm</code> 和 <code>update</code> 等 Pkg 命令修改的环境。</p>
<p>我们可以设置一个新的激活环境用于实验。要设置激活环境, 使用 <code>activate</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>@v1.5<span class="o">)</span> pkg&gt; activate tutorial
Activating new environment at <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span>
</code></pre></div><p><code>~/tutorial/Project.toml</code> 是激活环境的项目文件。项目文件是 Pkg 存储环境的元数据的地方。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; status
Status <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span> <span class="o">(</span>empty project<span class="o">)</span>
</code></pre></div><p>现在这个新的环境是空的, 我们添加一个 package 观察下:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; add Example
   Updating registry at <span class="sb">`</span>~/.julia/registries/General<span class="sb">`</span>
   Updating git-repo <span class="sb">`</span>https://github.com/JuliaRegistries/General.git<span class="sb">`</span>
  Resolving package versions...
    Cloning <span class="o">[</span>7876af07-990d-54b4-ab0e-23690620f79a<span class="o">]</span> Example from https://github.com/JuliaLang/Example.jl.git
  Installed Example ─ v0.5.3
Updating <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> + Example v0.5.3
Updating <span class="sb">`</span>~/tutorial/Manifest.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> + Example v0.5.3
</code></pre></div><p>用 <code>status</code> 命令查看激活环境的信息:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; status
Status <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> Example v0.5.3
</code></pre></div><p>使用 <code>develop</code> 命令设置 <code>Example</code> package 的 一个 <code>git clone</code>, 以供我们修改这个本地仓库:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; develop --local Example
    Cloning git-repo <span class="sb">`</span>https://github.com/JuliaLang/Example.jl.git<span class="sb">`</span>
  Resolving package versions...
Updating <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> ~ Example v0.5.3 ⇒ v0.5.4 <span class="sb">`</span>dev/Example<span class="sb">`</span>
Updating <span class="sb">`</span>~/tutorial/Manifest.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> ~ Example v0.5.3 ⇒ v0.5.4 <span class="sb">`</span>dev/Example<span class="sb">`</span>
</code></pre></div><p>用 <code>;</code> 切换到 shell 模式, 用 vi 修改 <code>~/tutorial/dev/Example/src/Example.jl</code> 文件, 增加一个 <code>plusone</code> 函数, 保存。</p>
<p>在 Julia 的 REPL 中, 导入修改后的 <code>Example</code> package:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; import Example
<span class="o">[</span> Info: Precompiling Example <span class="o">[</span>7876af07-990d-54b4-ab0e-23690620f79a<span class="o">]</span>

julia&gt; Example.plusone<span class="o">(</span>1<span class="o">)</span>
<span class="m">2</span>

julia&gt; Example.plusone<span class="o">(</span>4<span class="o">)</span>
<span class="m">5</span>
</code></pre></div><p>可以看到我们添加的函数生效了, 这样就很方便我们添加测试新功能。如果我们已经不再需要本地的 <code>Example</code> 了, 需要使用 <code>free</code> 命令以停止使用本地克隆的 package, 转而使用已注册版本代替:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; free Example
  Resolving package versions...
Updating <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> ~ Example v0.5.4 <span class="sb">`</span>dev/Example<span class="sb">`</span> ⇒ v0.5.3
Updating <span class="sb">`</span>~/tutorial/Manifest.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> ~ Example v0.5.4 <span class="sb">`</span>dev/Example<span class="sb">`</span> ⇒ v0.5.3
</code></pre></div><p>如果已经用 <code>tutorial</code> 做完实验了, 可以使用不带参数的 <code>activate</code> 回到默认环境:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; activate
 Activating environment at <span class="sb">`</span>~/.julia/environments/v1.5/Project.toml<span class="sb">`</span>

<span class="o">(</span>@v1.5<span class="o">)</span> pkg&gt; 
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia" term="julia" label="julia" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/pkg" term="pkg" label="pkg" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Julia 中的日期和时间]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-04-dates-in-julia/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-04-pkg-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的 Pkg" />
                <link href="https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 语言学习笔记" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-04-dates-in-julia/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-04T00:00:00+08:00</published>
            <updated>2020-08-04T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Dates in Julia</blockquote><h1 id="dates-模块的加载和使用">Dates 模块的加载和使用</h1>
<p>在 Julia 的 Pkg REPL 中, 输入 <code>add Dates</code> 添加 Dates 模块。回到 Julia 的 REPL 中, 输入:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; using Dates

julia&gt; DateTime<span class="o">(</span>2020<span class="o">)</span>
2020-01-01T00:00:00

julia&gt; typeof<span class="o">(</span>DateTime<span class="o">(</span>2020<span class="o">))</span>
DateTime

julia&gt; DateTime<span class="o">(</span>2020,8,1<span class="o">)</span>
2020-08-01T00:00:00

julia&gt; DateTime<span class="o">(</span>2020,8,1,12<span class="o">)</span>
2020-08-01T12:00:00

julia&gt; DateTime<span class="o">(</span>2020,8,1,12,30<span class="o">)</span>
2020-08-01T12:30:00

julia&gt; DateTime<span class="o">(</span>2020,8,1,12,30,59<span class="o">)</span>
2020-08-01T12:30:59

julia&gt; DateTime<span class="o">(</span>2020,8,1,12,30,59, 999<span class="o">)</span>
2020-08-01T12:30:59.999

julia&gt; Date<span class="o">(</span>2020, 8<span class="o">)</span>
2020-08-01

julia&gt; Date<span class="o">(</span>2020, 8, 1<span class="o">)</span>
2020-08-01

julia&gt; Date<span class="o">(</span>Dates.Year<span class="o">(</span>2020<span class="o">)</span>,Dates.Month<span class="o">(</span>8<span class="o">)</span>,Dates.Day<span class="o">(</span>1<span class="o">))</span>
2020-08-01

julia&gt; Date<span class="o">(</span>Dates.Month<span class="o">(</span>8<span class="o">)</span>,Dates.Year<span class="o">(</span>2020<span class="o">))</span>
2020-08-01
</code></pre></div><h1 id="date-和-datetime-的算术操作">Date 和 DateTime 的算术操作</h1>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">dt</span> <span class="o">=</span> Date<span class="o">(</span>2012,2,29<span class="o">)</span>
2012-02-29

julia&gt; <span class="nv">dt2</span> <span class="o">=</span> Date<span class="o">(</span>2000,2,1<span class="o">)</span>
2000-02-01

julia&gt; dump<span class="o">(</span>dt<span class="o">)</span>
Date
  instant: Dates.UTInstant<span class="o">{</span>Day<span class="o">}</span>
    periods: Day
      value: Int64 <span class="m">734562</span>

julia&gt; dump<span class="o">(</span>dt2<span class="o">)</span>
Date
  instant: Dates.UTInstant<span class="o">{</span>Day<span class="o">}</span>
    periods: Day
      value: Int64 <span class="m">730151</span>

julia&gt; dt &gt; dt2
<span class="nb">true</span>

julia&gt; dt !<span class="o">=</span> dt2
<span class="nb">true</span>

julia&gt; dt + dt2
ERROR: MethodError: no method matching +<span class="o">(</span>::Date, ::Date<span class="o">)</span>
<span class="o">[</span>...<span class="o">]</span>

julia&gt; dt * dt2
ERROR: MethodError: no method matching *<span class="o">(</span>::Date, ::Date<span class="o">)</span>
<span class="o">[</span>...<span class="o">]</span>

julia&gt; dt / dt2
ERROR: MethodError: no method matching /<span class="o">(</span>::Date, ::Date<span class="o">)</span>

julia&gt; dt - dt2
<span class="m">4411</span> days

julia&gt; typeof<span class="o">(</span>dt - dt2<span class="o">)</span>
Day

julia&gt; dt2 - dt
-4411 days

julia&gt; <span class="nv">dt</span> <span class="o">=</span> DateTime<span class="o">(</span>2012,2,29<span class="o">)</span>
2012-02-29T00:00:00

julia&gt; <span class="nv">dt2</span> <span class="o">=</span> DateTime<span class="o">(</span>2000,2,1<span class="o">)</span>
2000-02-01T00:00:00

julia&gt; dt - dt2
<span class="m">381110400000</span> milliseconds

julia&gt; typeof<span class="o">(</span>dt - dt2<span class="o">)</span>
Millisecond
</code></pre></div><h1 id="访问器函数">访问器函数</h1>
<p>因为 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.Date">Date</a> 和 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateTime">DateTime</a> 类型被存储为单个 <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Int64">Int64</a> 值，所以日期部分或字段可以通过访问器函数进行检索。小写访问器函数以整数形式返回字段。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">t</span> <span class="o">=</span> Date<span class="o">(</span>2014, 1, 31<span class="o">)</span>
2014-01-31

julia&gt; Dates.year<span class="o">(</span>t<span class="o">)</span>
<span class="m">2014</span>

julia&gt; Dates.month<span class="o">(</span>t<span class="o">)</span>
<span class="m">1</span>

julia&gt; Dates.week<span class="o">(</span>t<span class="o">)</span>
<span class="m">5</span>

julia&gt; Dates.day<span class="o">(</span>t<span class="o">)</span>
<span class="m">31</span>
</code></pre></div><p>而专有形式返回相应 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.Period">Period</a> 类型中的相同值。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.Year<span class="o">(</span>t<span class="o">)</span>
<span class="m">2014</span> years

julia&gt; Dates.Day<span class="o">(</span>t<span class="o">)</span>
<span class="m">31</span> days
</code></pre></div><p>Julia 还提供了复合方法，因为在同时需要多个字段的情况下，这些方法提供了一种效率衡量标准。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.yearmonth<span class="o">(</span>t<span class="o">)</span>
<span class="o">(</span>2014, 1<span class="o">)</span>

julia&gt; Dates.monthday<span class="o">(</span>t<span class="o">)</span>
<span class="o">(</span>1, 31<span class="o">)</span>

julia&gt; Dates.yearmonthday<span class="o">(</span>t<span class="o">)</span>
<span class="o">(</span>2014, 1, 31<span class="o">)</span>
</code></pre></div><p>也可以访问底层 <code>UTInstant</code> 或整数值。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; dump<span class="o">(</span>t<span class="o">)</span>
Date
  instant: Dates.UTInstant<span class="o">{</span>Day<span class="o">}</span>
    periods: Day
      value: Int64 <span class="m">735264</span>

julia&gt; t.instant
Dates.UTInstant<span class="o">{</span>Day<span class="o">}(</span>Day<span class="o">(</span>735264<span class="o">))</span>

julia&gt; Dates.value<span class="o">(</span>t<span class="o">)</span>
<span class="m">735264</span>
</code></pre></div><h1 id="查询函数">查询函数</h1>
<p>查询函数提供关于 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.TimeType">TimeType</a> 的历法信息。它们包括关于一周中的某一天的信息。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">t</span> <span class="o">=</span> Date<span class="o">(</span>2014, 1, 31<span class="o">)</span>
2014-01-31

julia&gt; Dates.dayofweek<span class="o">(</span>t<span class="o">)</span>
<span class="m">5</span>

julia&gt; Dates.dayname<span class="o">(</span>t<span class="o">)</span>
<span class="s2">&#34;Friday&#34;</span>

julia&gt; Dates.dayofweekofmonth<span class="o">(</span>t<span class="o">)</span> <span class="c1"># 5th Friday of January</span>
<span class="m">5</span>

julia&gt; Dates.monthname<span class="o">(</span>t<span class="o">)</span>
<span class="s2">&#34;January&#34;</span>

julia&gt; Dates.daysinmonth<span class="o">(</span>t<span class="o">)</span>
<span class="m">31</span>
</code></pre></div><p>以及 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.TimeType">TimeType</a> 的年份和季度信息。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.isleapyear<span class="o">(</span>t<span class="o">)</span>
<span class="nb">false</span>

julia&gt; Dates.dayofyear<span class="o">(</span>t<span class="o">)</span>
<span class="m">31</span>

julia&gt; Dates.quarterofyear<span class="o">(</span>t<span class="o">)</span>
<span class="m">1</span>

julia&gt; Dates.dayofquarter<span class="o">(</span>t<span class="o">)</span>
<span class="m">31</span>
</code></pre></div><p><a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.dayname">dayname</a> 和 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.monthname">monthname</a> 方法也可以使用一个可选的 <code>locale</code> 关键字，它可以用来返回其他语言/地区的年份或月份的名称。这些函数也有返回缩写名称的版本，即 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.dayabbr">dayabbr</a> 和 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.monthabbr">monthabbr</a>。首先将映射加载到 <code>LOCALES</code> 变量中。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">french_months</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&#34;janvier&#34;</span>, <span class="s2">&#34;février&#34;</span>, <span class="s2">&#34;mars&#34;</span>, <span class="s2">&#34;avril&#34;</span>, <span class="s2">&#34;mai&#34;</span>, <span class="s2">&#34;juin&#34;</span>,
                        <span class="s2">&#34;juillet&#34;</span>, <span class="s2">&#34;août&#34;</span>, <span class="s2">&#34;septembre&#34;</span>, <span class="s2">&#34;octobre&#34;</span>, <span class="s2">&#34;novembre&#34;</span>, <span class="s2">&#34;décembre&#34;</span><span class="o">]</span><span class="p">;</span>

julia&gt; <span class="nv">french_monts_abbrev</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&#34;janv&#34;</span>,<span class="s2">&#34;févr&#34;</span>,<span class="s2">&#34;mars&#34;</span>,<span class="s2">&#34;avril&#34;</span>,<span class="s2">&#34;mai&#34;</span>,<span class="s2">&#34;juin&#34;</span>,
                              <span class="s2">&#34;juil&#34;</span>,<span class="s2">&#34;août&#34;</span>,<span class="s2">&#34;sept&#34;</span>,<span class="s2">&#34;oct&#34;</span>,<span class="s2">&#34;nov&#34;</span>,<span class="s2">&#34;déc&#34;</span><span class="o">]</span><span class="p">;</span>

julia&gt; <span class="nv">french_days</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&#34;lundi&#34;</span>,<span class="s2">&#34;mardi&#34;</span>,<span class="s2">&#34;mercredi&#34;</span>,<span class="s2">&#34;jeudi&#34;</span>,<span class="s2">&#34;vendredi&#34;</span>,<span class="s2">&#34;samedi&#34;</span>,<span class="s2">&#34;dimanche&#34;</span><span class="o">]</span><span class="p">;</span>

julia&gt; Dates.LOCALES<span class="o">[</span><span class="s2">&#34;french&#34;</span><span class="o">]</span> <span class="o">=</span> Dates.DateLocale<span class="o">(</span>french_months, french_monts_abbrev, french_days, <span class="o">[</span><span class="s2">&#34;&#34;</span><span class="o">])</span><span class="p">;</span>
</code></pre></div><p>然后可以利用上述函数进行查询。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.dayname<span class="o">(</span>t<span class="p">;</span><span class="nv">locale</span><span class="o">=</span><span class="s2">&#34;french&#34;</span><span class="o">)</span>
<span class="s2">&#34;vendredi&#34;</span>

julia&gt; Dates.monthname<span class="o">(</span>t<span class="p">;</span><span class="nv">locale</span><span class="o">=</span><span class="s2">&#34;french&#34;</span><span class="o">)</span>
<span class="s2">&#34;janvier&#34;</span>

julia&gt; Dates.monthabbr<span class="o">(</span>t<span class="p">;</span><span class="nv">locale</span><span class="o">=</span><span class="s2">&#34;french&#34;</span><span class="o">)</span>
<span class="s2">&#34;janv&#34;</span>
</code></pre></div><p>由于没有加载日期的缩写版本，试图使用函数 <code>dayabbr</code> 会出错。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.dayabbr<span class="o">(</span>t<span class="p">;</span><span class="nv">locale</span><span class="o">=</span><span class="s2">&#34;french&#34;</span><span class="o">)</span>
ERROR: BoundsError: attempt to access 1-element Array<span class="o">{</span>String,1<span class="o">}</span> at index <span class="o">[</span>5<span class="o">]</span>
Stacktrace:
<span class="o">[</span>...<span class="o">]</span>
</code></pre></div><h1 id="时间类型-周期算术">时间类型-周期算术</h1>
<p>在使用任何语言/日期框架时，熟悉如何处理日期-周期算术是一个很好的做法，因为有一些<a href="https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/">棘手的问题</a>需要处理（尽管对于日-精度类型来说要少得多）。</p>
<p><code>Dates</code> 模块的方法试图遵循简单的原则，即在做 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.Period">Period</a> 算术时尽量少改。这种方法也常被称为历法算术，或者说如果有人在对话中问你同样的计算方法，你可能会猜到。为什么要大惊小怪呢？我们举个经典的例子：把2014年1月31日加1个月。答案是什么？Javascript 会说<a href="https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/">3月3日</a>（假设31天）。PHP 会说<a href="https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month">3月2日</a>（假设30天）。事实上，没有正确的答案。在 <code>Dates</code> 模块中，它给出的结果是2月28日。它是如何计算出来的呢？我喜欢想到赌场里经典的 7-7-7 赌博游戏。</p>
<p>现在只要想象一下，老虎机不是 7-7-7，而是年-月-日，或者在我们的例子中，2014-01-31。当你要求在这个日期的基础上增加1个月的时候，月份槽就会递增，所以现在我们有 2014-02-31。然后检查日号是否大于新月份的最后有效日，如果大于（如上例），则日号向下调整到最后有效日（28）。这种方法的后果是什么呢？继续在我们的日期上再加一个月，<code>2014-02-28 + Month(1) == 2014-03-28</code>。什么？你是在期待3月的最后一天吗？不对，对不起，记得 7-7-7 的档期。尽可能少的槽位要改变，所以我们先把月份槽位递增1，2014-03-28，轰，我们就完成了，因为这是一个有效的日期。另一方面，如果我们要在原来的日期 2014-01-31 的基础上增加2个月，那么我们最终的结果是 2014-03-31，正如预期的那样。这种方法的另一个后果是，当强行进行特定的排序时，关联性会有所损失（即以不同的顺序添加东西会导致不同的结果）。比如说：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="o">(</span>Date<span class="o">(</span>2014,1,29<span class="o">)</span>+Dates.Day<span class="o">(</span>1<span class="o">))</span> + Dates.Month<span class="o">(</span>1<span class="o">)</span>
2014-02-28

julia&gt; <span class="o">(</span>Date<span class="o">(</span>2014,1,29<span class="o">)</span>+Dates.Month<span class="o">(</span>1<span class="o">))</span> + Dates.Day<span class="o">(</span>1<span class="o">)</span>
2014-03-01
</code></pre></div><p>那是怎么回事呢？在第一行中，我们在1月29日的基础上加1天，结果是 2014-01-30；然后再加1个月，于是得到 2014-02-30，再往下调整为 2014-02-28。在第二个例子中，我们先加1个月，我们得到 2014-02-29，再往下调整为 2014-02-28，然后再加1天，结果是 2014-03-01。在这种情况下，有一个设计原则是有帮助的，那就是在存在多个 Periods 的情况下，操作将按照 Periods 的类型来排序，而不是按照它们的值或位置顺序来排序；这意味着总是先加 <code>Year</code>，然后加 <code>Month</code>，再加 <code>Week</code> 等。因此，以下确实会导致关联性并正好有用:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Date<span class="o">(</span>2014,1,29<span class="o">)</span> + Dates.Day<span class="o">(</span>1<span class="o">)</span> + Dates.Month<span class="o">(</span>1<span class="o">)</span>
2014-03-01

julia&gt; Date<span class="o">(</span>2014,1,29<span class="o">)</span> + Dates.Month<span class="o">(</span>1<span class="o">)</span> + Dates.Day<span class="o">(</span>1<span class="o">)</span>
2014-03-01
</code></pre></div><p>棘手吗？也许吧。一个无辜的 <code>Dates</code> 用户该怎么做？最重要的是要注意，当处理月份时，明确地强制执行某种关联性，可能会导致一些意想不到的结果，但除此之外，一切都应该按照预期工作。值得庆幸的是，在 UT 中处理时间时，日期-周期算术中的奇特情况几乎就是这样了（避免了处理夏令时、闰秒等的 &ldquo;乐趣&rdquo;）。</p>
<p>作为奖励，所有的周期算术对象都可以直接与范围一起工作。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">dr</span> <span class="o">=</span> Date<span class="o">(</span>2014,1,29<span class="o">)</span>:Day<span class="o">(</span>1<span class="o">)</span>:Date<span class="o">(</span>2014,2,3<span class="o">)</span>
Date<span class="o">(</span><span class="s2">&#34;2014-01-29&#34;</span><span class="o">)</span>:Day<span class="o">(</span>1<span class="o">)</span>:Date<span class="o">(</span><span class="s2">&#34;2014-02-03&#34;</span><span class="o">)</span>

julia&gt; collect<span class="o">(</span>dr<span class="o">)</span>
6-element Array<span class="o">{</span>Date,1<span class="o">}</span>:
 2014-01-29
 2014-01-30
 2014-01-31
 2014-02-01
 2014-02-02
 2014-02-03

julia&gt; <span class="nv">dr</span> <span class="o">=</span> Date<span class="o">(</span>2014,1,29<span class="o">)</span>:Dates.Month<span class="o">(</span>1<span class="o">)</span>:Date<span class="o">(</span>2014,07,29<span class="o">)</span>
Date<span class="o">(</span><span class="s2">&#34;2014-01-29&#34;</span><span class="o">)</span>:Month<span class="o">(</span>1<span class="o">)</span>:Date<span class="o">(</span><span class="s2">&#34;2014-07-29&#34;</span><span class="o">)</span>

julia&gt; collect<span class="o">(</span>dr<span class="o">)</span>
7-element Array<span class="o">{</span>Date,1<span class="o">}</span>:
 2014-01-29
 2014-02-28
 2014-03-29
 2014-04-29
 2014-05-29
 2014-06-29
 2014-07-29
</code></pre></div><pre><code>for i in Date(&quot;2020-08-01&quot;):Day(1):Date(&quot;2020-08-09&quot;)
           println(i)
end

2020-08-01
2020-08-02
2020-08-03
2020-08-04
2020-08-05
2020-08-06
2020-08-07
2020-08-08
2020-08-09
</code></pre><h1 id="调整器函数">调整器函数</h1>
<p>尽管日期-周期算术很方便，但经常需要在日期上进行的计算具有日历或时间的性质，而不是固定的周期数。节日就是一个很好的例子，大多数都遵循这样的规则：&ldquo;纪念日 = 五月的最后一个星期一&rdquo;，或者 &ldquo;感恩节 = 十一月的第四个星期四&rdquo;。这类时间表达式处理的是相对于日历的规则，比如本月的第一天或最后一天，下周二，或第一个和第三个星期三等。</p>
<p><code>Dates</code> 模块通过几个方便的方法提供了调整器 API，这些方法有助于简单、简洁地表达时间规则。第一组调整器方法处理周、月、季度和年的首尾。它们每个方法都接收一个单一的 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.TimeType">TimeType</a> 作为输入，并返回或调整到相对于输入的所需时期的第一个或最后一个。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.firstdayofweek<span class="o">(</span>Date<span class="o">(</span>2014,7,16<span class="o">))</span> <span class="c1"># Adjusts the input to the Monday of the input&#39;s week</span>
2014-07-14

julia&gt; Dates.lastdayofmonth<span class="o">(</span>Date<span class="o">(</span>2014,7,16<span class="o">))</span> <span class="c1"># Adjusts to the last day of the input&#39;s month</span>
2014-07-31

julia&gt; Dates.lastdayofquarter<span class="o">(</span>Date<span class="o">(</span>2014,7,16<span class="o">))</span> <span class="c1"># Adjusts to the last day of the input&#39;s quarter</span>
2014-09-30
</code></pre></div><p>接下来的两个高阶方法 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.tonext-Tuple%7BTimeType,Int64%7D">tonext</a> 和 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.toprev-Tuple%7BTimeType,Int64%7D">toprev</a>，通过将一个 <code>DateFunction</code> 和一个起始 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.TimeType">TimeType</a> 作为第一个参数来概括处理时间表达式。<code>DateFunction</code> 只是一个函数，通常是匿名的，它接受一个单一的 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.TimeType">TimeType</a> 作为输入，并返回一个 <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Bool">Bool</a>，<code>true</code> 表示满足调整标准。例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">istuesday</span> <span class="o">=</span> x-&gt;Dates.dayofweek<span class="o">(</span>x<span class="o">)</span> <span class="o">==</span> Dates.Tuesday<span class="p">;</span> <span class="c1"># Returns true if the day of the week of x is Tuesday</span>

julia&gt; Dates.tonext<span class="o">(</span>istuesday, Date<span class="o">(</span>2014,7,13<span class="o">))</span> <span class="c1"># 2014-07-13 is a Sunday</span>
2014-07-15

julia&gt; Dates.tonext<span class="o">(</span>Date<span class="o">(</span>2014,7,13<span class="o">)</span>, Dates.Tuesday<span class="o">)</span> <span class="c1"># Convenience method provided for day of the week adjustments</span>
2014-07-15
</code></pre></div><p>这对于更复杂的时间表达式的 do-block 语法是很有用的。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.tonext<span class="o">(</span>Date<span class="o">(</span>2014,7,13<span class="o">))</span> <span class="k">do</span> x
           <span class="c1"># Return true on the 4th Thursday of November (Thanksgiving)</span>
           Dates.dayofweek<span class="o">(</span>x<span class="o">)</span> <span class="o">==</span> Dates.Thursday <span class="o">&amp;&amp;</span>
           Dates.dayofweekofmonth<span class="o">(</span>x<span class="o">)</span> <span class="o">==</span> <span class="m">4</span> <span class="o">&amp;&amp;</span>
           Dates.month<span class="o">(</span>x<span class="o">)</span> <span class="o">==</span> Dates.November
       end
2014-11-27
</code></pre></div><p><a href="https://docs.julialang.org/en/v1/base/collections/#Base.filter">Base.filter</a> 方法可以用来获取指定范围内的所有有效日期/时刻。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 匹兹堡街道清洁; 从 4月到11月的每第二个周二</span>
<span class="c1"># 日期范围从 2014-01-01 到 2015-01-01</span>
julia&gt; <span class="nv">dr</span> <span class="o">=</span> Dates.Date<span class="o">(</span>2014<span class="o">)</span>:Day<span class="o">(</span>1<span class="o">)</span>:Dates.Date<span class="o">(</span>2015<span class="o">)</span><span class="p">;</span>

julia&gt; filter<span class="o">(</span>dr<span class="o">)</span> <span class="k">do</span> x
           Dates.dayofweek<span class="o">(</span>x<span class="o">)</span> <span class="o">==</span> Dates.Tue <span class="o">&amp;&amp;</span>
           Dates.April &lt;<span class="o">=</span> Dates.month<span class="o">(</span>x<span class="o">)</span> &lt;<span class="o">=</span> Dates.Nov <span class="o">&amp;&amp;</span>
           Dates.dayofweekofmonth<span class="o">(</span>x<span class="o">)</span> <span class="o">==</span> <span class="m">2</span>
       end
8-element Array<span class="o">{</span>Date,1<span class="o">}</span>:
 2014-04-08
 2014-05-13
 2014-06-10
 2014-07-08
 2014-08-12
 2014-09-09
 2014-10-14
 2014-11-11
</code></pre></div><p>在 Raku 中上面的代码可以写成:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">lazy</span> <span class="k">my</span> <span class="nv">@dates</span> <span class="o">=</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">2014-01-01</span><span class="p">&#39;)</span> <span class="o">...</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">2015-01-01</span><span class="p">&#39;);</span>

<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@dates</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="k">-&gt;</span> <span class="nv">$d</span> <span class="p">{</span>
    <span class="nv">$d</span><span class="o">.</span><span class="nb">day-of-week</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
    <span class="mi">4</span>  <span class="o">&lt;=</span> <span class="nv">$d</span><span class="o">.</span><span class="nb">month</span> <span class="o">&lt;=</span> <span class="mi">11</span> <span class="o">&amp;&amp;</span>
    <span class="nv">$d</span><span class="o">.</span><span class="nb">weekday-of-month</span> <span class="o">==</span> <span class="mi">2</span>
<span class="p">}</span>
</code></pre></div><p>其他的例子和测试可以在 <a href="https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl">stdlib/Dates/test/adjusters.jl</a> 中找到。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia" term="julia" label="julia" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/dates" term="dates" label="dates" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Julia 语言学习笔记]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-26T00:00:00+08:00</published>
            <updated>2020-07-26T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Learning Julia</blockquote><h2 id="语法">语法</h2>
<h3 id="数值字面量系数">数值字面量系数</h3>
<p>在标识符或圆括号前面直接放一个数字, 例如 <code>2x</code> 或 <code>2(x+y)</code>, 会被认为是把标识符和它前面的数字相乘。这样写多项式就很方便了。</p>
<h3 id="向量化的点号运算符">向量化的点号运算符</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">.+</span> <span class="mi">3</span>

<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">4</span>
 <span class="mi">5</span>
 <span class="mi">6</span>
</code></pre></div><p><code>.+</code> 类似于 Raku 中的 <code>»+»</code> 超运算符:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">»+»</span> <span class="mi">3</span>
<span class="o">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="o">]</span>
</code></pre></div><p>但是 Julia 的 <code>Vectorized &quot;dot&quot;</code> 语法没有 Raku 的超运算符语法清晰。</p>
<p>类似的例子还有:</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">sin</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="c"># 0.479425538604203</span>

<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">]</span>
<span class="n">sin</span><span class="o">.</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">0.479425538604203</span>
 <span class="mf">0.8414709848078965</span>
 <span class="mf">0.9974949866040544</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="mi">3</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="n">y</span><span class="p">;</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">];</span>
<span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">];</span>
<span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="nb">pi</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">13.42477796076938</span>
 <span class="mf">17.42477796076938</span>
 <span class="mf">21.42477796076938</span>

<span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nb">pi</span><span class="p">)</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">15.566370614359172</span>
 <span class="mf">18.566370614359172</span>
 <span class="mf">21.566370614359172</span>

<span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">19.0</span>
 <span class="mf">26.0</span>
 <span class="mf">33.0</span>
</code></pre></div><p>等价的 Raku 写法为:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span>\<span class="nb">x</span><span class="o">,</span> \<span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="mi">3</span><span class="o">*</span><span class="nb">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">y</span><span class="p">};</span>

<span class="k">my</span> <span class="nv">\A</span> <span class="o">=</span> <span class="o">[</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">,</span> <span class="mf">3.0</span><span class="o">]</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">\B</span> <span class="o">=</span> <span class="o">[</span><span class="mf">4.0</span><span class="o">,</span> <span class="mf">5.0</span><span class="o">,</span> <span class="mf">6.0</span><span class="o">]</span><span class="p">;</span>

<span class="n">A</span><span class="o">».</span><span class="nv">&amp;f</span><span class="p">(</span><span class="no">pi</span><span class="p">)</span>
<span class="o">[</span><span class="mf">15.566370614359172</span> <span class="mf">18.566370614359172</span> <span class="mf">21.566370614359172</span><span class="o">]</span>
</code></pre></div><h3 id="链式比较">链式比较</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">5</span>
<span class="nb">true</span>
</code></pre></div><p>Raku 同样支持这种链式比较。</p>
<h3 id="虚数">虚数</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">real</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="nb">im</span><span class="p">)</span>         <span class="c"># 1</span>
<span class="n">imag</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="nb">im</span><span class="p">)</span>         <span class="c"># 2</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="nb">im</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="nb">im</span><span class="p">)</span> <span class="c"># 5 + 0im</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="no">i</span><span class="p">)</span><span class="o">.</span><span class="nb">re</span>         <span class="c1"># 1</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="no">i</span><span class="p">)</span><span class="o">.</span><span class="nb">im</span>         <span class="c1"># 2</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="no">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="no">i</span><span class="p">)</span> <span class="c1"># 5+0i</span>
</code></pre></div><h3 id="命名参数">命名参数</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">function</span> <span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="n">style</span><span class="o">=</span><span class="s">&#34;solid&#34;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#34;black&#34;</span><span class="p">)</span>
    <span class="c">###</span>
<span class="k">end</span>

<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="ss">:width</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div><h3 id="函数组合">函数组合</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="p">(</span><span class="n">sqrt</span> <span class="o">∘</span> <span class="o">+</span><span class="p">)(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span> <span class="c"># 3.0</span>

<span class="n">map</span><span class="p">(</span><span class="n">first</span> <span class="o">∘</span> <span class="n">reverse</span> <span class="o">∘</span> <span class="n">uppercase</span><span class="p">,</span> <span class="n">split</span><span class="p">(</span><span class="s">&#34;you can compose functions like this&#34;</span><span class="p">))</span>
<span class="mi">6</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Char</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="sc">&#39;U&#39;</span>
 <span class="sc">&#39;N&#39;</span>
 <span class="sc">&#39;E&#39;</span>
 <span class="sc">&#39;S&#39;</span>
 <span class="sc">&#39;E&#39;</span>
 <span class="sc">&#39;S&#39;</span>
</code></pre></div><h3 id="piping">Piping</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="mi">1</span><span class="o">:</span><span class="mi">10</span> <span class="o">|&gt;</span> <span class="n">sum</span> <span class="o">|&gt;</span> <span class="n">sqrt</span> <span class="c"># 7.416198487095663</span>

<span class="c"># 等价于</span>
<span class="p">(</span><span class="n">sqrt</span> <span class="o">∘</span> <span class="n">sum</span><span class="p">)(</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span><span class="p">)</span>  <span class="c"># 7.416198487095663</span>
</code></pre></div><h3 id="广播和管道一起使用">广播和管道一起使用</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="p">[</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;list&#34;</span><span class="p">,</span> <span class="s">&#34;of&#34;</span><span class="p">,</span> <span class="s">&#34;strings&#34;</span><span class="p">]</span> <span class="o">.|&gt;</span> <span class="p">[</span><span class="n">uppercase</span><span class="p">,</span> <span class="n">reverse</span><span class="p">,</span> <span class="n">titlecase</span><span class="p">,</span> <span class="n">length</span><span class="p">]</span>
<span class="mi">4</span><span class="o">-</span><span class="n">element</span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Any</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
  <span class="s">&#34;A&#34;</span>
  <span class="s">&#34;tsil&#34;</span>
  <span class="s">&#34;Of&#34;</span>
 <span class="mi">7</span>
</code></pre></div><h3 id="组合类型">组合类型</h3>
<ul>
<li>不可变组合类型</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">struct</span> <span class="kt">Foo</span>
    <span class="n">bar</span>
    <span class="n">baz</span><span class="o">::</span><span class="kt">Int</span>
    <span class="n">qux</span><span class="o">::</span><span class="kt">Float64</span>
<span class="k">end</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="s">&#34;rakulang&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="n">typeof</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="c"># Foo</span>
<span class="n">typeof</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span> <span class="c"># DataType</span>

<span class="n">foo</span><span class="o">.</span><span class="n">bar</span>     <span class="c"># rakulang</span>
<span class="n">foo</span><span class="o">.</span><span class="n">qux</span>     <span class="c"># 1.5</span>
<span class="n">foo</span><span class="o">.</span><span class="n">qux</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># ERROR: setfield! immutable struct of type Foo cannot be changed</span>
</code></pre></div><ul>
<li>可变组合类型</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">mutable struct</span> <span class="kt">Bar</span>
    <span class="n">baz</span>
    <span class="n">qux</span><span class="o">::</span><span class="kt">Float64</span>
<span class="k">end</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">(</span><span class="s">&#34;rakudo&#34;</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">)</span>
<span class="n">bar</span><span class="o">.</span><span class="n">baz</span> <span class="o">=</span> <span class="mi">1</span><span class="o">//</span><span class="mi">2</span>
<span class="n">bar</span><span class="o">.</span><span class="n">qux</span> <span class="o">=</span> <span class="mf">2.0</span>
</code></pre></div><h3 id="联合类型">联合类型</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">IntOrString</span> <span class="o">=</span> <span class="kt">Union</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="kt">AbstractString</span><span class="p">}</span>
<span class="mi">1</span> <span class="o">::</span> <span class="n">IntOrString</span>          <span class="c"># 1</span>
<span class="s">&#34;rakulang&#34;</span> <span class="o">::</span> <span class="n">IntOrString</span> <span class="c"># rakulang</span>
</code></pre></div><h3 id="参数化类型">参数化类型</h3>
<ul>
<li>参数化组合类型</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">struct</span> <span class="kt">Point</span><span class="p">{</span><span class="kt">T</span><span class="p">}</span>
    <span class="n">x</span><span class="o">::</span><span class="kt">T</span>
    <span class="n">y</span><span class="o">::</span><span class="kt">T</span>
<span class="k">end</span>

<span class="n">point</span><span class="o">=</span><span class="kt">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="n">point</span><span class="o">.</span><span class="n">x</span> <span class="c"># 1.0</span>
<span class="n">point</span><span class="o">.</span><span class="n">y</span> <span class="c"># 2.0</span>


<span class="k">struct</span> <span class="kt">Circle</span><span class="p">{</span><span class="kt">T</span><span class="p">,</span><span class="kt">U</span><span class="p">}</span>
    <span class="n">x</span><span class="o">::</span><span class="kt">T</span>
    <span class="n">y</span><span class="o">::</span><span class="kt">U</span>
<span class="k">end</span>

<span class="n">c</span> <span class="o">=</span> <span class="kt">Circle</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="kt">AbstractString</span><span class="p">}(</span><span class="mf">6.0</span><span class="p">,</span> <span class="s">&#34;rakulang&#34;</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">x</span> <span class="c"># 6.0</span>
<span class="n">c</span><span class="o">.</span><span class="n">y</span> <span class="c"># rakulang</span>
</code></pre></div><h3 id="多重分派">多重分派</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Float64</span><span class="p">,</span> <span class="n">y</span><span class="o">::</span><span class="kt">Float64</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Number</span><span class="p">,</span> <span class="n">y</span><span class="o">::</span><span class="kt">Number</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span>

<span class="n">methods</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="c"># 2 methods for generic function &#34;f&#34;:</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Float64</span><span class="p">,</span> <span class="n">y</span><span class="o">::</span><span class="kt">Float64</span><span class="p">)</span> <span class="k">in</span> <span class="n">Main</span> <span class="n">at</span> <span class="n">REPL</span><span class="p">[</span><span class="mi">33</span><span class="p">]</span><span class="o">:</span><span class="mi">1</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="kt">Number</span><span class="p">,</span> <span class="n">y</span><span class="o">::</span><span class="kt">Number</span><span class="p">)</span> <span class="k">in</span> <span class="n">Main</span> <span class="n">at</span> <span class="n">REPL</span><span class="p">[</span><span class="mi">34</span><span class="p">]</span><span class="o">:</span><span class="mi">1</span>

<span class="n">f</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="c"># 7</span>
<span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>   <span class="c"># 1</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julialang" term="julialang" label="julialang" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia" term="julia" label="julia" />
                            
                        
                    
                
            
        </entry>
    
</feed>
