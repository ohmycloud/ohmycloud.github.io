<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.63.2">Hugo</generator><title type="html"><![CDATA[julia on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/julia/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/julia/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/julia/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/julia/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2020-08-20T18:58:43+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/julia/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Julia 中的 模块]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-05-modules-in-julia/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-04-pkg-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的 Pkg" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-04-dates-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的日期和时间" />
                <link href="https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 语言学习笔记" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-05-modules-in-julia/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-05T00:00:00+08:00</published>
            <updated>2020-08-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Modules</blockquote><h1 id="模块">模块</h1>
<p>Julia 中的模块是独立的变量工作空间，即它们引入了一个新的全局作用域。它们在语法上是有分界的，在 <code>module Name ... end</code> 里面。模块允许您创建顶层定义（也就是全局变量），而不用担心您的代码与别人的代码一起使用时的名称冲突。在一个模块中，你可以控制哪些来自其他模块的名字是可见的（通过导入），并指定哪些名字是要公开的（通过导出）。</p>
<p>下面的例子展示了模块的主要功能。这个例子并不是为了运行，而是为了说明问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">MyModule</span><span class="o"></span>
<span class="k">using</span> <span class="n">Lib</span><span class="o"></span>

<span class="k">using</span> <span class="n">BigLib</span><span class="o"></span><span class="o">:</span> <span class="n">thing1</span><span class="o"></span><span class="p">,</span> <span class="n">thing2</span><span class="o"></span>

<span class="k">import</span> <span class="n">Base</span><span class="o"></span><span class="o">.</span><span class="n">show</span><span class="o"></span>

<span class="k">export</span> <span class="n">MyType</span><span class="o"></span><span class="p">,</span> <span class="n">foo</span><span class="o"></span>

<span class="k">struct</span> <span class="n">MyType</span><span class="o"></span>
    <span class="n">x</span><span class="o"></span>
<span class="k">end</span>

<span class="n">bar</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="n">x</span><span class="o"></span>
<span class="n">foo</span><span class="o"></span><span class="p">(</span><span class="n">a</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="n">MyType</span><span class="o"></span><span class="p">)</span> <span class="o">=</span> <span class="n">bar</span><span class="o"></span><span class="p">(</span><span class="n">a</span><span class="o"></span><span class="o">.</span><span class="n">x</span><span class="o"></span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">show</span><span class="o"></span><span class="p">(</span><span class="n">io</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">IO</span><span class="p">,</span> <span class="n">a</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="n">MyType</span><span class="o"></span><span class="p">)</span> <span class="o">=</span> <span class="n">print</span><span class="o"></span><span class="p">(</span><span class="n">io</span><span class="o"></span><span class="p">,</span> <span class="s">&#34;</span><span class="s">M</span><span class="s">y</span><span class="s">T</span><span class="s">y</span><span class="s">p</span><span class="s">e</span><span class="s"> </span><span class="si">$</span><span class="p">(</span><span class="n">a</span><span class="o"></span><span class="o">.</span><span class="n">x</span><span class="o"></span><span class="p">)</span><span class="s">&#34;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><p>需要注意的是，这个样式并不是要在模块的正文中缩进，因为这通常会导致整个文件被缩进。</p>
<p>这个模块定义了一个 <code>MyType</code> 类型和两个函数。函数 <code>foo</code> 和 <code>MyType</code> 类型是导出的，因此可以导入到其他模块中。函数 <code>bar</code> 是 <code>MyModule</code> 的私有函数。</p>
<p><code>using Lib</code> 语句意味着将有一个名为 <code>Lib</code> 的模块可以根据需要解析名称。当遇到一个全局变量在当前模块中没有定义时，系统会在 <code>Lib</code> 导出的变量中搜索它，如果在那里找到了，就会导入它。这意味着在当前模块内对该全局的所有使用都将解析为该变量在 <code>Lib</code> 中的定义。</p>
<p><code>using BigLib: thing1, thing2</code> 语句，只将标识符 <code>thing1</code> 和 <code>thing2</code> 从模块 <code>BigLib</code> 中带入作用域。如果这些名称指的是函数，那么将不允许向它们添加方法（你只能 &ldquo;使用 &ldquo;它们，而不是扩展它们）。</p>
<p><code>import</code> 关键字支持与 <code>using</code> 相同的语法。<code>import</code> 与 <code>using</code> 的不同之处在于，使用 <code>import</code> 导入的函数可以用新的方法进行扩展。</p>
<p>在上面的 <code>MyModule</code> 中，我们想给标准的 <code>show</code> 函数添加一个方法，所以我们必须写 <code>import Base.show</code>。只有通过 <code>using</code> 才能看到名字的函数不能被扩展。</p>
<p>一旦一个变量通过 <code>using</code> 或 <code>import</code> 变得可见，一个模块就不能创建自己的同名变量。导入的变量是只读的，分配给全局变量总是会影响到当前模块所拥有的变量，否则会引发错误。</p>
<h2 id="模块使用情况概述">模块使用情况概述</h2>
<p>要加载一个模块，可以使用两个主要的关键词：<code>using</code> 和 <code>import</code>。要了解它们的区别，请看下面的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">MyModule</span><span class="o"></span>

<span class="k">export</span> <span class="n">x</span><span class="o"></span><span class="p">,</span> <span class="n">y</span><span class="o"></span>

<span class="n">x</span><span class="o"></span><span class="p">(</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;</span><span class="s">x</span><span class="s">&#34;</span>
<span class="n">y</span><span class="o"></span><span class="p">(</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;</span><span class="s">y</span><span class="s">&#34;</span>
<span class="n">p</span><span class="o"></span><span class="p">(</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;</span><span class="s">p</span><span class="s">&#34;</span>

<span class="k">end</span>
</code></pre></div><p>在这个模块中，我们导出了 <code>x</code> 和 <code>y</code> 函数(用关键字 <code>export</code>)，也有非导出的函数 <code>p</code>，有几种不同的方法可以将 <code>Module</code> 及其内部函数加载到当前的工作空间中。</p>
<table>
<thead>
<tr>
<th align="left">导入命令</th>
<th align="left">带入带作用域中的东西</th>
<th align="left">可用于方法扩展</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>using MyModule</code></td>
<td align="left">所有导出的名字(<code>x</code> 和 <code>y</code>), <code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
<td align="left"><code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
</tr>
<tr>
<td align="left"><code>using MyModule: x, p</code></td>
<td align="left"><code>x</code> 和 <code>p</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>import MyModule</code></td>
<td align="left"><code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
<td align="left"><code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
</tr>
<tr>
<td align="left"><code>import MyModule.x, MyModule.p</code></td>
<td align="left"><code>x</code> 和 <code>p</code></td>
<td align="left"><code>x</code> 和 <code>p</code></td>
</tr>
<tr>
<td align="left"><code>import MyModule: x, p</code></td>
<td align="left"><code>x</code> 和 <code>p</code></td>
<td align="left"><code>x</code> 和 <code>p</code></td>
</tr>
</tbody>
</table>
<h2 id="模块和文件">模块和文件</h2>
<p>文件和文件名大多与模块无关，模块只与模块表达式有关。一个模块可以有多个文件，一个文件可以有多个模块。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">Foo</span><span class="o"></span>

<span class="n">include</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">f</span><span class="s">i</span><span class="s">l</span><span class="s">e</span><span class="s">1</span><span class="s">.</span><span class="s">j</span><span class="s">l</span><span class="s">&#34;</span><span class="p">)</span>
<span class="n">include</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">f</span><span class="s">i</span><span class="s">l</span><span class="s">e</span><span class="s">2</span><span class="s">.</span><span class="s">j</span><span class="s">l</span><span class="s">&#34;</span><span class="p">)</span>

<span class="k">end</span>
</code></pre></div><p>在不同的模块中包含相同的代码，提供了类似 mixin 的行为。人们可以使用这一点来用不同的基础定义来运行相同的代码，例如，通过使用某些操作符的&quot;安全&quot;版本来测试代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">Normal</span><span class="o"></span>
<span class="n">include</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">m</span><span class="s">y</span><span class="s">c</span><span class="s">o</span><span class="s">d</span><span class="s">e</span><span class="s">.</span><span class="s">j</span><span class="s">l</span><span class="s">&#34;</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">module</span> <span class="n">Testing</span><span class="o"></span>
<span class="n">include</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">s</span><span class="s">a</span><span class="s">f</span><span class="s">e</span><span class="s">_</span><span class="s">o</span><span class="s">p</span><span class="s">e</span><span class="s">r</span><span class="s">a</span><span class="s">t</span><span class="s">o</span><span class="s">r</span><span class="s">s</span><span class="s">.</span><span class="s">j</span><span class="s">l</span><span class="s">&#34;</span><span class="p">)</span>
<span class="n">include</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">m</span><span class="s">y</span><span class="s">c</span><span class="s">o</span><span class="s">d</span><span class="s">e</span><span class="s">.</span><span class="s">j</span><span class="s">l</span><span class="s">&#34;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><h2 id="标准模块">标准模块</h2>
<p>There are three important standard modules:</p>
<p><a href="https://docs.julialang.org/en/v1/base/base/#Core">Core</a> 包含&quot;内置于&quot;语言中的所有功能。
<a href="https://docs.julialang.org/en/v1/base/base/#Base">Base</a> 包含几乎在所有情况下都有用的基本功能。
<a href="https://docs.julialang.org/en/v1/base/base/#Main">Main</a> 是当 Julia 被启动时的顶级模块和当前模块。</p>
<h2 id="默认的顶层定义和裸模块">默认的顶层定义和裸模块</h2>
<p>除了 <code>using Base</code> 之外，模块还自动包含 <a href="https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.eval">eval</a>和 <a href="https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.include">include</a> 函数的定义，这些函数在该模块的全局作用域内评估表达式/文件。</p>
<p>如果不想要这些默认的定义，可以使用关键字 <a href="https://docs.julialang.org/en/v1/base/base/#baremodule">baremodule</a> 来代替定义模块（注意： <code>Core</code> 仍然是导入的，如上所述）。以 <code>baremodule</code> 来说，一个标准的模块是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">baremodule</span> <span class="n">Mod</span><span class="o"></span>

<span class="k">using</span> <span class="n">Base</span><span class="o"></span>

<span class="n">eval</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="p">)</span> <span class="o">=</span> <span class="n">Core</span><span class="o"></span><span class="o">.</span><span class="n">eval</span><span class="o"></span><span class="p">(</span><span class="n">Mod</span><span class="o"></span><span class="p">,</span> <span class="n">x</span><span class="o"></span><span class="p">)</span>
<span class="n">include</span><span class="o"></span><span class="p">(</span><span class="n">p</span><span class="o"></span><span class="p">)</span> <span class="o">=</span> <span class="n">Base</span><span class="o"></span><span class="o">.</span><span class="n">include</span><span class="o"></span><span class="p">(</span><span class="n">Mod</span><span class="o"></span><span class="p">,</span> <span class="n">p</span><span class="o"></span><span class="p">)</span>

<span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="k">end</span>
</code></pre></div><h2 id="相对和绝对模块路径">相对和绝对模块路径</h2>
<p>给定 <code>using Foo</code> 语句，系统会查询内部的顶层模块表，寻找一个名为 <code>Foo</code> 的模块。如果该模块不存在，系统会尝试 <code>require(:Foo)</code>，这通常会导致从安装的包中加载代码。</p>
<p>然而，有些模块包含子模块，这意味着你有时需要访问一个非顶层模块。有两种方法可以做到这一点。第一种是使用绝对路径，例如 <code>using Base.Sort</code>。第二种是使用相对路径，这样可以更容易地导入当前模块的子模块或其任何一个外层模块。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">Parent</span><span class="o"></span>

<span class="k">module</span> <span class="n">Utils</span><span class="o"></span>
<span class="o">.</span><span class="o">.</span><span class="o">.</span>
<span class="k">end</span>

<span class="k">using</span> <span class="o">.</span><span class="n">Utils</span><span class="o"></span>

<span class="o">.</span><span class="o">.</span><span class="o">.</span>
<span class="k">end</span>
</code></pre></div><p>这里模块 <code>Parent</code> 包含一个子模块 <code>Utils</code>，<code>Parent</code> 中的代码希望 <code>Utils</code> 的内容可见。这可以通过在 <code>using</code> 路径中使用点号来实现。添加更多的前导点号会使模块的层次结构上升。例如，<code>using ..Utils</code> 会在 <code>Parent</code> 的外层模块中查找<code>Utils</code>，而不是在 <code>Parent</code> 本身中查找。</p>
<p>注意相对导入限定符只在使用和导入语句中有效。</p>
<h2 id="命名空间杂项">命名空间杂项</h2>
<p>如果一个名字是限定的(例如 <code>Base.sin</code>)，那么即使它没有被导出，也可以被访问。这在调试时往往很有用。它也可以通过使用限定名作为函数名来添加方法。但是，由于会产生语法上的歧义，如果你想给不同模块中的一个函数添加方法，而这个函数的名称只包含符号，例如一个运算符，<code>Base.+</code>，你必须使用 <code>Base.:+</code> 来引用它。如果运算符的长度超过一个字符，你必须用括号把它括起来，比如 <code>Base.:(==)</code>。</p>
<p>在导入和导出语句中，宏的名称用 <code>@</code> 书写，例如 <code>import Mod.@mac</code>。其他模块中的宏可以用 <code>Mod.@mac</code> 或 <code>@Mod.mac</code> 来调用。</p>
<p>语法 <code>M.x = y</code> 不能用于分配其他模块中的全局，全局分配总是模块-局部的。</p>
<p>变量名可以通过声明为 <code>global x</code> 来 &ldquo;保留&quot;而不分配给它，这样可以防止加载后初始化的 globals 的名称冲突。</p>
<h2 id="模块初始化和预编译">模块初始化和预编译</h2>
<p>大型模块可能需要几秒钟的时间来加载，因为执行一个模块中的所有语句往往需要编译大量的代码。Julia 创建了模块的预编译缓存来减少这个时间。</p>
<p>当使用 <code>import</code> 或 <code>using</code> 加载模块时，会自动创建并使用增量的预编译模块文件。这将导致它在第一次导入时自动编译。另外，您也可以手动调用 <a href="https://docs.julialang.org/en/v1/base/base/#Base.compilecache">Base.compilecache(modulename)</a>。由此产生的缓存文件将存储在 <code>DEPOT_PATH[1]/compiled/</code> 中。随后，只要模块的任何依赖关系发生变化，模块就会在 <code>using</code> 或 <code>import</code> 时自动重新编译；依赖关系是指导入的模块、Julia 构建的模块、包含的文件，或者模块文件中 <a href="https://docs.julialang.org/en/v1/base/base/#Base.include_dependency">include_dependency(path)</a> 声明的显式依赖关系。</p>
<p>对于文件依赖，通过检查由 <code>include</code> 加载的文件或由 <code>include_dependency</code> 显式添加的文件的修改时间(mtime)是否保持不变，或者是否等于被截断到最接近秒的修改时间(以适应无法以亚秒级精度复制 mtime 的系统)来确定变化。它还考虑到在 <code>require</code> 中搜索逻辑选择的文件路径是否与创建预编译文件的路径匹配。它还会考虑到已经加载到当前进程中的一组依赖关系，即使这些模块的文件发生变化或消失，也不会重新编译这些模块，以避免在运行系统和预编译缓存之间产生不兼容的情况。</p>
<p>如果你知道某个模块预编译你的模块是不安全的（例如，出于下面描述的原因之一），你应该在模块文件中加上 <code>__precompile__(false)</code>（通常放在顶部）。这将导致 <code>Base.compilecache</code> 抛出一个错误，并将导致 <code>using</code> / <code>import</code> 直接将其加载到当前进程中而跳过预编译和缓存。这也因此阻止了该模块被任何其他预编译模块导入。</p>
<p>您可能需要注意创建增量共享库时固有的某些行为，在编写模块时可能需要注意。例如，外部状态不会被保存。为了适应这一点，明确地将任何必须在运行时发生的初始化步骤与可以在编译时发生的步骤分开。为此，Julia 允许您在您的模块中定义一个 <code>__init__()</code> 函数来执行任何必须在运行时发生的初始化步骤。这个函数在编译时不会被调用（<code>--output-*</code>）。实际上，你可以假设它在代码的生命周期中只运行一次。当然，如果有必要的话，你可以手动调用它，但是默认情况下，你可以假设这个函数处理的是本地机器的计算状态，它不需要&ndash;甚至不应该&ndash;在编译后的镜像中捕获。它将在模块被加载到一个进程后被调用，包括如果它被加载到增量编译中(<code>--output-incremental=yes</code>)，但如果它被加载到一个完整的编译进程中，则不会被调用。</p>
<p>特别是，如果你在一个模块中定义了一个 <code>function __init__()</code>，那么 Julia 将在模块被加载后（例如通过 <code>import</code>、<code>using</code> 或 <code>require</code>）在运行时第一次立即调用 <code>__init__()</code>（也就是说，<code>__init__</code> 只被调用一次，而且是在模块中的所有语句被执行后才被调用）。因为它是在模块完全导入之后被调用的，所以任何子模块或其它导入的模块都会在外层模块的 <code>__init__</code> 之前调用它们的 <code>__init__</code> 函数。</p>
<p><code>__init__</code> 的两个典型用途是调用外部 C 库的运行时初始化函数和初始化涉及外部库返回指针的全局常量。例如，假设我们正在调用一个 C 库 <code>libfoo</code>，它要求我们在运行时调用 <code>foo_init()</code> 初始化函数。假设我们还想定义一个全局常量 <code>foo_data_ptr</code>，用来存放 <code>libfoo</code> 定义的 <code>void *foo_data()</code> 函数的返回值&ndash;这个常量必须在运行时（而不是在编译时）初始化，因为指针地址会随着运行而改变。你可以通过在你的模块中定义下面的 <code>__init__</code> 函数来实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="kd">const</span> <span class="n">foo_data_ptr</span><span class="o"></span> <span class="o">=</span> <span class="kt">Ref</span><span class="p">{</span><span class="kt">Ptr</span><span class="p">{</span><span class="n">Cvoid</span><span class="o"></span><span class="p">}</span><span class="p">}</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">function</span> <span class="n">__init__</span><span class="o"></span><span class="p">(</span><span class="p">)</span>
    <span class="k">ccall</span><span class="p">(</span><span class="p">(</span><span class="o">:</span><span class="n">foo_init</span><span class="o"></span><span class="p">,</span> <span class="o">:</span><span class="n">libfoo</span><span class="o"></span><span class="p">)</span><span class="p">,</span> <span class="n">Cvoid</span><span class="o"></span><span class="p">,</span> <span class="p">(</span><span class="p">)</span><span class="p">)</span>
    <span class="n">foo_data_ptr</span><span class="o"></span><span class="p">[</span><span class="p">]</span> <span class="o">=</span> <span class="k">ccall</span><span class="p">(</span><span class="p">(</span><span class="o">:</span><span class="n">foo_data</span><span class="o"></span><span class="p">,</span> <span class="o">:</span><span class="n">libfoo</span><span class="o"></span><span class="p">)</span><span class="p">,</span> <span class="kt">Ptr</span><span class="p">{</span><span class="n">Cvoid</span><span class="o"></span><span class="p">}</span><span class="p">,</span> <span class="p">(</span><span class="p">)</span><span class="p">)</span>
    <span class="nb">nothing</span>
<span class="k">end</span>
</code></pre></div><p>请注意，我们完全可以在函数内部定义一个全局，比如 <code>__init__</code>；这是使用动态语言的优势之一。但是通过在全局作用域内定义一个常量，我们可以确保编译器知道这个类型，并允许它生成更好的优化代码。显然，你的模块中任何其他依赖于 <code>foo_data_ptr</code> 的 globals 也必须在 <code>__init__</code> 中初始化。</p>
<p>涉及大多数不是由 <a href="https://docs.julialang.org/en/v1/base/c/#ccall">ccall</a> 产生的 Julia 对象的常量不需要放在 <code>__init__</code> 中：它们的定义可以被预编译并从缓存的模块映像中加载。这包括像数组这样复杂的堆分配对象。然而，任何返回原始指针值的例程都必须在运行时调用，以便预编译工作（<a href="https://docs.julialang.org/en/v1/base/c/#Core.Ptr">Ptr</a> 对象将变成空指针，除非它们被隐藏在 <a href="https://docs.julialang.org/en/v1/base/base/#Base.isbits">isbits</a> 对象中）。这包括 Julia 函数 <code>cfunction</code> 和 <a href="https://docs.julialang.org/en/v1/base/c/#Base.pointer">pointer</a> 的返回值。</p>
<p>字典和集合类型，或者一般来说任何依赖于 <code>hash(key)</code> 方法输出的东西，都是比较棘手的情况。在常见的情况下，键是数字、字符串、符号、范围、<code>Expr</code> 或这些类型的组合（通过数组、元组、集合、对等），它们可以安全地进行预编译。然而，对于其他一些关键类型，如 <code>Function</code> 或 <code>DataType</code> 和通用的用户定义类型，在这些类型中，你没有定义 <code>hash</code> 方法，回退 <code>hash</code> 方法取决于对象的内存地址（通过它的 <code>objectid</code>），因此可能会在运行时改变。如果你有这些键类型之一，或者如果你不确定，为了安全起见，你可以在你的 <code>__init__</code> 函数中初始化这个字典。或者，你也可以使用 <a href="https://docs.julialang.org/en/v1/base/collections/#Base.IdDict">IdDict</a> 字典类型，它由预编译特别处理，所以在编译时初始化是安全的。</p>
<p>在使用预编译时，保持对编译阶段和执行阶段的清晰认识很重要。在这种模式下，往往会更清楚地认识到 Julia 是一个允许执行任意 Julia 代码的编译器，而不是一个同时生成编译代码的独立解释器。</p>
<p>其他已知的潜在故障情况包括。</p>
<ol>
<li>全局计数器（例如，用于试图唯一识别对象）。考虑以下代码片段。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">mutable</span> <span class="k">struct</span> <span class="n">UniquedById</span><span class="o"></span>
    <span class="n">myid</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Int</span>
    <span class="k">let</span> <span class="n">counter</span><span class="o"></span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">UniquedById</span><span class="o"></span><span class="p">(</span><span class="p">)</span> <span class="o">=</span> <span class="n">new</span><span class="o"></span><span class="p">(</span><span class="n">counter</span><span class="o"></span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>虽然这段代码的目的是给每个实例一个唯一的 id，但计数器的值是在编译结束时记录的。这个增量编译模块的所有后续使用将从同一个计数器值开始。</p>
<p>请注意，<code>objectid</code>（通过哈希内存指针工作）也有类似的问题（参见下面关于 <code>Dict</code> 用法的说明）。</p>
<p>一种替代方法是使用宏来捕获 <a href="https://docs.julialang.org/en/v1/base/base/#Base.@__MODULE__">@<strong>MODULE</strong></a>，并将其与当前的计数器值一起单独存储，然而，重新设计代码使其不依赖于这个全局状态可能会更好。</p>
<ol start="2">
<li>
<p>关联集合(比如 <code>Dict</code> 和 <code>Set</code>)需要在 <code>__init__</code> 中重新洗牌(将来可能会提供一个机制来注册一个初始化函数)。</p>
</li>
<li>
<p>根据编译时的副作用在加载时持续存在。例如：修改其他 Julia 模块中的数组或其他变量；维护打开的文件或设备的句柄；存储其他系统资源（包括内存）的指针。</p>
</li>
<li>
<p>通过直接引用而不是通过它的查找路径，从另一个模块创建意外的全局状态&quot;副本&rdquo;。例如，（在全局作用域内）。</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="c">#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#</span>
<span class="c"># instead use accessor functions:</span>
<span class="n">getstdout</span><span class="o"></span><span class="p">(</span><span class="p">)</span> <span class="o">=</span> <span class="n">Base</span><span class="o"></span><span class="o">.</span><span class="n">stdout</span><span class="o"></span> <span class="cm">#=</span><span class="cm"> </span><span class="cm">b</span><span class="cm">e</span><span class="cm">s</span><span class="cm">t</span><span class="cm"> </span><span class="cm">o</span><span class="cm">p</span><span class="cm">t</span><span class="cm">i</span><span class="cm">o</span><span class="cm">n</span><span class="cm"> </span><span class="cm">=#</span>
<span class="c"># or move the assignment into the runtime:</span>
<span class="n">__init__</span><span class="o"></span><span class="p">(</span><span class="p">)</span> <span class="o">=</span> <span class="kd">global</span> <span class="n">mystdout</span><span class="o"></span> <span class="o">=</span> <span class="n">Base</span><span class="o"></span><span class="o">.</span><span class="n">stdout</span><span class="o"></span> <span class="cm">#=</span><span class="cm"> </span><span class="cm">a</span><span class="cm">l</span><span class="cm">s</span><span class="cm">o</span><span class="cm"> </span><span class="cm">w</span><span class="cm">o</span><span class="cm">r</span><span class="cm">k</span><span class="cm">s</span><span class="cm"> </span><span class="cm">=#</span>
</code></pre></div><p>对预编译代码时可以进行的操作进行了一些额外的限制，以帮助用户避免其他错误行为的情况。</p>
<ol>
<li>
<p>调用 <a href="https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.eval">eval</a> 引起另一个模块的副作用。当增量预编译标志被设置时，这也会导致发出警告。</p>
</li>
<li>
<p>在 <code>__init__()</code> 被启动后，从本地作用域调用 <code>global const</code> 语句(参见问题 <code>#12010</code>，计划为此增加一个错误)</p>
</li>
<li>
<p>在进行增量预编译时，替换一个模块是一个运行时错误。</p>
</li>
</ol>
<p>还有几点需要注意。</p>
<ol>
<li>
<p>在对源文件本身进行修改之后，不会进行代码重载/缓存无效化（包括通过 <code>Pkg.update</code>），而且在 <code>Pkg.rm</code> 之后也不会进行清理。</p>
</li>
<li>
<p>预编译不考虑重塑数组的内存共享行为 (每个视图都有自己的副本)</p>
</li>
<li>
<p>期待文件系统在编译时和运行时之间保持不变，例如 <a href="https://docs.julialang.org/en/v1/base/file/#Base.@__FILE__">@<strong>FILE</strong></a>/<code>source_path()</code> 在运行时查找资源，或者 BinDeps 的 <code>@checked_lib</code> 宏。有时这是不可避免的。然而，在可能的情况下，在编译时将资源复制到模块中是一个很好的做法，这样它们就不需要在运行时被找到。</p>
</li>
<li>
<p><code>WeakRef</code> 对象和 finalizers 目前还没有被序列化器正确处理（这将在即将发布的版本中得到修正）。</p>
</li>
<li>
<p>通常最好避免捕获对内部元数据对象实例的引用，如 <code>Method</code>、<code>MethodInstance</code>、<code>MethodTable</code>、<code>TypeMapLevel</code>、<code>TypeMapEntry</code> 以及这些对象的字段，因为这可能会混淆序列化器，可能不会导致你想要的结果。这样做不一定会出错，但你只需要做好准备，系统会尝试复制其中的一些对象，并为其他对象创建一个唯一的实例。</p>
</li>
</ol>
<p>在模块开发过程中，有时关闭增量预编译是很有帮助的。命令行标志 <code>--compiled-modules={yes|no}</code> 可以让你开启或关闭模块预编译。当 Julia 以 <code>--compiled-modules=no</code> 启动时，当加载模块和模块依赖时，编译缓存中的序列化模块会被忽略。<code>Base.compilecache</code> 仍然可以被手动调用。这个命令行标志的状态被传递给 <code>Pkg.build</code>，以便在安装、更新和显式构建包时禁用自动预编译触发。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia" term="julia" label="julia" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/module" term="module" label="module" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Julia 中的 Pkg]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-04-pkg-in-julia/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-04-dates-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的日期和时间" />
                <link href="https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 语言学习笔记" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-04-pkg-in-julia/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-04T00:00:00+08:00</published>
            <updated>2020-08-04T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Pkg</blockquote><h2 id="进入-pkg-模式">进入 Pkg 模式</h2>
<p>Pkg 是 Julia 中包管理工具。Pkg 来自于 REPL, 在 Julia 的 REPL 中按下 <code>]</code> 就进入 Pkg REPL 了。要回到 Julia REPL, 按退格键或 <code>^C</code>。</p>
<h2 id="使用-pkg">使用 Pkg</h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">add JSON              <span class="c1"># 添加一个 package</span>
add JSON StaticArrays <span class="c1"># 添加多个 package</span>
rm JSON               <span class="c1"># 移除一个 package</span>
rm JSON StaticArrays  <span class="c1"># 移除多个 package</span>
add https://github.com/JuliaLang/Example.jl <span class="c1"># 添加一个未注册的 package</span>
rm Example            <span class="c1"># 按名字移除 package</span>
update Example        <span class="c1"># 升级一个已安装的 package</span>
update                <span class="c1"># 升级所有已安装的 package</span>
</code></pre></div><h2 id="environments">environments</h2>
<p>你可能已经注意到 Pkg REPL 提示符前面的 <code>(@v1.5)</code> 字符串了。这里的  <code>(@v1.5)</code> 就是激活环境(<strong>active environment</strong>)。激活环境是能被诸如 <code>add</code>、<code>rm</code> 和 <code>update</code> 等 Pkg 命令修改的环境。</p>
<p>我们可以设置一个新的激活环境用于实验。要设置激活环境, 使用 <code>activate</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>@v1.5<span class="o">)</span> pkg&gt; activate tutorial
Activating new environment at <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span>
</code></pre></div><p><code>~/tutorial/Project.toml</code> 是激活环境的项目文件。项目文件是 Pkg 存储环境的元数据的地方。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; status
Status <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span> <span class="o">(</span>empty project<span class="o">)</span>
</code></pre></div><p>现在这个新的环境是空的, 我们添加一个 package 观察下:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; add Example
   Updating registry at <span class="sb">`</span>~/.julia/registries/General<span class="sb">`</span>
   Updating git-repo <span class="sb">`</span>https://github.com/JuliaRegistries/General.git<span class="sb">`</span>
  Resolving package versions...
    Cloning <span class="o">[</span>7876af07-990d-54b4-ab0e-23690620f79a<span class="o">]</span> Example from https://github.com/JuliaLang/Example.jl.git
  Installed Example ─ v0.5.3
Updating <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> + Example v0.5.3
Updating <span class="sb">`</span>~/tutorial/Manifest.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> + Example v0.5.3
</code></pre></div><p>用 <code>status</code> 命令查看激活环境的信息:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; status
Status <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> Example v0.5.3
</code></pre></div><p>使用 <code>develop</code> 命令设置 <code>Example</code> package 的 一个 <code>git clone</code>, 以供我们修改这个本地仓库:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; develop --local Example
    Cloning git-repo <span class="sb">`</span>https://github.com/JuliaLang/Example.jl.git<span class="sb">`</span>
  Resolving package versions...
Updating <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> ~ Example v0.5.3 ⇒ v0.5.4 <span class="sb">`</span>dev/Example<span class="sb">`</span>
Updating <span class="sb">`</span>~/tutorial/Manifest.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> ~ Example v0.5.3 ⇒ v0.5.4 <span class="sb">`</span>dev/Example<span class="sb">`</span>
</code></pre></div><p>用 <code>;</code> 切换到 shell 模式, 用 vi 修改 <code>~/tutorial/dev/Example/src/Example.jl</code> 文件, 增加一个 <code>plusone</code> 函数, 保存。</p>
<p>在 Julia 的 REPL 中, 导入修改后的 <code>Example</code> package:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; import Example
<span class="o">[</span> Info: Precompiling Example <span class="o">[</span>7876af07-990d-54b4-ab0e-23690620f79a<span class="o">]</span>

julia&gt; Example.plusone<span class="o">(</span>1<span class="o">)</span>
<span class="m">2</span>

julia&gt; Example.plusone<span class="o">(</span>4<span class="o">)</span>
<span class="m">5</span>
</code></pre></div><p>可以看到我们添加的函数生效了, 这样就很方便我们添加测试新功能。如果我们已经不再需要本地的 <code>Example</code> 了, 需要使用 <code>free</code> 命令以停止使用本地克隆的 package, 转而使用已注册版本代替:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; free Example
  Resolving package versions...
Updating <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> ~ Example v0.5.4 <span class="sb">`</span>dev/Example<span class="sb">`</span> ⇒ v0.5.3
Updating <span class="sb">`</span>~/tutorial/Manifest.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> ~ Example v0.5.4 <span class="sb">`</span>dev/Example<span class="sb">`</span> ⇒ v0.5.3
</code></pre></div><p>如果已经用 <code>tutorial</code> 做完实验了, 可以使用不带参数的 <code>activate</code> 回到默认环境:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; activate
 Activating environment at <span class="sb">`</span>~/.julia/environments/v1.5/Project.toml<span class="sb">`</span>

<span class="o">(</span>@v1.5<span class="o">)</span> pkg&gt; 
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia" term="julia" label="julia" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/pkg" term="pkg" label="pkg" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Julia 中的日期和时间]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-04-dates-in-julia/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-04-pkg-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的 Pkg" />
                <link href="https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 语言学习笔记" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-04-dates-in-julia/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-04T00:00:00+08:00</published>
            <updated>2020-08-04T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Dates in Julia</blockquote><h1 id="dates-模块的加载和使用">Dates 模块的加载和使用</h1>
<p>在 Julia 的 Pkg REPL 中, 输入 <code>add Dates</code> 添加 Dates 模块。回到 Julia 的 REPL 中, 输入:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; using Dates

julia&gt; DateTime<span class="o">(</span>2020<span class="o">)</span>
2020-01-01T00:00:00

julia&gt; typeof<span class="o">(</span>DateTime<span class="o">(</span>2020<span class="o">)</span><span class="o">)</span>
DateTime

julia&gt; DateTime<span class="o">(</span>2020,8,1<span class="o">)</span>
2020-08-01T00:00:00

julia&gt; DateTime<span class="o">(</span>2020,8,1,12<span class="o">)</span>
2020-08-01T12:00:00

julia&gt; DateTime<span class="o">(</span>2020,8,1,12,30<span class="o">)</span>
2020-08-01T12:30:00

julia&gt; DateTime<span class="o">(</span>2020,8,1,12,30,59<span class="o">)</span>
2020-08-01T12:30:59

julia&gt; DateTime<span class="o">(</span>2020,8,1,12,30,59, 999<span class="o">)</span>
2020-08-01T12:30:59.999

julia&gt; Date<span class="o">(</span>2020, 8<span class="o">)</span>
2020-08-01

julia&gt; Date<span class="o">(</span>2020, 8, 1<span class="o">)</span>
2020-08-01

julia&gt; Date<span class="o">(</span>Dates.Year<span class="o">(</span>2020<span class="o">)</span>,Dates.Month<span class="o">(</span>8<span class="o">)</span>,Dates.Day<span class="o">(</span>1<span class="o">)</span><span class="o">)</span>
2020-08-01

julia&gt; Date<span class="o">(</span>Dates.Month<span class="o">(</span>8<span class="o">)</span>,Dates.Year<span class="o">(</span>2020<span class="o">)</span><span class="o">)</span>
2020-08-01
</code></pre></div><h1 id="date-和-datetime-的算术操作">Date 和 DateTime 的算术操作</h1>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">dt</span> <span class="o">=</span> Date<span class="o">(</span>2012,2,29<span class="o">)</span>
2012-02-29

julia&gt; <span class="nv">dt2</span> <span class="o">=</span> Date<span class="o">(</span>2000,2,1<span class="o">)</span>
2000-02-01

julia&gt; dump<span class="o">(</span>dt<span class="o">)</span>
Date
  instant: Dates.UTInstant<span class="o">{</span>Day<span class="o">}</span>
    periods: Day
      value: Int64 <span class="m">734562</span>

julia&gt; dump<span class="o">(</span>dt2<span class="o">)</span>
Date
  instant: Dates.UTInstant<span class="o">{</span>Day<span class="o">}</span>
    periods: Day
      value: Int64 <span class="m">730151</span>

julia&gt; dt &gt; dt2
<span class="nb">true</span>

julia&gt; dt !<span class="o">=</span> dt2
<span class="nb">true</span>

julia&gt; dt + dt2
ERROR: MethodError: no method matching +<span class="o">(</span>::Date, ::Date<span class="o">)</span>
<span class="o">[</span>...<span class="o">]</span>

julia&gt; dt * dt2
ERROR: MethodError: no method matching *<span class="o">(</span>::Date, ::Date<span class="o">)</span>
<span class="o">[</span>...<span class="o">]</span>

julia&gt; dt / dt2
ERROR: MethodError: no method matching /<span class="o">(</span>::Date, ::Date<span class="o">)</span>

julia&gt; dt - dt2
<span class="m">4411</span> days

julia&gt; typeof<span class="o">(</span>dt - dt2<span class="o">)</span>
Day

julia&gt; dt2 - dt
-4411 days

julia&gt; <span class="nv">dt</span> <span class="o">=</span> DateTime<span class="o">(</span>2012,2,29<span class="o">)</span>
2012-02-29T00:00:00

julia&gt; <span class="nv">dt2</span> <span class="o">=</span> DateTime<span class="o">(</span>2000,2,1<span class="o">)</span>
2000-02-01T00:00:00

julia&gt; dt - dt2
<span class="m">381110400000</span> milliseconds

julia&gt; typeof<span class="o">(</span>dt - dt2<span class="o">)</span>
Millisecond
</code></pre></div><h1 id="访问器函数">访问器函数</h1>
<p>因为 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.Date">Date</a> 和 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateTime">DateTime</a> 类型被存储为单个 <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Int64">Int64</a> 值，所以日期部分或字段可以通过访问器函数进行检索。小写访问器函数以整数形式返回字段。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">t</span> <span class="o">=</span> Date<span class="o">(</span>2014, 1, 31<span class="o">)</span>
2014-01-31

julia&gt; Dates.year<span class="o">(</span>t<span class="o">)</span>
<span class="m">2014</span>

julia&gt; Dates.month<span class="o">(</span>t<span class="o">)</span>
<span class="m">1</span>

julia&gt; Dates.week<span class="o">(</span>t<span class="o">)</span>
<span class="m">5</span>

julia&gt; Dates.day<span class="o">(</span>t<span class="o">)</span>
<span class="m">31</span>
</code></pre></div><p>而专有形式返回相应 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.Period">Period</a> 类型中的相同值。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.Year<span class="o">(</span>t<span class="o">)</span>
<span class="m">2014</span> years

julia&gt; Dates.Day<span class="o">(</span>t<span class="o">)</span>
<span class="m">31</span> days
</code></pre></div><p>Julia 还提供了复合方法，因为在同时需要多个字段的情况下，这些方法提供了一种效率衡量标准。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.yearmonth<span class="o">(</span>t<span class="o">)</span>
<span class="o">(</span>2014, 1<span class="o">)</span>

julia&gt; Dates.monthday<span class="o">(</span>t<span class="o">)</span>
<span class="o">(</span>1, 31<span class="o">)</span>

julia&gt; Dates.yearmonthday<span class="o">(</span>t<span class="o">)</span>
<span class="o">(</span>2014, 1, 31<span class="o">)</span>
</code></pre></div><p>也可以访问底层 <code>UTInstant</code> 或整数值。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; dump<span class="o">(</span>t<span class="o">)</span>
Date
  instant: Dates.UTInstant<span class="o">{</span>Day<span class="o">}</span>
    periods: Day
      value: Int64 <span class="m">735264</span>

julia&gt; t.instant
Dates.UTInstant<span class="o">{</span>Day<span class="o">}</span><span class="o">(</span>Day<span class="o">(</span>735264<span class="o">)</span><span class="o">)</span>

julia&gt; Dates.value<span class="o">(</span>t<span class="o">)</span>
<span class="m">735264</span>
</code></pre></div><h1 id="查询函数">查询函数</h1>
<p>查询函数提供关于 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.TimeType">TimeType</a> 的历法信息。它们包括关于一周中的某一天的信息。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">t</span> <span class="o">=</span> Date<span class="o">(</span>2014, 1, 31<span class="o">)</span>
2014-01-31

julia&gt; Dates.dayofweek<span class="o">(</span>t<span class="o">)</span>
<span class="m">5</span>

julia&gt; Dates.dayname<span class="o">(</span>t<span class="o">)</span>
<span class="s2">&#34;Friday&#34;</span>

julia&gt; Dates.dayofweekofmonth<span class="o">(</span>t<span class="o">)</span> <span class="c1"># 5th Friday of January</span>
<span class="m">5</span>

julia&gt; Dates.monthname<span class="o">(</span>t<span class="o">)</span>
<span class="s2">&#34;January&#34;</span>

julia&gt; Dates.daysinmonth<span class="o">(</span>t<span class="o">)</span>
<span class="m">31</span>
</code></pre></div><p>以及 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.TimeType">TimeType</a> 的年份和季度信息。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.isleapyear<span class="o">(</span>t<span class="o">)</span>
<span class="nb">false</span>

julia&gt; Dates.dayofyear<span class="o">(</span>t<span class="o">)</span>
<span class="m">31</span>

julia&gt; Dates.quarterofyear<span class="o">(</span>t<span class="o">)</span>
<span class="m">1</span>

julia&gt; Dates.dayofquarter<span class="o">(</span>t<span class="o">)</span>
<span class="m">31</span>
</code></pre></div><p><a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.dayname">dayname</a> 和 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.monthname">monthname</a> 方法也可以使用一个可选的 <code>locale</code> 关键字，它可以用来返回其他语言/地区的年份或月份的名称。这些函数也有返回缩写名称的版本，即 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.dayabbr">dayabbr</a> 和 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.monthabbr">monthabbr</a>。首先将映射加载到 <code>LOCALES</code> 变量中。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">french_months</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&#34;janvier&#34;</span>, <span class="s2">&#34;février&#34;</span>, <span class="s2">&#34;mars&#34;</span>, <span class="s2">&#34;avril&#34;</span>, <span class="s2">&#34;mai&#34;</span>, <span class="s2">&#34;juin&#34;</span>,
                        <span class="s2">&#34;juillet&#34;</span>, <span class="s2">&#34;août&#34;</span>, <span class="s2">&#34;septembre&#34;</span>, <span class="s2">&#34;octobre&#34;</span>, <span class="s2">&#34;novembre&#34;</span>, <span class="s2">&#34;décembre&#34;</span><span class="o">]</span><span class="p">;</span>

julia&gt; <span class="nv">french_monts_abbrev</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&#34;janv&#34;</span>,<span class="s2">&#34;févr&#34;</span>,<span class="s2">&#34;mars&#34;</span>,<span class="s2">&#34;avril&#34;</span>,<span class="s2">&#34;mai&#34;</span>,<span class="s2">&#34;juin&#34;</span>,
                              <span class="s2">&#34;juil&#34;</span>,<span class="s2">&#34;août&#34;</span>,<span class="s2">&#34;sept&#34;</span>,<span class="s2">&#34;oct&#34;</span>,<span class="s2">&#34;nov&#34;</span>,<span class="s2">&#34;déc&#34;</span><span class="o">]</span><span class="p">;</span>

julia&gt; <span class="nv">french_days</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&#34;lundi&#34;</span>,<span class="s2">&#34;mardi&#34;</span>,<span class="s2">&#34;mercredi&#34;</span>,<span class="s2">&#34;jeudi&#34;</span>,<span class="s2">&#34;vendredi&#34;</span>,<span class="s2">&#34;samedi&#34;</span>,<span class="s2">&#34;dimanche&#34;</span><span class="o">]</span><span class="p">;</span>

julia&gt; Dates.LOCALES<span class="o">[</span><span class="s2">&#34;french&#34;</span><span class="o">]</span> <span class="o">=</span> Dates.DateLocale<span class="o">(</span>french_months, french_monts_abbrev, french_days, <span class="o">[</span><span class="s2">&#34;&#34;</span><span class="o">]</span><span class="o">)</span><span class="p">;</span>
</code></pre></div><p>然后可以利用上述函数进行查询。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.dayname<span class="o">(</span>t<span class="p">;</span><span class="nv">locale</span><span class="o">=</span><span class="s2">&#34;french&#34;</span><span class="o">)</span>
<span class="s2">&#34;vendredi&#34;</span>

julia&gt; Dates.monthname<span class="o">(</span>t<span class="p">;</span><span class="nv">locale</span><span class="o">=</span><span class="s2">&#34;french&#34;</span><span class="o">)</span>
<span class="s2">&#34;janvier&#34;</span>

julia&gt; Dates.monthabbr<span class="o">(</span>t<span class="p">;</span><span class="nv">locale</span><span class="o">=</span><span class="s2">&#34;french&#34;</span><span class="o">)</span>
<span class="s2">&#34;janv&#34;</span>
</code></pre></div><p>由于没有加载日期的缩写版本，试图使用函数 <code>dayabbr</code> 会出错。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.dayabbr<span class="o">(</span>t<span class="p">;</span><span class="nv">locale</span><span class="o">=</span><span class="s2">&#34;french&#34;</span><span class="o">)</span>
ERROR: BoundsError: attempt to access 1-element Array<span class="o">{</span>String,1<span class="o">}</span> at index <span class="o">[</span>5<span class="o">]</span>
Stacktrace:
<span class="o">[</span>...<span class="o">]</span>
</code></pre></div><h1 id="时间类型-周期算术">时间类型-周期算术</h1>
<p>在使用任何语言/日期框架时，熟悉如何处理日期-周期算术是一个很好的做法，因为有一些<a href="https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/">棘手的问题</a>需要处理（尽管对于日-精度类型来说要少得多）。</p>
<p><code>Dates</code> 模块的方法试图遵循简单的原则，即在做 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.Period">Period</a> 算术时尽量少改。这种方法也常被称为历法算术，或者说如果有人在对话中问你同样的计算方法，你可能会猜到。为什么要大惊小怪呢？我们举个经典的例子：把2014年1月31日加1个月。答案是什么？Javascript 会说<a href="https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/">3月3日</a>（假设31天）。PHP 会说<a href="https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month">3月2日</a>（假设30天）。事实上，没有正确的答案。在 <code>Dates</code> 模块中，它给出的结果是2月28日。它是如何计算出来的呢？我喜欢想到赌场里经典的 7-7-7 赌博游戏。</p>
<p>现在只要想象一下，老虎机不是 7-7-7，而是年-月-日，或者在我们的例子中，2014-01-31。当你要求在这个日期的基础上增加1个月的时候，月份槽就会递增，所以现在我们有 2014-02-31。然后检查日号是否大于新月份的最后有效日，如果大于（如上例），则日号向下调整到最后有效日（28）。这种方法的后果是什么呢？继续在我们的日期上再加一个月，<code>2014-02-28 + Month(1) == 2014-03-28</code>。什么？你是在期待3月的最后一天吗？不对，对不起，记得 7-7-7 的档期。尽可能少的槽位要改变，所以我们先把月份槽位递增1，2014-03-28，轰，我们就完成了，因为这是一个有效的日期。另一方面，如果我们要在原来的日期 2014-01-31 的基础上增加2个月，那么我们最终的结果是 2014-03-31，正如预期的那样。这种方法的另一个后果是，当强行进行特定的排序时，关联性会有所损失（即以不同的顺序添加东西会导致不同的结果）。比如说：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="o">(</span>Date<span class="o">(</span>2014,1,29<span class="o">)</span>+Dates.Day<span class="o">(</span>1<span class="o">)</span><span class="o">)</span> + Dates.Month<span class="o">(</span>1<span class="o">)</span>
2014-02-28

julia&gt; <span class="o">(</span>Date<span class="o">(</span>2014,1,29<span class="o">)</span>+Dates.Month<span class="o">(</span>1<span class="o">)</span><span class="o">)</span> + Dates.Day<span class="o">(</span>1<span class="o">)</span>
2014-03-01
</code></pre></div><p>那是怎么回事呢？在第一行中，我们在1月29日的基础上加1天，结果是 2014-01-30；然后再加1个月，于是得到 2014-02-30，再往下调整为 2014-02-28。在第二个例子中，我们先加1个月，我们得到 2014-02-29，再往下调整为 2014-02-28，然后再加1天，结果是 2014-03-01。在这种情况下，有一个设计原则是有帮助的，那就是在存在多个 Periods 的情况下，操作将按照 Periods 的类型来排序，而不是按照它们的值或位置顺序来排序；这意味着总是先加 <code>Year</code>，然后加 <code>Month</code>，再加 <code>Week</code> 等。因此，以下确实会导致关联性并正好有用:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Date<span class="o">(</span>2014,1,29<span class="o">)</span> + Dates.Day<span class="o">(</span>1<span class="o">)</span> + Dates.Month<span class="o">(</span>1<span class="o">)</span>
2014-03-01

julia&gt; Date<span class="o">(</span>2014,1,29<span class="o">)</span> + Dates.Month<span class="o">(</span>1<span class="o">)</span> + Dates.Day<span class="o">(</span>1<span class="o">)</span>
2014-03-01
</code></pre></div><p>棘手吗？也许吧。一个无辜的 <code>Dates</code> 用户该怎么做？最重要的是要注意，当处理月份时，明确地强制执行某种关联性，可能会导致一些意想不到的结果，但除此之外，一切都应该按照预期工作。值得庆幸的是，在 UT 中处理时间时，日期-周期算术中的奇特情况几乎就是这样了（避免了处理夏令时、闰秒等的 &ldquo;乐趣&rdquo;）。</p>
<p>作为奖励，所有的周期算术对象都可以直接与范围一起工作。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">dr</span> <span class="o">=</span> Date<span class="o">(</span>2014,1,29<span class="o">)</span>:Day<span class="o">(</span>1<span class="o">)</span>:Date<span class="o">(</span>2014,2,3<span class="o">)</span>
Date<span class="o">(</span><span class="s2">&#34;2014-01-29&#34;</span><span class="o">)</span>:Day<span class="o">(</span>1<span class="o">)</span>:Date<span class="o">(</span><span class="s2">&#34;2014-02-03&#34;</span><span class="o">)</span>

julia&gt; collect<span class="o">(</span>dr<span class="o">)</span>
6-element Array<span class="o">{</span>Date,1<span class="o">}</span>:
 2014-01-29
 2014-01-30
 2014-01-31
 2014-02-01
 2014-02-02
 2014-02-03

julia&gt; <span class="nv">dr</span> <span class="o">=</span> Date<span class="o">(</span>2014,1,29<span class="o">)</span>:Dates.Month<span class="o">(</span>1<span class="o">)</span>:Date<span class="o">(</span>2014,07,29<span class="o">)</span>
Date<span class="o">(</span><span class="s2">&#34;2014-01-29&#34;</span><span class="o">)</span>:Month<span class="o">(</span>1<span class="o">)</span>:Date<span class="o">(</span><span class="s2">&#34;2014-07-29&#34;</span><span class="o">)</span>

julia&gt; collect<span class="o">(</span>dr<span class="o">)</span>
7-element Array<span class="o">{</span>Date,1<span class="o">}</span>:
 2014-01-29
 2014-02-28
 2014-03-29
 2014-04-29
 2014-05-29
 2014-06-29
 2014-07-29
</code></pre></div><pre><code>for i in Date(&quot;2020-08-01&quot;):Day(1):Date(&quot;2020-08-09&quot;)
           println(i)
end

2020-08-01
2020-08-02
2020-08-03
2020-08-04
2020-08-05
2020-08-06
2020-08-07
2020-08-08
2020-08-09
</code></pre><h1 id="调整器函数">调整器函数</h1>
<p>尽管日期-周期算术很方便，但经常需要在日期上进行的计算具有日历或时间的性质，而不是固定的周期数。节日就是一个很好的例子，大多数都遵循这样的规则：&ldquo;纪念日 = 五月的最后一个星期一&rdquo;，或者 &ldquo;感恩节 = 十一月的第四个星期四&rdquo;。这类时间表达式处理的是相对于日历的规则，比如本月的第一天或最后一天，下周二，或第一个和第三个星期三等。</p>
<p><code>Dates</code> 模块通过几个方便的方法提供了调整器 API，这些方法有助于简单、简洁地表达时间规则。第一组调整器方法处理周、月、季度和年的首尾。它们每个方法都接收一个单一的 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.TimeType">TimeType</a> 作为输入，并返回或调整到相对于输入的所需时期的第一个或最后一个。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.firstdayofweek<span class="o">(</span>Date<span class="o">(</span>2014,7,16<span class="o">)</span><span class="o">)</span> <span class="c1"># Adjusts the input to the Monday of the input&#39;s week</span>
2014-07-14

julia&gt; Dates.lastdayofmonth<span class="o">(</span>Date<span class="o">(</span>2014,7,16<span class="o">)</span><span class="o">)</span> <span class="c1"># Adjusts to the last day of the input&#39;s month</span>
2014-07-31

julia&gt; Dates.lastdayofquarter<span class="o">(</span>Date<span class="o">(</span>2014,7,16<span class="o">)</span><span class="o">)</span> <span class="c1"># Adjusts to the last day of the input&#39;s quarter</span>
2014-09-30
</code></pre></div><p>接下来的两个高阶方法 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.tonext-Tuple%7BTimeType,Int64%7D">tonext</a> 和 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.toprev-Tuple%7BTimeType,Int64%7D">toprev</a>，通过将一个 <code>DateFunction</code> 和一个起始 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.TimeType">TimeType</a> 作为第一个参数来概括处理时间表达式。<code>DateFunction</code> 只是一个函数，通常是匿名的，它接受一个单一的 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.TimeType">TimeType</a> 作为输入，并返回一个 <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Bool">Bool</a>，<code>true</code> 表示满足调整标准。例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">istuesday</span> <span class="o">=</span> x-&gt;Dates.dayofweek<span class="o">(</span>x<span class="o">)</span> <span class="o">=</span><span class="o">=</span> Dates.Tuesday<span class="p">;</span> <span class="c1"># Returns true if the day of the week of x is Tuesday</span>

julia&gt; Dates.tonext<span class="o">(</span>istuesday, Date<span class="o">(</span>2014,7,13<span class="o">)</span><span class="o">)</span> <span class="c1"># 2014-07-13 is a Sunday</span>
2014-07-15

julia&gt; Dates.tonext<span class="o">(</span>Date<span class="o">(</span>2014,7,13<span class="o">)</span>, Dates.Tuesday<span class="o">)</span> <span class="c1"># Convenience method provided for day of the week adjustments</span>
2014-07-15
</code></pre></div><p>这对于更复杂的时间表达式的 do-block 语法是很有用的。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.tonext<span class="o">(</span>Date<span class="o">(</span>2014,7,13<span class="o">)</span><span class="o">)</span> <span class="k">do</span> x
           <span class="c1"># Return true on the 4th Thursday of November (Thanksgiving)</span>
           Dates.dayofweek<span class="o">(</span>x<span class="o">)</span> <span class="o">=</span><span class="o">=</span> Dates.Thursday <span class="o">&amp;&amp;</span>
           Dates.dayofweekofmonth<span class="o">(</span>x<span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="m">4</span> <span class="o">&amp;&amp;</span>
           Dates.month<span class="o">(</span>x<span class="o">)</span> <span class="o">=</span><span class="o">=</span> Dates.November
       end
2014-11-27
</code></pre></div><p><a href="https://docs.julialang.org/en/v1/base/collections/#Base.filter">Base.filter</a> 方法可以用来获取指定范围内的所有有效日期/时刻。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 匹兹堡街道清洁; 从 4月到11月的每第二个周二</span>
<span class="c1"># 日期范围从 2014-01-01 到 2015-01-01</span>
julia&gt; <span class="nv">dr</span> <span class="o">=</span> Dates.Date<span class="o">(</span>2014<span class="o">)</span>:Day<span class="o">(</span>1<span class="o">)</span>:Dates.Date<span class="o">(</span>2015<span class="o">)</span><span class="p">;</span>

julia&gt; filter<span class="o">(</span>dr<span class="o">)</span> <span class="k">do</span> x
           Dates.dayofweek<span class="o">(</span>x<span class="o">)</span> <span class="o">=</span><span class="o">=</span> Dates.Tue <span class="o">&amp;&amp;</span>
           Dates.April &lt;<span class="o">=</span> Dates.month<span class="o">(</span>x<span class="o">)</span> &lt;<span class="o">=</span> Dates.Nov <span class="o">&amp;&amp;</span>
           Dates.dayofweekofmonth<span class="o">(</span>x<span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="m">2</span>
       end
8-element Array<span class="o">{</span>Date,1<span class="o">}</span>:
 2014-04-08
 2014-05-13
 2014-06-10
 2014-07-08
 2014-08-12
 2014-09-09
 2014-10-14
 2014-11-11
</code></pre></div><p>在 Raku 中上面的代码可以写成:</p>
<pre><code class="language-raku" data-lang="raku">lazy my @dates = Date.new('2014-01-01') ... Date.new('2015-01-01');

.say for @dates.grep: -&gt; $d {
    $d.day-of-week == 2 &amp;&amp;
    4  &lt;= $d.month &lt;= 11 &amp;&amp;
    $d.weekday-of-month == 2
}
</code></pre><p>其他的例子和测试可以在 <a href="https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl">stdlib/Dates/test/adjusters.jl</a> 中找到。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia" term="julia" label="julia" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/dates" term="dates" label="dates" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Julia 语言学习笔记]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-26T00:00:00+08:00</published>
            <updated>2020-07-26T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Learning Julia</blockquote><h2 id="语法">语法</h2>
<h3 id="数值字面量系数">数值字面量系数</h3>
<p>在标识符或圆括号前面直接放一个数字, 例如 <code>2x</code> 或 <code>2(x+y)</code>, 会被认为是把标识符和它前面的数字相乘。这样写多项式就很方便了。</p>
<h3 id="向量化的点号运算符">向量化的点号运算符</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">.+</span> <span class="mi">3</span>

<span class="mi">3</span><span class="o">-</span><span class="n">element</span><span class="o"></span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">4</span>
 <span class="mi">5</span>
 <span class="mi">6</span>
</code></pre></div><p><code>.+</code> 类似于 Raku 中的 <code>»+»</code> 超运算符:</p>
<pre><code class="language-raku" data-lang="raku">[1,2,3] »+» 3
[4 5 6]
</code></pre><p>但是 Julia 的 <code>Vectorized &quot;dot&quot;</code> 语法没有 Raku 的超运算符语法清晰。</p>
<p>类似的例子还有:</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">sin</span><span class="o"></span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="c"># 0.479425538604203</span>

<span class="n">A</span><span class="o"></span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">]</span>
<span class="n">sin</span><span class="o"></span><span class="o">.</span><span class="p">(</span><span class="n">A</span><span class="o"></span><span class="p">)</span>

<span class="mi">3</span><span class="o">-</span><span class="n">element</span><span class="o"></span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">0.479425538604203</span>
 <span class="mf">0.8414709848078965</span>
 <span class="mf">0.9974949866040544</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">f</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="p">,</span><span class="n">y</span><span class="o"></span><span class="p">)</span> <span class="o">=</span> <span class="mi">3</span><span class="n">x</span><span class="o"></span> <span class="o">+</span> <span class="mi">4</span><span class="n">y</span><span class="o"></span><span class="p">;</span>
<span class="n">A</span><span class="o"></span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span><span class="p">;</span>
<span class="n">B</span><span class="o"></span> <span class="o">=</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">]</span><span class="p">;</span>
<span class="n">f</span><span class="o"></span><span class="o">.</span><span class="p">(</span><span class="nb">pi</span><span class="p">,</span> <span class="n">A</span><span class="o"></span><span class="p">)</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span><span class="o"></span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">13.42477796076938</span>
 <span class="mf">17.42477796076938</span>
 <span class="mf">21.42477796076938</span>

<span class="n">f</span><span class="o"></span><span class="o">.</span><span class="p">(</span><span class="n">A</span><span class="o"></span><span class="p">,</span> <span class="nb">pi</span><span class="p">)</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span><span class="o"></span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">15.566370614359172</span>
 <span class="mf">18.566370614359172</span>
 <span class="mf">21.566370614359172</span>

<span class="n">f</span><span class="o"></span><span class="o">.</span><span class="p">(</span><span class="n">A</span><span class="o"></span><span class="p">,</span><span class="n">B</span><span class="o"></span><span class="p">)</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span><span class="o"></span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">19.0</span>
 <span class="mf">26.0</span>
 <span class="mf">33.0</span>
</code></pre></div><p>等价的 Raku 写法为:</p>
<pre><code class="language-raku" data-lang="raku">sub f(\x, \y) { 3*x + 4*y};

my \A = [1.0, 2.0, 3.0];
my \B = [4.0, 5.0, 6.0];

A».&amp;f(pi)
[15.566370614359172 18.566370614359172 21.566370614359172]
</code></pre><h3 id="链式比较">链式比较</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">&lt;</span><span class="o">=</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">=</span><span class="o">=</span> <span class="mi">3</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">&gt;</span><span class="o">=</span> <span class="mi">1</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">5</span>
<span class="kc">true</span>
</code></pre></div><p>Raku 同样支持这种链式比较。</p>
<h3 id="虚数">虚数</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">real</span><span class="o"></span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="nb">im</span><span class="p">)</span>         <span class="c"># 1</span>
<span class="n">imag</span><span class="o"></span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="nb">im</span><span class="p">)</span>         <span class="c"># 2</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="nb">im</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="nb">im</span><span class="p">)</span> <span class="c"># 5 + 0im</span>
</code></pre></div><pre><code class="language-raku" data-lang="raku">(1 + 2i).re         # 1
(1 + 2i).im         # 2
(1 + 2i) * (1 - 2i) # 5+0i
</code></pre><h3 id="命名参数">命名参数</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">function</span> <span class="n">plot</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="p">,</span> <span class="n">y</span><span class="o"></span><span class="p">;</span> <span class="n">style</span><span class="o"></span><span class="o">=</span><span class="s">&#34;</span><span class="s">s</span><span class="s">o</span><span class="s">l</span><span class="s">i</span><span class="s">d</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">width</span><span class="o"></span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o"></span><span class="o">=</span><span class="s">&#34;</span><span class="s">b</span><span class="s">l</span><span class="s">a</span><span class="s">c</span><span class="s">k</span><span class="s">&#34;</span><span class="p">)</span>
    <span class="c">###</span>
<span class="k">end</span>

<span class="n">plot</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="p">,</span> <span class="n">y</span><span class="o"></span><span class="p">,</span> <span class="n">width</span><span class="o"></span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plot</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="p">,</span> <span class="n">y</span><span class="o"></span><span class="p">,</span> <span class="o">:</span><span class="n">width</span><span class="o"></span> <span class="o">=</span><span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div><h3 id="函数组合">函数组合</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="p">(</span><span class="n">sqrt</span><span class="o"></span> <span class="n">∘</span><span class="o"></span> <span class="o">+</span><span class="p">)</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span> <span class="c"># 3.0</span>

<span class="n">map</span><span class="o"></span><span class="p">(</span><span class="n">first</span><span class="o"></span> <span class="n">∘</span><span class="o"></span> <span class="n">reverse</span><span class="o"></span> <span class="n">∘</span><span class="o"></span> <span class="n">uppercase</span><span class="o"></span><span class="p">,</span> <span class="n">split</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">y</span><span class="s">o</span><span class="s">u</span><span class="s"> </span><span class="s">c</span><span class="s">a</span><span class="s">n</span><span class="s"> </span><span class="s">c</span><span class="s">o</span><span class="s">m</span><span class="s">p</span><span class="s">o</span><span class="s">s</span><span class="s">e</span><span class="s"> </span><span class="s">f</span><span class="s">u</span><span class="s">n</span><span class="s">c</span><span class="s">t</span><span class="s">i</span><span class="s">o</span><span class="s">n</span><span class="s">s</span><span class="s"> </span><span class="s">l</span><span class="s">i</span><span class="s">k</span><span class="s">e</span><span class="s"> </span><span class="s">t</span><span class="s">h</span><span class="s">i</span><span class="s">s</span><span class="s">&#34;</span><span class="p">)</span><span class="p">)</span>
<span class="mi">6</span><span class="o">-</span><span class="n">element</span><span class="o"></span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Char</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="sc">&#39;U&#39;</span>
 <span class="sc">&#39;N&#39;</span>
 <span class="sc">&#39;E&#39;</span>
 <span class="sc">&#39;S&#39;</span>
 <span class="sc">&#39;E&#39;</span>
 <span class="sc">&#39;S&#39;</span>
</code></pre></div><h3 id="piping">Piping</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="mi">1</span><span class="o">:</span><span class="mi">10</span> <span class="o">|&gt;</span> <span class="n">sum</span><span class="o"></span> <span class="o">|&gt;</span> <span class="n">sqrt</span><span class="o"></span> <span class="c"># 7.416198487095663</span>

<span class="c"># 等价于</span>
<span class="p">(</span><span class="n">sqrt</span><span class="o"></span> <span class="n">∘</span><span class="o"></span> <span class="n">sum</span><span class="o"></span><span class="p">)</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span><span class="p">)</span>  <span class="c"># 7.416198487095663</span>
</code></pre></div><h3 id="广播和管道一起使用">广播和管道一起使用</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="p">[</span><span class="s">&#34;</span><span class="s">a</span><span class="s">&#34;</span><span class="p">,</span> <span class="s">&#34;</span><span class="s">l</span><span class="s">i</span><span class="s">s</span><span class="s">t</span><span class="s">&#34;</span><span class="p">,</span> <span class="s">&#34;</span><span class="s">o</span><span class="s">f</span><span class="s">&#34;</span><span class="p">,</span> <span class="s">&#34;</span><span class="s">s</span><span class="s">t</span><span class="s">r</span><span class="s">i</span><span class="s">n</span><span class="s">g</span><span class="s">s</span><span class="s">&#34;</span><span class="p">]</span> <span class="o">.</span><span class="o">|&gt;</span> <span class="p">[</span><span class="n">uppercase</span><span class="o"></span><span class="p">,</span> <span class="n">reverse</span><span class="o"></span><span class="p">,</span> <span class="n">titlecase</span><span class="o"></span><span class="p">,</span> <span class="n">length</span><span class="o"></span><span class="p">]</span>
<span class="mi">4</span><span class="o">-</span><span class="n">element</span><span class="o"></span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Any</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
  <span class="s">&#34;</span><span class="s">A</span><span class="s">&#34;</span>
  <span class="s">&#34;</span><span class="s">t</span><span class="s">s</span><span class="s">i</span><span class="s">l</span><span class="s">&#34;</span>
  <span class="s">&#34;</span><span class="s">O</span><span class="s">f</span><span class="s">&#34;</span>
 <span class="mi">7</span>
</code></pre></div><h3 id="组合类型">组合类型</h3>
<ul>
<li>不可变组合类型</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">struct</span> <span class="n">Foo</span><span class="o"></span>
    <span class="n">bar</span><span class="o"></span>
    <span class="n">baz</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Int</span>
    <span class="n">qux</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Float64</span>
<span class="k">end</span>

<span class="n">foo</span><span class="o"></span> <span class="o">=</span> <span class="n">Foo</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">r</span><span class="s">a</span><span class="s">k</span><span class="s">u</span><span class="s">l</span><span class="s">a</span><span class="s">n</span><span class="s">g</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="n">typeof</span><span class="o"></span><span class="p">(</span><span class="n">foo</span><span class="o"></span><span class="p">)</span> <span class="c"># Foo</span>
<span class="n">typeof</span><span class="o"></span><span class="p">(</span><span class="n">Foo</span><span class="o"></span><span class="p">)</span> <span class="c"># DataType</span>

<span class="n">foo</span><span class="o"></span><span class="o">.</span><span class="n">bar</span><span class="o"></span>     <span class="c"># rakulang</span>
<span class="n">foo</span><span class="o"></span><span class="o">.</span><span class="n">qux</span><span class="o"></span>     <span class="c"># 1.5</span>
<span class="n">foo</span><span class="o"></span><span class="o">.</span><span class="n">qux</span><span class="o"></span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># ERROR: setfield! immutable struct of type Foo cannot be changed</span>
</code></pre></div><ul>
<li>可变组合类型</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">mutable</span> <span class="k">struct</span> <span class="n">Bar</span><span class="o"></span>
    <span class="n">baz</span><span class="o"></span>
    <span class="n">qux</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Float64</span>
<span class="k">end</span>

<span class="n">bar</span><span class="o"></span> <span class="o">=</span> <span class="n">Bar</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">r</span><span class="s">a</span><span class="s">k</span><span class="s">u</span><span class="s">d</span><span class="s">o</span><span class="s">&#34;</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">)</span>
<span class="n">bar</span><span class="o"></span><span class="o">.</span><span class="n">baz</span><span class="o"></span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="o">/</span><span class="mi">2</span>
<span class="n">bar</span><span class="o"></span><span class="o">.</span><span class="n">qux</span><span class="o"></span> <span class="o">=</span> <span class="mf">2.0</span>
</code></pre></div><h3 id="联合类型">联合类型</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">IntOrString</span><span class="o"></span> <span class="o">=</span> <span class="kt">Union</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="kt">AbstractString</span><span class="p">}</span>
<span class="mi">1</span> <span class="o">:</span><span class="o">:</span> <span class="n">IntOrString</span><span class="o"></span>          <span class="c"># 1</span>
<span class="s">&#34;</span><span class="s">r</span><span class="s">a</span><span class="s">k</span><span class="s">u</span><span class="s">l</span><span class="s">a</span><span class="s">n</span><span class="s">g</span><span class="s">&#34;</span> <span class="o">:</span><span class="o">:</span> <span class="n">IntOrString</span><span class="o"></span> <span class="c"># rakulang</span>
</code></pre></div><h3 id="参数化类型">参数化类型</h3>
<ul>
<li>参数化组合类型</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">struct</span> <span class="n">Point</span><span class="o"></span><span class="p">{</span><span class="n">T</span><span class="o"></span><span class="p">}</span>
    <span class="n">x</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="n">T</span><span class="o"></span>
    <span class="n">y</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="n">T</span><span class="o"></span>
<span class="k">end</span>

<span class="n">point</span><span class="o"></span><span class="o">=</span><span class="n">Point</span><span class="o"></span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="n">point</span><span class="o"></span><span class="o">.</span><span class="n">x</span><span class="o"></span> <span class="c"># 1.0</span>
<span class="n">point</span><span class="o"></span><span class="o">.</span><span class="n">y</span><span class="o"></span> <span class="c"># 2.0</span>


<span class="k">struct</span> <span class="n">Circle</span><span class="o"></span><span class="p">{</span><span class="n">T</span><span class="o"></span><span class="p">,</span><span class="n">U</span><span class="o"></span><span class="p">}</span>
    <span class="n">x</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="n">T</span><span class="o"></span>
    <span class="n">y</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="n">U</span><span class="o"></span>
<span class="k">end</span>

<span class="n">c</span><span class="o"></span> <span class="o">=</span> <span class="n">Circle</span><span class="o"></span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="kt">AbstractString</span><span class="p">}</span><span class="p">(</span><span class="mf">6.0</span><span class="p">,</span> <span class="s">&#34;</span><span class="s">r</span><span class="s">a</span><span class="s">k</span><span class="s">u</span><span class="s">l</span><span class="s">a</span><span class="s">n</span><span class="s">g</span><span class="s">&#34;</span><span class="p">)</span>
<span class="n">c</span><span class="o"></span><span class="o">.</span><span class="n">x</span><span class="o"></span> <span class="c"># 6.0</span>
<span class="n">c</span><span class="o"></span><span class="o">.</span><span class="n">y</span><span class="o"></span> <span class="c"># rakulang</span>
</code></pre></div><h3 id="多重分派">多重分派</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">f</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Float64</span><span class="p">,</span> <span class="n">y</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Float64</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="n">x</span><span class="o"></span> <span class="o">+</span> <span class="n">y</span><span class="o"></span>
<span class="n">f</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Number</span><span class="p">,</span> <span class="n">y</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Number</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="n">x</span><span class="o"></span> <span class="o">-</span> <span class="n">y</span><span class="o"></span>

<span class="n">methods</span><span class="o"></span><span class="p">(</span><span class="n">f</span><span class="o"></span><span class="p">)</span>
<span class="c"># 2 methods for generic function &#34;f&#34;:</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">f</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Float64</span><span class="p">,</span> <span class="n">y</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Float64</span><span class="p">)</span> <span class="kp">in</span> <span class="n">Main</span><span class="o"></span> <span class="n">at</span><span class="o"></span> <span class="n">REPL</span><span class="o"></span><span class="p">[</span><span class="mi">33</span><span class="p">]</span><span class="o">:</span><span class="mi">1</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">f</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Number</span><span class="p">,</span> <span class="n">y</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Number</span><span class="p">)</span> <span class="kp">in</span> <span class="n">Main</span><span class="o"></span> <span class="n">at</span><span class="o"></span> <span class="n">REPL</span><span class="o"></span><span class="p">[</span><span class="mi">34</span><span class="p">]</span><span class="o">:</span><span class="mi">1</span>

<span class="n">f</span><span class="o"></span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="c"># 7</span>
<span class="n">f</span><span class="o"></span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>   <span class="c"># 1</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julialang" term="julialang" label="julialang" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia" term="julia" label="julia" />
                            
                        
                    
                
            
        </entry>
    
</feed>
