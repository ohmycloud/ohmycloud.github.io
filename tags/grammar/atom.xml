<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.85.0">Hugo</generator><title type="html"><![CDATA[grammar on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/grammar/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/grammar/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/grammar/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/grammar/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2021-07-12T22:13:55+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/grammar/</id>
    
        
        <entry>
            <title type="html"><![CDATA[A Mutable Grammar for Raku]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 核心魔改: Grammar 的胡言乱语" />
                <link href="https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第一部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第二部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-07-11-an-example-of-parsing-text-in-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Grammar 解析文本: 一个例子" />
            
                <id>https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>A Mutable Grammar for Raku</blockquote><p>## A Mutable Grammar For Raku</p>
<h3 id="rules">Rules</h3>
<p><code>Rules</code> 就像 perl5的 <code>regexes</code>, 并且更好。它们像子例程和方法那样申明, 并且还能调用其它 rules</p>
<p>下面是一个解析 Raku 基本变量名的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nb">Raku</span> <span class="p">{</span>  
    <span class="c1"># token alpha 是一个预定义好的 rule</span>
    <span class="nf">token</span> identifier <span class="p">{</span><span class="sr">           
</span><span class="sr">       </span><span class="p">&lt;</span><span class="nb">alpha</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">     
</span><span class="sr">    </span><span class="p">}</span>    
    
   <span class="c1"># 匹配一个全限定名标识符</span>
    <span class="c1"># [ ... ]  是非捕获组</span>
    <span class="k">token</span> <span class="nf">name</span> <span class="p">{</span><span class="sr">        
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr">         
</span><span class="sr">        </span><span class="p">[</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">::</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="o">*</span><span class="sr">     
</span><span class="sr">    </span><span class="p">}</span>
     <span class="c1"># .. | .. 是分支. 最长匹配胜出.</span>
    <span class="k">token</span> <span class="nf">sigil</span> <span class="p">{</span><span class="sr">        
</span><span class="sr">       </span><span class="p">&#39;</span><span class="s1">$</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">@</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&amp;</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">%</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">::</span><span class="p">&#39;</span><span class="sr">    
</span><span class="sr">    </span><span class="p">}</span>    
    <span class="c1"># &lt;rule&gt; 调用命名 rule, 隐式地锚定在当前位置</span>
    <span class="k">token</span> <span class="nf">variable</span> <span class="p">{</span><span class="sr">      
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">sigil</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">name</span><span class="p">&gt;</span><span class="sr">  
</span><span class="sr">    </span><span class="p">}</span>

<span class="p">}</span> 
</code></pre></div><h3 id="grammars">Grammars</h3>
<p><code>Grammar</code> 跟类很像, 含有 <code>rules</code> 而不是 methods。Grammars 是 <code>rules</code> 的集合并支持<code>继承</code>。</p>
<p>如果要求 Raku 中变量的名字必须大写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># 我们继承原来那个 grammar</span>
<span class="k">grammar</span> <span class="nc">PERL6</span> <span class="k">is</span> <span class="nb">Raku</span> <span class="p">{</span>    
    <span class="c1"># ... 重写我们想改变的解析规则</span>
    <span class="k">token</span> <span class="nf">identifier</span> <span class="p">{</span><span class="sr">        
</span><span class="sr">   </span><span class="c1"># Raku 中的字符类现在写作 &lt;[ ... ]&gt;         
</span><span class="c1"></span><span class="sr">       </span><span class="p">&lt;[</span><span class="sr">A</span><span class="o">..</span><span class="sr">Z</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr">A</span><span class="o">..</span><span class="sr">Z</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="sr">_</span><span class="p">]&gt;</span><span class="o">*</span><span class="sr">   </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>现在我们只需告诉编译器使用 <code>PERL6</code> 这个 grammar 而非默认 grammar 。还记得类中的方法调用顺序吗？ 先从本类开始, 沿着继承树从下而上到父类。Grammar 与之类似。</p>
<p>然而有一个缺陷。假设你想更改一个符号, 例如把 <code>$</code> 更改 为 <code>¢</code>（因为你没有足够的 <code>$$$</code> 来买下所有的变量, 不是吗？）看起来很简单：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">LowBudgetRaku</span> <span class="k">is</span> <span class="nb">Raku</span> <span class="p">{</span>
    <span class="c1"># token 就像类中的方法一样, 继承后可以修改</span>
    <span class="k">token</span> <span class="nf">sigil</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">¢</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">@</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&amp;</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">%</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">::</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>新的 grammar 解析工作的很好,  但是那之后的所有东西肯定会失败。当编译器在解析树里看见 <code>sigil</code> 匹配时, 它得找出到底是哪一个 - 这意味着它必须要检查匹配文本的字面值,  而它并不知道怎么处理 <code>¢</code>。</p>
<p>所以, 我们需要更多的技能&hellip;</p>
<h2 id="proto-regexes">Proto Regexes</h2>
<p> <code>proto regex</code> 是一套有着相同名字的 regexes/rules, 当前的 <a href="http://svn.pugscode.org/pugs/src/raku/STD.pm">Raku grammar</a> 使用这个结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">token</span> <span class="nf">sigil</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
<span class="c1"># ...</span>
<span class="k">token</span> <span class="nf">sigil:sym</span>&lt;$&gt;  <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
<span class="k">token</span> <span class="nf">sigil:sym</span>&lt;@&gt;  <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
<span class="k">token</span> <span class="nf">sigil:sym</span>&lt;%&gt;  <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
<span class="k">token</span> <span class="nf">sigil:sym</span>&lt;&amp;&gt;  <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
<span class="k">token</span> <span class="nf">sigil:sym</span>&lt;::&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</code></pre></div><p>这创建了一个叫做 <code>sigil</code> 的组(<code>proto</code>), 组里面有使用 <code>sym</code> 标识符参数化的 5 个规则(rules)（它们属于这个组因为它们跟组的名字相同）。 第一个把 <code>sym</code> 设置为 <code>$</code> 然后匹配这个符号(使用<code>&lt;sym&gt;</code>). 第二个匹配 <code>@</code> 等等。现在如果调用规则 <code>&lt;sigil&gt;</code>, 你会得到一个含有上述所有 5 个规则的列表, 列表元素之间是或的关系。所以它依然跟正则 <code>'$' | '@' | '%' | '&amp;' | '::'</code> 匹配相同的东西, 但是更容易扩展。</p>
<p>如果你想添加一个新的符号, Grammar 中唯一要修改的就是添加另外一个 <code>sigil</code> 规则： </p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">SigilRichP6</span> <span class="k">is</span> <span class="nb">Raku</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">sigil:sym</span>&lt;ħ&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span> <span class="c1"># 物理学家会很爱你</span>
<span class="p">}</span>
</code></pre></div><p>回到原来那个例子,  你可以重写已存在的规则：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">LowBudgetRaku</span> <span class="k">is</span> <span class="nb">Raku</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">sigil:sym</span>&lt;$&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">¢</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>现在这个 grammar 为标量使用了一个不同的符号,  但是它和原来的 grammar 有着相同的规则和相同的参数(<code>sigil:sym&lt;$&gt;</code>), 编译器仍然知道怎么处理它。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku Grammars]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/?utm_source=atom_feed" rel="related" type="text/html" title="A Mutable Grammar for Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 核心魔改: Grammar 的胡言乱语" />
                <link href="https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第一部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第二部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-07-11-an-example-of-parsing-text-in-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Grammar 解析文本: 一个例子" />
            
                <id>https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Grammars</blockquote><h1 id="grammarshttpdocrakuorglanguagegrammars"><a href="http://doc.raku.org/language/grammars">Grammars</a></h1>
<p>Grammars - 一组具名 regexes 组成正式的 grammar</p>
<p>Grammars 是一个很强大的工具用于析构文本并通常返回数据结构。</p>
<p>例如, Raku 是使用 Raku 风格 grammar 解析并执行的。</p>
<p>对普通 Raku 使用者更实用的一个例子是 <a href="https://github.com/moritz/json">JSON::Tiny</a>模块, 它能反序列化任何合法的 JSON 文件, 而反序列代码只有不到 100 行, 还能扩展。</p>
<p>Grammars 允许你把 regexes 组织到一块儿, 就像类(class) 中组织方法那样。</p>
<h2 id="具名正则-named-regexes">具名正则 (Named Regexes)</h2>
<p>　
grammars 的主要组成部分是 <a href="http://doc.raku.org/language/regexes">regexes</a>。 而 Raku 的 <a href="http://doc.raku.org/language/regexes">regexes</a>语法不在该文档的讨论范围, 具名正则(named regexes) 有它自己的特殊语法, 这跟子例程(subroutine) 的定义很像:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">number</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">[</span><span class="sr"> \</span><span class="ni">.</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">?</span><span class="sr">   </span><span class="p">}</span>   <span class="c1"># 普通 regex 中空格被忽略, [] 是非捕获组</span>
</code></pre></div><p>上面的代码使用 <code>my</code> 关键字指定了本地作用域的 regex, 因为具名正则(named regexes) 通常用在 grammars 里面。</p>
<p>正则有名字了就方便我们在任何地方重用那个正则了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">32.51</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="nv">&amp;number</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">15 + 4.5</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">  </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr">  </span><span class="p">/</span>
<span class="nv">&amp;number</span>           <span class="c1"># my regex number { \d+ [ \. \d+ ]?   }  </span>
</code></pre></div><p>为什么用 <code>&amp;number</code>, 对比具名子例程你就知道了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="k">sub</span> <span class="nf">number</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">i am a subroutine</span><span class="p">&#34;</span> <span class="p">}</span>  <span class="c1"># 具名子例程</span>
<span class="o">&gt;</span> <span class="nv">&amp;number</span>                                 <span class="c1"># sub number () { #`(Sub|140651249646256) ... }</span>
</code></pre></div><p><code>&amp;number</code> 就是直接引用了具名的 regex 或 子例程。而在 <code>/ /</code> 或 grammars 里面, 引用一个具名正则的语法也很特殊, 就是给名字包裹上 <code>&lt; &gt;</code>。<code>&lt;&gt;</code> 就像引号那样, 当用它引起某个具名正则后, 引用这个 <code>&lt;&gt;</code> 就会把该具名正则插入(带入)到整个正则之中, 就像字符串插值那样：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># 具名正则的声明</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">number</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">[</span><span class="sr"> \</span><span class="ni">.</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="p">]</span><span class="o">?</span><span class="sr"> </span><span class="p">}</span>  
<span class="k">my</span> <span class="k">token</span> <span class="nf">ident</span>  <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">            </span><span class="p">}</span>
<span class="k">my</span> <span class="k">rule</span>  <span class="nf">alpha</span>  <span class="p">{</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr">A</span><span class="o">..</span><span class="sr">Za</span><span class="o">..</span><span class="sr">z</span><span class="p">]&gt;</span><span class="sr">   </span><span class="p">}</span>

<span class="c1"># 1.0 通过 &amp; 来引用</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="p">&#34;</span><span class="s2">12.34</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="nv">&amp;number</span><span class="p">;</span> <span class="c1"># true</span>

<span class="c1"># 2.0 在正则构造 // 里使用</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="p">&#34;</span><span class="s2">12.88 + 0.12</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">  </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr">  </span><span class="p">/;</span> <span class="c1"># true</span>
<span class="c1"># say so &#34;12.88 + 0.12&#34; ~~ /  \s* &#39;+&#39; \s*  /;</span>
<span class="c1"># wrong, method &#39;number&#39; not found for invocant of class &#39;Cursor&#39;</span>

<span class="c1"># 3.0 在 grammar 里面使用</span>
<span class="k">grammar</span> <span class="nc">EquationParse</span> <span class="p">{</span>
    <span class="c1"># 这里也不能给 number 起别名, 除非 number 是在 grammar 内部声明的</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">  </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr">  </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1"># 等式解析</span>
<span class="k">my</span> <span class="nv">$expr</span> <span class="o">=</span> <span class="n">EquationParse</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#34;</span><span class="s2">12.88 + 0.12 = 13.00</span><span class="p">&#34;);</span>
<span class="nb">say</span> <span class="nv">$expr</span><span class="p">;</span>
</code></pre></div><p>声明具名正则不是只有一个 <code>regex</code> 声明符, 实际上 , regex 声明符用的最少, 大多数时候, 都是使用 <code>token</code> 或 <code>rule</code> 声明符。token 和 rule 这两个都是 <code>ratcheing</code> (棘轮)的, 这意味着如果匹配失败, 那么匹配引擎就不会回并尝试匹配了。这通常会是你想要的, 但不适用于所有情况:</p>
<blockquote>
<p>棘轮用于单向驱动, 防止逆转。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">works-but-slow</span> <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">+</span><span class="sr"> q </span><span class="p">}</span> <span class="c1"># 可能会回溯</span>
<span class="k">my</span> <span class="k">token</span> <span class="nf">fails-but-fast</span> <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">+</span><span class="sr"> q </span><span class="p">}</span> <span class="c1"># 不回溯</span>
<span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Tokens and rules won\&#39;t backtrack, which makes them fail quicker!</span><span class="p">&#39;;</span>

<span class="nb">say</span> <span class="nb">so</span> <span class="nv">$s</span> <span class="o">~~</span> <span class="nv">&amp;works-but-slow</span><span class="p">;</span> <span class="c1"># True</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="nv">$s</span> <span class="o">~~</span> <span class="nv">&amp;fails-but-fast</span><span class="p">;</span> <span class="c1"># False, .+ 得到了整个字符串但不回溯</span>
</code></pre></div><p><code>token</code> 和 <code>rule</code> 的唯一区别就是 <code>rule</code> 声明符会让正则中的 <code>:sigspace</code> 修饰符起效:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">token</span> <span class="nf">non-space-y</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">once</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">upon</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">time</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">space-y</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">once</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">upon</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">time</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">onceuponatime</span><span class="p">&#39;</span>    <span class="o">~~</span> <span class="nv">&amp;non-space-y</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">once upon a time</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="nv">&amp;space-y</span><span class="p">;</span>
</code></pre></div><h2 id="创建-grammar">创建 Grammar</h2>
<p>　
当使用 grammar 关键字而非 class 关键字声明来声明一个类时, 会自动得到以 <a href="https://docs.raku.org/type/Grammar">Grammar</a> 的父类。Grammars 应该只用于解析文本; 如果你想提取复杂的数据, 推荐 <a href="http://doc.raku.org/language/grammars#Action_Objects">action object</a>和 grammar 一块使用。</p>
<h3 id="proto-regexes">Proto regexes</h3>
<p><a href="https://docs.raku.org/type/Grammar">Grammars</a> 由 rules，token 和 regexes 组成; 他们实际上是方法，因为 grammars 是类。这些方法可以共享一个共同的名称和功能，因此可以使用 <a href="https://docs.raku.org/syntax/proto">proto</a>。</p>
<p>如果你有很多备选分支(alternations), 那么生成可读性好的代码或子类化(subclass)你的 grammar 可能会变得很困难。在下面的 <code>Actions</code> 类中, <code>TOP</code> 方法中的三元操作符并不理想, 并且当我们添加的操作越多, 它就变得越糟糕:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Calculator</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">add</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sub</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">rule</span>  <span class="nf">add</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">rule</span>  <span class="nf">sub</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">num</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Calculations</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">TOP</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;add&gt;</span> <span class="o">??</span> <span class="nv">$&lt;add&gt;</span><span class="o">.</span><span class="k">made</span> <span class="o">!!</span> <span class="nv">$&lt;sub&gt;</span><span class="o">.</span><span class="k">made</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">method</span> <span class="nb">add</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">[+]</span> <span class="nv">$&lt;num&gt;</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">method</span> <span class="k">sub</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">[-]</span> <span class="nv">$&lt;num&gt;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">Calculator</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">2 + 3</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">Calculations</span><span class="p">)</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># 5</span>
</code></pre></div><p>为了让事情变得更好, 我们可以在 tokens 身上使用看起来像 <code>:sym&lt;...&gt;</code> 那样的副词来使用正则表达式原型(protoregexes):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Calculator</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">calc-op</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>

    <span class="k">proto</span> <span class="k">rule</span> <span class="nf">calc-op</span>          <span class="p">{</span><span class="o">*</span><span class="p">}</span>
          <span class="k">rule</span> <span class="nf">calc-op:sym</span>&lt;add&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
          <span class="k">rule</span> <span class="nf">calc-op:sym</span>&lt;sub&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">num</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Calculations</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">TOP</span>              <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;calc-op&gt;</span><span class="o">.</span><span class="k">made</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">method</span> <span class="nf">calc-op:sym</span><span class="p">&lt;</span><span class="s">add</span><span class="p">&gt;</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">[+]</span> <span class="nv">$&lt;num&gt;</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">method</span> <span class="nf">calc-op:sym</span><span class="p">&lt;</span><span class="s">sub</span><span class="p">&gt;</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">[-]</span> <span class="nv">$&lt;num&gt;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">Calculator</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">2 + 3</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">Calculations</span><span class="p">)</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># 5</span>
</code></pre></div><p>在这个 grammar 中, 备选分支(alternation)已经被 <code>&lt;calc-op&gt;</code> 替换掉了, 它实质上是我们将要创建的一组值的名字。我们通过使用 <code>proto rule calc-op</code> 定义了一个 rule 原型类型(prototype) 来达成。我们之前的每一个备选分支已经被新的 rule <code>calc-op</code> 替换掉了并且备选分支的名字被附加上了 <code>:sym&lt;&gt;</code> 副词。</p>
<p>在 actions 类中, 我们现在摆脱了三目操作符, 仅仅只在 <code>$&lt;calc-op&gt;</code> 匹配对象上接收 <code>.made</code> 值。并且单独备选分支的 actions 现在和 grammar 遵守相同的命名模式:  <code>method calc-op:sym&lt;add&gt;</code> 和 <code>method calc-op:sym&lt;sub&gt;</code>。</p>
<p>当你子类化(subclass)那个 grammar 和 actions 类的时候才能看到这个方法的真正魅力。假设我们想为 calculator 增加一个乘法功能:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">BetterCalculator</span> <span class="k">is</span> <span class="nc">Calculator</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">calc-op:sym</span>&lt;mult&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">*</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">BetterCalculations</span> <span class="k">is</span> <span class="nc">Calculations</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">calc-op:sym</span><span class="p">&lt;</span><span class="s">mult</span><span class="p">&gt;</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">[*]</span> <span class="nv">$&lt;num&gt;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">BetterCalculator</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">2 * 3</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">BetterCalculations</span><span class="p">)</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># 6</span>
</code></pre></div><p>所有我们需要添加的就是为 <code>calc-op</code> 组添加额外的 rule 和 action, 感谢正则表达式原型(protoregexes), 所有的东西都能正常工作。</p>
<h2 id="特殊的-tokens">特殊的 Tokens</h2>
<h3 id="top">TOP</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>TOP</code> token 是默认的第一个尝试去匹配的 token , 当解析一个 grammar 的时候 - 那颗树的根。注意如果你正使用 <code>.parse</code> 方法进行解析, 那么 token TOP 被自动地锚定到字符串的开头和结尾(再看看 <code>.subparse</code>)。</p>
<p>使用 <code>rule TOP</code> 或 <code>regex TOP</code> 也是可以接受的。</p>
<p>在 <code>.parse</code>、<code>.subparse</code> 或 <code>.parsefile</code> Grammar 方法中使用 <code>:rule</code> 命名参数可以选择一个不同的 token 来进行首次匹配。</p>
<h3 id="ws">ws</h3>
<p>当使用 <code>rule</code> 而非 <code>token</code> 时, 原子(atom)后面的任何空白(whitespace)被转换为一个对 <code>ws</code> 的非捕获调用。即:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">rule</span> <span class="nf">entry</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">key</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">value</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</code></pre></div><p>等价于:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">entry</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">key</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">value</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span> <span class="c1"># . = non-capturing</span>
</code></pre></div><p>默认的 <code>ws</code> 匹配&quot;空白&quot;(whitespace), 例如空格序列(不管什么类型)、换行符、unspaces、或 heredocs。</p>
<p>提供你自己的 <code>ws</code> token 是极好的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="sr"> </span><span class="se">\d</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span><span class="o">.</span><span class="nb">parse</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">4   \n\n 5</span><span class="p">&#34;;</span> <span class="c1"># Succeeds</span>

<span class="k">grammar</span> <span class="nc">Bar</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="sr"> </span><span class="se">\d</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">ws</span> <span class="p">{</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr">   </span><span class="p">}</span>
<span class="p">}</span><span class="o">.</span><span class="nb">parse</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">4   \n\n 5</span><span class="p">&#34;;</span> <span class="c1"># Fails</span>
</code></pre></div><p>上面的例子中, 在 Bar Gramamr 中重写了自己的 <code>ws</code>, 只匹配水平空白符, 所以 <code>\n\n</code> 匹配失败。</p>
<h3 id="sym">sym</h3>
<p><code>&lt;sym&gt;</code> token 可以在原型正则表达式(proto regex) 中使用，以匹配那个特定正则表达式的 <code>:sym</code> 副词的字符串值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">letter</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">proto</span> <span class="k">token</span> <span class="nf">letter</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">letter:sym</span>&lt;P&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">letter:sym</span>&lt;e&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">letter:sym</span>&lt;r&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">letter:sym</span>&lt;l&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">letter:sym</span>&lt;*&gt; <span class="p">{</span><span class="sr">   </span><span class="ni">.</span><span class="sr">   </span><span class="p">}</span>
<span class="p">}</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#34;</span><span class="s2">I ♥ Perl</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="k">class</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;letter&gt;</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*.</span><span class="p">&lt;</span><span class="s">sym</span><span class="p">&gt;)</span><span class="o">.</span><span class="nb">join</span> <span class="p">}</span>
<span class="p">})</span><span class="o">.</span><span class="k">made</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># OUTPUT: «Perl␤»</span>
</code></pre></div><p>当你已经将原型正则表达式与要匹配的字符串区分开来时，这很方便，因为使用 <code>&lt;sym&gt;</code> token 可防止重复这些字符串。</p>
<h3 id="总是成功断言">总是成功断言</h3>
<p><code>&lt;?&gt;</code> is the always succeed assertion(总是匹配成功). 当它用作 grammar 中的 token 时, 它可以被用于触发一个 Action 类方法。在下面的 grammar 中, 我们查找阿拉伯数字并且使用 <code>always succeed assertion</code> 定义一个 succ token。</p>
<p>在 action 类中, 我们使用对 succ 方法的调用来设置(在这个例子中, 我们在 @!numbers 中准备了一个新元素)。在 <code>digit</code> 方法中, 我们把阿拉伯数字转换为梵文数字并且把它添加到 @!numbers 数组的最后一个元素中。多亏了 <code>succ</code>, 最后一个元素总是当前正被解析的 <code>digit</code> 数字的数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Digifier</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">succ</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nb">digit</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">succ</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">digit</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Devanagari</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">@!numbers</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">digit</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@!numbers</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span> <span class="o">~=</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">ord</span><span class="o">.&amp;[+]</span><span class="p">(</span><span class="mi">2358</span><span class="p">)</span><span class="o">.</span><span class="nb">chr</span> <span class="p">}</span>
    <span class="k">method</span> <span class="nb">succ</span>  <span class="p">(</span><span class="nv">$</span><span class="p">)</span>  <span class="p">{</span> <span class="nv">@!numbers</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="p">&#39;&#39;</span>     <span class="p">}</span>
    <span class="k">method</span> <span class="nf">TOP</span>   <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">@!numbers</span><span class="o">[^</span><span class="p">(</span><span class="o">*-</span><span class="mi">1</span><span class="p">)</span><span class="o">]</span> <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">Digifier</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">255 435 777</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">Devanagari</span><span class="o">.</span><span class="nb">new</span><span class="p">)</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># (२५५ ४३५ ७७७)</span>
</code></pre></div><h2 id="grammar-中的方法">Grammar 中的方法</h2>
<p>在 grammar 中使用 <code>method</code> 代替 <code>rule</code> 或 <code>token</code> 也是可以的, 只要它们返回一个 <a href="https://docs.raku.org/type/Cursor">Cursor</a> 类型:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">DigitMatcher</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">TOP</span> <span class="p">(</span><span class="o">:</span><span class="nv">$full-unicode</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$full-unicode</span> <span class="o">??</span> <span class="nb">self</span><span class="o">.</span><span class="nf">num-full</span> <span class="o">!!</span> <span class="nb">self</span><span class="o">.</span><span class="nf">num-basic</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">token</span> <span class="nf">num-full</span>  <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">num-basic</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>上面的 grammar 会根据 parse 方法提供的参数尝试不同的匹配:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">+</span><span class="n">DigitMatcher</span><span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">12७१७९०९</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">args</span> <span class="o">=&gt;</span> \<span class="p">(:</span><span class="s">full-unicode</span><span class="p">);</span>
<span class="c1"># OUTPUT:</span>
<span class="c1"># 12717909</span>

<span class="nb">say</span> <span class="o">+</span><span class="n">DigitMatcher</span><span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">12७१७९०९</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">args</span> <span class="o">=&gt;</span> \<span class="p">(:!</span><span class="s">full-unicode</span><span class="p">);</span>
<span class="c1"># OUTPUT:</span>
<span class="c1"># 12</span>
</code></pre></div><h2 id="action-object">Action Object</h2>
<p>　
一个成功的 grammar 匹配会给你一棵匹配对象(Match objects)的解析树, 匹配树(match tree)到达的越深, 则 grammar 中的分支越多, 那么在匹配树中航行以获取你真正感兴趣的东西就变的越来越困难。</p>
<p>为了避免你在匹配树(match tree)中迷失, 你可以提供一个 action object。grammar 中每次解析成功一个具名规则(named rule)之后, 它就会尝试调用一个和该 grammar rule 同名的方法, 并传递给这个方法一个<code>Match</code> 对象作为位置参数。如果不存在这样的同名方法, 就跳过。</p>
<p>这儿有一个例子来说明 grammar 和 action：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">TestGrammar</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="ni">^</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="ni">$</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">TestActions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$/</span><span class="o">.</span><span class="k">make</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="nv">$/</span><span class="p">);</span>  <span class="c1"># 等价于 $/.make: 2 + $/</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$actions</span> <span class="o">=</span> <span class="n">TestActions</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span> <span class="c1"># 创建 Action 实例</span>
<span class="k">my</span> <span class="nv">$match</span>   <span class="o">=</span> <span class="n">TestGrammar</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">40</span><span class="p">&#39;</span><span class="o">,</span> <span class="o">:</span><span class="nv">$actions</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$match</span><span class="p">;</span>       <span class="c1"># ｢40｣</span>
<span class="nb">say</span> <span class="nv">$match</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>  <span class="c1"># 42</span>
</code></pre></div><p><code>TestActions</code> 的一个实例变量作为具名参数 <code>actions</code> 被传递给 <code>parse</code> 调用, 然后当 token <code>TOP</code> 匹配成功之后, 就会自动调用方法 <code>TOP</code>, 并传递匹配对象(match object) 作为方法的参数。</p>
<p>为了让参数是匹配对象更清楚, 上面的例子使用 <code>$/</code> 作为 action 方法的参数名, 尽管那仅仅是一个方便的约定, 跟内在无关。<code>$match</code> 也可以。(尽管使用 <code>$/</code> 可以提供把 <code>$</code> 作为 <code>$/</code> 的缩写的优势。)</p>
<p>下面是一个更有说服力的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">KeyValuePairs</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">[&lt;</span><span class="nf">pair</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="p">]</span><span class="o">*</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">ws</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="se">\h</span><span class="o">*</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">rule</span> <span class="nf">pair</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=.</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=.</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">identifier</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="se">\w</span><span class="o">+</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">KeyValuePairsActions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nb">pair</span>      <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="nv">$&lt;key&gt;</span><span class="o">.</span><span class="s">made</span> <span class="o">=&gt;</span> <span class="nv">$&lt;value&gt;</span><span class="o">.</span><span class="k">made</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">identifier</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1"># 子例程 `make` 和在 $/ 上调用 .make 相同</span>
        <span class="k">make</span> <span class="o">~</span><span class="nv">$/</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">TOP</span> <span class="p">(</span><span class="nv">$match</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1"># TOP 方法的参数可以使用任意变量名, 而不仅仅是 $/</span>
        <span class="nv">$match</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="nv">$match</span><span class="p">&lt;</span><span class="s">pair</span><span class="p">&gt;</span><span class="o">».</span><span class="k">made</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$res</span> <span class="o">=</span> <span class="n">KeyValuePairs</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="k">q</span><span class="sa">:to</span><span class="p">/EOI/,</span><span class="s"> :actions(KeyValuePairsActions)).made;
</span><span class="s">    second=b
</span><span class="s">    hits=42
</span><span class="s">    perl=6
</span><span class="s">    </span><span class="p">EOI</span>

<span class="k">for</span> <span class="nv">@$res</span> <span class="k">-&gt;</span> <span class="nv">$p</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Key: </span><span class="nv">$p</span><span class="o">.</span><span class="nf">key</span><span class="p">()</span><span class="s2">\tValue: </span><span class="nv">$p</span><span class="o">.</span><span class="nf">value</span><span class="p">()&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>这会输出:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">Key:</span> <span class="nb">second</span>     <span class="n">Value:</span> <span class="nf">b</span>
<span class="n">Key:</span> <span class="nf">hits</span>       <span class="n">Value:</span> <span class="mi">42</span>
<span class="n">Key:</span> <span class="nb">perl</span>       <span class="n">Value:</span> <span class="mi">6</span>
</code></pre></div><p><code>pair</code> 这个 rule, 解析一对由等号分割的 pair, 并且给 <code>identifier</code> 这个 token 各自起了别名。对应的 action 方法构建了一个 <code>Pair</code> 对象, 并使用子匹配对象(sub match objects)的 <code>.made</code> 属性。这也暴露了一个事实: submatches 的 action 方法在那些调用正则/外部正则之前就被调用。所以 action 方法是按后续调用的。</p>
<p>名为 <code>TOP</code> 的 action 方法仅仅把由 <code>pair</code> 这个 rule 的多重匹配组成的所有对象收集到一块, 然后以一个列表的方式返回。</p>
<p>注意 <code>KeyValuePairsActions</code> 是作为一个类型对象(type object)传递给方法 <code>parse</code>的, 这是因为 action 方法中没有一个使用属性(属性只能通过实例来访问)。</p>
<p>其它情况下, action 方法可能会在属性中保存状态。 那么这当然需要你传递一个实例给 <code>parse</code> 方法。</p>
<p>注意, <code>token ws</code> 有点特殊: 当 <code>:sigspace</code> 开启的时候(就是我们使用 <code>rule</code>的时候), 我们覆写的 <code>ws</code> 会替换某些空白序列。这就是为什么 <code>rule pair</code> 中等号两边的空格解析没有问题并且闭合 <code>}</code> 之前的空白不会狼吞虎咽地吃下换行符, 因为换行符在 <code>TOP</code> token 已经占位置了, 并且 token 不会回溯。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># ws 的内置定义</span>
<span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/</span>                <span class="c1"># match &#34;whitespace&#34;:</span>
                         <span class="c1">#   \s+ if it&#39;s between two \w characters,</span>
                         <span class="c1">#   \s* otherwise</span>

<span class="k">my</span> <span class="k">token</span> <span class="nf">ws</span> <span class="p">{</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>      <span class="c1"># 重写 ws 这个内置的 token</span>
<span class="o">&gt;</span><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#34;</span><span class="s2">\n</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="nv">&amp;ws</span>      <span class="c1"># True</span>
</code></pre></div><p>所以 <code>&lt;.ws&gt;</code> 内置的定义是：如果空白在两个 <code>\w</code> 单词字符之间, 则意思为 <code>\s+</code>, 否则为 <code>\s*</code>。 我们可以重写 <code>ws</code> 关于空白的定义, 重新定义我们需要的空白。比如把 <code>ws</code> 定义为 <code>{ \h* }</code> 就是所有水平空白符, 甚至可以将<code>ws</code> 定义为非空白字符。例如: <code>token ws { 'x' }</code></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 核心魔改: Grammar 的胡言乱语]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/?utm_source=atom_feed" rel="related" type="text/html" title="A Mutable Grammar for Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第一部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第二部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-07-11-an-example-of-parsing-text-in-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Grammar 解析文本: 一个例子" />
            
                <id>https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Core Hacking Grammatical Babble</blockquote><p>喜欢修复 Raku 编译器中的 bug? 这儿有一个<a href="https://rt.perl.org/Ticket/Display.html?id=128304">great grammar bugglet</a>: 当 <code>„”</code> 引号用在引起的用空白分割的单词列表构造器中时看起来好像不能工作:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> „<span class="n">hello</span> <span class="n">world</span>”<span class="p">;</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="k">q</span><span class="sa">ww</span><span class="p">&lt;</span><span class="s2">„hello world”</span><span class="p">&gt;;</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="k">q</span><span class="sa">ww</span><span class="p">&lt;</span><span class="s2">&#34;hello world&#34;</span><span class="p">&gt;;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># hello world</span>
<span class="c1"># „hello</span>
<span class="c1"># world”</span>
<span class="c1"># hello world</span>
</code></pre></div><p><code>”</code> 引号不应该出现在输出中并且在输出中我们应该只有 3 行输出; 这 3 行输出都是 <code>hello world</code>。看起来像是一个待修复的有趣的 bug! 我们进去看看。</p>
<h2 id="你怎样拼写它">你怎样拼写它?</h2>
<p>事实上这段代码没能正确解析表明这是一个 grammar bug。大部分的 grammar 住在 <a href="https://github.com/rakudo/rakudo/blob/83b8b1a/src/Raku/Grammar.nqp">src/Raku/Grammar.nqp</a>中, 但是在我们的手变脏之前, 让我们来解决我们应该查看什么。</p>
<p>二进制 <code>raku</code> 有一个 <code>--target</code> 命令行参数来接收其中之一的编译步骤并且会导致那个步骤的输出被产生出来。那儿有哪些步骤? 根据你正使用的后端它们也会有所不同, 但是你可以仅仅运行 <code>raku --stagestats -e ''</code> 把它们都打印出来:</p>
<pre><code>zoffix@leliana:~$ raku --stagestats -e ''
Stage start      :   0.000
Stage parse      :   0.077
Stage syntaxcheck:   0.000
Stage ast        :   0.000
Stage optimize   :   0.001
Stage mast       :   0.004
Stage mbc        :   0.000
Stage moar       :   0.000
</code></pre><p>Grammars 是关于解析的, 所以我们会查询 <code>parse</code> 目标(target)。至于要执行的代码, 我们会仅仅给它有问题的那块; 即 <code>qww&lt;&gt;</code>:</p>
<pre><code>zoffix@leliana:~$ raku --target=parse -e 'qww&lt;„hello world”&gt;'
- statementlist: qww&lt;„hello world”&gt;
  - statement: 1 matches
    - EXPR: qww&lt;„hello world”&gt;
      - value: qww&lt;„hello world”&gt;
        - quote: qww&lt;„hello world”&gt;
          - quibble: &lt;„hello world”&gt;
            - babble:
              - B:
            - nibble: „hello world”
          - quote_mod: ww
            - sym: ww
</code></pre><p>那很棒! 每一行前面都有能在 grammar 中找到的 token 的名字, 所以现在我们知道了在哪里查找问题。</p>
<p>我们还知道基本的引号能正确地工作, 所以我们也倾倒出它们的解析步骤, 来看看这两个输出之间是否有什么不同:</p>
<pre><code>zoffix@leliana:~$ raku --target=parse -e 'qww&lt;&quot;hello world&quot;&gt;'
- statementlist: qww&lt;&quot;hello world&quot;&gt;
  - statement: 1 matches
    - EXPR: qww&lt;&quot;hello world&quot;&gt;
      - value: qww&lt;&quot;hello world&quot;&gt;
        - quote: qww&lt;&quot;hello world&quot;&gt;
          - quibble: &lt;&quot;hello world&quot;&gt;
            - babble:
              - B:
            - nibble: &quot;hello world&quot;
          - quote_mod: ww
            - sym: ww
</code></pre><p>那么&hellip; 好吧, 除了引号不同, 解析数完全一样。所以它看起来好像所有涉及的 tokens 都是相同的, 但是那些 tokens 所做的事情不同。</p>
<p>我们不必检查输出中我们看到的每个 tokens。<code>statementlist</code> 和 <code>statement</code> 是匹配普通语句的 tokens, <code>EXPR</code> 是占位符解析器, <code>value</code> 是它正操作的值中的一个。我们会忽略上面那些, 留给我们的是下面这样一个可疑的列表:</p>
<pre><code>- quote: qww&lt;„hello world”&gt;
  - quibble: &lt;„hello world”&gt;
    - babble:
      - B:
    - nibble: „hello world”
  - quote_mod: ww
    - sym: ww
</code></pre><p>让我们开始质问它们。</p>
<h2 id="到兔子洞里去">到兔子洞里去&hellip;</h2>
<p>你自己搞一份本地的 <a href="https://github.com/rakudo/rakudo/">Rakudo 仓库</a>, 如果你已经有了一份,那么打开 <a href="https://github.com/rakudo/rakudo/blob/83b8b1a/src/Raku/Grammar.nqp">src/Raku/Grammar.nqp</a>, 然后放松点。</p>
<p>我们会从树的顶部到底部跟随我们的 tokens, 所以我们首先需要找到的是 <code>token quote</code>, <code>rule quote</code>, <code>regex quote</code> 或 <code>method quote</code>; 以那个顺序搜索, 因为第一项很可能就是正确的东西。</p>
<p>这种情况下, 它是一个 <a href="https://github.com/rakudo/rakudo/blob/83b8b1a/src/Raku/Grammar.nqp#L3555">token quote</a>, 它是一个 <a href="https://docs.raku.org/language/grammars#Protoregexes">proto regex</a>。我们的代码使用了它的 <code>q</code> 版本并且你还可以认出靠近它的 <code>qq</code> 和 <code>Q</code> 版本:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">quote:sym</span>&lt;q&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$qm</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quote_mod</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="nv">$qm</span> <span class="o">:=</span> <span class="nv">$&lt;quote_mod&gt;</span><span class="o">.</span><span class="nb">Str</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$qm</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">{}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">]</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>

<span class="k">token</span> <span class="nf">quote:sym</span>&lt;qq&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$qm</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="p">&#39;</span><span class="s1">qq</span><span class="p">&#39;</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quote_mod</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="nv">$qm</span> <span class="o">:=</span> <span class="nv">$&lt;quote_mod&gt;</span><span class="o">.</span><span class="nb">Str</span> <span class="p">}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">qq</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$qm</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">{}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">qq</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">]</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>

<span class="k">token</span> <span class="nf">quote:sym</span>&lt;Q&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$qm</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="p">&#39;</span><span class="s1">Q</span><span class="p">&#39;</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quote_mod</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="nv">$qm</span> <span class="o">:=</span> <span class="nv">$&lt;quote_mod&gt;</span><span class="o">.</span><span class="nb">Str</span> <span class="p">}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="nv">$qm</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">{}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">]</span><span class="sr">
</span><span class="sr">}
</span></code></pre></div><p>可以看到 <code>qq</code> 和 <code>Q</code> 的主体看起来像 <code>q</code>, 我们也来看看它们是否有我们要找的那个 bug:</p>
<pre><code>zoffix@leliana:~$ raku -e '.say for qqww&lt;„hello world”&gt;'
„hello
world”
zoffix@leliana:~$ raku -e '.say for Qww&lt;„hello world”&gt;'
„hello
world
</code></pre><p>是的, 它们也存在, 所以 <code>token quote</code> 不可能是那个问题。我们来分解下 <code>token quote:sym&lt;q&gt;</code> 是做什么的, 来算出怎么进行到下一步; 它的备选之一没有被用在我们当前的代码中, 所以我会省略它:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">quote:sym</span>&lt;q&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$qm</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quote_mod</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="nv">$qm</span> <span class="o">:=</span> <span class="nv">$&lt;quote_mod&gt;</span><span class="o">.</span><span class="nb">Str</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$qm</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="c1"># (this branch omited)
</span><span class="c1"></span><span class="sr">    </span><span class="p">]</span><span class="sr">
</span><span class="sr">}
</span></code></pre></div><p>在第二行中, 我们创建了一个变量, 然后匹配字面值 <code>q</code> 然后是 <code>quote_mod</code> token。那个是我们的 <code>--target=parse</code> 输出中的一部分并且如果你像我们找出 <code>quote</code> token 那样找出它, 你会注意到它是一个 proto regex, 即, 在那种情况下, 匹配我们代码的 <code>ww</code> 块。后面跟着的空 <code>{}</code> 块我们可以忽略(那是一个 bug 的替代方法可能在你读到这儿时已经被修复了)。目前为止, 我们已经匹配了我们代码的 <code>qww</code> 块。</p>
<p>再往前走, 我们遇见了对 <code>qok</code> token 的调用, 当前的 <a href="https://docs.raku.org/type/Match">Match</a> 对象作为其参数。<code>&lt;.qok&gt;</code> 中的点号表明这是一个非捕获 token 匹配, 这就是它为什么它没有在我们的 <code>--target=parse</code> 输出中出现的原因。我们定位到那个 token 并看看它是关于什么的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">qok</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">»</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="p">[</span><span class="sr">(</span><span class="p">]&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">:</span><span class="p">]&gt;</span><span class="sr"> </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="p">{</span>
            <span class="k">my</span> <span class="nv">$n</span> <span class="o">:=</span> <span class="o">~</span><span class="nv">$x</span><span class="p">;</span> <span class="vg">$*W</span><span class="o">.</span><span class="nf">is_name</span><span class="p">(</span><span class="o">[</span><span class="nv">$n</span><span class="o">]</span><span class="p">)</span> <span class="o">||</span> <span class="vg">$*W</span><span class="o">.</span><span class="nf">is_name</span><span class="p">(</span><span class="o">[</span><span class="p">&#39;</span><span class="s1">&amp;</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$n</span><span class="o">]</span><span class="p">)</span>
        <span class="p">}&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">]</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">#</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">panic</span><span class="p">:</span> <span class="p">&#34;</span><span class="s2"># not allowed as delimiter</span><span class="p">&#34;&gt;</span><span class="sr"> </span><span class="p">]</span><span class="o">?</span><span class="sr">
</span><span class="sr">    </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr">
</span><span class="sr">}
</span></code></pre></div><p>我的天呐! 这么多符号, 但是这个家伙很容易了: <code>»</code> 是一个<a href="https://docs.raku.org/language/regexes#%3C%3C_and_%3E%3E_,_left_and_right_word_boundary">右单词边界</a>后面不能跟着一个开圆括号(<code>&lt;![(]&gt;</code>), 再跟着一个备选分支(<code>[]</code>), 再跟着一个检查, 即我们不想尝试使用 <code>#</code> 号作为分割符(<code>[...]?</code>), 最后跟着一个 <a href="https://docs.raku.org/language/grammars#ws">&lt;.ws&gt;</a> token 吞噬各种各样的空白。</p>
<p>在备选分支中, 我们使用了首个token匹配的 <code>||</code> 备选分支(和最长token匹配 <code>|</code> 相反), 并且首个 token 向前查看一个冒号 <code>&lt;?[:]&gt;</code>。 如果失败了, 我们就字符串化那个给定的参数(<code>~$x</code>)并且之后在 <a href="https://github.com/rakudo/rakudo/blob/83b8b1a/src/Raku/World.nqp">World对象</a> 身上调用 <code>is_name</code> 方法, 原样地传递带有前置 <code>&amp;</code> 符号的字符串化的参数。传递的 <code>~$x</code> 是目前为止我们的 <code>token quote:sym&lt;q&gt;</code> token 所匹配到的东西(并且那是字符串 <code>qww</code>)。<code>is_name</code> 方法仅仅检查那个给定的符号是否被定义还有根据那个返回值检查我们的 token 匹配会通过还是会失败。如果那个求值代码返回一个真值那么我们正在使用的  <code>&lt;!{ ... }&gt;</code> 结构就会失败。</p>
<p>总而言之, 这个 token 所做的所有事情就是检查我们没有使用 <code>#</code> 作为分隔符并且没有尝试去调用一个方法或sub。房间的这个角落没有 bug 迹象。 让我们回到我们的 <code>token quote:sym&lt;q&gt;</code> 来查看下一步做什么:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">quote:sym</span>&lt;q&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$qm</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quote_mod</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="nv">$qm</span> <span class="o">:=</span> <span class="nv">$&lt;quote_mod&gt;</span><span class="o">.</span><span class="nb">Str</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$qm</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="c1"># (this branch omited)
</span><span class="c1"></span><span class="sr">    </span><span class="p">]</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>我们已经完成了 <code>&lt;.qok&gt;</code> 的检查, 所以下一步是 <code>{ $qm := $&lt;quote_mod&gt;.Str }</code>, 那仅仅把匹配到 <code>quote_mod</code> token 的字符串值存到 <code>$qm</code> 变量中。在我们的例子中, 那个值就是字符串 <code>ww</code>。</p>
<p>下面跟着的是另外一个 token, 它在我们的 <code>--target=parse</code> s输出中出现过:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$qm</span><span class="p">)</span><span class="o">&gt;</span>
</code></pre></div><p>这里, 我们使用三个位置参数引用了那个 token: <a href="https://github.com/rakudo/rakudo/blob/04af57c3b3d32353e36614de53396d2b4a08b7be/src/Raku/Grammar.nqp#L424">Quote language braid</a>, 字符串 <code>q</code> 和 我们保存在变量 <code>$qm</code> 中的字符串 <code>ww</code>。我想知道它是做什么的。那是我们的下一站。全力以赴!</p>
<h2 id="nibble-quibble-babbling-nibbler">Nibble Quibble Babbling Nibbler</h2>
<p>这里是完整的 <code>token quibble</code> 并且你马上可以发现我们不得不从开始往更深处挖掘, 因为第 5 行是另外一个 token 匹配:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">quibble</span><span class="p">(</span><span class="nv">$l</span><span class="o">,</span> <span class="o">*</span><span class="nv">@base_tweaks</span><span class="p">)</span> <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$lang</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$start</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$stop</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="p">&lt;</span><span class="nf">babble</span><span class="p">(</span><span class="nv">$l</span><span class="o">,</span> <span class="nv">@base_tweaks</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">{</span>
        <span class="k">my</span> <span class="nv">$B</span>  <span class="o">:=</span> <span class="nv">$&lt;babble&gt;&lt;B&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">;</span>
        <span class="nv">$lang</span>  <span class="o">:=</span> <span class="nv">$B</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
        <span class="nv">$start</span> <span class="o">:=</span> <span class="nv">$B</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
        <span class="nv">$stop</span>  <span class="o">:=</span> <span class="nv">$B</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
    <span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr">    </span><span class="nv">$start</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">nibble</span><span class="p">(</span><span class="nv">$lang</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr">
</span><span class="sr">        </span><span class="nv">$stop</span><span class="sr">
</span><span class="sr">        </span><span class="o">||</span><span class="sr"> </span><span class="p">{</span>
            <span class="nv">$/</span><span class="o">.</span><span class="nf">CURSOR</span><span class="o">.</span><span class="nf">typed_panic</span><span class="p">(</span>
                <span class="p">&#39;</span><span class="s1">X::Comp::AdHoc</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="s">payload</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Couldn&#39;t find terminator </span><span class="nv">$stop</span><span class="s2"> (corresponding </span><span class="nv">$start</span><span class="s2"> was at line {</span>
                    <span class="n">HLL::Compiler</span><span class="o">.</span><span class="nf">lineof</span><span class="p">(</span>
                        <span class="nv">$&lt;babble&gt;&lt;B&gt;</span><span class="o">.</span><span class="nb">orig</span><span class="p">()</span><span class="o">,</span> <span class="nv">$&lt;babble&gt;&lt;B&gt;</span><span class="o">.</span><span class="nb">from</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="p">})&#34;</span><span class="s2">,
</span><span class="s2">                expected =&gt; [</span><span class="nv">$stop</span><span class="s2">],
</span><span class="s2">            )
</span><span class="s2">        }
</span><span class="s2">    ]
</span><span class="s2">
</span><span class="s2">    </span><span class="p">{</span>
        <span class="nf">nqp::can</span><span class="p">(</span><span class="nv">$lang</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">herelang</span><span class="p">&#39;)</span>
        <span class="o">&amp;&amp;</span> <span class="nb">self</span><span class="o">.</span><span class="nf">queue_heredoc</span><span class="p">(</span>
            <span class="vg">$*W</span><span class="o">.</span><span class="nf">nibble_to_str</span><span class="p">(</span>
                <span class="nv">$/</span><span class="o">,</span>
                <span class="nv">$&lt;nibble&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="k">-&gt;</span> <span class="p">{</span>
                    <span class="p">&#34;</span><span class="s2">Stopper &#39;</span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$&lt;nibble&gt;</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">&#39; too complex for heredoc</span><span class="p">&#34;</span>
                <span class="p">}</span><span class="s2">
</span><span class="s2">            ),
</span><span class="s2">            </span><span class="nv">$lang</span><span class="s2">.herelang,
</span><span class="s2">        )
</span><span class="s2">    }
</span><span class="s2">}
</span></code></pre></div><p>我们定义了 3 个变量然后引用了 <code>babble</code> token, 这个 babble 引用了和 <code>quibble</code> token 所引用的同样的参数。我们来以和查找所有之前的 tokens 同样的方式查找它并窥探它的内核。为了简洁, 我移除了大约一半<a href="https://github.com/rakudo/rakudo/blob/bc35922/src/Raku/Grammar.nqp#L111-L125">代码</a>:那部分是处理副词的, 目前我们不能在我们的代码中使用它。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">babble</span><span class="p">(</span><span class="nv">$l</span><span class="o">,</span> <span class="nv">@base_tweaks</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">@extra_tweaks</span><span class="p">;</span><span class="sr">
</span><span class="sr">
</span><span class="sr">    </span><span class="c1"># &lt;irrelevant portion redacted&gt;
</span><span class="c1"></span><span class="sr">
</span><span class="sr">    </span><span class="nv">$&lt;B&gt;</span><span class="o">=</span><span class="p">[&lt;</span><span class="o">?</span><span class="ow">before</span><span class="sr"> </span><span class="ni">.</span><span class="p">&gt;]</span><span class="sr">
</span><span class="sr">    </span><span class="p">{</span>
        <span class="c1"># Work out the delimeters.</span>
        <span class="k">my</span> <span class="nv">$c</span> <span class="o">:=</span> <span class="nv">$/</span><span class="o">.</span><span class="nf">CURSOR</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">@delims</span> <span class="o">:=</span> <span class="nv">$c</span><span class="o">.</span><span class="nf">peek_delimiters</span><span class="p">(</span><span class="nv">$c</span><span class="o">.</span><span class="nb">target</span><span class="o">,</span> <span class="nv">$c</span><span class="o">.</span><span class="nb">pos</span><span class="p">);</span>
        <span class="k">my</span> <span class="nv">$start</span> <span class="o">:=</span> <span class="nv">@delims</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">$stop</span>  <span class="o">:=</span> <span class="nv">@delims</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>

        <span class="c1"># Get the language.</span>
        <span class="k">my</span> <span class="nv">$lang</span> <span class="o">:=</span> <span class="nb">self</span><span class="o">.</span><span class="nf">quote_lang</span><span class="p">(</span><span class="nv">$l</span><span class="o">,</span> <span class="nv">$start</span><span class="o">,</span> <span class="nv">$stop</span><span class="o">,</span> <span class="nv">@base_tweaks</span><span class="o">,</span> <span class="nv">@extra_tweaks</span><span class="p">);</span>
        <span class="nv">$&lt;B&gt;</span><span class="o">.</span><span class="p">&#39;</span><span class="s1">!make</span><span class="p">&#39;(</span><span class="o">[</span><span class="nv">$lang</span><span class="o">,</span> <span class="nv">$start</span><span class="o">,</span> <span class="nv">$stop</span><span class="o">]</span><span class="p">);</span>
    <span class="p">}</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>我们通过把向前查看捕获到 <code>$&lt;B&gt;</code> 捕获中开始, 它用作更新当前的 Cursor 位置, 然后进入以执行那个代码块。我们把当前的 Cursor 存储在 <code>$c</code> 中, 然后在它身上调用 <code>.peek_delimiters</code> 方法。如果我们为了它在内置的 rakudo 目录中进行 <code>grep</code>, 我们会看到它被定义在 <a href="https://github.com/raku/nqp/blob/4fd4b48afb45c8b25ccf7cfc5e39cb4bd658901d/src/HLL/Grammar.nqp#L200">NQP</a>中, 在 <a href="https://github.com/raku/nqp/blob/4fd4b48afb45c8b25ccf7cfc5e39cb4bd658901d/src/HLL/Grammar.nqp#L200">nqp/src/HLL/Grammar.nqp</a>中, 但是在我们冲出去阅读它的代码之前, 注意它是怎样返回两个分隔符的。我们仅仅把它们打印出来好了?</p>
<p><code>src/Raku/Grammar.nqp</code> 的 <code>.nqp</code> 后缀名表明我们正处在 NQP 的地盘儿, 所以我们不要使用 <a href="https://github.com/raku/nqp/blob/master/docs/ops.markdown">NQP ops</a>仅仅并且不是完全的 Raku 代码。通过把下面这一行代码添加到 <code>@delim</code> 被赋值给 <code>$start</code> 和 <code>$stop</code> 的地方, 我们能找出 <code>.peek_delimiters</code> 给我们的东西:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">nqp::say</span><span class="p">(&#34;</span><span class="nv">$sart</span><span class="s2"> </span><span class="nv">$stop</span><span class="p">&#34;);</span>
</code></pre></div><p>编译!</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ perl Configure.pl --gen-moar --gen-nqp --backends<span class="o">=</span>moar <span class="o">&amp;&amp;</span>
  make <span class="o">&amp;&amp;</span>
  make <span class="nb">test</span> <span class="o">&amp;&amp;</span>
  make install
</code></pre></div><p>即使在编译期间, 通过吐出额外的东西, 我们的调试行已经给了我们所有那些分隔符是关于什么的启发。再次运行我们的有问题的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./raku -e <span class="s1">&#39;.say for qww&lt;„hello world”&gt;;&#39;</span>
&lt; &gt;
hello world
</code></pre></div><p>打印出的分隔符是 <code>qww</code> 里的尖括号分隔符。我们对那些不感兴趣, 所以我们可以忽略 <code>.peek_delimiters</code> 并继续。再往上是 <code>.quote_lang</code> 方法。 它的名字里有一个&quot;引号&quot;而我们有一个关于引号的问题.. 听起来我们离真相越来越近了。我们来看看我们正传递给它的是什么参数:</p>
<ul>
<li><code>$1</code> — <a href="https://github.com/rakudo/rakudo/blob/04af57c3b3d32353e36614de53396d2b4a08b7be/src/Raku/Grammar.nqp#L4752">Quote language braid</a></li>
<li><code>$start</code> / <code>$stop</code> — 尖括号分隔符</li>
<li><code>@base_tweaks</code> — 包含一个元素: 字符串 <code>ww</code></li>
<li><code>@extra_tweaks</code> — 额外的副词, 这里我们没有, 所以这个数组是空的</li>
</ul>
<p>定位到 <code>method quote_lang</code>; 它仍然在 <a href="https://github.com/rakudo/rakudo/blob/04af57c3b3d32353e36614de53396d2b4a08b7be/src/Raku/Grammar.nqp#L65">src/Raku/Grammar.nqp</a>文件中:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">quote_lang</span><span class="p">(</span><span class="nv">$l</span><span class="o">,</span> <span class="nv">$start</span><span class="o">,</span> <span class="nv">$stop</span><span class="o">,</span> <span class="nv">@base_tweaks</span><span class="o">?,</span> <span class="nv">@extra_tweaks</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">sub</span> <span class="nf">lang_key</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1"># &lt;body redacted&gt;</span>
    <span class="p">}</span>
    <span class="k">sub</span> <span class="nf">con_lang</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1"># &lt;body redacted&gt;</span>
    <span class="p">}</span>

    <span class="c1"># Get language from cache or derive it.</span>
    <span class="k">my</span> <span class="nv">$key</span> <span class="o">:=</span> <span class="nf">lang_key</span><span class="p">();</span>
    <span class="nf">nqp::existskey</span><span class="p">(</span><span class="nv">%quote_lang_cache</span><span class="o">,</span> <span class="nv">$key</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nv">$key</span> <span class="ow">ne</span> <span class="p">&#39;</span><span class="s1">NOCACHE</span><span class="p">&#39;</span>
        <span class="o">??</span> <span class="nv">%quote_lang_cache</span><span class="p">{</span><span class="nv">$key</span><span class="p">}</span>
        <span class="o">!!</span> <span class="p">(</span><span class="nv">%quote_lang_cache</span><span class="p">{</span><span class="nv">$key</span><span class="p">}</span> <span class="o">:=</span> <span class="nf">con_lang</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div><p>我们有两个词法子例程 <code>lang_key</code> 和 <code>con_lang</code>, 在它们下面我们把 <code>lang_key</code> 的输出存储到 <code>$key</code> 中, 在 <code>%quote_lang_cache</code> 中这个 <code>$key</code> 被用在整个缓存 dance 中, 所以我们可以忽略掉 <code>lang_key</code> sub 并直接进入 <code>con_lang</code>, 它被调用以生成我们的 <code>quote_lang</code> 方法的返回值:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">con_lang</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$lang</span> <span class="o">:=</span> <span class="nv">$l</span><span class="o">.</span><span class="p">&#39;</span><span class="s1">!cursor_init</span><span class="p">&#39;(</span><span class="nb">self</span><span class="o">.</span><span class="nb">orig</span><span class="p">()</span><span class="o">,</span> <span class="p">:</span><span class="s">p</span><span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="nb">pos</span><span class="p">())</span><span class="o">,</span> <span class="p">:</span><span class="s">shared</span><span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="p">&#39;</span><span class="s1">!shared</span><span class="p">&#39;()));</span>
    <span class="k">for</span> <span class="nv">@base_tweaks</span> <span class="p">{</span>
        <span class="nv">$lang</span> <span class="o">:=</span> <span class="nv">$lang</span><span class="o">.</span><span class="p">&#34;</span><span class="s2">tweak_</span><span class="nv">$_</span><span class="p">&#34;(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nv">@extra_tweaks</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$t</span> <span class="o">:=</span> <span class="nv">$_</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
        <span class="k">if</span> <span class="nf">nqp::can</span><span class="p">(</span><span class="nv">$lang</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">tweak_</span><span class="nv">$t</span><span class="p">&#34;)</span> <span class="p">{</span>
            <span class="nv">$lang</span> <span class="o">:=</span> <span class="nv">$lang</span><span class="o">.</span><span class="p">&#34;</span><span class="s2">tweak_</span><span class="nv">$t</span><span class="p">&#34;(</span><span class="nv">$_</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nb">self</span><span class="o">.</span><span class="nf">sorry</span><span class="p">(&#34;</span><span class="s2">Unrecognized adverb: :</span><span class="nv">$t</span><span class="p">&#34;);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">nqp::istype</span><span class="p">(</span><span class="nv">$stop</span><span class="o">,</span><span class="n">VMArray</span><span class="p">)</span> <span class="o">||</span>
    <span class="nv">$start</span> <span class="ow">ne</span> <span class="nv">$stop</span> <span class="o">??</span> <span class="nv">$lang</span><span class="o">.</span><span class="nf">balanced</span><span class="p">(</span><span class="nv">$start</span><span class="o">,</span> <span class="nv">$stop</span><span class="p">)</span>
                    <span class="o">!!</span> <span class="nv">$lang</span><span class="o">.</span><span class="nf">unbalanced</span><span class="p">(</span><span class="nv">$stop</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>在初始化 Cursor 位置之后, <code>$lang</code> 继续包含我们的 Quote 语言编织然后我们落进一个 <code>for</code> 循环来迭代 <code>@base_tweaks</code>, 对于里面的每一个元素, 我们都调用方法 <code>tweak_$_</code>, 给它传递一个真值 <code>1</code>。因为我们仅仅只有一个 base tweak, 这意味着我们正在Quote braid上调用方法 <code>tweak_ww</code>。我们来看看那个方法是关于什么的。</p>
<p>因为 Quote braid 被定义在同一个文件中, 仅仅搜索 <code>method tweak_ww</code> 好了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">tweak_ww</span><span class="p">(</span><span class="nv">$v</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$v</span> <span class="o">??</span> <span class="nb">self</span><span class="o">.</span><span class="nf">add-postproc</span><span class="p">(&#34;</span><span class="s2">quotewords</span><span class="p">&#34;)</span><span class="o">.</span><span class="nf">apply_tweak</span><span class="p">(</span><span class="n">ww</span><span class="p">)</span>
       <span class="o">!!</span> <span class="nb">self</span>
<span class="p">}</span>
</code></pre></div><p>很好。我们给它的 <code>$v</code> 为真, 所以我们调用了 <code>.add-postproc</code> 然后调用 <code>.apply_tweak(ww)</code>。看一下那个方法的上面和下面, 我们看到 <code>.add-postproc</code> 也用在其它不含 bug 的引号中, 所以我们忽略它并直接跳到 <code>.apply_tweak</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">apply_tweak</span><span class="p">(</span><span class="nv">$role</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$target</span> <span class="o">:=</span> <span class="nf">nqp::can</span><span class="p">(</span><span class="nb">self</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">herelang</span><span class="p">&#39;)</span> <span class="o">??</span> <span class="nb">self</span><span class="o">.</span><span class="nf">herelang</span> <span class="o">!!</span> <span class="nb">self</span><span class="p">;</span>
    <span class="nv">$target</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nb">mixin</span><span class="p">(</span><span class="nv">$target</span><span class="o">,</span> <span class="nv">$role</span><span class="p">);</span>
    <span class="nb">self</span>
<span class="p">}</span>
</code></pre></div><p>啊哈! 它的参数是一个 role 并且它把该 role 混进来我们的 Quote braid 中。我们来看看那个 role 是关于什么的(再一次, 仅仅在文件中搜索 <a href="https://github.com/rakudo/rakudo/blob/94b09ab9280d39438f84cb467d4b3d3042b8f672/src/Raku/Grammar.nqp#L4846">role ww</a>, 或者仅仅向上滚动一点):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">ww</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">escape:sym</span>&lt;&#39; &#39;&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">&#39;</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">quote</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">quote</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">escape:sym</span>&lt;‘ ’&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">‘</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">quote</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">quote</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">escape:sym</span>&lt;&#34; &#34;&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">&#34;</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">quote</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">quote</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">escape:sym</span>&lt;“ ”&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">“</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">quote</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">quote</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">escape:sym</span>&lt;colonpair&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">:</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="nf">RESTRICTED</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">colonpair</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">colonpair</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">escape:sym</span>&lt;#&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">#</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">comment</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>奥, 我的天呐!引号! 如果这个地方不是我们修复 bug 的地方, 那么我就是一个芭蕾舞女演员。 我们找到它了!</p>
<p>我们定位到的 role 把进了某些 tokens 混合进了我们正使用的 Quote braid 中来解析 <code>qww</code> 的内容。我们带有 bug 的 <code>„”</code> 引号组合明显不在那个列表中。我们来把它添加进去!</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">escape:sym</span>&lt;„ ”&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">„</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">quote</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">quote</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>编译! 运行我们带有 bug 的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./raku -e <span class="s1">&#39;.say for qww&lt;foo „hello world” bar&gt;&#39;</span>
foo
bar
</code></pre></div><p>悲催! 好吧, 我们确实为引号处理找到了正确的地方, 但是我们让问题变得更加糟糕了。发生了什么?</p>
<h2 id="quotastic-inaction">Quotastic Inaction</h2>
<p>我们新的 token 肯定解析了那个引号, 但是我们绝对没有给它添加 Actions 动作&hellip; 好吧, 对它起作用。Action 类和 Grammars 相邻, 在 <code>src/Raku/Actions.nqp</code> 中。打开它并定位到匹配的方法那里; 比如 <a href="https://github.com/rakudo/rakudo/blob/94b09ab9280d39438f84cb467d4b3d3042b8f672/src/Raku/Actions.nqp#L9243">method escape:sym&lt;“ ”&gt;</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">escape</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">&#39; &#39;</span><span class="p">&gt;(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nf">mark_ww_atom</span><span class="p">(</span><span class="nv">$&lt;quote&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">);</span> <span class="p">}</span>
<span class="k">method</span> <span class="nf">escape</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">&#34; &#34;</span><span class="p">&gt;(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nf">mark_ww_atom</span><span class="p">(</span><span class="nv">$&lt;quote&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">);</span> <span class="p">}</span>
<span class="k">method</span> <span class="nf">escape</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">‘ ’</span><span class="p">&gt;(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nf">mark_ww_atom</span><span class="p">(</span><span class="nv">$&lt;quote&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">);</span> <span class="p">}</span>
<span class="k">method</span> <span class="nf">escape</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">“ ”</span><span class="p">&gt;(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nf">mark_ww_atom</span><span class="p">(</span><span class="nv">$&lt;quote&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div><p>并在列表中添加我们自己的版本:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">escape</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">„ ”</span><span class="p">&gt;(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nf">mark_ww_atom</span><span class="p">(</span><span class="nv">$&lt;quote&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div><p>编译! 运行我们带有 bug 的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./raku -e <span class="s1">&#39;.say for qww&lt;foo „hello world” bar&gt;&#39;</span>
foo
hello world
bar
</code></pre></div><p>呼! 成功了! 不再有 bug 了。我们修复了那个 bug!</p>
<p>但是, 等一下&hellip;</p>
<h2 id="遗漏了-但是没有忘记">遗漏了, 但是没有忘记</h2>
<p>看一下<a href="https://docs.raku.org/language/unicode_texas#Other_acceptable_single_codepoints">所有可能的奢华的引号的列表</a>。尽管我们的 bug 报告中仅仅提到了 <code>„”</code> 引号对儿, 但是 <code>‚‘</code> 和 <code>「」</code> 都不在我们的 <code>role ww</code> tokens 中。远远不止的是, 某些左/右引号, 当它们交换位置后, 在引起字符串的时候也刚好能工作, 所以它们也应该在 <code>qww</code> 中起效。然而, 添加一整串额外的 tokens 和一整串其它的 actions 方法是相当不精彩的。有没有更好的方法?</p>
<p>我们仔细看看我们的 tokens:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">escape:sym</span>&lt;“ ”&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">“</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">quote</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">quote</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p><code>sym&lt;“ ”&gt;</code> 我们可以把它省略了 — 这里它的功能仅仅是作为一个名字。我们留下的是一个向前查看的 <code>“</code> 引号还有 <code>&lt;quote=.LANG('MAIN','quote')&gt;</code>。所以我们可以向前查看所有的我们关心的开口引号并让 MAIN braid 接管所有的细节。</p>
<p>所以, 让我们用这个单个 token 替换掉所有的引号处理 tokens:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">escape:sym</span>&lt;&#39;&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr"> &#39; &#34; ‘ ‚ ’ “ „ ” 「 </span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">quote</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">quote</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>并且使用下面这个单个 action 替换掉所有的匹配 actions 方法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">escape</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">&#39;</span><span class="p">&gt;(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nf">mark_ww_atom</span><span class="p">(</span><span class="nv">$&lt;quote&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div><p>编译! 运行我们的带有某些引号变体的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./raku -e <span class="s1">&#39;.say for qww&lt;„looks like” ‚we fixed‘ ｢this thing｣&gt;&#39;</span>
looks like
we fixed
this thing
</code></pre></div><p>精彩! 我们不仅让所有的引号都能正常工作, 还设法清理的存在的 tokens 和 actions 方法。现在所有我们需要做的就是对我们的修复做测试并且我们已经准备提交了。</p>
<h2 id="享用-bug-烤肉">享用 bug 烤肉</h2>
<p><a href="https://github.com/raku/roast">Raku 官方测试套件 Roast</a> 是在 Rakudo 内建目录中的 <code>t/spec</code> 中，如果它不存在, 仅仅运行 <code>make spectest</code> 就好了并且在它把 roast 仓库克隆到 <code>t/spec</code> 中后就中止它。我们需要找到在哪里插入我们的测试而 <code>grep</code> 是干那件事的好朋友:</p>
<pre><code>zoffix@VirtualBox:~/CPANPRC/rakudo/t/spec$ grep -R 'qww' .
Binary file ./.git/objects/pack/pack-5bdee39f28283fef4b500859f5b288ea4eec20d7.pack matches
./S02-literals/allomorphic.t:    my @wordlist = qqww[1 2/3 4.5 6e7 8+9i] Z (IntStr, RatStr, RatStr, NumStr, ComplexStr);
./S02-literals/allomorphic.t:        isa-ok $val, Str, &quot;'$val' from qqww[] is a Str&quot;;
./S02-literals/allomorphic.t:        nok $val.isa($wrong-type), &quot;'$val' from qqww[] is not a $wrong-type.perl()&quot;;
./S02-literals/allomorphic.t:    my @wordlist  = qqww:v[1 2/3 4.5 6e7 8+9i];
./S02-literals/allomorphic.t:    my @written = qqww:v[1 2/3 $num 6e7 8+9i ten];
./S02-literals/allomorphic.t:    is-deeply @angled, @written, &quot;«...» is equivalent to qqww:v[...]&quot;;
./S02-literals/quoting.t:    is(qqww[$alpha $beta], &lt;foo bar&gt;, 'qqww');
./S02-literals/quoting.t:    for (&lt;&lt;$a b c&gt;&gt;, qqww{$a b c}, qqw{$a b c}).kv -&gt; $i, $_ {
./S02-literals/quoting.t:    is-deeply qww&lt;a a ‘b b’ ‚b b’ ’b b‘ ’b b‘ ’b b’ ‚b b‘ ‚b b’ “b b” „b b”
./S02-literals/quoting.t:    'fancy quotes in qww work just like regular quotes';
./integration/advent2014-day16.t:    for flat qww/ foo bar 'first second' / Z @a -&gt; $string, $result {
</code></pre><p>看起来 <code>S02-literals/quoting.t</code> 是它的一个好地方。打开那个文件, 在它的顶部, 通过我们添加的测试的数量来增加 <code>plan</code> 的数量 — 在这个例子中仅仅增加一条就好了。然后滚动到底部并创建一个 block 块, 前面添加一个注释, 并为我们正修复的 <a href="https://rt.perl.org/Ticket/Display.html?id=128304">bug 报告</a>引用那个 RT 标签数字。</p>
<p>在文件里面, 我们使用 <a href="https://docs.raku.org/language/testing#index-entry-is-deeply-is-deeply%28%24value%2C_%24expected%2C_%24description%3F%29">is-deeply</a> 测试函数, 它使用 <a href="https://docs.raku.org/routine/eqv">eqv 操作符</a>语义来做测试。我们会给它一个带有完整引号串的 <code>qww&lt;&gt;</code> 行并告诉它我们所期望返回的项目列表。还要写下测试描述:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># RT #128304</span>
<span class="p">{</span>
    <span class="nb">is-deeply</span> <span class="k">q</span><span class="sa">ww</span><span class="p">&lt;</span><span class="s2">a a ‘b b’ ‚b b’ ’b b‘ ’b b‘ ’b b’ ‚b b‘ ‚b b’ “b b” „b b”
</span><span class="s2">            ”b b“ ”b b“ ”b b” „b b“ „b b” ｢b b｣ ｢b b｣</span><span class="p">&gt;</span><span class="o">,</span>
        <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="o">|</span><span class="p">(&#39;</span><span class="s1">b b</span><span class="p">&#39;</span> <span class="ow">xx</span> <span class="mi">16</span><span class="p">))</span><span class="o">,</span>
    <span class="p">&#39;</span><span class="s1">fancy quotes in qww work just like regular quotes</span><span class="p">&#39;;</span>
<span class="p">}</span>
</code></pre></div><p>返回到 Rakudo checkout, 运行修改后的测试并保证它通过:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ make t/spec/S02-literals/quoting.t
<span class="c1"># &lt;lots of output&gt;</span>
All tests successful.
<span class="nv">Files</span><span class="o">=</span>1, <span class="nv">Tests</span><span class="o">=</span>185,  <span class="m">3</span> wallclock secs <span class="o">(</span> 0.03 usr  0.01 sys +  2.76 cusr  0.11 <span class="nv">csys</span> <span class="o">=</span>  2.91 CPU<span class="o">)</span>
Result: PASS
</code></pre></div><p>漂亮。提交测试 bug 修复好了并且把它们送走! 我们做到了!</p>
<h2 id="结论">结论</h2>
<p>当我们在修复 Raku 中的解析 bugs 的时候, 把程序减少到能重新产生那个 bug 的最小部分然后使用 <code>--target=parse</code> 命令行参数, 得到解析树的输出, 找到所匹配的那个 tokens。<code>statementlist</code></p>
<p>然后, 在 <a href="https://github.com/rakudo/rakudo/blob/04af57c3b3d32353e36614de53396d2b4a08b7be/src/Raku/Grammar.nqp">src/Raku/Grammar.nqp</a> 中跟随这些 tokens, 它也继承自 <a href="https://github.com/raku/nqp/blob/4fd4b48afb45c8b25ccf7cfc5e39cb4bd658901d/src/HLL/Grammar.nqp">NQP 的 src/HLL/Grammar.nqp</a> 。 与位于 <a href="https://github.com/rakudo/rakudo/blob/04af57c3b3d32353e36614de53396d2b4a08b7be/src/Raku/Actions.nqp">src/Raku/Actions.nqp</a> 中的 actions 类协作, 跟随着代码找出正在做什么并期望找出问题出现在什么位置。</p>
<p>修复它。测试它。发布它。</p>
<p>充满了乐趣。</p>
<p><a href="http://raku.party/post/Perl-6-Core-Hacking-Grammatical-Babble">http://raku.party/post/Perl-6-Core-Hacking-Grammatical-Babble</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[从正则表达式到 Grammar(第一部分)]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第二部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/?utm_source=atom_feed" rel="related" type="text/html" title="A Mutable Grammar for Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 核心魔改: Grammar 的胡言乱语" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-14-play-audio-at-given-volume/?utm_source=atom_feed" rel="related" type="text/html" title="以指定音量随机播放音频文件" />
            
                <id>https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>From Regex to Grammar Part One</blockquote><h2 id="into-the-breach">Into the Breach</h2>
<p>假设我们 的日志文件中有一个时间戳 <strong>2016-02-06T14:36+02:00</strong>, 我们使用智能匹配:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="mi">2016</span><span class="sr">-</span><span class="mo">02</span><span class="sr">-</span><span class="mo">06</span><span class="sr">T</span><span class="mi">14</span><span class="p">:</span><span class="na">36</span><span class="o">+</span><span class="mo">02</span><span class="p">:</span><span class="na">00</span><span class="p">/;</span>
</code></pre></div><p>这会报错:</p>
<blockquote>
<p>Unrecognized regex metacharacter - (must be quoted to match literally)</p>
</blockquote>
<p>在 Raku 的正则表达式中任何非字母数字字符(&lsquo;a&rsquo;..&lsquo;z&rsquo;, &lsquo;A&rsquo;..&lsquo;Z&rsquo;, 0..9)都必须用引号引起来:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="mi">2016</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">02</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">06</span><span class="sr">T</span><span class="mi">14</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="mi">36</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">02</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">00</span><span class="p">/;</span>
</code></pre></div><p>现在我们得到等价的奇怪的表达式:</p>
<pre><code>｢2016-01-29T13:25+01:00｣
</code></pre><p>这仅仅告诉我们, <code>~~</code> 智能匹配操作符匹配了一些文本, 这就是它匹配到的文本。<strong>｢｣</strong> 是日语引号标记, 故意和剩余的文本区分开来。</p>
<p>在 Raku 中, 默认打印出带有明确标记的匹配对象, 它准确地告诉你匹配从哪里开始, 到哪里结束。</p>
<h2 id="归纳">归纳</h2>
<p>我们想让该正则表达式更具普遍性, 例如匹配 2016 年的日志:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="mi">2015</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="mi">2016</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">02</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">06</span><span class="sr">T</span><span class="mi">14</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="mi">36</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">02</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">00</span><span class="p">/;</span>
</code></pre></div><p>但是这还会匹配到我们不想要的东西, 例如  &lsquo;/post/2015/02&rsquo; 或者甚至 &lsquo;/number/120153&rsquo;。因为 <code>|</code>的优先级没有字符间的连接优先级高。所以:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">[</span><span class="mi">2015</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="mi">2016</span><span class="p">]</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">02</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">06</span><span class="sr">T</span><span class="mi">14</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="mi">36</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">02</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">00</span><span class="p">/;</span>
</code></pre></div><p>问题解决, 但是我们想匹配 &lsquo;[ 1997 | 1998 | 1999 | 2000&hellip; 2015 ]&rsquo; 这些呢？</p>
<h3 id="learning-shorthnd">Learning Shorthnd</h3>
<p>匹配4位数字的年份好了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\d\d\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">02</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">06</span><span class="sr">T</span><span class="mi">14</span><span class="o">..</span><span class="ni">.</span><span class="p">/;</span>
</code></pre></div><p>其它需要数字的地方也可以使用 <code>\d</code> 这种便捷形式的数字:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\d\d\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> - </span><span class="se">\d\d</span><span class="sr"> T </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="p">/;</span>
</code></pre></div><p><code>'+' &lt;digits&gt; : &lt;digits&gt;</code> 只会匹配 <code>+01</code> 和 <code>+12</code> 之间的时区, 还有其它在 <code>-11</code> 到 <code>-01</code> 之间的时区, 所以我们使用 <code>|</code> 来匹配 &lsquo;+&rsquo; 或 &lsquo;-&rsquo;, 像这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\d\d\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> - </span><span class="se">\d\d</span><span class="sr"> T </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="p">/;</span>
</code></pre></div><p>基本正确了, 但是由于历史原因, 时区还能是一个字母 <code>Z</code>, 所以, 还有一处要修改:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\d\d\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> - </span><span class="se">\d\d</span><span class="sr"> T </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="o">|</span><span class="sr"> Z </span><span class="p">]</span><span class="sr"> </span><span class="p">/;</span>
</code></pre></div><h2 id="重构">重构</h2>
<p>但是那个 <strong><code>[ '+' ... Z ]</code></strong> 表达式太长了, 能重构就更好了。<strong>regex</strong> 对象来拯救我们了, 它帮助我们清理代码。</p>
<p><strong>regex</strong> 对象看起来很像匹配表达式, 除了它使用花括号来告诉从哪开始, 到哪结束:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">Timezone</span> <span class="p">{</span><span class="sr"> Z </span><span class="o">|</span><span class="sr"> </span><span class="p">[&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;]</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">};</span>
<span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\d\d\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> T </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Timezone</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/;</span>
</code></pre></div><p><code>&lt;..&gt;</code> 从外表上看把重构后的表达式和主文本分开了, 而让 Timezone 表达式分离意味着我们能在代码中的任何地方使用它了。事实上我们可以重构其它的正则:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">Date</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d\d\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">};</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">Time</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr">              </span><span class="p">};</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">Timezone</span> <span class="p">{</span><span class="sr"> Z </span><span class="o">|</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">};</span>

<span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Date</span><span class="p">&gt;</span><span class="sr"> T </span><span class="p">&lt;</span><span class="nf">Time</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Timezone</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/;</span>
</code></pre></div><p>让所有这些 <code>\d\d</code> 坐在一块儿有些碍眼, 所以我们再重构下:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">Integer</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">};</span>

<span class="k">my</span> <span class="k">regex</span> <span class="nf">Date</span>     <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Integer</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Integer</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Integer</span><span class="p">&gt;</span><span class="sr">     </span><span class="p">};</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">Time</span>     <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Integer</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Integer</span><span class="p">&gt;</span><span class="sr">                   </span><span class="p">};</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">Timezone</span> <span class="p">{</span><span class="sr"> Z </span><span class="o">|</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Integer</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Integer</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">};</span>

<span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Date</span><span class="p">&gt;</span><span class="sr"> T </span><span class="p">&lt;</span><span class="nf">Time</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Timezone</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/;</span>
</code></pre></div><p><a href="http://theperlfisher.blogspot.jp/2016/02/from-regular-expressions-to-grammars-pt.html">http://theperlfisher.blogspot.jp/2016/02/from-regular-expressions-to-grammars-pt.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/regex" term="regex" label="regex" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[从正则表达式到 Grammar(第二部分)]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第一部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/?utm_source=atom_feed" rel="related" type="text/html" title="A Mutable Grammar for Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 核心魔改: Grammar 的胡言乱语" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-14-play-audio-at-given-volume/?utm_source=atom_feed" rel="related" type="text/html" title="以指定音量随机播放音频文件" />
            
                <id>https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>From Regex to Grammar</blockquote><p>如果你是正则表达式新人(至少当它们用于 Raku 中时), 那我建议你从这个系列的<a href="http://theperlfisher.blogspot.ro/2016/02/from-regular-expressions-to-grammars-pt.html">第一部分</a>开始。那些掌握了一定正则表达式的人可以跳过<a href="http://theperlfisher.blogspot.ro/2016/02/from-regular-expressions-to-grammars-pt_20.html">上周</a>的文章。现在, 继续演示!</p>
<h2 id="上周轶事">上周轶事</h2>
<p>我们开始开发一个接收诸如:</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Hey, did you konw a = &#34;</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">+</span> <span class="s2">&#34;?&#34;</span><span class="p">);</span>
</code></pre></div><p>Javascript 表达式的 Raku 编译器, 并把这段代码转换为 <a href="http://raku.org/">Rakudo</a> 那样的编译器能运行的 Raku 代码。在我们开始之前, 想想转换后的 Raku 代码看起来是什么样的可能会是个好主意。如果你已经知道了 Perl 5, 那么你应该熟悉这样的代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-perl" data-lang="perl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">say</span> <span class="s">&#34;Hey, did you konw a = &#34;</span> <span class="o">~</span> <span class="nv">$a</span> <span class="o">~</span> <span class="s">&#34;?&#34;</span><span class="p">;</span>
</code></pre></div><p>我们将需要确保我们的正则表达式捕获到了 Javascript 的要素。如果你还记得上一次, 我们使用这样一组正则表达式来捕获我们的文本:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">rule</span> <span class="nf">Number</span>                <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">Variable</span>              <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">String</span>                <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">&#34; </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr">                                             </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">Assignment-Expression</span> <span class="p">{</span><span class="sr"> var </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Number</span><span class="p">&gt;</span><span class="sr">                                  </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">Function-Call</span>         <span class="p">{</span><span class="sr"> console </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> log </span><span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">};</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">var a = 3; console.log(&#34;Hey, did you konw a = &#34; + a + &#34;?&#34;);</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">rule</span> <span class="p">{</span> <span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>  <span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span> <span class="p">};</span>
</code></pre></div><p>如果你把这段代码放到一个 Raku 源文件中并运行它, 那么它的输出第一次看起来可能会有点奇怪:</p>
<pre><code>｢var a = 3; console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; );｣
 Assignment-Expression =&gt; ｢var a = 3｣
    Variable =&gt; ｢a ｣
    Number =&gt; ｢3｣
 Function-Call =&gt; ｢console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; )｣
    String =&gt; ｢&quot;Hey, did you know a = &quot; ｣
    Variable =&gt; ｢a ｣
    String =&gt; ｢&quot;?&quot; ｣
</code></pre><p>如果你愿意暂时忽略 「」 标记, 你会看到匹配被缩进了, 几乎像资源管理器窗口一样, <code>&lt;Assignment-Expression&gt;</code> 作为目录, <code>Variable</code> 和 <code>Number</code> 作为目录里面的文件。实际上, 那离真相不远了。当我看到这种结构时, 我发现使用一点添加的语法能帮助我们像这样来观察它:</p>
<pre><code>$/ =&gt; ｢var a = 3; console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; );｣
 &lt;Assignment-Expression&gt; =&gt; ｢var a = 3｣
    &lt;Variable&gt; =&gt; ｢a ｣
    &lt;Number&gt; =&gt; ｢3｣
 &lt;Function-Call&gt; =&gt; ｢console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; )｣
    &lt;String&gt; =&gt; ｢&quot;Hey, did you know a = &quot; ｣
    &lt;Variable&gt; =&gt; ｢a ｣
    &lt;String&gt; =&gt; ｢&quot;?&quot; ｣
</code></pre><p>这几乎让怎么打印出文本变得更容易, 并在我们的正则表达式中指出了一个小问题。我们来打印给变量 <em>a</em> 所赋的数字, 从这儿开始。第一行告诉我们目录的根, 或者匹配树是 <code>$/</code>。如果你在测试文件的末尾添加上 <code>say $/;</code> 并返回它, 那么你会看到整个表达式被打印出了 2 次。那一定意味着 <code>$/</code> 就是整个匹配。</p>
<p>每向下推进一层就是把 <code>=&gt;</code> 箭头的左侧的东西添加到 <code>$/</code> 的右边。把之前的 <code>say</code> 语句修改为 <code>say  $/&lt;Assignment-Expression&gt;;</code>, 并看看输出发生了什么改变。它现在看起来应该像这样:</p>
<pre><code>｢var a = 3｣
  Variable =&gt; ｢a ｣
  Number =&gt; ｢3｣
</code></pre><p>让我们把把标记(不可见)添加进来, 所以我们能知道到了哪里&hellip;</p>
<pre><code>$/&lt;Assignment-Expression&gt; =&gt; ｢var a = 3｣
  &lt;Variable&gt; =&gt; ｢a ｣
  &lt;Number&gt; =&gt; ｢3｣
</code></pre><p>我们现在能看到我们的目标, 数字 3, 仅仅实在更下面的一层。和上次一样, 我们能够添加表达式左侧的东西, 所以我们就动手吧。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;&lt;</span><span class="s">Number</span><span class="p">&gt;;</span>
  <span class="p">｢</span><span class="s">3</span><span class="p">｣</span>
</code></pre></div><p>我们几乎得到我们想要的了。「」 挡道, 所以我们在这儿把值转换回数字。我把转换(cast)用引号扩起来, 因为它不是 <code>C/C++</code> 程序员那样认为的&quot;casting&quot;。我们想做的大约等价于 <code>sscanf(str,&quot;%d&quot;,&amp;num)</code>, 但是在 Raku 中, 这个操作符更加简单:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">+</span><span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;&lt;</span><span class="s">Number</span><span class="p">&gt;;</span> <span class="c1"># 3</span>
</code></pre></div><p>如果不深入更多细节, 那么 <code>$/</code> 是一个里面藏着隐式数字、字符串和布尔值的对象。前面添加的 <code>+</code> 把隐藏在 <code>$/</code> 对象中的数字显示出来了。</p>
<h2 id="从-javascript-到-perl">从 Javascript 到 Perl</h2>
<p>我们离从 Javascript 生成 Raku 代码不远了。让我们使用上面所学的开始我们的第一个语句, 赋值语句。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span>
      <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>

<span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div><p>我们仅仅使用了 7 行 Raku 就把代码从一种语言转换为另外一种语言。并且大部分的 Raku 代码都是可重用的, 因为字符串, 数字, 和 <code>Javascript/C/Java</code> 风格的变量名在大部分语言之间是通用的。</p>
<p>上次, 我们学习了怎么使用正则表达式来创建匹配。这次我们学会了怎么使用我们说匹配到的东西, 还有怎么在 <em>say</em> 语句中找出我们想要的东西。 不可见的匹配标记相当有用, 我可能会写一个模块来把它们放回到匹配表达式中, 那应该不难。</p>
<p>那个方案有一个问题, 如果我们看一下 <code>&lt;Function-Call&gt;</code> 匹配, 会很容易发现那个问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="o">=&gt;</span> <span class="p">｢</span><span class="s">console.log( &#34;Hey, did you know a = &#34; + a + &#34;?&#34; )</span><span class="p">｣</span>
  <span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span> <span class="o">=&gt;</span> <span class="p">｢</span><span class="s">&#34;Hey, did you know a = &#34; </span><span class="p">｣</span>
  <span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">=&gt;</span> <span class="p">｢</span><span class="s">a </span><span class="p">｣</span>
  <span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span> <span class="o">=&gt;</span> <span class="p">｢</span><span class="s">&#34;?&#34; </span><span class="p">｣</span>
</code></pre></div><p>当我们写了 <code>say $/&lt;Function-Call&gt;&lt;String&gt;;</code> 时, 我们会获取哪个 <code>&lt;String&gt;?</code> 在你运行这段代码之前, 先猜测一下。会是第一个吗, 因为一旦匹配对象被创建,  Raku 就不会把它替换掉? 会是最后一个吗, 因为最后一个&quot;覆盖&quot;了第一个? 编译器会仅仅&quot;感到困惑&quot;然后什么也不打印吗? 运行一下看看!</p>
<p>它实际上以一个列表的形式把两个匹配都返回了, 所以你可以引用任何一个。 我们的不可见标记现在看起来长这样:</p>
<pre><code>$/&lt;Function-Call&gt; =&gt; ｢console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; )｣
  &lt;String&gt;[0] =&gt; ｢&quot;Hey, did you know a = &quot; ｣
  &lt;Variable&gt; =&gt; ｢a ｣
  &lt;String&gt;[1] =&gt; ｢&quot;?&quot; ｣
</code></pre><p>所以, 如果我们想打印第一个字符串, 我们可以写上 <code>say $/&lt;Function-Call&gt;&lt;String&gt;[0];</code> 并得到含有时髦的日语标记的「&ldquo;Hey, did you know a = &quot; 」。幸运的是有一种便捷方式来避免那些日语标记, 就像数字 3 中的那样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">~</span><span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
 <span class="p">&#34;</span><span class="s2">Hey, did you know a = </span><span class="p">&#34;</span>
</code></pre></div><p><strong>~</strong> 操作符使匹配字符串化, 就像 <code>+</code> 让返回的匹配数字化一样。所以你可能自己把最后一行写作:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span>
  <span class="p">&#39;</span><span class="s1"> $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span>
  <span class="nv">$&lt;Function-Call&gt;&lt;String&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hey, did you know a = </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$a</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">?</span><span class="p">&#34;;</span>
</code></pre></div><p>我们已经把我们的两行 Javascript 代码编译成 Raku 代码了。</p>
<h2 id="重构">重构</h2>
<p>现在已经能工作了, 但是有很多重复。目前我们得到是:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">rule</span> <span class="nf">Variable</span>               <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">String</span>                 <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> &#34; </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr">                                            </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">Assignment-Expression</span>  <span class="p">{</span><span class="sr"> var </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Number</span><span class="p">&gt;</span><span class="sr">                                  </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">Function-Call</span>          <span class="p">{</span><span class="sr"> console </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> log </span><span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">};</span>

<span class="p">&#39;</span><span class="s1">var a = 3; console.log( &#34;Hey, did you know a = &#34; + a + &#34;?&#34; );</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">rule</span> <span class="p">{</span> <span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span> <span class="p">}</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span>  <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span>  <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>
</code></pre></div><p>那些 rules 看起来相当好,  <code>&lt;String&gt;</code> 和 <code>&lt;Variable&gt;</code> 的重复也是不可避免的。 但是看看 <code>say</code> 语句, 你会看到 <code>&lt;Assignment-Expression&gt;</code> 和 <code>&lt;Function-Call&gt;</code> 重复了自身好几次。避免这种重复的一种方法是创建一个临时变量, 但是那可能会变得丑陋。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$assignment-expression</span> <span class="o">=</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$assignment-expression</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span>  <span class="nv">$assignment-expression</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
</code></pre></div><p>相反, 我们利用 Raku 的子例程签名, 并且重用 <code>$/</code> 变量名以使我们能重用上面所写的代码, 然后拿掉 <code>&lt;Assignment-Expression&gt;</code> 部分。 我会把子例程的名字命名为 rule 的名字, 只是为了直接了当。(你会在之后看到为什么这样做。)</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span>  <span class="nf">assignment-expression</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nf">assignment-expression</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">);</span>
</code></pre></div><p>让我们对 <code>&lt;Function-Call&gt;</code> 也做同样的事情, 创建一个含有 <code>$/</code> 子例程签名的同名函数。 它现在写在一行里面就很整洁了, 并且只重复 <em><!-- raw HTML omitted --></em> 部分, 因为它不得不重复。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
     <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">);</span>
</code></pre></div><h2 id="对象化">对象化</h2>
<p>一路上我做了相当多的选择, 让我们到达这里。这就是我们上次重构的地方:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">rule</span> <span class="nf">Number</span>                <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">Variable</span>              <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">String</span>                <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> &#34; </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr">                                            </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">Assignment-Expression</span> <span class="p">{</span><span class="sr"> var </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Number</span><span class="p">&gt;</span><span class="sr">                                  </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">Function-Call</span>         <span class="p">{</span><span class="sr"> console </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> log </span><span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">};</span>

<span class="p">&#39;</span><span class="s1">var a = 3; console.log( &#34;Hey, did you know a = &#34; + a + &#34;?&#34; );</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">rule</span> <span class="p">{</span> <span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span> <span class="p">}</span>

<span class="k">sub</span> <span class="nf">assignment-expression</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
    <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
    <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nf">assignment-expression</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">);</span>
<span class="nb">say</span> <span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">);</span>
</code></pre></div><p>这就是我们的回报。我们先捡起最后那两个 <code>say</code> 语句。 我们还没有给顶层 rule 一个名字, 所以我们就叫它&hellip; 好吧, 现在还是叫 &lsquo;top&rsquo; 吧。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">top</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span> <span class="nf">assignment-expression</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="o">~</span> <span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">}</span>
</code></pre></div><h2 id="收回你的吐槽">收回你的吐槽</h2>
<p>我们暂时还没有对处于文件顶层的 rules 做太多处理, 所以让我们开始工作吧。 在 Raku 中, 就一般编程而言, 把你的代码打包复用是不错的注意。而 Raku 让我们使用 <code>class</code> 关键字将我们的程序打包, 我们拥有的那些 rules 从任何意义上来说实际上不是&quot;代码&rdquo;。而它们能够用于代码中, 并且我们确实使用了它们, 它们自身实际上并没有做出任何决定。</p>
<p>所以我们不应该使用 <code>class</code> 关键字来把它们打包到一块。相反, 有另外一种便捷的类型用于把一堆正则表达式和 rules 打包到一块儿, 它叫做 <code>grammar</code>。</p>
<p>它的语法就像声明一个「rule」 那样。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Javascript</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">Number</span>                <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
    <span class="k">rule</span> <span class="nf">Variable</span>              <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
    <span class="k">rule</span> <span class="nf">String</span>                <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> &#34; </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr">                                            </span><span class="p">};</span>
    <span class="k">rule</span> <span class="nf">Assignment-Expression</span> <span class="p">{</span><span class="sr"> var </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Number</span><span class="p">&gt;</span><span class="sr">                                  </span><span class="p">};</span>
    <span class="k">rule</span> <span class="nf">Function-Call</span>         <span class="p">{</span><span class="sr"> console </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> log </span><span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">};</span>      

    <span class="k">rule</span> <span class="nf">TOP</span>                   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Assignment-Expression</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Function-Call</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span><span class="sr">              </span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div><p>你会注意到, 我们给我们的顶层 rule 也起了个名字, 并且暂时把它叫做 「TOP」 吧。 如果你正在家独自玩耍, 你可能已经做出更改并想知道 「&lsquo;var a = 3;&hellip;&rsquo; ~~ rule { &hellip; }」 是怎么起作用的, 因为键入诸如 「&lsquo;var a = 3;&hellip;&rsquo; ~~ JavaScript;」这样的东西可能不会那么有作用。</p>
<p>Grammars 就像类一样, 在里面它们实际上是一块可能的代码。 它们本身不会工作, 它们必须从潜在的转换为动态的代码。我们可以像你在类中做的那样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$JavaScript</span> <span class="o">=</span> <span class="n">JavaScript</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</code></pre></div><p>现在我们拥有了一个可以工作的变量。 现在, 让我们来使用它。所有的 Grammar 类都有一个内置的 「parse()」 方法, 以使我们能得到 grammar 中的正则表达式。 我们来修改我们的匹配语句以利用 parse() 方法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$JavaScript</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">var a = 3; console.log( &#34;Hey, did you know a = &#34; + a + &#34;?&#34; );</span><span class="p">&#39;);</span>
</code></pre></div><p>我们的代码应该又能工作了。</p>
<h2 id="接收动作">接收动作</h2>
<p>现在我们已经把我们所有的匹配的东西打包到一个小型的类里面了, 如果我们能对那些子例程做同样的处理将会很棒。 我们在这儿试试, 把我们的子例程放到它们自己的命名空间中, 就像我们对 rule 做的那样。 我们必须从 「sub」 修改为 「method」, 而我们的 「top」 方法将会使用 「self.」 去调用其它方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Actions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">assignment-expression</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">top</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nb">self</span><span class="o">.</span><span class="nf">assignment-expression</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">)</span> <span class="o">~</span>
        <span class="nb">self</span><span class="o">.</span><span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>就像之前那样, 我们可以在一行里面创建 Actions 对象:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$actions</span> <span class="o">=</span> <span class="n">Actions</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</code></pre></div><p>并且调用 top 几乎像我们之前做的那样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$actions</span><span class="o">.</span><span class="nf">top</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">);</span>
</code></pre></div><p>我们已经修改了很多东西了, 所以我们来看看到哪了。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">JavaScript</span> <span class="p">{</span>
  <span class="k">rule</span> <span class="nf">Number</span>                <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
  <span class="k">rule</span> <span class="nf">Variable</span>              <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
  <span class="k">rule</span> <span class="nf">String</span>                <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> &#34; </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr">                                            </span><span class="p">};</span>
  <span class="k">rule</span> <span class="nf">Assignment-Expression</span> <span class="p">{</span><span class="sr"> var </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Number</span><span class="p">&gt;</span><span class="sr">                                  </span><span class="p">};</span>
  <span class="k">rule</span> <span class="nf">Function-Call</span>         <span class="p">{</span><span class="sr"> console </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> log </span><span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">};</span>
  <span class="k">rule</span> <span class="nf">TOP</span>                   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Assignment-Expression</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Function-Call</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span><span class="sr">              </span><span class="p">}</span>
<span class="p">}</span>
<span class="k">my</span> <span class="nv">$j</span> <span class="o">=</span> <span class="n">JavaScript</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>

<span class="nv">$j</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">var a = 3; console.log( &#34;Hey, did you know a = &#34; + a + &#34;?&#34; );</span><span class="p">&#39;);</span>

<span class="k">class</span> <span class="nc">Actions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">assignment-expression</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
      <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
      <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">top</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
      <span class="nb">self</span><span class="o">.</span><span class="nf">assignment-expression</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">)</span> <span class="o">~</span>
      <span class="nb">self</span><span class="o">.</span><span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$actions</span> <span class="o">=</span> <span class="n">Actions</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$actions</span><span class="o">.</span><span class="nf">top</span><span class="p">(</span><span class="nv">$/</span><span class="p">);</span>
</code></pre></div><p>不用担心, 我们快要到了。既然我们有了一个单独的类来处理 Actions, 我们把方法重命名为 Grammar 中所匹配的 rule 的名字, 以使我们不会忘记它们是什么。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Actions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">Assignment-Expression</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">Function-Call</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~$</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nb">self</span><span class="o">.</span><span class="nf">Assignment-Expression</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">)</span> <span class="o">~</span>
        <span class="nb">self</span><span class="o">.</span><span class="nf">Function-Call</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">)</span>

    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>更进一步, 我们还有最后一点魔法能够利用。 我们将把 <code>$javascript</code> 和 <code>$actions</code> 对象像这样组合在一块。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$javascript</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">...</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="nv">$actions</span><span class="p">)</span> <span class="p">);</span>
</code></pre></div><p>「:actions(&hellip;)」 给 「parse()」方法声明的可选参数。我们正告诉正则表达式引擎, 任何时候, 像 <code>&lt;Function-Call&gt;</code> 或 <code>&lt;TOP&gt;</code> 这样的 rule 匹配时, 我们会在我们的类中让它调用对应的同名方法。</p>
<p>这几乎是按原样工作的, 但是如果你运行修改后的代码,  你会发现解析返回了原来的匹配对象, 带着日语引用标记。所以看起来好像我们又回到了原地。不完全是。</p>
<p>继续, 我们在其中之一的方法中添加一个临时的 <code>&quot;say 'Hello';&quot;</code> 语句, 仅仅是为了确认它们正被调用。这是正则引擎正在工作并且可能正解析它所 going over 的一个重要证据。 你甚至可以使用某些我们上面已经学到的技巧然后写上 「<code>say $/&lt;Variable&gt;;</code>」 来查看匹配是否正像你想的那样运行。继续运行并玩玩, 做完的时候再回到这儿。</p>
<h2 id="混合信号mixed-signals">混合信号(Mixed Signals)</h2>
<p>正发生的是方法正被调用, 但是它们的输出被丢弃。我们来捕获输出然后使用 grammar 的最后一个特性, 抽象语法树。现在,  这可能会勾起坐在教室里看黑板上画出的盒子和线段的场景, 但是也没有那么糟糕了。我们已经看到了一个, 实际上 <strong>say()</strong> 的输出就是一个 AST。</p>
<p>我们来看下其它语法树, 我们在后台创建的那个。在 &ldquo;$javascript.parse(&hellip;)&rdquo; 调用的末尾添加上 「.ast」, 这会给我们展示我们自己创建的语法树。</p>
<p>如果你这样做了, 你会看到它打印了(Any), 这通常等价于「匹配失败」, 单是我们从之前的测试中知道匹配没有失败。所以这儿发生了什么? 当我们的方法运行的时候, 它们返回输出, 但是 Raku 不知道怎么处理这些输出, 或者说它不知道把输出安装到它所创建的 AST 中的哪个位置。</p>
<p>关键是一个叫做「make」的小东西。在方法的开头, 把这个添加到过去我们放置「say」的地方。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Actions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">Assignment-Expression</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">make</span> <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">Function-Call</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">make</span> <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">make</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">ast</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">ast</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>还有, 因为 Raku 为我们调用方法, 我们不需要自己来调用 <code>self.Function-Call(...)</code>, 我们需要做的全部工作就是查看 <code>Function-Call(...)</code> 返回给我们的语法树。最终我们做到了。一个完整, 虽然微小的编译器。为了防止你在编辑时迷失, 这儿有一个最终的结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">JavaScript</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">Number</span>                <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr">                                                          };
</span><span class="sr">    rule Variable              </span><span class="p">{</span> \<span class="nb">w</span><span class="o">+</span>                                                          <span class="p">}</span><span class="sr">;
</span><span class="sr">    rule String                </span><span class="p">{</span> <span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">-[ &#34; ]</span><span class="p">&gt;</span><span class="o">+</span> <span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span>                                            <span class="p">}</span><span class="sr">;
</span><span class="sr">    rule Assignment-Expression </span><span class="p">{</span> <span class="n">var</span> <span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span>                                  <span class="p">}</span><span class="sr">;
</span><span class="sr">    rule Function-Call         </span><span class="p">{</span> <span class="n">console</span> <span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span> <span class="nb">log</span> <span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span> <span class="p">}</span><span class="sr">;
</span><span class="sr">    rule TOP                   </span><span class="p">{</span> <span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>              <span class="p">}</span><span class="sr">
</span><span class="sr">}
</span><span class="sr">
</span><span class="sr">class Actions </span><span class="p">{</span>
    <span class="k">method</span> <span class="nf">Assignment-Expression</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
    <span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr">    method Function-Call</span><span class="p">(</span><span class="sr"> </span><span class="ni">$</span><span class="sr">/ </span><span class="p">)</span><span class="sr"> </span><span class="p">{</span>
        <span class="k">make</span> <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>
    <span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr">    method TOP</span><span class="p">(</span><span class="sr"> </span><span class="ni">$</span><span class="sr">/ </span><span class="p">)</span><span class="sr"> </span><span class="p">{</span>
        <span class="k">make</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">ast</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">ast</span> 
    <span class="p">}</span><span class="sr">
</span><span class="sr">}
</span><span class="sr">
</span><span class="sr">my </span><span class="nv">$j</span><span class="sr"> </span><span class="o">=</span><span class="sr"> JavaScript</span><span class="ni">.</span><span class="sr">new;
</span><span class="sr">my </span><span class="nv">$a</span><span class="sr"> </span><span class="o">=</span><span class="sr"> Actions</span><span class="ni">.</span><span class="sr">new;
</span><span class="sr">say </span><span class="nv">$j</span><span class="ni">.</span><span class="sr">parse</span><span class="p">(</span><span class="sr">
</span><span class="sr">   </span><span class="p">&#39;</span><span class="s1">var a = 3; console.log( &#34;Hey, did you know a = &#34; + a + &#34;?&#34; );</span><span class="p">&#39;</span><span class="sr">,
</span><span class="sr">   </span><span class="p">:</span><span class="na">actions</span><span class="p">(</span><span class="nv">$a</span><span class="p">))</span><span class="ni">.</span><span class="sr">ast;
</span></code></pre></div><h2 id="到哪里去">到哪里去</h2>
<p>一个简单但整洁的更改是你可以扩展 Assignment-Expression 来既接收数字又接收字符串。上次我们谈论了 rules 中的轮试,所以这个提示应该足够让你开始了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">rule</span> <span class="nf">Assignment-Expression</span> <span class="p">{</span><span class="sr"> var </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">(&lt;</span><span class="nf">Number</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;)</span><span class="sr"> </span><span class="p">}</span>
</code></pre></div><p>你必须修改下 Assignment-Expression 方法以使它起作用。或者你可以狡猾一点然后发现( <code>&lt;Number&gt; | &lt;String&gt;</code> ) 可以转换为它自己的小的普通的 &ldquo;Term&rdquo; rule, &ldquo;rule Term { <!-- raw HTML omitted --> | <!-- raw HTML omitted --> }&rdquo;, 然后添加一个 action &ldquo;method Term($/) { make $/<!-- raw HTML omitted --> or $/<!-- raw HTML omitted -->}&rdquo; 而只在 Assignment-Expression 中修改一个东西。</p>
<p><a href="http://theperlfisher.blogspot.fr/2016/02/from-regular-expressions-to-grammars-pt_28.html">http://theperlfisher.blogspot.fr/2016/02/from-regular-expressions-to-grammars-pt_28.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/regex" term="regex" label="regex" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[使用 Grammar 解析文本: 一个例子]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-07-11-an-example-of-parsing-text-in-grammar/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/?utm_source=atom_feed" rel="related" type="text/html" title="A Mutable Grammar for Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 核心魔改: Grammar 的胡言乱语" />
                <link href="https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第一部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第二部分)" />
            
                <id>https://ohmyweekly.github.io/notes/2015-07-11-an-example-of-parsing-text-in-grammar/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>An Example of Parsing Text in Grammar</blockquote><ul>
<li>解析<code>[ ]</code> 里面的数据：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nn">Grammar::Debugger</span><span class="p">;</span>

<span class="k">grammar</span> <span class="nc">Lines</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="ni">^</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">line</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="ni">$</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">line</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        \[
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">student</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">semicolon</span><span class="p">&gt;</span><span class="sr">
</span><span class="sr">        \]
</span><span class="sr">        </span><span class="se">\n</span><span class="sr">                   </span><span class="c1"># 换行 \n 是最容易被忽略的地方
</span><span class="c1"></span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">student</span> <span class="p">{</span><span class="sr">
</span><span class="sr">       </span><span class="p">&lt;</span><span class="nf">myname</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">comma</span><span class="p">&gt;</span><span class="sr">   </span><span class="c1"># 分隔符也可以是一个 subrule
</span><span class="c1"></span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">myname</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;[</span><span class="sr">A</span><span class="o">..</span><span class="sr">Za</span><span class="o">..</span><span class="sr">z-</span><span class="p">]&gt;</span><span class="o">+</span><span class="sr">       </span><span class="c1"># 字符类的写法 &lt;[...]&gt;
</span><span class="c1"></span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">comma</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&#39;</span><span class="s1">,</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">+</span><span class="sr">              </span><span class="c1"># 逗号, 分号 不能裸露出现在 token 中
</span><span class="c1"></span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">semicolon</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">+</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

<span class="p">}</span>

<span class="k">my</span> <span class="nv">$parse</span> <span class="o">=</span> <span class="n">Lines</span><span class="o">.</span><span class="nb">parsefile</span><span class="p">(&#39;</span><span class="s1">test.txt</span><span class="p">&#39;);</span>
<span class="nb">say</span> <span class="nv">$parse</span><span class="p">;</span>
</code></pre></div><p>test.txt 的内容如下：</p>
<pre><code>[Lue, Fan]
[Lou, Man-Li]
[Tian, Mijie; Zhou, Lin; Zou, Xiao; Zheng, Qiaoji; Luo, Lingling; Jiang, Na; Lin, Dunmin]
</code></pre><p>下面的 Grammar 用于解析一个字符串, 由于 tokens 不能回溯, 所以当解析 <code>$str</code> 时使用了 Grammar 的继承, 重写了 university 这个 token:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$string</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">[Wang, Zhiguo; Zhao, Zhiguo] Hangzhou Normal Univ, Ctr Cognit &amp; Brain Disorders, Hangzhou, Zhejiang, Peoples R China; [Wang, Zhiguo; Theeuwes, Jan] Vrije Univ Amsterdam, Dept Cognit Psychol, Amsterdam, Netherlands</span><span class="p">&#34;;</span>

<span class="k">grammar</span> <span class="nc">University::Grammar</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span>             <span class="p">{</span><span class="sr"> </span><span class="ni">^</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">university</span><span class="p">&gt;</span><span class="sr"> </span><span class="ni">$</span><span class="sr">             </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">university</span>      <span class="p">{</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">bracket</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">info</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">; </span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">bracket</span>         <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">studentname</span><span class="p">&gt;</span><span class="sr">  </span><span class="p">&#39;</span><span class="s1">] </span><span class="p">&#39;</span><span class="sr">      </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">studentname</span>     <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">stdname</span><span class="o">=.</span><span class="nf">info</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">; </span><span class="p">&#39;</span><span class="sr">      </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">info</span>            <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">field</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">, </span><span class="p">&#39;</span><span class="sr">              </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">field</span>           <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">,\]\[;</span><span class="se">\n</span><span class="p">]&gt;</span><span class="o">+</span><span class="sr">               </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1"># grammar 像类一样可以继承, 里面的 token 可以被重写</span>
<span class="k">grammar</span> <span class="nc">MyUniversity</span>  <span class="k">is</span> <span class="nc">University::Grammar</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">university</span>      <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">info</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">; </span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Zhejiang Univ, Coll Environm &amp; Resources Sci, Dept Resource Sci, Hangzhou 310029, Peoples R China; La Trobe Univ, Dept Agr Sci, Bundoora, Vic 3083, Australia; Hangzhou Normal Coll, Fac Life Sci, Hangzhou, Peoples R China</span><span class="p">&#34;;</span>

<span class="k">my</span> <span class="nv">$parsed</span> <span class="o">=</span> <span class="n">University::Grammar</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$string</span><span class="p">);</span>
<span class="c1"># my $parsed = MyUniversity.parse($str);</span>

<span class="k">for</span> <span class="nv">@</span><span class="p">(</span><span class="nv">$parsed</span><span class="p">&lt;</span><span class="s">university</span><span class="p">&gt;&lt;</span><span class="s">info</span><span class="p">&gt;)</span> <span class="k">-&gt;</span> <span class="nv">$f</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$f</span><span class="p">&lt;</span><span class="s">field</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[使用 Grammar 解析日期]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-09-15-use-grammar-to-parse-date/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/?utm_source=atom_feed" rel="related" type="text/html" title="A Mutable Grammar for Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 核心魔改: Grammar 的胡言乱语" />
                <link href="https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第一部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第二部分)" />
            
                <id>https://ohmyweekly.github.io/notes/2015-09-15-use-grammar-to-parse-date/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Use Grammar to Parse Date</blockquote><h3 id="描述">描述</h3>
<p>下面的日期, 有些使用了 <code>M D Y</code> 格式, 有些使用了 <code>Y M D</code> 格式, 还使用了任意分隔符! 请把这些散乱的文本解析成合适的 ISO 8601 (<code>YYYY-MM-DD</code>) 格式化日期。</p>
<p>假设只有以 4 个数字开头的日期使用 <code>Y M D</code> 格式, 其它的使用 <code>M D Y</code> 格式。</p>
<h3 id="输入样本">输入样本</h3>
<pre><code>2/13/15
1-31-10
5 10 2015
2012 3 17
2001-01-01
2008/01/07
</code></pre><h3 id="输出样本">输出样本</h3>
<pre><code>2015-02-13
2010-01-31
2015-05-10
2012-03-17
2001-01-01
2008-01-07
</code></pre><h3 id="扩展挑战-中级">扩展挑战 [中级]</h3>
<p>使用 <code>2014-12-24</code> 作为相对日期的基准。</p>
<p>当添加 <code>days</code>(天数) 时, 要考虑到每月会有不同的天数, 忽略闰年。</p>
<p>当添加月和年时, 使用整个 <code>units</code>, 以至于:</p>
<p>one month before october 10 is september 10</p>
<p>one year after 2001-04-02 is 2002-04-02</p>
<p>one month after january 30 is february 28 (not march 1)</p>
<h3 id="sallys-inputs">Sally&rsquo;s inputs:</h3>
<pre><code>tomorrow
2010-dec-7
OCT 23
1 week ago
next Monday
last sunDAY
1 year ago
1 month ago
last week
LAST MONTH
10 October 2010
an year ago
2 years from tomoRRow
1 month from 2016-01-31
4 DAYS FROM today
9 weeks from yesterday
</code></pre><h3 id="sallys-expected-outputs">Sally&rsquo;s expected outputs:</h3>
<pre><code>2014-12-25
2010-12-01
2014-10-23
2014-12-17
2014-12-29
2014-12-21
2013-12-24
2014-11-24
2014-12-15
2014-11-24
2010-10-10
2013-12-24
2016-12-25
2016-02-28
2014-12-28
2015-02-25
</code></pre><p>smls 大神给出了完整的 grammar：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$today</span> <span class="o">=</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">2014</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">24</span><span class="p">);</span>

<span class="k">grammar</span> <span class="nc">MessyDate</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr">    </span><span class="p">&lt;</span><span class="nf">date</span><span class="p">&gt;</span><span class="sr">                 </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;date&gt;</span><span class="o">.</span><span class="k">made</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">duration</span><span class="p">&gt;</span><span class="sr"> ago         </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span><span class="o">.</span><span class="nb">earlier</span><span class="o">:</span> <span class="o">|</span><span class="nv">$&lt;duration&gt;</span><span class="o">.</span><span class="k">made</span>     <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">duration</span><span class="p">&gt;</span><span class="sr"> from </span><span class="p">&lt;</span><span class="nf">date</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;date&gt;</span><span class="o">.</span><span class="k">made</span><span class="o">.</span><span class="nb">later</span><span class="o">:</span> <span class="o">|</span><span class="nv">$&lt;duration&gt;</span><span class="o">.</span><span class="k">made</span> <span class="p">}</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">rule</span> <span class="nf">date</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">month</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">(&lt;</span><span class="nf">sep</span><span class="p">&gt;</span><span class="o">?</span><span class="p">)</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">day</span><span class="p">&gt;</span><span class="sr">   </span><span class="p">[</span><span class="nv">$0</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">year</span><span class="p">&gt;]</span><span class="o">?</span><span class="sr">
</span><span class="sr">            </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">day</span><span class="p">&gt;</span><span class="sr">   </span><span class="p">(&lt;</span><span class="nf">sep</span><span class="p">&gt;</span><span class="o">?</span><span class="p">)</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">month</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">[</span><span class="nv">$0</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">year</span><span class="p">&gt;]</span><span class="o">?</span><span class="sr">
</span><span class="sr">            </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">year</span><span class="p">&gt;</span><span class="sr">  </span><span class="p">(&lt;</span><span class="nf">sep</span><span class="p">&gt;</span><span class="o">?</span><span class="p">)</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">month</span><span class="p">&gt;</span><span class="sr">  </span><span class="nv">$0</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">day</span><span class="p">&gt;</span><span class="sr">    </span><span class="p">]</span><span class="sr">
</span><span class="sr">          </span><span class="p">{</span> <span class="k">make</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="nv">$&lt;year&gt;</span><span class="o">.</span><span class="k">made</span><span class="o">//</span><span class="nv">$today</span><span class="o">.</span><span class="nb">year</span><span class="o">,</span> <span class="o">|</span><span class="nv">$&lt;month day&gt;</span><span class="o">».</span><span class="k">made</span> <span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> today          </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span>     <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> yesterday      </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> tomorrow       </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> last </span><span class="p">&lt;</span><span class="nf">weekday</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span> <span class="o">-</span> <span class="p">(</span><span class="nv">$today</span><span class="o">.</span><span class="nb">day-of-week</span> <span class="o">-</span> <span class="nv">$&lt;weekday&gt;</span><span class="o">.</span><span class="k">made</span><span class="p">)</span> <span class="nv">%</span> <span class="mi">7</span> <span class="o">||</span> <span class="mi">7</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> next </span><span class="p">&lt;</span><span class="nf">weekday</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span> <span class="o">+</span> <span class="p">(</span><span class="nv">$&lt;weekday&gt;</span><span class="o">.</span><span class="k">made</span> <span class="o">-</span> <span class="nv">$today</span><span class="o">.</span><span class="nb">day-of-week</span><span class="p">)</span> <span class="nv">%</span> <span class="mi">7</span> <span class="o">||</span> <span class="mi">7</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> last </span><span class="p">&lt;</span><span class="nf">unit</span><span class="p">&gt;</span><span class="sr">    </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span><span class="o">.</span><span class="nb">earlier</span><span class="o">:</span> <span class="o">|</span><span class="p">(</span><span class="nv">$&lt;unit&gt;</span><span class="o">.</span><span class="s">made</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> next </span><span class="p">&lt;</span><span class="nf">unit</span><span class="p">&gt;</span><span class="sr">    </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span><span class="o">.</span><span class="nb">later</span><span class="o">:</span>   <span class="o">|</span><span class="p">(</span><span class="nv">$&lt;unit&gt;</span><span class="o">.</span><span class="s">made</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span><span class="sr">
</span><span class="sr">    }
</span><span class="sr">
</span><span class="sr">    rule duration </span><span class="p">{</span>
        <span class="p">&lt;</span><span class="s">count</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="s">unit</span><span class="p">&gt;</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;unit&gt;</span><span class="o">.</span><span class="s">made</span> <span class="o">=&gt;</span> <span class="nv">$&lt;count&gt;</span><span class="o">.</span><span class="k">made</span> <span class="p">}</span><span class="sr">
</span><span class="sr">    }
</span><span class="sr">
</span><span class="sr">    token year </span><span class="p">{</span>
        <span class="o">|</span> <span class="p">&lt;</span><span class="s">number(4)</span><span class="p">&gt;</span>        <span class="p">{</span> <span class="k">make</span> <span class="o">+</span><span class="nv">$&lt;number&gt;</span>       <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">number</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">..</span><span class="mi">49</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span> <span class="mi">2000</span> <span class="o">+</span> <span class="nv">$&lt;number&gt;</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">number</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">50</span><span class="o">..*</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span> <span class="mi">1900</span> <span class="o">+</span> <span class="nv">$&lt;number&gt;</span> <span class="p">}</span><span class="sr">
</span><span class="sr">    }
</span><span class="sr">
</span><span class="sr">    token month </span><span class="p">{</span>
        <span class="o">|</span> <span class="p">&lt;</span><span class="s">number(1..2, 1..12)</span><span class="p">&gt;</span> <span class="p">{</span> <span class="k">make</span> <span class="o">+</span><span class="nv">$&lt;number&gt;</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Jan</span><span class="p">[</span><span class="sr">uary</span><span class="p">]</span><span class="o">?</span><span class="sr">   </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">1</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Feb</span><span class="p">[</span><span class="sr">ruary</span><span class="p">]</span><span class="o">?</span><span class="sr">  </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">2</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Mar</span><span class="p">[</span><span class="sr">ch</span><span class="p">]</span><span class="o">?</span><span class="sr">     </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">3</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Apr</span><span class="p">[</span><span class="sr">il</span><span class="p">]</span><span class="o">?</span><span class="sr">     </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">4</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> May          </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">5</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Jun</span><span class="p">[</span><span class="sr">e</span><span class="p">]</span><span class="o">?</span><span class="sr">      </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">6</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Jul</span><span class="p">[</span><span class="sr">y</span><span class="p">]</span><span class="o">?</span><span class="sr">      </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">7</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Aug</span><span class="p">[</span><span class="sr">ust</span><span class="p">]</span><span class="o">?</span><span class="sr">    </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">8</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Sep</span><span class="p">[</span><span class="sr">tember</span><span class="p">]</span><span class="o">?</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">9</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Oct</span><span class="p">[</span><span class="sr">ober</span><span class="p">]</span><span class="o">?</span><span class="sr">   </span><span class="p">{</span> <span class="k">make</span> <span class="mi">10</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Nov</span><span class="p">[</span><span class="sr">ember</span><span class="p">]</span><span class="o">?</span><span class="sr">  </span><span class="p">{</span> <span class="k">make</span> <span class="mi">11</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Dec</span><span class="p">[</span><span class="sr">ember</span><span class="p">]</span><span class="o">?</span><span class="sr">  </span><span class="p">{</span> <span class="k">make</span> <span class="mi">12</span> <span class="p">}</span><span class="sr">
</span><span class="sr">    }
</span><span class="sr">
</span><span class="sr">    token day </span><span class="p">{</span> <span class="p">&lt;</span><span class="s">number(1..2, 1..31)</span><span class="p">&gt;</span> <span class="p">{</span> <span class="k">make</span> <span class="o">+</span><span class="nv">$&lt;number&gt;</span> <span class="p">}</span><span class="sr"> }
</span><span class="sr">
</span><span class="sr">    token weekday </span><span class="p">{</span>
        <span class="o">|</span> <span class="p">:</span><span class="s">i</span> <span class="n">Mon</span><span class="o">[</span><span class="nb">day</span><span class="o">]?</span>    <span class="p">{</span> <span class="k">make</span> <span class="mi">1</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Tue</span><span class="p">[</span><span class="sr">sday</span><span class="p">]</span><span class="o">?</span><span class="sr">   </span><span class="p">{</span> <span class="k">make</span> <span class="mi">2</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Wed</span><span class="p">[</span><span class="sr">nesday</span><span class="p">]</span><span class="o">?</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span> <span class="mi">3</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Thu</span><span class="p">[</span><span class="sr">rsday</span><span class="p">]</span><span class="o">?</span><span class="sr">  </span><span class="p">{</span> <span class="k">make</span> <span class="mi">4</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Fri</span><span class="p">[</span><span class="sr">day</span><span class="p">]</span><span class="o">?</span><span class="sr">    </span><span class="p">{</span> <span class="k">make</span> <span class="mi">5</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Sat</span><span class="p">[</span><span class="sr">urday</span><span class="p">]</span><span class="o">?</span><span class="sr">  </span><span class="p">{</span> <span class="k">make</span> <span class="mi">6</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Sun</span><span class="p">[</span><span class="sr">day</span><span class="p">]</span><span class="o">?</span><span class="sr">    </span><span class="p">{</span> <span class="k">make</span> <span class="mi">7</span> <span class="p">}</span><span class="sr">
</span><span class="sr">    }
</span><span class="sr">
</span><span class="sr">    token sep   </span><span class="p">{</span> <span class="p">&lt;</span><span class="s">[-/.\h]</span><span class="p">&gt;</span> <span class="p">}</span><span class="sr"> 
</span><span class="sr">    token count </span><span class="p">{</span> <span class="p">(&lt;</span><span class="s">[0..9]</span><span class="p">&gt;</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">+</span><span class="nv">$0</span> <span class="p">}</span><span class="sr">  </span><span class="o">|</span><span class="sr">  an</span><span class="o">?</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span> <span class="mi">1</span> <span class="p">}</span><span class="sr"> }
</span><span class="sr">    token unit  </span><span class="p">{</span> <span class="p">:</span><span class="s">i</span> <span class="p">(</span><span class="nb">day</span><span class="o">|</span><span class="nb">week</span><span class="o">|</span><span class="nb">month</span><span class="o">|</span><span class="nb">year</span><span class="p">)</span> <span class="k">s</span><span class="err">?</span> <span class="p">{</span><span class="sr"> make </span><span class="nv">$0</span><span class="ni">.</span><span class="sr">lc </span><span class="p">}</span><span class="sr"> </span><span class="p">}</span>

    <span class="k">multi</span> <span class="k">token</span> <span class="nf">number</span> <span class="p">(</span><span class="nv">$digits</span><span class="p">)</span>        <span class="p">{</span><span class="sr">  </span><span class="p">&lt;[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]&gt;</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="nv">$digits</span><span class="p">}</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">multi</span> <span class="k">token</span> <span class="nf">number</span> <span class="p">(</span><span class="nv">$digits</span><span class="o">,</span> <span class="nv">$test</span><span class="p">)</span> <span class="p">{</span><span class="sr"> </span><span class="p">(&lt;[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]&gt;</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="nv">$digits</span><span class="p">})</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="p">{</span> <span class="o">+</span><span class="nv">$0</span> <span class="o">~~</span> <span class="nv">$test</span> <span class="p">}&gt;</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nb">lines</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="n">MessyDate</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span><span class="o">.</span><span class="k">made</span> <span class="o">//</span> <span class="p">&#34;</span><span class="s2">failed to parse &#39;</span><span class="nv">$_&#39;</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><ul>
<li><code>[...]</code> 是非捕获分组</li>
<li><code>&lt;[...]&gt;</code> 是 Raku 中的字符类</li>
<li><code>&lt;number(4)&gt;</code> 是扩展的 <code>&lt;...&gt;</code> 语法, 实际上是方法调用</li>
</ul>
<p>在 grammar 中, 有两个 regex 的变体, <code>rule</code> 和 <code>token</code>。rule 默认不会回溯。<code>rule</code> 与 <code>token</code> 的一个重要区别是, <code>rule</code> 这样的正则采取了 <code>:sigspace</code> 修饰符。 <code>rule</code> 实际上是</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">regex</span> <span class="p">:</span><span class="s">ratchet</span> <span class="p">:</span><span class="s">sigspace</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>的简写。<code>ratchet </code>这个单词的意思是: (防倒转的)棘齿, 意思它是不能回溯的! 而 <code>:sigspace</code> 表明正则中的空白是有意义的, 而 <code>token</code> 实际上是:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">regex</span> <span class="p">:</span><span class="s">ratchet</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>的简写。 所以在 token 中, 若不是显式的写上 <code>\s</code>、<code>\h</code>、<code>\n</code> 等空白符号, 其它情况下就好像空白隐身了一样, 虽然你写了, 但是编译器却视而不见。</p>
<p><code>//</code> 在左侧匹配失败时会在右侧提供一个默认值。</p>
<p><code>&lt;number(4)&gt;</code>  和 <code>&lt;number(2, 0..49)&gt;</code> 中使用了扩展了的 <code>&lt;...&gt;</code> 元语法。 标识符(例如左面的 number)后面的第一个字符决定了闭合尖括号之前剩余文本的处理。它的底层语义是函数或方法调用, 所以, 如果标识符后面的第一个字符是左圆括号, 那么它要么是方法调用, 要么是函数调用:</p>
<p><code>&lt;number(4)&gt;</code> 等价于 <code>&lt;number=&amp;number(4)&gt;</code></p>
<p><code>&lt;number(2, 0..49)&gt;</code> 等价于 <code>&lt;number=&amp;number(2, 0..49)&gt;</code></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">token</span> <span class="nf">number</span> <span class="p">(</span><span class="nv">$digits</span><span class="p">)</span>        <span class="p">{</span><span class="sr">  </span><span class="p">&lt;[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]&gt;</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="nv">$digits</span><span class="p">}</span><span class="sr"> </span><span class="p">}</span>
<span class="k">multi</span> <span class="k">token</span> <span class="nf">number</span> <span class="p">(</span><span class="nv">$digits</span><span class="o">,</span> <span class="nv">$test</span><span class="p">)</span> <span class="p">{</span><span class="sr"> </span><span class="p">(&lt;[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]&gt;</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="nv">$digits</span><span class="p">})</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="p">{</span> <span class="o">+</span><span class="nv">$0</span> <span class="o">~~</span> <span class="nv">$test</span> <span class="p">}&gt;</span><span class="sr"> </span><span class="p">}</span>
</code></pre></div><p>在扩展的 <code>&lt;...&gt;</code> 语法中, 一个前置的 <code>?{</code> 或 <code>!{</code> 标示着代码断言:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(&lt;</span><span class="s">[0..9]</span><span class="p">&gt;</span> <span class="o">**</span> <span class="p">{</span><span class="nv">$digits</span><span class="p">})</span> <span class="o">&lt;?</span><span class="p">{</span> <span class="o">+</span><span class="nv">$0</span> <span class="o">~~</span> <span class="nv">$test</span> <span class="p">}</span><span class="o">&gt;</span>
</code></pre></div><p>等价于：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># + 强制后面的$0为数值上下文, 以匹配 $test 中的数字</span>
<span class="p">(&lt;</span><span class="s">[0..9]</span><span class="p">&gt;</span> <span class="o">**</span> <span class="p">{</span><span class="nv">$digits</span><span class="p">})</span> <span class="p">{</span> <span class="o">+</span><span class="nv">$0</span> <span class="o">~~</span> <span class="nv">$test</span> <span class="ow">or</span> <span class="nb">fail</span> <span class="p">}</span>
</code></pre></div><p>上面的两句代码, 具名 <code>regex</code>, <code>token</code>, 或 <code>rule</code> 是一个子例程, 所以可以传递参数给具名 token。</p>
<p>这从标准输入里读取散乱的日期并把对应的 ISO 日期写到标准输出。</p>
<p>它能解析任务描述中的所有日期（包含扩展）, 还有 - 然而, 在它们中我得到 4 个不同的结果。请弄清它们是否是错误的, 并且为什么是错的:</p>
<p>2010-dec-7 &ndash;&gt; 我得到  2010-12-07 而不是 2010-12-01</p>
<p>last week &ndash;&gt; 我得到 2014-12-17 而不是 2014-12-15</p>
<p>1 month from 2016-01-31 &ndash;&gt; 我得到  2016-02-29 而不是 2016-02-28</p>
<p>9 weeks from yesterday &ndash;&gt; 我得到  2015-02-24 而不是 2015-02-25</p>
<p>有人在评论中问他 <code>make/made</code> 是类中的方法吗？</p>
<p>是的, 它们是 Match 类的方法。</p>
<h3 id="match-objects注意-object-是复数">Match objects(注意 object 是复数)</h3>
<p>每个 regex match(并且通过扩展, 每个 grammar token match)的结果被表示为一个 Match 对象。</p>
<p>通过这个对象你能访问各种信息片段:</p>
<ul>
<li>匹配到的字符串</li>
<li>关于输入字符串匹配的开始和结束位置</li>
<li>每个位置捕获和具名捕获的sub-matches</li>
<li>与这个匹配有关的 AST 片段, 如果有的话</li>
</ul>
<h3 id="ast-片段">AST 片段</h3>
<p>在 <code>token/rule</code> 里面调用 <code>make</code>, 设置将会与当前匹配关联的 &ldquo;AST 片段&rdquo;。然后, 你可以通过在当前结果 Match 对象身上调用 <code>.made</code> 方法来获取那个关联数据。</p>
<p>这正是自由形式的插槽, 允许你使用 Match 对象存储任何你想要的东西并在以后检索它, 尽管显而易见这意味着像我那样创建一个 AST。</p>
<h3 id="在-grammar-中创建-ast">在 grammar 中创建 &ldquo;AST&rdquo;</h3>
<p>在我的 grammar 中每个 <code>token/rule</code> 使用 <code>.made</code> 来取得它的 sub-rule 匹配构建的数据片段, 把它们组合成一个更大的数据片段, 这是为了让它的 parent rule 能检索。等等。</p>
<p>我在每个 token/rule 里面使用这些语法简写来引用 sub-matches 的 Match 对象:</p>
<ul>
<li><code>$0</code> 引用 sub-match（由一个 <code>()</code> 捕获组导致） 的第一个位置处的 Match 对象。</li>
<li><code>$&lt;date&gt;</code> 引用一个名字为 <code>date</code> 的具名 sub-match 的 Match 对象(通过 <code>&lt;date&gt;</code> 递归引用名为 date 的 <code>token</code> 导致).</li>
</ul>
<p><a href="https://www.reddit.com/r/dailyprogrammer/comments/3wshp7/20151214_challenge_245_easy_date_dilemma/">https://www.reddit.com/r/dailyprogrammer/comments/3wshp7/20151214_challenge_245_easy_date_dilemma/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Grammar Generating Grammar]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-04-15-grammar-generating-grammar/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-04-15-grammar-generating-grammar/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+08:00</published>
            <updated>2021-07-10T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Grammar Generating Grammar</blockquote><p>现在你可能已经习惯了 Raku 中到处出现的前缀 &ldquo;meta&rdquo;。<strong>Metaclasses</strong>, <strong>Metaobjects</strong>, <strong>Metaoperators</strong>, 还有迷一般的 Meta-Object 协议。听起来一点也不可怕, 你都见过了不是吗？今天, 在 Raku Advent Calendar 上, 我们将进行完全的 <strong>meta</strong> 化(full meta)。我们将拥有能解析 grammar 的 grammar, 然后生成将用于解析 grammar 的 grammar。</p>
<p>Grammar 无疑是 Raku 的杀手级功能。我们拥有了正则表达式曾经没有的东西: 可读性、可组合性当然还有解析 Raku 自身的能力。— 如果这不能展示它的强大, 那我不知道什么能够!</p>
<p>为预定义好的 grammar(例如以 <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">Bachus-Naur</a> 形式)写解析器总是有点无趣, 几乎和复制粘贴一样。如果你曾经坐下来重头开始写一个解析器(或者期间温习一遍那本优秀的&quot;让我们构建一个编译器&quot;图书), 你可能会意识到模式是如此相似:从你的 grammar 中拿出单个 rule, 为它写一个子例程, 让它调用(可能是递归的)其它类似的为其它 grmmars rules 定义的子例程, 清洗, 重复。现在我们有了Raku grammar! 在这个新世界中, 我们不必为每个 token 写上子例程来完成工作了。 现在我们写 <strong>grammar</strong> 类, 里面放上 <em>tokens</em>、<em>rules</em>、<em>regexes</em> 标志。在标志里写正则表达式(或代码)并引用(可能是递归的) Raku gramamr 中的其它标志。如果你曾经使用过这些东西, 你肯定会意识到 Raku 中的 grammar 是多么的方便。</p>
<p>但是假如我们已经有了一个 grammar, 例如之前提到过的 BNF? 我们所做的就是小心地把已经存在的 grammar(实际上在我们头脑中解析它)重新键入到一个新的 Raku  Grammar 中以代表同样的一个东西, 但是那确实有一个可作为可执行代码的优势。对大多数人来说, 那都不是事儿。我们不是普通人, 我们是程序员。我们拥有资源。它们会让这些 grammar 变得有意义。</p>
<p>绝妙的是 Raku grammar 和语言的其它元素没什么两样。grammar 就像类那样也是头等公民, 可以内省, 扩展。实际上, 你可以查看编译器源代码自身, 你会注意到 <a href="https://github.com/rakudo/rakudo/blob/nom/src/Raku/Metamodel/GrammarHOW.nqp">grammar 就是一种特定种类的类</a>。它们遵守和类一样的规则, 允许我们就地创建 grammar, 就地给 grammar 添加 tokens, 最终完结这个 gramamr 以拥有一个合适的能实例化的类对象。现在既然我们能解析 BNF grammar(因为它们就是普通的文本)并从代码中创建 Raku grammar, 让我们把这些片段放在一起并写点能手动把 BNF gramamr 转化为 Raku grammar 的东西。</p>
<h4 id="解析-bnf-grammar-的-grammar">解析 BNF grammar 的 grammar</h4>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Grammar::BNF</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">rule</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">rule</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">opt-ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&lt;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">rule-name</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&gt;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">opt-ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">::=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">opt-ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">expression</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">line-end</span><span class="p">&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">expression</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">list-of-terms</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">+</span><span class="nv">%</span><span class="sr"> </span><span class="p">[</span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">|</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">opt-ws</span><span class="p">&gt;]</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">term</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">literal</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&lt;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">rule-name</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&gt;</span><span class="p">&#39;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">list-of-terms</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">term</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">+</span><span class="nv">%</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">opt-ws</span><span class="p">&gt;</span><span class="sr">                </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">rule-name</span>     <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">&gt;</span><span class="p">]&gt;</span><span class="o">+</span><span class="sr">                           </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">opt-ws</span>        <span class="p">{</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr">                               </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">line-end</span>      <span class="p">{</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">opt-ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr">                  </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">literal</span>       <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">&#34;</span><span class="p">]&gt;</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#34;</span><span class="s2">&#39;</span><span class="p">&#34;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">&#39;</span><span class="p">]&gt;</span><span class="o">*</span><span class="sr"> </span><span class="p">&#34;</span><span class="s2">&#39;</span><span class="p">&#34;</span><span class="sr"> </span><span class="p">}</span>

    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>最上层的 3 个 token 发生了有意思的事情。<em>rule</em> 是 BNF grammar 的核心构造块: 一个 <code>&lt;symbol&gt; ::=  &lt;expression&gt;</code> 块儿, 后面跟着一个换行符。整个 grammar 就是一列 rule。每个表达式是一列项、或可能的和它们的备选分支。每个项要么是一个字面值, 或一个由尖括号包围的标志名。足够了! 那涵盖了解析部分。让我们看一下生成自身。我们的确有一种&quot;为 grammar 中的每个 token 做某事&quot;的机制, 以 <strong>Actions</strong>的形式, 让我们继续并使用它:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">class</span> <span class="nc">Actions</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">BNFGrammar</span><span class="p">&#39;;</span>
    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$grmr</span> <span class="o">:=</span> <span class="n">Metamodel::GrammarHOW</span><span class="o">.</span><span class="nb">new_type</span><span class="p">(</span><span class="o">:</span><span class="nv">$.name</span><span class="p">);</span>
        <span class="nv">$grmr</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(&#39;</span><span class="s1">TOP</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="nb">EVAL</span> <span class="p">&#39;</span><span class="s1">token { &lt;</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$&lt;rule&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">ast</span><span class="o">.</span><span class="nb">key</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">&gt; }</span><span class="p">&#39;);</span>
        <span class="k">for</span> <span class="nv">$&lt;rule&gt;</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">ast</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$rule</span> <span class="p">{</span>
            <span class="nv">$grmr</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(</span><span class="nv">$rule</span><span class="o">.</span><span class="nb">key</span><span class="o">,</span> <span class="nv">$rule</span><span class="o">.</span><span class="nb">value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nv">$grmr</span><span class="o">.^</span><span class="nb">compose</span><span class="p">;</span>
        <span class="k">make</span> <span class="nv">$grmr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">expression</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="nb">EVAL</span> <span class="p">&#39;</span><span class="s1">token { </span><span class="p">&#39;</span> <span class="o">~</span> <span class="o">~</span><span class="nv">$/</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> }</span><span class="p">&#39;;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="k">rule</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="o">~</span><span class="nv">$&lt;rule-name&gt;</span> <span class="o">=&gt;</span> <span class="nv">$&lt;expression&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><strong>TOP</strong> 方法毫无疑问是最魔幻和最恐怖的, 所以擒贼先擒王, 其它小喽啰就无关紧要了。基本上, <em>TOP</em> 那儿发生了三件事:</p>
<ul>
<li>1、我们创建了一个新的 grammar, 作为一个新的 Raku 类型</li>
<li>2、我们使用 <code>^add_method</code> 方法为 grammar 添加 token</li>
<li>3、我们使用 <code>^compose</code> 方法定型该 grammar</li>
</ul>
<p>虽然 Raku 指定名为 <strong>TOP</strong> 的 token 是解析开始的地方, 在 BNF 中第一个 rule 总是开始点。为了彼此适应,  我们精巧地制作了一个假的 <strong>TOP</strong> token, 它正是调用了 BNF grammar 中指定的第一个 rule。不可避免地, 恐怖又令人失望的 <strong>EVAL</strong> 引起了我们的注意, 就像它说了&quot;这儿发生了可怕的事情&quot; 一样。它那样说并不是完全错误的, 但是因为我们没有其它程序化构建单独正则的方法, 我们不得不接受这点不适。</p>
<p><strong>TOP</strong> 之后我们继续为我们的 grammar 添加 BNF rule 的剩余部分, 这一次保留它们原来的名字, 然后 <code>^compose</code> 整个东西, 最后让它(make)成为解析的结果: 一个做好的解析类。</p>
<p>在 <em>expression</em> 方法中我们把解析过的 BNF 元素粘贴到一块以产生合法的 Raku 代码。这变得特别容易, 因为那俩个单独的标志带有空格, 使用管道符号来轮试备选分支, 并使用尖括号包围标志名。目前为止, 一个 rule 看起来像这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&lt;</span><span class="s">foo</span><span class="p">&gt;</span> <span class="o">::=</span> <span class="p">&#39;</span><span class="s1">bar</span><span class="p">&#39;</span> <span class="o">|</span> <span class="p">&lt;</span><span class="s">baz</span><span class="p">&gt;</span>
</code></pre></div><p>我们求值(EVAL)的 Raku 代码变为:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="p">{</span> <span class="p">&#39;</span><span class="s1">bar</span><span class="p">&#39;</span> <span class="o">|</span> <span class="p">&lt;</span><span class="s">baz</span><span class="p">&gt;</span> <span class="p">}</span>
</code></pre></div><p>因为我们已经在我们代码的 grammar 部分检测我们解析的 BNF 是正确的, 没有什么能够阻止我们传递解析整个表达式字面值到我们的代码中并使用一个 <code>token  { }</code> 来包裹它, 所以让我们继续。</p>
<p>最后, 对于我们解析的每一个 BNF rule, 我们产生了一个很不错的 <em>Pair</em>, 所以我们的 <strong>TOP</strong> 方法很愉快地处理它们中的每个。</p>
<p>看起来我们好像在这儿结束了, 但是仅仅是为了方便使用者, 让我们写一个更好的方法, 接收一个 BNF grammar, 并为我们生成一个准备好使用的类型对象。我们记得, grammar 就是类, 所以我们没有什么能阻止我们直接为我们的 gramamr 添加它:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Grammar::BNF</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">method</span> <span class="nf">generate</span><span class="p">(</span><span class="nv">$source</span><span class="o">,</span> <span class="o">:</span><span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">BNFGrammar</span><span class="p">&#39;)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$actions</span> <span class="o">=</span> <span class="n">Actions</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">:</span><span class="nv">$name</span><span class="p">);</span>
        <span class="k">my</span> <span class="nv">$ret</span> <span class="o">=</span> <span class="nb">self</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$source</span><span class="o">,</span> <span class="o">:</span><span class="nv">$actions</span><span class="p">)</span><span class="o">.</span><span class="nb">ast</span><span class="p">;</span>
        <span class="k">return</span> <span class="nv">$ret</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这儿看起来很不错! 在你开始往你自己的项目中复制粘贴所有这些之前, 记得 <a href="https://github.com/tadzik/Grammar-BNF/">Grammar::BNF</a> 是一个可在 <a href="http://modules.raku.org/">Raku Module Ecosystem</a>获得的 Raku 模块, 使用你喜欢的模块管理器安装。</p>
<p>假设你确实花费时间查看了开头的 post, 你可能会记得我许诺过我们将有 grammar(第一条)来解析 grammar(第二条), 然后生成 grammar(第三条), 使用生成的 grammar 来解析 grammar(第四条)。目前为止， 我们已经看到过 BNF::Grammar  grammar(那是第一条), 并解析一个 BNF grammar(那是第二条), 以类对象的形式来生成 Raku grammar(第三条)。 就这些。我们仍旧缺乏最后一部分, 使用整个东西来解析 grammar。 我们只完成了 75% 的 meta 化, 今天足够了。为什么现在停止? 为什么不拿一个 BNF grammar , 使用 Raku grammar 来解析 grammar, 使用 Raku BNF grammar 的结果来解析我们原来的 BNF Grammar? 那不是很好吗？是的, 那很好, 我们只是留了一个练习给你。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Parser API - 解析 INI]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-01-19-parser-api-example-ini/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2021-01-19-parser-api-example-ini/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-01-19T00:00:00+08:00</published>
            <updated>2021-01-19T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Parser API - Example: INI</blockquote><h2 id="例子-ini">例子: INI</h2>
<p>INI(initialization 的简称)文件是简单的配置文件。由于没有标准的格式，我们将编写一个能够解析这个例子文件的程序。</p>
<div class="highlight"><pre class="chroma"><code class="language-ini" data-lang="ini"><span class="na">username</span> <span class="o">=</span> <span class="s">noha</span>
<span class="na">password</span> <span class="o">=</span> <span class="s">plain_text</span>
<span class="na">salt</span> <span class="o">=</span> <span class="s">NaCl</span>

<span class="k">[server_1]</span>
<span class="na">interface</span><span class="o">=</span><span class="s">eth0</span>
<span class="na">ip</span><span class="o">=</span><span class="s">127.0.0.1</span>
<span class="na">document_root</span><span class="o">=</span><span class="s">/var/www/example.org</span>

<span class="k">[empty_section]</span>

<span class="k">[second_server]</span>
<span class="na">document_root</span><span class="o">=</span><span class="s">/var/www/example.com</span>
<span class="na">ip</span><span class="o">=</span>
<span class="na">interface</span><span class="o">=</span><span class="s">eth1</span>
</code></pre></div><p>每一行都包含一个键和值，中间用等号隔开；或者包含一个用方括号括起来的章节名；或者是空白，没有任何意义。</p>
<p>每当出现一个节名，下面的键和值就属于该节，直到下一个节名。文件开头的键值对属于一个隐式的 &ldquo;空&quot;节。</p>
<h2 id="编写-grammar">编写 grammar</h2>
<p>首先使用 Cargo <a href="https://pest.rs/book/examples/csv.html#setup">初始化一个新项目</a>，添加依赖关系 <code>pest = &quot;2.0&quot;</code> 和  <code>pest_derive = &quot;2.0&quot;</code>。创建一个新文件 <code>src/ini.pest</code> 来保存 grammar。</p>
<p>我们文件中感兴趣的文本 - <code>username</code>、<code>/var/www/example.org</code> 等 - 只由几个字符组成。让我们制定一个规则来识别该集合中的单个字符。内置的规则 <code>ASCII_ALPHANUMERIC</code> 是表示任何大写或小写 ASCII 字母或任何数字的快捷方式。</p>
<pre><code>char = { ASCII_ALPHANUMERIC | &quot;.&quot; | &quot;_&quot; | &quot;/&quot; }
</code></pre><p>节名和属性键不能为空，但属性值可以为空（如上文中的 <code>ip=</code> 行）。也就是说，前者由一个或多个字符组成，<code>char+</code>; 后者由零或多个字符组成，<code>char*</code>。我们将其含义分为两条规则。</p>
<pre><code>name = { char+ }
value = { char* }
</code></pre><p>现在很容易表达这两种输入行。</p>
<pre><code>section = { &quot;[&quot; ~ name ~ &quot;]&quot; }
property = { name ~ &quot;=&quot; ~ value }
</code></pre><p>最后，我们需要一个规则来表示整个输入文件。表达式 <code>(section | property)?</code> 匹配 <code>section</code>、<code>property</code>，否则什么也不匹配。使用内置规则 <code>NEWLINE</code> 来匹配行尾。</p>
<pre><code>file = {
    SOI ~
    ((section | property)? ~ NEWLINE)* ~
    EOI
}
</code></pre><p>要将解析器编译成 Rust，我们需要在 <code>src/main.rs</code> 中添加以下内容。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">pest</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="cp">#[macro_use]</span><span class="w">
</span><span class="w"></span><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">pest_derive</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">pest</span>::<span class="n">Parser</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Parser)]</span><span class="w">
</span><span class="w"></span><span class="cp">#[grammar = </span><span class="s">&#34;ini.pest&#34;</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">INIParser</span><span class="p">;</span><span class="w">
</span></code></pre></div><h2 id="程序初始化">程序初始化</h2>
<p>现在我们可以读取文件，并用 <code>pest</code> 进行解析。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">unparsed_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">read_to_string</span><span class="p">(</span><span class="s">&#34;config.ini&#34;</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;cannot read file&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INIParser</span>::<span class="n">parse</span><span class="p">(</span><span class="n">Rule</span>::<span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">unparsed_file</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;unsuccessful parse&#34;</span><span class="p">)</span><span class="w"> </span><span class="c1">// unwrap the parse result
</span><span class="c1"></span><span class="w">        </span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="c1">// get and unwrap the `file` rule; never fails
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们将使用嵌套的 <code>HashMap</code> 来表达属性列表。外层哈希 map 将以章节名称作为键，以章节内容（内部哈希 map）作为值。每个内部哈希 map 将有属性键和属性值。例如，要访问 <code>server_1</code> 的 <code>document_root</code>，我们可以写 <code>properties[&quot;server_1&quot;][&quot;document_root&quot;]</code>。隐含的 &ldquo;空&quot;节将由常规部分表示，名称为空字符串 <code>&quot;&quot;</code>，这样 <code>properties[&quot;&quot;][&quot;salt&quot;]</code> 就是有效的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">properties</span>: <span class="nc">HashMap</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>请注意，哈希 map 的键和值都是 <code>&amp;str</code>，即借用的字符串。<code>pest</code> 解析器不会复制他们解析的输入，而是借用。所有用于检查解析结果的方法都会返回从原始解析字符串中借用字符串。</p>
<h2 id="主循环">主循环</h2>
<p>现在我们解释解析结果。我们循环浏览文件的每一行，这一行要么是节名，要么是键值属性对。如果遇到一个节名，我们更新一个变量。如果遇到一个属性对，我们就获取一个对当前章节的哈希 map 的引用，然后把这个属性对插入到这个哈希 map 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">current_section_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">file</span><span class="p">.</span><span class="n">into_inner</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">as_rule</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Rule</span>::<span class="n">section</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">inner_rules</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">into_inner</span><span class="p">();</span><span class="w"> </span><span class="c1">// { name }
</span><span class="c1"></span><span class="w">                </span><span class="n">current_section_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inner_rules</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_str</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="n">Rule</span>::<span class="n">property</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">inner_rules</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">into_inner</span><span class="p">();</span><span class="w"> </span><span class="c1">// { name ~ &#34;=&#34; ~ value }
</span><span class="c1"></span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="n">inner_rules</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_str</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="n">inner_rules</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_str</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">                </span><span class="c1">// Insert an empty inner hash map if the outer hash map hasn&#39;t
</span><span class="c1"></span><span class="w">                </span><span class="c1">// seen this section name before.
</span><span class="c1"></span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">section</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">properties</span><span class="p">.</span><span class="n">entry</span><span class="p">(</span><span class="n">current_section_name</span><span class="p">).</span><span class="n">or_default</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="n">section</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="n">Rule</span>::<span class="n">EOI</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">unreachable</span><span class="o">!</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span></code></pre></div><p>在输出方面，我们用<a href="https://doc.rust-lang.org/std/fmt/index.html#sign0">漂亮的打印</a> <code>Debug</code> 格式简单地转储哈希 map。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:#?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">properties</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="空白">空白</h2>
<p>如果你把本章顶部的例子 INI 文件复制到 <code>config.ini</code> 文件中并运行程序，它将无法解析。我们已经忘记了等号周围的可选空格!</p>
<p>对于大型 grammar 来说，处理空白会很不方便。显示地编写 <code>whitespace</code> 规则并手动插入空白会让 grammar 变得难以阅读和修改。<code>pest</code> 提供了一个<a href="https://pest.rs/book/grammars/syntax.html#implicit-whitespace">特殊规则 <code>WHITESPACE</code></a> 的解决方案。如果定义了 <code>WHITESPACE</code>，它将被隐式地运行，尽可能多次地在每个波浪号 <code>~</code> 和每个重复之间运行（例如，<code>*</code> 和 <code>+</code>）。对于我们的 INI 解析器，只有空格才是合法的 whitespace。</p>
<pre><code>WHITESPACE = _{ &quot; &quot; }
</code></pre><p>我们用一个前导的下划线 <code>_{ ... }</code> 来标记 <code>WHITESPACE</code> 规则的<a href="https://pest.rs/book/grammars/syntax.html#silent-and-atomic-rules">静默</a>。}. 这样，即使它匹配，也不会出现在其他规则中。如果它不是静默的，解析就会复杂得多，因为对  <code>Pairs::next(...)</code> 的每次调用都有可能返回 <code>Rule::WHITESPACE</code> 而不是想要的下一条规则。</p>
<p>但是等等! 节名、键或值中不应该有空格！目前，空格是自动插入的。目前，在 <code>name = { char+ }</code> 中，空格会自动插入字符之间。对空格敏感的规则需要用前导符号 <code>@{ ... }</code> 来标记<a href="https://pest.rs/book/grammars/syntax.html#atomic">原子</a>。}. 在原子规则中，自动的空白处理是被禁用的，而内部规则是静默的。</p>
<pre><code>name = @{ char+ }
value = @{ char* }
</code></pre><h2 id="完工">完工</h2>
<p>试试吧！确保文件 <code>config.ini</code> 存在，然后运行程序! 你应该看到这样的东西。</p>
<pre><code>$ cargo run
  [ ... ]
{
    &quot;&quot;: {
        &quot;password&quot;: &quot;plain_text&quot;,
        &quot;username&quot;: &quot;noha&quot;,
        &quot;salt&quot;: &quot;NaCl&quot;
    },
    &quot;second_server&quot;: {
        &quot;ip&quot;: &quot;&quot;,
        &quot;document_root&quot;: &quot;/var/www/example.com&quot;,
        &quot;interface&quot;: &quot;eth1&quot;
    },
    &quot;server_1&quot;: {
        &quot;interface&quot;: &quot;eth0&quot;,
        &quot;document_root&quot;: &quot;/var/www/example.org&quot;,
        &quot;ip&quot;: &quot;127.0.0.1&quot;
    }
}
</code></pre>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rust" term="rust" label="Rust" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="Grammar" />
                            
                        
                    
                
            
        </entry>
    
</feed>
