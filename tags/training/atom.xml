<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.63.2">Hugo</generator><title type="html"><![CDATA[Training on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/training/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/training/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/training/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/training/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2020-09-03T19:49:03+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/training/</id>
    
        
        <entry>
            <title type="html"><![CDATA[DataStream API 介绍]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-event-driven-applications/?utm_source=atom_feed" rel="related" type="text/html" title="事件驱动型应用程序" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-learn-flink-hands-on-training/?utm_source=atom_feed" rel="related" type="text/html" title="学习 Flink: 实践培训" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-data-pipelines-and-etl/?utm_source=atom_feed" rel="related" type="text/html" title="数据管道和 ETL" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics/?utm_source=atom_feed" rel="related" type="text/html" title="流分析" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-fault-tolerance/?utm_source=atom_feed" rel="related" type="text/html" title="通过状态快照进行容错" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-19T00:00:00+08:00</published>
            <updated>2020-08-19T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Intro to the DataStream API</blockquote><p>本次培训的重点是广泛地介绍 DataStream API，使你能够开始编写流式应用程序。</p>
<h2 id="什么可以被流式化">什么可以被流式化？</h2>
<p>Flink 的 DataStream API(Java 和 Scala)可以让你流化任何可以序列化的东西。Flink 自己的序列化器用于:</p>
<ul>
<li>基本类型，即 String, Long, Integer, Boolean, Array</li>
<li>复合类型。Tuples, POJOs 和 Scala case classes</li>
</ul>
<p>而 Flink 又回到了 Kryo 的其他类型。也可以在 Flink 中使用其他序列化器。特别是 Avro，得到了很好的支持。</p>
<h3 id="java-元组-和-pojo">Java 元组 和 POJO</h3>
<p>Flink 的本地序列化器可以有效地操作元组和 POJO。</p>
<p><strong>元组</strong></p>
<p>对于 Java，Flink 定义了自己的 Tuple0 到 Tuple25 类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">person</span> <span class="o">=</span> <span class="n">Tuple2</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;Fred&#34;</span><span class="o">,</span> <span class="n">35</span><span class="o">)</span><span class="o">;</span>

<span class="c1">// zero based index!  
</span><span class="c1"></span><span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">person</span><span class="o">.</span><span class="na">f0</span><span class="o">;</span>
<span class="n">Integer</span> <span class="n">age</span> <span class="o">=</span> <span class="n">person</span><span class="o">.</span><span class="na">f1</span><span class="o">;</span>
</code></pre></div><p><strong>POJO</strong></p>
<p>如果满足以下条件，Flink 将数据类型识别为 POJO 类型（并允许&quot;按名称&quot;字段引用）。</p>
<ul>
<li>类是公共的和独立的（没有非静态的内部类）。</li>
<li>该类有一个公共的无参数构造函数。</li>
<li>类（以及所有超级类）中的所有非静态、非瞬态字段要么是公共的（而且是非最终的），要么有公共的 getter- 和 setter- 方法，这些方法遵循 Java beans 中 getter 和 setter 的命名约定。</li>
</ul>
<p>例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>  
    <span class="kd">public</span> <span class="n">Integer</span> <span class="n">age</span><span class="o">;</span>  
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span><span class="o">}</span><span class="o">;</span>  
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>  
        <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
    <span class="o">}</span><span class="o">;</span>  
<span class="o">}</span>  

<span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;Fred Flintstone&#34;</span><span class="o">,</span> <span class="n">35</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>Flink 的序列化器<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/schema_evolution.html#pojo-types">支持 POJO 类型的模式进化</a>。</p>
<h3 id="scala-元组和-case-class">Scala 元组和 case class</h3>
<p>这些工作就像你期望的那样。</p>
<h2 id="一个完整的例子">一个完整的例子</h2>
<p>这个例子将一个关于人的记录流作为输入，并将其过滤为只包括成年人。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">org.apache.flink.streaming.api.environment.StreamExecutionEnvironment</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.streaming.api.datastream.DataStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.api.common.functions.FilterFunction</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Example</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span>
                <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

        <span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">flintstones</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span>
                <span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;Fred&#34;</span><span class="o">,</span> <span class="n">35</span><span class="o">)</span><span class="o">,</span>
                <span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;Wilma&#34;</span><span class="o">,</span> <span class="n">35</span><span class="o">)</span><span class="o">,</span>
                <span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;Pebbles&#34;</span><span class="o">,</span> <span class="n">2</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

        <span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">adults</span> <span class="o">=</span> <span class="n">flintstones</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Person</span> <span class="n">person</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">person</span><span class="o">.</span><span class="na">age</span> <span class="o">&gt;</span><span class="o">=</span> <span class="n">18</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span><span class="o">)</span><span class="o">;</span>

        <span class="n">adults</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

        <span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
        <span class="kd">public</span> <span class="n">Integer</span> <span class="n">age</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span><span class="o">}</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="o">}</span><span class="o">;</span>

        <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;: age &#34;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="流执行环境">流执行环境</h2>
<p>每个 Flink 应用都需要一个执行环境，本例中的 env。流式应用需要使用一个 StreamExecutionEnvironment。</p>
<p>在你的应用程序中进行的 DataStream API 调用建立了一个作业图(job graph)，这个作业图被附加到 StreamExecutionEnvironment 上。当调用 env.execute() 时，这个图会被打包并发送给 JobManager，JobManager 将作业并行化，并将它的片断分配给 Task Manager 执行。你的作业的每个并行片断将在一个任务槽(task slot)中执行。</p>
<p>注意，如果你不调用 execute()，你的应用程序将不会被运行。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/distributed-runtime.svg" alt="img"></p>
<p>这种分布式运行时取决于你的应用程序是可序列化的。它还要求所有的依赖关系都能在集群中的每个节点上使用。</p>
<h3 id="基本的流源">基本的流源</h3>
<p>上面的例子使用 <code>env.fromElements(...)</code> 构造了一个 <code>DataStream[Person]</code>。这是一种方便的方法，可以将一个简单的流组合起来，用于原型或测试。StreamExecutionEnvironment 上还有一个 fromCollection(Collection) 方法。所以，你可以用这个方法来代替。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">people</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

<span class="n">people</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&#34;Fred&#34;</span><span class="o">,</span> <span class="mi">35</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="n">people</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&#34;Wilma&#34;</span><span class="o">,</span> <span class="mi">35</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="n">people</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&#34;Pebbles&#34;</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="k">val</span> <span class="n">flintstones</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromCollection</span><span class="o">(</span><span class="n">people</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>另一种方便的方法是在原型开发时将一些数据导入流中，使用 socket:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">lines</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">socketTextStream</span><span class="o">(</span><span class="s">&#34;localhost&#34;</span><span class="o">,</span> <span class="mi">9999</span><span class="o">)</span>
</code></pre></div><p>或从文件中读取:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">lines</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">readTextFile</span><span class="o">(</span><span class="s">&#34;file:///path&#34;</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>在实际应用中，最常用的数据源是那些支持低延迟、高吞吐量并行读取并结合倒带和重放的数据源&ndash;这是高性能和容错的先决条件&ndash;如 Apache Kafka、Kinesis 和各种文件系统。REST API 和数据库也经常被用于流的丰富。</p>
<h3 id="基本的流式接收器">基本的流式接收器</h3>
<p>上面的例子使用 <code>adults.print()</code> 将其结果打印到 task manager 的日志中（当在 IDE 中运行时，它将出现在你的 IDE 的控制台中）。这将在流的每个元素上调用 <code>toString()</code>。</p>
<p>输出结果看起来像这样：</p>
<pre><code>1&gt; Fred: age 35
2&gt; Wilma: age 35
</code></pre><p>其中 <code>1&gt;</code> 和 <code>2&gt;</code> 表示哪个子任务（即线程）产生的输出。</p>
<p>在生产中，常用的接收器括 StreamingFileSink、各种数据库和一些 pub-sub 系统。</p>
<h2 id="调试">调试</h2>
<p>在生产中，你的应用程序将在远程集群或一组容器中运行。而如果它失败了，它将会远程失败。JobManager 和 TaskManager 日志对调试此类故障非常有帮助，但在 IDE 内部进行本地调试要容易得多，Flink 支持这一点。你可以设置断点，检查本地变量，并逐步检查你的代码。你也可以步入 Flink 的代码，如果你好奇 Flink 是如何工作的，这可以是一个很好的方式来了解它的内部结构。</p>
<h2 id="实践">实践</h2>
<p>在这一点上，你知道了足够的知识，可以开始编码和运行一个简单的 DataStream 应用程序。克隆 <a href="https://github.com/apache/flink-training/tree/release-1.11">flink-training</a> repo，按照 README 中的说明操作后，进行第一个练习。<a href="https://github.com/apache/flink-training/tree/release-1.11/ride-cleansing">过滤一个流（Ride Cleansing）</a>。</p>
<h2 id="进一步阅读">进一步阅读</h2>
<ul>
<li><a href="https://flink.apache.org/news/2020/04/15/flink-serialization-tuning-vol-1.html">Flink序列化调优第一卷：选择你的序列化器&ndash;如果你可以的话</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/datastream_api.html#anatomy-of-a-flink-program">Flink 程序的解剖</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/datastream_api.html#data-sources">数据源</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/datastream_api.html#data-sinks">数据接收器</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/connectors/">DataStream 连接器</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/training" term="training" label="Training" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[事件驱动型应用程序]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-19-event-driven-applications/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="related" type="text/html" title="DataStream API 介绍" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-learn-flink-hands-on-training/?utm_source=atom_feed" rel="related" type="text/html" title="学习 Flink: 实践培训" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-data-pipelines-and-etl/?utm_source=atom_feed" rel="related" type="text/html" title="数据管道和 ETL" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics/?utm_source=atom_feed" rel="related" type="text/html" title="流分析" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-fault-tolerance/?utm_source=atom_feed" rel="related" type="text/html" title="通过状态快照进行容错" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-19-event-driven-applications/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-19T00:00:00+08:00</published>
            <updated>2020-08-19T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Event-driven Applications</blockquote><h2 id="process-functions">Process Functions</h2>
<h3 id="介绍">介绍</h3>
<p>ProcessFunction 将事件处理与定时器和状态结合起来，使其成为流处理应用的强大构件。这是用 Flink 创建事件驱动应用的基础。它与 RichFlatMapFunction 非常相似，但增加了定时器。</p>
<h3 id="实例">实例</h3>
<p>如果你做过<a href="https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics">流分析</a>培训中的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/streaming_analytics.html#hands-on">实战练习</a>，你会记得它使用 TumblingEventTimeWindow 来计算每个司机在每个小时内的小费之和，就像这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// compute the sum of the tips per hour for each driver
</span><span class="c1"></span><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">hourlyTips</span> <span class="o">=</span> <span class="n">fares</span>
        <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="o">(</span><span class="n">TaxiFare</span> <span class="n">fare</span><span class="o">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">fare</span><span class="o">.</span><span class="na">driverId</span><span class="o">)</span>
        <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingEventTimeWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">hours</span><span class="o">(</span><span class="n">1</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="k">new</span> <span class="n">AddTips</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>用 KeyedProcessFunction 做同样的事情是相当直接的，也是很有教育意义的。让我们先把上面的代码替换成这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// compute the sum of the tips per hour for each driver
</span><span class="c1"></span><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">hourlyTips</span> <span class="o">=</span> <span class="n">fares</span>
        <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="o">(</span><span class="n">TaxiFare</span> <span class="n">fare</span><span class="o">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">fare</span><span class="o">.</span><span class="na">driverId</span><span class="o">)</span>
        <span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="k">new</span> <span class="n">PseudoWindow</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">hours</span><span class="o">(</span><span class="n">1</span><span class="o">)</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>在这段代码中，一个名为 PseudoWindow 的 KeyedProcessFunction 被应用于一个 keyed 流，其结果是一个 <code>DataStream&lt;Tuple3&lt;Long，Long，Float&gt;&gt;</code>（就是使用 Flink 内置时间窗口的实现所产生的那种流）。</p>
<p>PseudoWindow 的整体轮廓是这样的形状:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// Compute the sum of the tips for each driver in hour-long windows.
</span><span class="c1"></span><span class="c1">// The keys are driverIds.
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">PseudoWindow</span> <span class="kd">extends</span> 
        <span class="n">KeyedProcessFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">TaxiFare</span><span class="o">,</span> <span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">durationMsec</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">PseudoWindow</span><span class="o">(</span><span class="n">Time</span> <span class="n">duration</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">durationMsec</span> <span class="o">=</span> <span class="n">duration</span><span class="o">.</span><span class="na">toMilliseconds</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="c1">// Called once during initialization.
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">open</span><span class="o">(</span><span class="n">Configuration</span> <span class="n">conf</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="c1">// Called as each fare arrives to be processed.
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span>
            <span class="n">TaxiFare</span> <span class="n">fare</span><span class="o">,</span>
            <span class="n">Context</span> <span class="n">ctx</span><span class="o">,</span>
            <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

        <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="c1">// Called when the current watermark indicates that a window is now complete.
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onTimer</span><span class="o">(</span><span class="kt">long</span> <span class="n">timestamp</span><span class="o">,</span> 
            <span class="n">OnTimerContext</span> <span class="n">context</span><span class="o">,</span> 
            <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

        <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>需要注意的事情。</p>
<ul>
<li>
<p>ProcessFunctions 有好几种类型&ndash;这是一个 KeyedProcessFunctions，但还有 CoProcessFunctions、BroadcastProcessFunctions 等。</p>
</li>
<li>
<p>KeyedProcessFunction 是 RichFunction的一种。作为一个 RichFunction，它可以访问在管理 keyed state 下工作所需的 <code>open</code> 和 <code>getRuntimeContext</code> 方法。</p>
</li>
<li>
<p>有两个回调要实现：<code>processElement</code> 和 <code>onTimer</code>。<code>processElement</code> 在每次传入事件时被调用；<code>onTimer</code> 在定时器发射时被调用。这些定时器可以是事件时间，也可以是处理时间定时器。<code>processElement</code> 和 <code>onTimer</code> 都提供了一个上下文对象，该对象可以用来与 <code>TimerService</code> 交互（除其他外）。两个回调都还传递了一个可以用来发出结果的 Collector。</p>
</li>
</ul>
<h4 id="open-方法">open() 方法</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// Keyed, managed state, with an entry for each window, keyed by the window&#39;s end time.
</span><span class="c1"></span><span class="c1">// There is a separate MapState object for each driver.
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">transient</span> <span class="n">MapState</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span> <span class="n">sumOfTips</span><span class="o">;</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">open</span><span class="o">(</span><span class="n">Configuration</span> <span class="n">conf</span><span class="o">)</span> <span class="o">{</span>

    <span class="n">MapStateDescriptor</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span> <span class="n">sumDesc</span> <span class="o">=</span>
            <span class="k">new</span> <span class="n">MapStateDescriptor</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="s">&#34;sumOfTips&#34;</span><span class="o">,</span> <span class="n">Long</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Float</span><span class="o">.</span><span class="na">class</span><span class="o">)</span><span class="o">;</span>
    <span class="n">sumOfTips</span> <span class="o">=</span> <span class="n">getRuntimeContext</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getMapState</span><span class="o">(</span><span class="n">sumDesc</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>由于票价事件可能会不按顺序到达，所以有时需要处理一个小时的事件，然后再完成前一个小时的结果计算。事实上，如果水印延迟比窗口长度长得多，那么可能会同时打开许多窗口，而不是只有两个。本实现通过使用 <code>MapState</code> 来支持这一点，<code>MapState</code> 将每个窗口结束的时间戳映射到该窗口的提示之和。</p>
<h4 id="processelement-方法">processElement() 方法</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span>
        <span class="n">TaxiFare</span> <span class="n">fare</span><span class="o">,</span>
        <span class="n">Context</span> <span class="n">ctx</span><span class="o">,</span>
        <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

    <span class="kt">long</span> <span class="n">eventTime</span> <span class="o">=</span> <span class="n">fare</span><span class="o">.</span><span class="na">getEventTime</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="n">TimerService</span> <span class="n">timerService</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">timerService</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">eventTime</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">timerService</span><span class="o">.</span><span class="na">currentWatermark</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// This event is late; its window has already been triggered.
</span><span class="c1"></span>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// Round up eventTime to the end of the window containing this event.
</span><span class="c1"></span>        <span class="kt">long</span> <span class="n">endOfWindow</span> <span class="o">=</span> <span class="o">(</span><span class="n">eventTime</span> <span class="o">-</span> <span class="o">(</span><span class="n">eventTime</span> <span class="o">%</span> <span class="n">durationMsec</span><span class="o">)</span> <span class="o">+</span> <span class="n">durationMsec</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span><span class="o">;</span>

        <span class="c1">// Schedule a callback for when the window has been completed.
</span><span class="c1"></span>        <span class="n">timerService</span><span class="o">.</span><span class="na">registerEventTimeTimer</span><span class="o">(</span><span class="n">endOfWindow</span><span class="o">)</span><span class="o">;</span>

        <span class="c1">// Add this fare&#39;s tip to the running total for that window.
</span><span class="c1"></span>        <span class="n">Float</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">sumOfTips</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">endOfWindow</span><span class="o">)</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">.</span><span class="na">0F</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">sum</span> <span class="o">+</span><span class="o">=</span> <span class="n">fare</span><span class="o">.</span><span class="na">tip</span><span class="o">;</span>
        <span class="n">sumOfTips</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">endOfWindow</span><span class="o">,</span> <span class="n">sum</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>要考虑的事情:</p>
<ul>
<li>
<p>迟到的事件会怎样？在水印后面的事件（即迟到）会被丢弃。如果你想做一些比这更好的事情，可以考虑使用侧输出，这将在<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/event_driven.html#side-outputs">下一节</a>解释。</p>
</li>
<li>
<p>这个例子使用了一个 MapState，其中键是时间戳，并为同一个时间戳设置一个 Timer。这是一种常见的模式；它使得在定时器发射时查找相关信息变得简单而高效。</p>
</li>
</ul>
<h4 id="ontimer-方法">onTimer() 方法</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">onTimer</span><span class="o">(</span>
        <span class="kt">long</span> <span class="n">timestamp</span><span class="o">,</span> 
        <span class="n">OnTimerContext</span> <span class="n">context</span><span class="o">,</span> 
        <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

    <span class="kt">long</span> <span class="n">driverId</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getCurrentKey</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="c1">// Look up the result for the hour that just ended.
</span><span class="c1"></span>    <span class="n">Float</span> <span class="n">sumOfTips</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">sumOfTips</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">timestamp</span><span class="o">)</span><span class="o">;</span>

    <span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Tuple3</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">driverId</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">,</span> <span class="n">sumOfTips</span><span class="o">)</span><span class="o">;</span>
    <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">result</span><span class="o">)</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">sumOfTips</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">timestamp</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>观察:</p>
<ul>
<li>
<p>传递给 onTimer 的 OnTimerContext 上下文可以用来确定当前的键。</p>
</li>
<li>
<p>我们的伪窗口是在当前水印到达每个小时结束时被触发的，此时调用 onTimer。这个 onTimer 方法从 sumOfTips 中删除了相关的条目，这样做的效果是无法容纳迟到的事件。这相当于在使用 Flink 的时间窗口时，将 allowLateness 设置为零。</p>
</li>
</ul>
<h3 id="性能方面的考虑">性能方面的考虑</h3>
<p>Flink 提供了针对 RocksDB 优化的 MapState 和 ListState 类型。在可能的情况下，应该使用这些类型来代替持有某种集合的 ValueState 对象。RocksDB 状态后端可以追加到 ListState，而不需要经过(去)序列化，对于 MapState，每个键/值对都是一个单独的 RocksDB 对象，因此 MapState 可以有效地被访问和更新。</p>
<h2 id="侧输出">侧输出</h2>
<h3 id="介绍-1">介绍</h3>
<p>有几个很好的理由可以让 Flink operator 有一个以上的输出流，比如报告:</p>
<ul>
<li>异常</li>
<li>畸形事件</li>
<li>迟到事件</li>
<li>操作警报，如与外部服务的连接超时。</li>
</ul>
<p>侧输出是一种方便的方式。除了错误报告，侧输出也是实现流的多路分割的好方法。</p>
<h3 id="例子">例子</h3>
<p>现在，您可以对上一节中被忽略的迟到事件做些什么了。</p>
<p>一个侧输出通道与一个 <code>OutputTag&lt;T&gt;</code> 相关联。这些标签具有与侧输出的 DataStream 的类型相对应的通用类型，它们有名称。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">OutputTag</span><span class="o">&lt;</span><span class="n">TaxiFare</span><span class="o">&gt;</span> <span class="n">lateFares</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OutputTag</span><span class="o">&lt;</span><span class="n">TaxiFare</span><span class="o">&gt;</span><span class="o">(</span><span class="s">&#34;lateFares&#34;</span><span class="o">)</span> <span class="o">{</span><span class="o">}</span><span class="o">;</span>
</code></pre></div><p>上面展示的是一个静态的 <code>OutputTag&lt;TaxiFare&gt;</code>，它既可以在 PseudoWindow 的 processElement 方法中发出迟到事件时被引用。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">(</span><span class="n">eventTime</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">timerService</span><span class="o">.</span><span class="na">currentWatermark</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// This event is late; its window has already been triggered.
</span><span class="c1"></span>    <span class="n">ctx</span><span class="o">.</span><span class="na">output</span><span class="o">(</span><span class="n">lateFares</span><span class="o">,</span> <span class="n">fare</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
<span class="o">}</span>
</code></pre></div><p>并在访问这一侧输出的流时，在作业的 <code>main</code> 方法中输出:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// compute the sum of the tips per hour for each driver
</span><span class="c1"></span><span class="n">SingleOutputStreamOperator</span> <span class="n">hourlyTips</span> <span class="o">=</span> <span class="n">fares</span>
        <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="o">(</span><span class="n">TaxiFare</span> <span class="n">fare</span><span class="o">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">fare</span><span class="o">.</span><span class="na">driverId</span><span class="o">)</span>
        <span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="k">new</span> <span class="n">PseudoWindow</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">hours</span><span class="o">(</span><span class="n">1</span><span class="o">)</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="n">hourlyTips</span><span class="o">.</span><span class="na">getSideOutput</span><span class="o">(</span><span class="n">lateFares</span><span class="o">)</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>或者，您可以使用两个具有相同名称的 OutputTags 来引用同一侧面输出，但如果您这样做，它们必须具有相同的类型。</p>
<h2 id="结束语">结束语</h2>
<p>在这个例子中，你已经看到了如何使用 ProcessFunction 来重新实现一个直接的时间窗口。当然，如果 Flink 内置的窗口 API 满足你的需求，无论如何，请继续使用它。但如果你发现自己在考虑用 Flink 的窗口做一些变形，不要害怕推出自己的窗口。</p>
<p>此外，ProcessFunction 对于计算分析之外的许多其他用例也很有用。下面的实践练习提供了一个完全不同的例子。</p>
<p>ProcessFunction 的另一个常见用例是用于过期的陈旧状态。如果你回想一下 <a href="https://github.com/apache/flink-training/tree/release-1.11/rides-and-fares">Rides 和 Fares 练习</a>，其中使用 RichCoFlatMapFunction 来计算一个简单的连接，示例解决方案假设 TaxiRides 和 TaxiFares 是完美匹配的，每个 rideId 是一对一的。如果一个事件丢失了，同一乘车 ID 的其他事件将永远保持在状态。这可以替换为一个 KeyedCoProcessFunction 来实现，并且可以使用一个定时器来检测和清除任何陈旧的状态。</p>
<h2 id="实践">实践</h2>
<p>与本节配套的实战练习是 <a href="https://github.com/apache/flink-training/tree/release-1.11/long-ride-alerts">Long Ride Alerts 练习</a>。</p>
<h2 id="进一步阅读">进一步阅读</h2>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/process_function.html">ProcessFunction</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/side_output.html">侧输出</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/training" term="training" label="Training" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[学习 Flink: 实践培训]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-19-learn-flink-hands-on-training/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="related" type="text/html" title="DataStream API 介绍" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-event-driven-applications/?utm_source=atom_feed" rel="related" type="text/html" title="事件驱动型应用程序" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-data-pipelines-and-etl/?utm_source=atom_feed" rel="related" type="text/html" title="数据管道和 ETL" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics/?utm_source=atom_feed" rel="related" type="text/html" title="流分析" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-fault-tolerance/?utm_source=atom_feed" rel="related" type="text/html" title="通过状态快照进行容错" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-19-learn-flink-hands-on-training/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-19T00:00:00+08:00</published>
            <updated>2020-08-19T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Learn Flink: Hands-on Training</blockquote><h2 id="本次培训的目标和范围">本次培训的目标和范围</h2>
<p>本培训介绍了 Apache Flink，包括足够的内容让你开始编写可扩展的流式 ETL，分析和事件驱动的应用程序，同时省略了很多（最终重要的）细节。本书的重点是为 Flink 管理状态和时间的 API 提供直接的介绍，希望在掌握了这些基础知识后，你能更好地从更详细的参考文档中获取其余需要了解的内容。每一节末尾的链接将引导你到可以学习更多知识的地方。</p>
<p>具体来说，您将学习:</p>
<ul>
<li>如何实现流数据处理管道</li>
<li>Flink 如何以及为何管理状态</li>
<li>如何使用事件时间来持续计算准确的分析结果？</li>
<li>如何在连续流上构建事件驱动的应用程序？</li>
<li>Flink 是如何提供具有精确只读语义的容错、有状态的流处理的？</li>
</ul>
<p>本培训主要介绍四个关键概念：流数据的连续处理、事件时间、有状态的流处理和状态快照。本页介绍了这些概念。</p>
<p>注: 伴随本培训的是一套实践练习，它将指导您学习如何使用所介绍的概念。每一节的最后都提供了相关练习的链接。</p>
<h2 id="流处理">流处理</h2>
<p>流是数据的天然栖息地。无论是来自网络服务器的事件，还是来自股票交易所的交易，或者是来自工厂车间机器的传感器读数，数据都是作为流的一部分被创建的。但当你分析数据时，你可以围绕有界流或无界流组织处理，而你选择哪种范式会产生深远的影响。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/bounded-unbounded.png" alt="img"></p>
<p>当你处理一个有边界的数据流时，<strong>批处理</strong>是工作的范式。在这种操作模式下，你可以选择在产生任何结果之前摄取整个数据集，这意味着，例如，可以对数据进行排序，计算全局统计，或产生一个汇总所有输入的最终报告。</p>
<p>另一方面，<strong>流处理</strong>涉及无边界的数据流。至少在概念上，输入可能永远不会结束，因此你不得不在数据到达时持续处理数据。</p>
<p>在 Flink 中，应用程序由<strong>流式数据流</strong>组成，这些数据流可以通过用户定义的<strong>运算符</strong>进行转换。这些数据流形成有向图，从一个或多个源开始，到一个或多个 sink 结束。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/program_dataflow.svg" alt="img"></p>
<p>通常，程序中的变换(transformation)和数据流(dataflow)中的运算符(operator)之间存在一对一的对应关系。但有时，一个变换可能由多个运算符(operator)组成。</p>
<p>一个应用程序可能会消耗来自流式源的实时数据，如消息队列或分布式日志，如 Apache Kafka 或 Kinesis。但 Flink 也可以消耗来自各种数据源的有界历史数据。同样，Flink 应用正在产生的结果流也可以被发送到各种各样的系统，这些系统可以作为 sink 连接。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/flink-application-sources-sinks.png" alt="img"></p>
<h3 id="并行数据流">并行数据流</h3>
<p>Flink 中的程序本质上是并行和分布式的。在执行过程中，一个流有一个或多个流分区(<strong>stream partitions</strong>)，每个运算符(operator)有一个或多个运算符子任务(<strong>operator subtasks</strong>)。运算符子任务(<strong>operator subtasks</strong>)相互独立，在不同的线程中执行，也可能在不同的机器或容器上执行。</p>
<p>运算符符子任务(<strong>operator subtasks</strong>)的数量就是该特定运算符(operator)的并行度(<strong>parallelism</strong>)。同一程序的不同运算符可能具有不同的并行度水平。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/parallel_dataflow.svg" alt="img"></p>
<p>流可以在两个运算符之间以一对一（或转发）的模式或以重分发的模式传输数据。</p>
<ul>
<li>
<p>一对一的流（例如上图中 Source 和 map() 运算符之间）保留了元素的分区和排序。这意味着 map() 运算符的 subtask[1] 将看到与 Source 运算符的 subtask[1] 所产生的元素顺序相同的元素。</p>
</li>
<li>
<p>重新分发流（如上面 map() 和 keyBy/window 之间，以及 keyBy/window 和 Sink 之间）会改变流的分区。每个运算符子任务(operator subtask)都会根据所选的转换将数据发送到不同的目标子任务。例如 keyBy()（通过散列键来重新分区）、broadcast() 或 rebalance()（随机重新分区）。在重分发交换中，元素之间的排序只在每一对发送和接收子任务中被保留（例如，map() 的 subtask[1] 和 keyBy/window 的 subtask[2]）。因此，例如，上面显示的 keyBy/window 和 Sink 运算符之间的重新分发，引入了关于不同键的聚合结果到达 Sink 的顺序的非确定性。</p>
</li>
</ul>
<h2 id="及时的流处理">及时的流处理</h2>
<p>对于大多数流式应用来说，能够用处理实时数据的相同代码重新处理历史数据是非常有价值的&ndash;无论如何，都能产生确定性的、一致的结果。</p>
<p>此外，关注事件发生的顺序，而不是事件交付处理的顺序，并且能够推理出一组事件何时（或应该）完成也是至关重要的。例如，考虑电子商务交易，或金融贸易中涉及的一系列事件。</p>
<p>通过使用记录在数据流中的事件时间戳，而不是使用处理数据的机器的时钟，可以满足这些及时流处理的要求。</p>
<h2 id="有状态的流处理">有状态的流处理</h2>
<p>Flink 的操作可以是有状态的。这意味着一个事件的处理方式可以取决于之前所有事件的累积效果。状态可以用于一些简单的事情，例如计算每分钟的事件以显示在仪表板上，或者用于一些更复杂的事情，例如计算欺诈检测模型的功能。</p>
<p>一个 Flink 应用是在分布式集群上并行运行的。一个给定的运算符的各种并行实例将以不同的线程独立执行，一般来说，它们将在不同的机器上运行。</p>
<p>一个有状态运算符的并行实例集实际上是一个分片的键值存储。每一个并行实例负责处理一组特定键的事件，这些键的状态被保存在本地。</p>
<p>下图显示了一个作业(Job)，在作业图(job graph)中的前三个运算符上运行的并行度为2，终止于一个并行度为 1 的 sink。第三个运算符是有状态的，你可以看到在第二个和第三个运算符之间发生了一个完全连接的网络洗牌。这是在通过一些键来对流进行分区，这样所有需要一起处理的事件，都会被一起处理。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/parallel-job.png" alt="img"></p>
<p>状态总是在本地访问，这有助于 Flink 应用实现高吞吐量和低延迟。你可以选择将状态保存在 JVM 堆上，如果状态太大，也可以将其保存在有效组织的磁盘数据结构中。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/local-state.png" alt="img"></p>
<h2 id="通过状态快照进行容错">通过状态快照进行容错</h2>
<p>Flink 能够通过状态快照和流重放的组合，提供容错、精确的一次性语义。这些快照捕获了分布式管道的整个状态，记录了进入输入队列的偏移以及整个作业图(job graph)中因摄取了该点数据而产生的状态。当发生故障时，源会被重放，状态被恢复，并恢复处理。如上所述，这些状态快照是异步捕获的，不会妨碍正在进行的处理。</p>
<p>原文链接: <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/">https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/training" term="training" label="Training" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[数据管道和 ETL]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-19-data-pipelines-and-etl/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="related" type="text/html" title="DataStream API 介绍" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-event-driven-applications/?utm_source=atom_feed" rel="related" type="text/html" title="事件驱动型应用程序" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-learn-flink-hands-on-training/?utm_source=atom_feed" rel="related" type="text/html" title="学习 Flink: 实践培训" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics/?utm_source=atom_feed" rel="related" type="text/html" title="流分析" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-fault-tolerance/?utm_source=atom_feed" rel="related" type="text/html" title="通过状态快照进行容错" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-19-data-pipelines-and-etl/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-19T00:00:00+08:00</published>
            <updated>2020-08-19T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Data Pipelines &amp; ETL</blockquote><p>对于 Apache Flink 来说，一个非常常见的用例是实现 ETL（提取、转换、加载）管道，从一个或多个源中获取数据，进行一些转换和/或丰富，然后将结果存储在某个地方。在这一节中，我们将看看如何使用 Flink 的 DataStream API 来实现这种应用。</p>
<p>请注意，Flink的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/">Table 和 SQL API</a>很适合许多 ETL 用例。但无论你最终是否直接使用 DataStream API，对这里介绍的基础知识有一个扎实的理解都是有价值的。</p>
<h2 id="无状态转换">无状态转换</h2>
<p>本节介绍了 map() 和 flatmap()，它们是用来实现无状态转换的基本操作。本节中的例子假设你熟悉 <a href="https://github.com/apache/flink-training/tree/release-1.11">flink-training</a> 仓库中的实战练习中使用的出租车乘车数据。</p>
<h3 id="map">map()</h3>
<p>在第一个练习中，你过滤了一个打车事件的流，在同一个代码库中，有一个 GeoUtils 类，它提供了一个静态方法 GeoUtils.mapToGridCell(float lon, float lat)，该方法将一个 location (longitude, latitude) 映射到一个网格单元，该单元指的是一个大约100x100米大小的区域。</p>
<p>现在让我们通过为每个事件添加 startCell 和 endCell 字段来丰富我们的打车对象流。你可以创建一个 EnrichedRide 对象，扩展 TaxiRide，添加这些字段。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">EnrichedRide</span> <span class="kd">extends</span> <span class="n">TaxiRide</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">startCell</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">endCell</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">EnrichedRide</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span><span class="o">}</span>

    <span class="kd">public</span> <span class="nf">EnrichedRide</span><span class="o">(</span><span class="n">TaxiRide</span> <span class="n">ride</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">rideId</span> <span class="o">=</span> <span class="n">ride</span><span class="o">.</span><span class="na">rideId</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">isStart</span> <span class="o">=</span> <span class="n">ride</span><span class="o">.</span><span class="na">isStart</span><span class="o">;</span>
        <span class="o">.</span><span class="o">.</span><span class="o">.</span>
        <span class="k">this</span><span class="o">.</span><span class="na">startCell</span> <span class="o">=</span> <span class="n">GeoUtils</span><span class="o">.</span><span class="na">mapToGridCell</span><span class="o">(</span><span class="n">ride</span><span class="o">.</span><span class="na">startLon</span><span class="o">,</span> <span class="n">ride</span><span class="o">.</span><span class="na">startLat</span><span class="o">)</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">endCell</span> <span class="o">=</span> <span class="n">GeoUtils</span><span class="o">.</span><span class="na">mapToGridCell</span><span class="o">(</span><span class="n">ride</span><span class="o">.</span><span class="na">endLon</span><span class="o">,</span> <span class="n">ride</span><span class="o">.</span><span class="na">endLat</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;,&#34;</span> <span class="o">+</span>
            <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">startCell</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;,&#34;</span> <span class="o">+</span>
            <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">endCell</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>然后，您可以创建一个应用程序，将流转化为:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">rides</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">TaxiRide</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">addSource</span><span class="o">(</span><span class="k">new</span> <span class="nc">TaxiRideSource</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="k">val</span> <span class="n">enrichedNYCRides</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">EnrichedRide</span><span class="o">]</span>  <span class="k">=</span> <span class="n">rides</span>
    <span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">new</span> <span class="nc">RideCleansingSolution</span><span class="o">.</span><span class="nc">NYCFilter</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">new</span> <span class="nc">Enrichment</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="n">enrichedNYCRides</span><span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>使用这个 MapFunction:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Enrichment</span> <span class="k">extends</span> <span class="nc">MapFunction</span><span class="o">[</span><span class="kt">TaxiRide</span>, <span class="kt">EnrichedRide</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">taxiRide</span><span class="k">:</span> <span class="kt">TaxiRide</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">EnrichedRide</span><span class="o">(</span><span class="n">taxiRide</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="flatmap">flatmap()</h3>
<p><code>MapFunction</code> 只适用于执行一对一的转换：对于每一个进入的流元素，<code>map()</code> 将发出一个转换后的元素。否则，你将需要使用 <code>flatmap()</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">rides</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">TaxiRide</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">addSource</span><span class="o">(</span><span class="k">new</span> <span class="nc">TaxiRideSource</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="k">val</span> <span class="n">enrichedNYCRides</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">EnrichedRide</span><span class="o">]</span> <span class="k">=</span> <span class="n">rides</span>
    <span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="nc">NYCEnrichment</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="n">enrichedNYCRides</span><span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>加上一个 <code>FlatMapFunction</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">NYCEnrichment</span> <span class="k">extends</span> <span class="nc">FlatMapFunction</span><span class="o">[</span><span class="kt">TaxiRide</span>, <span class="kt">EnrichedRide</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">flatMap</span><span class="o">(</span><span class="n">taxiRide</span><span class="k">:</span> <span class="kt">TaxiRide</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[</span><span class="kt">EnrichedRide</span><span class="o">]</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">valid</span><span class="k">:</span> <span class="kt">FilterFunction</span><span class="o">[</span><span class="kt">TaxiRide</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">RideCleansing</span><span class="o">.</span><span class="nc">NYCFilter</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">valid</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">taxiRide</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">out</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="k">new</span> <span class="nc">EnrichedRide</span><span class="o">(</span><span class="n">taxiRide</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>通过这个接口提供的 Collector，<code>flatmap()</code> 方法可以随心所欲地发射许多流元素，包括完全不发射元素。</p>
<h2 id="keyed-streams">Keyed Streams</h2>
<h3 id="keyby">keyBy()</h3>
<p>通常，能够围绕一个属性对一个流进行分区是非常有用的，这样所有具有相同属性值的事件就会被归为一组。例如，假设你想找到从每个网格单元开始的最长的出租车乘车时间。从 SQL 查询的角度考虑，这意味着要对 startCell 进行某种 GROUP BY，而在 Flink 中，这是用 <code>keyBy(KeySelector)</code> 来完成的。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">rides</span>
    <span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="nc">NYCEnrichment</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="s">&#34;startCell&#34;</span><span class="o">)</span>
</code></pre></div><p>每一个 <code>keyBy</code> 都会引起一次网络洗牌，对流进行重新分区。一般来说，这是很昂贵的，因为它涉及到网络通信以及序列化和反序列化。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/keyBy.png" alt="img"></p>
<p>在上面的例子中，键是由一个字段名 &ldquo;startCell&rdquo; 指定的。这种键选择的风格有一个缺点，那就是编译器无法推断用于键选择的字段的类型，因此 Flink 会将键值作为元组传递，这可能会很笨拙。最好是使用一个正确类型的 <code>KeySelector</code>，例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">rides</span>
    <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">NYCEnrichment</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span>
        <span class="k">new</span> <span class="n">KeySelector</span><span class="o">&lt;</span><span class="n">EnrichedRide</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getKey</span><span class="o">(</span><span class="n">EnrichedRide</span> <span class="n">enrichedRide</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">enrichedRide</span><span class="o">.</span><span class="na">startCell</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span><span class="o">)</span>
</code></pre></div><p>可以用 lambda 更简洁地表达出来。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">rides</span>
    <span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="nc">NYCEnrichment</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="n">enrichedRide</span> <span class="o">-&gt;</span> <span class="n">enrichedRide</span><span class="o">.</span><span class="n">startCell</span><span class="o">)</span>
</code></pre></div><h3 id="keys-are-computed">Keys are computed</h3>
<p>KeySelectors 并不局限于从你的事件中提取一个键，相反，它们可以用任何你想要的方式来计算键，只要产生的键是确定性的，并且有有效的 <code>hashCode()</code> 和 <code>equals()</code> 的实现。这个限制排除了生成随机数，或者返回数组或枚举的 KeySelectors，但是你可以使用元组或 POJOs 来生成复合键，例如，只要它们的元素遵循这些相同的规则。</p>
<p>键必须以确定性的方式产生，因为每当需要它们时，它们就会被重新计算，而不是附加到流记录上。</p>
<p>例如，我们不是创建一个新的 <code>EnrichedRide</code> 类，该类有一个 <code>startCell</code> 字段，然后我们将其用作键:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">keyBy</span><span class="o">(</span><span class="n">enrichedRide</span> <span class="o">-&gt;</span> <span class="n">enrichedRide</span><span class="o">.</span><span class="n">startCell</span><span class="o">)</span>
</code></pre></div><p>相反, 我们可以这样做:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">keyBy</span><span class="o">(</span><span class="n">ride</span> <span class="o">-&gt;</span> <span class="nc">GeoUtils</span><span class="o">.</span><span class="n">mapToGridCell</span><span class="o">(</span><span class="n">ride</span><span class="o">.</span><span class="n">startLon</span><span class="o">,</span> <span class="n">ride</span><span class="o">.</span><span class="n">startLat</span><span class="o">)</span><span class="o">)</span>
</code></pre></div><h3 id="keyed-流的聚合">Keyed 流的聚合</h3>
<p>这段代码为每个 end-of-ride 事件创建一个新的元组流，其中包含 <code>startCell</code> 和持续时间（分钟）。</p>
<pre><code>import org.joda.time.Interval;

DataStream&lt;Tuple2&lt;Integer, Minutes&gt;&gt; minutesByStartCell = enrichedNYCRides
    .flatMap(new FlatMapFunction&lt;EnrichedRide, Tuple2&lt;Integer, Minutes&gt;&gt;() {

        @Override
        public void flatMap(EnrichedRide ride,
                            Collector&lt;Tuple2&lt;Integer, Minutes&gt;&gt; out) throws Exception {
            if (!ride.isStart) {
                Interval rideInterval = new Interval(ride.startTime, ride.endTime);
                Minutes duration = rideInterval.toDuration().toStandardMinutes();
                out.collect(new Tuple2&lt;&gt;(ride.startCell, duration));
            }
        }
    });
</code></pre><p>现在可以产生一个流，其中只包含那些对每个 <code>startCell</code> 来说是有史以来（至此）最长的乘车记录。</p>
<p>有多种方式可以表达作为键的字段。之前你看到了一个 EnrichedRide POJO 的例子，在这个例子中，要用作键的字段是用它的名字指定的。这个例子涉及到 Tuple2 对象，元组中的索引（从0开始）被用来指定键。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">minutesByStartCell</span>
  <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="c1">// startCell
</span><span class="c1"></span>  <span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// duration
</span><span class="c1"></span>  <span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>现在，每当持续时间达到一个新的最大值时，输出流就会包含一个针对每个键的记录&ndash;如这里的50797单元格所示。</p>
<pre><code>...
4&gt; (64549,5M)
4&gt; (46298,18M)
1&gt; (51549,14M)
1&gt; (53043,13M)
1&gt; (56031,22M)
1&gt; (50797,6M)
...
1&gt; (50797,8M)
...
1&gt; (50797,11M)
...
1&gt; (50797,12M)
</code></pre><h3 id="implicit-state">(Implicit) State</h3>
<p>这是本次训练中第一个涉及有状态流的例子。虽然状态被透明地处理，但 Flink 必须跟踪每个不同键的最大持续时间。</p>
<p>每当状态涉及到你的应用时，你应该考虑状态可能会变得多大。每当键空间是无限制的，那么 Flink 需要的状态量也是无限制的。</p>
<p>当处理流时，一般来说，在有限的窗口上考虑聚合比在整个流上考虑更有意义。</p>
<h3 id="reduce-和其他聚合器">reduce() 和其他聚合器</h3>
<p>上文中使用的 <code>maxBy()</code> 只是 Flink 的 KeyedStreams 上众多聚合函数中的一个例子。还有一个更通用的 <code>reduce()</code> 函数，你可以用它来实现自己的自定义聚合。</p>
<h2 id="状态转换">状态转换</h2>
<h3 id="为什么-flink-要参与管理状态">为什么 Flink 要参与管理状态？</h3>
<p>你的应用程序当然能够在没有让 Flink 参与管理状态的情况下使用状态&ndash;但 Flink 为它所管理的状态提供了一些引人注目的功能。</p>
<ul>
<li>本地化。Flink 状态被保存在处理它的机器的本地，并且可以以内存速度被访问。</li>
<li>耐用。Flink 状态是容错的，即每隔一段时间就会自动检查一次，一旦失败就会恢复。</li>
<li>纵向可扩展。Flink 状态可以保存在嵌入式 RocksDB 实例中，通过增加更多的本地磁盘来扩展。</li>
<li>横向可扩展。随着集群的增长和收缩，Flink 状态会被重新分配。</li>
<li>可查询。Flink 状态可以通过<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/queryable_state.html">可查询状态 API</a> 进行外部查询。</li>
</ul>
<p>在本节中，您将学习如何使用 Flink 的 API 管理 keyed 状态。</p>
<h3 id="rich-函数">Rich 函数</h3>
<p>此时你已经看到了 Flink 的几个函数接口，包括 <code>FilterFunction</code>、<code>MapFunction</code> 和 <code>FlatMapFunction</code>。这些都是单一抽象方法模式的例子。</p>
<p>对于每一个接口，Flink 还提供了一个所谓的&quot;富&quot;变体，例如，<code>RichFlatMapFunction</code>，它有一些额外的方法，包括:</p>
<ul>
<li>open(Configuration c)</li>
<li>close()</li>
<li>getRuntimeContext()</li>
</ul>
<p><code>open()</code> 在操作符初始化期间被调用一次。这是一个加载一些静态数据的机会，或者, 例如打开一个外部服务的连接。</p>
<p><code>getRuntimeContext()</code> 提供了对一整套潜在的有趣的东西的访问，但最值得注意的是它是如何创建和访问由 Flink 管理的状态。</p>
<h3 id="一个带有-keyed-state-的例子">一个带有 Keyed State 的例子</h3>
<p>在这个例子中，想象一下，你有一个事件流，你想去掉重复，所以你只保留每个键的第一个事件。这里有一个应用程序可以做到这一点，使用一个名为 <code>Deduplicator</code> 的 <code>RichFlatMapFunction</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Event</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">key</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="o">;</span>
    <span class="o">.</span><span class="o">.</span><span class="o">.</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
  
    <span class="n">env</span><span class="o">.</span><span class="na">addSource</span><span class="o">(</span><span class="k">new</span> <span class="n">EventSource</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="n">e</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span>
        <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">Deduplicator</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
  
    <span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>为了达到这个目的，Deduplicator 将需要以某种方式记住，对于每个键来说，是否已经有了该键的事件。它将使用 Flink 的 <em>keyed state</em> 接口来做到这一点。</p>
<p>当你在使用像这样的 <em>keyed</em> 流时，Flink 将为每个被管理的状态项目维护一个键/值存储。</p>
<p>Flink 支持几种不同类型的 <em>keyed state</em>，本例使用的是最简单的一种，即 <code>ValueState</code>。这意味着对于每个键，Flink 将存储一个单一的对象&ndash;在本例中，一个类型为 Boolean 的对象。</p>
<p>我们的 Deduplicator 类有两个方法：<code>open()</code> 和 <code>flatMap()</code>。<code>open</code> 方法通过定义一个 ValueStateDescriptor<!-- raw HTML omitted -->` 来建立对托管状态的使用。构造函数的参数为这个 <em>keyed state</em> 项指定了一个名称（&ldquo;keyHasBeenSeen&rdquo;），并提供了可用于序列化这些对象的信息（在本例中，Types.BOOLEAN）。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Deduplicator</span> <span class="kd">extends</span> <span class="n">RichFlatMapFunction</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">,</span> <span class="n">Event</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">ValueState</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">keyHasBeenSeen</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">open</span><span class="o">(</span><span class="n">Configuration</span> <span class="n">conf</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ValueStateDescriptor</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">desc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ValueStateDescriptor</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="s">&#34;keyHasBeenSeen&#34;</span><span class="o">,</span> <span class="n">Types</span><span class="o">.</span><span class="na">BOOLEAN</span><span class="o">)</span><span class="o">;</span>
        <span class="n">keyHasBeenSeen</span> <span class="o">=</span> <span class="n">getRuntimeContext</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getState</span><span class="o">(</span><span class="n">desc</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">Event</span> <span class="n">event</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">keyHasBeenSeen</span><span class="o">.</span><span class="na">value</span><span class="o">(</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">event</span><span class="o">)</span><span class="o">;</span>
            <span class="n">keyHasBeenSeen</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>当 <code>flatMap</code> 方法调用 <code>keyHasBeenSeen.value()</code> 时，Flink 的运行时会在上下文中查找 key 的这块状态值，只有当它为 null 时，它才会去收集事件到输出。在这种情况下，它还会将 <code>keyHasBeenSeen</code> 更新为 true。</p>
<p>这种访问和更新 key-partitioned 状态的机制可能看起来相当神奇，因为在我们的 Deduplicator 的实现中，key 并不是显式可见的。当 Flink 的运行时调用我们的 <code>RichFlatMapFunction</code> 的 <code>open</code> 方法时，没有任何事件，因此那一刻上下文中没有 key。但是当它调用 <code>flatMap</code> 方法时，被处理的事件的 key 对运行时来说是可用的，并在幕后用于确定 Flink 的状态后端中的哪个条目被操作。</p>
<p>当部署到分布式集群时，会有很多这个 Deduplicator 的实例，每个实例将负责整个键空间的一个不相干子集。因此，当你看到一个 ValueState 的单项，如:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ValueState</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">keyHasBeenSeen</span><span class="o">;</span>
</code></pre></div><p>理解这不仅仅是一个单一的布尔值，而是一个分布式的、分片式的、键/值存储。</p>
<h3 id="清除状态">清除状态</h3>
<p>上面的例子有一个潜在的问题。如果键的空间是无限制的，会发生什么？Flink 是在某个地方为每一个被使用的不同键存储一个布尔的实例。如果有一个有界的键集，那么这将是很好的，但是在键集以无界的方式增长的应用中，有必要为不再需要的键清除状态。这是通过调用状态对象上的 <code>clear()</code> 来实现的，如:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">keyHasBeenSeen</span><span class="o">.</span><span class="n">clear</span><span class="o">(</span><span class="o">)</span>
</code></pre></div><p>例如，你可能想在给定键的一段时间不活动后这样做。当你在事件驱动的应用程序一节中学习 <code>ProcessFunction</code> 时，你将看到如何使用 <code>Timer</code> 来实现这一点。</p>
<p>此外，还有一个<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html#state-time-to-live-ttl">状态存活时间(TTL)</a>选项，你可以用状态描述符来配置，指定什么时候自动清除陈旧键的状态。</p>
<h3 id="non-keyed-state">Non-keyed State</h3>
<p>也可以在 non-keyed 的上下文中使用托管状态。这有时被称为 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html#operator-state">operator state</a>。所涉及的接口有些不同，由于用户定义的函数需要 non-keyed state 是不常见的，所以这里不做介绍。这个功能最常用于源和接收器(sink)的实现。</p>
<h2 id="connected-streams">Connected Streams</h2>
<p>有时不是应用这样的预定义变换:</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/transformation.svg" alt="img"></p>
<p>你希望能够动态地改变变换的某些方面&ndash;通过流的阈值，或规则，或其他参数。Flink 中支持这种模式的是一种叫做连接流(connected streams)的东西，其中一个 operator 有两个输入流，就像这样:</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/connected-streams.svg" alt="img"></p>
<p>连接流也可以用来实现流式连接(streaming joins.)。</p>
<h3 id="例子">例子</h3>
<p>在这个例子中，控制流被用来指定必须从  streamOfWords 中过滤掉的单词。一个名为 ControlFunction 的 RichCoFlatMapFunction 被应用到连接的流中来完成这个任务。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="n">DataStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">control</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span><span class="s">&#34;DROP&#34;</span><span class="o">,</span> <span class="s">&#34;IGNORE&#34;</span><span class="o">)</span><span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">)</span><span class="o">;</span>
    <span class="n">DataStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">streamOfWords</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span><span class="s">&#34;Apache&#34;</span><span class="o">,</span> <span class="s">&#34;DROP&#34;</span><span class="o">,</span> <span class="s">&#34;Flink&#34;</span><span class="o">,</span> <span class="s">&#34;IGNORE&#34;</span><span class="o">)</span><span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">)</span><span class="o">;</span>
  
    <span class="n">control</span>
        <span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="n">datastreamOfWords</span><span class="o">)</span>
        <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">ControlFunction</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>注意，被连接的两个流必须以兼容的方式进行 keyed。keyBy 的作用是对流的数据进行分区，当 keyed 流连接时，必须以同样的方式进行分区。这样就可以保证两个流中具有相同 key 的事件都会被发送到同一个实例中。那么，这就使得将该键上的两个流连接起来成为可能，例如。</p>
<p>在这种情况下，两个流的类型都是 <code>DataStream[String]</code>，并且两个流都以字符串为键。如下所示，这个 <code>RichCoFlatMapFunction</code> 在  keyed state 下存储了一个布尔值，而这个布尔值是由两个流共享的。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ControlFunction</span> <span class="kd">extends</span> <span class="n">RichCoFlatMapFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">ValueState</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">blocked</span><span class="o">;</span>
      
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">open</span><span class="o">(</span><span class="n">Configuration</span> <span class="n">config</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">blocked</span> <span class="o">=</span> <span class="n">getRuntimeContext</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getState</span><span class="o">(</span><span class="k">new</span> <span class="n">ValueStateDescriptor</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="s">&#34;blocked&#34;</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">.</span><span class="na">class</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
      
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap1</span><span class="o">(</span><span class="n">String</span> <span class="n">control_value</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">blocked</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">Boolean</span><span class="o">.</span><span class="na">TRUE</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
      
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap2</span><span class="o">(</span><span class="n">String</span> <span class="n">data_value</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">blocked</span><span class="o">.</span><span class="na">value</span><span class="o">(</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">data_value</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>RichCoFlatMapFunction 是 FlatMapFunction 的一种，它可以应用于一对连接的流，并且它可以访问富函数接口。这意味着它可以被做成有状态的。</p>
<p>屏蔽的(blocked)布尔正在被用来记住控制流上提到的键（在这里是单词），这些词被过滤出 streamOfWords 流。这就是 <em>keyed state</em>，它在两个流之间是共享的，这就是为什么两个流要共享同一个键空间。</p>
<p><code>flatMap1</code> 和 <code>flatMap2</code> 被 Flink 运行时调用，分别来自两个连接流的元素&ndash;在我们的例子中，来自控制流的元素被传入 <code>flatMap1</code>，来自 <code>streamOfWords</code> 的元素被传入 <code>flatMap2</code>。这是由使用 <code>control.connect(datastreamOfWords)</code> 连接两个流的顺序决定的。</p>
<p>重要的是要认识到，你无法控制调用 <code>flatMap1</code> 和 <code>flatMap2</code> 回调的顺序。这两个输入流在相互竞争，Flink 运行时将对来自一个流或另一个流的事件的消耗做它想做的事。在时间和/或顺序很重要的情况下，你可能会发现有必要在托管的 Flink 状态下缓冲事件，直到你的应用程序准备好处理它们。(注意：如果你真的很绝望，可以通过使用实现 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/api/java/org/apache/flink/streaming/api/operators/InputSelectable.html">InputSelectable</a> 接口的自定义 Operator 来对双输入 operator 消耗输入的顺序进行一些有限的控制。)</p>
<h2 id="实践">实践</h2>
<p>与本节配套的实践练习是<a href="https://github.com/apache/flink-training/tree/release-1.11/rides-and-fares">&ldquo;乘车与票价练习&rdquo;</a>。</p>
<h2 id="进一步阅读">进一步阅读</h2>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/#datastream-transformations">数据流转换</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html">有状态的流处理</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/training" term="training" label="Training" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[流分析]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="related" type="text/html" title="DataStream API 介绍" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-event-driven-applications/?utm_source=atom_feed" rel="related" type="text/html" title="事件驱动型应用程序" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-learn-flink-hands-on-training/?utm_source=atom_feed" rel="related" type="text/html" title="学习 Flink: 实践培训" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-data-pipelines-and-etl/?utm_source=atom_feed" rel="related" type="text/html" title="数据管道和 ETL" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-fault-tolerance/?utm_source=atom_feed" rel="related" type="text/html" title="通过状态快照进行容错" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-19T00:00:00+08:00</published>
            <updated>2020-08-19T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Streaming Analytics</blockquote><h2 id="event-time-和-watermarks">Event Time 和 Watermarks</h2>
<h3 id="介绍">介绍</h3>
<p>Flink 明确支持三种不同的时间概念。</p>
<p>事件时间：事件发生的时间，由产生（或存储）该事件的设备记录的时间</p>
<p>摄取时间：Flink 在摄取事件时记录的时间戳。</p>
<p>处理时间：您的管道中的特定 operator 处理事件的时间。</p>
<p>为了获得可重复的结果，例如，在计算某一天股票在交易的第一个小时内达到的最高价格时，您应该使用事件时间(event time)。这样一来，结果就不会依赖于计算的时间。这种实时应用有时会使用处理时间(processing time)，但这样一来，结果就会由该小时内恰好处理的事件决定，而不是由当时发生的事件决定。基于处理时间的计算分析会导致不一致，并使重新分析历史数据或测试新的实现变得困难。</p>
<h3 id="使用事件时间">使用事件时间</h3>
<p>默认情况下，Flink 将使用处理时间(processing time)。要改变这一点，您可以设置时间特性(Time Characteristic)。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span>
    <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="n">env</span><span class="o">.</span><span class="na">setStreamTimeCharacteristic</span><span class="o">(</span><span class="n">TimeCharacteristic</span><span class="o">.</span><span class="na">EventTime</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>如果你想使用事件时间，你还需要提供一个时间戳提取器和水印生成器，Flink 将使用它们来跟踪事件时间的进展。这将在下面的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/streaming_analytics.html#working-with-watermarks">&ldquo;使用水印&rdquo;</a>一节中介绍，但首先我们应该解释一下什么是水印。</p>
<h3 id="水印">水印</h3>
<p>让我们通过一个简单的例子来说明为什么需要水印，以及它们是如何工作的。</p>
<p>在这个例子中，你有一个带时间戳的事件流，这些事件的到达顺序有些混乱，如下所示。显示的数字是时间戳，表示这些事件实际发生的时间。第一个到达的事件发生在时间 4，随后是更早发生的事件，在时间 2，以此类推。</p>
<pre><code>··· 23 19 22 24 21 14 17 13 12 15 9 11 7 2 4 →
</code></pre><p>现在想象一下，你正在尝试创建一个流排序器(stream sorter)。这个应用程序的目的是处理流中的每个事件，并发出一个新的流，其中包含相同的事件，但按时间戳排序。</p>
<p>一些观察:</p>
<p>(1)你的流排序器看到的第一个元素是 4， 但你不能马上把它作为排序流的第一个元素释放出来。它可能已经不按顺序到达，而更早的事件可能还没有到达。事实上，你对这个流的未来有一些神一样的知识，你可以看到，你的流排序器至少应该等到 2 到达后再产生任何结果。</p>
<p>一些缓冲，和一些延迟，是必要的。</p>
<p>(2)如果你做错了，你可能最终会永远等待。首先，排序器看到了一个来自时间 4 的事件，然后是一个来自时间 2 的事件。一个时间戳小于 2 的事件会不会永远到达？也许会，也许不会。也许不会。你可以永远等待，永远看不到 1。</p>
<p>最终你必须鼓起勇气，发出 2 作为排序流的开始。</p>
<p>(3)那么你需要的是某种策略，它定义了对于任何给定的时间戳事件，何时停止等待早期事件的到来。</p>
<p>这正是水印的作用&ndash;它们定义了何时停止等待早期(earlier)事件。</p>
<p>Flink 中的事件时间处理依赖于水印生成器，这些水印生成器将特殊的时间戳元素插入到流中，称为水印。时间 t 的水印是一种断言，即到时间 t 为止，流现在（可能）是完整的。</p>
<p>这个流排序器应该在什么时候停止等待，并推出2开始排序流？当一个时间戳为 2，或更大的水印到达时。</p>
<p>(4)你可以想象不同的策略来决定如何生成水印。</p>
<p>每一个事件都是在一些延迟之后到达的，而这些延迟是不同的，所以一些事件的延迟比其他事件更多。一个简单的方法是假设这些延迟被某个最大延迟所约束。Flink 将这种策略称为有界无序水印。很容易想象更复杂的水印方法，但对于大多数应用来说，固定的延迟已经足够好了。</p>
<h3 id="延迟与完整性">延迟与完整性</h3>
<p>关于水印的另一种思考方式是，水印让你这个流式应用的开发者能够控制延迟和完整性之间的权衡。与批处理不同的是，在批处理中，人们可以在产生任何结果之前完全了解输入，而在流式处理中，你最终必须停止等待看到更多的输入，并产生某种结果。</p>
<p>你可以积极地配置你的水印，用一个很短的延迟，从而承担在对输入不完全了解的情况下产生结果的风险&ndash;也就是说，一个可能是错误的结果，很快就产生了。或者你可以等待更长时间，并利用对输入流更完整的知识产生结果。</p>
<p>也可以实现混合解决方案，快速生成初始结果，然后在处理额外（后期）数据时对这些结果进行更新。对于某些应用来说，这是一种很好的方法。</p>
<h3 id="延迟">延迟</h3>
<p>迟到的定义是相对于水印而言的。水印(t)声明流在时间t之前是完整的；在这个水印之后的任何事件，如果时间戳 ≤t，则为延迟。</p>
<h3 id="使用水印">使用水印</h3>
<p>为了执行基于事件时间的事件处理，Flink 需要知道与每个事件相关联的时间，还需要流包含水印。</p>
<p>实践练习中使用的 Taxi 数据源为你处理了这些细节。但在你自己的应用程序中，你必须自己处理这些事情，通常是通过实现一个类来实现，该类从事件中提取时间戳，并按需生成水印。最简单的方法是使用 WatermarkStrategy:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">WatermarkStrategy</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">strategy</span> <span class="o">=</span> <span class="n">WatermarkStrategy</span>
        <span class="o">.</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span><span class="n">forBoundedOutOfOrderness</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="n">20</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withTimestampAssigner</span><span class="o">(</span><span class="o">(</span><span class="n">event</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">event</span><span class="o">.</span><span class="na">timestamp</span><span class="o">)</span><span class="o">;</span>

<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">withTimestampsAndWatermarks</span> <span class="o">=</span>
    <span class="n">stream</span><span class="o">.</span><span class="na">assignTimestampsAndWatermarks</span><span class="o">(</span><span class="n">strategy</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><h2 id="窗口">窗口</h2>
<p>Flink 具有非常有表现力的窗口语义。</p>
<p>在本节中，你将学习</p>
<ul>
<li>如何使用窗口来计算无边界流的聚合。</li>
<li>Flink 支持哪些类型的窗口，以及</li>
<li>如何实现一个窗口化聚合的 DataStream 程序？</li>
</ul>
<h3 id="介绍-1">介绍</h3>
<p>在做流处理的时候，自然而然地想要计算流的有界子集的聚合分析，以回答这样的问题。</p>
<ul>
<li>每分钟的页面浏览量</li>
<li>每个用户每周会话数</li>
<li>每个传感器每分钟的最高温度</li>
</ul>
<p>用 Flink 计算窗口化分析依赖于两个主要的抽象。窗口分配器（Window Assigners）将事件分配给窗口（必要时创建新的窗口对象），窗口函数（Window Functions）应用于分配给窗口的事件。</p>
<p>Flink 的窗口 API 还有 Triggers 的概念，它决定什么时候调用窗口函数，还有 Evictors，它可以删除窗口中收集的元素。</p>
<p>在它的基本形式中，你将窗口化应用到像这样的 keyed stream 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">stream</span><span class="o">.</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">assigner</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">reduce</span><span class="o">|</span><span class="n">aggregate</span><span class="o">|</span><span class="n">process</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>
</code></pre></div><p>您也可以对 non-keyed stream 使用窗口化，但请记住，在这种情况下，处理将不会并行进行。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">stream</span><span class="o">.</span>
    <span class="o">.</span><span class="n">windowAll</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">assigner</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">reduce</span><span class="o">|</span><span class="n">aggregate</span><span class="o">|</span><span class="n">process</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>
</code></pre></div><h3 id="窗口分配器">窗口分配器</h3>
<p>Flink 有几种内置的窗口分配器类型，下面进行说明。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/window-assigners.svg" alt="img"></p>
<p>一些例子说明这些窗口分配器的用途，以及如何指定它们:</p>
<ul>
<li>
<p>滚动时间窗口</p>
</li>
<li>
<p>每分钟浏览量</p>
</li>
<li>
<p>TumblingEventTimeWindows.of(Time.minutes(1))</p>
</li>
<li>
<p>滑动时间窗口</p>
</li>
<li>
<p>每10秒计算的每分钟页面浏览量</p>
</li>
<li>
<p>SlidingEventTimeWindows.of(Time.min(1), Time.seconds(10))</p>
</li>
<li>
<p>会话窗口</p>
</li>
<li>
<p>每节课的页面浏览量，其中每节课之间至少有30分钟的间隔。</p>
</li>
<li>
<p>EventTimeSessionWindows.withGap(Time.minutes(30))</p>
</li>
</ul>
<p>可以使用 Time.milliseconds(n), Time.seconds(n), Time.minutes(n), Time.hours(n), 和 Time.days(n) 中的一种指定持续时间。</p>
<p>基于时间的窗口分配器（包括会话窗口）有事件时间(event time)和处理时间(processing time)两种风味。这两种类型的时间窗口之间有显著的权衡。对于处理时间窗口，你必须接受这些限制:</p>
<ul>
<li>不能正确处理历史数据。</li>
<li>不能正确处理失序数据。</li>
<li>结果将是非确定性的。</li>
</ul>
<p>但具有较低延迟的优势。</p>
<p>当使用基于计数的窗口时，请记住，这些窗口将不会启动，直到一个批次完成。没有超时和处理部分窗口的选项，尽管你可以用自定义的触发器自己实现这种行为。</p>
<p>全局窗口分配器将每个事件（用相同的键）分配到同一个全局窗口。只有当你打算使用自定义触发器来做你自己的自定义窗口时，这才是有用的。在许多看似有用的情况下，您最好使用<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/event_driven.html#process-functions">另一节</a>中描述的 ProcessFunction。</p>
<h3 id="窗口函数">窗口函数</h3>
<p>对于如何处理窗口的内容，您有三个基本选项。</p>
<ol>
<li>作为一个批次，使用一个 ProcessWindowFunction，它将被传递一个包含窗口内容的 Iterable。</li>
<li>以增量方式，使用 ReduceFunction 或 AggregateFunction，当每个事件被分配到窗口时被调用。</li>
<li>或两者结合，当窗口被触发时，ReduceFunction 或 AggregateFunction 的预聚集结果被提供给 ProcessWindowFunction。</li>
</ol>
<p>这里是方法1和3的例子。每个实现都在1分钟的事件时间窗口中从每个传感器中找到峰值值，并产生一个包含(key, end-of-window-timestamp, max_value) 的 Tuples 流。</p>
<h4 id="processwindowfunction-示例">ProcessWindowFunction 示例</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">SensorReading</span><span class="o">&gt;</span> <span class="n">input</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">input</span>
    <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">)</span>
    <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingEventTimeWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">minutes</span><span class="o">(</span><span class="n">1</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="k">new</span> <span class="n">MyWastefulMax</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyWastefulMax</span> <span class="kd">extends</span> <span class="n">ProcessWindowFunction</span><span class="o">&lt;</span>
        <span class="n">SensorReading</span><span class="o">,</span>                  <span class="c1">// input type
</span><span class="c1"></span>        <span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span><span class="o">,</span>  <span class="c1">// output type
</span><span class="c1"></span>        <span class="n">String</span><span class="o">,</span>                         <span class="c1">// key type
</span><span class="c1"></span>        <span class="n">TimeWindow</span><span class="o">&gt;</span> <span class="o">{</span>                   <span class="c1">// window type
</span><span class="c1"></span>    
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span>
            <span class="n">String</span> <span class="n">key</span><span class="o">,</span>
            <span class="n">Context</span> <span class="n">context</span><span class="o">,</span> 
            <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">SensorReading</span><span class="o">&gt;</span> <span class="n">events</span><span class="o">,</span>
            <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">SensorReading</span> <span class="n">event</span> <span class="o">:</span> <span class="n">events</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">value</span><span class="o">,</span> <span class="n">max</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Tuple3</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">context</span><span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getEnd</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">max</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>在这个实现中，有几件事需要注意。</p>
<ul>
<li>所有分配给窗口的事件都必须在 keyed Flink state 下被缓冲，直到窗口被触发。这可能是相当昂贵的。</li>
<li>我们的 ProcessWindowFunction 被传递了一个 Context 对象，其中包含了窗口的信息。它的接口是这样的:</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Context</span> <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">W</span> <span class="nf">window</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">long</span> <span class="nf">currentProcessingTime</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">long</span> <span class="nf">currentWatermark</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">KeyedStateStore</span> <span class="nf">windowState</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">KeyedStateStore</span> <span class="nf">globalState</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>windowState 和 globalState 是您可以存储该键的所有窗口的 per-key, per-window, 或全局 per-key 信息的地方。例如，如果您想记录一些关于当前窗口的信息，并在处理后续窗口时使用这些信息，这可能会很有用。</p>
<h4 id="递增聚合示例">递增聚合示例</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">SensorReading</span><span class="o">&gt;</span> <span class="n">input</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">input</span>
    <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">)</span>
    <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingEventTimeWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">minutes</span><span class="o">(</span><span class="n">1</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="k">new</span> <span class="n">MyReducingMax</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="k">new</span> <span class="n">MyWindowFunction</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyReducingMax</span> <span class="kd">implements</span> <span class="n">ReduceFunction</span><span class="o">&lt;</span><span class="n">SensorReading</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">SensorReading</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">SensorReading</span> <span class="n">r1</span><span class="o">,</span> <span class="n">SensorReading</span> <span class="n">r2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">r1</span><span class="o">.</span><span class="na">value</span><span class="o">(</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">r2</span><span class="o">.</span><span class="na">value</span><span class="o">(</span><span class="o">)</span> <span class="o">?</span> <span class="n">r1</span> <span class="o">:</span> <span class="n">r2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyWindowFunction</span> <span class="kd">extends</span> <span class="n">ProcessWindowFunction</span><span class="o">&lt;</span>
    <span class="n">SensorReading</span><span class="o">,</span> <span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">SensorReading</span><span class="o">&gt;</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">TimeWindow</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span>
            <span class="n">String</span> <span class="n">key</span><span class="o">,</span>
            <span class="n">Context</span> <span class="n">context</span><span class="o">,</span>
            <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">SensorReading</span><span class="o">&gt;</span> <span class="n">maxReading</span><span class="o">,</span>
            <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">SensorReading</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">SensorReading</span> <span class="n">max</span> <span class="o">=</span> <span class="n">maxReading</span><span class="o">.</span><span class="na">iterator</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">next</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Tuple3</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">context</span><span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getEnd</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">max</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>请注意，<code>Iterable&lt;SensorReading&gt;</code> 将只包含一个读数&ndash;由 MyReducingMax 计算的 pre-aggregated 最大值。</p>
<h3 id="迟来的事件">迟来的事件</h3>
<p>默认情况下，当使用事件时间窗口时，迟到的事件会被丢弃。窗口 API 有两个可选部分可以让您对此有更多的控制。</p>
<p>您可以使用名为<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/event_driven.html#side-outputs">&ldquo;侧输出&rdquo;</a>的机制，安排将被丢弃的事件收集到一个备用的输出流中。下面是一个例子，说明这可能是什么样子的:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">OutputTag</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">lateTag</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OutputTag</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span><span class="o">(</span><span class="s">&#34;late&#34;</span><span class="o">)</span><span class="o">{</span><span class="o">}</span><span class="o">;</span>

<span class="n">SingleOutputStreamOperator</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span>
    <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span>
    <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span>
    <span class="o">.</span><span class="na">sideOutputLateData</span><span class="o">(</span><span class="n">lateTag</span><span class="o">)</span>
    <span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span><span class="o">;</span>
  
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">lateStream</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getSideOutput</span><span class="o">(</span><span class="n">lateTag</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>您还可以指定允许的延迟时间间隔，在此期间，延迟事件将继续分配给相应的窗口（其状态将被保留）。默认情况下，每个延迟事件都会导致窗口函数再次被调用（有时称为延迟发射）。</p>
<p>换句话说，水印后面的元素会被丢弃（或发送到侧输出）。</p>
<p>比如说:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">stream</span><span class="o">.</span>
    <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span>
    <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span>
    <span class="o">.</span><span class="na">allowedLateness</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="n">10</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>当允许的延迟大于零时，只有那些晚到会被丢弃的事件才会被发送到侧输出（如果已经配置了）。</p>
<h3 id="惊喜">惊喜</h3>
<p>Flink 的 windowing API 的某些方面可能并不像你所期望的那样。基于 <a href="https://flink.apache.org/community.html#mailing-lists">flink 用户邮件列表</a>和其他地方的常见问题，这里有一些关于窗口的事实可能会让你感到惊讶。</p>
<h4 id="滑动窗口会进行复制">滑动窗口会进行复制</h4>
<p>滑动窗口分配器可以创建很多窗口对象，并会将每个事件复制到每个相关窗口中。例如，如果你每15分钟有一个长度为24小时的滑动窗口，每个事件将被复制到 4*24=96 个窗口中。</p>
<h4 id="时间窗口与纪元对齐">时间窗口与纪元对齐</h4>
<p>仅仅因为你使用了一个小时的处理时间窗口，并且在 12:05 开始运行你的应用程序，并不意味着第一个窗口会在 1:05 关闭。第一个窗口将长达 55 分钟，并在 1:00 关闭。</p>
<p>但是请注意，滚动窗口和滑动窗口分配器采用一个可选的偏移参数，可以用来改变窗口的对齐方式。详情请参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#tumbling-windows">滚动窗口</a>和<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#sliding-windows">滑动窗口</a>。</p>
<h4 id="窗口可以跟随窗口">窗口可以跟随窗口</h4>
<p>例如，这样做是可行的:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">stream</span>
    <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="n">t</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">key</span><span class="o">)</span>
    <span class="o">.</span><span class="na">timeWindow</span><span class="o">(</span><span class="o">&lt;</span><span class="n">time</span> <span class="n">specification</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="o">&lt;</span><span class="n">reduce</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="na">timeWindowAll</span><span class="o">(</span><span class="o">&lt;</span><span class="n">same</span> <span class="n">time</span> <span class="n">specification</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="o">&lt;</span><span class="n">same</span> <span class="n">reduce</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>
</code></pre></div><p>你可能会期望 Flink 的运行时足够聪明，能够为你做这种并行的预聚合（前提是你使用的是 ReduceFunction 或 AggregateFunction），但事实并非如此。</p>
<p>之所以这样做的原因是，一个时间窗口产生的事件会根据窗口结束的时间分配时间戳。所以，例如，一个小时长的窗口产生的所有事件都会有标记一个小时结束的时间戳。任何消耗这些事件的后续窗口的持续时间应该与前一个窗口的持续时间相同，或者是其倍数。</p>
<h4 id="空的时间窗口没有结果">空的时间窗口没有结果</h4>
<p>只有当事件被分配到窗口时，才会创建窗口。因此，如果在给定的时间帧内没有事件，就不会报告结果。</p>
<h4 id="迟来的事件会导致迟来的合并">迟来的事件会导致迟来的合并</h4>
<p>会话窗口是基于可以合并的窗口的抽象。每个元素最初都被分配到一个新的窗口，之后只要窗口之间的间隙足够小，就会合并。这样一来，一个迟到的事件可以弥合分开两个之前独立的会话的差距，产生迟到的合并。</p>
<h2 id="实践">实践</h2>
<p>与本节配套的实战练习是 <a href="https://github.com/apache/flink-training/tree/release-1.11/hourly-tips">Hourly Tips Exercise</a>。</p>
<h2 id="进一步阅读">进一步阅读</h2>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/timely-stream-processing.html">及时的流处理</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html">窗口</a></li>
</ul>
<p>原文链接: <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/streaming_analytics.html">https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/streaming_analytics.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/training" term="training" label="Training" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[通过状态快照进行容错]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-19-fault-tolerance/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="related" type="text/html" title="DataStream API 介绍" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-event-driven-applications/?utm_source=atom_feed" rel="related" type="text/html" title="事件驱动型应用程序" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-learn-flink-hands-on-training/?utm_source=atom_feed" rel="related" type="text/html" title="学习 Flink: 实践培训" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-data-pipelines-and-etl/?utm_source=atom_feed" rel="related" type="text/html" title="数据管道和 ETL" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics/?utm_source=atom_feed" rel="related" type="text/html" title="流分析" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-19-fault-tolerance/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-19T00:00:00+08:00</published>
            <updated>2020-08-19T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Fault Tolerance via State Snapshots</blockquote><h2 id="状态后端">状态后端</h2>
<p>Flink 管理的 keyed state 是一种碎片化的、键/值存储，每项 keyed state 的工作副本都被保存在负责该键的 taskmanager 的本地某处。Operator 的状态也被保存在需要它的机器的本地。Flink 会定期对所有状态进行持久化快照，并将这些快照复制到某个更持久的地方，比如分布式文件系统。</p>
<p>在发生故障的情况下，Flink 可以恢复你的应用程序的完整状态，并恢复处理，就像什么都没有发生过一样。</p>
<p>Flink 管理的这种状态被存储在状态后端中。状态后端有两种实现&ndash;一种是基于 RocksDB 的，它是一个嵌入式的键/值存储，将其工作状态保存在磁盘上；另一种是基于堆的状态后端，将其工作状态保存在内存中，在 Java 堆上。这种基于堆的状态后端有两种风味：将其状态快照持久化到分布式文件系统的 FsStateBackend 和使用 JobManager 的堆的 MemoryStateBackend。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">工作状态</th>
<th align="left">状态备份</th>
<th align="left">快照</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">RocksDBStateBackend</td>
<td align="left">本地磁盘(tmp dir)</td>
<td align="left">分布式文件系统</td>
<td align="left">完全/增量</td>
</tr>
<tr>
<td align="left">支持大于可用内存的状态; 经验法则：比基于堆的后端慢10倍。</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">FsStateBackend</td>
<td align="left">JVM Heap</td>
<td align="left">分布式文件系统</td>
<td align="left">Full</td>
</tr>
<tr>
<td align="left">速度快，需要大量堆积; 受制于 GC</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">MemoryStateBackend</td>
<td align="left">JVM Heap</td>
<td align="left">JobManager JVM Heap</td>
<td align="left">Full</td>
</tr>
<tr>
<td align="left">有利于小状态（地方）的测试和实验。</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>当处理保存在基于堆的状态后端的状态时，访问和更新涉及到在堆上读写对象。但是对于保存在 RocksDBStateBackend 中的对象，访问和更新涉及到序列化和反序列化，因此成本更高。但是使用 RocksDB 可以拥有的状态数量只受限于本地磁盘的大小。还要注意的是，只有 RocksDBStateBackend 能够进行增量快照，这对于有大量缓慢变化的状态的应用来说是一个很大的好处。</p>
<p>所有这些状态后端都能够进行异步快照，这意味着它们可以在不妨碍正在进行的流处理的情况下进行快照。</p>
<h2 id="状态快照">状态快照</h2>
<h3 id="定义">定义</h3>
<ul>
<li>快照&ndash;一个通用术语，指的是一个 Flink 作业状态的全局、一致的图像。快照包括进入每个数据源的指针（例如，进入文件或 Kafka 分区的偏移），以及来自每个作业的有状态操作符的状态副本，这些操作符是在处理了所有事件后产生的，直到源中的这些位置。</li>
<li>检查点&ndash;Flink 为了能够从故障中恢复而自动拍摄的快照。检查点可以是增量的，并为快速恢复进行了优化。</li>
<li>外部化检查点&ndash;通常检查点不打算被用户操纵。Flink 只在作业运行时保留n个最近的检查点（n是可配置的），并在作业取消时删除它们。但你也可以配置它们被保留，在这种情况下，你可以手动从它们恢复。</li>
<li>保存点&ndash;由用户（或API调用）手动触发的快照，用于某些操作目的，例如有状态的重新部署/升级/重新缩放操作。保存点始终是完整的，并为操作的灵活性进行了优化。</li>
</ul>
<h3 id="状态快照是如何工作的">状态快照是如何工作的？</h3>
<p>Flink 使用 <a href="https://en.wikipedia.org/wiki/Chandy-Lamport_algorithm">Chandy-Lamport</a> 算法的一个变体，称为异步屏障快照。</p>
<p>当任务管理器被检查点协调器（作业管理器的一部分）指示开始检查点时，它让所有的源记录它们的偏移量，并在它们的流中插入编号的检查点障碍。这些屏障在作业图(job graph)中流动，指示每个检查点前后的流的部分。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/stream_barriers.svg" alt="img"></p>
<p>检查点n将包含每个 operator 的状态，这些状态是由于消耗了检查点障碍n之前的每个事件，而没有消耗它之后的任何事件。</p>
<p>当作业图中的每个 operator 接收到这些障碍之一时，它就会记录其状态。具有两个输入流（如 CoProcessFunction）的 operator 执行屏障对齐，这样快照将反映消耗两个输入流的事件所产生的状态，直到（但不超过）两个屏障。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/stream_aligning.svg" alt="img"></p>
<p>Flink 的状态后端使用复制-写机制，允许在异步快照状态的旧版本时，流处理不受阻碍地继续。只有当快照被持久化后，这些旧版本的状态才会被垃圾回收。</p>
<h3 id="一次性保证">一次性保证</h3>
<p>当流处理应用中出现问题时，有可能出现丢失，或者重复的结果。在 Flink 中，根据你对应用的选择和你运行它的集群，这些结果中的任何一种都是可能的。</p>
<ul>
<li>Flink 不努力从故障中恢复（最多一次）。</li>
<li>没有任何损失，但您可能会遇到重复的结果（至少一次）。</li>
<li>没有任何东西丢失或重复（精确地一次）。</li>
</ul>
<p>鉴于 Flink 通过倒带和重放源数据流从故障中恢复，当理想情况被描述为精确一次时，这并不意味着每个事件都将被精确处理一次。相反，它意味着每一个事件都会对 Flink 所管理的状态产生一次确切的影响。</p>
<p>Barrier 对齐只需要用于提供精确的一次保证。如果你不需要这个，你可以通过配置 Flink 使用 CheckpointingMode.AT_LEAST_ONCE 来获得一些性能，它的效果是禁用屏障对齐。</p>
<h3 id="精确一次-端到端">精确一次, 端到端</h3>
<p>为了实现端到端精确的一次，让源的每个事件精确地影响汇，以下几点必须是真的。</p>
<ol>
<li>你的源必须是可重播的，并且</li>
<li>你的接收器必须是事务性的(或幂等的)</li>
</ol>
<h2 id="实践">实践</h2>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/try-flink/flink-operations-playground.html">Flink Operations Playground</a> 包括<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/try-flink/flink-operations-playground.html#observing-failure--recovery">观察故障和恢复</a>的部分。</p>
<h2 id="进一步阅读">进一步阅读</h2>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html">有状态的流处理</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/state/state_backends.html">状态后端</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/connectors/guarantees.html">数据源和接收器的容错保证</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/checkpointing.html">启用和配置检查点</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/state/checkpoints.html">检查点</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/state/savepoints.html">保存点</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/state/large_state_tuning.html">调整检查点和大状态</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/monitoring/checkpoint_monitoring.html">监测检查点</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/task_failure_recovery.html">任务故障恢复</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/training" term="training" label="Training" />
                            
                        
                    
                
            
        </entry>
    
</feed>
