<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>
            
                    Junction on
                
            
            焉知非鱼</title>
        <link>https://ohmyweekly.github.io/tags/junction/</link>
        <description>Recent content  in Junction
            on 焉知非鱼</description>
        <language>en-us</language>
        <lastBuildDate>Wed, 23 Dec 2020 23:25:57 +0800</lastBuildDate>
        <generator>Hugo -- gohugo.io</generator>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
            <atom:link href="https://ohmyweekly.github.io/tags/junction/index.xml" rel="self" type="application/rss&#43;xml" />
        
            
            <item>
                <title>贪婪 Junction 的奇闻异事</title>
                <link>https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/</link>
                
                
                <description>&lt;blockquote&gt;The Strange Case of the Greedy Junction&lt;/blockquote&gt;&lt;h2 id=&#34;贪婪-junction-的奇闻异事&#34;&gt;贪婪 junction 的奇闻异事&lt;/h2&gt;
&lt;p&gt;说明 Raku 的 junction 是如何贪婪的设计，以及一个建议。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://raku.org/&#34;&gt;Raku&lt;/a&gt; 有一个整洁的功能，叫做 &lt;a href=&#34;https://docs.raku.org/type/Junction&#34;&gt;Junction&lt;/a&gt;。在这篇短文中，我想强调一下 junction 与函数交互的一个特殊后果：它们是贪婪的，我的意思是它们会无意中把函数的其他参数变成 junction。为了说明这种行为，我将使用一个闭包创建一个 &lt;code&gt;pair&lt;/code&gt; 数据结构，它可以接受两个不同类型的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;enum RGB &amp;lt;R G B&amp;gt;;

# Pair Constructor: the arguments of pair() are captured
# in a closure that is returned
sub pair(\x, \y) {
    sub (&amp;amp;p){ p(x, y) } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以 &lt;code&gt;pair&lt;/code&gt; 接受两个任意类型的参数，并返回一个以函数为参数的闭包。我们将使用这个函数来访问存储在 &lt;code&gt;pair&lt;/code&gt; 中的值。我将把这些访问(accessor)函数称为 &lt;code&gt;fst&lt;/code&gt; 和 &lt;code&gt;snd&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;# Accessors to get the values from the closure
my sub fst (&amp;amp;p) {p( sub (\x,\y){x})}
my sub snd (&amp;amp;p) {p( sub (\x,\y){y})}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;做实际选择的函数是由 &lt;code&gt;fst&lt;/code&gt; 和 &lt;code&gt;snd&lt;/code&gt; 返回的匿名子程序，这纯粹是为了让我可以将它们应用于 &lt;code&gt;pair&lt;/code&gt;，而不是必须将它们作为参数传递。让我们看一个例子，一个 &lt;code&gt;Int&lt;/code&gt; 和一个 &lt;code&gt;RGB&lt;/code&gt; 的 pair。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my \p1 = pair 42, R;

if ( 42 == fst p1) {
    say snd p1;	#=&amp;gt; says &amp;quot;R&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以我们用两个值调用 &lt;code&gt;pair&lt;/code&gt; 来创建一个 pair，并使用 &lt;code&gt;fst&lt;/code&gt; 和 &lt;code&gt;snd&lt;/code&gt; 来访问 pair 中的值。这是一个不可变的数据结构，所以不可能进行更新。&lt;/p&gt;
&lt;p&gt;现在让我们使用 junction 作为其中一个参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;# Example instance with a &#39;one&#39;-type junction
my Junction \p1j = pair (42^43),R;

if ( 42 == fst p1j) {
    say snd p1j; #=&amp;gt; one(R, R)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里发生的情况是，原始参数 &lt;code&gt;R&lt;/code&gt; 已经不可逆转地变成了与自己的 junction，尽管我们从未明确地在 &lt;code&gt;R&lt;/code&gt; 上创建过 junction，但还是发生了这种情况。这是将 junction 类型应用于函数的结果，它不是一个 bug，只是 junction 行为的一个影响。更详细的解释，请看我的文章&amp;quot;&lt;a href=&#34;https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e&#34;&gt;重构 Raku 的 Junction&lt;/a&gt;&amp;quot;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.raku.org/type/Junction&#34;&gt;Raku 关于 junction 的文档&lt;/a&gt;中说，你不应该真正尝试从 junction 中获取值。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Junction 是用来作为布尔上下文中的匹配器，不支持 junction 的自省。如果你觉得有自省 junction 的冲动，请使用 Set 或相关类型代替。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;然而，有一个 FAQ &lt;a href=&#34;https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)&#34;&gt;勉强地告诉你如何做&lt;/a&gt;。FAQ 再次警告不要这样做。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;如果你想从 junction 中提取值（特征态），你可能做错了什么，应该用 Set 来代替。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;然而，正如我所举的例子所证明的那样，从 junction 中恢复值是有明确的用例的。当然，仅仅因为另一个值恰好是 junction，存储在 pair 中的其中一个值就变得不可访问，这不是我们的本意。&lt;/p&gt;
&lt;p&gt;因此，我建议增加一个折叠(&lt;code&gt;collapse&lt;/code&gt;)函数，允许将这些无意中出现的 junction 值折叠成它们的原始值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;if ( 42 == fst p1j) {
    say collapse(snd p1j); #=&amp;gt; says &#39;R&#39;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该函数的实现取自&lt;a href=&#34;https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)&#34;&gt;上述常见问题&lt;/a&gt;，并增加了一个检查，以确保 junction 上的所有值都相同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub collapse(Junction \j) {    
    my @vvs;
    -&amp;gt; Any \s { push @vvs, s }.(j);    
    my $v =  shift @vvs;        
    my @ts = grep {!($_ ~~ $v)}, @vvs;
    if (@ts.elems==0) {  
        $v
    } else {
        die &amp;quot;Can&#39;t collapse this Junction: elements are not identical: {$v,@vvs}&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果能把这个功能作为一个 &lt;code&gt;collapse&lt;/code&gt; 方法添加到 &lt;code&gt;Junction&lt;/code&gt; 类中就更好了。&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&#34;https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8&#34;&gt;https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/rakulang">rakulang</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/junction">Junction</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/</guid>
                <pubDate>Sun, 04 Oct 2020 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>重构 Raku 的 Junction</title>
                <link>https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/</link>
                
                
                <description>&lt;blockquote&gt;Reconstructing Raku&amp;rsquo;s Junctions&lt;/blockquote&gt;&lt;h2 id=&#34;重构-raku-的-junction&#34;&gt;重构 Raku 的 Junction&lt;/h2&gt;
&lt;p&gt;Raku 中的 junction 很酷，但乍一看它们并没有遵循静态类型化的规则。我对它们的形式化类型语义很好奇，所以我从功能、静态类型的角度对 junction 进行了解构和重构。&lt;/p&gt;
&lt;h3 id=&#34;raku-中的-junction&#34;&gt;Raku 中的 Junction&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.raku.org/&#34;&gt;Raku&lt;/a&gt; 有一个整洁的功能叫做 &lt;a href=&#34;https://docs.raku.org/type/Junction&#34;&gt;Junction&lt;/a&gt;。Junction 是一个无序的复合值。当使用 junction 代替值时，会对每个结点(junction)元素进行操作，结果是所有这些操作符的返回值的结点(junction)。当在布尔上下文中使用 junction 时，结点(junction)会折叠成一个值。Junction 的类型可以是 all(&lt;code&gt;&amp;amp;&lt;/code&gt;)、any(&lt;code&gt;|&lt;/code&gt;)、one(&lt;code&gt;^&lt;/code&gt;) 或 &lt;code&gt;none&lt;/code&gt; (空结点)。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my $j = 11|22; # short for any(11,22)
if 33 == $j + 11 {
    say &#39;yes&#39;;
}

say so 3 == (1..30).one;         #=&amp;gt; True 
say so (&amp;quot;a&amp;quot; ^ &amp;quot;b&amp;quot; ^ &amp;quot;c&amp;quot;) eq &amp;quot;a&amp;quot;; #=&amp;gt; True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数 &lt;code&gt;so&lt;/code&gt; 强制使用布尔上下文。&lt;/p&gt;
&lt;p&gt;Junction 有 &lt;code&gt;Junction&lt;/code&gt; 类型，我很好奇 Junction 的类型规则，因为乍一看有些奇怪。比方说我们有一个函数 &lt;code&gt;sq&lt;/code&gt; 从 &lt;code&gt;Int&lt;/code&gt; 到 &lt;code&gt;Int&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sq(Int $x --&amp;gt; Int) { $x*$x }

my Int $res = sq(11); # OK
say $res; #=&amp;gt; 121
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在让我们定义一个类型为任何 &lt;code&gt;Int&lt;/code&gt; 值的 Junction。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my Junction $j = 11 | 22; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当我们将 &lt;code&gt;sq&lt;/code&gt; 应用于 &lt;code&gt;$j&lt;/code&gt; 时，我们没有得到一个类型错误，即使函数的类型是 &lt;code&gt;:(Int --&amp;gt; Int)&lt;/code&gt;，Junction 的类型是 &lt;code&gt;Junction&lt;/code&gt;。相反，我们得到的是一个结果的 Junction。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;say sq($j); #=&amp;gt; any(121, 484)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们像之前一样将其赋值给一个类型为 &lt;code&gt;Int&lt;/code&gt; 的变量，我们会得到一个类型错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my Int $rj = sq($j); #=&amp;gt; Type check failed in assignment to $rj; expected Int but got Junction (any(121, 484))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;取而代之的是，现在返回值的类型为 &lt;code&gt;Junction&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my Junction $rj = sq(11|22); # OK
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以，Junction 类型可以代替任何其他类型，但这样一来，操作也变成了 Junction。&lt;/p&gt;
&lt;p&gt;另一方面，Junction 是由其组成值隐式类型的，尽管它们看起来是不透明的 &lt;code&gt;Junction&lt;/code&gt; 类型。例如，如果我们创建了一个由 &lt;code&gt;Str&lt;/code&gt; 值组成的 Junction，并试图将这个 Junction 的值传递到 &lt;code&gt;sq&lt;/code&gt; 中，我们会得到一个类型错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my $sj = &#39;11&#39; | &#39;22&#39;;
say $sj.WHAT; #=&amp;gt;(Junction)

my Junction $svj = sq($sj); #=&amp;gt; Type check failed in binding to parameter &#39;x&#39;; expected Int but got Str (&amp;quot;11&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;junction-不遵循静态类型规则&#34;&gt;Junction 不遵循静态类型规则&lt;/h3&gt;
&lt;p&gt;虽然这样做是有道理的(如果原始函数期望使用 &lt;code&gt;Int&lt;/code&gt;，我们不希望它与 &lt;code&gt;Str&lt;/code&gt; 一起工作)，但这确实违背了静态类型化的规则，即使是子类型化。如果一个参数的类型是 &lt;code&gt;Int&lt;/code&gt;，那么可以使用类型图中低于它的任何类型来代替。但是 &lt;code&gt;Int&lt;/code&gt; 和 &lt;code&gt;Junction&lt;/code&gt; 的简化类型图如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Int -&amp;gt; Cool -&amp;gt; Any -&amp;gt; Mu &amp;lt;- Junction
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以 Junction 永远不是 &lt;code&gt;Any&lt;/code&gt; 以下任何东西的子类型。因此，将 Junction 放在类型为 &lt;code&gt;Any&lt;/code&gt; 或其子类型的槽中应该是一个类型错误。&lt;/p&gt;
&lt;p&gt;此外，由于 Junction 类型是不透明的（即它不是一个参数化的类型），它不应该持有任何关于 Junction 内部值的类型的信息。然而它却对这些不可见、不可访问的值进行了类型检查。&lt;/p&gt;
&lt;p&gt;那么这里到底发生了什么？&lt;/p&gt;
&lt;h3 id=&#34;一个工作假设&#34;&gt;一个工作假设&lt;/h3&gt;
&lt;p&gt;一个工作假设是，Junction 类型并不真正取代任何其他类型：它只是一个语法糖，使它看起来如此。&lt;/p&gt;
&lt;h3 id=&#34;重构-junction-的第一部分类型&#34;&gt;重构 Junction 的第一部分：类型&lt;/h3&gt;
&lt;p&gt;让我们试着重建这个。我们的目的是想出一个数据类型和一些动作，以复制观察到的 Raku Junction 的行为。首先我们讨论一下类型，为了清晰起见，使用 Haskell 符号。然后我介绍 Raku 中的实现。这个实现将像 Raku 的原生 Junction 一样，但没有神奇的语法糖。通过这种方式，我证明了 Raku 的 Junction 毕竟遵循了正确的类型规则。&lt;/p&gt;
&lt;h4 id=&#34;junction-类型&#34;&gt;Junction 类型&lt;/h4&gt;
&lt;p&gt;Junction 是一个由 Junction 类型 &lt;code&gt;JType&lt;/code&gt; 和一组值组成的数据结构。为了方便起见，我将这个值集限制为单一类型，同时也是因为混合类型的 Junction 其实没有什么意义。我使用一个列表来模拟这个集合，同样是为了方便。因为 Junction 可以包含任何类型的值，所以它是一个多态的代数数据类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;data JType = JAny | JAll | JOne | JNone

data Junction a = Junction JType [a]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;应用结点&#34;&gt;应用结点&lt;/h4&gt;
&lt;p&gt;对一个 Junction 做任何事情都意味着对它应用一个函数。我们可以考虑三种情况，我为每一种情况介绍一个特别定制的操作符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将非 Junction 函数应用于 Junction 表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;(•￮) :: (a -&amp;gt; b) -&amp;gt; Junction a -&amp;gt;  Junction b
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;将 Junction 函数应用于非 Junction 表达式。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;(￮•) ::  Junction (b -&amp;gt; c) -&amp;gt; b -&amp;gt; Junction c
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;将 Junction 函数应用于 Junction 表达式，创建一个嵌套 Junction。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;(￮￮) ::  Junction (b -&amp;gt; c) -&amp;gt; Junction b -&amp;gt; Junction (Junction c)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了方便，我们还可以在 Junction a 和 a 之间创建自定义比较运算符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;-- and similar for /-, &amp;gt;, &amp;lt;, &amp;lt;=,&amp;gt;=
(￮==•) :: Junction a -&amp;gt; a -&amp;gt; Bool
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;折叠-junction&#34;&gt;折叠 Junction&lt;/h4&gt;
&lt;p&gt;那么我们就有了 &lt;code&gt;so&lt;/code&gt;，布尔强制函数。它的作用是将一个布尔的 Junction 折叠成一个布尔。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;so :: Junction Bool -&amp;gt; Bool
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后我们有 &lt;code&gt;collapse&lt;/code&gt;，它从一个 Junction 返回值，前提是它是一个 Junction，所有存储的值都是一样的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;collapse :: (Show a,Eq a) =&amp;gt; Junction a -&amp;gt; a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这似乎是一个奇怪的函数，但由于 Junction 的行为，它是必要的。正如我们将看到的，上述语义意味着 Junction 是贪婪的：如果一个函数的一个参数是 Junction，那么所有其他参数也会成为 Junction，但 Junction 中的所有值都是相同的。我已经在&amp;quot;&lt;a href=&#34;https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8&#34;&gt;贪婪 Junction 的奇怪情况&lt;/a&gt;&amp;ldquo;中讨论过这个问题，但我们现在可以将这种行为形式化。&lt;/p&gt;
&lt;h4 id=&#34;重新审视贪婪-junction-的奇怪情况&#34;&gt;重新审视贪婪 Junction 的奇怪情况&lt;/h4&gt;
&lt;p&gt;假设我们有一个两个参数的函数 &lt;code&gt;f :: a -&amp;gt; b -&amp;gt; c&lt;/code&gt;，我们对第一个参数应用一个结点 &lt;code&gt;j :: Junction&lt;/code&gt; a 应用到第一个参数 &lt;code&gt;f •￮ j&lt;/code&gt; 上，那么结果是一个部分应用的函数，包裹在一个 Junction 上：&lt;code&gt;fp :: Junction b -&amp;gt; c&lt;/code&gt;。如果我们现在想用 &lt;code&gt;fp ￮• v&lt;/code&gt; 将这个函数应用于一个非结点的值 &lt;code&gt;v :: b&lt;/code&gt;，那么结果就是 &lt;code&gt;Junction c&lt;/code&gt; 类型的。&lt;/p&gt;
&lt;p&gt;现在，让我们考虑类型 &lt;code&gt;c&lt;/code&gt; 是 &lt;code&gt;forall d . (a -&amp;gt; b -&amp;gt; d) -&amp;gt; d&lt;/code&gt; 的特殊情况。所以我们有 &lt;code&gt;Junction&lt;/code&gt;(&lt;code&gt;forall d . (a-&amp;gt;b-&amp;gt;d) -&amp;gt; d&lt;/code&gt;)。这是一个函数，它接受一个函数参数并返回该函数的返回类型的东西。我们使用 &lt;code&gt;forall&lt;/code&gt;，所以 &lt;code&gt;d&lt;/code&gt; 可以是任何东西，但在实践中我们希望它是 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;假设我们将这个函数(称它为 &lt;code&gt;p&lt;/code&gt;)应用于 &lt;code&gt;fst :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt;，使用 &lt;code&gt;p ￮• fst&lt;/code&gt;，那么我们得到 &lt;code&gt;Junction a&lt;/code&gt;。但是如果我们将它应用于 &lt;code&gt;snd :: a-&amp;gt;b-&amp;gt;b&lt;/code&gt;，使用 &lt;code&gt;p ￮• snd&lt;/code&gt;，那么我们得到 &lt;code&gt;Junction b&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这就是形式上基于类型的分析，为什么我们不能从一个 pair 中返回一个非 Junction 的值，在&amp;rdquo;&lt;a href=&#34;https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8&#34;&gt;贪婪 Junction 的奇怪情况&lt;/a&gt;&amp;ldquo;中已经解释过。而这也是我们需要 &lt;code&gt;collapse&lt;/code&gt; 函数的原因。&lt;/p&gt;
&lt;h4 id=&#34;重构-junction-的第2部分raku-的实现&#34;&gt;重构 Junction 的第2部分：Raku 的实现。&lt;/h4&gt;
&lt;p&gt;我们从创建 Junction 类型开始，为四种 Junction 类型使用一个枚举，为实际的 Junction 数据类型使用一个角色。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;# The types of Junctions
enum JType &amp;lt;JAny  JAll  JOne  JNone &amp;gt;;

# The actual Junction type
role Junction[\jt, @vs] {
    has JType $.junction-type=jt;
    has @.values=@vs;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来是四种类型的 Junction 的构造函数（下划线，避免与内建函数的名称冲突）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;our sub all_(@vs) {
    Junction[ JAll, @vs].new;
}

our sub any_(@vs) {
    Junction[ JAny, @vs].new;
}

our sub one_(@vs) {
    Junction[ JOne, @vs].new;
}

our sub none_(@vs) {
    Junction[ JNone, @vs].new;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将一个（单参数）函数应用于 junction 参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub infix:&amp;lt;●○&amp;gt;( &amp;amp;f, \j ) is export {
    my \jt=j.junction-type; 
    my @vs = j.values;
  
    Junction[ jt, map( {&amp;amp;f($_)}, @vs)].new;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要将 Junction 内的函数应用于非 Junction 的参数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub infix:&amp;lt;○●&amp;gt;( \jf, \v ) is export {
    my \jt=jf.junction-type; 
    my @fs = jf.values;

    Junction[ jt, map( {$_( v)}, @fs)].new;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将一个函数应用于两个 junction 参数，相当于将一个 junction 内的函数应用于一个 junction。这里有一个复杂的问题。Raku 对嵌套施加了一个排序，即所有的嵌套总是外嵌套。因此，我们必须检查 junction 的类型，如果需要的话，我们必须交换映射。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub infix:&amp;lt;○○&amp;gt;( \jf, \jv ) is export {
    my \jft= jf.junction-type; 
    my @fs = jf.values;
    my \jvt = jv.junction-type;
    my @vs = jv.values;
    if (jvt == JAll and jft != JAll) {        
        Junction[ jvt, map( sub (\v){jf ○● v}, @vs)].new;  
    } else {        
        Junction[ jft, map( sub (&amp;amp;f){ &amp;amp;f ●○ jv}, @fs)].new;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了完整，这里是 &lt;code&gt;○==●&lt;/code&gt; 的定义。&lt;code&gt;○!=●&lt;/code&gt;、&lt;code&gt;○&amp;gt;●&lt;/code&gt; 等的定义是类似的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub infix:&amp;lt; ○==● &amp;gt;( \j, \v ) is export {
    sub (\x){x==v} ●○ j
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来我们有 &lt;code&gt;so&lt;/code&gt;，它把布尔值的 junction 变成了布尔值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;our sub so (\jv) { 
    my @vs = jv.values;
    given jv.junction-type {
        when JAny { elems(grep {$_},  @vs) &amp;gt;0}
        when JAll { elems(grep {!$_}, @vs)==0}
        when JOne { elems(grep {$_},  @vs)==1}
        when JOne { elems(grep {$_},  @vs)==0}
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后我们有 &lt;code&gt;collapse&lt;/code&gt;，正如&lt;a href=&#34;https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8&#34;&gt;贪婪 Junction 的文章&lt;/a&gt;中所定义的那样， &lt;code&gt;collapse&lt;/code&gt; 返回 Junction 的值，只要它们都是一样的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;our sub collapse( \j ) {
    my \jt=j.junction-type; 
    my @vvs = j.values;
    my $v =  shift @vvs;        
    my @ts = grep {!($_ ~~ $v)}, @vvs;
    if (@ts.elems==0) {  
        $v
    } else {
        die &amp;quot;Can&#39;t collapse this Junction: elements are not identical: {$v,@vvs}&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;junction-清理&#34;&gt;Junction 清理&lt;/h3&gt;
&lt;p&gt;现在我们再来看看我们的工作假说，将 Raku 的 Junction 上的动作解释为上述类型和操作符的语法糖。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sq(Int $x --&amp;gt; Int) { $x*$x }
my Junction $j = 11 | 22; 
my Junction $rj = sq($j); 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;去语法塘后这变成了:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my Junction $j = any_ [11,22];
my Junction $rj = &amp;amp;sq ●○ $j;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类似地,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;if ($j == 42) {...} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;变成了:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;if (so ($j ○==● 42)) {...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和其他布尔上下文类似。&lt;/p&gt;
&lt;p&gt;如果我们仔细看&lt;a href=&#34;https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8&#34;&gt;贪婪 Junction 文章&lt;/a&gt;中的 pair 例子，那么将 junction 应用到一个有多个参数的函数上:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my Junction \p1j = pair R,(42^43);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;去语法塘后变为:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my Junction \p1j = &amp;amp;pair.assuming(R) ●○ one_ [42,43];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们使用 &lt;code&gt;.assuming()&lt;/code&gt; 是因为我们需要部分应用。不管我们是先应用非 Junction 参数还是 Junction 参数，都没有关系。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my \p1jr = ( sub ($y){ &amp;amp;pair.assuming(*,$y) } ●○ one_ [42,43] ) ○● R;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后，举一个两个参数都是 Junction 的例子。由于 &lt;code&gt;○○&lt;/code&gt; 的定义，应用的顺序并不重要。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub m(\x,\y){x*y}

my \p4 = ( sub (\x){ &amp;amp;m.assuming(x) } ●○ any_ [11,22] ) ○○ all_ [33,44];
my \p4r = ( sub (\x){ &amp;amp;m.assuming(*,x) } ●○ all_ [33,44] ) ○○ any_ [11,22];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;结论&#34;&gt;结论&lt;/h3&gt;
&lt;p&gt;从 Raku 的 junction 的神奇类型行为实际上是语法糖的假设出发，我使用多态代数数据类型重构了 junction 类型和它的动作，并表明 Raku 的行为作为语法糖的解释对于所提出的实现是成立的。换句话说，Raku 的 Junction 确实遵循静态类型规则。&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&#34;https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e&#34;&gt;https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/rakulang">rakulang</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/junction">Junction</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/</guid>
                <pubDate>Sun, 04 Oct 2020 00:00:00 +0800</pubDate>
            </item>
        
    </channel>
</rss>


