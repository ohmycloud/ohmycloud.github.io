<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>
            
                    Rakulang on
                
            
            焉知非鱼</title>
        <link>https://ohmyweekly.github.io/tags/rakulang/</link>
        <description>Recent content  in Rakulang
            on 焉知非鱼</description>
        <language>en-us</language>
        <lastBuildDate>Tue, 18 May 2021 22:45:56 +0800</lastBuildDate>
        <generator>Hugo -- gohugo.io</generator>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
            <atom:link href="https://ohmyweekly.github.io/tags/rakulang/index.xml" rel="self" type="application/rss&#43;xml" />
        
            
            <item>
                <title>自定义 when</title>
                <link>https://ohmyweekly.github.io/notes/2021-02-28-custom-when/</link>
                
                
                <description>&lt;blockquote&gt;Custom When&lt;/blockquote&gt;&lt;p&gt;我不太喜欢上一篇文章中使用匹配的语法。它的参数列表中的逗号看起来很奇怪，不合适。也许是因为我的眼睛习惯了给定的块。睡一觉就好了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub accord(&amp;amp;c) { (c(CALLER::&amp;lt;$_&amp;gt;); succeed) if &amp;amp;c.cando(\(CALLER::&amp;lt;$_&amp;gt;)) }

given Err.new(:msg&amp;lt;a&amp;gt;) {
    accord -&amp;gt; Hold (:$key) { put „holding $key“; }
    accord -&amp;gt; Err (:$msg) { warn „ERR: $msg“ }
    default { fail ‚unsupported‘ }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是因为 &lt;code&gt;accord&lt;/code&gt; 模仿了 &lt;code&gt;when&lt;/code&gt; 的工作。它做了一些匹配，当 True 时调用一个块，并在每个块的结尾添加一个 success（通过抛出一个控制异常）。given 所做的只是设置主题。它还充当了 caller 的角色，所以我们可以通过一个伪包来访问它的 &lt;code&gt;$_&lt;/code&gt;。利用 pointy 的签名来做&lt;a href=&#34;https://docs.raku.org/type/Signature#Destructuring_arguments&#34;&gt;解构&lt;/a&gt;是相当强大的。把这个添加到 CORE 中可能是个好主意。&lt;/p&gt;
&lt;p&gt;我们可能要把 Raku 的定义改成: &amp;ldquo;Raku 是一种高度可组合的编程语言&amp;rdquo;, 在这里，所有的东西都会落到实处。&amp;quot;&lt;/p&gt;
&lt;p&gt;更新一下。&lt;/p&gt;
&lt;p&gt;有些情况下，&lt;code&gt;$_&lt;/code&gt; 不是动态的。另外，success 正在抛出一个控制异常，而这些的处理程序是由 when 或默认添加的。这种情况是在编译时发生的，目前不能用宏来解决。第一个问题可以用黑魔法解决。后一个问题需要用默认块。我没有找到一种方法来提供一个合理的错误信息，如果缺少这个块。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;multi sub accord(&amp;amp;c) {
    use nqp;
    $_ := nqp::getlexcaller(&#39;$_&#39;);
    (c($_); succeed) if &amp;amp;c.cando(\($_))
}

for @possibilities.roll(1) -&amp;gt; $needle {
    given $needle {
        accord -&amp;gt; Hold (:$key) { put „holding $key“; }
        accord -&amp;gt; Err (:$msg) { warn „ERR: $msg“ }
        default { warn ‚unsopported‘ }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原文链接: &lt;a href=&#34;https://gfldex.wordpress.com/2021/02/25/custom-when/&#34;&gt;https://gfldex.wordpress.com/2021/02/25/custom-when/&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/raku">Raku</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/rakulang">Rakulang</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-02-28-custom-when/</guid>
                <pubDate>Sun, 28 Feb 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>为最年轻的 Raku 贡献力量</title>
                <link>https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/</link>
                
                
                <description>&lt;blockquote&gt;Contributing to Raku&lt;/blockquote&gt;&lt;p&gt;在过去的几周里，我看到了一些&lt;a href=&#34;https://mydeveloperplanet.com/2021/01/20/how-to-start-contributing-to-open-source/&#34;&gt;文章&lt;/a&gt;和&lt;a href=&#34;https://youtu.be/GAqfMNB-YBU&#34;&gt;视频&lt;/a&gt;，讲述了在开源软件中构思是多么的伟大。这次我又想起了另一篇旧文&lt;a href=&#34;http://strangelyconsistent.org/blog/perl-6-is-my-mmorpg&#34;&gt;Raku 是我的 MMORPG&lt;/a&gt;。它说，你可以从以下几个方面受益于开源软件。比如说，可以做一个大侠，基于一些开源软件来写软件。作为写手，可以写博客、微博等，对所选软件产生兴趣。或者你可以成为一个法师 - 实现新的功能和修复 bug。今天小编就带着弓箭手来告诉大家如何成为 &lt;a href=&#34;https://raku.org/&#34;&gt;Raku&lt;/a&gt; 编程语言的法师。&lt;/p&gt;
&lt;h2 id=&#34;选择一个任务&#34;&gt;选择一个任务&lt;/h2&gt;
&lt;p&gt;让我们挑选一些编译器的 bug，并修复它。让我们去 &lt;a href=&#34;https://rakudo.org/&#34;&gt;Rakudo&lt;/a&gt; 编译器 &lt;a href=&#34;https://github.com/rakudo/rakudo/issues&#34;&gt;issues&lt;/a&gt;中选择我们想要修复的 bug。我滚动了一下 bug 列表，遇到了解析 - 运气不错，我前段时间一直在研究&lt;a href=&#34;https://www.apress.com/gp/book/9781484232279&#34;&gt;编译器语法&lt;/a&gt;，看了一本这方面的好书。找到了四个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rakurs.atroxaper.net/assets/img/posts/2021-02-13-contributing-raku-1.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标签为 LTA （Less Than Awesome - 当真实行为与直觉预期不同时）- 我们暂时把它划掉。&lt;/li&gt;
&lt;li&gt;标签 &amp;ldquo;需要共识&amp;rdquo; - 我们只想修复一个不复杂的 bug - 肯定要划掉。&lt;/li&gt;
&lt;li&gt;标签为 &amp;ldquo;grammar and actions&amp;rdquo; 的关于一个可能死的代码是一个很好的候选人的第一个任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;任务确定后，现在我们需要配置工作环境。在 Windows、Linux 和 macOS 中，一切应该都差不多。我将通过 macOS 的例子来告诉你。&lt;/p&gt;
&lt;h2 id=&#34;建立工作环境&#34;&gt;建立工作环境&lt;/h2&gt;
&lt;p&gt;为源码和我们建立的编译器建立文件夹。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;mkdir ~/dev-rakudo &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; mkdir ~/dev-rakudo-install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Rakudo 编译器由三部分组成。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚拟机。现在有三种 - JVM、JS 和 MoarVM。我们以 MoarVM 为最稳定的一个。&lt;/li&gt;
&lt;li&gt;NQP（Not Quite Perl），是一种低级（中级）语言的实现，它是 Raku 的一个 &amp;ldquo;子集&amp;rdquo;。虚拟机可以执行用 NQP 编写的代码。&lt;/li&gt;
&lt;li&gt;Rakudo 编译器本身，用 NQP 和 Raku 编写。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下载并编译这三个组件。我分别花了一分半钟、半分钟和两分半钟才编好。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ~/dev-rakudo &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git clone git@github.com:MoarVM/MoarVM.git &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; MoarVM
perl Configure.pl --prefix ~/dev-rakudo-install &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -j &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install

&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ~/dev-rakudo &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git clone git@github.com:Raku/nqp.git &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; nqp
perl Configure.pl --backend&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;moar --prefix ~/dev-rakudo-install &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -j &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install

&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ~/dev-rakudo &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git clone git@github.com:rakudo/rakudo.git &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; rakudo
perl Configure.pl --backend&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;moar --prefix ~/dev-rakudo-install &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -j &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意参数。&lt;code&gt;--prefix&lt;/code&gt; 显示了 &lt;code&gt;make install&lt;/code&gt; 命令后可执行文件的复制位置，&lt;code&gt;--backend=moar&lt;/code&gt; 表示正在使用的虚拟机，而 &lt;code&gt;-j 4&lt;/code&gt; 则要求跨多线程并行化（以防加快进度）。现在我们已经建立了 Rakudo 编译器 &lt;code&gt;~/dev-rakudo-install/bin/raku&lt;/code&gt;。我们还需要官方的编译器测试套件。你应该把它和它的代码一起放在文件夹里。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ~/dev-rakudo/rakudo &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git clone https://github.com/Raku/roast.git t/spec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们先进行测试。这种情况很常见，有些测试甚至在新的变化之前就失败了。我们需要辨别出来，这样以后就不会害怕这些变化破坏了一些不必要的东西。&lt;/p&gt;
&lt;p&gt;这里和下面我将在 &lt;code&gt;~/dev-rakudo/rakudo&lt;/code&gt; 文件夹中工作，除非另有说明。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; make spectest
[...]
Test Summary Report
-------------------
t/spec/S32-str/utf8-c8.t    (Wstat: 65280 Tests: 54 Failed: 0)
  Non-zero exit status: 255
  Parse errors: Bad plan.  You planned 66 tests but ran 54.
Files=1346, Tests=117144, 829 wallclock secs (27.70 usr  6.04 sys + 2638.79 cusr 210.98 csys = 2883.51 CPU)
Result: FAIL
make: *** [m-spectest5] Error 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;14分钟内共运行了1,346个文件中的117,144次测试。一些与utf8相关的测试由于某种原因失败了，其他的都能正常工作。我们已经准备好去工作了!&lt;/p&gt;
&lt;h2 id=&#34;让我们来看看问题的陈述&#34;&gt;让我们来看看问题的陈述&lt;/h2&gt;
&lt;p&gt;问题陈述说，某个元运算符 &lt;code&gt;R&lt;/code&gt; 在 colonpair 上出了问题。我打开文档，搜索 R 这个词，但下拉列表中没有这个名字的元运算符。我试着输入 metaop，看到的是反向元操作符(R)。原来，如果你想把二元运算的操作数按相反的顺序写出来，你可以在其符号前使用前缀 R。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;say 3 R- 2 == -1 # Output: True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Colonpair 是命名对的语法。它看起来就像名字前面有一个冒号，前面有一个括号，有一个值。例如 &lt;code&gt;:foo(42)&lt;/code&gt; 是一个名称为 &lt;code&gt;foo&lt;/code&gt;、值为 &lt;code&gt;42&lt;/code&gt; 的对儿。这个语法通常用于在调用函数时，向函数传递一个命名参数中的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sub-with-named-parameter(:$foo) {
    say $foo;
}

sub-with-named-parameter(:foo(42)); # Output: 42
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果一个函数参数不是命名的，而是位置的，那么在用命名对调用时，就会出现编译错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sub-without-named-parameter($foo) { # &amp;lt;- 没有冒号
  say $foo;
}

sub-without-named-parameter(:foo(42)); # Unexpected named argument &#39;foo&#39; passed
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你在调用这样的函数时用括号包围一个参数，整个参数对将被传递到位置参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sub-without-named-parameter($foo) {
  say $foo;
}

sub-without-named-parameter((:foo(42))); # Output: foo =&amp;gt; 42
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 Raku 中，你可以写一个函数来捕获所有传递给它的参数并分析它们。这是在单个参数 - 捕获前用竖线完成的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sub-with-capture(|foo) { # &amp;lt;- 参数捕获
  say foo;
}

sub-with-capture(:foo(42));     # Output: \(:foo(42))
sub-with-capture(42);           # Output: \(42)
sub-with-capture(:foo(3 Z- 2)); # Output: \(:foo((1,).Seq))
sub-with-capture(:foo(3 R- 2)); # Output: \(-1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;倒数第二行使用了 Z 元操作符 - zip 操作符。它将左右两部分作为一个列表，按顺序每次从它们中抽取一个元素，并进行操作，从而形成一个序列。&lt;/p&gt;
&lt;p&gt;在最后一行，只用了我们需要的 R 元操作符。在这种情况下，它不是一个对，而是一个常量，它被传递到函数中。我们可以假设这是元运算符工作方式的一些特殊性，但用 Z 的例子表明并非如此。其实这是一个 bug - 当一个对被传递到一个使用 R 元运算符的函数中时，它的值会被转换。&lt;/p&gt;
&lt;h2 id=&#34;我们需要一个新的测试&#34;&gt;我们需要一个新的测试&lt;/h2&gt;
&lt;p&gt;为了确保未来的变化能够修复错误的行为，我们需要写一个新的测试。在测试文件中不难找到 R 元操作符的测试（&lt;a href=&#34;https://github.com/Raku/roast/blob/fea1d16d993eb851d2935155e0b0d074fa3593bf/S03-metaops/reverse.t&#34;&gt;S03-metops/reverse.t&lt;/a&gt;）。下面我将补充以下测试。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;# https://github.com/rakudo/rakudo/issues/1632
{
  sub subroutine($expected, |actual) {
    is actual.gist, $expected, &amp;quot;Сolonpair exists&amp;quot;
  }

  subroutine(&#39;\(:foo(-1))&#39;, :foo(3 R- 2));
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该测试有一个功能，有两个参数 - 正常和捕获。在函数体中，第一个参数和传递的 Capture 的字符串表示进行比较。你可以使用 &lt;code&gt;make&lt;/code&gt; 对新构建的编译器进行单独测试。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; make t/spec/S03-metaops/reverse.t
[...]
ok 69 - [R~]=
not ok 70 - Colonpair exists
# Failed test &#39;Colonpair exists&#39;
# at t/spec/S03-metaops/reverse.t line 191
# expected: &#39;\(:foo(-1))&#39;
#      got: &#39;\(-1)&#39;
# You planned 69 tests, but ran 70
# You failed 1 test of 70
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以看到，测试失败了（如预期）。还有一个单独的说明，系统预计69次测试，但收到70次。这是基于 TAP 的测试系统的特点 - 必须在文件的顶部修正传递给 &lt;code&gt;plan&lt;/code&gt; 函数的数字。现在测试崩溃了，但编号没有受到影响。你可以开始修复它。&lt;/p&gt;
&lt;h2 id=&#34;凝视法&#34;&gt;凝视法&lt;/h2&gt;
&lt;p&gt;一开始我很相信任务上的标签 - 如果是解析的话，一定是源码解析阶段的某个地方出现了问题。目前我的认识如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基础解析器代码在文件 &lt;code&gt;rakudo/src/Perl6/Grammar.nqp&lt;/code&gt; 中。&lt;/li&gt;
&lt;li&gt;这个解析器是从 &lt;code&gt;nqp/src/HLL/Grammar.nqp&lt;/code&gt; 文件中的基础解析器继承的。&lt;/li&gt;
&lt;li&gt;元操作符的解析和工作方式都差不多，你可以通过仔细观察来发现不同之处。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我在基础解析器代码中找到了对元操作符的引用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;token infix_prefix_meta_operator:sym&amp;lt;R&amp;gt; {
  &amp;lt;sym&amp;gt; &amp;lt;infixish(&#39;R&#39;)&amp;gt; {}
  &amp;lt;.can_meta($&amp;lt;infixish&amp;gt;, &amp;quot;reverse the args of&amp;quot;)&amp;gt;
  &amp;lt;O=.revO($&amp;lt;infixish&amp;gt;)&amp;gt;
}

token infix_prefix_meta_operator:sym&amp;lt;Z&amp;gt; {
  &amp;lt;sym&amp;gt; &amp;lt;infixish(&#39;Z&#39;)&amp;gt; {}
  &amp;lt;.can_meta($&amp;lt;infixish&amp;gt;, &amp;quot;zip with&amp;quot;)&amp;gt;
  &amp;lt;O(|%list_infix)&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这需要对 Raku grammar 有一定的了解。据我所知，原来这两个元运算符在解析上并没有根本的区别。一段时间后，在解析器的源代码中挖得够多了，我开始怀疑解析工作是否正确。认为代码 &lt;code&gt;my $r = :foo(3 R- 2); say $r; # Output: foo =&amp;gt; -1&lt;/code&gt; 正确工作的建议 - 问题恰恰发生在调用函数时。显然，我白白相信了任务栏上的标签。&lt;/p&gt;
&lt;h2 id=&#34;编译器将帮助我们&#34;&gt;编译器将帮助我们&lt;/h2&gt;
&lt;p&gt;颇为迟钝的我想起了我从一开始就应该做的事情。Rakudo 编译器有 &lt;code&gt;--target&lt;/code&gt; 调试开关。它取编译器阶段的名称，你想将其结果输出到控制台并退出。我想看看 &lt;code&gt;--target=parse&lt;/code&gt;（因为我只知道这一个）。&lt;/p&gt;
&lt;p&gt;我从 &lt;code&gt;~/dev-rakudo/rakudo&lt;/code&gt; 文件夹中使用 &lt;code&gt;rakumo-m&lt;/code&gt;，这样我就不必等待通过 &lt;code&gt;make install&lt;/code&gt; 命令将所需文件复制到 &lt;code&gt;~/dev-rakudo-install&lt;/code&gt;。简单的脚本可以这样运行。更复杂的脚本必须在 &lt;code&gt;make install&lt;/code&gt; 之后从 &lt;code&gt;-install&lt;/code&gt; 中运行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; cat ~/test.raku
sub s(|c) { say c }
s(:foo(3 R- 2));
s(:foo(3 Z- 2));

&amp;gt; ./rakudo-m --target=parse ~/test.raku
[...]
- args: (:foo(3 R- 2))
  - semiarglist: :foo(3 R- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 R- 2)
        - colonpair: :foo(3 R- 2)
          - identifier: foo
          - coloncircumfix: (3 R- 2)
            - circumfix: (3 R- 2)
              - semilist: 3 R- 2
                - statement: 1 matches
                  - EXPR: R- 2
[...]
- args: (:foo(3 Z- 2))
  - semiarglist: :foo(3 Z- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 Z- 2)
        - colonpair: :foo(3 Z- 2)
          - identifier: foo
          - coloncircumfix: (3 Z- 2)
            - circumfix: (3 Z- 2)
              - semilist: 3 Z- 2
                - statement: 1 matches
                  - EXPR: Z- 2
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结论：R 和 Z 的解析是一样的。&lt;/p&gt;
&lt;h2 id=&#34;这不是解析&#34;&gt;这不是解析&lt;/h2&gt;
&lt;p&gt;所有被解析的东西都会被传递给所谓的 Action，把字词变成一棵语法树。在我们的例子中，Actions 位于文件 &lt;code&gt;rakudo/src/Perl6/Actions.nqp&lt;/code&gt; 和 &lt;code&gt;nqp/src/HLL/Actions.nqp&lt;/code&gt; 中。这里就比较容易搞清楚了，毕竟是代码，是 grammar。&lt;/p&gt;
&lt;p&gt;我在主 Actions 中找到了以下代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
elsif $&amp;lt;infix_prefix_meta_operator&amp;gt; {
[...]
  if    $metasym eq &#39;R&#39; { $helper := &#39;&amp;amp;METAOP_REVERSE&#39;; $t := nqp::flip($t) if $t; }
  elsif $metasym eq &#39;X&#39; { $helper := &#39;&amp;amp;METAOP_CROSS&#39;; $t := nqp::uc($t); }
  elsif $metasym eq &#39;Z&#39; { $helper := &#39;&amp;amp;METAOP_ZIP&#39;; $t := nqp::uc($t); }
  
  my $metapast := QAST::Op.new( :op&amp;lt;call&amp;gt;, :name($helper), WANTED($basepast,&#39;infixish&#39;) );
  $metapast.push(QAST::Var.new(:name(baseop_reduce($base&amp;lt;OPER&amp;gt;&amp;lt;O&amp;gt;.made)), :scope&amp;lt;lexical&amp;gt;))
    if $metasym eq &#39;X&#39; || $metasym eq &#39;Z&#39;;
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它说，如果在代码中解析了元操作符 &lt;code&gt;R&lt;/code&gt;、&lt;code&gt;Z&lt;/code&gt; 或 &lt;code&gt;X&lt;/code&gt;，就应该在语法树中添加一些 &lt;code&gt;METAOP_&lt;/code&gt; 函数调用。在 &lt;code&gt;Z&lt;/code&gt; 和 &lt;code&gt;X&lt;/code&gt; 的情况下，它会多一个参数，即某种还原函数。所有这些功能都可以在 &lt;code&gt;rakudo/src/core.c/metaops.pm6&lt;/code&gt; 中找到。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub METAOP_REVERSE(\op) is implementation-detail {
  -&amp;gt; |args { op.(|args.reverse) }
}

sub METAOP_ZIP(\op, &amp;amp;reduce) is implementation-detail {
 nqp::if(op.prec(&#39;thunky&#39;).starts-with(&#39;.&#39;),
  -&amp;gt; +lol {
    my $arity = lol.elems;
    [...]
  },
  -&amp;gt; +lol {
    Seq.new(Rakudo::Iterator.ZipIterablesOp(lol,op))
  }
  )
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;给你：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;\op&lt;/code&gt; 是由我们的元操作符，即-，在前面的操作。&lt;/li&gt;
&lt;li&gt;Trait &lt;code&gt;implementation-detail&lt;/code&gt; 只是表明这不是公共代码，是编译器实现的一部分。&lt;/li&gt;
&lt;li&gt;由于-操作没有笨重的特性，所以 &lt;code&gt;&amp;amp;reduce&lt;/code&gt; 函数不会参与计算，&lt;code&gt;Z&lt;/code&gt; 的结果是 &lt;code&gt;Seq.new(...)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt; 的结果是一个操作调用 - 参数顺序相反。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这时我想起还有一个 - 目标，即星。它将显示行动的结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ./rakudo-m --target=ast ~/test.raku
[...]
- QAST::Op(call &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&amp;lt;foo&amp;gt;) &amp;lt;wanted&amp;gt; :statement_id&amp;lt;5&amp;gt; :before_promotion&amp;lt;?&amp;gt; R-
    - QAST::Op(call &amp;amp;METAOP_REVERSE) &amp;lt;wanted&amp;gt; :is_pure&amp;lt;?&amp;gt;
      - QAST::Var(lexical &amp;amp;infix:&amp;lt;-&amp;gt;) &amp;lt;wanted&amp;gt;
    - QAST::Want &amp;lt;wanted&amp;gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &amp;lt;wanted&amp;gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
- QAST::Op(call &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;7&amp;gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(:named&amp;lt;foo&amp;gt;) &amp;lt;wanted&amp;gt; :statement_id&amp;lt;8&amp;gt; :before_promotion&amp;lt;?&amp;gt; Z-
    - QAST::Op(call &amp;amp;METAOP_ZIP) &amp;lt;wanted&amp;gt; :is_pure&amp;lt;?&amp;gt;
      - QAST::Var(lexical &amp;amp;infix:&amp;lt;-&amp;gt;) &amp;lt;wanted&amp;gt;
      - QAST::Var(lexical &amp;amp;METAOP_REDUCE_LEFT)
    - QAST::Want &amp;lt;wanted&amp;gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &amp;lt;wanted&amp;gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一如所料。除了调用不同的 &lt;code&gt;METAOP_&lt;/code&gt; 函数外，所有的东西几乎都是一样的。从它们的代码中我们可以知道，原则上这些函数的不同之处在于返回值的类型 - 分别是 &lt;code&gt;Int&lt;/code&gt; 和 &lt;code&gt;Seq&lt;/code&gt;。众所周知，Raku 对不同类型的对象的上下文相当敏感&amp;hellip;&amp;hellip;我想，它关注的可能是返回值。我试着用下面的方式修改代码。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub METAOP_REVERSE(\op) is implementation-detail {
  -&amp;gt; |args { Seq.new(op.(|args.reverse)) }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译、运行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; make
[...]
Stage start      :   0.000
Stage parse      :  61.026
Stage syntaxcheck:   0.000
Stage ast        :   0.000
Stage optimize   :   7.076
Stage mast       :  14.120
Stage mbc        :   3.941
[...]
&amp;gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一切都没有改变。所以，不是返回值&amp;hellip;&amp;hellip;想了想，不知道为什么结果又是 &lt;code&gt;-1&lt;/code&gt; 而不是 &lt;code&gt;(-1,).Seq&lt;/code&gt;。而且，从代码来看，&lt;code&gt;Seq&lt;/code&gt; 根本就没有一个合适的构造函数。下一次，作为一些疯狂的事情，我尝试调用 &lt;code&gt;METAOP_REVERSE&lt;/code&gt; 结果只是为了崩溃。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub METAOP_REVERSE(\op) is implementation-detail {
  -&amp;gt; |args { die }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译、运行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; make
[...]
&amp;gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;怎么会呢？语法树中包含了对 &lt;code&gt;METAOP_REVERSE&lt;/code&gt; 的调用，它的代码应该是折叠的，但计算仍然进行，我们得到 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这些都不是《行动》。&lt;/p&gt;
&lt;p&gt;这里我的目光落在编译器的构建日志上。它是一些阶段被列在那里。我随机试了 &lt;code&gt;--target=mast&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ./rakudo-m --target=mast ~/test.raku
[...]
MAST::Frame name&amp;lt;s&amp;gt;, cuuid&amp;lt;1&amp;gt;
  Local types: 0&amp;lt;obj&amp;gt;, 1&amp;lt;obj&amp;gt;, 2&amp;lt;obj&amp;gt;, 3&amp;lt;obj&amp;gt;, 4&amp;lt;int&amp;gt;, 5&amp;lt;str&amp;gt;, 6&amp;lt;obj&amp;gt;, 7&amp;lt;obj&amp;gt;, 8&amp;lt;obj&amp;gt;,
  Lexical types: 0&amp;lt;obj&amp;gt;, 1&amp;lt;obj&amp;gt;, 2&amp;lt;obj&amp;gt;, 3&amp;lt;obj&amp;gt;, 4&amp;lt;obj&amp;gt;,
  Lexical names: 0&amp;lt;c&amp;gt;, 1&amp;lt;$¢&amp;gt;, 2&amp;lt;$!&amp;gt;, 3&amp;lt;$/&amp;gt;, 4&amp;lt;$*DISPATCHER&amp;gt;,
  Lexical map: $!&amp;lt;2&amp;gt;, c&amp;lt;0&amp;gt;, $*DISPATCHER&amp;lt;4&amp;gt;, $¢&amp;lt;1&amp;gt;, $/&amp;lt;3&amp;gt;,
  Outer: name&amp;lt;&amp;lt;unit&amp;gt;&amp;gt;, cuuid&amp;lt;2&amp;gt;
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;某种不可读的矩阵。星号和桅杆之间有一个阶段性的优化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ./rakudo-m --target=optimize ~/test.raku
[...]
- QAST::Op(callstatic &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;amp;infix:&amp;lt;-&amp;gt;)  :METAOP_opt_result&amp;lt;?&amp;gt;
    - QAST::Want &amp;lt;wanted&amp;gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
    - QAST::Want &amp;lt;wanted&amp;gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
[...]
- QAST::Op(callstatic &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;7&amp;gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&amp;lt;foo&amp;gt;) &amp;lt;wanted&amp;gt; :statement_id&amp;lt;8&amp;gt; :before_promotion&amp;lt;?&amp;gt; Z-
    - QAST::Op(callstatic &amp;amp;METAOP_ZIP) &amp;lt;wanted&amp;gt; :is_pure&amp;lt;?&amp;gt;
      - QAST::Var(lexical &amp;amp;infix:&amp;lt;-&amp;gt;) &amp;lt;wanted&amp;gt;
      - QAST::Var(lexical &amp;amp;METAOP_REDUCE_LEFT)
    - QAST::Want &amp;lt;wanted&amp;gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &amp;lt;wanted&amp;gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;哈，就是这样。在优化阶段后，行将失踪。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;QAST::Op+{QAST::SpecialArg}(call :named&amp;lt;foo&amp;gt;) &amp;lt;wanted&amp;gt; :statement_id&amp;lt;5&amp;gt; :before_promotion&amp;lt;?&amp;gt; R-.&lt;/code&gt;
并将整个 &lt;code&gt;METAOP_REVERSE&lt;/code&gt; 调用替换为通常的操作 &lt;code&gt;(&amp;amp;infix:&amp;lt;-&amp;gt;)&lt;/code&gt;。所以问题一定在优化器的某个地方。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只有在 &lt;code&gt;optim_nameless_call&lt;/code&gt; 方法中才会提到 &lt;code&gt;&amp;amp;METAOP_ASSIGN&lt;/code&gt;，其中 &lt;code&gt;QAST::Op+{QAST::SpecialArg}(call :named&amp;lt;foo&amp;gt;)&lt;/code&gt;。显然，这个操作负责生成一个命名对 - 它已经有了一个名字（命名参数），它需要计算值。从优化 &lt;code&gt;_&lt;/code&gt; 无名方法的执行路径来看，我们可以得出结论，我们对最后一个块感兴趣。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
  elsif self.op_eq_core($metaop, &#39;&amp;amp;METAOP_REVERSE&#39;) {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;amp;&amp;amp; nqp::elems($op) == 3;
    return QAST::Op.new(:op&amp;lt;call&amp;gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: &#39;METAOP_opt_result&#39;, 1;
  }
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;让我提醒你，优化前的树是这样的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
- QAST::Op(call &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&amp;lt;foo&amp;gt;) &amp;lt;wanted&amp;gt; :statement_id&amp;lt;5&amp;gt; :before_promotion&amp;lt;?&amp;gt; R-
    - QAST::Op(call &amp;amp;METAOP_REVERSE) &amp;lt;wanted&amp;gt; :is_pure&amp;lt;?&amp;gt;
      - QAST::Var(lexical &amp;amp;infix:&amp;lt;-&amp;gt;) &amp;lt;wanted&amp;gt;
    - QAST::Want &amp;lt;wanted&amp;gt; 3
    - QAST::Want &amp;lt;wanted&amp;gt; 2
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而精简之后，是这样的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
- QAST::Op(callstatic &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;amp;infix:&amp;lt;-&amp;gt;)  :METAOP_opt_result&amp;lt;?&amp;gt;
    - QAST::Want &amp;lt;wanted&amp;gt; 2
    - QAST::Want &amp;lt;wanted&amp;gt; 3
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说，优化 &lt;code&gt;_nameless_call&lt;/code&gt; 做了以下工作。&lt;/p&gt;
&lt;p&gt;如果我们的 &lt;code&gt;QAST::Op+{QAST::SpecialArg}&lt;/code&gt; 操作没有三个参数，如果 &lt;code&gt;METAOP_REVERSE&lt;/code&gt; 调用没有一个正确的类型，我们就返回空。这不是我们的情况。
否则，我们将返回一个新的操作，代替我们的 &lt;code&gt;QAST::Op+{QAST::SpecialArg}&lt;/code&gt; 操作，以相反的顺序调用 &lt;code&gt;&amp;amp;infix:&amp;lt;-&amp;gt;&lt;/code&gt; 参数。就是说，把结果打包成一对就没了。&lt;/p&gt;
&lt;p&gt;在摸索了一下如何解决这个问题，并阅读了 &lt;code&gt;QAST::SpecialArg&lt;/code&gt; 和 &lt;code&gt;QAST::Node&lt;/code&gt; 的实现后，我想到了下面的代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
  elsif self.op_eq_core($metaop, &#39;&amp;amp;METAOP_REVERSE&#39;) {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;amp;&amp;amp; nqp::elems($op) == 3;
    my $opt_result := QAST::Op.new(:op&amp;lt;call&amp;gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: &#39;METAOP_opt_result&#39;, 1;
    if $op.named { $opt_result.named($op.named) } # 添加选项 named 
    if $op.flat { $opt_result.flat($op.flat) }    # 添加选项 flat
    return $opt_result;
  }
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还有木头。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
- QAST::Op(callstatic &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call &amp;amp;infix:&amp;lt;-&amp;gt; :named&amp;lt;foo&amp;gt;)  :METAOP_opt_result&amp;lt;?&amp;gt;
    - QAST::Want &amp;lt;wanted&amp;gt; 2
    - QAST::Want &amp;lt;wanted&amp;gt; 3
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命名的参数返回到它的位置。测试也开始通过。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; make t/spec/S03-metaops/reverse.t
[...]
All tests successful.
Files=1, Tests=70,  3 wallclock secs ( 0.03 usr  0.01 sys +  3.61 cusr  0.17 csys =  3.82 CPU)
Result: PASS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们本可以就此打住，但这是编译器优化器的代码，它的结果是一个有两个整数参数的方法调用。我认为这在某种程度上是次优的。如果我们将返回表达式改为返回 &lt;code&gt;self.visit_op: $opt_result;&lt;/code&gt;，对产生的非优化操作调用优化器，那么产生的树就会像这样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
- QAST::Op(callstatic &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Want+{QAST::SpecialArg}(:named&amp;lt;foo&amp;gt;)
    - QAST::WVal+{QAST::SpecialArg}(Int :named&amp;lt;foo&amp;gt;)
    - QAST::IVal(-1)
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在一切都很理想。&lt;/p&gt;
&lt;h2 id=&#34;分享成果&#34;&gt;分享成果&lt;/h2&gt;
&lt;p&gt;我们已经到了终点线。现在我们只需要分享我们的经验。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重要的是：运行所有的 &lt;code&gt;make spectest&lt;/code&gt; 测试，确保没有新的东西被破坏。&lt;/li&gt;
&lt;li&gt;在 GitHub 上使用 Rakudo 编译器和测试制作 fork 仓库。&lt;/li&gt;
&lt;li&gt;将 fork 仓库添加为新的 git 远程仓库。&lt;/li&gt;
&lt;li&gt;cd ~/dev-rakudo/rakudo &amp;amp;&amp;amp; git remote add fork &lt;!-- raw HTML omitted --&gt;。&lt;/li&gt;
&lt;li&gt;cd ~/dev-rakudo/t/spec &amp;amp;&amp;amp; git remote add fork &lt;!-- raw HTML omitted --&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重要：确保两个仓库在 git 中都有正确的用户名和用户邮箱。&lt;/p&gt;
&lt;p&gt;提交到两个版本库，详细说明你为什么做了哪些改动，并添加对原始问题跟踪器的引用。&lt;/p&gt;
&lt;p&gt;运行提交。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd ~/dev-rakudo/rakudo &amp;amp;&amp;amp; git push fork
cd ~/dev-rakudo/t/spec &amp;amp;&amp;amp; git push fork
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向两个仓库提出拉取请求。在他们的描述中，最好是相互参照和原任务。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;对开源软件的贡献是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;趣味性和趣味性。&lt;/li&gt;
&lt;li&gt;给你的感觉是，你正在做一些有用的事情，你真的是。&lt;/li&gt;
&lt;li&gt;让你认识新的有趣和专业的人（任何关于 Raku 的问题都会在 &lt;code&gt;#raku IRC&lt;/code&gt; 频道中得到回答）。&lt;/li&gt;
&lt;li&gt;解决非标准任务，没有截止日期的压力，是一种很好的体验。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选择你觉得最舒服的角色等级，去做新的任务吧!&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/rakulang">rakulang</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/rakulang">Rakulang</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/</guid>
                <pubDate>Tue, 16 Feb 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>Caesarean Substrings With Raku and Perl</title>
                <link>https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/</link>
                
                
                <description>&lt;blockquote&gt;Caesarean Substrings With Raku and Perl&lt;/blockquote&gt;&lt;p&gt;[113] 发表于2021年1月30日。
这是我对 &lt;a href=&#34;https://perlweeklychallenge.org/blog/perl-weekly-challenge-097/&#34;&gt;Perl 每周挑战#097&lt;/a&gt; 的回应。&lt;/p&gt;
&lt;h2 id=&#34;挑战-0971-凯撒密码&#34;&gt;挑战 #097.1: 凯撒密码&lt;/h2&gt;
&lt;p&gt;给你一个只包含字母 &lt;code&gt;A..Z&lt;/code&gt; 的字符串 &lt;code&gt;$S&lt;/code&gt; 和一个数字 &lt;code&gt;$N&lt;/code&gt;。
写一个脚本，用&lt;a href=&#34;https://en.wikipedia.org/wiki/Caesar_cipher&#34;&gt;凯撒密码&lt;/a&gt;对给定的字符串 &lt;code&gt;$S&lt;/code&gt; 进行加密，左移大小为 &lt;code&gt;$N&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例子:
输入: $S = &amp;ldquo;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&amp;rdquo;, $N = 3
输出: &amp;ldquo;QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Plain:    ABCDEFGHIJKLMNOPQRSTUVWXYZ
Cipher:   XYZABCDEFGHIJKLMNOPQRSTUVW&lt;/p&gt;
&lt;p&gt;Plaintext:  THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG
Ciphertext: QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD&lt;/p&gt;
&lt;p&gt;&amp;ldquo;只用字母 &lt;code&gt;A...Z&lt;/code&gt;&amp;rdquo; 的表述是错误的，因为例子中也有几个空格。因此，应该允许这些空格。&lt;/p&gt;
&lt;p&gt;文件: caesar-cipher&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;#! /usr/bin/env raku

subset AZ-space of Str where /^ &amp;lt;[ A .. Z \s ]&amp;gt;+ $/;   # [1]
subset PosInt of Int where -25 &amp;lt;= $_ &amp;lt;= 25;            # [2]

unit sub MAIN (AZ-space $S = &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39;,
               PosInt $N = 3);                         # [3]

say $S.comb.map({ caesar($_, $N) }).join;              # [4]

sub caesar ($char, $shift)
{
  return $char if $char eq &amp;quot; &amp;quot;;                        # [5]

  my $code = $char.ord;                                # [6]

  $code -= $shift;                                     # [7]

  $code += 26 if $code &amp;lt; 65;  # &#39;A&#39;                    # [8]
  $code -= 26 if $code &amp;gt; 90;  # &#39;Z&#39;                    # [8a]

  return $code.chr;                                    # [9]
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[1] 所允许的字符 (或 «特定领域字母»).&lt;/p&gt;
&lt;p&gt;[2] 挑战说左移值是一个数字。允许除整数以外的任何东西是没有意义的，所以我把值限制在这个类型。负值应该是可以的，它们意味着右移值（而不是左移）。&lt;/p&gt;
&lt;p&gt;[3] 参数，默认值为挑战中给出的值。&lt;/p&gt;
&lt;p&gt;[4] 将字符串分割成单个字符（用梳子(comb)，在每个字符上应用 &amp;ldquo;caesar&amp;rdquo; 函数（用map），再次将字符连接成一个字符串（用join），然后打印出来。&lt;/p&gt;
&lt;p&gt;[5] 不移动空格。&lt;/p&gt;
&lt;p&gt;[6] 获取字符的代码点。&lt;/p&gt;
&lt;p&gt;[7] 减去移位值（当我们向左移位时，或在字母表中降低移位值）。&lt;/p&gt;
&lt;p&gt;[8] 绕回, 如果我们移出A-Z范围，这里为更低 - 或更高的 [8b]。&lt;/p&gt;
&lt;p&gt;[9] 获取指定代码点的字符。&lt;/p&gt;
&lt;p&gt;查看 docs.raku.org/routine/ord 获取更多关于 ord 的信息。&lt;/p&gt;
&lt;p&gt;查看 docs.raku.org/routine/chr 获取更多关于 chr 的信息。&lt;/p&gt;
&lt;p&gt;运行它:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./caesar-cipher &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Raku 有一个 ords 变体，它接收一整个字符串，而不是一个字符作为 ord。还有 chrs，它接收一个代码点数组，并将它们变成一个字符串，而不是像 chr 那样接收一个字符的代码点。让我们用它们来写一个更短的程序。&lt;/p&gt;
&lt;p&gt;文件: caesar-cipher-map&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;#! /usr/bin/env raku

subset AZ-space of Str where /^ &amp;lt;[ A .. Z \s ]&amp;gt;+ $/;
subset PosInt of Int where -25 &amp;lt;= $_ &amp;lt;= 25;

unit sub MAIN (AZ-space $S = &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39;,
               PosInt $N = 3);

say caesar($S, $N);

sub caesar ($string, $shift)
{
  return $string.ords.map({$_ == 32 ?? 32 !! (($_ - $shift - 65) % 26 ) + 65}).chrs;
    # #################### # 1a ############# ############ # 1b  # 1c ## 1d
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[1] 我们使用map来改变各个代码点。我们让代码点为32的空间单独存在[1a]。每一个其他的值我们都还原成0到25之间的数字（通过减去第一个字母的代码点（A：65）和移位值[1b]）。模数运算符 (%) 为我们处理负值，做正确的事情。例如：-2 % 26 -&amp;gt; 24 [1c]。然后我们添加调整值到它们应该在的位置(从A到Z)[1d]，然后我们将整个数组的代码点变成一个字符串。&lt;/p&gt;
&lt;p&gt;查看 docs.raku.org/routine/ords 获取更多关于 ords 的信息。&lt;/p&gt;
&lt;p&gt;查看 docs.raku.org/routine/chrs 获取更多关于 chrs 的信息。&lt;/p&gt;
&lt;p&gt;运行它的结果和之前一样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./caesar-cipher-map &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher-map &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher-map &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher-map &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;perl-版本&#34;&gt;Perl 版本&lt;/h2&gt;
&lt;p&gt;这是对第一个 Raku 版的直接翻译。&lt;/p&gt;
&lt;p&gt;File: caesar-cipher-perl&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span class=&#34;ch&#34;&gt;#! /usr/bin/env perl&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;use&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;strict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;use&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;warnings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;use&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;feature&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#39;say&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;use&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;feature&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#39;signatures&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;no&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;warnings&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;experimental::signatures&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;my&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$S&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;shift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;@ARGV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;sr&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;nb&#34;&gt;die&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Illegal characters&amp;#34;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;unless&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$S&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=~&lt;/span&gt;&lt;span class=&#34;sr&#34;&gt; /^[A-Z\s]+$/&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;my&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;shift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;@ARGV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;sr&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;nb&#34;&gt;die&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Illegal shift $N&amp;#34;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!~&lt;/span&gt; &lt;span class=&#34;sr&#34;&gt;/^\-?\d+$/&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;say&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;map&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;caesar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;split&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sr&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;sub&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;caesar&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;($char, $shift)
&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$char&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$char&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;eq&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;k&#34;&gt;my&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;ord&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

  &lt;span class=&#34;nv&#34;&gt;$code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$shift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;nv&#34;&gt;$code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;26&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;65&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# &amp;#39;A&amp;#39;&lt;/span&gt;
  &lt;span class=&#34;nv&#34;&gt;$code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;26&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;90&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# &amp;#39;Z&amp;#39;&lt;/span&gt;

  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;chr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行它的结果和 Raku 版一样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./caesar-cipher-perl &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher-perl &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher-perl &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher-perl &#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39; -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;挑战-0972二进制子字符串binary-substrings&#34;&gt;挑战 #097.2：二进制子字符串(Binary Substrings)&lt;/h2&gt;
&lt;p&gt;给你一个二进制字符串 &lt;code&gt;$B&lt;/code&gt; 和一个整数 &lt;code&gt;$S&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;写一个脚本来拆分大小为 &lt;code&gt;$S&lt;/code&gt; 的二进制字符串 &lt;code&gt;$B&lt;/code&gt;，然后找出使其相同的最小翻转次数。&lt;/p&gt;
&lt;p&gt;例 1:
输入: $B = “101100101”, $S = 3
输出: 1&lt;/p&gt;
&lt;p&gt;二进制子字符串:
&amp;ldquo;101&amp;rdquo;: 0 flip
&amp;ldquo;100&amp;rdquo;: 1 flip to make it &amp;ldquo;101&amp;rdquo;
&amp;ldquo;101&amp;rdquo;: 0 flip&lt;/p&gt;
&lt;p&gt;例 2:
输入 $B = “10110111”, $S = 4
输出: 2&lt;/p&gt;
&lt;p&gt;二进制子字符串:
&amp;ldquo;1011&amp;rdquo;: 0 flip
&amp;ldquo;0111&amp;rdquo;: 2 flips to make it &amp;ldquo;1011&amp;rdquo;&lt;/p&gt;
&lt;p&gt;我们先从第一个例子中的二进制子字符串中砍掉3个字符块。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; say &amp;quot;101100101&amp;quot;.comb(3);   # -&amp;gt; (101 100 101)
&amp;gt; say &amp;quot;1011001010&amp;quot;.comb(3);  # -&amp;gt; (101 100 101 0)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二行显示了如果长度不匹配会发生什么。这就给了我们一个非法的值，因为我们不能将一位数翻转为三位数的值。所以我们必须添加一个检查。&lt;/p&gt;
&lt;p&gt;然后我们将第一个子串与其余的子串进行比较，一次一个。在这里使用bitwise XOR（Exclusive OR）运算符是一个合理的选择。这给了我们一个二进制值，其中1的数量就是该子串的翻转次数。Raku确实有一个XOR运算符。+^. 但是它 &amp;ldquo;将两个参数都强制为Int，并进行位智XOR操作&amp;rdquo;(根据文档&amp;quot;；参见docs.raku.org/language/operators#infix_+^)。&lt;/p&gt;
&lt;p&gt;我们可以在进行XOR操作之前，将二进制值转换为十进制值。让我们试试。&lt;/p&gt;
&lt;p&gt;获取翻转的次数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; say (&amp;quot;10101&amp;quot;.parse-base(2) +^ &amp;quot;10111&amp;quot;.parse-base(2)).base(2).comb.sum;  # -&amp;gt; 1
&amp;gt; say (&amp;quot;11101&amp;quot;.parse-base(2) +^ &amp;quot;10111&amp;quot;.parse-base(2)).base(2).comb.sum;  # -&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这当然可行，但需要大量的代码。所以我将使用一个更简单的方法 - 逐个比较每个数字。&lt;/p&gt;
&lt;p&gt;File: binary-substring&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;#! /usr/bin/env raku

subset BinaryString where /^ &amp;lt;[01]&amp;gt;+ $/;                    # [1]
subset PosInt of Int where * &amp;gt; 0;                           # [2]

unit sub MAIN (BinaryString $B = &#39;101100101&#39;,               # [1]
               PosInt $S where $B.chars %% $S = 3,          # [2]
	       :v(:$verbose));

my @B     = $B.comb($S.Int);                                # [3]
my $first = @B.shift;                                       # [4]
my $total = 0;                                              # [5]

for @B -&amp;gt; $current                                          # [6]
{
  my $flip = bit-diff($first, $current);                    # [7]
  $total += $flip;                                          # [8]
  say &amp;quot;: $first -&amp;gt; $current -&amp;gt; Flip: $flip&amp;quot; if $verbose;
}

say $total;                                                 # [9]

sub bit-diff ($a, $b)                                       # [7]
{
  my $flip = 0;                                             # [10]

  for ^$a.chars -&amp;gt; $index                                   # [11]
  {
    $flip++ if $a.substr($index,1) ne $b.substr($index,1);  # [12]
  }

  return $flip;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[1] 确保二进制字符串是合法的（只包含 &amp;ldquo;0 &amp;ldquo;和 &amp;ldquo;1&amp;rdquo;）。&lt;/p&gt;
&lt;p&gt;[2] 确保是一个正整数，同时确保字符串是被它偶数分割的。(例如，&amp;ldquo;4 &amp;ldquo;给我们提供了长度为4的子串，如果最后一个较短，程序将中止。)&lt;/p&gt;
&lt;p&gt;[3] 梳子通常用于将一个字符串分割成单个字符，但我们可以通过指定长度来获得每个子字符串中的多个字符，比如这样。&lt;/p&gt;
&lt;p&gt;[4] 例子首先将第一个子串与自己进行比较，给出零翻转。这是愚蠢的(ish)，所以我跳过这一点，把第一个子串移出。&lt;/p&gt;
&lt;p&gt;[5] 结果会到这里。&lt;/p&gt;
&lt;p&gt;[6] 对于每一个子串（除了第一个，见[4]）。&lt;/p&gt;
&lt;p&gt;[7] 获取每个子串的翻转次数。&lt;/p&gt;
&lt;p&gt;[8] 并将其添加到总数中。&lt;/p&gt;
&lt;p&gt;[9] 打印它。&lt;/p&gt;
&lt;p&gt;[10] 翻转的数量会在这里。&lt;/p&gt;
&lt;p&gt;[11] 对于两个子串中的每个索引（具有相同的长度）。&lt;/p&gt;
&lt;p&gt;[12] - 如果给定位置上的字符不同，则在总数的基础上加1，意味着移动。&lt;/p&gt;
&lt;p&gt;See docs.raku.org/routine/comb for more information about comb.&lt;/p&gt;
&lt;p&gt;运行它。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./binary-substring &amp;quot;101100101&amp;quot; 3
 1

$ ./binary-substring -v &amp;quot;101100101&amp;quot; 3
: 101 -&amp;gt; 100 -&amp;gt; Flip: 1
: 101 -&amp;gt; 101 -&amp;gt; Flip: 0
1

$ ./binary-substring &amp;quot;10110111&amp;quot; 4
2

$ ./binary-substring -v &amp;quot;10110111&amp;quot; 4
: 1011 -&amp;gt; 0111 -&amp;gt; Flip: 2
2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看起来不错。&lt;/p&gt;
&lt;h2 id=&#34;perl&#34;&gt;Perl&lt;/h2&gt;
&lt;p&gt;这是对 Raku 版本的直接翻译，只是我必须实现 &amp;ldquo;comb&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;文件： binary-substring-perl&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;#! /usr/bin/env perl

use strict;
use warnings;
use feature &#39;say&#39;;
use feature &#39;signatures&#39;;
use Getopt::Long;

no warnings &amp;quot;experimental::signatures&amp;quot;;

my $verbose = 0;

GetOptions(&amp;quot;verbose&amp;quot;  =&amp;gt; \$verbose);

my $B = shift(@ARGV) // &#39;101100101&#39;;

die &amp;quot;Not a binary number&amp;quot; unless $B =~ /^[01]+$/;

my $S = shift(@ARGV) // 3;

die &amp;quot;Not an integer&amp;quot; unless $S =~ /^[1-9][0-9]*$/;
die &amp;quot;Not a legal length&amp;quot; if length($B) % $S;

my @B     =  comb($B, $S);
my $first = shift(@B);
my $total = 0;

for my $current (@B)
{
  my $flip = bit_diff($first, $current);
  $total += $flip;
  say &amp;quot;: $first -&amp;gt; $current -&amp;gt; Flip: $flip&amp;quot; if $verbose;
}

say $total;

sub bit_diff ($a, $b)
{
  my $flip = 0;

  for my $index (0 .. length($a))
  {
    $flip++ if substr($a, $index,1) ne substr($b, $index,1);
  }

  return $flip;
}

sub comb ($string, $length = 1)  # [1]
{
  my @result;

  while ($string)
  {
    push(@result, substr($string, 0, $length));
    $string = substr($string, $length);
  }
  return @result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[1] 缺失的 Raku 例程 &amp;ldquo;comb&amp;rdquo;。可选的第二个参数指定了它所返回的每个子串中所包含的（第一个参数的）子串长度。&lt;/p&gt;
&lt;p&gt;运行它的结果与 Raku 版本相同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./binary-substring-perl &amp;quot;101100101&amp;quot; 3
1

$ ./binary-substring-perl -v &amp;quot;101100101&amp;quot; 3
: 101 -&amp;gt; 100 -&amp;gt; Flip: 1
: 101 -&amp;gt; 101 -&amp;gt; Flip: 0
1

$ ./binary-substring-perl &amp;quot;101100111&amp;quot; 3
2

$ ./binary-substring-perl -v &amp;quot;101100111&amp;quot; 3
: 101 -&amp;gt; 100 -&amp;gt; Flip: 1
: 101 -&amp;gt; 111 -&amp;gt; Flip: 1
2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就是这样。&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/raku">Raku</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/rakulang">Rakulang</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/</guid>
                <pubDate>Sun, 07 Feb 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>如果集合如我所想</title>
                <link>https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/</link>
                
                
                <description>&lt;blockquote&gt;If Sets Would DWIM&lt;/blockquote&gt;&lt;h1 id=&#34;if-sets-would-dwimhttpsdonaldhwtf202101if-sets-would-dwim&#34;&gt;&lt;a href=&#34;https://donaldh.wtf/2021/01/if-sets-would-dwim/&#34;&gt;If Sets Would DWIM&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;每当我在 Raku 中使用集合的时候，它们经常无法 &lt;a href=&#34;https://docs.raku.org/language/glossary#DWIM&#34;&gt;DWIM&lt;/a&gt;。这是一个简短的探索，看看是否可以改进 DWIMminess。&lt;/p&gt;
&lt;p&gt;我最近重新审视了我前段时间写的一个利用 &lt;code&gt;(-)&lt;/code&gt; 集差运算符的脚本。这段代码有一个 bug 潜伏在那里，显而易见，因为下面的代码并没有按照我的直觉去做。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;  my @allowed = &amp;lt;m c i p l o t&amp;gt;;
  my @chars = &#39;impolitic&#39;.comb;

  my @remainder = @allowed (-) @chars;

  if +@remainder == 0 {
     say &#39;pangram&#39;;
  } else {
     say &amp;quot;unused: [{@remainder.join(&#39; &#39;)}]&amp;quot;;
  }
unused: []
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;错误的原因是 &lt;code&gt;(-)&lt;/code&gt; 产生了一个 Set，而赋值给 &lt;code&gt;@remainder&lt;/code&gt; 会产生1项的 Array。总是这样。但不方便的是，当它是一个空集合时，它就会字符串化为一个空字符串，这只是帮助掩盖了这个潜伏的错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my @items = &amp;lt;a b c d e&amp;gt; (-) &amp;lt;a b c d e&amp;gt;;
say @items.raku;
say +@items;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;[Set.new()]
1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决方法比较简单。只要不赋值给数组就可以了。使用一个标量容器来代替。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my $items = &amp;lt;a b c d e&amp;gt; (-) &amp;lt;a b d&amp;gt;;
say $items.raku;
say +$items;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;Set.new(&amp;quot;e&amp;quot;,&amp;quot;c&amp;quot;)
2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;甚至是关联容器也可以。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my %items = &amp;lt;a b c d e&amp;gt; (-) &amp;lt;a b d&amp;gt;;
say %items.raku;
say +%items;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;{:c(Bool::True), :e(Bool::True)}
2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或在赋值前明确地取出键的列表。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my @items = (&amp;lt;a b c d e&amp;gt; (-) &amp;lt;a b d&amp;gt;).keys;
say @items.raku;
say +@items;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;[&amp;quot;e&amp;quot;, &amp;quot;c&amp;quot;]
2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很好，起作用了。只是不要用数组容器来处理 &lt;code&gt;Setty&lt;/code&gt; 这样的东西。只是这并不能阻止我的直觉时不时地碰上这个错误。同一类的 bug 在我的代码中出现过好几次，因为它实在是太容易犯错了。Raku 不会告诉我，我做错了什么，因为也许是故意的。但重要的是， Raku 没有设法 DWIM。&lt;/p&gt;
&lt;p&gt;我可以采取的另一个方法是养成添加类型信息的习惯。这样确实可以让 Raku 在我掉进这个陷阱的时候告诉我。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my Str @a = &amp;lt;a b c d e&amp;gt; (-) &amp;lt;a b d&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;Type check failed in assignment to @a; expected Str but got Set (Set.new(&amp;quot;e&amp;quot;,&amp;quot;c&amp;quot;))
  in sub  at EVAL_0 line 3
  in block &amp;lt;unit&amp;gt; at EVAL_0 line 5
  in block &amp;lt;unit&amp;gt; at -e line 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是一个明显的例子，添加类型信息有助于 Raku 编译器帮助我避免引入这种 bug。&lt;/p&gt;
&lt;h2 id=&#34;实验---为-set-自定义数组存储&#34;&gt;实验 - 为 Set 自定义数组存储&lt;/h2&gt;
&lt;p&gt;我开始研究核心设置(core setting)，看看可以做什么。我惊喜地发现，我可以在 &lt;code&gt;Array.STORE&lt;/code&gt; 的多重分派中添加我正在寻找的语义。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;use MONKEY;

augment class Array {
   multi method STORE(Array:D: Set \item --&amp;gt; Array:D) {
       self.STORE(item.keys)
   }
}

my @a = &amp;lt;a b c d e&amp;gt; (-) &amp;lt;a b d&amp;gt;;
say @a.raku;
say +@a;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;[&amp;quot;c&amp;quot;, &amp;quot;e&amp;quot;]
2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;分享这个似乎是谨慎的，看看我的小 DWIM 是否有任何我没有考虑到的问题或缺点。一个可能的缺点是，如果你需要这样做的话，你需要使用 &lt;code&gt;,&lt;/code&gt; 来强制将一个集合变成一个数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my @a = &amp;lt;a b c d e&amp;gt; (-) &amp;lt;a b d&amp;gt; , ;
say @a.raku;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;[Set.new(&amp;quot;e&amp;quot;,&amp;quot;c&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;下一步是什么&#34;&gt;下一步是什么&lt;/h2&gt;
&lt;p&gt;我希望这能引发关于这个问题以及其他我们的直觉和 Raku 的行为不太一致的情况的讨论。也许还有其他相关的语言边缘可以被磨平，以消除这种危害。&lt;/p&gt;
&lt;h2 id=&#34;后续&#34;&gt;后续&lt;/h2&gt;
&lt;p&gt;在 &lt;a href=&#34;https://t.co/0QSoMxrSXf?amp=1&#34;&gt;Reddit&lt;/a&gt; 上有一些非常有启发性的讨论，涵盖了语言语义和各种替代方法。公平地说，我建议的方法引入了更多的不一致性，而不是价值，但讨论可能会导致一个语言一致的解决方案。&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/flink">Flink</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/rakulang">Rakulang</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/</guid>
                <pubDate>Sun, 07 Feb 2021 00:00:00 +0800</pubDate>
            </item>
        
    </channel>
</rss>


