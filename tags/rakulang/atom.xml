<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.92.0">Hugo</generator><title type="html"><![CDATA[rakulang on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/rakulang/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/rakulang/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/rakulang/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/rakulang/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2022-01-23T16:05:49+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/rakulang/</id>
    
        
        <entry>
            <title type="html"><![CDATA[New Disp Is Here]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-09-30-new-disp-is-here/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-09-24-haku-a-japanese-programming-language/?utm_source=atom_feed" rel="related" type="text/html" title="Haku a Japanese Programming Language" />
                <link href="https://ohmyweekly.github.io/notes/2021-08-06-105-c-plus-plus-algorithms-in-one-line-of-raku/?utm_source=atom_feed" rel="related" type="text/html" title="105 C&#43;&#43; Algorithms in One Line of Raku" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
            
                <id>https://ohmyweekly.github.io/notes/2021-09-30-new-disp-is-here/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-09-30T00:00:00+00:00</published>
            <updated>2021-09-30T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>New Disp Is Here</blockquote><p>大约 18 个月前，我开始着手进行 Raku 运行时 MoarVM 自成立以来最大的一组架构变化。这项工作最直接的起因是我们意识到，我们没有很好的方法来修复派发中的某个语义错误，而不会对整个系统的性能造成巨大的影响，也不会使已经在走运的优化中进一步增加复杂性。然而，对这种东西的需求在一段时间内是显而易见的：优化某些 Raku 语言特性的持续斗争，一堆性能机制的痛苦，这些机制都在解决同类问题，但每个都是针对特定的情况，以及一种感觉，即自从我创立 MoarVM 以来所学到的一切，都有可能做得更好。</p>
<p>其结果是开发了一个新的通用派发机制。简而言之，它为我们提供了一个更加统一的架构，适用于所有类型的派发，使我们能够在一系列的语言特性上提供更好的性能，而这些特性迄今为止一直是冰冷的，同时也为新的优化提供了机会。</p>
<p>今天，这项工作已经与 NQP（我们用于引导和实现编译器的 Raku 子集）和 Rakudo（完整的 Raku 编译器和标准库实现）中的相应变化合并。这意味着它将出现在2021年10月的版本中。</p>
<p>在这篇文章中，我将概述你可以立即观察到的情况，以及随着我们继续建立新的派发架构所提供的可能性，你可能会在未来期待什么。</p>
<h2 id="大赢家">大赢家</h2>
<p>最大的改进涉及到我们以前确实没有架构可以做得更好的语言特性。它们涉及到派发 —— 也就是说，让调用有效地链接到目的地 —— 但运行时并没有为我们提供一种方法来&quot;解释&quot;它正在看一个派发，更不用说提供优化它所需的信息了。</p>
<p>下图捕捉了一些这样的案例，并显示了改进的程度，从3.3倍到13.3倍不等。</p>
<p><img src="https://6guts.files.wordpress.com/2021/09/graph-1.png?w=601" alt="Graph showing benchmark results, described textually below"></p>
<p>让我们快速看一下每一个问题。第一个，<code>new-buf</code>，问我们如何快速分配 <code>Buf</code>s。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="o">^</span><span class="mi">10_000_000</span> <span class="p">{</span> <span class="nb">Buf</span><span class="o">.</span><span class="nb">new</span> <span class="p">}</span>
</code></pre></div><p>为什么说这是一个派发基准？因为 <code>Buf</code> 不是一个类，而是一个角色。当我们试图制造一个角色的实例时，它被 &ldquo;punned&rdquo; 成一个类。到现在为止，它的工作方式如下。</p>
<ol>
<li>我们查找 <code>new</code> 方法</li>
<li>如果需要的话，<code>find_method</code> 方法会创建一个角色的双关，并将其缓存起来</li>
<li>它将返回一个转发闭包，该闭包接受参数，并将其交给在被双关的类上调用的同一方法，或者写作 Raku 代码，<code>-&gt; $role-discarded, |args { $pun.&quot;$name&quot;(|args) }</code></li>
<li>这个闭包将被调用，携带参数</li>
</ol>
<p>这有一些不理想的后果。</p>
<ol>
<li>虽然双关被缓存了，但我们仍然有一些开销来检查我们是否已经做了它。</li>
<li>参数被 slurp 和扁平化，这需要花费一些开销，而且&hellip;&hellip;</li>
<li>&hellip;&hellip;失去了 <code>callite</code> 形状意味着我们无法查找方法的类型特化，因此也就失去了内联的机会。</li>
</ol>
<p>有了新的派发机制，我们就有了在特定程序位置缓存常量和替换参数的方法。因此，当我们第一次遇到调用时，我们</p>
<ol>
<li>如果需要的话，获得产生的角色双关</li>
<li>解决来自角色的类上的新方法的问题</li>
<li>产生一个派发程序，缓存这个已解决的方法，同时用双关替换角色参数。</li>
</ol>
<p>在接下来的数千次调用中，我们解释这个派发程序。这仍然需要一些成本，但我们正在调用的方法已经被解决了，而且参数列表的重写也相当便宜。同时，在我们进入几百次迭代之后，在一个后台线程上，优化器开始工作。这时，参数重排的成本就完全消失了，而且新的参数非常小，可以被内联 —— 这时，缓冲区的分配被确定为无效，所以也就消失了。剩下的一些错过的机会意味着我们仍然留下了一个不完全是空的循环：它忙着确保它真的可以什么都不做，而不是什么都不做。</p>
<p>下一步，用 <code>where</code> 子句进行多重派发。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span> <span class="k">where</span> <span class="nv">$n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">*</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">1_000_000</span> <span class="p">{</span> <span class="nf">fac</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>这些以前真的很慢，因为。</p>
<ol>
<li>一旦有 <code>where</code> 子句，我们就无法应用多派发缓存机制。</li>
<li>在候选者被选中的情况下，我们要运行两次 <code>where</code> 子句：一次是看我们是否应该选择该多候选者，另一次是在我们进入该候选者时。</li>
</ol>
<p>有了新的机制，我们:</p>
<ol>
<li>在第一次调用时，计算出一个多重派发计划：一个需要处理的候选者的链接列表</li>
<li>调用带有 <code>where</code> 子句的计划，在这种模式下，如果签名不能绑定，就会触发派发的恢复。(如果它绑定了，它就会运行到完成)。</li>
<li>如果绑定失败，则触发派发恢复，我们尝试下一个候选程序。</li>
</ol>
<p>再一次，在设置阶段之后，我们解释派发程序。事实上，这就是我们目前运行速度较快的程度，因为专用程序还不知道如何翻译和进一步优化这种派发程序。(这就是为什么我知道它目前没有机会把这整个事情变成另一个空循环！）。) 因此，这里还有更多的东西可以利用；同时，恐怕你只能满足于10倍的速度。</p>
<p>这是下一个:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="nf">with-proto</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span><span class="p">)</span> <span class="p">{</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">with-proto</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>

<span class="k">sub</span> <span class="nf">invoking-nontrivial-proto</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="o">^</span><span class="mi">10_000_000</span> <span class="p">{</span> <span class="nf">with-proto</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>同样，在顶层，我们也会把它变成一个空循环，但我们还没有达到这个目的。这种情况在以前并不可怕：我们确实可以使用多重派发缓存，但是为了做到这一点，我们也不得不分配一个参数捕获。这种需要也阻碍了将 <code>proto</code> 内联到调用者中的任何机会。现在这是有可能的。由于我们还不能翻译恢复正在进行的派发的派发程序，所以我们还不能进一步将被调用的多候选者内联到原语中。然而，我们现在有一个设计，可以让我们实现这一点。</p>
<p>这整个派发恢复的概念 —— 我们开始做一个派发，后来需要访问参数或其他预先计算的数据，以便进行下一步的派发 —— 已经被证明是一个伟大的统一。它的最初想法来自于考虑像 <code>callame</code> 这样的东西。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">m</span><span class="p">()</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="k">is</span> <span class="nc">Parent</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">m</span><span class="p">()</span> <span class="p">{</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">callsame</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">10_000_000</span> <span class="p">{</span> <span class="n">Child</span><span class="o">.</span><span class="k">m</span><span class="p">;</span><span class="sr"> }
</span></code></pre></div><p>一旦我开始关注这个问题，然后考虑到一个复杂的 <code>proto</code> 也想在 <code>{*}</code> 处继续派发，并且在 <code>where</code> 子句在 <code>multi</code> 中失败的情况下，它也想继续派发，我意识到这对很多事情都会很有用。教导优化器和 JIT 对恢复做一些好的事情将是一个令人头痛的问题 —— 但是，做一次就能使多种语言特性受益，这让我感到非常欣慰。</p>
<p>总之，回到基准上。这是另一个&quot;如果我们聪明的话，它就会是一个空循环&quot;。以前，<code>callsame</code> 的成本很高，因为每次我们调用它时，它都必须计算出我们要恢复的是哪种派发以及要调用的方法集。我们还必须能够定位参数。涉及到动态变量，这也需要花费一些时间来查找，而且 —— 尽管是一个实现细节 —— 这些也会在自省中泄露出来，这并不理想。新的派发机制使这一切变得更有效率：我们可以缓存计算出的方法集（或包装器和 <code>multi</code> 候选方法，取决于上下文），然后走过它，而且不涉及动态变量（因此也不会泄露）。这体现了最大的速度提升 —— 由于我们还不能内联去掉调用名，它（目前）衡量的是人们在使用这种语言特性时可能期望的速度提升。 在未来，它注定会被优化为一个空循环。</p>
<p>OO::Monitors 是一个在相对较热的路径上使用 <code>callame</code> 的模块，所以我想看看那里是否也会有速度的提升。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nn">OO::Monitors</span><span class="p">;</span>

<span class="n">monitor</span> <span class="n">TestMonitor</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">m</span><span class="p">()</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$mon</span> <span class="o">=</span> <span class="n">TestMonitor</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="k">for</span> <span class="o">^</span><span class="mi">1_000_000</span> <span class="p">{</span> <span class="nv">$mon</span><span class="o">.</span><span class="k">m</span><span class="p">();</span> <span class="p">}</span>
</code></pre></div><p><code>monitor</code> 是一个围绕每个方法调用获取锁的类。该模块提供了一个自定义的元类，为该类添加了一个锁属性，然后对每个方法进行包装，使其获得该锁。除了 <code>callsame</code> 的参与之外，当然还有一些昂贵的东西在里面，但是对 <code>callsame</code> 的改进已经足以让我们在这个基准中看到3.3倍的速度。由于 <code>OO::Monitors</code> 被用于相当多的应用程序和模块（例如，Cro 使用它），这是很受欢迎的（是的，这里也会有更大的改进）。</p>
<h3 id="调用者端去容器化">调用者端去容器化</h3>
<p>我在其他一些微小测试中看到了一些不那么令人印象深刻，但仍然值得欢迎的改进。 即使是对 <code>+</code> 操作的基本多重派发。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="o">^</span><span class="mi">10_000_000</span> <span class="p">{</span> <span class="nv">$i</span> <span class="o">=</span> <span class="nv">$i</span> <span class="o">+</span> <span class="nv">$_</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><p>我们的速度提高了1.6倍，这主要归功于我们用更少的守卫产生了更紧密的代码。 以前，我们在这种看似简单的情况下会出现重复的防护措施。<code>infix:&lt;+&gt;</code> 多重选择将被专门用于其第一个参数是 Scalar 容器中的 Int，第二个参数是不可变的 Int 的情况。因为 Scalar 是可变的，所以这个特殊化需要读取它，然后在继续之前保护读取的值，否则它可能会改变，我们会有内存安全的风险。当我们想内联这个候选值时，我们也想检查一下这个候选值是否真的适用，所以也要遵从 Scalar，并对其内容进行保护来做到这一点。我们可以而且确实消除了重复的守卫 —— 但是这些守卫是对值的两次不同的读取，所以这没有帮助。</p>
<p>因为在新的派发机制中，我们可以重写参数，所以我们现在可以很容易地在调用方删除值周围的 Scalar 容器。事实上，这样做非常容易，我花了几个小时就完成了这个改动。这带来了很多好处。由于派发程序会自动消除重复的读取和守卫，多派发器的读取和守卫以及为了传递去容器化的值而进行的读取都会被凝聚起来。这意味着在专业化和 JIT 编译之前减少了重复的工作，而且在之后的专业化代码中也只有一个读和守。由于要传递的值已经被保护起来，我们可以简单地选择一个候选的两个 Int 值，这意味着在被调用者中也不需要再读和保护。</p>
<p>一个不太明显的好处是，这意味着 Scalar 容器逃逸到被调用方的情况要少得多，但在未来的工作中会变得很重要。这为逃逸分析创造了更多机会。虽然 MoarVM 的逃逸分析器和标量替换器目前还相当有限，但我希望在不久的将来能回到它的工作中，并期望它现在能给我们带来比以前更多的价值。</p>
<h3 id="进一步的结果">进一步的结果</h3>
<p>前面显示的基准测试大多是&quot;我们有多接近意识到我们有一个空循环&quot;的性质，这对于评估优化器能多好地&quot;看穿&quot;派发是很有趣的。下面是一些在更&quot;传统&quot;的微基准上的进一步结果。</p>
<p><img src="https://6guts.files.wordpress.com/2021/09/graph2.png?w=600" alt="Graph showing benchmark results, described textually below"></p>
<p>复数的基准是这样的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$total-re</span> <span class="o">=</span> <span class="mf">0e0</span><span class="p">;</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">2_000_000</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">2</span><span class="no">i</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$y</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">3</span><span class="no">i</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$z</span> <span class="o">=</span> <span class="nv">$x</span> <span class="o">*</span> <span class="nv">$x</span> <span class="o">+</span> <span class="nv">$y</span><span class="p">;</span>

    <span class="nv">$total-re</span> <span class="o">=</span> <span class="nv">$total-re</span> <span class="o">+</span> <span class="nv">$z</span><span class="o">.</span><span class="nb">re</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nv">$total-re</span><span class="p">;</span>
</code></pre></div><p>也就是说，只是一堆运算符（多派发）和方法调用，在这里我们确实使用了结果。目前，我们在这个基准上与 Python 并列，比 Ruby 稍稍落后（比用 Perl 的 <code>Math::Complex</code> 做同样的事情快了48倍，令人惊讶），但这也是一个在未来能看到逃逸分析和标量替换带来巨大好处的案例。</p>
<p>散列读取的基准是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="o">,</span> <span class="s">b</span> <span class="o">=&gt;</span> <span class="mi">12</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">10_000_000</span> <span class="p">{</span>
    <span class="nv">$total</span> <span class="o">=</span> <span class="nv">$total</span> <span class="o">+</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">a</span><span class="p">&gt;</span> <span class="o">+</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">b</span><span class="p">&gt;;</span>
<span class="p">}</span>
</code></pre></div><p>而散列存储一个是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@keys</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;;</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">500_000</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">%h</span><span class="p">;</span>
    <span class="k">for</span> <span class="nv">@keys</span> <span class="p">{</span> <span class="nv">%h</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这些改进与哈希算法本身没有任何关系，相反，由于调用方的去容器化，看起来主要是由于更紧凑的代码。这可能有一个次要的影响，即把事情带到内联的大小限制之下，这也是一个很大的帮助。2倍和1.85倍的加速因子是值得欢迎的，尽管我们真的可以再做同样水平的改进，以便我对我们的结果感到合理的满意。</p>
<p>读取行的基准是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#34;</span><span class="s2">longfile</span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">$chars</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">$fh</span><span class="o">.</span><span class="nb">lines</span> <span class="p">{</span> <span class="nv">$chars</span> <span class="o">=</span> <span class="nv">$chars</span> <span class="o">+</span> <span class="o">.</span><span class="nb">chars</span> <span class="p">};</span>

<span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$chars</span>
</code></pre></div><p>同样，没有什么特定的 I/O 变得更快，但当派发 —— 把所有的部件组合在一起的胶水 —— 得到提升时，它就会帮助所有的地方。(我们在这个基准上也很有竞争力，尽管在 UTF-8 解码器不能采取它的&quot;NFG 不可能应用&quot;的快速路径时往往会慢一些）。)</p>
<h3 id="而在不那么微观的事情上">而在不那么微观的事情上&hellip;</h3>
<p>我也开始关注更大的程序，并从其他人那里听到他们的结果。这大多是令人鼓舞的。</p>
<p>长期存在的 <code>Text::CSV</code> 基准 <code>test-t</code> 已经看到了大约 20% 的改进（感谢lizmat的测量）。</p>
<p>一个简单的 <code>Cro::HTTP</code> 测试程序每秒多了 10% 的请求。</p>
<p>MoarVM 的贡献者 dogbert 对一些脚本做了时间上的比较；最显著的改进看到从25秒下降到7秒，大多数都快了 10%-30%，有些没有变化，只有一个变慢了。</p>
<p>在标准库 CORE.setting 的编译上，有大约2.5%的改进。然而，这里需要一大把盐：作为工作的一部分，编译器本身在很多地方发生了变化，还有一些基于查看配置文件的东西进行了调整，这些东西与派发并不真正相关。</p>
<p>Agrammon，一个计算农业排放的应用程序，已经看到了大约9%的速度下降。我还没来得及仔细看，不过从剖析输出来看，取消优化的次数相对较多，这表明我们在某处做了一些不好的优化决定。</p>
<h3 id="较小的剖析器输出">较小的剖析器输出</h3>
<p>一个未曾预料到的（我）但也是值得欢迎的改进是，剖析器的输出已经明显变小。 可能的原因包括:</p>
<ul>
<li>
<p>派发机制支持产生值结果（从常量、输入参数或从输入参数读取的属性）。它完全取代了早期的机制，即&quot;特殊化插件&quot;，它可以将守卫映射到要调用的目标，但总是需要调用某个东西 —— 即使这个东西是身份函数。其逻辑是，这对任何真正的热代码来说并不重要，因为身份函数会被微不足道地内联掉。然而，由于仪器分析器的大小是通过调用树的路径数量的函数，从树中修剪对身份函数的调用负载会使它变小很多。</p>
</li>
<li>
<p>当一个值处于 sink 上下文时，我们曾经对 <code>sink</code> 方法进行了大量的调用。现在，如果我们看到这个类型只是从 Mu 那里继承了这个方法，我们就会完全删除这个调用（同样，它会被内联掉，但是一个更小的调用图就是一个更小的配置文件）。</p>
</li>
</ul>
<p>多重派发缓存以前总是在错过缓存时调用原语，但当它在未来得到缓存点击时，就不会再调用 onlystar 原语。这意味着许多多重派发下的调用树在配置文件中是重复的。这不仅仅是一个大小的问题；这种影响在配置文件的报告中也显示出来，这有点令人讨厌。</p>
<p>为了举例说明这种差别，我从 Agrammon 中提取了配置文件，以研究为什么它可能变得更慢。派发器工作之前的配置文件重达 87MB；而采用新的派发机制的配置文件则低于 30MB。这意味着剖析时使用的内存更少，事后将剖析结果写入磁盘的时间更短，工具加载剖析器输出的时间也更短。因此，现在可以更快地研究如何使事情变得更快。</p>
<h3 id="有什么坏消息吗">有什么坏消息吗？</h3>
<p>恐怕是的。启动时间受到了影响。虽然新的派发机制更加强大，将更多的复杂性从虚拟机中推到了高级代码中，并且更有利于达到更高的峰值性能，但它也有更高的预热时间。在写这篇文章的时候，对启动时间的影响似乎是 25% 左右。我希望我们能在10月的发布之前收回一些。</p>
<h3 id="什么会被打破">什么会被打破？</h3>
<p>这种规模的变化总是伴随着一定的风险。我们将在下一次月度发布前几周进行合并，以便有时间进行更多的测试，并解决任何被报告的回归问题。然而，即使在达到合并的地步之前，我们已经。</p>
<ul>
<li>确保它在正常情况下，以及在优化器压力下，都能通过规范测试套件（我们强迫它过早地优化一切，这样我们就能找出优化器的错误，以及 —— 考虑到我们强迫它做出的许多错误决定 —— 去优化的错误</li>
<li>使用 <code>Blin</code> 来运行生态系统模块的测试。这是准备 Rakudo 发布时的一个标准步骤，但在这种情况下，我们把它放在 <code>new-disp</code> 分支上。这发现了一些由于切换到新的派发机制而引起的退步，这些问题已经被解决。</li>
<li>对一些依赖不支持的内部 API 的模块进行了补丁或发送了拉取请求，这些内部 API 现在已经消失或改变，或者依赖其他实现细节。这些模块相对较少，而且令人高兴的是，其中许多模块通过迁移到支持的 API（这些 API 在编写模块时可能并不存在）得到了修复。</li>
</ul>
<h3 id="接下来会发生什么">接下来会发生什么？</h3>
<p>正如我在这篇文章中提到的一些地方，虽然有一些改进可以立即享受，但也有一些新的机会可以进一步改进。我想到的一些事情包括。</p>
<ul>
<li>重新设计 callframe 的进入和退出。这些仍然是明显的成本过高。在研究新的派发机制时发生的各种变化，为这一领域的改进提供了新的机会。</li>
<li>避免巨变的堆积。微观基准在隐藏这些方面非常出色。事实上，这里的 &ldquo;callsame&rdquo; 就是一个完美的例子! 我们在 <code>callsame</code> 中进行派发的恢复，所以整个程序中所有恢复的内联缓存条目都堆积在一个地方。我们所希望的是让它们在调用栈的下面一层连接起来。否则，在微观测试中看到的 <code>callsame</code> 水平的提高将无法在更大的应用中享受。 这也适用于其他一些情况。</li>
<li>应用新的派发机制来进一步优化结构。例如，一个方法调用的结果是调用特殊的 <code>FALLBACK</code> 方法，它的调用点可以很容易地改写成这样，为内联开辟道路。</li>
<li>进一步调整我们在优化后产生的代码。有大量的浪费应该可以比较直接地消除，还有一些机会可以调整去优化，使我们能够删除更多的指令，并且仍然保留去优化的能力。</li>
<li>继续我之前做的逃逸分析工作，现在应该是比较有价值的了。更加灵活的 <code>callstack/frame</code> 处理也应该解除我在标量替换 <code>Int</code>s 方面的工作（在内存管理方面需要非常小心，因为它们可能会框住一个大的整数，而不仅仅是一个本地整数）。</li>
<li>实现特殊化、JIT 和派发恢复的内联。</li>
</ul>
<h3 id="感谢">感谢</h3>
<p>我要感谢<a href="https://www.perlfoundation.org/">TPF</a>和他们的捐助者提供的资金，使我有可能把大量的工作时间花在这项工作上。</p>
<p>虽然我对新派发机制的整体设计和大部分实现负有责任，但其他 MoarVM 和 Rakudo 的贡献者也付出了大量的工作 —— 特别是在过去的几个月里，随着最后的碎片落地，我们把注意力转移到让它为生产做好准备。我很感谢他们，不仅是对代码和调试的贡献，还有一路走来的支持和鼓励。合并的感觉很好，我期待着在未来的几个月和几年里在此基础上继续发展。</p>
<p><a href="https://6guts.wordpress.com/2021/09/29/the-new-moarvm-dispatch-mechanism-is-here/">https://6guts.wordpress.com/2021/09/29/the-new-moarvm-dispatch-mechanism-is-here/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Haku a Japanese Programming Language]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-09-24-haku-a-japanese-programming-language/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-08-06-105-c-plus-plus-algorithms-in-one-line-of-raku/?utm_source=atom_feed" rel="related" type="text/html" title="105 C&#43;&#43; Algorithms in One Line of Raku" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
            
                <id>https://ohmyweekly.github.io/notes/2021-09-24-haku-a-japanese-programming-language/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-09-24T00:00:00+00:00</published>
            <updated>2021-09-24T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Haku a Japanese Programming Language</blockquote><h1 id="haku-a-japanese-programming-language">Haku: a Japanese programming language</h1>
<p>Haku 是一种基于文学性日语的自然语言功能编程语言。这篇文章是关于 Haku 在 <a href="https://raku.org/">Raku</a> 中的实现。你不需要懂日语或<a href="https://codeberg.org/wimvanderbauwhede/haku">阅读 Haku 的文档</a>。如果你不熟悉 Raku，你可能想阅读<a href="https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/#raku-intro">我的快速介绍</a>。</p>
<p>我确实假定你对解析、语法树和代码生成的概念很熟悉。如果你发现你对下面的内容缺乏背景，我推荐 Andrew Shitov 的系列文章<a href="https://andrewshitov.com/creating-a-compiler-with-raku/">《用 Raku 创建编译器》</a>，它采取了一个逐步的方法。</p>
<h2 id="haku">Haku</h2>
<p>Haku 的目标是接近书面日语，因此它是由汉字、平假名和片假名这三种日语书写系统以及日语标点符号组合而成的。没有空格，Haku 不使用阿拉伯（甚至是罗马）数字，也不使用任何运算符。该语言的设计<a href="https://codeberg.org/wimvanderbauwhede/haku">在文档中得到了更详细的解释</a>。</p>
<p>下面是一个小的 Haku 程序的例子（更多的例子请看 <a href="https://codeberg.org/wimvanderbauwhede/haku/src/branch/main/examples">repo</a>）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">本とは
「魄から楽まで」を見せる
の事です。
</code></pre></div><p>这句话翻译过来就是:</p>
<blockquote>
<p>&ldquo;main is: to show &lsquo;From Haku to Raku&rsquo;&rdquo;</p>
</blockquote>
<p>而 Raku 版本是这样的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">From Haku to Raku</span><span class="p">&#39;;</span>
</code></pre></div><p>字符串&quot;本とは &ldquo;和 &ldquo;の事です&quot;表示主程序的开始和结束。&ldquo;魄から楽まで &ldquo;是一个字符串常数。&ldquo;见せる &ldquo;是打印函数。&lsquo;&lsquo;を&rsquo;表示前面的东西是函数的一个参数。示例代码中的换行符是可选的，纯粹是为了方便阅读。Haku 程序是一个没有空白或换行的单一字符串。</p>
<p>这个例子的实际生成的 Raku 代码是这样的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">HakuPrelude</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">show</span><span class="p">(&#39;</span><span class="s1">魄から楽まで</span><span class="p">&#39;)</span>
<span class="p">}</span>

<span class="nf">main</span><span class="p">();</span>
</code></pre></div><p>为了更接近文学性的日语，Haku 程序可以从右到左竖着写。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">の 忘 本 　 の 条 条 遠 　 の 物 忘
事 れ と 　 こ を で い 　 こ で れ
で か は 　 と 見 　 と 　 と 空 る
す け 記 　 で せ 　 は 　 で 　 と
。 て 憶 　 す る 　 　 　 す 　 は
　 た は 　 。 　 　 　 　 。 　 　g
　 遠 無 　 　 　 　 　 　 　 　 　
　 い 、 　 　 　 　 　 　 　 　 　
　 記 　 　 　 　 　 　 　 　 　 　
　 憶 　 　 　 　 　 　 　 　 　 　
</code></pre></div><p>为这个 Haku 程序生成的 Raku 代码同样非常简单。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">HakuPrelude</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">wasureru</span><span class="p">(</span> \<span class="n">mono</span><span class="p">)</span> <span class="p">{</span><span class="o">[]</span><span class="p">}</span>

<span class="k">sub</span> <span class="nf">tooi</span><span class="p">(</span> \<span class="n">jou</span><span class="p">)</span> <span class="p">{</span><span class="nf">show</span><span class="p">(</span><span class="n">jou</span><span class="p">)}</span>

<span class="k">sub</span> <span class="nf">hon</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">\kioku</span> <span class="o">=</span> <span class="nb">Nil</span><span class="p">;</span>
    <span class="nf">wasureru</span><span class="p">(</span><span class="nf">tooi</span><span class="p">(</span><span class="n">kioku</span><span class="p">))</span>
<span class="p">}</span>

<span class="nf">hon</span><span class="p">();</span>
</code></pre></div><p>Haku 是用 Raku 实现的。Haku 编译器是一个源到源的编译器（有时称为转译器），它从 Haku 源生成 Raku 源并执行它。Raku 在许多方面使编写这样的编译器变得容易。</p>
<h2 id="parsing-using-grammars">Parsing using Grammars</h2>
<p>我决定用 Raku 来实现 Haku，主要是因为我想使用 Raku 的 <a href="https://docs.raku.org/language/grammars">Grammar</a> 功能，而且它没有让我失望。Grammar 就像一个类，但它没有方法，而是有 rule 或 token，它们是解析器的构建块。任何 token 都可以在另一个 token 的定义中使用，例如用 <code>&lt;...&gt;</code> 将其括起来。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6"><span class="k">token</span> <span class="nf">adjective</span> <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="p">&lt;</span><span class="nf">i-adjective</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">na-adjective</span><span class="p">&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p><code>i-adjective</code> 和 <code>na-adjective</code> 已经被分别定义，<code>adjective</code> 与其中一个相匹配。</p>
<p>我一直喜欢解析器组合器（如 Haskell 中的 <a href="https://www.futurelearn.com/info/courses/functional-programming-haskell/0/steps/27222">Parsec</a>），从某种角度看，Raku 的 grammar 也很相似。它们都是无扫描器，即没有单独的 token 化步骤，而且高度可组合。Parsec 提供的许多功能（如 <code>many</code>,<code> oneOf</code>, <code>sepBy</code>）都可以通过 Raku 的 regex 来实现。</p>
<p>Raku 的 grammar 有几个特点，有助于使 Haku 的解析器易于实现。</p>
<h3 id="excellent-unicode-support">Excellent Unicode support</h3>
<p>我认为 Raku 的 Unicode 支持真的很好。例如，由于对 Unicode 块的支持，我可以简单地写出:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6"><span class="k">token</span> <span class="nf">kanji</span> <span class="p">{</span><span class="sr">  
</span><span class="sr">    </span><span class="p">&lt;:</span><span class="na">Block</span><span class="p">(&#39;</span><span class="s1">CJK Unified Ideographs</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>  
</code></pre></div><p>rather than having to enumerate them all (there are 92,865 kanji in that block!). In fact, the <code>&lt;:...&gt;</code> syntax works for any Unicode property, not just for Blocks.</p>
<p>Even better: I have some kanji that are reserved as keywords:</p>
<p>而不是把它们全部列举出来（该块中有 92,865 个汉字！）。事实上， <code>&lt;:...&gt;</code> 语法适用于任何 Unicode 属性，而不仅仅是 Blocks。</p>
<p>甚至更好。我有一些汉字被保留为关键词。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6"><span class="k">token</span> <span class="nf">reserved-kanji</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">本</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">事</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="o">..</span><span class="ni">.</span><span class="sr"> </span><span class="p">}</span>
</code></pre></div><p>为了确保这些被排除在 Haku 的有效汉字之外，我可以简单地使用一个差集。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6"><span class="k">token</span> <span class="nf">kanji</span> <span class="p">{</span><span class="sr">  
</span><span class="sr">    </span><span class="p">&lt;:</span><span class="na">Block</span><span class="p">(&#39;</span><span class="s1">CJK Unified Ideographs</span><span class="p">&#39;)</span> <span class="o">-</span> <span class="sr">reserved</span><span class="o">-</span><span class="sr">kanji</span> <span class="p">&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>  
</code></pre></div><p>(有一个细节让我感到不安的是，用户定义的字符类的等效语法需要一个显式的  &lsquo;+'：<code>token set-difference { &lt; +set1 - set2&gt; }</code>)</p>
<h3 id="tokens-和-rules">Tokens 和 rules</h3>
<p>幸运的是，Raku 默认不会假设你想解析可以忽略空白的东西，或者你想在空白处进行标记。如果你想忽略空白，你可以使用 <code>rule</code>。但是在 Haku 中，不允许不相干的空白（除了某些位置的换行）。所以我在任何地方都使用 <code>token</code>。(还有 <a href="https://docs.raku.org/language/grammars#index-entry-declarator_token-Named_Regexes"><code>regex</code>，可以回溯</a>。在 Haku 的语法中我不需要它）。)</p>
<h3 id="very-powerful-regexes">Very powerful regexes</h3>
<p>作为一个 lambdacamel，我一直很喜欢 Perl 的 regexes，现在无处不在的 <a href="https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions">PCREs</a>。然而，<a href="https://docs.raku.org/language/regexes">Raku 的 regexes</a> 在功能、表现力和可读性方面远远超过了它。</p>
<p>首先，它们是可组合的：你可以用 <code>regex</code> 类型定义一个命名的 regex，然后用 <code>&lt;...&gt;</code> 语法在随后的 regex 中使用它。另外，设计时的谨慎使它们非常容易使用。例如，一个否定向前查看断言只是 <code>&lt;no&gt; &lt;!before &lt;koto&gt; &gt;</code>；而尝试顺序交替(<code>||</code>)和最长令牌匹配交替(<code>|</code>)的可用性是一个巨大的好处。我非常喜欢的另一件事是使一个字符类不被捕获的能力。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6">    <span class="k">token</span> <span class="nf">lambda-expression</span> <span class="p">{</span><span class="sr"> 
</span><span class="sr">        </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">aru</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">variable-list</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">de</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">expression</span><span class="p">&gt;</span><span class="sr"> 
</span><span class="sr">    </span><span class="p">}</span>
</code></pre></div><p>只有 <code>&lt;variable-list&gt;</code> 和 <code>&lt;expression&gt;</code> 会被捕获，所以很多具体的语法可以在解析时被删除。</p>
<h3 id="grammar-composition-via-roles">Grammar composition via roles</h3>
<p>Roles (&lsquo;mixins&rsquo; in Ruby, &lsquo;traits&rsquo; in Rust) define interfaces and/or implementation of those interfaces.
I found this a better fit for my purpose than the also-supported class inheritance. For example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6"><span class="k">role</span> <span class="nc">Nouns</span> <span class="k">does</span> <span class="nc">Characters</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">sa</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">さ</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">ki</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">き</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
    <span class="c1"># 一線 is OK,  一 is not OK, 線 is OK</span>
    <span class="k">token</span> <span class="nf">noun</span> <span class="p">{</span><span class="sr"> 
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">number-kanji</span><span class="p">&gt;</span><span class="o">?</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">non-number-kanji</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">kanji</span><span class="p">&gt;</span><span class="o">*</span><span class="sr"> 
</span><span class="sr">        </span><span class="p">[&lt;</span><span class="nf">sa</span><span class="p">&gt;</span><span class="o">|</span><span class="p">&lt;</span><span class="nf">ki</span><span class="p">&gt;]</span><span class="o">?</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">role</span> <span class="nc">Identifiers</span> 
<span class="k">does</span> <span class="nc">Verbs</span> 
<span class="k">does</span> <span class="nc">Nouns</span> 
<span class="k">does</span> <span class="nc">Adjectives</span> 
<span class="k">does</span> <span class="nc">Variables</span> 
<span class="p">{</span>
    <span class="k">token</span> <span class="nf">nominaliser</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">no</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="ow">before</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">koto</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&gt;</span><span class="sr"> 
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">koto</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="ow">before</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">desu</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&gt;</span><span class="sr"> 
</span><span class="sr">    </span><span class="p">}</span>
    <span class="c1"># Identifiers are variables,</span>
    <span class="c1"># noun-style, verb-style</span>
    <span class="c1"># and adjective-style function names</span>
    <span class="k">token</span> <span class="nf">identifier</span> <span class="p">{</span><span class="sr"> 
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">variable</span><span class="p">&gt;</span><span class="sr"> 
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">verb</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">nominaliser</span><span class="p">&gt;</span><span class="o">?</span><span class="sr"> 
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">noun</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">sura</span><span class="p">&gt;</span><span class="o">?</span><span class="sr"> 
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">adjective</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>(Although I would like a list syntax for this, something like <code>role Identifiers does Verbs, Nouns, Adjectives, Variables {...}</code>.)</p>
<p>There is a lot more to grammars and regexes. The nice Raku folks on Twitter recommended me the book <a href="https://link.springer.com/book/10.1007/978-1-4842-3228-6">&ldquo;Parsing with Perl 6 Regexes and Grammars&rdquo; by Moritz Lenz</a> and it was very useful in particular for debugging of the grammar and handling of error messages.</p>
<h2 id="abstract-syntax-tree-using-roles">Abstract syntax tree using roles</h2>
<p>I like to implement the abstract syntax tree (AST) as an algebraic data type, the way it is usually done in Haskell. In Raku, one way to do this is to use parametrised Roles <a href="https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/">as I explained in an earlier post</a>. Most of the AST maps directly to the toplevel parser for each role in my grammar, for example the lambda expression:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6"><span class="k">role</span> <span class="nc">LambdaExpr</span><span class="o">[</span> <span class="nv">@lambda-args</span><span class="o">,</span> <span class="nv">$expr</span><span class="o">]</span> <span class="k">does</span> <span class="nc">HakuExpr</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Variable</span> <span class="nv">@.args</span> <span class="o">=</span> <span class="nv">@lambda-args</span><span class="p">;</span>
    <span class="k">has</span> <span class="n">HakuExpr</span> <span class="nv">$.expr</span> <span class="o">=</span> <span class="nv">$expr</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div><h2 id="from-parse-tree-to-abstract-syntax-tree">From parse tree to abstract syntax tree</h2>
<p>Raku&rsquo;s grammars provide a very convenient mechanism for turning the parse tree into an AST, called <a href="https://docs.raku.org/language/grammars#index-entry-Actions">Actions</a>. Essentially, you create a class with a method with the same name as the token or rule in the Grammar. Each method gets the <a href="https://docs.raku.org/type/Match">Match object</a> (<code>$/</code>) created by the token as a positional argument.</p>
<p>For example, to populate the AST node for a lambda expression from the parse tree:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6"><span class="k">method</span> <span class="nf">lambda-expression</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">@args</span> <span class="o">=</span> <span class="nv">$&lt;variable-list&gt;</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">$expr</span> <span class="o">=</span> <span class="nv">$&lt;expression&gt;</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>
        <span class="k">make</span> <span class="n">LambdaExpr</span><span class="o">[</span><span class="nv">@args</span><span class="o">,</span><span class="nv">$expr</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>The capturing tokens used in the <code>lambda-expression</code> token are accessible via the notation <code>$&lt;...&gt;</code> which is shorthand for <code>$/&lt;...&gt;</code>, i.e. they are named attributes of the current match object.</p>
<p>In the Haku grammar, there are several tokens where the match is one from a list of alternatives, for example the <code>expression</code> token, which enumerates anything that is an expression in Haku. For such tokens I use the following code to &ldquo;inherit&rdquo; from the constituent tokens:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6"><span class="k">method</span> <span class="nf">expression</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> 
        <span class="k">make</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">values</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="k">made</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Because every match is a map with as keys the names of the capturing tokens, and because we know that in this case there will be only one token selected, we know the first element in the corresponding <code>values</code> list will be the match for that particular token.</p>
<h2 id="code-generation">Code generation</h2>
<p>The <code>haku.raku</code> main program essentially does this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6"><span class="k">my</span> <span class="nv">$hon_parse</span> <span class="o">=</span> 
    <span class="n">Haku</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$program_str</span><span class="o">,</span> <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="n">HakuActions</span><span class="p">));</span>
<span class="k">my</span> <span class="nv">$hon_raku_code</span> <span class="o">=</span>  
    <span class="nf">ppHakuProgram</span><span class="p">(</span><span class="nv">$hon_parse</span><span class="o">.</span><span class="k">made</span><span class="p">);</span>
</code></pre></div><p>The Haku program string is parsed using the Haku grammar and the methods defined in the corresponding HakuActions class are used to populate the AST. The toplevel parse tree node must be <code>$&lt;haku-program&gt;</code>, and the <code>made</code> method of this node returns the AST node <code>HakuProgram</code>. The routine <code>ppHakuProgram</code> is the toplevel routine in the module <code>Raku</code>, which is the Raku emitter for Haku. (There is also a Scheme emitter, in the module <code>Scheme</code>.)</p>
<p>So <code>ppHakuProgram($hon_parse.made)</code> pretty-prints the HakuProgram AST node and thus the entire Haku program as Raku code.</p>
<p>What I like about the role-based AST is that you can pattern match against the variants of a type using <code>given/when</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6"><span class="k">sub</span> <span class="nf">ppHakuExpr</span><span class="p">(</span>\<span class="n">h</span><span class="p">)</span> <span class="p">{</span>            
    <span class="k">given</span> <span class="n">h</span> <span class="p">{</span>
        <span class="k">when</span> <span class="n">BindExpr</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
        <span class="k">when</span> <span class="n">FunctionApplyExpr</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
        <span class="k">when</span> <span class="n">ListExpr</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
        <span class="k">when</span> <span class="n">MapExpr</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>        
        <span class="k">when</span>  <span class="n">IfExpr</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>   
        <span class="k">when</span> <span class="n">LetExpr</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
        <span class="k">when</span> <span class="n">LambdaExpr</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>        
        <span class="o">...</span>
        <span class="k">default</span> <span class="p">{</span>
            <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">TODO:</span><span class="p">&#34;</span> <span class="o">~</span> <span class="n">h</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
        <span class="p">}</span>        
    <span class="p">}</span>
<span class="p">}</span> 
</code></pre></div><p>The Raku code corresponding to the Haku AST is quite straightforward, but there are a few things worth noting:</p>
<ul>
<li>Because Haku&rsquo;s variables are immutable, I use the <code>\</code> notation which means I don&rsquo;t have to build a variable table with the sigils.</li>
<li>Because Haku is functional, <code>let</code> and <code>if</code> are expressions, so in Raku I wrap them in a <code>do {}</code> block.</li>
<li>For partial application I use <code>.assuming()</code>.</li>
<li>In Haku, strings are lists. In Raku they aren&rsquo;t. I created a small Prelude of functions, and the list manipulation functions in that Prelude use pattern matching on the type with <code>given/when</code> to see if the argument is a string or a list.</li>
</ul>
<h2 id="running-the-generated-raku-code">Running the generated Raku code</h2>
<p>Running the generated Raku code is simple: I write the generated Raku code to a module and <code>require</code> it. The generated code ends with a call to <code>hon()</code>, the main function in a Haku program, so this automatically executes the program.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6"><span class="c1"># Write the parsed program to a module </span>
<span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Hon.rakumod</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">open</span><span class="o">:</span> <span class="p">:</span><span class="s">w</span><span class="p">;</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">put</span><span class="o">:</span> <span class="nv">$hon_raku_code</span><span class="p">;</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>

<span class="c1"># Require the module. This will execute the program</span>
<span class="k">require</span> <span class="n">Hon</span><span class="p">;</span>
</code></pre></div><p>Other things Haku makes really easy is to create command-line flags and document their usage:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl6" data-lang="perl6"><span class="k">sub</span> <span class="nb">USAGE</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">print</span> <span class="k">Q</span><span class="sa">:to</span><span class="p">/EOH/;</span><span class="s">
</span><span class="s">    Usage: haku &lt;Haku program, written horizontally or vertically, utf-8 text file&gt;
</span><span class="s">        [--tategaki, -t] : do not run the program but print it vertically.
</span><span class="s">        [--miseru, -m] : just print the Raku source code, don&#39;t execute.
</span><span class="s">        ...
</span><span class="s">    </span><span class="p">EOH</span>
<span class="p">}</span>

<span class="k">unit</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span>
          <span class="nb">Str</span> <span class="nv">$src_file</span><span class="o">,</span>
          <span class="nb">Bool</span> <span class="p">:</span><span class="s">t</span><span class="p">(</span><span class="nv">$tategaki</span><span class="p">)</span> <span class="o">=</span> <span class="nb">False</span><span class="o">,</span>   
          <span class="nb">Bool</span> <span class="p">:</span><span class="s">m</span><span class="p">(</span><span class="nv">$miseru</span><span class="p">)</span> <span class="o">=</span> <span class="nb">False</span><span class="o">,</span>
          <span class="o">...</span>
        <span class="p">);</span>  
</code></pre></div><p><code>USAGE</code> is called when <code>MAIN</code> is called with the wrong (or no) arguments. Arguments of <code>MAIN</code> prefixed with <code>:</code> are flags. <code>unit sub</code> means that anything after this declaration is part of the MAIN program, so no need for <code>{...}</code>.</p>
<h2 id="to-conclude">To conclude</h2>
<p>This article shows the lazy programmer&rsquo;s way to creating your own programming language: let Raku do all the hard work.</p>
<p>Or to express it with a Haku program:</p>
<p>　本真とは
　コンパイラを書いて、
　プログラムを書いて、
　プログラムを走らす
　と言う事です。</p>
<blockquote>
<p>the truth:
write the compiler,
write the program,
run the program.</p>
</blockquote>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[105 C++ Algorithms in One Line of Raku]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-08-06-105-c-plus-plus-algorithms-in-one-line-of-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中怎么为已存在的类添加方法" />
            
                <id>https://ohmyweekly.github.io/notes/2021-08-06-105-c-plus-plus-algorithms-in-one-line-of-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-08-07T00:00:00+00:00</published>
            <updated>2021-08-07T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>105 C++ Algorithms in One Line of Raku</blockquote><ul>
<li>filter_map</li>
</ul>
<p>Rust 中有一个 filter_map 函数, Raku 也可以有:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$text</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">1</span><span class="se">\n</span><span class="s2">frond .25  289</span><span class="se">\n</span><span class="s2">3.1415 estuary</span><span class="se">\n</span><span class="p">&#34;;</span>
<span class="nv">$text</span><span class="o">.</span><span class="nb">split</span><span class="p">(/</span><span class="se">\s</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span> <span class="p">{</span><span class="nv">$_</span> <span class="o">~~</span> <span class="p">/</span><span class="se">\d</span><span class="p">/</span> <span class="o">??</span> <span class="nv">$_</span><span class="o">*</span><span class="nv">$_</span> <span class="o">!!</span> <span class="nb">Empty</span> <span class="p">});</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@a</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="nv">&amp;fn1</span><span class="p">)</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="nv">&amp;fn2</span><span class="p">);</span>

<span class="nv">@a</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span><span class="nv">&amp;fn2</span> <span class="o">??</span> <span class="o">.&amp;</span><span class="nf">fn1</span> <span class="o">!!</span> <span class="nb">Empty</span><span class="p">});</span>
</code></pre></div><ul>
<li>zip-tail</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@a</span> <span class="ow">Z</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">1</span><span class="o">...*]</span><span class="p">;</span>
<span class="nv">@a</span> <span class="ow">Z</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">skip</span><span class="p">;</span>
<span class="nv">@a-longer-name</span> <span class="ow">Z</span> <span class="nv">@a-longer-name</span><span class="o">.</span><span class="nb">skip</span><span class="p">;</span>
<span class="nv">@a</span><span class="o">.&amp;</span><span class="p">{</span><span class="nv">$_</span> <span class="ow">Z</span> <span class="o">.</span><span class="nb">skip</span><span class="p">};</span>
<span class="nv">@a</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div><ul>
<li>binary filter</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@a</span> <span class="o">«&amp;&amp;»</span> <span class="nv">@b</span><span class="p">;</span>
<span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">foo bar baz buz</span><span class="p">&gt;;</span>
<span class="nv">@b</span> <span class="o">=</span> <span class="o">[</span><span class="nb">True</span><span class="o">,</span> <span class="nb">False</span><span class="o">,</span> <span class="n">Flase</span><span class="o">,</span> <span class="nb">True</span><span class="o">]</span><span class="p">;</span>
<span class="p">(</span><span class="nv">@b</span> <span class="o">«&amp;&amp;»</span> <span class="nv">@a</span><span class="p">)</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*</span> <span class="o">!=</span> <span class="nb">False</span><span class="p">)</span>
</code></pre></div><ul>
<li>find</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">&amp;first:</span> <span class="n">p</span> <span class="c1"># or :v, :kv</span>
<span class="nv">&amp;min</span>
<span class="nv">&amp;max</span>
<span class="nv">&amp;minmax</span>
</code></pre></div><ul>
<li>&amp;sort</li>
<li>&amp;reduce</li>
<li>&amp;produce</li>
<li>&amp;map</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># remove</span>
<span class="nv">@a</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="o">!</span><span class="nv">&amp;pred</span>
<span class="c1"># count</span>
<span class="o">+</span><span class="nv">@a</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="nv">&amp;pred</span>
<span class="c1"># replace</span>
<span class="nv">@a</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span><span class="nv">&amp;pred</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="o">??</span> <span class="nv">$new</span> <span class="nv">$_</span><span class="p">}</span>
<span class="c1"># find_end, lower_bound, upper_bound</span>
<span class="nv">@a</span><span class="o">.</span><span class="nb">first</span><span class="p">(</span><span class="nv">&amp;pred</span><span class="o">,</span> <span class="p">:</span><span class="s">end</span><span class="p">);</span> <span class="c1"># with :p etc for key</span>
<span class="c1"># partition</span>
<span class="nv">@a</span><span class="o">.</span><span class="nb">classify</span><span class="p">(</span><span class="o">+</span><span class="p">(</span><span class="nv">&amp;pred</span><span class="p">)){</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="p">}</span>
</code></pre></div><ul>
<li>Permutations</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@a</span> <span class="o">==</span> <span class="nv">@b</span>

<span class="c1"># next permutation</span>
<span class="nv">@a</span><span class="o">.</span><span class="nb">permutations</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>

<span class="c1"># prev permutation</span>
<span class="nv">@a</span><span class="o">.</span><span class="nb">permutations</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="c1">#zip-tail (again)</span>
<span class="nv">@a</span><span class="o">.&amp;</span><span class="p">{</span><span class="nv">$_</span> <span class="ow">Z</span> <span class="o">.</span><span class="nb">skip</span><span class="p">}</span>

<span class="c1"># is sorted</span>
<span class="nv">@a</span><span class="o">.&amp;</span><span class="p">{</span><span class="nv">$_</span> <span class="ow">Z</span><span class="o">&lt;</span> <span class="o">.</span><span class="nb">skip</span><span class="p">}</span><span class="o">.</span><span class="nb">all</span>

<span class="c1"># is sorted until</span>
<span class="nv">@a</span><span class="o">.&amp;</span><span class="p">{</span><span class="nv">$_</span> <span class="ow">Z</span> <span class="o">.</span><span class="nb">skip</span><span class="p">}</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span><span class="o">.[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;</span> <span class="o">.[</span><span class="mi">1</span><span class="o">]</span> <span class="o">||</span> <span class="nb">last</span><span class="p">})</span><span class="o">.</span><span class="nb">sum</span>

<span class="c1"># adjacent difference</span>
<span class="nv">@a</span><span class="o">.&amp;</span><span class="p">{</span><span class="nv">$_</span> <span class="ow">Z</span><span class="o">-</span> <span class="o">.</span><span class="nb">skip</span><span class="p">}</span>
<span class="nv">@a</span><span class="o">.&amp;</span><span class="p">{</span><span class="o">.</span><span class="nb">skip</span> <span class="ow">Z</span><span class="o">-</span> <span class="nv">$_</span><span class="p">}</span>

<span class="c1"># adjacent find</span>
<span class="nb">first</span><span class="p">({</span><span class="o">[==]</span> <span class="nv">$_</span><span class="p">}</span><span class="o">,</span> <span class="nv">@a</span><span class="o">.&amp;</span><span class="p">{</span><span class="nv">$_</span> <span class="ow">Z</span> <span class="o">.</span><span class="nb">skip</span><span class="p">})</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</code></pre></div><ul>
<li>mismatch, aka zip_find</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">first</span><span class="p">(</span><span class="o">*</span> <span class="o">!=</span> <span class="nb">False</span><span class="o">,</span> <span class="p">(</span><span class="nv">@b</span> <span class="ow">Z</span><span class="o">!===</span> <span class="nv">@a</span><span class="p">)</span> <span class="o">«&amp;&amp;»</span> <span class="nv">@a</span><span class="p">)</span>
</code></pre></div><ul>
<li>is partitioned</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="nv">@a</span><span class="o">.&amp;</span><span class="p">{</span><span class="nv">$_</span> <span class="ow">Z</span> <span class="o">.</span><span class="nb">skip</span><span class="p">}</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="o">?</span><span class="p">(</span><span class="nv">&amp;pred</span><span class="p">(</span><span class="o">.[</span><span class="mi">0</span><span class="o">]</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">!</span><span class="nv">&amp;pred</span><span class="p">(</span><span class="o">.[</span><span class="mi">1</span><span class="o">]</span><span class="p">))</span> <span class="p">})</span> <span class="o">«&amp;&amp;»</span> <span class="nv">@a</span><span class="p">)</span><span class="o">.</span><span class="nb">first</span><span class="p">(</span><span class="o">?*</span><span class="p">)</span>
</code></pre></div><ul>
<li>inner product</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">[+]</span> <span class="nv">@a</span> <span class="n">Zx</span> <span class="nv">@b</span>

<span class="c1">#exclusive scan</span>
<span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">|</span><span class="nv">@a</span><span class="p">)</span><span class="o">.</span><span class="nb">produce</span><span class="p">(</span><span class="o">&amp;[+]</span><span class="p">)</span><span class="o">[^</span><span class="p">(</span><span class="o">*-</span><span class="mi">1</span><span class="p">)</span><span class="o">]</span>

<span class="c1"># transfrom reduce</span>
<span class="nv">@a</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="nv">&amp;fn</span><span class="p">)</span><span class="o">.</span><span class="nb">reduce</span><span class="p">(</span><span class="nv">&amp;fn2</span><span class="p">)</span>

<span class="c1"># transfrom inclusive scan</span>
<span class="nv">@a</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="nv">&amp;fn</span><span class="p">)</span><span class="o">.</span><span class="nb">produce</span><span class="p">(</span><span class="nv">&amp;fn2</span><span class="p">)</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Guess Who]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中怎么为已存在的类添加方法" />
                <link href="https://ohmyweekly.github.io/notes/2015-03-16-features-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的特性(二)" />
            
                <id>https://ohmyweekly.github.io/notes/2015-11-20-guess-who/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+00:00</published>
            <updated>2021-07-11T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Guess Who</blockquote><p>你是一个刚成立的小公司里的一名软件工程师, 有天晚上你收到了一封来自 CEO 的电子邮件:</p>
<blockquote>
<p>亲爱的工程师,</p>
<p>​    好新闻！看起来我们的网站越来越受欢迎。我们要变的有钱了! 每秒钟有成千上万的人在同时访问我们的网站, 而且还在快速增长。</p>
<p>我们必须立即识别出谁的通信量最大。幸运的是我的朋友给我发送了一份巨大的 IP 地址和名字的列表。很酷不是吗？你能写一段程序接收我们大量的访问者, 把它和地址/名字列表相比, 并创建一些统计吗？我的意思是, 生成一个国家的名字列表。</p>
<p>做好了的话我给你们开个披萨聚会。</p>
</blockquote>
<blockquote>
<p>邮件的附件文件包含了一个 IP 地址和名字的列表。写一个程序来统计下有多少 IP 访问了你的网站。</p>
</blockquote>
<h2 id="输入描述">输入描述</h2>
<p>输入来自两部分。第一个是一个文本文件, 包含 IP 地址范围。每行一项,使用两个空格分割 IP 和名字。</p>
<p>第二个文件是一个 IP 地址的列表, 每行一个, 它们是必须被查询的IP。</p>
<h2 id="ip-输入样本">IP 输入样本</h2>
<p>输入是有包含两个 IP 地址和一个跟 IP 范围关联的名字的大量行组成。</p>
<pre tabindex="0"><code>123.45.17.8 123.45.123.45 University of Vestige
123.50.1.1 123.50.10.1 National Center for Pointlessness
188.0.0.3 200.0.0.250 Mayo Tarkington
200.0.0.251 200.0.0.255 Daubs Haywire Committee
200.0.1.1 200.255.255.255 Geopolitical Encyclopedia
222.222.222.222 233.233.233.233 SAP Rostov
250.1.2.3 250.4.5.6 Shavian Refillable Committee
123.45.100.0 123.60.32.1 United Adverbs
190.0.0.1 201.1.1.1 Shavian Refillable Committee
238.0.0.1 254.1.2.3 National Center for Pointlessness
</code></pre><p>注意: 这些 IP 范围不能保证是 IPv4 &ldquo;子网&rdquo;。这意味着它们可能不能精确地由基于前缀的 CIDR 块来表示。</p>
<p>范围可以重叠。可能多余2层深。</p>
<p>可可有多个范围关联同一个名字。</p>
<h2 id="查询输入样本">查询输入样本</h2>
<pre tabindex="0"><code>250.1.3.4
123.50.1.20
189.133.73.57
123.50.1.21
250.1.2.4
123.50.1.21
250.1.3.100
250.1.3.5
188.0.0.5
123.50.1.100
123.50.2.34
123.50.1.100
123.51.100.52
127.0.0.1
123.50.1.22
123.50.1.21
188.0.0.5
123.45.101.100
123.45.31.52
230.230.230.230
</code></pre><h2 id="输出格式化">输出格式化</h2>
<p>倒序输出访问次数。</p>
<pre tabindex="0"><code>8 - National Center for Pointlessness
4 - Shavian Refillable Committee
3 - Mayo Tarkington
2 - University of Vestige
1 - SAP Rostov
1 - United Adverbs
1 - &lt;unknown&gt;
</code></pre><h2 id="解释">解释</h2>
<p>这儿是一个输入 IP 和它的名字的映射:</p>
<pre tabindex="0"><code>National Center for Pointlessness
123.50.1.20
123.50.1.21
123.50.1.22
123.50.1.21
123.50.1.21
123.50.1.100
123.50.1.100
123.50.2.34

Shavian Refillable Committee
250.1.2.4
250.1.3.4
250.1.3.5
250.1.3.100

Mayo Tarkington
188.0.0.5
188.0.0.5
189.133.73.57

University of Vestige
123.45.101.100
123.45.31.52

SAP Rostov
230.230.230.230

United Adverbs
123.51.100.52

&lt;unknown&gt;
127.0.0.1
</code></pre><p>smls 的解决方法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">ip-to-number</span> <span class="p">(</span><span class="nv">$ip</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">do</span> <span class="k">given</span> <span class="nv">$ip</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">.</span><span class="p">&#39;)</span> <span class="p">{</span>
        <span class="o">.[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+&lt;</span> <span class="mi">24</span> <span class="o">+</span>
        <span class="o">.[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+&lt;</span> <span class="mi">16</span> <span class="o">+</span>
        <span class="o">.[</span><span class="mi">2</span><span class="o">]</span> <span class="o">+&lt;</span>  <span class="mi">8</span> <span class="o">+</span>
        <span class="o">.[</span><span class="mi">3</span><span class="o">]</span> <span class="o">+&lt;</span>  <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">IntervalTree</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.min</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.max</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$!center</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$!min</span> <span class="o">+</span> <span class="nv">$!max</span><span class="p">)</span> <span class="ow">div</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@!intervals</span><span class="p">;</span>
    <span class="k">has</span> <span class="n">IntervalTree</span> <span class="nv">$!left</span><span class="p">;</span>
    <span class="k">has</span> <span class="n">IntervalTree</span> <span class="nv">$!right</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">new</span> <span class="p">(</span><span class="nv">$min</span><span class="o">,</span> <span class="nv">$max</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span><span class="o">:</span><span class="nv">$min</span><span class="o">,</span> <span class="o">:</span><span class="nv">$max</span><span class="p">)</span> <span class="p">}</span>

    <span class="k">method</span> <span class="nf">insert</span> <span class="p">(</span><span class="o">|</span><span class="n">c</span> <span class="p">(</span><span class="nv">$start</span><span class="o">,</span> <span class="nv">$end</span><span class="o">,</span> <span class="nv">$name</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$end</span> <span class="o">&lt;</span> <span class="nv">$!center</span> <span class="ow">and</span> <span class="nv">$!min</span> <span class="o">&lt;</span> <span class="nv">$!center</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="p">(</span><span class="nv">$!left</span> <span class="o">//=</span> <span class="nb">self</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$!min</span><span class="o">,</span> <span class="nv">$!center</span><span class="p">))</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">elsif</span> <span class="nv">$start</span> <span class="o">&gt;</span> <span class="nv">$!center</span> <span class="ow">and</span> <span class="nv">$!max</span> <span class="o">&gt;</span> <span class="nv">$!center</span> <span class="p">{</span>
            <span class="p">(</span><span class="nv">$!right</span> <span class="o">//=</span> <span class="nb">self</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$!center</span><span class="o">,</span> <span class="nv">$!max</span><span class="p">))</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nv">@!intervals</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="o">[</span><span class="nv">$start</span><span class="o">,</span> <span class="nv">$end</span><span class="o">,</span> <span class="nv">$name</span><span class="o">,</span> <span class="nv">$end-$start</span><span class="o">]</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">prepare</span> <span class="p">{</span>
        <span class="nv">@!intervals</span><span class="o">.=</span><span class="nb">sort</span><span class="p">(</span><span class="o">*[</span><span class="mi">3</span><span class="o">]</span><span class="p">);</span>
        <span class="nv">$!left</span> <span class="o">.</span><span class="nf">prepare</span> <span class="k">if</span> <span class="nv">$!left</span><span class="p">;</span>
        <span class="nv">$!right</span><span class="o">.</span><span class="nf">prepare</span> <span class="k">if</span> <span class="nv">$!right</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nb">lookup</span> <span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$best</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$n</span> <span class="o">&lt;</span> <span class="nv">$!center</span> <span class="o">??</span> <span class="p">(</span><span class="nv">$!left</span> <span class="o">.</span><span class="nb">lookup</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="k">if</span> <span class="nv">$!left</span><span class="p">)</span>
                                  <span class="o">!!</span> <span class="p">(</span><span class="nv">$!right</span><span class="o">.</span><span class="nb">lookup</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="k">if</span> <span class="nv">$!right</span><span class="p">));</span>
        <span class="nv">$best</span> <span class="o">??</span> <span class="nv">@!intervals</span><span class="o">.</span><span class="nb">first</span><span class="p">({</span> <span class="k">return</span> <span class="nv">$best</span> <span class="k">if</span> <span class="o">.[</span><span class="mi">3</span><span class="o">]</span> <span class="o">&gt;</span> <span class="nv">$best</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">;</span>
                                     <span class="o">.[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="nv">$n</span> <span class="o">&lt;=</span> <span class="o">.[</span><span class="mi">1</span><span class="o">]</span> <span class="p">})</span> <span class="o">//</span> <span class="nv">$best</span>
              <span class="o">!!</span> <span class="nv">@!intervals</span><span class="o">.</span><span class="nb">first</span><span class="p">({</span> <span class="o">.[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="nv">$n</span> <span class="o">&lt;=</span> <span class="o">.[</span><span class="mi">1</span><span class="o">]</span> <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="nv">$ip-file</span><span class="o">,</span> <span class="nv">$query-file</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$index</span> <span class="o">=</span> <span class="n">IntervalTree</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">ip-to-number</span> <span class="p">&#39;</span><span class="s1">255.255.255.255</span><span class="p">&#39;);</span>

    <span class="k">for</span> <span class="nv">$ip-file</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span> <span class="p">{</span>
        <span class="k">my</span> <span class="p">(</span><span class="nv">$start</span><span class="o">,</span> <span class="nv">$end</span><span class="o">,</span> <span class="nv">$name</span><span class="p">)</span> <span class="o">=</span> <span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="nv">$index</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nf">ip-to-number</span><span class="p">(</span><span class="nv">$start</span><span class="p">)</span><span class="o">,</span> <span class="nf">ip-to-number</span><span class="p">(</span><span class="nv">$end</span><span class="p">)</span><span class="o">,</span> <span class="nv">$name</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nv">$index</span><span class="o">.</span><span class="nf">prepare</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="nv">$query-file</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$ip</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$name</span> <span class="o">=</span> <span class="nv">$index</span><span class="o">.</span><span class="nb">lookup</span><span class="p">(</span><span class="n">ip-to-number</span> <span class="nv">$ip</span><span class="p">)</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$ip</span><span class="s2"> </span><span class="p">{</span><span class="nv">$name</span> <span class="o">//</span> <span class="p">&#39;</span><span class="s1">&lt;unknown&gt;</span><span class="p">&#39;}&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[List in Raku]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中怎么为已存在的类添加方法" />
                <link href="https://ohmyweekly.github.io/notes/2015-03-16-features-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的特性(二)" />
            
                <id>https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+00:00</published>
            <updated>2021-07-11T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>List in Raku</blockquote><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">class</span> <span class="nb">List</span> <span class="k">is</span> <span class="nb">Iterable</span> <span class="k">does</span> <span class="nb">Positional</span> <span class="p">{</span> <span class="o">..</span> <span class="p">}</span>
</code></pre></div><p><strong>List</strong> 以序列化的方式存储 items并且潜在是惰性的。</p>
<p>默认列表和数组的索引从 0 开始。</p>
<p>你可以给列表中的元素赋值如果它们是容器的话。使用数组以使列表中的每个元素存储在容器中。</p>
<h2 id="itemsflattening-和-sigils">Items、Flattening 和 Sigils</h2>
<p>在 Raku 中, 把 <strong>List</strong> 赋值给一个标量变量不会丢失信息。不同之处在于迭代通常会把标量中的列表当作单个元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">for</span> <span class="nv">@a</span> <span class="p">{</span> <span class="p">}</span>      <span class="c1"># 三次迭代</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="nv">@a</span><span class="p">;</span>
<span class="k">for</span> <span class="nv">$s</span> <span class="p">{</span> <span class="p">}</span>      <span class="c1"># 一次迭代</span>
<span class="k">for</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">item</span> <span class="p">{</span> <span class="p">}</span> <span class="c1"># 一次迭代</span>
<span class="k">for</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">list</span> <span class="p">{</span> <span class="p">}</span> <span class="c1"># 三次迭代</span>
</code></pre></div><p><strong>Lists</strong> 通常会插值(展开)除非它们通过一个 item(scalar)容器访问:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@flat</span>   <span class="o">=</span> <span class="nv">@a</span><span class="o">,</span> <span class="nv">@a</span><span class="p">;</span>           <span class="c1"># two elements</span>
<span class="k">my</span> <span class="nv">@nested</span> <span class="o">=</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">item</span><span class="o">,</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">item</span><span class="p">;</span> <span class="c1"># two elements</span>
</code></pre></div><p><code>.item</code> 通常能被写为 <code>$( ... )</code>, 而在数组变量上甚至写为 <code>$@a</code>。</p>
<h2 id="methods">Methods</h2>
<h3 id="elems">elems</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">elems</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>  <span class="k">returns</span> <span class="nb">Int:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">elems</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>返回列表中元素的个数。</p>
<h3 id="end">end</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">end</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>  <span class="k">returns</span> <span class="nb">Int:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">end</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>返回列表中最后一个元素的索引</p>
<h3 id="keys">keys</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">keys</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>  <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">keys</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回一个索引列表( 例如 <code>0..(@list.elems-1)</code> )</p>
<h3 id="values">values</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">values</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>  <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">values</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回列表的一份拷贝。</p>
<h3 id="kv">kv</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">kv</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>  <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">kv</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回索引和值的交替的列表。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">kv</span>
</code></pre></div><p>返回:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">0</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;</span>
</code></pre></div><h3 id="pairs">pairs</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">pairs</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>   <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">pairs</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回一个 pairs 的列表, 使用索引作为键, 列表值作为键值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">pairs</span>   <span class="c1"># 0 =&gt; &#39;a&#39;, 1 =&gt; &#39;b&#39;, 2 =&gt; &#39;c&#39;</span>
</code></pre></div><h3 id="join">join</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">join</span><span class="p">(</span><span class="nv">$separator</span><span class="o">,</span> <span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">join</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">$separator</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str:D</span>
</code></pre></div><p>把列表中元素当作字符串, 在元素之间插入 <code>$separator</code> 并把所有东西连接成单个字符串。</p>
<p>例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">join</span> <span class="p">&#39;</span><span class="s1">, </span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;;</span>     <span class="c1"># &#39;a, b, c&#39;</span>
</code></pre></div><h3 id="map">map</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">map</span><span class="p">(</span><span class="nv">&amp;code</span><span class="o">,</span> <span class="o">*</span><span class="nv">@elems</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">map</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">&amp;code</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>对每个元素调用 <code>&amp;code</code> 并且把值收集到另外一个列表中并返回它。这个过程是惰性的。<code>&amp;code</code>只在返回值被访问的时候调用。</p>
<p>例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span> <span class="o">.</span><span class="nb">WHAT</span><span class="o">.</span><span class="nb">raku</span> <span class="p">};</span> <span class="c1"># Str Int Rat Int Str</span>
<span class="nb">map</span> <span class="o">*.</span><span class="nb">Str</span><span class="o">.</span><span class="nb">chars</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;;</span>      <span class="c1"># 5 1 8 2 5</span>
</code></pre></div><h3 id="grep">grep</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">grep</span><span class="p">(</span><span class="nb">Mu</span> <span class="nv">$matcher</span><span class="o">,</span> <span class="o">*</span><span class="nv">@elems</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">grep</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span>  <span class="nb">Mu</span> <span class="nv">$matcher</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回一个使用 <code>$matcher</code> 智能匹配的惰性列表。元素是以出现在原列表中的顺序返回的。</p>
<p>例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="nb">Int</span><span class="p">;</span>              <span class="c1"># 1 42</span>
<span class="nb">grep</span> <span class="p">{</span> <span class="o">.</span><span class="nb">Str</span><span class="o">.</span><span class="nb">chars</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="p">}</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;;</span> <span class="c1"># hello 3.142857 world</span>
</code></pre></div><h3 id="first">first</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">first</span><span class="p">(</span><span class="nb">Mu</span> <span class="nv">$matcher</span><span class="o">,</span> <span class="o">*</span><span class="nv">@elems</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">first</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span>  <span class="nb">Mu</span> <span class="nv">$matcher</span><span class="p">)</span>
</code></pre></div><p>返回列表中第一个匹配 <code>$matcher</code> 的元素, 当没有匹配值时, 失败。</p>
<p>例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="nb">first</span><span class="o">:</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">;</span> <span class="c1"># 42</span>
<span class="nb">say</span> <span class="nv">$f</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">first</span><span class="o">:</span> <span class="nb">Complex</span><span class="p">;</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;</span><span class="o">,</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="no">i</span><span class="p">)</span><span class="o">.</span><span class="nb">first</span><span class="o">:</span> <span class="nb">Complex</span><span class="p">;</span> <span class="c1"># 1+2i</span>
<span class="nb">say</span> <span class="nv">$f</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span> 
<span class="c1"># Failure.new(exception =&gt; X::AdHoc.new(payload =&gt; &#34;No values matched&#34;))</span>
</code></pre></div><h3 id="classify">classify</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">classify</span><span class="p">(</span><span class="nv">&amp;mapper</span><span class="o">,</span> <span class="o">*</span><span class="nv">@values</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Hash:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">classify</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">&amp;mapper</span><span class="p">)</span>   <span class="k">returns</span> <span class="nb">Hash:D</span>
</code></pre></div><p>根据映射器把一列值转换成代表那些值的类别的散列; 散列的每个键代表着将要归入列表的一个或多个值的类别。比如字符个数,  元素多少, 键值就是根据 mapper 得到的这个类别下的元素,  它来自于原始列表：</p>
<p>例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nb">classify</span> <span class="p">{</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">even</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">odd</span><span class="p">&#39;</span> <span class="p">}</span><span class="o">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="c1"># (&#34;odd&#34; =&gt; [1, 7, 3], &#34;even&#34; =&gt; [6, 2]).hash;</span>

<span class="nb">say</span> <span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">classify</span><span class="o">:</span> <span class="p">{</span> <span class="o">.</span><span class="nb">Str</span><span class="o">.</span><span class="nb">chars</span> <span class="p">};</span>
<span class="c1"># (&#34;5&#34; =&gt; [&#34;hello&#34;, &#34;world&#34;], &#34;1&#34; =&gt; [1], &#34;8&#34; =&gt; [22/7], &#34;2&#34; =&gt; [42]).hash</span>
</code></pre></div><h3 id="bool">Bool</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">Bool</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>如果列表至少含有一个元素则返回 True, 如果列表为空则返回 False。</p>
<h3 id="str">Str</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">Str</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str:D</span>
</code></pre></div><p>字符串化列表中的元素并使用空格把这些元素连接起来。( 和 <code>.join(' ')</code> 一样)。</p>
<h3 id="int">Int</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">Int</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">return</span> <span class="nb">Int:D</span>
</code></pre></div><p>返回列表中元素的数量(和 <code>.elems</code> 一样)</p>
<h3 id="pick">pick</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">pick</span><span class="p">(</span><span class="nv">$count</span><span class="o">,</span> <span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">pick</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">$count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div><p>从调用者身上随机返回 <code>$count</code> 个不重复的元素。 如果 <code>*</code> 作为 <code>$count</code> 传递进来或 <code>$count</code> 大于或等于列表的大小, 那么就以随机序列的方式返回列表中的所有元素。</p>
<p>例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">pick</span><span class="p">;</span>     <span class="c1"># b</span>
<span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">pick</span><span class="o">:</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1"># c a e</span>
<span class="nb">say</span>  <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">pick</span><span class="o">:</span> <span class="o">*</span><span class="p">;</span> <span class="c1"># e d a b c</span>
</code></pre></div><h3 id="roll">roll</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">roll</span><span class="p">(</span><span class="nv">$count</span><span class="o">,</span> <span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">roll</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">$count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div><p>返回一个 <code>$count</code> 个元素的惰性列表, 每个元素都从列表中随机选择。每个随机选择都是独立的.</p>
<p>如果给 <code>$count</code> 传递了 <code>*</code> 号, 则返回一个惰性的, 从原列表中随机选取元素的无限列表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">roll</span><span class="p">;</span>       <span class="c1"># b</span>
<span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">roll</span><span class="o">:</span> <span class="mi">3</span><span class="p">;</span>    <span class="c1"># c c e</span>
<span class="nb">say</span> <span class="nb">roll</span> <span class="mi">8</span><span class="o">,</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;;</span>    <span class="c1"># b a e d a e b c</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$random_digits</span> <span class="o">:=</span> <span class="p">(</span><span class="o">^</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="o">*</span><span class="p">);</span><span class="mi">1</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$random_digits</span><span class="o">[^</span><span class="mi">15</span><span class="o">]</span><span class="p">;</span>    <span class="c1"># 3 8 7 6 0 1 3 2 0 8 8 5 8 0 5</span>
</code></pre></div><h3 id="eager">eager</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">eager</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>急切地计算列表中的所有元素, 并返回调用者。如果列表标示它是 &ldquo;konw inifinite&rdquo; 的, 急切求值可以停止在探测到的无限的点上。</p>
<h3 id="reverse">reverse</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">reverse</span><span class="p">(</span><span class="o">*</span><span class="nv">@list</span> <span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">reverse</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>以相反的顺序返回一个含有相同元素的列表。
注意 <code>reverse</code> 总是指反转列表中的元素, 如果你想反转字符串中的字符, 那么使用 flip。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">hello world!</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">reverse</span>      <span class="c1">#  world! hello</span>
<span class="nb">say</span> <span class="nb">reverse</span> <span class="o">^</span><span class="mi">10</span>                 <span class="c1"># 9 8 7 6 5 4 3 2 1 0</span>
</code></pre></div><h3 id="rotate">rotate</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">rotate</span><span class="p">(</span><span class="nv">@list</span><span class="o">,</span>  <span class="nb">Int:D</span> <span class="nv">$n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">rotate</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nb">Int:D</span> <span class="nv">$n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>以 <code>$n</code> 个元素旋转列表, 这把原列表分成两部分, 旋转中心就是在这两部分之间:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>   <span class="c1"># &lt;c d e a b&gt;</span>
<span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>  <span class="c1"># &lt;e a b c d&gt;</span>
</code></pre></div><h3 id="sort">sort</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">sort</span><span class="p">(</span><span class="o">*</span><span class="nv">@elems</span><span class="p">)</span>      <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">sub</span>    <span class="nb">sort</span><span class="p">(</span><span class="nv">&amp;by</span><span class="o">,</span> <span class="o">*</span><span class="nv">@elems</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">sort</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span>      <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">sort</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:,</span> <span class="nv">&amp;by</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>列表排序, 最小的元素首先。默认使用 <code>infix:&lt;cmp&gt;</code> 排序列表中的元素。</p>
<p>如果提供了 <code>&amp;by</code>, 那么它接收两个参数, 它由列表元素对儿调用, 并且应该返回 <code>Order::Increase</code>, <code>Order::Same</code> 或 <code>Order::Decrease</code>。</p>
<p>如果 <code>&amp;by</code> 只接受一个参数, 那么列表元素是通过 <code>by($a) cmp by($b)</code> 来排序的。<code>&amp;by</code> 的返回值被缓存起来, 以使每个列表元素只调用一次 <code>&amp;by</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="p">;</span>                  <span class="c1"># -4 -1 0 2 3 7</span>
<span class="nb">say</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="o">*.</span><span class="nb">abs</span><span class="p">;</span>           <span class="c1"># 0 -1 2 3 -4 7</span>
<span class="nb">say</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^b</span> <span class="ow">leg</span> <span class="nv">$^a</span> <span class="p">};</span> <span class="c1"># 7 3 2 0 -4 -1</span>
</code></pre></div><h3 id="reduce">reduce</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">reduce</span><span class="p">(</span><span class="nv">&amp;with</span><span class="o">,</span> <span class="o">*</span><span class="nv">@elems</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">reduce</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">&amp;with</span><span class="p">)</span>
</code></pre></div><p>把 <code>&amp;with</code> 应用到列表中的第一个和第二个值上, 然后把 <code>&amp;with</code> 应用到那个计算的结果值和第三个值上, 以此类推。按照那种方式生成单个项。</p>
<p>注意 <code>reduce</code> 是一个隐式的循环。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">reduce</span><span class="o">:</span> <span class="o">*</span> <span class="o">-</span> <span class="o">*</span><span class="p">;</span> <span class="c1"># -4</span>
</code></pre></div><h3 id="splice">splice</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">splice</span><span class="p">(</span><span class="nv">@list</span><span class="o">,</span>  <span class="nv">$start</span><span class="o">,</span> <span class="nv">$elems</span><span class="o">?,</span> <span class="o">*</span><span class="nv">@replacement</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">splice</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">$start</span><span class="o">,</span> <span class="nv">$elems</span><span class="o">?,</span> <span class="o">*</span><span class="nv">@replacement</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>从列表中删除从 <code>$start</code> 索引开始的 <code>$elems</code> 个元素, 返回删除的元素并用 <code>@replacement</code> 来代替它。如果省略了 <code>$elems</code>, 所有从 <code>$index</code> 开始的元素都被删除。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e f g</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">splice</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="p">&lt;</span><span class="s">M N O P</span><span class="p">&gt;);</span> <span class="c1"># c d e</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="p">;</span>                         <span class="c1"># a b M N O P f g</span>
</code></pre></div><h3 id="pop">pop</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">pop</span><span class="p">(</span><span class="nb">List:D</span> <span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">pop</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span>
</code></pre></div><p>从列表中移除并返回最后一项。如果列表为空则失败。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b</span><span class="p">&gt;;</span>
<span class="o">&gt;</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">pop</span><span class="p">;</span>  <span class="c1"># b</span>
<span class="o">&gt;</span> <span class="nb">pop</span> <span class="nv">@foo</span>   <span class="c1"># a</span>
<span class="o">&gt;</span> <span class="nb">pop</span> <span class="nv">@foo</span>   <span class="c1"># Element popped from empty list</span>
</code></pre></div><h3 id="push">push</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">push</span><span class="p">(</span><span class="nb">List:D</span><span class="o">,</span> <span class="o">*</span><span class="nv">@values</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">push</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="o">*</span><span class="nv">@values</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>把 <code>@values</code> 添加到列表的末尾, 并返回修改后的列表。 如果列表是无限列表则失败。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;;</span>
<span class="nv">@foo</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span> <span class="o">...</span> <span class="mi">11</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="p">;</span>                   <span class="c1"># a b c 1 3 5 7 9 11</span>
</code></pre></div><h3 id="shift">shift</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">shift</span><span class="p">(</span><span class="nb">List:D</span> <span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">shift</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span>
</code></pre></div><p>从列表中移除并返回第一项元素。如果列表为空则失败。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>     <span class="c1"># a</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>     <span class="c1"># b</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>     <span class="c1"># Element shifted from empty list</span>
</code></pre></div><h3 id="unshift">unshift</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">unshift</span><span class="p">(</span><span class="nb">List:D</span><span class="o">,</span> <span class="o">*</span><span class="nv">@values</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">unshift</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="o">*</span><span class="nv">@values</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>添加 <code>@values</code> 到列表的开头, 并返回修改后的列表。如果列表是无限列表则失败。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;;</span>
<span class="nv">@foo</span><span class="o">.</span><span class="nb">unshift</span><span class="o">:</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span> <span class="o">...</span> <span class="mi">11</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="p">;</span> <span class="c1"># 1 3 5 7 9 11 a b c</span>
</code></pre></div><h5 id="combinations">combinations</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">combinations</span> <span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nb">Int:D</span> <span class="nv">$of</span><span class="p">)</span>          <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">combinations</span> <span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nb">Range:D</span> <span class="nv">$of</span> <span class="o">=</span> <span class="mi">0</span><span class="o">..*</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">sub</span>    <span class="nb">combinations</span> <span class="p">(</span><span class="nv">$n</span><span class="o">,</span> <span class="nv">$k</span><span class="p">)</span>                     <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>Int 变体返回调用者列表所有的 <code>$of-combinations</code> 组合。例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;)</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">combinations</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div><p>打印</p>
<pre tabindex="0"><code>a|b
a|c
b|c
</code></pre><p>因为  &lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo; 的所有 2-combinations 是  [&lsquo;a&rsquo;, &lsquo;b&rsquo;], [&lsquo;a&rsquo;, &lsquo;c&rsquo;], [&lsquo;b&rsquo;, &lsquo;c&rsquo;].</p>
<p>Range 变体把所有单独的组合组合到单个列表中, 所以:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;)</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">combinations</span><span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="mi">3</span><span class="p">);</span>
</code></pre></div><p>打印：</p>
<pre tabindex="0"><code>a|b
a|c
b|c
a|b|c
</code></pre><p>因为那是一个所有 2-和3-combinations 组合的列表。</p>
<p>子例程 <code>combinations($n, $k)</code> 等价于 <code>(^$n).combinations($k)</code>, 所以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nb">combinations</span><span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div><p>打印：</p>
<pre tabindex="0"><code>0 1
0 2
0 3
1 2
1 3
2 3
</code></pre><h3 id="permutations">permutations</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">permutations</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">sub</span>    <span class="nb">permutations</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span>      <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回列表所有可能的组合作为数组的列表。所以:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;)</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">permutations</span>
</code></pre></div><p>打印：</p>
<pre tabindex="0"><code>a|b|c
a|c|b
b|a|c
b|c|a
c|a|b
c|b|a
</code></pre><p><code>permutations</code> 把所有列表元素当作可区别的, 所以 <code>(1, 1, 2).permutations</code> 仍旧返回 6 个元素的列表, 即使只有 3 个不同的排列。</p>
<p><code>permutations($n)</code> 等价于 <code>(^$n).permutations</code>, 所以:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nb">permutations</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div><p>打印：</p>
<pre tabindex="0"><code>1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
</code></pre>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 S/// 操作符]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中怎么为已存在的类添加方法" />
                <link href="https://ohmyweekly.github.io/notes/2015-03-16-features-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的特性(二)" />
            
                <id>https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+00:00</published>
            <updated>2021-07-11T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>The S Operator in Raku</blockquote><h1 id="raku-s-操作符httpblogsperlorguserszoffix_znet201604perl-6-the-s-operatorhtml"><a href="http://blogs.perl.org/users/zoffix_znet/2016/04/perl-6-the-s-operator.html">Raku: S/// 操作符</a></h1>
<p>By <a href="http://blogs.perl.org/users/zoffix_znet/">Zoffix Znet</a></p>
<p>来自 Perl 5 背景的我, 第一次使用 Raku 的非破坏性替换操作符 <code>S///</code> 的经历就像下面这样:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-3a07abee4665adaf.gif?imageMogr2/auto-orient/strip" alt="img"></p>
<p>进展会更好的。我不但会改善错误信息, 而且会解释当前的所有事情。</p>
<h2 id="智能匹配">智能匹配</h2>
<p>我有问题的原因是因为, 看到外形相似的操作符, 我就简单地把 Perl 5 中的绑定操作符(<code>=~</code>)转换为 Raku 中的智能匹配操作符(<code>~~</code>) 还期望它能正常工作。事实上我是异想天开。<code>S///</code> 操作符没有文档, 并且结合令人困惑的(那个时候)警告信息, 这就是我痛苦的根源：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$orig</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$new</span>  <span class="o">=</span> <span class="nv">$orig</span> <span class="o">~~</span> <span class="k">S</span><span class="p">/</span><span class="sr">me</span><span class="p">/</span><span class="s2">c</span><span class="p">/;</span>
<span class="nb">say</span> <span class="nv">$new</span><span class="p">;</span>

<span class="c1"># OUTPUT warning:</span>
<span class="c1"># Smartmatch with S/// can never succeed</span>
</code></pre></div><p>这个丑陋的警告说这儿的 <code>~~</code> 操作符是个错误的选择并且确实如此。<code>~~</code> 操作符不是 Perl 5 的 <code>=~</code> 操作符的等价物。<code>~~</code> 智能操作符把它左边的东西起了个叫做 <code>$_</code> 的别名, 然后 <code>~~</code> 计算它右侧的东西, 然后在右侧这个东西身上调用 <code>.ACCEPTS($_)</code> 方法。这就是所有的魔法。</p>
<p>所以上面的例子实际上发生了:</p>
<ul>
<li>我们到达 <code>S///</code> 的时候, <code>$orig</code> 被起了个叫做 <code>$_</code> 的别名。</li>
<li><code>S///</code> 非破坏性地在 <code>$_</code> 身上执行了替换并返回那个结果字符串。这是智能匹配将要操作的东西。</li>
<li>智能匹配, 按照 Str 与 Str 相匹配的规则, 会根据替换是否发生来给出 True 或 False（令人困惑的是, True 意味着没发生）</li>
</ul>
<p>结果一路下来, 我们并没有得到我们想要的：替换过的字符串。</p>
<h2 id="使用-given">使用 Given</h2>
<p>既然我们知道了 <code>S///</code> 总是作用在 <code>$_</code> 上并且返回替换后的结果, 很容易就想到几种方法把 <code>$_</code> 设置为我们原来的字符串并把 <code>S///</code> 的返回值收集回来, 我们来看几个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$orig</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$new</span>  <span class="o">=</span> <span class="k">S</span><span class="p">/</span><span class="sr">me</span><span class="p">/</span><span class="s2">c</span><span class="p">/</span> <span class="k">given</span> <span class="nv">$orig</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$orig</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$new</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">@orig</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">meow cow sow vow</span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">@new</span>  <span class="o">=</span> <span class="nb">do</span> <span class="k">for</span> <span class="nv">@orig</span> <span class="p">{</span> <span class="k">S</span><span class="p">/</span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="ow">before</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">ow</span><span class="p">&#39;&gt;/</span><span class="s2">w</span><span class="p">/</span> <span class="p">};</span>
<span class="nb">say</span> <span class="nv">@orig</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@new</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># meowmix</span>
<span class="c1"># cowmix</span>
<span class="c1"># [meow cow sow vow]</span>
<span class="c1"># [wow wow wow wow]</span>
</code></pre></div><p>第一个作用在单个值上。我们使用后置形式的 <em>given</em> 块儿, 这让我们避免了花括号（你可以使用 <em>with</em> 代替 <em>given</em> 得到同样的结果）。<code>given $orig</code> 会给 <code>$orig</code> 起个叫做 <code>$_</code> 的别名。从输出来看, 原字符串没有被更改。</p>
<p>第二个例子作用在数组中的一堆字符串身上并且我们使用 <em>do</em> 关键字来执行常规的 <em>for</em> 循环(那种情况下, 它把循环变量别名给 <code>$_</code> 了)并把结果赋值给 <code>@new</code> 数组。再次, 输出显示原来的数组并没有发生改变。</p>
<h2 id="副词">副词</h2>
<p><code>S///</code> 操作符 - 就像 <code>s///</code> 操作符和某些方法一样 - 允许你使用正则表达式副词：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">Lörem Ipsum Dolor Sit Amet</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">g</span>      <span class="p">/</span><span class="sr">m</span><span class="p">/</span><span class="s2">g</span><span class="p">/;</span>  <span class="c1"># Löreg Ipsug Dolor Sit Aget</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">i</span>      <span class="p">/</span><span class="sr">l</span><span class="p">/</span><span class="s2">b</span><span class="p">/;</span>  <span class="c1"># börem Ipsum Dolor Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">ii</span>     <span class="p">/</span><span class="sr">l</span><span class="p">/</span><span class="s2">b</span><span class="p">/;</span>  <span class="c1"># Börem Ipsum Dolor Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">mm</span>     <span class="p">/</span><span class="sr">o</span><span class="p">/</span><span class="s2">u</span><span class="p">/;</span>  <span class="c1"># Lürem Ipsum Dolor Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">nth</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">/</span><span class="sr">m </span><span class="p">/</span><span class="s2">g</span><span class="p">/;</span> <span class="c1"># Lörem Ipsug Dolor Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>   <span class="p">/</span><span class="sr">m </span><span class="p">/</span><span class="s2">g</span><span class="p">/;</span> <span class="c1"># Löreg Ipsug Dolor Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">ss</span><span class="p">/</span><span class="sr">Ipsum Dolor</span><span class="p">/</span><span class="s2">Gipsum</span><span class="se">\n</span><span class="s2">Color</span><span class="p">/;</span> <span class="c1"># Lörem Gipsum Color Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">g</span><span class="p">:</span><span class="na">ii</span><span class="p">:</span><span class="na">nth</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">/</span><span class="sr">m</span><span class="p">/</span><span class="s2">g</span><span class="p">/;</span>             <span class="c1"># Lörem Ipsug Dolor Sit Amet</span>
<span class="p">}</span>
</code></pre></div><p>如你所见, 它们以 <em>:foo</em> 的形式添加在操作符 <strong>S</strong> 这个部件的后面。你可以大大方方地使用空白符号并且几个副词可以同时使用。下面是它们的意义：</p>
<ul>
<li>:g —(长形式：<code>:global</code>)全局匹配：替换掉所有的出现</li>
<li>:i —不区分大小写的匹配</li>
<li>:ii —(长形式： <code>:samecase</code>) 保留大小写：不管用作替换字母的大小写, 使用原来被替换的字母的大小写</li>
<li>:mm —(长形式：<code>:samemark</code>) 保留重音符号：在上面的例子中, 字母 o 上的分音符号被保留并被应用到替换字母 u 上</li>
<li>:nth(n) —只替换第 n 次出现的</li>
<li>:x(n) —至多替换 n 次（助记符: &lsquo;x&rsquo; 作为及时）</li>
<li>:ss —(长形式：<code>samespace</code>)保留空白类型：空白字符的类型被保留, 而不管替换字符串中使用的是什么空白字符。在上面的例子中, 我们使用换行作为替换, 但是原来的空白被保留了。</li>
</ul>
<h2 id="方法形式">方法形式</h2>
<p><code>S///</code> 操作符很好, 但是有时候有点笨拙。不要害怕, Raku 提供了 <code>.subst</code> 方法能满足你所有的替换需求并且消除你对 <code>.subst/.substr</code> 的困惑。下面来看例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">me</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">/</span><span class="sr">m</span><span class="ni">.</span><span class="p">/</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># cowmix</span>
<span class="c1"># cowmix</span>
</code></pre></div><p>这个方法要么接收一个正则表达式要么接收一个普通的字符串作为它的第一个位置参数, 它是要在调用者里面(&ldquo;meowmix&rdquo;)查找的东西。第二个参数是替换字符串。</p>
<p>通过简单地把它们列为具名 Bool 参数, 你也可以使用副词。在 <code>S///</code> 形式中, 副词 <code>:ss</code> 和 <code>:ii</code> 分别表明 <code>:s</code>(使空白有意义) 的出现和  <code>:i</code>(不区分大小写的匹配) 的出现。在方法形式中, 你必须把这些副词应用到正则表达式自身身上：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">Lorem Ipsum Dolor Sit Amet</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">/:</span><span class="na">i</span><span class="sr"> l</span><span class="p">/</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">ii</span><span class="p">;</span>
    <span class="nb">say</span> <span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">/:</span><span class="na">s</span><span class="sr"> Ipsum Dolor</span><span class="p">/</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Gipsum</span><span class="se">\n</span><span class="s2">Color</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">:</span><span class="s">ss</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># Borem Ipsum Dolor Sit Amet</span>
<span class="c1"># Lorem Gipsum Color Sit Amet</span>
</code></pre></div><h2 id="方法形式的捕获">方法形式的捕获</h2>
<p>捕获对于替换操作来说不陌生, 所以我们来尝试捕获下方法调用形式的替换：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">/</span><span class="sr">me </span><span class="p">(</span><span class="ni">.</span><span class="o">+</span><span class="p">)/</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">c</span><span class="nv">$0</span><span class="p">&#34;;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># Use of Nil in string context  in block &lt;unit&gt; at test.p6 line 1</span>
<span class="c1"># c</span>
</code></pre></div><p>不是我们要找的。我们的替换字符串构建在达到 <code>.subst</code> 方法之前, 并且里面的 <code>$0</code> 变量实际上指向任何这个方法调用之前的东西, 而不是 <code>.subst</code> 正则表达式中的捕获。所以我们怎么来修正它呢？</p>
<p><code>.subst</code> 方法的第二个参数也可以接受一个 <a href="http://docs.raku.org/type/Callable">Callable</a>。在它里面, 你可以使用 <code>$0, $1, ... $n</code> 变量, 直到你想要的编号, 并从捕获中得到正确的值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">/</span><span class="sr">me </span><span class="p">(</span><span class="ni">.</span><span class="o">+</span><span class="p">)/</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">c</span><span class="nv">$0</span><span class="p">&#34;</span> <span class="p">};</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># cowmix</span>
</code></pre></div><p>这里, 我们为我们的 <strong>Callable</strong> 使用了尖号块儿, 但是 <strong>WhateverCode</strong> 和子例程也有效。每次替换都会调用这个 Callable, 并且把 <a href="http://docs.raku.org/type/Match">Match</a> 对象作为第一个位置参数传递给 Callable, 如果你需要访问它的话。</p>
<h2 id="结论">结论</h2>
<p><code>S///</code> 操作符在 Raku 中是 <code>s///</code> 操作符的战友, 它不是修改原来的字符串, 而是拷贝原来的字符串, 修改, 然后返回修改过的版本。这个操作符的使用方式跟 Perl 5 中的非破坏性替换操作符的使用方式不同。作为备选, 方法版本的 <code>.subst</code> 也能使用。 方法形式和操作符形式的替换都能接收一组副词以修改它们的行为, 来满足你的需求。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 twigil]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中怎么为已存在的类添加方法" />
                <link href="https://ohmyweekly.github.io/notes/2015-03-16-features-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的特性(二)" />
            
                <id>https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+00:00</published>
            <updated>2021-07-11T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Twigils in Raku</blockquote><h2 id="raku-中的--和--twigil-是什么">Raku 中的 <code>.</code> 和 <code>!</code> <strong>twigil</strong> 是什么？</h2>
<p><code>.</code> <strong>twigil</strong> 的意思是&quot;这是类公用的&quot;, <code>!</code> <strong>twigil</strong> 的意思是“这是类私有的”, 只能用在类的内部。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">ScoreKeeper</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">@.options</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">%!player-points</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>普通的符号表明了词法作用域或包作用域, 但是 <strong>twigils</strong> 就像是 <strong>sigils</strong> 的兄弟, 表明了不同的作用域, 它影响了变量的作用域。<code>.</code> 和 <code>!</code> 是二级 <strong>sigils</strong>。</p>
<p>属性存在于每个类的实例中, 在类的内部, 可以直接使用 <code>!</code> 访问到实例的属性:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">Str</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">&#34;</span><span class="s2">(</span><span class="nv">$!x</span><span class="s2">, </span><span class="nv">$!y</span><span class="s2">)</span><span class="p">&#34;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>那么 <code>.</code> <strong>twigil</strong> 和 <code>!</code> <strong>twigil</strong> 之间有什么关系呢？下面看一个例子:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">Str</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1"># 注意这次我们使用 . 而非 !</span>
        <span class="p">&#34;</span><span class="s2">\$.x 等价于 self.x()</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span>  <span class="k">if</span> <span class="nv">$.x</span> <span class="o">==</span> <span class="nb">self</span><span class="o">.</span><span class="nb">x</span><span class="p">();</span>
        <span class="p">&#34;</span><span class="s2">\$.y 等价于 self.y()</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span>  <span class="k">if</span> <span class="nv">$.y</span> <span class="o">==</span> <span class="nb">self</span><span class="o">.</span><span class="nf">y</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nb">print</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nb">self</span><span class="o">.</span><span class="nb">x</span><span class="p">();</span> <span class="c1"># 调用实例的名为 x 的方法</span>
        <span class="nb">say</span> <span class="nb">self</span><span class="o">.</span><span class="nf">y</span><span class="p">();</span> <span class="c1"># 调用实例的名为 y 的方法</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$point</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="o">,</span> <span class="s">y</span> <span class="o">=&gt;</span> <span class="mi">20</span><span class="p">);</span>
<span class="nv">$point</span><span class="o">.</span><span class="nb">Str</span><span class="p">;</span>   
<span class="nv">$point</span><span class="o">.</span><span class="nb">print</span><span class="p">;</span>
</code></pre></div><p>会输出:</p>
<pre tabindex="0"><code>$.x 等价于 self.x()
$.y 等价于 self.y()
10
20
</code></pre><p>注意到, 属性被声明为 <code>$.x</code> 和 <code>$.y</code>, 但是在类的内部仍旧能通过 <code>$!x</code> 和 <code>$!y</code> 来访问属性。这是因为在 Raku 中所有的属性都是私有的并且在类中可以通过 <code>$!attribute-name</code> 直接访问这些属性。Raku 可以为你自动生成存取方法。</p>
<p>公共属性拥有 <code>.</code> twigil, 私有属性拥有 <code>!</code> twigil。</p>
<p><code>has $.x</code> 就是私有属性 <code>has $!x</code> 加上一个<code>getter</code>方法, 即 <code>method x() { ... }</code>。</p>
<p><code>has $.x is rw</code> 就是私有属性 <code>has $!x</code> 加上一个<code>getter/setter</code>方法。</p>
<h2 id="-twigil-就是调用了与属性同名的方法">. <strong>twigil</strong> 就是调用了与属性同名的方法</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">SaySomething</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;;</span>  <span class="p">}</span>
    <span class="k">method</span> <span class="nf">b</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$.a</span><span class="p">;</span>      <span class="p">}</span>
    <span class="k">method</span> <span class="nf">c</span><span class="p">()</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nf">a</span><span class="p">();</span> <span class="p">}</span> <span class="c1"># 这证明了 $.a 的 . twigil 做了一次隐式的实例方法调用。</span>
<span class="p">}</span>

<span class="n">SaySomething</span><span class="o">.</span><span class="nf">b</span><span class="p">;</span> <span class="c1"># 打印 &#34;a&#34;</span>
<span class="n">SaySomething</span><span class="o">.</span><span class="nf">c</span><span class="p">;</span> <span class="c1"># 打印 &#34;a&#34;</span>
</code></pre></div><h2 id="-twigil-中自动生成的方法可以被子类重写">. <strong>twigil</strong> 中自动生成的方法可以被子类重写</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Circle</span> <span class="k">is</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$!radius</span><span class="p">;</span>

    <span class="c1"># 重写父类中的 x() 方法和 y() 方法</span>
    <span class="k">method</span> <span class="nb">x</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">&#34;</span><span class="s2">I am x point in a Circle</span><span class="p">&#34;;</span>
    <span class="p">}</span>
    <span class="k">method</span> <span class="nf">y</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">&#34;</span><span class="s2">I am y point in a Circle</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$circle</span> <span class="o">=</span> <span class="n">Circle</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">radius</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">);</span>
<span class="nv">$circle</span><span class="o">.</span><span class="nb">x</span><span class="p">()</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># I am x point in a Circle</span>
<span class="nv">$circle</span><span class="o">.</span><span class="nf">y</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>   <span class="c1"># I am y point in a Circle</span>
</code></pre></div><p>如果不想子类重写父类中的方法, 那么在父类中声明属性的时候, 使用 <code>!</code> <strong>twigil</strong> 替代 <code>.</code> <strong>twigil</strong>。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[在 Raku 中怎么为已存在的类添加方法]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
                <link href="https://ohmyweekly.github.io/notes/2015-03-16-features-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的特性(二)" />
            
                <id>https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+00:00</published>
            <updated>2021-07-11T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Add a Method to an Existing Class in Raku</blockquote><h2 id="raku-中怎么为已存在的类添加方法">Raku 中怎么为已存在的类添加方法</h2>
<p>Int 类有一个方法叫做 <code>is-prime</code>, 我想为 <code>Int</code> 类型添加其它的方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">MyInt</span> <span class="k">is</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">is-even</span> <span class="p">()</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">False</span> <span class="k">if</span> <span class="nb">self</span> <span class="nv">%</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">True</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="n">MyInt</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">138</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$n</span><span class="o">.</span><span class="nf">is-even</span><span class="p">;</span>
</code></pre></div><p>通过类的继承也是一种方法, 但是不是我想要的。Swift 中可以通过扩展来实现, Raku 中有一个 <code>add_method</code> 方法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nb">add_method</span><span class="p">(</span><span class="n">Metamodel::MethodContainer:</span> <span class="nv">$obj</span><span class="o">,</span> <span class="nv">$name</span><span class="o">,</span> <span class="nv">$code</span><span class="p">)</span>
</code></pre></div><p>这会给元类(meta class)添加一个方法, 使用 <code>$name</code> 作为调用的方法名。这只会在类型被组合前使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">Int</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">is-even</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">method</span> <span class="p">()</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">False</span> <span class="k">if</span> <span class="nb">self</span> <span class="nv">%</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">True</span><span class="p">;</span>
    <span class="p">}</span> <span class="p">);</span>

<span class="nb">say</span> <span class="mi">137</span><span class="o">.</span><span class="nf">is-even</span><span class="p">;</span>
<span class="nb">say</span> <span class="nb">Int</span><span class="o">.^</span><span class="nb">methods</span><span class="p">;</span>
</code></pre></div><p>如果我调用 <code>Int.^methods</code> 时, <code>is-even</code> 没有出现。但是上面的代码能被调用并起作用了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">Int</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(&#39;</span><span class="s1">fac</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">method</span> <span class="p">()</span> <span class="k">returns</span> <span class="nb">Int:D</span> <span class="p">{</span>
     <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">self</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
     <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">self</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
     <span class="k">my</span> <span class="nv">$sum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="nb">self</span>  <span class="p">{</span><span class="nv">$sum</span> <span class="o">*=</span> <span class="nv">$_</span><span class="p">};</span> <span class="k">return</span> <span class="nv">$sum</span><span class="p">;</span>
<span class="p">});</span>

<span class="mi">1</span><span class="o">.</span><span class="nf">fac</span> <span class="c1"># 1</span>
<span class="mi">5</span><span class="o">.</span><span class="nf">fac</span> <span class="c1"># 120</span>
</code></pre></div><p><code>method</code> 后面的圆括号是方法的签名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">Int</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(&#39;</span><span class="s1">power</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">method</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$num</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nb">self</span> <span class="o">**</span> <span class="nv">$num</span><span class="p">;</span>
<span class="p">});</span>

<span class="mi">2</span><span class="o">.</span><span class="nf">power</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>  <span class="c1"># 8</span>
<span class="mi">2</span><span class="o">.</span><span class="nf">power</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># 1024</span>
</code></pre></div><h2 id="词法方法">词法方法</h2>
<p>我可以让方法不依附于任何类, 并且能在对象上调用该方法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">&amp;is-even</span> <span class="o">=</span> <span class="k">method</span> <span class="p">(</span><span class="nb">Int:D</span> <span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="p">{</span> <span class="nb">self</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="p">};</span>
</code></pre></div><p>这构建了一个 <code>Callable</code>（查看以下 <code>&amp;is-even.WHAT</code>）。 在签名中, 我把它约束为一个定义了的 Int 类型的值(<code>Int:D</code>), 但是没有给它名字。我在类型约束后面添加冒号来说明第一个参数是调用者。现在我能把这个方法应用到任何我想要的对象上:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">137</span><span class="o">.&amp;</span><span class="nf">is-even</span><span class="p">;</span>
<span class="nb">say</span> <span class="mi">138</span><span class="o">.&amp;</span><span class="nf">is-even</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span><span class="o">.&amp;</span><span class="nf">is-even</span><span class="p">;</span>  <span class="c1"># works, although inside is-even blow up</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的特性(二)]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-16-features-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-03-23-sneaking-into-a-loop/?utm_source=atom_feed" rel="related" type="text/html" title="Sneaking Into a Loop" />
            
                <id>https://ohmyweekly.github.io/notes/2015-03-16-features-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+00:00</published>
            <updated>2021-07-10T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Features in Raku</blockquote><h2 id="set">Set</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$keywords</span> <span class="o">=</span> <span class="nb">set</span> <span class="p">&lt;</span><span class="s">if for unless while</span><span class="p">&gt;;</span> <span class="c1"># create a set</span>

<span class="k">sub</span> <span class="nf">has-keyword</span><span class="p">(</span><span class="o">*</span><span class="nv">@words</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nv">@words</span> <span class="k">-&gt;</span> <span class="nv">$word</span> <span class="p">{</span>
        <span class="c1"># 依次检查数组中的元素是否属于集合 $keywords</span>
        <span class="k">return</span> <span class="nb">True</span> <span class="k">if</span> <span class="nv">$word</span> <span class="ow">(elem)</span> <span class="nv">$keywords</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nb">False</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">has-keyword</span> <span class="p">&#39;</span><span class="s1">not</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">one</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">here</span><span class="p">&#39;;</span>  <span class="c1"># False</span>
<span class="nb">say</span> <span class="n">has-keyword</span> <span class="p">&#39;</span><span class="s1">but</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">here</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">for</span><span class="p">&#39;;</span>  <span class="c1"># True</span>
</code></pre></div><h2 id="series-operator">Series Operator</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span><span class="o">=</span><span class="p">&lt;</span><span class="s">A G C T</span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">$x</span><span class="o">=</span><span class="nv">@a</span><span class="p">;</span>

<span class="k">for</span> <span class="mi">1</span> <span class="o">...</span> <span class="o">*</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span>  
  <span class="p">((</span> <span class="o">[</span><span class="ow">X</span><span class="o">~]</span> <span class="nv">$x</span> <span class="ow">xx</span> <span class="nv">$a</span> <span class="p">))</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
  <span class="nb">last</span> <span class="k">if</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>倒序的 range:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="mi">10</span> <span class="o">...</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="o">.</span><span class="nb">say</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><h2 id="flipplop">flip/plop</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$file</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#39;</span><span class="s1">flip_flop.txt</span><span class="p">&#39;;</span>

<span class="k">for</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$line</span> <span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="nv">$line</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="ni">^</span><span class="se">\</span><span class="sr">;</span><span class="p">/</span> <span class="ow">ff</span> <span class="nv">$line</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="ni">^</span><span class="se">\</span><span class="sr">&#34;</span><span class="p">/);</span>
<span class="p">}</span>
</code></pre></div><p><code>$line ~~ m/^\;/ ff $line ~~ m/^\&quot;/</code> 过滤掉 <code>;</code> 和 <code>&quot;</code> 之间的内容, 再对它进行取反操作就是过滤后剩下的文本。</p>
<p>flip_flop.txt 内容如下：</p>
<pre tabindex="0"><code>; next is some lines to skip,include this line
fuck fuck fuck
dam dam dam
mie mie mie
&quot; next is subject
There is more than one way to do it
                                -- Larry Wall

We hope Raku is wrote by the hole Socfilia
                                -- Larry Wall
; next is some lines to skip,include this line
fuck fuck fuck
dam dam dam
mie mie mie
&quot; next is subject
programming is hard,Let's go shopping
                               -- Larry Wall
Ruby is Another Raku
                               -- Larry Wall
</code></pre><p>输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">There is more than one way to do it
                                -- Larry Wall
We hope Raku is wrote by the hole Socfilia
                                -- Larry Wall
programming is hard,Let&#39;s go shopping
                               -- Larry Wall
Ruby is Another Raku
                               -- Larry Wall
</code></pre></div><p><code>ff</code> 操作符左右两侧的 <code>^</code> 表示排除:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">20</span> <span class="p">{</span><span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">9</span> <span class="ow">ff</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">16</span><span class="p">}</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">20</span> <span class="p">{</span><span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">9</span> <span class="ow">^ff</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">16</span><span class="p">}</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">20</span> <span class="p">{</span><span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">9</span> <span class="ow">ff^</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">16</span><span class="p">}</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">20</span> <span class="p">{</span><span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">9</span> <span class="ow">^ff</span><span class="o">^</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">16</span><span class="p">}</span>
</code></pre></div><p>输出:</p>
<pre tabindex="0"><code>9
10
11
12
13
14
15
16
----------
10
11
12
13
14
15
16
----------
9
10
11
12
13
14
15
----------
10
11
12
13
14
15
</code></pre><h2 id="grammars">Grammars</h2>
<p>解析 CSV:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku">﻿<span class="k">grammar</span> <span class="n">CSV</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">line</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">?</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">line</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="ni">^^</span><span class="sr">            </span><span class="c1"># Beginning of a line
</span><span class="c1"></span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">value</span><span class="p">&gt;</span><span class="o">*</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="se">\</span><span class="sr">, </span><span class="c1"># Any number of &lt;value&gt;s with commas in `between` them
</span><span class="c1"></span><span class="sr">        </span><span class="ni">$$</span><span class="sr">            </span><span class="c1"># End of a line
</span><span class="c1"></span><span class="sr">    </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">value</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">[</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">&#34;,</span><span class="se">\n</span><span class="p">]&gt;</span><span class="sr">     </span><span class="c1"># Anything not a double quote, comma or newline
</span><span class="c1"></span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quoted-text</span><span class="p">&gt;</span><span class="sr"> </span><span class="c1"># Or some quoted text
</span><span class="c1"></span><span class="sr">        </span><span class="p">]</span><span class="o">*</span><span class="sr">              </span><span class="c1"># Any number of times
</span><span class="c1"></span><span class="sr">    </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">quoted-text</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="se">\</span><span class="sr">&#34;
</span><span class="sr">        </span><span class="p">[</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">&#34;</span><span class="se">\</span><span class="sr">\</span><span class="p">]&gt;</span><span class="sr"> </span><span class="c1"># Anything not a &#34; or \
</span><span class="c1"></span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">\&#34;</span><span class="p">&#39;</span><span class="sr">     </span><span class="c1"># Or \&#34;, an escaped quotation mark
</span><span class="c1"></span><span class="sr">        </span><span class="p">]</span><span class="o">*</span><span class="sr">         </span><span class="c1"># Any number of times
</span><span class="c1"></span><span class="sr">        </span><span class="se">\</span><span class="sr">&#34;
</span><span class="sr">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1"># method parse($str, :$rule = &#39;TOP&#39;, :$actions) returns Match:D</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Valid CSV file!</span><span class="p">&#34;</span> <span class="k">if</span> <span class="n">CSV</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOCSV/ </span><span class="s">);
</span><span class="s">    Year,Make,Model,Length
</span><span class="s">    1997,Ford,E350,2.34
</span><span class="s">    2000,Mercury,Cougar,2.38
</span><span class="s">    </span><span class="p">EOCSV</span>

<span class="nb">say</span> <span class="n">CSV</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOCSV/,</span><span class="s"> &#39;line&#39;, :$actions );
</span><span class="s">    Year,Make,Model,Length
</span><span class="s">    1997,Ford,E350,2.34
</span><span class="s">    2000,Mercury,Cougar,2.38
</span><span class="s">    </span><span class="p">EOCSV</span>
</code></pre></div><p>解析天气数据:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">StationDataParser</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span>          <span class="p">{</span><span class="sr"> </span><span class="ni">^</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">keyval</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">observations</span><span class="p">&gt;</span><span class="sr"> </span><span class="ni">$</span><span class="sr">             </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">keyval</span>       <span class="p">{</span><span class="sr"> </span><span class="nv">$&lt;key&gt;</span><span class="o">=</span><span class="p">[&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">=</span><span class="p">]&gt;</span><span class="o">+</span><span class="p">]</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="nv">$&lt;val&gt;</span><span class="o">=</span><span class="p">[</span><span class="se">\N</span><span class="o">+</span><span class="p">]</span><span class="sr"> </span><span class="se">\n</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">observations</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">Obs:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="se">\n</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">observation</span><span class="p">&gt;</span><span class="o">+</span><span class="sr">             </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">observation</span>  <span class="p">{</span><span class="sr"> </span><span class="nv">$&lt;year&gt;</span><span class="o">=</span><span class="p">[</span><span class="se">\d</span><span class="o">+</span><span class="p">]</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">temp</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="nv">%%</span><span class="sr"> </span><span class="p">[</span><span class="se">\h</span><span class="o">*</span><span class="p">]</span><span class="sr"> </span><span class="se">\n</span><span class="sr">    </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">temp</span>         <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="o">?</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="se">\</span><span class="sr">. </span><span class="se">\d</span><span class="o">+</span><span class="sr">                          </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">StationData</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.country</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@.data</span><span class="p">;</span>

    <span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(</span><span class="o">:</span><span class="nv">%info</span> <span class="p">(:</span><span class="s">Name</span><span class="p">(</span><span class="nv">$!name</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">Country</span><span class="p">(</span><span class="nv">$!country</span><span class="p">)</span><span class="o">,</span> <span class="o">*</span><span class="nv">%</span><span class="p">)</span><span class="o">,</span> <span class="o">:</span><span class="nv">@!data</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">StationDataActions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="n">StationData</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
            <span class="s">info</span> <span class="o">=&gt;</span> <span class="nv">$&lt;keyval&gt;</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">ast</span><span class="p">)</span><span class="o">.</span><span class="nb">hash</span><span class="o">,</span>
            <span class="s">data</span> <span class="o">=&gt;</span> <span class="nv">$&lt;observations&gt;</span><span class="o">.</span><span class="nb">ast</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">keyval</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="o">~</span><span class="nv">$&lt;key&gt;</span> <span class="o">=&gt;</span> <span class="o">~</span><span class="nv">$&lt;val&gt;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">method</span> <span class="nf">observations</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="nv">$&lt;observation&gt;</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">ast</span><span class="p">)</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*.</span><span class="nb">value</span><span class="o">.</span><span class="nb">none</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">99</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">method</span> <span class="nf">observation</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="o">+</span><span class="nv">$&lt;year&gt;</span> <span class="o">=&gt;</span> <span class="nv">$&lt;temp&gt;</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">Num</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">StationDataParser</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOCSV/,</span><span class="s"> :actions(StationDataActions)).ast
</span><span class="s">Name= Jan Mayen
</span><span class="s">Country= NORWAY
</span><span class="s">Lat=   70.9
</span><span class="s">Long=    8.7
</span><span class="s">Height= 10
</span><span class="s">Start year= 1921
</span><span class="s">End year= 2009
</span><span class="s">Obs:
</span><span class="s">1921 -4.4 -7.1 -6.8 -4.3 -0.8  2.2  4.7  5.8  2.7 -2.0 -2.1 -4.0  
</span><span class="s">1922 -0.9 -1.7 -6.2 -3.7 -1.6  2.9  4.8  6.3  2.7 -0.2 -3.8 -2.6  
</span><span class="s">2008 -2.8 -2.7 -4.6 -1.8  1.1  3.3  6.1  6.9  5.8  1.2 -3.5 -0.8  
</span><span class="s">2009 -2.3 -5.3 -3.2 -1.6  2.0  2.9  6.7  7.2  3.8  0.6 -0.3 -1.3
</span><span class="s"></span><span class="p">EOCSV</span>
</code></pre></div><h2 id="raku-examples">Raku Examples</h2>
<ul>
<li>1、生成8位随机密码</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span>  <span class="nv">@char_set</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">A</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">~</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">!</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">@</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">#</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">$</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">%</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">^</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">&amp;</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">*</span><span class="p">&#39;);</span>
<span class="nb">say</span> <span class="nv">@char_set</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;&#34;)</span> <span class="c1"># 不重复的8位密码</span>

<span class="nb">say</span> <span class="nv">@char_set</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;&#34;)</span> <span class="c1"># 可以重复</span>
</code></pre></div><ul>
<li>2、打印前5个数字</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="o">[^</span><span class="mi">5</span><span class="o">]</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span> <span class="o">...</span> <span class="o">[^</span><span class="mi">10</span><span class="o">]</span>  <span class="c1"># 这个会无限循环</span>
</code></pre></div><ul>
<li>
<p>3、排序</p>
</li>
<li>
<p>3.1 按数值排序</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%hash</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Perl</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">Python</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">Go</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">CMD</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">20</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">Php</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">80</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">Java</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">85</span><span class="p">;</span>

<span class="nv">%hash</span><span class="o">.</span><span class="nb">values</span><span class="o">.</span><span class="nb">sort</span><span class="p">;</span>
<span class="nv">%hash</span><span class="o">.</span><span class="nb">values</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*</span><span class="p">);</span>
</code></pre></div><ul>
<li>3.2 按分数排序散列：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%hash</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Perl</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">80</span><span class="o">,</span>
         <span class="p">&#39;</span><span class="s1">Python</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="o">,</span>
             <span class="p">&#39;</span><span class="s1">Go</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">95</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">CMD</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">20</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">Php</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">80</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">Java</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">85</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">%hash</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span><span class="o">-.</span><span class="nb">value</span><span class="p">})</span><span class="o">.</span><span class="nb">hash</span><span class="o">.</span><span class="nb">keys</span> <span class="k">-&gt;</span> <span class="nv">$key</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$key</span><span class="o">,</span> <span class="p">&#34;</span><span class="se">\t</span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">%hash</span><span class="p">{&#34;</span><span class="nv">$key</span><span class="p">&#34;}</span>
<span class="p">}</span>
</code></pre></div><p>输出:</p>
<pre tabindex="0"><code>Python	100
Go	95
Java	85
Perl	80
Php	80
CMD	20
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(&#39;</span><span class="s1">xx</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">zz</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">classify</span><span class="p">(</span><span class="o">*.</span><span class="nb">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">))&lt;</span><span class="s">z</span><span class="p">&gt;;</span> <span class="c1"># xz yz zz</span>
</code></pre></div><p>加密：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">rot13</span> <span class="p">{</span> <span class="nv">$^s</span><span class="o">.</span><span class="nb">trans</span><span class="p">(&#39;</span><span class="s1">a..z</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">n..za..m</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">A..Z</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">N..ZA..M</span><span class="p">&#39;)</span> <span class="p">}</span>
</code></pre></div><ul>
<li>4、求 1! + 2! + 3! + 4! +5! + 6! +7! +8! +9! +10!</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!</span><span class="p">&gt;(</span><span class="nb">Int</span> <span class="nv">$x</span><span class="p">){</span> <span class="o">[*]</span> <span class="mi">1</span><span class="o">..</span><span class="nv">$x</span> <span class="p">}</span>
<span class="nb">say</span> <span class="o">[+]</span> <span class="mi">1</span><span class="o">!,</span><span class="mi">2</span><span class="o">!,</span><span class="mi">3</span><span class="o">!,</span><span class="mi">4</span><span class="o">!,</span><span class="mi">5</span><span class="o">!,</span><span class="mi">6</span><span class="o">!,</span><span class="mi">7</span><span class="o">!,</span><span class="mi">8</span><span class="o">!,</span><span class="mi">9</span><span class="o">!,</span><span class="mi">10</span><span class="o">!</span> <span class="c1"># 4037913</span>
</code></pre></div><ul>
<li>5、列出对象所有可用的方法</li>
</ul>
<p>使用元对象协议， 即 <code>对象名.^methods</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="p">&#34;</span><span class="s2">JZY</span><span class="p">&#34;</span><span class="o">.^</span><span class="nb">methods</span>
</code></pre></div><blockquote>
<p>BUILD Int Num chomp chop substr pred succ match ords lines samecase samespace tr
im-leading trim-trailing trim words encode wordcase trans indent codes path WHIC
H Bool Str Stringy DUMP ACCEPTS Numeric gist perl comb subst split</p>
</blockquote>
<ul>
<li>6、 匿名子例程</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="k">sub</span><span class="p">(</span><span class="nv">$a</span><span class="p">){</span> <span class="nv">$a</span><span class="o">+</span><span class="mi">2</span> <span class="p">};</span><span class="nb">say</span> <span class="nv">$x</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">4</span>
<span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="nv">$a</span><span class="o">+</span><span class="mi">2</span> <span class="p">};</span><span class="nb">say</span> <span class="nv">$x</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">4</span>
<span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="o">*</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span><span class="nb">say</span> <span class="nv">$x</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">4</span>
</code></pre></div><ul>
<li>7、字符串翻转与分割</li>
</ul>
<pre tabindex="0"><code>&gt; 1223.flip
3221
&gt; 'abcd'.flip
dcba
&gt; 1234.comb
1 2 3 4
&gt; 1234.comb(/./)
1 2 3 4
&gt; 'abcd'.comb
a b c d
</code></pre><ul>
<li>8、有这么一个四位数 A，其个位数相加得到 B，将 B 乘以 B 的反转数后得到 A，请求出这个数字。</li>
</ul>
<p>举例， 1458 就符合这个条件，1+4+5+8 ＝ 18， 18 ＊ 81 ＝1458</p>
<p>请找出另一个符合上面条件的四位数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="o">^</span><span class="mi">37</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span>
  <span class="k">my</span> <span class="nv">$r</span> <span class="o">=</span> <span class="nv">$_</span> <span class="o">*</span> <span class="o">.</span><span class="nb">flip</span><span class="p">;</span>
  <span class="mi">1000</span> <span class="o">&lt;</span> <span class="nv">$r</span> <span class="ow">and</span> <span class="nv">$_</span> <span class="o">==</span> <span class="o">[+]</span> <span class="nv">$r</span><span class="o">.</span><span class="nb">comb</span> <span class="ow">and</span> <span class="nb">say</span> <span class="nv">$r</span>
<span class="p">}</span>
</code></pre></div><p><code>^37</code> 产生一个范围  0 .. ^37, 就是 0到36之前的数，在表达式中代表 B</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$b</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1000</span><span class="o">..^</span><span class="mi">10000</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
  <span class="nv">$b</span><span class="o">=[+]</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">comb</span><span class="p">;</span>
  <span class="nb">say</span> <span class="nv">$i</span> <span class="k">if</span> <span class="nv">$b</span><span class="o">*</span><span class="nv">$b</span><span class="o">.</span><span class="nb">flip</span> <span class="o">==</span> <span class="nv">$i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>输出:</p>
<pre tabindex="0"><code>1458
1729
</code></pre><ul>
<li>9、 大小写转换</li>
</ul>
<pre tabindex="0"><code>&gt; my $word= &quot;I Love Raku&quot;
I Love Raku
&gt; $word.wordcase()
I Love Raku
&gt; my $lowercase = &quot;i love perl 6&quot;
i love perl 6
&gt; $lowercase.wordcase()
I Love Raku
&gt; $word.samecase('A')
I LOVE PERL 6
&gt; $word.samecase('a')
i love perl 6
&gt; $word.samecase('a').wordcase()
I Love Raku
</code></pre><ul>
<li>10、 多行文本</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$string</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/THE END/;</span><span class="s">
</span><span class="s">Norway
</span><span class="s">    Oslo : 59.914289,10.738739 : 2
</span><span class="s">    Bergen : 60.388533,5.331856 : 4
</span><span class="s">Ukraine
</span><span class="s">    Kiev : 50.456001,30.50384 : 3
</span><span class="s">Switzerland
</span><span class="s">    Wengen : 46.608265,7.922065 : 3
</span><span class="s"></span><span class="p">THE END</span>

<span class="nb">say</span> <span class="nv">$string</span><span class="p">;</span>
</code></pre></div><ul>
<li>11、 超运算符与子例程</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">1 2 3 4</span><span class="p">&gt;;</span>

<span class="k">sub</span> <span class="nf">by2</span><span class="p">(</span><span class="nv">$n</span><span class="p">){</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="nv">$n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">power2</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">$n</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@b</span> <span class="o">=</span> <span class="nv">@a</span><span class="o">».&amp;</span><span class="nf">by2</span><span class="o">».&amp;</span><span class="nf">power2</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@b</span><span class="p">;</span> <span class="c1"># 4 16 36 64</span>
</code></pre></div><p>为什么是 <code>&amp;function</code> 呢：</p>
<blockquote>
<p>the name of the by2 function is &amp;by2, just as the name of the foo scalar is $foo and the name of the foo array is @foo</p>
</blockquote>
<ul>
<li>12、 如何在 Raku 中执行外部命令并捕获输出</li>
</ul>
<pre tabindex="0"><code>&gt; my $res = qqx{mkdir 123456}

# 或使用 qx{ }
&gt; my $res = qx{mkdir 112233}
</code></pre><ul>
<li>13、Does Raku support something equivalent to Perl5&rsquo;s <strong>DATA</strong> and <strong>END</strong> sections?</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="n">=foo</span><span class="sd"> This is a Pod block. A single line one. This Pod block&#39;s name is &#39;foo&#39;.
</span><span class="sd">
</span><span class="sd"></span><span class="k">=begin</span><span class="sd"> </span><span class="k">qux</span><span class="sd">
</span><span class="sd">This is another syntax for defining a Pod block.
</span><span class="sd">It allows for multi line content.
</span><span class="sd">This block&#39;s name is &#39;qux&#39;.
</span><span class="sd"></span><span class="k">=end qux</span>

<span class="k">=data</span><span class="sd"> A data block -- a Pod block with the name &#39;data&#39;.
</span><span class="sd">
</span><span class="sd"></span><span class="c1"># Data blocks are P6&#39;s version of P5&#39;s __DATA__.</span>
<span class="c1"># But you can have multiple data blocks:</span>

<span class="k">=begin</span><span class="sd"> </span><span class="k">data</span><span class="sd">
</span><span class="sd">Another data block.
</span><span class="sd">This time a multi line one.
</span><span class="sd"></span><span class="k">=end data</span>

<span class="nv">$=pod</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*.</span><span class="nb">name</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">data</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">contents</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">contents</span><span class="o">.</span><span class="nb">say</span><span class="p">);</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">45</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@$=pod</span> <span class="p">{</span>
  <span class="k">if</span> <span class="o">.</span><span class="nb">name</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">data</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="o">.</span><span class="nb">contents</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">contents</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>14、生成含有26个英文字母和下划线的 junction</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">any</span><span class="p">(&#39;</span><span class="s1">A</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">_</span><span class="p">&#39;);</span>
</code></pre></div><ul>
<li>15、判断一个字符是否在某个集合中</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span>  <span class="nb">so</span> <span class="nb">any</span><span class="p">(&#39;</span><span class="s1">A</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;)</span> <span class="o">∈</span> <span class="nb">set</span><span class="p">(&#34;</span><span class="s2">12a34</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">comb</span><span class="p">)</span>
</code></pre></div><p>&ldquo;12a34&rdquo;.comb 会把字符串分割为单个字符，返回一个字符数组。</p>
<ul>
<li>16、生成 IP 地址范围</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="p">&#34;</span><span class="s2">192.168.10.</span><span class="p">&#34;</span> <span class="p">«</span><span class="s2">~</span><span class="p">»</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="nb">list</span>
</code></pre></div><ul>
<li>17、 生成 OC 中的测试数组</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="p">&#34;</span><span class="s2">@</span><span class="p">&#34;</span> <span class="p">«</span><span class="s2">~</span><span class="p">»</span> <span class="p">&#39;</span><span class="s1">&#34;Perl</span><span class="p">&#39;</span> <span class="p">«</span><span class="s2">~</span><span class="p">»</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">30</span><span class="p">)</span><span class="o">.</span><span class="nb">list</span> <span class="p">«</span><span class="s2">~</span><span class="p">»</span> <span class="p">&#39;</span><span class="s1">&#34;,</span><span class="p">&#39;</span>
</code></pre></div><pre><code>@&quot;Perl&quot;1&quot;,
@&quot;Perl&quot;2&quot;,
@&quot;Perl&quot;3&quot;,
@&quot;Perl&quot;4&quot;,
@&quot;Perl&quot;5&quot;,
…
</code></pre>
<ul>
<li>18、我想以 AGCT 4 种字母为基础生成字符串。</li>
</ul>
<p>比如希望长度为1，输出A,G,C,T。</p>
<p>如果长度为2，输出 AA,AG,AC,AT,GA,GG,GC,GT,CA,CG,CC,CT,TA,TG,TC,TT。这样的结果。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="p">&#34;&#34;</span>             <span class="c1"># 长度为1</span>
<span class="p">(</span><span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span><span class="p">)</span>           <span class="c1"># 长度为2</span>
<span class="p">(</span><span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span><span class="p">)</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span>     <span class="c1"># 长度为3</span>
<span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span> <span class="c1"># 长度为4</span>
</code></pre></div><pre tabindex="0"><code>&gt; my @a=&lt;A G C T&gt;
A G C T
&gt; my $x=@a
A G C T
&gt; $x xx 2
A G C T A G C T
&gt; $x xx 3
A G C T A G C T A G C T
&gt; ($x xx 3).WHAT
(List)
&gt; $x.WHAT
(Array)

&gt; ([X~] $x xx 2).join(',')
AA,AG,AC,AT,GA,GG,GC,GT,CA,CG,CC,CT,TA,TG,TC,TT
</code></pre><p>惰性操作符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span><span class="o">=</span><span class="p">&lt;</span><span class="s">A G C T</span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">$x</span><span class="o">=</span><span class="nv">@a</span><span class="p">;</span>  <span class="c1"># 或者使用 $x = @(&#39;A&#39;,&#39;G&#39;,&#39;C&#39;,&#39;T&#39;)</span>
<span class="k">for</span> <span class="mi">1</span> <span class="o">...^</span> <span class="o">*</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{((</span><span class="o">[</span><span class="ow">X</span><span class="o">~]</span> <span class="nv">$x</span> <span class="ow">xx</span> <span class="nv">$a</span><span class="p">))</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span><span class="nb">last</span> <span class="k">if</span> <span class="nv">$a</span><span class="o">==</span><span class="mi">4</span><span class="p">;};</span>
</code></pre></div><h2 id="best-of-raku">Best Of Raku</h2>
<ul>
<li>Command Line 命令行</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#               Perl 5                                     Raku</span>
 <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">bananas are good</span><span class="se">\n</span><span class="p">&#34;;</span>                     <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">bananas are good</span><span class="p">&#34;;</span>
 <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">and I said: </span><span class="nv">$quotes</span><span class="p">{</span>\&#34;<span class="n">me</span>\&#34;<span class="p">}</span><span class="se">\n</span><span class="p">&#34;;</span>          <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">and I said: </span><span class="nv">%quotes</span><span class="p">{&#34;</span><span class="s2">me</span><span class="p">&#34;}</span><span class="s2">.</span><span class="p">&#34;;</span>
 <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">and I said: </span><span class="nv">$quotes</span><span class="p">{</span>\&#34;<span class="n">me</span>\&#34;<span class="p">}</span><span class="se">\n</span><span class="p">&#34;;</span>          <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">and I said: </span><span class="nv">%quotes</span><span class="s2">&lt;me&gt;.</span><span class="p">&#34;;</span>
 <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">What is ... </span><span class="p">&#34;;</span>                           <span class="nv">$result</span> <span class="o">=</span> <span class="nb">prompt</span> <span class="p">&#34;</span><span class="s2">What is ... </span><span class="p">&#34;;</span>
 <span class="nb">chomp</span><span class="p">(</span><span class="nv">$result</span> <span class="o">=</span> <span class="o">&lt;&gt;</span><span class="p">);</span>
</code></pre></div><ul>
<li>File IO</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#              Perl 5                                     Raku</span>
 <span class="nv">$content</span> <span class="o">=</span> <span class="nb">do</span> <span class="p">{</span> <span class="nb">local</span> <span class="nv">$/</span><span class="p">;</span>                       <span class="nv">$content</span> <span class="o">=</span> <span class="nb">slurp</span> <span class="p">&#34;</span><span class="s2">poetry.txt</span><span class="p">&#34;;</span>
    <span class="nb">open</span> <span class="k">my</span> <span class="nv">$FH</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">poetry.txt</span><span class="p">&#34;;</span> <span class="p">&lt;</span><span class="s">$FH</span><span class="p">&gt;</span>
 <span class="p">};</span>

<span class="nb">chomp</span><span class="p">(</span><span class="nv">@content</span> <span class="o">=</span> <span class="nb">do</span> <span class="p">{</span>                            <span class="nv">@content</span> <span class="o">=</span> <span class="nb">lines</span> <span class="p">&#34;</span><span class="s2">poetry.txt</span><span class="p">&#34;;</span>
    <span class="nb">open</span> <span class="k">my</span> <span class="nv">$FH</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">poetry.txt</span><span class="p">&#34;;</span> <span class="p">&lt;</span><span class="s">$FH</span><span class="p">&gt;</span>
<span class="p">});</span>
</code></pre></div><ul>
<li>Automatic multithreading</li>
</ul>
<p>Applying operations to junctions and arrays is now syntactically compact and readable.
Raku will create threads where appropriate to use multiple processors, cores or hyperthreading for high level language SIMD concurrent processing.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#              Perl 5                                     Raku</span>
 <span class="k">my</span> <span class="nv">$sum</span><span class="p">;</span>                                        <span class="k">my</span> <span class="nv">$sum</span> <span class="o">=</span> <span class="o">[+]</span> <span class="nv">@numbers</span><span class="p">;</span>
 <span class="nv">$sum</span> <span class="o">+=</span> <span class="nv">$_</span> <span class="k">for</span> <span class="nv">@numbers</span><span class="p">;</span>
 <span class="k">for</span> <span class="p">(</span><span class="mi">0</span> <span class="o">..</span> <span class="nv">$</span><span class="c1">#factor1) {                          @product = @factor1 &gt;&gt;*&lt;&lt; @factor2;</span>
   <span class="nv">$product</span><span class="o">[</span><span class="nv">$</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$factor1</span><span class="o">[</span><span class="nv">$</span><span class="o">]</span> <span class="o">*</span> <span class="nv">$factor2</span><span class="o">[</span><span class="nv">$_</span><span class="o">]</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div><p>The Perl 5 code is a simplification, of course Raku &ldquo;does the right thing&rdquo; when the arrays have different lengths.</p>
<ul>
<li>比较</li>
</ul>
<p>Here are junctions, then chained comparison operators.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#            Perl 5                                     Raku</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">or</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>        <span class="k">if</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">|</span> <span class="mi">4</span> <span class="o">|</span> <span class="mi">7</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">if</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;</span> <span class="nv">$a</span> <span class="ow">and</span> <span class="nv">$a</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                   <span class="k">if</span> <span class="mi">4</span> <span class="o">&lt;</span> <span class="nv">$a</span> <span class="o">&lt;</span> <span class="mi">12</span>    <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">if</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;</span> <span class="nv">$a</span> <span class="ow">and</span> <span class="nv">$a</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                  <span class="k">if</span> <span class="nv">$a</span> <span class="o">~~</span> <span class="mi">4</span><span class="o">^..</span><span class="mi">12</span>   <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="nv">$a</span> <span class="o">=</span> <span class="nb">defined</span> <span class="nv">$b</span> <span class="o">?</span> <span class="nv">$b</span> <span class="o">:</span> <span class="nv">$c</span><span class="p">;</span>                      <span class="nv">$a</span> <span class="o">=</span> <span class="nv">$b</span> <span class="o">//</span> <span class="nv">$c</span><span class="p">;</span>
</code></pre></div><p>The defined-OR operator eases lot of cases where Perl 5 newbies could fall into traps.</p>
<ul>
<li>Case 结构</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku">  <span class="c1">#            Perl 5                                      Raku</span>
                                                     <span class="k">given</span> <span class="nv">$a</span> <span class="p">{</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="p">}}</span><span class="err">                      when 2 | 5  {...}
</span><span class="err"> elsif ($a == 6 or $a == 7 or $a == 8 or $a == 9) {}   when 6 .. 9 {...}
</span><span class="err"> elsif ($a =~ /g/) {...}                               when &#39;g&#39;    {...}
</span><span class="err"> else {...}                                            default     {...}
</span><span class="err">                                                     }
</span></code></pre></div><p>That new construct (backported to 5.10) is clear to read, very versatile and when used in combination with junctions, becomes even clearer.</p>
<ul>
<li>强大的循环</li>
</ul>
<p>List iteration via for is now much more versatile.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#            Perl 5                                     Raku</span>
 <span class="k">for</span> <span class="k">my</span> <span class="nv">$i</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">15</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                         <span class="k">for</span> <span class="o">^</span><span class="mi">16</span> <span class="k">-&gt;</span> <span class="nv">$i</span>        <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">for</span> <span class="p">(</span><span class="k">my</span> <span class="nv">$i</span><span class="o">=</span><span class="mi">15</span><span class="p">;</span> <span class="nv">$i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span> <span class="nv">$i-2</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                <span class="k">for</span> <span class="mi">15</span><span class="o">,*-</span><span class="mi">2</span><span class="o">...</span><span class="mi">1</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">for</span> <span class="k">my</span> <span class="nv">$key</span> <span class="p">(</span><span class="nb">keys</span> <span class="nv">%hash</span><span class="p">)</span> <span class="p">{</span>                      <span class="k">for</span> <span class="nv">%hash</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$key</span><span class="o">,</span> <span class="nv">$value</span> <span class="p">{</span>
   <span class="nb">print</span> <span class="p">&#34;</span><span class="nv">$key</span><span class="s2"> =&gt; </span><span class="nv">$hash</span><span class="p">{</span><span class="nv">$key</span><span class="p">}</span><span class="se">\n</span><span class="p">&#34;;</span> <span class="o">...</span>              <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$key</span><span class="s2"> =&gt; </span><span class="nv">$value</span><span class="p">&#34;;</span> <span class="o">...</span>
 <span class="k">for</span> <span class="k">my</span> <span class="nv">$i</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="nv">$</span><span class="c1">#a) {                            for zip(@a; @b; @c) -&gt; $a, $b, $c {...}</span>
   <span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="nv">@a</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="nv">@b</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="nv">@c</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span><span class="p">;</span> <span class="o">...</span>
</code></pre></div><ul>
<li>子例程中的具名参数</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#            Perl 5                                     Raku</span>
 <span class="k">sub</span> <span class="nf">routine</span> <span class="p">{</span>                                   <span class="k">sub</span> <span class="nf">routine</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="o">,</span> <span class="o">*</span><span class="nv">@rest</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
   <span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">@rest</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div><ul>
<li>Objects with auto generated new and getters and setters</li>
</ul>
<p>Simple Object creation is now as easy as it gets.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#              Perl 5                                     Raku</span>
 <span class="nb">package</span> <span class="nn">Heart::Gold</span><span class="p">;</span>                            <span class="k">class</span> <span class="nc">Heart::Gold</span> <span class="p">{</span>
                                                   <span class="k">has</span> <span class="nv">$.speed</span><span class="p">;</span>
 <span class="k">sub</span> <span class="nb">new</span> <span class="p">{</span>                                         <span class="k">method</span> <span class="nf">stop</span> <span class="p">{</span> <span class="nv">$.speed</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">}</span>
   <span class="nb">bless</span> <span class="p">{</span><span class="s">speed</span> <span class="o">=&gt;</span> <span class="mi">0</span> <span class="p">}</span><span class="o">,</span> <span class="nb">shift</span><span class="p">;</span>                   <span class="p">}</span>  
 <span class="p">}</span>
                                                 <span class="k">my</span> <span class="n">Heart::Gold</span> <span class="nv">$hg1</span> <span class="o">.=</span> <span class="nb">new</span><span class="p">;</span>
 <span class="k">sub</span> <span class="nf">speed</span> <span class="p">{</span>                                     <span class="nv">$hg1</span><span class="o">.</span><span class="nf">speed</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">$self</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>                             <span class="k">my</span> <span class="nv">$hg2</span> <span class="o">=</span> <span class="nv">$hg1</span><span class="o">.</span><span class="nb">clone</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">$speed</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="nb">defined</span> <span class="nv">$speed</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$self-</span><span class="o">&gt;</span><span class="p">{</span><span class="n">speed</span><span class="p">}</span> <span class="o">=</span> <span class="nv">$speed</span> <span class="p">}</span>
   <span class="k">else</span> <span class="p">{</span> <span class="nv">$self-</span><span class="o">&gt;</span><span class="p">{</span><span class="n">speed</span><span class="p">}</span> <span class="p">}</span>
 <span class="p">}</span>

 <span class="k">sub</span> <span class="nf">stop</span> <span class="p">{</span>
   <span class="k">my</span> <span class="nv">$self</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
   <span class="nv">$self-</span><span class="o">&gt;</span><span class="p">{</span><span class="n">speed</span><span class="p">}</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div><h2 id="raku-variable">Raku Variable</h2>
<ul>
<li>Variable Types</li>
</ul>
<p>Raku (as Perl 5) knows 3 basic types of variables: Scalars (single values), Arrays (ordered and indexed lists of several values) and Hashes (2 column table, with ID and associated value pairs). They can be easily distinguished, because in front of their name is a special character called sigil (latin for sign). It&rsquo;s the $ (similar to S) for Scalars, @ (like an a) for Arrays and a % (kv pair icon) for a Hash. They are now invariant (not changing), which means for instance, an array vaiable starts always with an @, even if you just want a slice of the content.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$scalar</span>
<span class="nv">@array</span>
<span class="nv">@array</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>              <span class="c1"># $array[1]   in Perl 5</span>
<span class="nv">@array</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>            <span class="c1"># @array[1,2] in Perl 5</span>
<span class="nv">%hash</span>
<span class="nv">%hash</span><span class="p">{&#39;</span><span class="s1">ba</span><span class="p">&#39;}</span>            <span class="c1"># $hash{&#39;ba&#39;} in Perl 5</span>
<span class="nv">%hash</span><span class="p">{&#39;</span><span class="s1">ba</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">da</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">bim</span><span class="p">&#39;}</span> <span class="c1"># @hash{&#39;ba&#39;,&#39;da&#39;,&#39;bim&#39;} in Perl 5</span>
</code></pre></div><p>The sigils also mark distinct namespaces, meaning: in one lexical scope you can have 3 different variables named $stuff, @stuff and %stuff. These sigils can also be used as an operator to enforce a context in which the following data will be seen.</p>
<p>The fourth namespace is for subroutines and similar, even if you don&rsquo;t usually think of them as variables. It&rsquo;s sigil &amp; is used to refer to subroutines without calling them.</p>
<p>All special namespaces from Perl 5 (often marked with special syntax), like tokens (<strong>PACKAGE</strong>), formats, file or dir handles, or builtins are now regular variables or routines.</p>
<p>Because all variables contain objects, they have methods. In fact, all operators, including square or curly bracket subscripts, are just methods of an object with a fancy name.</p>
<p>The primary sigil can be followed by a secondary sigil, called a twigil, which indicates a special scope for that variable.</p>
<h3 id="scalar">Scalar</h3>
<p>This type stores one value, usually a reference to something: a value of a data type, a code object, an object or a compound of values like a pair, junction, array, hash or capture. The scalar context is now called item context, hence the scalar instruction from Perl 5 was renamed to item.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$CHAPTER</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>              <span class="c1"># first comment!</span>
<span class="nv">$bin</span> <span class="o">=</span> <span class="mb">0b11</span><span class="p">;</span>               <span class="c1"># same value in binary format</span>
<span class="nv">$pi</span> <span class="o">=</span> <span class="mf">3.14159_26535_89793</span><span class="p">;</span> <span class="c1"># the underscores just ease reading</span>
<span class="nv">$float</span> <span class="o">=</span> <span class="mf">6.02e-23</span><span class="p">;</span>         <span class="c1"># floating number in scientific notation</span>
<span class="nv">$text</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Welcome all!</span><span class="p">&#39;;</span>    <span class="c1"># single quoted string</span>

<span class="c1"># double quoted string, does eval $pi to it&#39;s content</span>
<span class="nv">$text</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2"> What is </span><span class="nv">$pi</span><span class="s2">?</span><span class="p">&#34;;</span>
<span class="nv">$text</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">&#39;EOT&#39;;</span><span class="s">         # heredoc string
</span><span class="s">
</span><span class="s">    handy for multiline text
</span><span class="s">    like HTML templates or email
</span><span class="s">
</span><span class="s"></span><span class="p">EOT</span>
<span class="nv">$handle</span> <span class="o">=</span> <span class="nb">open</span> <span class="nv">$file_name</span><span class="p">;</span> <span class="c1"># file handle</span>
<span class="c1"># an object from a class with a nested namespace</span>
<span class="nv">$object</span> <span class="o">=</span> <span class="n">Class::Name</span><span class="o">.</span><span class="nb">new</span><span class="p">();</span>
<span class="nv">$condition</span> <span class="o">=</span> <span class="mi">3</span><span class="o">|</span><span class="mi">5</span><span class="o">|</span><span class="mi">7</span><span class="p">;</span>                <span class="c1"># a junction, a logical conjunction of values</span>
<span class="nv">$arrayref</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">21</span><span class="o">]</span><span class="p">;</span> <span class="c1"># an array stored as a single item</span>

<span class="c1"># a hash stored as a single item</span>
<span class="nv">$hashref</span> <span class="o">=</span> <span class="p">{&#39;</span><span class="s1">audreyt</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">pugs</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">pm</span><span class="p">&#39;</span>      <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">pct</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">damian</span><span class="p">&#39;</span>  <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">larrys evil henchman</span><span class="p">&#39;};</span>
<span class="c1"># pointing to a callable</span>
<span class="nv">$coderef</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{</span> <span class="nf">do_something_completely_diffenent</span><span class="p">(</span><span class="nv">@_</span><span class="p">)</span> <span class="p">};</span>
</code></pre></div><p>(For info on some of those terms: comment, binary format, the underscores ease reading, scientific notation, single-quoted string, double-quoted string, heredoc string, file handle, class, junction, list of values, hash, callable.)</p>
<p>Unlike Perl 5, references are automatically dereferenced to a fitting context. So you could use these $arrayrefs and $hashrefs similarly to an array or hash, making $ the universal variable prefix, pretty much like in PHP. The primary difference is that $ prefixed lists are not flattened in lists.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">for</span> <span class="nv">$a</span> <span class="p">{</span> <span class="p">}</span>          <span class="c1"># just one iteration</span>
<span class="k">for</span> <span class="nv">@a</span> <span class="p">{</span> <span class="p">}</span>          <span class="c1"># three iterations</span>
</code></pre></div><h3 id="scalar-methods">Scalar Methods</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$chapter</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">undefine</span> <span class="nv">$chapter</span><span class="p">;</span>
<span class="nb">defined</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1"># false, returns 0</span>
</code></pre></div><ul>
<li>Array</li>
</ul>
<p>An array is an ordered and indexed list of scalars. If not specified otherwise, they can be changed, expanded and shortened anytime and used as a list, stack, queue and much more. As in Haskell, lists are processed lazily, which means: the compiler looks only at the part it currently needs. This way Raku can handle infinite lists or do computation on lists that have not been computed yet. The lazy command enforces this and the eager command forces all values to be computed.</p>
<p>The list context is forced with a @() operator or list() command. That&rsquo;s not autoflattening like in Perl 5 (automatically convert a List of Lists into one List). If you still want that, say flat(). Or say lol() to explicitly prevent autoflattening.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@primes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">19</span><span class="o">,</span><span class="mi">23</span><span class="p">);</span> <span class="c1"># an array gets filled like in Perl 5</span>
<span class="nv">@primes</span> <span class="o">=</span>  <span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">19</span><span class="o">,</span><span class="mi">23</span> <span class="p">;</span> <span class="c1"># same thing, since unlike P5 round braces just do group</span>
<span class="nv">@primes</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">2 3 5 7 11 13 17 19 23</span><span class="p">&gt;;</span> <span class="c1"># ditto, &lt;&gt; is the new qw()</span>
<span class="nv">$primes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">19</span><span class="o">,</span><span class="mi">23</span><span class="p">);</span> <span class="c1"># same array object just sits in $primes, $primes[0] is 2</span>
<span class="nv">$primes</span> <span class="o">=</span> <span class="nb">item</span> <span class="nv">@primes</span><span class="p">;</span>             <span class="c1"># same thing, more explicit</span>
<span class="nv">$primes</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span><span class="p">;</span>                       <span class="c1"># just 2, first element of the Parcel</span>
<span class="nv">@primes</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>                        <span class="c1"># array with one element</span>
<span class="nv">@primes</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">19</span><span class="o">,</span><span class="mi">23</span><span class="o">]</span><span class="p">;</span> <span class="c1"># array with one element (List of Lists - LoL)</span>
<span class="nv">@dev</span>    <span class="o">=</span> <span class="p">{&#39;</span><span class="s1">dan</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">parrot</span><span class="p">&#39;};</span>      <span class="c1"># array with one element (a Hash)</span>
<span class="nv">@data</span>   <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="o">],[</span><span class="mi">6</span><span class="o">..</span><span class="mi">10</span><span class="o">],[</span><span class="mi">11</span><span class="o">..</span><span class="mi">15</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># Array of Arrays (LoL)</span>
<span class="nv">@list</span>   <span class="o">=</span> <span class="n">lol</span> <span class="nv">@data</span><span class="p">;</span>                <span class="c1"># no change</span>
<span class="nv">@list</span>   <span class="o">=</span> <span class="nb">flat</span> <span class="nv">@data</span><span class="p">;</span>               <span class="c1"># returns 1..15</span>
</code></pre></div><ul>
<li>Array Slices</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@primes</span>                       <span class="c1"># all values as list</span>
<span class="nv">@primes</span><span class="o">.</span><span class="nb">values</span>                <span class="c1"># same thing</span>
<span class="nv">@primes</span><span class="o">.</span><span class="nb">keys</span>                  <span class="c1"># list of all indices</span>
<span class="p">&#34;</span><span class="nv">@primes</span><span class="s2">[]</span><span class="p">&#34;</span>                   <span class="c1"># insert all values in a string, uses [] to distinguish from mail adresses</span>
<span class="nv">$prime</span> <span class="o">=</span> <span class="nv">@primes</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>          <span class="c1"># get the first prime</span>
<span class="nv">$prime</span> <span class="o">=</span> <span class="nv">@primes</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>        <span class="c1"># get the last one</span>
<span class="nv">@some</span> <span class="o">=</span> <span class="nv">@primes</span><span class="o">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">5</span><span class="o">]</span><span class="p">;</span>        <span class="c1"># get several</span>
<span class="nv">$cell</span> <span class="o">=</span> <span class="nv">@data</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>          <span class="c1"># get 8, third value of second value (list)</span>
<span class="nv">$cell</span> <span class="o">=</span> <span class="nv">@data</span><span class="o">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>           <span class="c1"># same thing, shorten syntax</span>
<span class="nv">@numbers</span> <span class="o">=</span> <span class="nv">@data</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>          <span class="c1"># get a copy of the second subarray (6..10)</span>
<span class="nv">@copy</span> <span class="o">=</span> <span class="nv">@data</span><span class="p">;</span>                <span class="c1"># shallow copy of the array</span>
</code></pre></div><ul>
<li>Array Methods</li>
</ul>
<p>Some of the more important things you can do with lists. All the methods can also used like ops in &ldquo;elems @array;&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">?</span> <span class="nv">@array</span><span class="p">;</span>              <span class="c1"># boolean context, Bool::True if array has any value in it, even if it&#39;s a 0</span>
<span class="o">+</span> <span class="nv">@array</span><span class="p">;</span>              <span class="c1"># numeric context, number of elements (like in Perl 5 scalar @a)</span>
<span class="o">~</span> <span class="nv">@array</span><span class="p">;</span>              <span class="c1"># string context, you get content of all cells, stringified and joined, same as &#34;@primes[]&#34;</span>

<span class="nv">@array</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>          <span class="c1"># same as + @array</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">end</span><span class="p">;</span>            <span class="c1"># number of the last element, equal to @array.elems-1</span>
<span class="nv">@array</span><span class="o">.</span><span class="nf">cat</span><span class="p">;</span>            <span class="c1"># same ~ @array</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;&#39;);</span>       <span class="c1"># also same result, you can put another string as parameter that gets between all values</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">unshift</span><span class="p">;</span>        <span class="c1"># prepend one value to the array</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>          <span class="c1"># remove the first value and return it</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">push</span><span class="p">;</span>           <span class="c1"># add one value on the end</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">pop</span><span class="p">;</span>            <span class="c1"># remove one value from the end and return it</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">splice</span><span class="p">(</span><span class="nv">$pos</span><span class="o">,</span><span class="nv">$n</span><span class="p">);</span><span class="c1"># starting at $pos remove $n values and replace them with values that follow those two</span>
</code></pre></div><ul>
<li>parameters</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@array</span><span class="o">.</span><span class="nb">delete</span><span class="p">(</span><span class="nv">@ind</span><span class="p">);</span>   <span class="c1"># delete all cells with indices in @ind</span>
<span class="nv">@array</span><span class="o">.</span><span class="nf">exists</span><span class="p">(</span><span class="nv">@ind</span><span class="p">);</span>   <span class="c1"># Bool::True if all indices of @ind have a value (can be 0 or &#39;&#39;)</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="o">[</span><span class="nv">$n</span><span class="o">]</span><span class="p">);</span>     <span class="c1"># return $n (default is 1) randomly selected values, without duplication</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="o">[</span><span class="nv">$n</span><span class="o">]</span><span class="p">);</span>     <span class="c1"># return $n (default is 1) randomly selected values, duplication possible (like roll dice)</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>        <span class="c1"># all elements in reversed order</span>
<span class="c1"># returns a list where $n times first item is taken to last</span>
<span class="c1"># position if $n is positive, if negative the other way around</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="nv">$n</span><span class="p">);</span>

<span class="nv">@array</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="nv">$coderef</span><span class="p">);</span> <span class="c1"># returns a list sorted by a user-defined criteria, default is alphanumerical sorting</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">min</span><span class="p">;</span>            <span class="c1"># numerical smallest value of that array</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">max</span><span class="p">;</span>            <span class="c1"># numerical largest value of that array</span>
<span class="nv">$a</span><span class="o">,</span><span class="nv">$b</span><span class="o">=</span> <span class="nv">@array</span><span class="o">.</span><span class="nb">minmax</span><span class="p">;</span>  <span class="c1"># both at once, like in .sort,  .min, or .max, a sorting algorithm can be provided</span>

<span class="nv">@array</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="nv">$coderef</span><span class="p">);</span>  <span class="c1"># high oder map function, runs $coderef with every value as $_ and returns the list or results</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">classify</span><span class="p">(</span><span class="nv">$cr</span><span class="p">);</span>  <span class="c1"># kind of map, but creates a hash, where keys are the results of $cr and values are from @array</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">categorize</span><span class="p">(</span><span class="nv">$cr</span><span class="p">);</span><span class="c1"># kind of classify, but closure can have no (Nil) or several results, so a key can have a list of values</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span><span class="nv">$_</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">});</span>   <span class="c1"># high order grep, returns only these elements that pass a condition ($cr returns something positive)</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">first</span><span class="p">(</span><span class="nv">$coder</span><span class="p">);</span>  <span class="c1"># kind of grep, return just the first matching value</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">zip</span><span class="p">;</span>            <span class="c1"># join arrays by picking first element left successively from here and then there</span>
<span class="n">There</span> <span class="k">is</span> <span class="nc">even</span> <span class="n">a</span> <span class="n">whole</span> <span class="k">class</span> <span class="k">of</span> <span class="nc">metaoperators</span> <span class="n">that</span> <span class="n">work</span> <span class="n">upon</span> <span class="n">lists</span><span class="o">.</span>
</code></pre></div><ul>
<li>Hash</li>
</ul>
<p>In Raku a Hash is an unordered list of Pairs. A Pair is a single key =&gt; value association and appears in many places of the language syntax. A hash allows lookup of values by key using {} or &lt;&gt; syntax.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%dev</span> <span class="o">=</span>  <span class="p">&#39;</span><span class="s1">pugs</span><span class="p">&#39;</span><span class="o">=&gt;</span><span class="p">&#39;</span><span class="s1">audreyt</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">pct</span><span class="p">&#39;</span><span class="o">=&gt;</span><span class="p">&#39;</span><span class="s1">pm</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">STD</span><span class="p">&#34;</span><span class="o">=&gt;</span><span class="p">&#39;</span><span class="s1">larry</span><span class="p">&#39;;</span>
<span class="nv">%dev</span> <span class="o">=</span> <span class="p">:</span><span class="s">rakudo</span><span class="p">(&#39;</span><span class="s1">jnthn</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">testsuite</span><span class="p">(&#39;</span><span class="s1">moritz</span><span class="p">&#39;);</span>            <span class="c1"># adverb (pair) syntax works as well</span>
<span class="nv">%dev</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">audreyt</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">pugs</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">pm</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">pct</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">larry</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">STD</span><span class="p">&#34;);</span>  <span class="c1"># lists get autoconverted in hash context</span>
<span class="nv">%compiler</span> <span class="o">=</span> <span class="s">Parrot</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="s">Rakudo</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">jnthn</span><span class="p">&#39;}</span><span class="o">,</span> <span class="s">SMOP</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="s">Mildew</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">ruoso</span><span class="p">&#39;};</span>       <span class="c1"># hash of hashes (HoH)</span>
</code></pre></div><ul>
<li>Hash Slices</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$value</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">{&#39;</span><span class="s1">key</span><span class="p">&#39;};</span>      <span class="c1"># just give me the value related to that key, like in P5</span>
<span class="nv">$value</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">&lt;</span><span class="s">pm</span><span class="p">&gt;;</span>         <span class="c1"># &lt;&gt; autoquotes like qw() in P5</span>
<span class="nv">$value</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">&lt;&lt;</span><span class="nv">$name</span><span class="p">&gt;&gt;;</span>    <span class="c1"># same thing, just with eval</span>
<span class="nv">@values</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">{&#39;</span><span class="s1">key1</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">key2</span><span class="p">&#39;};</span>
<span class="nv">@values</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">&lt;</span><span class="s">key1 key2</span><span class="p">&gt;;</span>
<span class="nv">@values</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">&lt;&lt;</span><span class="s2">key1 key2 </span><span class="nv">$key3</span><span class="p">&gt;&gt;;</span>
<span class="nv">%compiler</span><span class="p">&lt;</span><span class="s">Parrot</span><span class="p">&gt;&lt;</span><span class="s">Rakudo</span><span class="p">&gt;;</span> <span class="c1"># value in a HoH, returns &#39;jnthn&#39;</span>
<span class="nv">%compiler</span><span class="p">&lt;</span><span class="s">SMOP</span><span class="p">&gt;;</span>           <span class="c1"># returns the Pair: Mildew =&gt; &#39;ruoso&#39;</span>

<span class="nv">%dev</span>   <span class="p">{&#39;</span><span class="s1">audrey</span><span class="p">&#39;};</span>         <span class="c1"># error, spaces between varname and braces (postcircumfix operator) are no longer allowed</span>
<span class="nv">%dev</span>\  <span class="p">{&#39;</span><span class="s1">allison</span><span class="p">&#39;};</span>        <span class="c1"># works, quote the space</span>
<span class="nv">%dev</span>   <span class="o">.</span><span class="p">&lt;</span><span class="s">dukeleto</span><span class="p">&gt;;</span>        <span class="c1"># error</span>
<span class="nv">%dev</span>\ <span class="o">.</span><span class="p">{&#39;</span><span class="s1">patrick</span><span class="p">&#39;};</span>        <span class="c1"># works too, &#34;long dot style&#34;, because it&#39;s an object in truth</span>
</code></pre></div><ul>
<li>Hash Methods</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">?</span> <span class="nv">%dev</span>                     <span class="c1"># bool context, true if hash has any pairs</span>
<span class="o">+</span> <span class="nv">%dev</span>                     <span class="c1"># numeric context, returns number of pairs(keys)</span>
<span class="o">~</span> <span class="nv">%dev</span>                     <span class="c1"># string context, nicely formatted 2 column table using \t and \n</span>

<span class="nv">$table</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">;</span>             <span class="c1"># same as ~ %dev</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                  <span class="c1"># stringified, but only $key and $value are separated by \t</span>
<span class="nv">@pairs</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">;</span>             <span class="c1"># list of all containing pairs</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">pairs</span>                 <span class="c1"># same thing in all context</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">elems</span>                 <span class="c1"># same as + %dev or + %dev.pairs</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">keys</span>                  <span class="c1"># returns a list of all keys</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">values</span>                <span class="c1"># list of all values</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">kv</span>                    <span class="c1"># flat list with key1, value1, key 2 ...</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">invert</span>                <span class="c1"># reverse all key =&gt; value relations</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">push</span> <span class="p">(</span><span class="nv">@pairs</span><span class="p">)</span>         <span class="c1"># inserts a list of pairs, if a key is already present in %dev, both values gets added to an array</span>
</code></pre></div><ul>
<li>Callable</li>
</ul>
<p>Internally subroutines, methods and alike are variables with the sigil &amp; and stored in a fourth namespace. Unlike Perl 5, all subroutines can be overwritten or augmented with user defined routines. Of course scalars can also contain routines.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">&amp;function</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span>         <span class="c1"># store subroutine in callable namespace</span>
<span class="nf">function</span><span class="p">();</span>                      <span class="c1"># call/run it</span>

<span class="nv">$coderef</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span>          <span class="c1"># store it in a scalar</span>
<span class="nv">$coderef</span><span class="p">(</span><span class="nv">$several</span><span class="o">,</span> <span class="nv">$parameter</span><span class="p">);</span>  <span class="c1"># run that code</span>
</code></pre></div><ul>
<li>Data Types</li>
</ul>
<p>In contrast to variable types (container types) every value has a type too. These are organized internally as classes or roles and can be categorized into 3 piles: the undefined, immutable, and the mutable types.</p>
<p>You can assign one of these types to scalar, array, or hash variables, which enforces the contents to be that type.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Int</span> <span class="nv">$a</span><span class="p">;</span>
<span class="k">my</span> <span class="nb">Int</span> <span class="nv">@a</span><span class="p">;</span>  <span class="c1"># array of Int</span>
</code></pre></div><ul>
<li>Pair</li>
</ul>
<p>Pairs are new and their syntax is used nearly everywhere in the language where there is an association between a name and a value.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$pair</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">jakub</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">helena</span><span class="p">&#39;;</span>  <span class="c1"># &#34;=&gt;&#34; is the pair constructor</span>
<span class="nv">$pair</span> <span class="o">=</span> <span class="p">:</span><span class="s">jakub</span><span class="p">(&#39;</span><span class="s1">helena</span><span class="p">&#39;);</span>     <span class="c1"># same in adverbial notation</span>
<span class="nv">$pair</span> <span class="o">=</span> <span class="p">:</span><span class="s">jakub</span><span class="p">&lt;</span><span class="s">helena</span><span class="p">&gt;;</span>       <span class="c1"># same using &lt;&gt;, the new qw()</span>
<span class="nv">$pair</span><span class="o">.</span><span class="nb">key</span>                     <span class="c1"># returns &#39;jakub&#39;</span>
<span class="nv">$pair</span><span class="o">.</span><span class="nb">value</span>                   <span class="c1"># returns &#39;helena&#39;</span>
<span class="nv">$pair</span><span class="o">.</span><span class="nb">isa</span><span class="p">(</span><span class="nb">Pair</span><span class="p">)</span>               <span class="c1"># Bool::True</span>
</code></pre></div><ul>
<li>Capture</li>
</ul>
<p>Captures are also a new type, which holds the parameters a routine gets. Because Perl now knows both positional and named parameters, it is a mixture of a list and array.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$cap</span> <span class="o">=</span> \<span class="p">(</span><span class="nv">@a</span><span class="o">,</span><span class="nv">$s</span><span class="o">,</span><span class="nv">%h</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">=&gt;</span><span class="mi">3</span><span class="p">);</span>    <span class="c1"># creating a capture, &#34;\&#34; was free since there are no references anymore</span>
<span class="o">|</span><span class="nv">$cap</span>                         <span class="c1"># flatten into argument list (without |, it will pass it as a single value)</span>
<span class="o">||</span><span class="nv">$cap</span>                        <span class="c1"># flatten into semicolon list (meant for variadic functions that take list of lists)</span>
</code></pre></div><p>One important difference between a capture and a compound structure of lists and hashes: While assignments with = will copy the complete content of the named variables, this is not so in the case of a capture. When I change sinthelastexample, thecontentofcap changes too, because when parameters to a routine are variables, they are also interpolated in the moment the routine is called, not when it&rsquo;s defined.</p>
<ul>
<li>
<p>Assignment and Binding</p>
</li>
<li>
<p>Assignment</p>
</li>
</ul>
<p>As rightfully expected, assignments are done with the equal sign. But unlike Perl 5 you always get a copy of the right side data assigned to the left, no matter how nested the data structure was (lists of lists eg). You never get in Raku a reference with =. The only exception may be seen captures.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@original</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$copy</span> <span class="o">=</span> <span class="nv">@original</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span> <span class="c1"># $copy points to [1,2]</span>
<span class="nv">@original</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">fresh stuff</span><span class="p">&#39;;</span> <span class="c1"># $copy[0] holds still 1</span>
</code></pre></div><ul>
<li>Binding</li>
</ul>
<p>Since every variable in Raku is a reference, programmers can use binding to get 2 variables that point to the same memory location.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$original</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nv">$original</span> <span class="o">:=</span> <span class="nv">$mirror</span><span class="p">;</span>       <span class="c1"># normal binding, done on runtime</span>
<span class="nv">$original</span> <span class="o">::=</span> <span class="nv">$mirror</span><span class="p">;</span>      <span class="c1"># same thing, but done during compile time</span>
<span class="nv">$original</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$mirror</span><span class="p">;</span>                <span class="c1"># prints 3</span>
<span class="nv">$original</span> <span class="o">=:=</span> <span class="nv">$mirror</span>       <span class="c1"># true, because they&#39;re bound together</span>
<span class="nv">$original</span> <span class="o">===</span> <span class="nv">$mirror</span>       <span class="c1"># also true, because content and type are equal</span>
</code></pre></div><ul>
<li>FP oriented</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">balanced</span><span class="p">(</span><span class="nv">$s</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">.</span><span class="nb">none</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="o">.[*-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">given</span> <span class="o">[</span>\<span class="o">+]</span> <span class="p">&#39;</span><span class="se">\</span><span class="s1">\</span><span class="p">&#39;</span> <span class="o">«</span><span class="ow">leg</span><span class="o">«</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">comb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="nb">prompt</span> <span class="p">&#34;</span><span class="s2">Number of bracket pairs: </span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">[ ]</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="nv">$n</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$s</span><span class="s2"> </span><span class="p">{</span> <span class="nf">balanced</span><span class="p">(</span><span class="nv">$s</span><span class="p">)</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2">is</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="s2">is not</span><span class="p">&#34;</span> <span class="p">}</span><span class="s2"> well-balanced</span><span class="p">&#34;</span>
</code></pre></div><ul>
<li>String munging</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">balanced</span><span class="p">(</span><span class="nv">$_</span> <span class="k">is</span> <span class="nb">copy</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">while</span> <span class="k">s</span><span class="p">:</span><span class="na">g</span><span class="p">/&#39;</span><span class="s1">[]</span><span class="p">&#39;//;</span>
    <span class="nv">$_</span> <span class="ow">eq</span> <span class="p">&#39;&#39;;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="nb">prompt</span> <span class="p">&#34;</span><span class="s2">Number of bracket pairs: </span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">[ ]</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="nv">$n</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$s</span><span class="s2"> is</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1"> not</span><span class="p">&#39;</span> <span class="ow">xx</span> <span class="nb">not</span> <span class="nf">balanced</span><span class="p">(</span><span class="nv">$s</span><span class="p">))</span><span class="err">, &#34; well-balanced&#34;;
</span></code></pre></div><ul>
<li>Parsing with a grammar</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">BalBrack</span> <span class="p">{</span> <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">TOP</span><span class="p">&gt;</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span> <span class="p">}</span>

<span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="nb">prompt</span> <span class="p">&#34;</span><span class="s2">Number of bracket pairs: </span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">[</span><span class="p">&#39;</span> <span class="ow">xx</span> <span class="nv">$n</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span> <span class="ow">xx</span> <span class="nv">$n</span><span class="p">)</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$s</span><span class="s2"> </span><span class="p">{</span> <span class="n">BalBrack</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$s</span><span class="p">)</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2">is</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="s2">is not</span><span class="p">&#34;</span> <span class="p">}</span><span class="s2"> well-balanced</span><span class="p">&#34;;</span>
</code></pre></div><ul>
<li>凯撒加密</li>
</ul>
<p>实现一个凯撒加密， 编码和解码都要有</p>
<p>key 是一个 1 到 25 之间的整数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@alpha</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">A</span><span class="p">&#39;</span> <span class="o">..</span> <span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;;</span>

<span class="k">sub</span> <span class="nf">encrypt</span> <span class="p">(</span> <span class="nv">$key</span> <span class="k">where</span> <span class="mi">1</span><span class="o">..</span><span class="mi">25</span><span class="o">,</span> <span class="nv">$plaintext</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nv">$plaintext</span><span class="o">.</span><span class="nb">trans</span><span class="p">(</span> <span class="nv">@alpha</span> <span class="ow">Z</span><span class="o">=&gt;</span> <span class="nv">@alpha</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="nv">$key</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">decrypt</span> <span class="p">(</span> <span class="nv">$key</span> <span class="k">where</span> <span class="mi">1</span><span class="o">..</span><span class="mi">25</span><span class="o">,</span> <span class="nv">$cyphertext</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nv">$cyphertext</span><span class="o">.</span><span class="nb">trans</span><span class="p">(</span> <span class="nv">@alpha</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="nv">$key</span><span class="p">)</span> <span class="ow">Z</span><span class="o">=&gt;</span> <span class="nv">@alpha</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$original</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">THE FIVE BOXING WIZARDS JUMP QUICKLY</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$en</span> <span class="o">=</span> <span class="nf">encrypt</span><span class="p">(</span> <span class="mi">13</span><span class="o">,</span> <span class="nv">$original</span> <span class="p">);</span>
<span class="k">my</span> <span class="nv">$de</span> <span class="o">=</span> <span class="nf">decrypt</span><span class="p">(</span> <span class="mi">13</span><span class="o">,</span> <span class="nv">$en</span> <span class="p">);</span>

<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">$original</span><span class="o">,</span> <span class="nv">$en</span><span class="o">,</span> <span class="nv">$de</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">OK</span><span class="p">&#39;</span> <span class="k">if</span> <span class="nv">$original</span> <span class="ow">eq</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">map</span> <span class="p">{</span> <span class="o">.&amp;</span><span class="nf">decrypt</span><span class="p">(</span><span class="o">.&amp;</span><span class="nf">encrypt</span><span class="p">(</span><span class="nv">$original</span><span class="p">))</span> <span class="p">}</span><span class="o">,</span> <span class="mi">1</span><span class="o">..</span><span class="mi">25</span> <span class="p">);</span>
</code></pre></div><pre><code>Output:
THE FIVE BOXING WIZARDS JUMP QUICKLY
GUR SVIR OBKVAT JVMNEQF WHZC DHVPXYL
THE FIVE BOXING WIZARDS JUMP QUICKLY
OK
</code></pre>
<ul>
<li>日期格式化</li>
</ul>
<p>使用 &ldquo;2007-11-10&rdquo; 和 &ldquo;Sunday, November 10, 2007&rdquo; 日期格式显式当前日期:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nb">DateTime</span><span class="o">:</span><span class="p">:</span><span class="s">Utils</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$dt</span> <span class="o">=</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">now</span><span class="p">;</span>

<span class="nb">say</span> <span class="nf">strftime</span><span class="p">(&#39;</span><span class="s1">%Y-%m-%d</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$dt</span><span class="p">);</span>
<span class="nb">say</span> <span class="nf">strftime</span><span class="p">(&#39;</span><span class="s1">%A, %B %d, %Y</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$dt</span><span class="p">);</span>
</code></pre></div><ul>
<li>阶乘</li>
</ul>
<p>n 的阶乘定义为 <code>n*(n-1)*(n-2)…*1</code>, 零的阶乘为1.</p>
<p>定义一个函数返回一个数字的阶乘。</p>
<ul>
<li>使用自定义后缀操作符</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku">
<span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!</span><span class="p">&gt;(</span><span class="nv">$n</span> <span class="k">where</span> <span class="nv">$n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">[*]</span> <span class="mi">2</span><span class="o">..</span><span class="nv">$n</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="mi">5</span><span class="o">!</span>
</code></pre></div><ul>
<li>[*]</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="o">[</span>\<span class="o">*]</span> <span class="mi">1</span><span class="o">..*</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span><span class="p">;</span>
</code></pre></div><p>标量容器中存储的对象不会在 flattening 上下文中插值，即使那个对象是可迭代的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nv">@a</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span> <span class="c1"># 5次迭代</span>
</code></pre></div><p>输出:</p>
<pre tabindex="0"><code>1
2
3
4
5
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="nv">@a</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nv">$s</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># 3次迭代</span>
</code></pre></div><p>输出:</p>
<pre tabindex="0"><code>1
2
3 4 5
</code></pre><p>这里，<code>$s</code> 和 <code>@a</code> 指向同一个数组对象，但是标量容器的出现阻止 <code>$s</code> 被展开到 for 循环中。</p>
<p>.list 和 .flat 方法能被用于还原展开行为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">list</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span>    <span class="c1"># 5次遍历</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nv">@</span><span class="p">(</span><span class="nv">$s</span><span class="p">)</span>   <span class="p">{</span> <span class="o">.</span><span class="nb">say</span>  <span class="p">}</span>   <span class="c1"># 5次遍历，@()会强制为列表上下文</span>
</code></pre></div><p>输出:</p>
<pre tabindex="0"><code>1
2
3
4
5
</code></pre><p>相反，<code>.item</code> 方法和 <code>$()</code> 能用于防止插值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="nv">@a</span><span class="p">;</span>           <span class="c1"># @b 有5个元素</span>
<span class="k">my</span> <span class="nv">@c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="nv">@a</span><span class="o">.</span><span class="nb">item</span><span class="p">;</span>      <span class="c1"># @c 有3个元素</span>
<span class="k">my</span> <span class="nv">@c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="nv">$</span><span class="p">(</span><span class="nv">@a</span><span class="p">);</span>        <span class="c1"># 同上</span>

<span class="nb">say</span> <span class="o">+</span><span class="nv">@c</span><span class="p">;</span> <span class="c1"># 3</span>
</code></pre></div><ul>
<li>Feed operators</li>
</ul>
<p>feed 操作符是完全懒惰的，意味着在使用者要求任何元素之前不会执行任何操作。这就是</p>
<pre tabindex="0"><code class="language-rraku" data-lang="rraku">my @a &lt;== grep { ... } &lt;== map { ... } &lt;== grep { ... } &lt;== 1, 2, 3
</code></pre><p>是完全懒惰的。</p>
<ul>
<li>Grammars</li>
</ul>
<p>文法是一种强大的工具, 用于拆解文本,并通常返回数据结构
例如, Raku 是使用 Raku 风格的文法解析和执行的.
对普通 Raku 用户来说,一个更实用的例子就是 JSON::Simple 模块, 这个模块能反序列化任何有效的 JSON 文件, 反序列化代码还写了不到 100 行, 简单,可扩展.</p>
<p>词法允许你组织正则, 就像类允许你组织普通代码的方法一样.</p>
<h2 id="命名正则">命名正则</h2>
<p>命名正则有特殊的语法, 与<strong>子例程</strong>的定义类似:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">number</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="se">\</span><span class="sr">. </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">?</span><span class="sr"> </span><span class="p">}</span>
</code></pre></div><p>这个例子中, 我们必须使用 <strong>my</strong> 关键词指定这个正则是词法作用域的, 因为 <strong>命名正则</strong> 通常用在 词法中.
给正则命名后有利于在其他地方<code>复用</code>正则:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">32.51</span><span class="p">&#34;</span>    <span class="o">~~</span> <span class="nv">&amp;number</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">15 + 4.5</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">number</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">number</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/</span>
</code></pre></div><p>首先说下, 使用 <code>regex/token/rule</code> 定义了一个正则表达式后怎么去调用它。就像调用一个子例程那样, 使用 <code>&amp;</code> 符号:
<code>&amp;</code> 后面跟正则表达式的名字,  即 <code>&amp;regex_name</code>。</p>
<p>regex 不是命名正则仅有的标识符 &ndash; 实际上, 它用的不多. 大多数时候, 用的最多的是 <code>token</code> 和 <code>rule</code> 标识符. 它们都是<code>不能回溯</code>的, 这意味着正则引擎在匹配失败时不会备份和重试. 这通常是你想要的, 但不是对所有场合都合适:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">works-but-slow</span> <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">+</span><span class="sr"> q </span><span class="p">}</span>
<span class="k">my</span> <span class="k">token</span> <span class="nf">fails-but-fast</span> <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">+</span><span class="sr"> q </span><span class="p">}</span>

<span class="c1"># Tokens 不会沿原路返回, 这让它们更快地失败!</span>
<span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Tokens won</span><span class="se">\</span><span class="s1">&#39;t backtrack, which makes them fail quicker!</span><span class="p">&#39;;</span>

<span class="nb">say</span> <span class="nb">so</span> <span class="nv">$s</span> <span class="o">~~</span> <span class="nv">&amp;works-but-slow</span><span class="p">;</span> <span class="c1"># True</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="nv">$s</span> <span class="o">~~</span> <span class="nv">&amp;fails-but-fast</span><span class="p">;</span> <span class="c1"># False, the entire string get taken by the .+</span>
</code></pre></div><p><code>token</code> 和 <code>rule</code> 标识符的不同之处在于 <code>rule</code> 标识符让 <code>Regex</code> 的 <code>:sigspace</code> 起作用了:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">token</span> <span class="nf">non-space-y</span> <span class="p">{</span><span class="sr"> once upon a time </span><span class="p">}</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">space-y</span>      <span class="p">{</span><span class="sr"> once upon a time </span><span class="p">}</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">onceuponatime</span><span class="p">&#39;</span>    <span class="o">~~</span> <span class="nv">&amp;non-space-y</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">once upon a time</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="nv">&amp;space-y</span><span class="p">;</span>
</code></pre></div><h2 id="action-classes">Action Classes</h2>
<p>实际上, 命名正则甚至能接受额外的参数, 它使用的语法跟子例程参数列表的语法一样.</p>
<p>​写一个程序打印从 1  到 100 的整数，但是对 3 的倍数打印 &ldquo;Fizz&rdquo;, 对 5 的倍数打印 &ldquo;Buzz&rdquo;, 对于即是 3 的倍数，又是 5 的倍数的打印 &ldquo;FizzBuzz&rdquo;.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">100</span> <span class="p">{</span>
    <span class="k">when</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&amp;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">FizzBuzz</span><span class="p">&#39;;</span> <span class="p">}</span>
    <span class="k">when</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">3</span>       <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Fizz</span><span class="p">&#39;;</span>     <span class="p">}</span>
    <span class="k">when</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">5</span>       <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Buzz</span><span class="p">&#39;;</span>     <span class="p">}</span>
    <span class="k">default</span>            <span class="p">{</span> <span class="o">.</span><span class="nb">say</span><span class="p">;</span>           <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Or abusing multi subs:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">fizzbuzz</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$</span> <span class="k">where</span> <span class="o">*</span> <span class="nv">%%</span> <span class="mi">15</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#39;</span><span class="s1">FizzBuzz</span><span class="p">&#39;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nf">fizzbuzz</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$</span> <span class="k">where</span> <span class="o">*</span> <span class="nv">%%</span> <span class="mi">5</span><span class="p">)</span>  <span class="p">{</span> <span class="p">&#39;</span><span class="s1">Buzz</span><span class="p">&#39;</span>     <span class="p">}</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nf">fizzbuzz</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$</span> <span class="k">where</span> <span class="o">*</span> <span class="nv">%%</span> <span class="mi">3</span><span class="p">)</span>  <span class="p">{</span> <span class="p">&#39;</span><span class="s1">Fizz</span><span class="p">&#39;</span>     <span class="p">}</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nf">fizzbuzz</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$number</span> <span class="p">)</span>        <span class="p">{</span> <span class="nv">$number</span>    <span class="p">}</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">100</span><span class="p">)</span><span class="o">».</span><span class="nv">&amp;fizzbuzz</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="se">\n</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</code></pre></div><p>Most concisely:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Fizz</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">3</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">Buzz</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">5</span> <span class="o">||</span> <span class="nv">$_</span> <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">100</span><span class="p">;</span>
</code></pre></div><p>And here&rsquo;s an implementation that never checks for divisibility:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span>
    <span class="p">((&#39;&#39;</span> <span class="ow">xx</span> <span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Fizz</span><span class="p">&#39;)</span> <span class="ow">xx</span> <span class="o">*</span> <span class="ow">Z</span><span class="o">~</span>
    <span class="p">(&#39;&#39;</span> <span class="ow">xx</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Buzz</span><span class="p">&#39;)</span> <span class="ow">xx</span> <span class="o">*</span><span class="p">)</span> <span class="ow">Z</span><span class="o">||</span><span class="err">1</span> <span class="o">..</span> <span class="mi">100</span><span class="p">;</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Sneaking Into a Loop]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-23-sneaking-into-a-loop/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-03-16-features-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的特性(二)" />
            
                <id>https://ohmyweekly.github.io/notes/2015-03-23-sneaking-into-a-loop/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+00:00</published>
            <updated>2021-07-10T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Sneaking Into a Loop</blockquote><h2 id="sneaking-into-a-loop">Sneaking into a loop</h2>
<p>Zoffix 回答了一个关于 Perl 5 的 <code>&lt;&gt;</code> 操作符的<a href="http://irclog.perlgeek.de/raku/2016-08-09#i_12993090">问题</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">slurp</span><span class="o">.</span><span class="nb">words</span><span class="o">.</span><span class="nb">Bag</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*.</span><span class="nb">value</span><span class="p">)</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#34;</span><span class="nv">%10s3d</span><span class="se">\n</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</code></pre></div><p><code>slurp</code> 会从 STDIN 中读取整个 &ldquo;file&rdquo; 并返回一个 Str。方法 <code>Str::words</code> 会按照某种 Unicode 意义的单词把该字符串分割成一个列表。把列表强转为 Bag 则创建一个计数 Hash, 它是如下表述的快捷方式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%h</span><span class="p">;</span>
<span class="nv">%h</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span><span class="o">++</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">peter paul marry</span><span class="p">&gt;;</span>
<span class="n">dd</span> <span class="nv">%h</span><span class="p">;</span>

<span class="c1"># OUTPUT«Hash %h = {:marry(1), :paul(1), :peter(1)}␤»</span>
</code></pre></div><p>在关联数组上调用 <code>.sort(-*.value)</code> 会按照值的降序排序并返回一个排序后的 Pairs 列表。List::fmt 会调用 Pair::fmt, 它调用 fmt 方法, <code>.key</code> 作为其第二个参数, <code>.value</code> 也作为参数。say 会会使用一个空格连接各个元素并输出到标准输出。最后一步有一点错误因为除了第一行之外的每一行前面都会有一个额外的空格。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">slurp</span><span class="o">.</span><span class="nb">words</span><span class="o">.</span><span class="nb">Bag</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*.</span><span class="nb">value</span><span class="p">)</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#34;</span><span class="nv">%10s</span><span class="s2"> =&gt; </span><span class="nv">%3d</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="se">\n</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</code></pre></div><p>手动连接字符串更好。这对于简短的单行程序来说有点多了。我们需要找到最长的单词并使用 <code>.chars</code> 来获取列宽。</p>
<p>slurp 会在 <code>$*IN</code> 身上调用 <code>.slurp-rest</code> 方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="vg">$*IN</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">peter paul marry peter paul paul</span><span class="p">&gt;</span> <span class="k">but</span> <span class="k">role</span> <span class="p">{</span> <span class="k">method</span> <span class="nb">slurp-rest</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nb">Str</span> <span class="p">}</span> <span class="p">};</span>
</code></pre></div><p>这是一种 hack 因为它会在任何形式的类型检测上失败并且它除了 slurp 之外不会对任何东西起作用。还有, 实际上我们从 <code>$*IN</code> 那里解绑 STDIN。不要在工作中使用这个奇淫技巧。</p>
<p>现在我们能开心地吞噬并开始计数了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%counted-words</span> <span class="o">=</span> <span class="nb">slurp</span><span class="o">.</span><span class="nb">words</span><span class="o">.</span><span class="nb">Bag</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$word-width</span> <span class="o">=</span> <span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="nv">%counted-words</span><span class="o">.</span><span class="nb">keys</span><span class="o">».</span><span class="nb">chars</span><span class="p">;</span>
</code></pre></div><p>并且继续在链子断开的地方继续。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%counted-words</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*.</span><span class="nb">value</span><span class="p">)</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#34;</span><span class="s2">%</span><span class="p">{</span><span class="nv">$word-width</span><span class="p">}</span><span class="s2">s3d</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="se">\n</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</code></pre></div><p>问题解决了但是很丑陋。我们把一个单行程序拆开了。我们来修复 fmt 以使它再次完整。</p>
<p>我们想要的是一个 fmt 方法, 它接收一个位置的(Positional), 一个 printf 风格的格式字符串和一个格式字符串中的 block per <code>%*</code>。还有, 我们可能需要在 self.fmt 前面放上一个分隔符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">multi</span> <span class="k">method</span> <span class="nb">fmt</span><span class="p">(</span><span class="n">Positional:D:</span> <span class="nv">$fmt-str</span><span class="o">,</span> 
                    <span class="o">*</span><span class="nv">@width</span> <span class="k">where</span> <span class="o">*.</span><span class="nb">all</span> <span class="o">~~</span> <span class="nb">Callable</span><span class="o">,</span>
                    <span class="o">:</span><span class="nv">$separator</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;){</span>
    <span class="nb">self</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(</span>
        <span class="nv">$fmt-str</span><span class="o">.</span><span class="nb">subst</span><span class="p">(:</span><span class="s">g</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">%*</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">{</span>
            <span class="k">my</span> <span class="nv">&amp;width</span> <span class="o">=</span> <span class="nv">@width</span><span class="o">[</span><span class="nv">$</span><span class="o">++]</span> <span class="o">//</span> <span class="nb">Failure</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">missingh block</span><span class="p">&#34;);</span>
            <span class="p">&#39;</span><span class="s1">%</span><span class="p">&#39;</span> <span class="o">~</span> <span class="p">(</span><span class="nv">&amp;width</span><span class="o">.</span><span class="nb">count</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">??</span> <span class="nf">width</span><span class="p">(</span><span class="nb">self</span><span class="o">,</span> <span class="nv">$_</span><span class="p">)</span> <span class="o">!!</span> <span class="nf">width</span><span class="p">(</span><span class="nb">self</span><span class="p">))</span>
        <span class="p">})</span><span class="o">,</span> <span class="nv">$separator</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>表达式 <code>*.all ~~ Callable</code> 检查 <a href="https://docs.raku.org/type/Signature#Slurpy_(A.K.A._Variadic)_Parameters">slurp array</a>中的所有元素是否实现了 CALL-ME(那是实际被执行的方法在你执行 foo()的时候)。</p>
<p>然后我们在格式字符串上使用了 <code>subst</code> 来替换 <code>%*</code>, 替换是一个(闭包)块儿, 它每次匹配被调用一次。而且这儿我们有不错的惯用法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">1-a 2-b 3-c</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">subst</span><span class="p">(:</span><span class="s">g</span><span class="o">,</span> <span class="p">/</span><span class="se">\d</span><span class="p">/</span><span class="o">,</span> <span class="p">{&lt;</span><span class="s">one two three</span><span class="p">&gt;</span><span class="o">[</span><span class="nv">$</span><span class="o">++]</span><span class="p">});</span>
<span class="c1"># one-a two-b three-c</span>
</code></pre></div><p>匿名状态变量 <code>$</code> 从 0  开始计数, 每次代码块执行时增 1。实际上我们在这儿做的就是移除一个循环并给 subst 偷偷加入一个额外的计数器和数组下标。或者可以说我们注册了一个迭代器到 subst 里面的循环中。有人可能会质疑 subst 应该接收一个 Seq 作为它的第二个位置参数, 它会让调用变得冗长。无论如何, 我们把洞补上了。</p>
<p>在第 11 行, 我们从吞噬数组中拿出一个元素或者在没有元素时创建一个 Failure。我们把 block 存储在一个变量中因为我们想在第 12 行中内省。如果那个 block 接收两个位置参数,we feed the topic subst is calling the block with as a 2nd parameter to our stored block. 那碰巧是一个 Match 并且对于影响所匹配的东西可能有用。在我们这个例子中我们对 <code>%*</code> 进行匹配并且当前位置由 <code>$++</code> 计数。做完那个之后我们得到了一个格式字符串, 它带有一个由用户提供的 fmt 版本的列宽参数。</p>
<p>用户提供的块儿使用一组 Pairs 调用。我们不得不深入一层以得到更大的键。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">{</span><span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="o">.</span><span class="nb">values</span><span class="o">».</span><span class="nb">keys</span><span class="o">».</span><span class="nb">chars</span><span class="p">}</span>
</code></pre></div><p>得到第一列的列宽。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">print</span> <span class="nv">%counted-words</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*.</span><span class="nb">value</span><span class="p">)</span><span class="o">.&amp;</span><span class="nb">fmt</span><span class="p">(</span>
    <span class="p">&#34;</span><span class="nv">%*s3d</span><span class="p">&#34;</span><span class="o">,</span> 
    <span class="p">{</span><span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="o">.</span><span class="nb">values</span><span class="o">».</span><span class="nb">keys</span><span class="o">».</span><span class="nb">chars</span><span class="p">}</span><span class="o">,</span> 
    <span class="s">separator</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="se">\n</span><span class="p">&#34;);</span>
</code></pre></div><p>那个时髦的 <code>.&amp;fmt</code> 调用是必须的因为我们免费的浮点方法不是 List 的方法。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[自定义 when]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-02-28-custom-when/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="related" type="text/html" title="如果集合如我所想" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/?utm_source=atom_feed" rel="related" type="text/html" title="模式分派" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2021-02-28-custom-when/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-28T00:00:00+00:00</published>
            <updated>2021-02-28T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Custom When</blockquote><p>我不太喜欢上一篇文章中使用匹配的语法。它的参数列表中的逗号看起来很奇怪，不合适。也许是因为我的眼睛习惯了给定的块。睡一觉就好了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">accord</span><span class="p">(</span><span class="nv">&amp;c</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="n">CALLER::</span><span class="p">&lt;</span><span class="s">$_</span><span class="p">&gt;);</span> <span class="k">succeed</span><span class="p">)</span> <span class="k">if</span> <span class="nv">&amp;c</span><span class="o">.</span><span class="nb">cando</span><span class="p">(</span>\<span class="p">(</span><span class="n">CALLER::</span><span class="p">&lt;</span><span class="s">$_</span><span class="p">&gt;))</span> <span class="p">}</span>

<span class="k">given</span> <span class="n">Err</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">msg</span><span class="p">&lt;</span><span class="s">a</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="n">accord</span> <span class="k">-&gt;</span> <span class="n">Hold</span> <span class="p">(</span><span class="o">:</span><span class="nv">$key</span><span class="p">)</span> <span class="p">{</span> <span class="nb">put</span> „<span class="n">holding</span> <span class="nv">$key</span>“<span class="p">;</span> <span class="p">}</span>
    <span class="n">accord</span> <span class="k">-&gt;</span> <span class="n">Err</span> <span class="p">(</span><span class="o">:</span><span class="nv">$msg</span><span class="p">)</span> <span class="p">{</span> <span class="nb">warn</span> „<span class="n">ERR:</span> <span class="nv">$msg</span>“ <span class="p">}</span>
    <span class="k">default</span> <span class="p">{</span> <span class="nb">fail</span> ‚<span class="n">unsupported</span>‘ <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这是因为 <code>accord</code> 模仿了 <code>when</code> 的工作。它做了一些匹配，当 True 时调用一个块，并在每个块的结尾添加一个 success（通过抛出一个控制异常）。given 所做的只是设置主题。它还充当了 caller 的角色，所以我们可以通过一个伪包来访问它的 <code>$_</code>。利用 pointy 的签名来做<a href="https://docs.raku.org/type/Signature#Destructuring_arguments">解构</a>是相当强大的。把这个添加到 CORE 中可能是个好主意。</p>
<p>我们可能要把 Raku 的定义改成: &ldquo;Raku 是一种高度可组合的编程语言&rdquo;, 在这里，所有的东西都会落到实处。&quot;</p>
<p>更新一下。</p>
<p>有些情况下，<code>$_</code> 不是动态的。另外，success 正在抛出一个控制异常，而这些的处理程序是由 when 或默认添加的。这种情况是在编译时发生的，目前不能用宏来解决。第一个问题可以用黑魔法解决。后一个问题需要用默认块。我没有找到一种方法来提供一个合理的错误信息，如果缺少这个块。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">accord</span><span class="p">(</span><span class="nv">&amp;c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nb">nqp</span><span class="p">;</span>
    <span class="nv">$_</span> <span class="o">:=</span> <span class="nf">nqp::getlexcaller</span><span class="p">(&#39;</span><span class="s1">$_</span><span class="p">&#39;);</span>
    <span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="nv">$_</span><span class="p">);</span> <span class="k">succeed</span><span class="p">)</span> <span class="k">if</span> <span class="nv">&amp;c</span><span class="o">.</span><span class="nb">cando</span><span class="p">(</span>\<span class="p">(</span><span class="nv">$_</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nv">@possibilities</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$needle</span> <span class="p">{</span>
    <span class="k">given</span> <span class="nv">$needle</span> <span class="p">{</span>
        <span class="n">accord</span> <span class="k">-&gt;</span> <span class="n">Hold</span> <span class="p">(</span><span class="o">:</span><span class="nv">$key</span><span class="p">)</span> <span class="p">{</span> <span class="nb">put</span> „<span class="n">holding</span> <span class="nv">$key</span>“<span class="p">;</span> <span class="p">}</span>
        <span class="n">accord</span> <span class="k">-&gt;</span> <span class="n">Err</span> <span class="p">(</span><span class="o">:</span><span class="nv">$msg</span><span class="p">)</span> <span class="p">{</span> <span class="nb">warn</span> „<span class="n">ERR:</span> <span class="nv">$msg</span>“ <span class="p">}</span>
        <span class="k">default</span> <span class="p">{</span> <span class="nb">warn</span> ‚<span class="n">unsopported</span>‘ <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>原文链接: <a href="https://gfldex.wordpress.com/2021/02/25/custom-when/">https://gfldex.wordpress.com/2021/02/25/custom-when/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/raku" term="raku" label="Raku" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Caesarean Substrings With Raku and Perl]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="related" type="text/html" title="如果集合如我所想" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-07T00:00:00+00:00</published>
            <updated>2021-02-07T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Caesarean Substrings With Raku and Perl</blockquote><p>[113] 发表于2021年1月30日。
这是我对 <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-097/">Perl 每周挑战#097</a> 的回应。</p>
<h2 id="挑战-0971-凯撒密码">挑战 #097.1: 凯撒密码</h2>
<p>给你一个只包含字母 <code>A..Z</code> 的字符串 <code>$S</code> 和一个数字 <code>$N</code>。
写一个脚本，用<a href="https://en.wikipedia.org/wiki/Caesar_cipher">凯撒密码</a>对给定的字符串 <code>$S</code> 进行加密，左移大小为 <code>$N</code>。</p>
<p>例子:
输入: $S = &ldquo;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&rdquo;, $N = 3
输出: &ldquo;QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD&rdquo;</p>
<p>Plain:    ABCDEFGHIJKLMNOPQRSTUVWXYZ
Cipher:   XYZABCDEFGHIJKLMNOPQRSTUVW</p>
<p>Plaintext:  THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG
Ciphertext: QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD</p>
<p>&ldquo;只用字母 <code>A...Z</code>&rdquo; 的表述是错误的，因为例子中也有几个空格。因此，应该允许这些空格。</p>
<p>文件: caesar-cipher</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">subset</span> <span class="nc">AZ-space</span> <span class="k">of</span> <span class="nb">Str</span> <span class="k">where</span> <span class="o">/^</span> <span class="p">&lt;</span><span class="s">[ A .. Z \s ]</span><span class="p">&gt;</span><span class="o">+</span> <span class="nv">$/</span><span class="p">;</span>   <span class="c1"># [1]</span>
<span class="k">subset</span> <span class="nc">PosInt</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">where</span> <span class="o">-</span><span class="mi">25</span> <span class="o">&lt;=</span> <span class="nv">$_</span> <span class="o">&lt;=</span> <span class="mi">25</span><span class="p">;</span>            <span class="c1"># [2]</span>

<span class="k">unit</span> <span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="n">AZ-space</span> <span class="nv">$S</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</span><span class="p">&#39;</span><span class="o">,</span>
               <span class="n">PosInt</span> <span class="nv">$N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">);</span>                         <span class="c1"># [3]</span>

<span class="nb">say</span> <span class="nv">$S</span><span class="o">.</span><span class="nb">comb</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="nf">caesar</span><span class="p">(</span><span class="nv">$_</span><span class="o">,</span> <span class="nv">$N</span><span class="p">)</span> <span class="p">})</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>              <span class="c1"># [4]</span>

<span class="k">sub</span> <span class="nf">caesar</span> <span class="p">(</span><span class="nv">$char</span><span class="o">,</span> <span class="nv">$shift</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nv">$char</span> <span class="k">if</span> <span class="nv">$char</span> <span class="ow">eq</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;;</span>                        <span class="c1"># [5]</span>

  <span class="k">my</span> <span class="nv">$code</span> <span class="o">=</span> <span class="nv">$char</span><span class="o">.</span><span class="nb">ord</span><span class="p">;</span>                                <span class="c1"># [6]</span>

  <span class="nv">$code</span> <span class="o">-=</span> <span class="nv">$shift</span><span class="p">;</span>                                     <span class="c1"># [7]</span>

  <span class="nv">$code</span> <span class="o">+=</span> <span class="mi">26</span> <span class="k">if</span> <span class="nv">$code</span> <span class="o">&lt;</span> <span class="mi">65</span><span class="p">;</span>  <span class="c1"># &#39;A&#39;                    # [8]</span>
  <span class="nv">$code</span> <span class="o">-=</span> <span class="mi">26</span> <span class="k">if</span> <span class="nv">$code</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">;</span>  <span class="c1"># &#39;Z&#39;                    # [8a]</span>

  <span class="k">return</span> <span class="nv">$code</span><span class="o">.</span><span class="nb">chr</span><span class="p">;</span>                                    <span class="c1"># [9]</span>
<span class="p">}</span>
</code></pre></div><p>[1] 所允许的字符 (或 «特定领域字母»).</p>
<p>[2] 挑战说左移值是一个数字。允许除整数以外的任何东西是没有意义的，所以我把值限制在这个类型。负值应该是可以的，它们意味着右移值（而不是左移）。</p>
<p>[3] 参数，默认值为挑战中给出的值。</p>
<p>[4] 将字符串分割成单个字符（用梳子(comb)，在每个字符上应用 &ldquo;caesar&rdquo; 函数（用map），再次将字符连接成一个字符串（用join），然后打印出来。</p>
<p>[5] 不移动空格。</p>
<p>[6] 获取字符的代码点。</p>
<p>[7] 减去移位值（当我们向左移位时，或在字母表中降低移位值）。</p>
<p>[8] 绕回, 如果我们移出A-Z范围，这里为更低 - 或更高的 [8b]。</p>
<p>[9] 获取指定代码点的字符。</p>
<p>查看 docs.raku.org/routine/ord 获取更多关于 ord 的信息。</p>
<p>查看 docs.raku.org/routine/chr 获取更多关于 chr 的信息。</p>
<p>运行它:</p>
<pre tabindex="0"><code>$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
</code></pre><p>Raku 有一个 ords 变体，它接收一整个字符串，而不是一个字符作为 ord。还有 chrs，它接收一个代码点数组，并将它们变成一个字符串，而不是像 chr 那样接收一个字符的代码点。让我们用它们来写一个更短的程序。</p>
<p>文件: caesar-cipher-map</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">subset</span> <span class="nc">AZ-space</span> <span class="k">of</span> <span class="nb">Str</span> <span class="k">where</span> <span class="o">/^</span> <span class="p">&lt;</span><span class="s">[ A .. Z \s ]</span><span class="p">&gt;</span><span class="o">+</span> <span class="nv">$/</span><span class="p">;</span>
<span class="k">subset</span> <span class="nc">PosInt</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">where</span> <span class="o">-</span><span class="mi">25</span> <span class="o">&lt;=</span> <span class="nv">$_</span> <span class="o">&lt;=</span> <span class="mi">25</span><span class="p">;</span>

<span class="k">unit</span> <span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="n">AZ-space</span> <span class="nv">$S</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</span><span class="p">&#39;</span><span class="o">,</span>
               <span class="n">PosInt</span> <span class="nv">$N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">);</span>

<span class="nb">say</span> <span class="nf">caesar</span><span class="p">(</span><span class="nv">$S</span><span class="o">,</span> <span class="nv">$N</span><span class="p">);</span>

<span class="k">sub</span> <span class="nf">caesar</span> <span class="p">(</span><span class="nv">$string</span><span class="o">,</span> <span class="nv">$shift</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nv">$string</span><span class="o">.</span><span class="nb">ords</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span><span class="nv">$_</span> <span class="o">==</span> <span class="mi">32</span> <span class="o">??</span> <span class="mi">32</span> <span class="o">!!</span> <span class="p">((</span><span class="nv">$_</span> <span class="o">-</span> <span class="nv">$shift</span> <span class="o">-</span> <span class="mi">65</span><span class="p">)</span> <span class="nv">%</span> <span class="mi">26</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">65</span><span class="p">})</span><span class="o">.</span><span class="nb">chrs</span><span class="p">;</span>
    <span class="c1"># #################### # 1a ############# ############ # 1b  # 1c ## 1d</span>
<span class="p">}</span>
</code></pre></div><p>[1] 我们使用map来改变各个代码点。我们让代码点为32的空间单独存在[1a]。每一个其他的值我们都还原成0到25之间的数字（通过减去第一个字母的代码点（A：65）和移位值[1b]）。模数运算符 (%) 为我们处理负值，做正确的事情。例如：-2 % 26 -&gt; 24 [1c]。然后我们添加调整值到它们应该在的位置(从A到Z)[1d]，然后我们将整个数组的代码点变成一个字符串。</p>
<p>查看 docs.raku.org/routine/ords 获取更多关于 ords 的信息。</p>
<p>查看 docs.raku.org/routine/chrs 获取更多关于 chrs 的信息。</p>
<p>运行它的结果和之前一样。</p>
<pre tabindex="0"><code>$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
</code></pre><h2 id="perl-版本">Perl 版本</h2>
<p>这是对第一个 Raku 版的直接翻译。</p>
<p>File: caesar-cipher-perl</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="ch">#! /usr/bin/env perl</span>

<span class="k">use</span> <span class="nn">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">feature</span> <span class="s">&#39;say&#39;</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">feature</span> <span class="s">&#39;signatures&#39;</span><span class="p">;</span>

<span class="k">no</span> <span class="nn">warnings</span> <span class="s">&#34;experimental::signatures&#34;</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$S</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="sr">//</span> <span class="s">&#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39;</span><span class="p">;</span>

<span class="nb">die</span> <span class="s">&#34;Illegal characters&#34;</span> <span class="k">unless</span> <span class="nv">$S</span> <span class="o">=~</span><span class="sr"> /^[A-Z\s]+$/</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$N</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="sr">//</span> <span class="mi">3</span><span class="p">;</span>

<span class="nb">die</span> <span class="s">&#34;Illegal shift $N&#34;</span> <span class="k">if</span> <span class="nv">$N</span> <span class="o">!~</span> <span class="sr">/^\-?\d+$/</span> <span class="o">||</span> <span class="nv">$N</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">25</span> <span class="o">||</span> <span class="nv">$N</span> <span class="o">&gt;</span> <span class="mi">25</span><span class="p">;</span>

<span class="n">say</span> <span class="nb">join</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nb">map</span> <span class="p">{</span> <span class="n">caesar</span><span class="p">(</span><span class="nv">$_</span><span class="p">,</span> <span class="nv">$N</span><span class="p">)</span> <span class="p">}</span> <span class="nb">split</span><span class="p">(</span><span class="sr">//</span><span class="p">,</span> <span class="nv">$S</span><span class="p">));</span>

<span class="k">sub</span> <span class="nf">caesar</span> <span class="p">($char, $shift)
</span><span class="p">{</span>
  <span class="k">return</span> <span class="nv">$char</span> <span class="k">if</span> <span class="nv">$char</span> <span class="ow">eq</span> <span class="s">&#34; &#34;</span><span class="p">;</span>

  <span class="k">my</span> <span class="nv">$code</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="nv">$char</span><span class="p">);</span>

  <span class="nv">$code</span> <span class="o">-=</span> <span class="nv">$shift</span><span class="p">;</span>

  <span class="nv">$code</span> <span class="o">+=</span> <span class="mi">26</span> <span class="k">if</span> <span class="nv">$code</span> <span class="o">&lt;</span> <span class="mi">65</span><span class="p">;</span>  <span class="c1"># &#39;A&#39;</span>
  <span class="nv">$code</span> <span class="o">-=</span> <span class="mi">26</span> <span class="k">if</span> <span class="nv">$code</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">;</span>  <span class="c1"># &#39;Z&#39;</span>

  <span class="k">return</span> <span class="nb">chr</span><span class="p">(</span><span class="nv">$code</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>运行它的结果和 Raku 版一样。</p>
<pre tabindex="0"><code>$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
</code></pre><h2 id="挑战-0972二进制子字符串binary-substrings">挑战 #097.2：二进制子字符串(Binary Substrings)</h2>
<p>给你一个二进制字符串 <code>$B</code> 和一个整数 <code>$S</code>。</p>
<p>写一个脚本来拆分大小为 <code>$S</code> 的二进制字符串 <code>$B</code>，然后找出使其相同的最小翻转次数。</p>
<p>例 1:
输入: $B = “101100101”, $S = 3
输出: 1</p>
<p>二进制子字符串:
&ldquo;101&rdquo;: 0 flip
&ldquo;100&rdquo;: 1 flip to make it &ldquo;101&rdquo;
&ldquo;101&rdquo;: 0 flip</p>
<p>例 2:
输入 $B = “10110111”, $S = 4
输出: 2</p>
<p>二进制子字符串:
&ldquo;1011&rdquo;: 0 flip
&ldquo;0111&rdquo;: 2 flips to make it &ldquo;1011&rdquo;</p>
<p>我们先从第一个例子中的二进制子字符串中砍掉3个字符块。</p>
<pre tabindex="0"><code>&gt; say &quot;101100101&quot;.comb(3);   # -&gt; (101 100 101)
&gt; say &quot;1011001010&quot;.comb(3);  # -&gt; (101 100 101 0)
</code></pre><p>第二行显示了如果长度不匹配会发生什么。这就给了我们一个非法的值，因为我们不能将一位数翻转为三位数的值。所以我们必须添加一个检查。</p>
<p>然后我们将第一个子串与其余的子串进行比较，一次一个。在这里使用bitwise XOR（Exclusive OR）运算符是一个合理的选择。这给了我们一个二进制值，其中1的数量就是该子串的翻转次数。Raku确实有一个XOR运算符。+^. 但是它 &ldquo;将两个参数都强制为Int，并进行位智XOR操作&rdquo;(根据文档&quot;；参见docs.raku.org/language/operators#infix_+^)。</p>
<p>我们可以在进行XOR操作之前，将二进制值转换为十进制值。让我们试试。</p>
<p>获取翻转的次数。</p>
<pre tabindex="0"><code>&gt; say (&quot;10101&quot;.parse-base(2) +^ &quot;10111&quot;.parse-base(2)).base(2).comb.sum;  # -&gt; 1
&gt; say (&quot;11101&quot;.parse-base(2) +^ &quot;10111&quot;.parse-base(2)).base(2).comb.sum;  # -&gt; 2
</code></pre><p>这当然可行，但需要大量的代码。所以我将使用一个更简单的方法 - 逐个比较每个数字。</p>
<p>File: binary-substring</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">subset</span> <span class="nc">BinaryString</span> <span class="k">where</span> <span class="o">/^</span> <span class="p">&lt;</span><span class="s">[01]</span><span class="p">&gt;</span><span class="o">+</span> <span class="nv">$/</span><span class="p">;</span>                    <span class="c1"># [1]</span>
<span class="k">subset</span> <span class="nc">PosInt</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">where</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>                           <span class="c1"># [2]</span>

<span class="k">unit</span> <span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="n">BinaryString</span> <span class="nv">$B</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">101100101</span><span class="p">&#39;</span><span class="o">,</span>               <span class="c1"># [1]</span>
               <span class="n">PosInt</span> <span class="nv">$S</span> <span class="k">where</span> <span class="nv">$B</span><span class="o">.</span><span class="nb">chars</span> <span class="nv">%%</span> <span class="nv">$S</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span>          <span class="c1"># [2]</span>
	       <span class="p">:</span><span class="s">v</span><span class="p">(</span><span class="o">:</span><span class="nv">$verbose</span><span class="p">));</span>

<span class="k">my</span> <span class="nv">@B</span>     <span class="o">=</span> <span class="nv">$B</span><span class="o">.</span><span class="nb">comb</span><span class="p">(</span><span class="nv">$S</span><span class="o">.</span><span class="nb">Int</span><span class="p">);</span>                                <span class="c1"># [3]</span>
<span class="k">my</span> <span class="nv">$first</span> <span class="o">=</span> <span class="nv">@B</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>                                       <span class="c1"># [4]</span>
<span class="k">my</span> <span class="nv">$total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                              <span class="c1"># [5]</span>

<span class="k">for</span> <span class="nv">@B</span> <span class="k">-&gt;</span> <span class="nv">$current</span>                                          <span class="c1"># [6]</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="nv">$flip</span> <span class="o">=</span> <span class="nf">bit-diff</span><span class="p">(</span><span class="nv">$first</span><span class="o">,</span> <span class="nv">$current</span><span class="p">);</span>                    <span class="c1"># [7]</span>
  <span class="nv">$total</span> <span class="o">+=</span> <span class="nv">$flip</span><span class="p">;</span>                                          <span class="c1"># [8]</span>
  <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">: </span><span class="nv">$first</span><span class="s2"> -&gt; </span><span class="nv">$current</span><span class="s2"> -&gt; Flip: </span><span class="nv">$flip</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$verbose</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nv">$total</span><span class="p">;</span>                                                 <span class="c1"># [9]</span>

<span class="k">sub</span> <span class="nf">bit-diff</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span>                                       <span class="c1"># [7]</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="nv">$flip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                             <span class="c1"># [10]</span>

  <span class="k">for</span> <span class="o">^</span><span class="nv">$a</span><span class="o">.</span><span class="nb">chars</span> <span class="k">-&gt;</span> <span class="nv">$index</span>                                   <span class="c1"># [11]</span>
  <span class="p">{</span>
    <span class="nv">$flip</span><span class="o">++</span> <span class="k">if</span> <span class="nv">$a</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="nv">$index</span><span class="o">,</span><span class="mi">1</span><span class="p">)</span> <span class="ow">ne</span> <span class="nv">$b</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="nv">$index</span><span class="o">,</span><span class="mi">1</span><span class="p">);</span>  <span class="c1"># [12]</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nv">$flip</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>[1] 确保二进制字符串是合法的（只包含 &ldquo;0 &ldquo;和 &ldquo;1&rdquo;）。</p>
<p>[2] 确保是一个正整数，同时确保字符串是被它偶数分割的。(例如，&ldquo;4 &ldquo;给我们提供了长度为4的子串，如果最后一个较短，程序将中止。)</p>
<p>[3] 梳子通常用于将一个字符串分割成单个字符，但我们可以通过指定长度来获得每个子字符串中的多个字符，比如这样。</p>
<p>[4] 例子首先将第一个子串与自己进行比较，给出零翻转。这是愚蠢的(ish)，所以我跳过这一点，把第一个子串移出。</p>
<p>[5] 结果会到这里。</p>
<p>[6] 对于每一个子串（除了第一个，见[4]）。</p>
<p>[7] 获取每个子串的翻转次数。</p>
<p>[8] 并将其添加到总数中。</p>
<p>[9] 打印它。</p>
<p>[10] 翻转的数量会在这里。</p>
<p>[11] 对于两个子串中的每个索引（具有相同的长度）。</p>
<p>[12] - 如果给定位置上的字符不同，则在总数的基础上加1，意味着移动。</p>
<p>See docs.raku.org/routine/comb for more information about comb.</p>
<p>运行它。</p>
<pre tabindex="0"><code>$ ./binary-substring &quot;101100101&quot; 3
 1

$ ./binary-substring -v &quot;101100101&quot; 3
: 101 -&gt; 100 -&gt; Flip: 1
: 101 -&gt; 101 -&gt; Flip: 0
1

$ ./binary-substring &quot;10110111&quot; 4
2

$ ./binary-substring -v &quot;10110111&quot; 4
: 1011 -&gt; 0111 -&gt; Flip: 2
2
</code></pre><p>看起来不错。</p>
<h2 id="perl">Perl</h2>
<p>这是对 Raku 版本的直接翻译，只是我必须实现 &ldquo;comb&rdquo;。</p>
<p>文件： binary-substring-perl</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env perl</span>

<span class="k">use</span> <span class="nb">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="nb">feature</span> <span class="p">&#39;</span><span class="s1">say</span><span class="p">&#39;;</span>
<span class="k">use</span> <span class="nb">feature</span> <span class="p">&#39;</span><span class="s1">signatures</span><span class="p">&#39;;</span>
<span class="k">use</span> <span class="nn">Getopt::Long</span><span class="p">;</span>

<span class="k">no</span> <span class="nf">warnings</span> <span class="p">&#34;</span><span class="s2">experimental::signatures</span><span class="p">&#34;;</span>

<span class="k">my</span> <span class="nv">$verbose</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nf">GetOptions</span><span class="p">(&#34;</span><span class="s2">verbose</span><span class="p">&#34;</span>  <span class="o">=&gt;</span> \<span class="nv">$verbose</span><span class="p">);</span>

<span class="k">my</span> <span class="nv">$B</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="o">//</span> <span class="p">&#39;</span><span class="s1">101100101</span><span class="p">&#39;;</span>

<span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Not a binary number</span><span class="p">&#34;</span> <span class="k">unless</span> <span class="nv">$B</span> <span class="o">=~</span> <span class="o">/^[</span><span class="mo">01</span><span class="o">]+</span><span class="nv">$/</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$S</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span><span class="p">;</span>

<span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Not an integer</span><span class="p">&#34;</span> <span class="k">unless</span> <span class="nv">$S</span> <span class="o">=~</span> <span class="o">/^[</span><span class="mi">1</span><span class="o">-</span><span class="mi">9</span><span class="o">][</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="o">]*</span><span class="nv">$/</span><span class="p">;</span>
<span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Not a legal length</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nf">length</span><span class="p">(</span><span class="nv">$B</span><span class="p">)</span> <span class="nv">%</span> <span class="nv">$S</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">@B</span>     <span class="o">=</span>  <span class="nb">comb</span><span class="p">(</span><span class="nv">$B</span><span class="o">,</span> <span class="nv">$S</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$first</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@B</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">for</span> <span class="k">my</span> <span class="nv">$current</span> <span class="p">(</span><span class="nv">@B</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="nv">$flip</span> <span class="o">=</span> <span class="nf">bit_diff</span><span class="p">(</span><span class="nv">$first</span><span class="o">,</span> <span class="nv">$current</span><span class="p">);</span>
  <span class="nv">$total</span> <span class="o">+=</span> <span class="nv">$flip</span><span class="p">;</span>
  <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">: </span><span class="nv">$first</span><span class="s2"> -&gt; </span><span class="nv">$current</span><span class="s2"> -&gt; Flip: </span><span class="nv">$flip</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$verbose</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nv">$total</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">bit_diff</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="nv">$flip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="k">my</span> <span class="nv">$index</span> <span class="p">(</span><span class="mi">0</span> <span class="o">..</span> <span class="nf">length</span><span class="p">(</span><span class="nv">$a</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="nv">$flip</span><span class="o">++</span> <span class="k">if</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$index</span><span class="o">,</span><span class="mi">1</span><span class="p">)</span> <span class="ow">ne</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$b</span><span class="o">,</span> <span class="nv">$index</span><span class="o">,</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nv">$flip</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">comb</span> <span class="p">(</span><span class="nv">$string</span><span class="o">,</span> <span class="nv">$length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># [1]</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="nv">@result</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="nv">$string</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="nb">push</span><span class="p">(</span><span class="nv">@result</span><span class="o">,</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">$length</span><span class="p">));</span>
    <span class="nv">$string</span> <span class="o">=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="o">,</span> <span class="nv">$length</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nv">@result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>[1] 缺失的 Raku 例程 &ldquo;comb&rdquo;。可选的第二个参数指定了它所返回的每个子串中所包含的（第一个参数的）子串长度。</p>
<p>运行它的结果与 Raku 版本相同。</p>
<pre tabindex="0"><code>$ ./binary-substring-perl &quot;101100101&quot; 3
1

$ ./binary-substring-perl -v &quot;101100101&quot; 3
: 101 -&gt; 100 -&gt; Flip: 1
: 101 -&gt; 101 -&gt; Flip: 0
1

$ ./binary-substring-perl &quot;101100111&quot; 3
2

$ ./binary-substring-perl -v &quot;101100111&quot; 3
: 101 -&gt; 100 -&gt; Flip: 1
: 101 -&gt; 111 -&gt; Flip: 1
2
</code></pre><p>就是这样。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/raku" term="raku" label="Raku" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[如果集合如我所想]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-07T00:00:00+00:00</published>
            <updated>2021-02-07T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>If Sets Would DWIM</blockquote><h1 id="if-sets-would-dwimhttpsdonaldhwtf202101if-sets-would-dwim"><a href="https://donaldh.wtf/2021/01/if-sets-would-dwim/">If Sets Would DWIM</a></h1>
<p>每当我在 Raku 中使用集合的时候，它们经常无法 <a href="https://docs.raku.org/language/glossary#DWIM">DWIM</a>。这是一个简短的探索，看看是否可以改进 DWIMminess。</p>
<p>我最近重新审视了我前段时间写的一个利用 <code>(-)</code> 集差运算符的脚本。这段代码有一个 bug 潜伏在那里，显而易见，因为下面的代码并没有按照我的直觉去做。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku">  <span class="k">my</span> <span class="nv">@allowed</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">m c i p l o t</span><span class="p">&gt;;</span>
  <span class="k">my</span> <span class="nv">@chars</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">impolitic</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">comb</span><span class="p">;</span>

  <span class="k">my</span> <span class="nv">@remainder</span> <span class="o">=</span> <span class="nv">@allowed</span> <span class="ow">(-)</span> <span class="nv">@chars</span><span class="p">;</span>

  <span class="k">if</span> <span class="o">+</span><span class="nv">@remainder</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
     <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">pangram</span><span class="p">&#39;;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">unused: [</span><span class="p">{</span><span class="nv">@remainder</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;)}</span><span class="s2">]</span><span class="p">&#34;;</span>
  <span class="p">}</span>
<span class="n">unused:</span> <span class="o">[]</span>
</code></pre></div><p>错误的原因是 <code>(-)</code> 产生了一个 Set，而赋值给 <code>@remainder</code> 会产生1项的 Array。总是这样。但不方便的是，当它是一个空集合时，它就会字符串化为一个空字符串，这只是帮助掩盖了这个潜伏的错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@items</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="nb">d</span> <span class="nb">e</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@items</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">+</span><span class="nv">@items</span><span class="p">;</span>
</code></pre></div><pre tabindex="0"><code>[Set.new()]
1
</code></pre><p>解决方法比较简单。只要不赋值给数组就可以了。使用一个标量容器来代替。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$items</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$items</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">+</span><span class="nv">$items</span><span class="p">;</span>
</code></pre></div><pre tabindex="0"><code>Set.new(&quot;e&quot;,&quot;c&quot;)
2
</code></pre><p>甚至是关联容器也可以。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%items</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">%items</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">+</span><span class="nv">%items</span><span class="p">;</span>
</code></pre></div><pre tabindex="0"><code>{:c(Bool::True), :e(Bool::True)}
2
</code></pre><p>或在赋值前明确地取出键的列表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@items</span> <span class="o">=</span> <span class="p">(&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span><span class="p">)</span><span class="o">.</span><span class="nb">keys</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@items</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">+</span><span class="nv">@items</span><span class="p">;</span>
</code></pre></div><pre tabindex="0"><code>[&quot;e&quot;, &quot;c&quot;]
2
</code></pre><p>很好，起作用了。只是不要用数组容器来处理 <code>Setty</code> 这样的东西。只是这并不能阻止我的直觉时不时地碰上这个错误。同一类的 bug 在我的代码中出现过好几次，因为它实在是太容易犯错了。Raku 不会告诉我，我做错了什么，因为也许是故意的。但重要的是， Raku 没有设法 DWIM。</p>
<p>我可以采取的另一个方法是养成添加类型信息的习惯。这样确实可以让 Raku 在我掉进这个陷阱的时候告诉我。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Str</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div><pre tabindex="0"><code>Type check failed in assignment to @a; expected Str but got Set (Set.new(&quot;e&quot;,&quot;c&quot;))
  in sub  at EVAL_0 line 3
  in block &lt;unit&gt; at EVAL_0 line 5
  in block &lt;unit&gt; at -e line 1
</code></pre><p>这是一个明显的例子，添加类型信息有助于 Raku 编译器帮助我避免引入这种 bug。</p>
<h2 id="实验---为-set-自定义数组存储">实验 - 为 Set 自定义数组存储</h2>
<p>我开始研究核心设置(core setting)，看看可以做什么。我惊喜地发现，我可以在 <code>Array.STORE</code> 的多重分派中添加我正在寻找的语义。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nn">MONKEY</span><span class="p">;</span>

<span class="k">augment</span> <span class="k">class</span> <span class="nb">Array</span> <span class="p">{</span>
   <span class="k">multi</span> <span class="k">method</span> <span class="nb">STORE</span><span class="p">(</span><span class="nb">Array</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nb">Set</span> \<span class="nb">item</span> <span class="k">--&gt;</span> <span class="nb">Array:D</span><span class="p">)</span> <span class="p">{</span>
       <span class="nb">self</span><span class="o">.</span><span class="nb">STORE</span><span class="p">(</span><span class="nb">item</span><span class="o">.</span><span class="nb">keys</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">+</span><span class="nv">@a</span><span class="p">;</span>
</code></pre></div><pre tabindex="0"><code>[&quot;c&quot;, &quot;e&quot;]
2
</code></pre><p>分享这个似乎是谨慎的，看看我的小 DWIM 是否有任何我没有考虑到的问题或缺点。一个可能的缺点是，如果你需要这样做的话，你需要使用 <code>,</code> 来强制将一个集合变成一个数组。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span> <span class="o">,</span> <span class="p">;</span>
<span class="nb">say</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
</code></pre></div><pre tabindex="0"><code>[Set.new(&quot;e&quot;,&quot;c&quot;)]
</code></pre><h2 id="下一步是什么">下一步是什么</h2>
<p>我希望这能引发关于这个问题以及其他我们的直觉和 Raku 的行为不太一致的情况的讨论。也许还有其他相关的语言边缘可以被磨平，以消除这种危害。</p>
<h2 id="后续">后续</h2>
<p>在 <a href="https://t.co/0QSoMxrSXf?amp=1">Reddit</a> 上有一些非常有启发性的讨论，涵盖了语言语义和各种替代方法。公平地说，我建议的方法引入了更多的不一致性，而不是价值，但讨论可能会导致一个语言一致的解决方案。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/flink" term="flink" label="Flink" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
</feed>
