<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.85.0">Hugo</generator><title type="html"><![CDATA[rakulang on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/rakulang/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/rakulang/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/rakulang/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/rakulang/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2021-07-07T23:01:08+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/rakulang/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Using Raku]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-14-using-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-03-14-using-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-07T00:00:00+08:00</published>
            <updated>2021-07-07T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Using Raku</blockquote><h2 id="第一章-概要">第一章 概要</h2>
<p>略</p>
<h2 id="第二章-基础">第二章 基础</h2>
<p>假设有一场乒乓球比赛, 比赛结果以这种格式记录：</p>
<pre><code>Player1 Player2 | 3:2
</code></pre><p>这意味着选手1与选手2的比分为 3:2, 你需要一个脚本算出每位选手赢了几场比赛并且胜了几局。输入数据(存储在一个叫做 scores 的文件中)像下面这样：</p>
<pre><code>Beth Ana Charlie Dave
Ana Dave        | 3:0
Charlie Beth    | 3:1
Ana Beth        | 2:3
Dave Charlie    | 3:0
Ana Charlie     | 3:1
Beth Dave       | 0:3
</code></pre><p>第一行是选手清单。随后每一行记录着比赛结果。</p>
<p>这里使用 Raku 给出一种解决方案：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!/usr/bin/env raku</span>

<span class="k">my</span> <span class="nv">$file</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#39;</span><span class="s1">scores</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">get</span><span class="o">.</span><span class="nb">words</span> <span class="p">;</span>  <span class="c1"># get 方法读入一行, 每调用一次 get, 读取一行</span>
<span class="k">my</span> <span class="nv">%matches</span><span class="p">;</span>                   <span class="c1"># 赢得比赛次数</span>
<span class="k">my</span> <span class="nv">%sets</span><span class="p">;</span>                      <span class="c1"># 赢得比赛局数</span>

<span class="k">for</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>                       <span class="c1"># .lines 是惰性的</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$pairing</span><span class="o">,</span> <span class="nv">$result</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> | </span><span class="p">&#39;);</span> <span class="c1"># 对剩下的每一行调用 split 操作</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$p1</span><span class="o">,</span> <span class="nv">$p2</span><span class="p">)</span>          <span class="o">=</span> <span class="nv">$pairing</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>     <span class="c1"># 提取选手1和选手2的名字</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$r1</span><span class="o">,</span> <span class="nv">$r2</span><span class="p">)</span>          <span class="o">=</span> <span class="nv">$result</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">:</span><span class="p">&#39;);</span> <span class="c1"># 提取比赛比分</span>

    <span class="nv">%sets</span><span class="p">{</span><span class="nv">$p1</span><span class="p">}</span> <span class="o">+=</span> <span class="nv">$r1</span><span class="p">;</span>  <span class="c1"># 选手1赢得的比赛局数</span>
    <span class="nv">%sets</span><span class="p">{</span><span class="nv">$p2</span><span class="p">}</span> <span class="o">+=</span> <span class="nv">$r2</span><span class="p">;</span>  <span class="c1"># 选手2赢得的比赛局数</span>

    <span class="k">if</span> <span class="nv">$r1</span> <span class="o">&gt;</span> <span class="nv">$r2</span> <span class="p">{</span> <span class="c1"># 如果每场比赛中, 选手1赢的局数多于选手2, 则选手1赢得的比赛数+1, 反之选手2的+1</span>
        <span class="nv">%matches</span><span class="p">{</span><span class="nv">$p1</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nv">%matches</span><span class="p">{</span><span class="nv">$p2</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@names</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span> <span class="p">{</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@sorted</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$n</span><span class="s2"> has won </span><span class="nv">%matches</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span><span class="s2"> matches and </span><span class="nv">%sets</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span><span class="s2"> sets</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>输出如下：</p>
<pre><code>Ana has won 2 matches and 8 sets
Dave has won 2 matches and 6 sets
Charlie has won 1 matches and 4 sets
Beth has won 1 matches and 4 sets
</code></pre><p>每个 Raku 程序应该以 <code>#!/usr/bin/env raku</code> 作为开始。</p>
<p>在 Raku 中, 变量名以一个魔符打头, 这个魔符是一个非字母数字符号, 诸如 <code>$</code>, <code>@</code>, <code>%</code> 或者 <code>&amp;</code>, 还有更少见的双冒号 <code>::</code>。
内置函数 <a href="https://docs.raku.org/routine/open">open</a> 打开了一个名叫 scores 的文件, 并返回一个文件句柄, 即一个代表该文件的对象。赋值符号 <code>=</code> 将句柄赋值给左边的变量, 这意味着 <code>$file</code> 现在存储着该文件句柄。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">get</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>
</code></pre></div><p>上边这句的右侧对存储在 <code>$file</code> 中的文件句柄调用了 <a href="https://docs.raku.org/routine/get">get</a> 方法, <code>get</code> 方法从文件中读取并返回一行, 并去掉行的末尾。<a href="https://docs.raku.org/routine/words">.words</a> 也是一个方法, 用于从 get 方法返回的字符串上。<code>.words</code> 方法将它的组件 - 它操作的字符串, 分解成一组单词, 这里即意味着不含空格的字符串。它把单个字符串 &lsquo;Beth Ana Charlie Dave&rsquo; 转换成一组字符串 &lsquo;Beth&rsquo;, &lsquo;Ana&rsquo;, &lsquo;Charlie&rsquo;, &lsquo;Dave&rsquo;。最后, 这组字符串存储在数组 <code>@names</code> 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%matches</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">%sets</span><span class="p">;</span>
</code></pre></div><p>在比分计数程序中, <code>%matches</code> 存储每位选手赢得的比赛数, <code>%sets</code> 存储每位选手赢得的比赛局数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>for 循环中 $file.lines 产生一组从文件 scores 读取的行, 从上次 $file.lines 离开的地方开始, 一直到文件末尾结束。
在第一次循环中, $line 会包含字符串 <code>Ana Dave | 3:0;</code> 在第二次循环中, $line 会包含 <code>Charlie Beth | 3:1</code>,以此类推。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="p">(</span><span class="nv">$pairing</span><span class="o">,</span> <span class="nv">$result</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> | </span><span class="p">&#39;);</span>
</code></pre></div><p>split此处是一个方法, 字符串 &lsquo;|&rsquo; 是它的参数。</p>
<p>第一次循环结束：</p>
<pre><code>Variable       Contents
$line           'Ana Dave | 3:0'
$pairing        'Ana Dave'
$result         '3:0'
$p1             'Ana'
$p2             'Dave'
$r1              '3'
$r2              '0'
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@names</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>
</code></pre></div><p>这一句是排序, 先按比赛局数多少排序, 再按赢得的比赛数排序, 然后反转。打印选手名字的时候以胜负次序排序, 代码必须使用选手的分数, 而非他们的名字来进行排序。sort 方法的参数是一个代码块, 用于将数组元素（选手的名字）转换成用于排序的数据。数组的元素通过变量 <code>$_</code> 传递到代码块中。</p>
<p>最简单的使用分数排序选手的方法应该是:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@names</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span> <span class="p">{</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">}</span> <span class="p">)</span>
</code></pre></div><p>这是通过使用赢得比赛的次数来进行排序。然而, Ana 和 Dave都赢了两场比赛。还需要比较谁赢的的比赛局数多, 才能决定比赛的排名。</p>
<p>在双引号括起的字符串中, 标量和花括号中的变量能进行变量插值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$names</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">things</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Do not call me $names</span><span class="p">&#39;;</span> <span class="c1"># Do not call me $names</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Do not call me </span><span class="nv">$names</span><span class="p">&#34;;</span> <span class="c1"># Do not call me things</span>
</code></pre></div><p>花括号中的数组进行插值后会变成用空格分隔的条目。花括号中的散列插值后每个散列键值对单独成为一行, 每行包含一个健, 随后是一个 tab 制表符, 然后是键值, 最后是一个新行符。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Math: </span><span class="p">{</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">}&#34;</span>     <span class="c1"># Math: 3</span>
<span class="k">my</span> <span class="nv">@people</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">Luke Matthew Mark</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The synoptics are: </span><span class="p">{</span><span class="nv">@people</span><span class="p">}&#34;</span> <span class="c1"># The synoptics are: Luke Matthew Mark</span>

<span class="nb">say</span> <span class="p">&#34;{</span><span class="nv">%sets</span><span class="p">}&#34;;</span> <span class="c1"># From the table tennis tournament</span>

<span class="c1"># Charlie 4</span>
<span class="c1"># Dave 6</span>
<span class="c1"># Ana 8</span>
<span class="c1"># Beth 4</span>
</code></pre></div><p>当数组和散列变量直接出现在双引号字符串中(并且不在花括号 <code>{}</code> 里), 它们只在它们的名字后跟着一个 postcircumfix - 一对括号, 后面跟着语句时才会进行插值。在变量名和后置环缀之间进行方法调用也是可以的(例如 <code>@flavours.sort()</code>)</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@flavours</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">vanilla peach</span><span class="p">&gt;;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavours</span><span class="p">&#34;;</span>    <span class="c1"># we have @flavours, 这里没进行插值</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavours</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">&#34;;</span> <span class="c1"># we have vanilla, 后置环缀, 变量名字后面跟着一对儿括号</span>
<span class="c1"># so-called &#34;Zen slice&#34;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavours</span><span class="o">[]</span><span class="p">&#34;;</span>  <span class="c1"># we have vanilla peach</span>

<span class="c1"># 以后置环缀结尾的方法调用</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavours</span><span class="o">.</span><span class="nf">sort</span><span class="p">()&#34;;</span> <span class="c1"># we have peach vanilla</span>

<span class="c1"># 链式方法调用:</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavours</span><span class="o">.</span><span class="nf">sort.join</span><span class="p">(&#39;</span><span class="s1">, </span><span class="p">&#39;)&#34;;</span>
<span class="c1"># we have peach, vanilla</span>
</code></pre></div><h3 id="练习">练习</h3>
<p>例子中的第一行选手的名字是多余的, 你可以在参加比赛的选手中找出所有选手的名字！如果例子中的第一行被省略了, 你如何更改程序？提示：<code>%hash.keys</code> 返回散列 <code>%hash</code> 中的所有键。</p>
<p>答案: 移除此行：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">get</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>
</code></pre></div><p>并且将</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@names</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>
</code></pre></div><p>变成:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">%sets</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>
</code></pre></div><p>除了移除冗余, 你也可以用它来提醒我们, 如果一个选手没有在第一行的名字清单中被提到, 例如因为输入错误, 你该怎样修改你的程序？</p>
<p>答案: 引入另外一个散列, 合法选手的名字作为键, 当读取选手名字的时候查找该散列：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">get</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;);</span>
<span class="k">my</span> <span class="nv">%legitimate-players</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@names</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span> <span class="c1">#  -&gt; 两侧要有空格</span>
    <span class="nv">%legitimate-players</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$pairing</span><span class="o">,</span> <span class="nv">$result</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> | </span><span class="p">&#39;);</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$p1</span><span class="o">,</span> <span class="nv">$p2</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$pairing</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;);</span>
    
    <span class="k">for</span> <span class="nv">$p1</span><span class="o">,</span> <span class="nv">$p2</span> <span class="k">-&gt;</span> <span class="nv">$p</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="nv">%legitimate-players</span><span class="p">{</span><span class="nv">$p</span><span class="p">}</span> <span class="p">{</span>
            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Warning: &#39;</span><span class="nv">$p&#39;</span><span class="s2"> is not on our list!</span><span class="p">&#34;;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><h2 id="第三章-操作符">第三章 操作符</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Ana</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">8</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dave</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">6</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Charlie</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Beth</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$screen-width</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$label-area-width</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="nv">@scores</span><span class="o">».</span><span class="nb">key</span><span class="o">».</span><span class="nb">chars</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$max-score</span> <span class="o">=</span> <span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="nv">@scores</span><span class="o">».</span><span class="nb">value</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$unit</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$screen-width</span> <span class="o">-</span> <span class="nv">$label-area-width</span><span class="p">)</span> <span class="o">/</span> <span class="nv">$max-score</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$format</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">%- </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$label-area-width</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">s</span><span class="nv">%s</span><span class="s2">\n</span><span class="p">&#34;;</span>

<span class="k">for</span> <span class="nv">@scores</span> <span class="p">{</span>
    <span class="nb">printf</span> <span class="nv">$format</span><span class="o">,</span> <span class="o">.</span><span class="nb">key</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">X</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="p">(</span><span class="nv">$unit</span> <span class="o">*</span> <span class="o">.</span><span class="nb">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>在这个例子中, 我们计算一下每位选手在竞标赛中赢得比赛的局数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Ana</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">8</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dave</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">6</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Charlie</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Beth</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>  
</code></pre></div><p>这一句局包含了三个不同的操作符 <code>=</code> 和 <code>=&gt;</code> 和 <code>,</code>。以字符串连接操作符 <code>~</code> 为例, <code>$string ~= &quot;text&quot;</code> 等价于 <code>$string = $string ~ &quot;text&quot;</code>。</p>
<p><code>=&gt;</code> 操作符(大键号)创建了一个键值对对象, 一个键值对存储着键和值；键在 <code>=&gt;</code> 操作符的左侧, 值在右侧。这个操作符有一个特殊的特性：编译器会把 <code>=&gt;</code> 操作符左侧的任何裸标识符解释为一个字符串。你也可以这样写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="s">Ana</span> <span class="o">=&gt;</span> <span class="mi">8</span>, <span class="s">Dave</span> <span class="o">=&gt;</span> <span class="mi">6</span>, <span class="s">Charlie</span> <span class="o">=&gt;</span> <span class="mi">4</span>, <span class="s">Beth</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div><p>最后逗号操作符 <code>,</code> 构建了一个对象序列, 在该情况下, 所谓的对象就是键值对。</p>
<p>这三个操作符都是中缀操作符, 这意味着它在两个条目之间。</p>
<p>一个项前面可以有0个或多个前缀操作符, 所以你可以写比如 <code>4 + -5</code>。<code>+</code> 号（一个中缀操作符）的后面, 编译器期望一个项, 为了将 <code>-</code> 号解释为项 5 的一个前缀。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$label-area-width</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="nv">@scores</span><span class="o">».</span><span class="nb">key</span><span class="o">».</span><span class="nb">chars</span><span class="p">;</span>
</code></pre></div><p><code>»</code> 是一个特殊的符号, 打印不出来可以用两个大于号 <code>&gt;&gt;</code> 代替。中缀操作符 <code>max</code> 返回两个值中的较大者, 所以 <code>2 max 3</code> 返回 3。方括号包裹着一个中缀操作符让 Raku 将该中缀操作符应用到列表中的元素之间。<code>[max] 1,5,3,7</code> 和 <code>1 max 5 max 3 max 7</code> 一样, 结果都为 7。</p>
<p>同样地, <code>[+]</code> 用来计算列表元素的和, <code>[*]</code> 用来计算列表元素的积, <code>[&lt;=]</code> 用来检查一个列表的值是否按递增排序。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">».</span><span class="nb">key</span><span class="o">».</span><span class="nb">chars</span>
<span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="s">Ana</span> <span class="o">=&gt;</span> <span class="mi">8</span>, <span class="s">Dave</span> <span class="o">=&gt;</span> <span class="mi">6</span>, <span class="s">Charlie</span> <span class="o">=&gt;</span> <span class="mi">4</span>, <span class="s">Beth</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">Ana</span>     <span class="mi">8</span> <span class="n">Dave</span>  <span class="mi">6</span> <span class="n">Charlie</span>       <span class="mi">4</span> <span class="n">Beth</span>  <span class="mi">4</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">.</span><span class="nb">key</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Method &#39;key&#39; not found for invocant of class &#39;Array&#39;
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">&gt;&gt;.</span><span class="nb">key</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Ana Dave Charlie Beth
</code></pre></div><p>就像 <code>@variable.method</code> 在 <code>@variable</code> 上调用一个方法一样, <code>@array».method</code> 对 <code>@array</code> 中的每一项调用 <code>method</code> 方法, 并且返回一个返回值的列表。即 <code>@scores&gt;&gt;.key</code> 返回一个列表。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">&gt;&gt;.</span><span class="nb">key</span><span class="o">&gt;&gt;.</span><span class="nb">chars</span>  <span class="c1"># 每个名字含有几个字符</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">4 7 4
</code></pre></div><p>表达式 <code>[max] @scores».key».chars</code> 给出 (3,4,7,4) 中的最大值。它与下面的表达式相同：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">key</span><span class="o">.</span><span class="nb">chars</span>
<span class="nb">max</span> <span class="nv">@scores</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="nb">key</span><span class="o">.</span><span class="nb">chars</span>
<span class="nb">max</span> <span class="nv">@scores</span><span class="o">[</span><span class="mi">2</span><span class="o">].</span><span class="nb">key</span><span class="o">.</span><span class="nb">chars</span>
<span class="nb">max</span> <span class="o">...</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#34;</span><span class="s2">Ana</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="mi">8</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">key</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Ana
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$format</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">%- </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$label-area-width</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">s</span><span class="nv">%s</span><span class="s2">\n</span><span class="p">&#34;;</span>

<span class="k">for</span> <span class="nv">@scores</span> <span class="p">{</span>
    <span class="nb">printf</span> <span class="nv">$format</span><span class="o">,</span> <span class="o">.</span><span class="nb">key</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">X</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="p">(</span><span class="nv">$unit</span> <span class="o">*</span> <span class="o">.</span><span class="nb">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>定义一个格式, <code>%-</code> 表示左对齐, <code>~</code> 是字符串连接操作符 <code>.for</code> 循环中, <code>@scores</code> 中的每一项被绑定给特殊变量 <code>$_</code>, <code>.key</code> 是每项的键, 即名字, <code>.value</code> 是每项的键值, 即得分。小 x 是字符串重复操作符。</p>
<h3 id="关于优先级的的一句话">关于优先级的的一句话</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Ana</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">8</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dave</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">6</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Charlie</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Beth</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div><p>等号右侧产生一个列表（因为逗号, 操作符）, 这个列表由对儿组成(因为 <code>=&gt;</code>), 并且结果赋值给数组变量。
在 Perl5 中会这样解释:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Ana</span><span class="p">&#39;)</span> <span class="o">=&gt;</span> <span class="mi">8</span>, <span class="p">&#39;</span><span class="s1">Dave</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">6</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Charlie</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Beth</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div><p>以至于数组 <code>@scores</code> 中只有一个项, 表达式的其余部分被计算后丢弃。</p>
<p>优先级规则控制着编译器如何解释这一行。Raku 的优先级规则申明 中缀操作符 <code>=&gt;</code> 比 <code>,</code> 中缀操作符对于参数的绑定更紧, 而逗号操作符比等号赋值操作符绑定的更紧。</p>
<p>实际上有两种不同优先级的赋值操作符。当赋值操作符右侧是一个标量时, 使用较紧优先级的项赋值操作符, 否则使用较松优先级的列表赋值操作符。(如同螺丝的松紧)
比较 <code>$a = 1, $b = 2</code> 和 <code>@a = 1, 2,</code> 前者是在一个列表中赋值给两个变量, 后者是将含有两个项的一个列表赋值给一个变量。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">5</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>   <span class="c1"># 5 - 3.5 = 1.5</span>
<span class="nb">say</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1"># (-2) / 2 = -1</span>
</code></pre></div><p>Raku 中的优先级可以用圆括号改变, 但是如果圆括号直接跟在标识符的后面而不加空格的话, 则会被解释为参数列表。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span><span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1"># -2</span>
</code></pre></div><p>只打印出了 <code>5-7</code> 的值。</p>
<p>优先级表</p>
<table>
<thead>
<tr>
<th style="text-align:left">expression</th>
<th style="text-align:left">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">(), 42.5</td>
<td style="text-align:left">(tightest precedence)</td>
</tr>
<tr>
<td style="text-align:left">42.rand</td>
<td style="text-align:left">term</td>
</tr>
<tr>
<td style="text-align:left">$x++</td>
<td style="text-align:left">method calls and postcircumfixes</td>
</tr>
<tr>
<td style="text-align:left">$x**2</td>
<td style="text-align:left">autoincrement and autodecrement</td>
</tr>
<tr>
<td style="text-align:left">?$x, !$x</td>
<td style="text-align:left">exponentiation operator</td>
</tr>
<tr>
<td style="text-align:left">+$x, ~$x</td>
<td style="text-align:left">boolean prefix</td>
</tr>
<tr>
<td style="text-align:left">2*3, 7/5</td>
<td style="text-align:left">prefix context operators</td>
</tr>
<tr>
<td style="text-align:left">1+2, 7-5</td>
<td style="text-align:left">multiplicative infix operators</td>
</tr>
<tr>
<td style="text-align:left">$a x 3</td>
<td style="text-align:left">additive infix operators</td>
</tr>
<tr>
<td style="text-align:left">$x ~&quot;.nn&quot;</td>
<td style="text-align:left">replication operators</td>
</tr>
<tr>
<td style="text-align:left">1&amp;2</td>
<td style="text-align:left">string concatenation</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">abs $x</td>
<td style="text-align:left">junctive OR</td>
</tr>
<tr>
<td style="text-align:left">$x cmp 3</td>
<td style="text-align:left">named unary prefix</td>
</tr>
<tr>
<td style="text-align:left">$x == 3</td>
<td style="text-align:left">non-chaining binary operators</td>
</tr>
<tr>
<td style="text-align:left">$x &amp;&amp; $y</td>
<td style="text-align:left">chaining binary operators</td>
</tr>
<tr>
<td style="text-align:left">$x</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$x &gt; 0 ?? 1 !! -1</td>
<td style="text-align:left">tight OR infix</td>
</tr>
<tr>
<td style="text-align:left">$x = 1</td>
<td style="text-align:left">conditional operator</td>
</tr>
<tr>
<td style="text-align:left">not $x</td>
<td style="text-align:left">item assignment</td>
</tr>
<tr>
<td style="text-align:left">1, 2</td>
<td style="text-align:left">loose unary prefix</td>
</tr>
<tr>
<td style="text-align:left">1, 2 Z @a</td>
<td style="text-align:left">comma</td>
</tr>
<tr>
<td style="text-align:left">@a = 1, 2</td>
<td style="text-align:left">list infix</td>
</tr>
<tr>
<td style="text-align:left">$x and say &ldquo;Yes&rdquo;</td>
<td style="text-align:left">list prefix, list assignment</td>
</tr>
<tr>
<td style="text-align:left">$x or die &ldquo;No&rdquo;</td>
<td style="text-align:left">loose AND infix</td>
</tr>
<tr>
<td style="text-align:left">;</td>
<td style="text-align:left">loose OR infix</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">statement terminator</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">(loosest precedence)</td>
</tr>
</tbody>
</table>
<h3 id="比较和智能匹配">比较和智能匹配</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>

<span class="nb">say</span> <span class="nv">@a</span> <span class="o">===</span> <span class="nv">@a</span><span class="p">;</span> <span class="c1"># Bool::True</span>
<span class="nb">say</span> <span class="nv">@a</span> <span class="o">===</span> <span class="nv">@b</span><span class="p">;</span> <span class="c1"># Bool::False</span>

<span class="c1"># these use identity for value</span>
<span class="nb">say</span> <span class="mi">3</span> <span class="o">===</span> <span class="mi">3</span> <span class="c1"># Bool::True</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">===</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span> <span class="c1"># Bool::True</span>

<span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="nv">$a</span> <span class="o">===</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span> <span class="c1"># Bool::True</span>

<span class="nv">@b</span><span class="o">===</span><span class="nv">@a</span><span class="p">;</span>   <span class="c1"># False</span>
<span class="nv">@a</span> <span class="ow">eqv</span> <span class="nv">@b</span><span class="p">;</span> <span class="c1"># True</span>
<span class="p">&#39;</span><span class="s1">2</span><span class="p">&#39;</span> <span class="ow">eqv</span> <span class="mi">2</span><span class="p">;</span> <span class="c1"># False</span>
</code></pre></div><p>只有当两个对象有相同的类型和相同的结构时, eqv 操作符才返回 True。在前面定义的例子中, @a  eqv  @b 结果为 True, 因为 @a 和 @b 各自包含相同的值, 另一方面, &lsquo;2&rsquo; eqv 2 返回 &lsquo;False&rsquo; ,因为一个参数是字符串, 另一个是整数, 类型不相同。</p>
<h4 id="数字比较">数字比较</h4>
<p>使用 == 中缀操作符查看两个对象是否有相同的数字值。如果某个对象不是数字, Perl 会在比较之前尽力使其数字化。如果没有更好的方式将对象转换为数字, Perl 会使用默认的数字 0 。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">1</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">;</span>  <span class="c1"># Bool::True</span>
<span class="nb">say</span> <span class="mi">1</span> <span class="o">==</span> <span class="p">&#39;</span><span class="s1">1</span><span class="p">&#39;;</span>  <span class="c1"># Bool::True</span>
<span class="nb">say</span> <span class="mi">1</span> <span class="o">==</span> <span class="p">&#39;</span><span class="s1">2</span><span class="p">&#39;;</span>  <span class="c1"># Bool::False</span>
<span class="nb">say</span> <span class="mi">3</span> <span class="o">==</span> <span class="p">&#39;</span><span class="s1">3b</span><span class="p">&#39;;</span> <span class="c1"># fails</span>
</code></pre></div><p>跟数字比较相关的还有 <code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>,<code>&gt;=</code>。如果两个对象的数字值不同, 使用 <code>!=</code> 会返回 True 。</p>
<p>如果你将数组或列表作为数字, 它会计算列表中项的个数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@colors</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">red blue green</span><span class="p">&gt;;</span>

<span class="k">if</span> <span class="nv">@colors</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">It&#39;s true, </span><span class="nv">@colors</span><span class="s2"> contains 3 items</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><h4 id="字符串比较">字符串比较</h4>
<p>Raku 中使用 eq 比较字符串, 必要时会将其参数转换为字符串。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$greeting</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">hello</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">welcome</span><span class="p">&#39;;</span>
<span class="p">}</span>
</code></pre></div><p>Table 3.2: Operators and Comparisons</p>
<table>
<thead>
<tr>
<th style="text-align:left">数字比较</th>
<th style="text-align:left">字符串比较</th>
<th style="text-align:left">意思</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">==</td>
<td style="text-align:left">eq</td>
<td style="text-align:left">等于</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">ne</td>
<td style="text-align:left">不等于</td>
</tr>
<tr>
<td style="text-align:left">!==</td>
<td style="text-align:left">!eq</td>
<td style="text-align:left">不等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">lt</td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">le</td>
<td style="text-align:left">小于或等于</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">gt</td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">ge</td>
<td style="text-align:left">大于或等于</td>
</tr>
</tbody>
</table>
<p>例如, <code>'a' lt 'b'</code> 为 true, <code>'a' lt 'aa'</code> 也为 true。 != 是 <code>!==</code> 的便捷形式, 它实际是 <code>!</code> 元操作符加在 中缀操作符 <code>==</code> 之前。同样地, <code>ne</code> 和 <code>!eq</code>s 是一样的。</p>
<p>三路操作符</p>
<p>三路操作符有两个操作数, 如果左侧较小, 返回 Order::Increase , 两侧相等则返回 Order::Same, 如果右侧较小则返回 Order::Decrease。对于数字使用三路操作符 <code>&lt;=&gt;</code>,对于字符串, 使用三路操作符 <code>leg</code> （取自 lesser, equal, greater）。中缀操作符 cmp 是一个对类型敏感的三路操作符, 它像 <code>&lt;=&gt;</code> 一样比较数字, 像 leg 一样比较字符串, 并且比较键值对儿时, 先比较键, 如果键相同再比较键值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">10</span> <span class="o">&lt;=&gt;</span> <span class="mi">5</span><span class="p">;</span>     <span class="c1"># +1</span>
<span class="nb">say</span> <span class="mi">10</span> <span class="ow">leg</span> <span class="mi">5</span><span class="p">;</span>     <span class="c1"># because &#39;1&#39; lt &#39;5&#39;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">ab</span><span class="p">&#39;</span> <span class="ow">leg</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span> <span class="c1"># +1, lexicographic comparison</span>
</code></pre></div><p>三路操作符的典型用处就是用在排序中。列表中的 <code>.sort</code> 方法能使用一个含有两个值的块或一个函数, 比较它们, 并返回一个小于, 等于或大于 0 的值。 sort 方法根据该返回值进行排序：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">~&lt;</span><span class="n">abstract</span> <span class="n">Concrete</span><span class="o">&gt;.</span><span class="nb">sort</span><span class="p">;</span>
<span class="c1"># output: Concrete abstract</span>

<span class="nb">say</span> <span class="o">~&lt;</span><span class="n">abstract</span> <span class="n">Concrete</span><span class="o">&gt;.</span><span class="nb">sort</span><span class="o">:</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="nb">uc</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="ow">leg</span> <span class="nb">uc</span><span class="p">(</span><span class="nv">$b</span><span class="p">)</span> <span class="p">};</span>
<span class="c1"># output: abstract Concrete</span>
</code></pre></div><p>默认的, 比较是大小写敏感的, 通过比较它们的大写变形, 而不是比较它们的值, 这个例子使用了大小写敏感排序。</p>
<h4 id="智能匹配">智能匹配</h4>
<p>使用 <code>~~</code> 做正确的事情。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$pints-drunk</span> <span class="o">~~</span> <span class="mi">8</span> <span class="p">{</span>
   <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Go home, you&#39;ve had enough!</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nv">$country</span> <span class="o">~~</span> <span class="p">&#39;</span><span class="s1">Sweden</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Meatballs with lingonberries and potato moose, please.</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="k">unless</span> <span class="nv">$group-size</span> <span class="o">~~</span> <span class="mi">2</span><span class="o">..</span><span class="mi">4</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">You must have between 2 and 4 people to book this tour.</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>智能匹配总是根据 <code>~~</code> 右侧值的类型来决定使用哪种比较。上个例子中, 比较的是数字、字符串和范围。
智能匹配的工作方式 <code>$answer ~~ 42</code> 等价于 <code>42.ACCPETS( $answer )</code>。对 <code>~~</code> 操作符右侧的操作数调用 ACCEPTS 方法, 并将左操作数作为参数传入。</p>
<h2 id="第四章-子例程和签名">第四章 子例程和签名</h2>
<p>一个子例程就是一段执行特殊任务的代码片段。它可以对提供的数据(<code>实参</code>)操作, 并产生结果（返回值）。子例程的签名是它<code>所含的参数</code>和它产生的<code>返回值</code>的描述。从某一意义上来说, 第三章描述的操作符也是 Raku 用特殊方式解释的子例程。</p>
<h3 id="申明子例程">申明子例程</h3>
<p>子例程申明由几部分组成。首先, <code>sub</code> 表明你在申明一个子例程, 然后是可选的子例程的名称和可选的签名。子例程的主体是一个用花括号扩起来的代码块。
默认的, 子例程是本地作用域的, 就像任何使用 <code>my</code> 申明的变量一样。这意味着, 一个子例程只能在它被申明的作用域内被调用。使用 <code>our</code> 来申明子例程可以使其在当前包中可见。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">{</span>
    <span class="k">our</span> <span class="k">sub</span> <span class="nf">eat</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">om nom nom</span><span class="p">&#34;;</span>
    <span class="p">}</span>

    <span class="k">sub</span> <span class="nf">drink</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">glug glug</span><span class="p">&#34;;</span>
    <span class="p">}</span>
 <span class="p">}</span>

<span class="k">our</span> <span class="nv">&amp;eat</span><span class="p">;</span> <span class="c1"># makes the package-scoped sub eat available in this lexical scope</span>

<span class="nf">eat</span><span class="p">();</span>   <span class="c1"># om nom nom</span>
<span class="nf">drink</span><span class="p">();</span> <span class="c1"># 失败, can&#39;t drink outside of the block</span>
</code></pre></div><p>our 也能让子例程从包或模块的外部是可见的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">module</span> <span class="nn">EatAndDrink</span> <span class="p">{</span>
    <span class="k">our</span> <span class="k">sub</span> <span class="nf">eat</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">om nom nom</span><span class="p">&#34;;</span>
    <span class="p">}</span>

    <span class="k">sub</span> <span class="nf">drink</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">glug glug</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">EatAndDrink::eat</span><span class="p">();</span> <span class="c1"># om nom nom</span>
<span class="nf">EatAndDrink::drink</span><span class="p">();</span> <span class="c1"># fails, not declared with &#34;our&#34;</span>
</code></pre></div><p>你也可以<code>导出</code>一个子例程, 让它在另外的作用域内可见。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># in file Math/Trivial.pm</span>
<span class="k">module</span> <span class="nn">Math::Trivial</span> <span class="p">{</span>
    <span class="k">sub</span> <span class="nf">double</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nv">$x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>然后在其它程序或模块中你可以这样写:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nn">Math::Trivial</span><span class="p">;</span> <span class="c1"># imports sub double</span>
<span class="nb">say</span> <span class="nf">double</span><span class="p">(</span><span class="mi">21</span><span class="p">);</span>    <span class="c1"># 21 is only half the truth</span>
</code></pre></div><p>Raku 的子例程都是对象。你可以将它们随意传递并存储在数据结构中。编程语言设计者常常将它们称之为 first-class 子例程；它们就像数组和散列一样作为语言的基础。</p>
<p>First-class 子例程能帮助你解决复杂的问题。例如, 为了做出一个微型的ASCII艺术舞蹈图, 你可能要建立一个散列, 键是舞蹈动作的名称, 键值是匿名散列。假使使用者能键入一系列舞蹈动作（可能是站在舞蹈平台上或其它外部输入设备）。 你怎么保持一个变量清单中都是合法的行为, 允许使用者输入, 并限制输入是一系列安全的行为呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%moves</span> <span class="o">=</span>
<span class="s">hands-over-head</span>       <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">/o\ </span><span class="p">&#39;</span>  <span class="p">}</span>,
<span class="s">bird-arms</span>             <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">|/o\| </span><span class="p">&#39;}</span>,
<span class="s">left</span>                  <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">&gt;o </span><span class="p">&#39;</span>   <span class="p">}</span>,
<span class="s">right</span>                 <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">o&lt; </span><span class="p">&#39;</span>   <span class="p">}</span>,
<span class="s">arms-up</span>               <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">\o/ </span><span class="p">&#39;</span>  <span class="p">};</span>

<span class="k">my</span> <span class="nv">@awesome-dance</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">arms-up bird-arms right hands-over-head</span><span class="p">&gt;;</span>

<span class="k">for</span> <span class="nv">@awesome-dance</span> <span class="k">-&gt;</span> <span class="nv">$move</span> <span class="p">{</span>
    <span class="nv">%moves</span><span class="p">{</span><span class="nv">$move</span><span class="p">}</span><span class="o">.</span><span class="p">();</span>  <span class="c1"># 在散列上调用方法</span>
<span class="p">}</span>
</code></pre></div><pre><code>outputs:
 \o/
|/o\|
  o&lt;
 /o\.
</code></pre>
<h3 id="adding-signatures">Adding Signatures</h3>
<p>子例程的签名执行两个任务。首先, 它申明哪个调用者可能或必须将参数传递给子例程。第二, 它申明子例程中的变量被绑定到哪些参数上。这些变量叫做参数。Raku 的签名更深入, 它们允许你限制参数的类型, 值和参数的定义, 并准确匹配复杂数据结构的某一部分。此外, 它们也允许你显式地指定子例程返回值的类型。</p>
<h4 id="基础">基础</h4>
<p>签名最简单的形式是, 绑定到输入参数上的用逗号分隔的一列变量的名字。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-beer</span><span class="p">(</span><span class="nv">$type</span><span class="o">,</span> <span class="nv">$pints</span><span class="p">)</span> <span class="p">{</span>
   <span class="nb">say</span> <span class="p">(</span><span class="nv">$pints</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">A pint</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="nv">$pints</span><span class="s2"> pints</span><span class="p">&#34;)</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> of </span><span class="nv">$type</span><span class="s2">, please.</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="nf">order-beer</span><span class="p">(&#39;</span><span class="s1">Hobgoblin</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>    <span class="c1"># A pint of Hobgoblin, please.</span>
<span class="nf">order-beer</span><span class="p">(&#39;</span><span class="s1">Zlatý Bažant</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1"># 3 pints of Zlatý Bažant, please.</span>
</code></pre></div><p>这里使用的关系绑定而非赋值就是签名。默认地, 在 Raku 中, 子例程中引用到传入参数的签名的变量是只读的。这意味着你不能从子例程内部修改它们。
如果只读绑定太受限制了, 你可以将 <code>is rw</code> (rw 是 read/write 的缩写) 特性应用到参数上以降低这种限制。这个特性说明参数是可读可写的, 这允许你从子例程内部修改参数。使用的时候必须小心, 因为它会修改传入的原始对象。如果你试图传入一个字面值, 一个常量, 或其它类型的不可变对象到一个有 <code>is rw</code> 特性的参数中, 绑定会在调用时失败并抛出异常:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">make-it-more-so</span><span class="p">(</span><span class="nv">$it</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$it</span> <span class="o">~=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$it</span><span class="o">,</span> <span class="nv">$it</span><span class="o">.</span><span class="nb">chars</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="nb">x</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$happy</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">yay!</span><span class="p">&#34;;</span>
<span class="nf">make-it-more-so</span><span class="p">(</span><span class="nv">$happy</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$happy</span><span class="p">;</span> <span class="c1"># yay!!!!!!   # 原始传入对象被修改了</span>
<span class="nf">make-it-more-so</span><span class="p">(&#34;</span><span class="s2">uh-oh</span><span class="p">&#34;);</span> <span class="c1"># 失败, 不能修改一个常量</span>
</code></pre></div><p>如果你想将参数的本地副本用在子例程内部而不改变调用者的变量, 使用 <code>is copy</code> 特性：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">say-it-one-higher</span><span class="p">(</span><span class="nv">$it</span> <span class="k">is</span> <span class="nb">copy</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$it</span><span class="o">++</span><span class="p">;</span>
    <span class="nb">say</span> <span class="nv">$it</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$unanswer</span> <span class="o">=</span> <span class="mi">41</span><span class="p">;</span>
<span class="nf">say-it-one-higher</span><span class="p">(</span><span class="nv">$unanswer</span><span class="p">);</span> <span class="c1"># 42</span>
<span class="nf">say-it-one-higher</span><span class="p">(</span><span class="mi">41</span><span class="p">);</span>        <span class="c1"># 42</span>
<span class="nb">say</span> <span class="nv">$unanswer</span><span class="p">;</span>                <span class="c1"># 41</span>
</code></pre></div><p>在诸如 <code>C/C++</code> 和 Scheme 等其它类型的编程语言中,这种广为人知的求值策略就是按值传递。当使用 <code>is copy</code> 特性时, 只有本地副本被赋值。其它任何传递给子例程的参数在调用者的作用域内保持不变。（一个不可变对象是当这个对象被创建后, 它的状态不会改变, 作为比较, 一个可变对象的状态在创建后是会被改变的）</p>
<h4 id="传递数组散列和代码">传递数组、散列和代码</h4>
<p>一个变量的魔符表明它的本意用途。在签名中, 变量的魔符也起着限制传入的参数类型的作用。例如, <code>@</code> 符号检查传入的对象行使位置角色（一个角色包含像数组和列表的类型）。如果传递的东西不能匹配这样的限制, 会引起调用失败：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">shout-them</span><span class="p">(</span><span class="nv">@words</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nv">@words</span> <span class="k">-&gt;</span> <span class="nv">$w</span> <span class="p">{</span>
        <span class="nb">print</span> <span class="nb">uc</span><span class="p">(&#34;</span><span class="nv">$w</span><span class="s2"> </span><span class="p">&#34;);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@last_words</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">do not want</span><span class="p">&gt;;</span>

<span class="nf">shout-them</span><span class="p">(</span><span class="nv">@last_words</span><span class="p">);</span> <span class="c1"># DO NOT WANT</span>
<span class="nf">shout-them</span><span class="p">(&#39;</span><span class="s1">help</span><span class="p">&#39;);</span>      <span class="c1"># 失败了, 字符串不是位置参数</span>
</code></pre></div><p>类似地, <code>%</code> 符号表明调用者必须传递一个行使关系角色的对象；即允许通过 <code>&lt;...&gt;</code> 或 <code>{...}</code> 进行索引的东西。 <code>&amp;</code> 符号要求调用者传递一个诸如匿名散列之类的行使能调用的角色的对象。在那种情况下, 你也可以不用 <code>&amp;</code> 符号调用可调用的参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">do-it-lots</span><span class="p">(</span><span class="nv">&amp;it</span><span class="o">,</span> <span class="nv">$how-many-times</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="nv">$how-many-times</span> <span class="p">{</span>
        <span class="nf">it</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">do-it-lots</span><span class="p">(</span><span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Eating a stroopwafel</span><span class="p">&#34;</span> <span class="p">}</span><span class="o">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1"># 此处是一个匿名子例程</span>
</code></pre></div><p>标量使用 <code>$</code> 符号, 并表明没有限制。什么都可以绑定在它上面, 即使它使用另外的符号绑定到一个对象上。</p>
<h4 id="插值数组和散列">插值、数组和散列</h4>
<p>有时你想从数组中填充占位参数。你可以通过在数组前添加一个垂直竖条或管道字符 ( <code>|</code> ): <code>eat(|@food)</code>, 而不是写作 <code>eat(@food[0], @food[1], @food[2], ...)</code> 等将它们吸进参数列表( <code>|</code> 像不像一个吸管, ^_^)。</p>
<p>同样地, 你可以将散列插值进具名参数:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-shrimps</span><span class="p">(</span><span class="nv">$count</span><span class="o">,</span> <span class="o">:</span><span class="nv">$from</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I&#39;d like </span><span class="nv">$count</span><span class="s2"> pieces of shrimp from the </span><span class="nv">$from</span><span class="s2">, please</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">%user-preferences</span> <span class="o">=</span> <span class="s">from</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Northern Sea</span><span class="p">&#39;;</span>

<span class="nf">order-shrimps</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="o">|</span><span class="nv">%user-preferences</span><span class="p">);</span>
<span class="c1"># I&#39;d like 3 pieces of shrimp from the Northern Sea, please</span>
</code></pre></div><h4 id="可选参数">可选参数</h4>
<p>为使参数可选, 要么给签名的参数赋值为默认值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-steak</span><span class="p">(</span><span class="nv">$how</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">medium</span><span class="p">&#39;)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I&#39;d like a steak, </span><span class="nv">$how</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">order-steak</span><span class="p">();</span>
<span class="nf">order-steak</span><span class="p">(&#39;</span><span class="s1">well done</span><span class="p">&#39;);</span>
</code></pre></div><p>或者在参数名字的后面添加一个问号(?):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-burger</span><span class="p">(</span><span class="nv">$type</span><span class="o">,</span> <span class="nv">$side</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I&#39;d like a </span><span class="nv">$type</span><span class="s2"> burger</span><span class="p">&#34;</span> <span class="o">~</span>
    <span class="p">(</span> <span class="nb">defined</span><span class="p">(</span><span class="nv">$side</span><span class="p">)</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2"> with a side of </span><span class="nv">$side</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;&#34;</span> <span class="p">);</span>
<span class="p">}</span>

<span class="nf">order-burger</span><span class="p">(&#34;</span><span class="s2">triple bacon</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">deep fried onion rings</span><span class="p">&#34;);</span>
</code></pre></div><p>如果没有参数被传递, 参数会被绑定成一个未定义的值。<code>defined(...)</code> 函数用来检查是否有值。</p>
<h4 id="强制参数">强制参数</h4>
<p>默认地, 位置参数是必不可少的。然而, 你可以通过在参数后面追加一个感叹号来显式地指定该参数是必须的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-drink</span><span class="p">(</span><span class="nv">$size</span><span class="o">,</span> <span class="nv">$flavor</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$size</span><span class="s2"> </span><span class="nv">$flavor</span><span class="s2">, coming right up!</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">order-drink</span><span class="p">(&#39;</span><span class="s1">Large</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Mountain Dew</span><span class="p">&#39;);</span> <span class="c1"># OK</span>
<span class="nf">order-drink</span><span class="p">(&#39;</span><span class="s1">Small</span><span class="p">&#39;);</span>                 <span class="c1"># Error</span>
</code></pre></div><h4 id="具名实参和形参">具名实参和形参</h4>
<ul>
<li>arguments  实参</li>
<li>parameters 形参</li>
</ul>
<p>当一个子例程有很多参数时, 调用者很难记清传递参数的顺序。这种情况下, 通过名字传递参数往往更容易。这样, 参数出现的顺序就无关紧要了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-beer</span><span class="p">(</span><span class="nv">$type</span><span class="o">,</span> <span class="nv">$pints</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">(</span><span class="nv">$pints</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">A pint</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="nv">$pints</span><span class="s2"> pints</span><span class="p">&#34;)</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> of </span><span class="nv">$type</span><span class="s2">, please.</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="nf">order-beer</span><span class="p">(</span><span class="s">type</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Hobgoblin</span><span class="p">&#39;</span>, <span class="s">pints</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1"># A pint of Hobgoblin, please.</span>

<span class="nf">order-beer</span><span class="p">(</span><span class="s">pints</span> <span class="o">=&gt;</span> <span class="mi">3</span>, <span class="s">type</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Zlatý Bažant</span><span class="p">&#39;);</span>
<span class="c1"># 3 pints of Zlatý Bažant, please.</span>
</code></pre></div><p>你也可以指定参数只能按名字被传递（这意味着它不允许按位置传递）。这样的话, 在参数名字前加一个冒号：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-shrimps</span><span class="p">(</span><span class="nv">$count</span><span class="o">,</span> <span class="o">:</span><span class="nv">$from</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Northern Sea</span><span class="p">&#39;)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I&#39;d like </span><span class="nv">$count</span><span class="s2"> pieces of shrimp from the </span><span class="nv">$from</span><span class="s2">, please</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">order-shrimps</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> <span class="c1"># takes &#39;Northern Sea&#39;</span>
<span class="nf">order-shrimps</span><span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="s">from</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Atlantic Ocean</span><span class="p">&#39;);</span>
<span class="nf">order-shrimps</span><span class="p">(</span><span class="mi">22</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Mediterranean Sea</span><span class="p">&#39;);</span>   <span class="c1"># 不允许, :$from is named only</span>
</code></pre></div><p>不像位置参数, 命名参数默认是可选的。在命名参数后面追加一个 <code>!</code> 号使命名参数强制性存在。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">design-ice-cream-mixture</span><span class="p">(</span><span class="nv">$base</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Vanilla</span><span class="p">&#39;</span><span class="o">,</span> <span class="o">:</span><span class="nv">$name</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Creating a new recipe named </span><span class="nv">$name</span><span class="s2">!</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="nf">design-ice-cream-mixture</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Plain</span><span class="p">&#39;);</span>
<span class="nf">design-ice-cream-mixture</span><span class="p">(</span><span class="s">base</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Strawberry chip</span><span class="p">&#39;);</span> <span class="c1"># 错误</span>,<span class="n">没有指定</span> <span class="nv">$name</span>
</code></pre></div><p><strong>重命名参数</strong></p>
<p>因为按名字传递实参给形参是合理的, 形参的名字应该应该作为子例程公共 API 的一部分被考虑在内. 小心地挑选它们吧! 有时候, 使用一个名字暴露形参而使用另外一个名字绑定到变量会很方便:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">announce-time</span><span class="p">(:</span><span class="s">dinner</span><span class="p">(</span><span class="nv">$supper</span><span class="p">)</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">8pm</span><span class="p">&#39;)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">We eat dinner at </span><span class="nv">$supper</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">announce-time</span><span class="p">(</span><span class="s">dinner</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">9pm</span><span class="p">&#39;);</span> <span class="c1"># We eat dinner at 9pm</span>
</code></pre></div><p>参数可以有多个名字, 如果你的用户有些是英国人, 有些是美国人, 你可能这样写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">paint-rectangle</span><span class="p">(</span>
    <span class="o">:</span><span class="nv">$x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">:</span><span class="nv">$y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">:</span><span class="nv">$width</span> <span class="o">=</span> <span class="mi">100</span><span class="o">,</span>
    <span class="o">:</span><span class="nv">$height</span> <span class="o">=</span> <span class="mi">50</span><span class="o">,</span>
    <span class="p">:</span><span class="s">color</span><span class="p">(:</span><span class="s">colour</span><span class="p">(</span><span class="nv">$c</span><span class="p">)))</span> <span class="p">{</span>

    <span class="c1"># print a piece of SVG that represents a rectangle</span>
    <span class="nb">say</span> <span class="k">qq</span><span class="p">[</span><span class="s2">&lt;rect x=&#34;</span><span class="nv">$x</span><span class="s2">&#34; y=&#34;</span><span class="nv">$y</span><span class="s2">&#34; width=&#34;</span><span class="nv">$width</span><span class="s2">&#34; height=&#34;</span><span class="nv">$height</span><span class="s2">&#34; &gt;</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1"># both calls work the same</span>
<span class="n">paint-rectangle</span> <span class="p">:</span><span class="s">color</span><span class="p">&lt;</span><span class="s">Blue</span><span class="p">&gt;;</span>
<span class="n">paint-rectangle</span> <span class="p">:</span><span class="s">colour</span><span class="p">&lt;</span><span class="s">Blue</span><span class="p">&gt;;</span>

<span class="c1"># of course you can still fill the other options</span>
<span class="n">paint-rectangle</span> <span class="p">:</span><span class="s">width</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">height</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">colour</span><span class="p">&lt;</span><span class="s">Blue</span><span class="p">&gt;;</span>
</code></pre></div><p><strong>可选的命名参数语法</strong></p>
<p>命名变量通常是成对的（键值对）。写一个 <code>Pairs</code> 有多种方式。各种方法的不同之处就是清晰性, 因为每种选择提供不同的引述机制。下面的三种调用是一样的意思：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">announce-time</span><span class="p">(</span><span class="s">dinner</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">9pm</span><span class="p">&#39;);</span>
<span class="nf">announce-time</span><span class="p">(:</span><span class="s">dinner</span><span class="p">(&#39;</span><span class="s1">9pm</span><span class="p">&#39;));</span>
<span class="nf">announce-time</span><span class="p">(:</span><span class="s">dinner</span><span class="p">&lt;</span><span class="s">9pm</span><span class="p">&gt;);</span>
</code></pre></div><p>如果传递的是布尔值, 你可以省略键值对的键值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">toggle-blender</span><span class="p">(</span> <span class="p">:</span><span class="s">enabled</span><span class="p">);</span> <span class="c1"># enables the blender 开启果汁机</span>
<span class="nf">toggle-blender</span><span class="p">(:!</span><span class="s">enabled</span><span class="p">);</span> <span class="c1"># disables the blender 关闭果汁机</span>
</code></pre></div><p>形如 <code>:name</code> 但不带值的命名参数有一个隐式的布尔真值 <code>Bool::True</code>。它的对立形式是 <code>:!name</code> , 其值是隐式的布尔假值 <code>Bool::false</code>。如果你使用变量创建了一个 <code>Pair</code>, 你可以将变量名作为 <code>Pair</code> 的键复用.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$dinner</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">9pm</span><span class="p">&#39;;</span>
<span class="n">announce-dinner</span> <span class="o">:</span><span class="nv">$dinner</span><span class="p">;</span> <span class="c1"># same as dinner =&gt; $dinner;</span>
</code></pre></div><pre><code>                        Pair forms and their meanings.

    Shorthand      Long form                          Description
:allowed           allowed =&gt; Bool::True               Boolean flag
:!allowed          allowed =&gt; Bool::False              Boolean flag
:bev&lt;tea coffee&gt;   bev =&gt; ('tea', 'coffee')            List
:times[1, 3]       times =&gt; [1, 3]                     Array
:opts{ a =&gt; 2 }    opts =&gt; { a =&gt; 2 }                  Hash
:$var              var =&gt; $var Scalar                  variable
:@var              var =&gt; @var Array                   variable
:%var              var =&gt; %var Hash                    variable
:&amp;var              vaf =&gt; &amp;var Callable/ Subroutine    variable
</code></pre>
<p>你可以使用在任何可以使用 Pair 对象的上下文使用表中的任意一种形式. 例如, 生成散列:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># TODO: better example</span>
<span class="k">my</span> <span class="nv">$black</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">%color-popularities</span> <span class="o">=</span> <span class="o">:</span><span class="nv">$black</span><span class="o">,</span> <span class="p">:</span><span class="s">blue</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">,</span> <span class="s">red</span> <span class="o">=&gt;</span> <span class="mi">18</span>, <span class="p">:</span><span class="s">white</span><span class="p">&lt;</span><span class="s">0</span><span class="p">&gt;;</span>

<span class="c1"># 与此相同：</span>
<span class="c1"># my %color-popularities =</span>
<span class="c1"># black =&gt; 12,</span>
<span class="c1"># blue =&gt; 8,</span>
<span class="c1"># red =&gt; 18,</span>
<span class="c1"># white =&gt; 0;</span>
</code></pre></div><p>最后, 通过位置而非名字传递一个已存在的 Pair 对象到子例程中, 要么把它放在圆括号中 ( 就像 (<code>:$thing</code>) ), 或者使用 <code>=&gt;</code> 操作符引起左侧的字符串: <code>&quot;thing&quot; =&gt; $thing</code>。</p>
<p><strong>参数的顺序</strong></p>
<p>当位置参数和命名参数都出现在签名中时, 所有的位置参数都要出现在命名参数之前：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">mix</span><span class="p">(</span><span class="nv">@ingredients</span><span class="o">,</span> <span class="o">:</span><span class="nv">$name</span><span class="p">)</span>    <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># OK</span>
<span class="k">sub</span> <span class="nf">notmix</span><span class="p">(</span><span class="o">:</span><span class="nv">$name</span><span class="o">,</span> <span class="nv">@ingredients</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># Error</span>
</code></pre></div><p>必须的位置参数要在可选的位置参数之前。然而, 命名参数没有这种限制。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">copy-machine</span><span class="p">(</span><span class="nv">$amount</span><span class="o">,</span> <span class="nv">$size</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">A4</span><span class="p">&#39;</span><span class="o">,</span> <span class="o">:</span><span class="nv">$color</span><span class="o">!,</span> <span class="o">:</span><span class="nv">$quality</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># OK</span>
<span class="k">sub</span> <span class="nf">fax-machine</span><span class="p">(</span><span class="nv">$amount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="nv">$number</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># Error</span>
</code></pre></div><h4 id="slurpy-参数">Slurpy 参数</h4>
<p>有时候, 你会希望让子例程接受任何数量的参数, 并且将所有这些参数收集到一个数组中。为了达到这个目的, 给签名添加一个数组参数, 就是在数组前添加一个 <code>*</code> 号前缀：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">shout-them</span><span class="p">(</span><span class="o">*</span><span class="nv">@words</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nv">@words</span> <span class="k">-&gt;</span> <span class="nv">$w</span> <span class="p">{</span>
        <span class="nb">print</span> <span class="nb">uc</span><span class="p">(&#34;</span><span class="nv">$w</span><span class="s2"> </span><span class="p">&#34;);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># 现在你可以传递项</span>
<span class="nf">shout-them</span><span class="p">(&#39;</span><span class="s1">go</span><span class="p">&#39;);</span>         <span class="c1"># GO</span>
<span class="nf">shout-them</span><span class="p">(&#39;</span><span class="s1">go</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">home</span><span class="p">&#39;);</span> <span class="c1"># GO HOME</span>
</code></pre></div><p>除了集合所有的值之外, slurpy 参数会展平任何它接收到的数组, 最后你只会得到一个展平的列表, 因此：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@words</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">go</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">home</span><span class="p">&#39;);</span>
<span class="nf">shout-them</span><span class="p">(</span><span class="nv">@words</span><span class="p">);</span>
</code></pre></div><p>会导致 <code>*@words</code> 参数有两个字符串元素, 而非只有单个数组元素。</p>
<p>你可以选择将某些参数捕获到位置参数中, 并让其它参数被吸进数组参数里。这种情况下, <code>slupy</code> 应该放到最后。相似地, <code>*%hash</code> slurps 所有剩下的未绑定的命名参数到散列 <code>%hash</code> 中。<code>Slurpy</code> 数组和散列允许你传递所有的位置参数和命名参数到另一个子例程中。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">
<span class="k">sub</span> <span class="nf">debug-wrapper</span><span class="p">(</span><span class="nv">&amp;code</span><span class="o">,</span> <span class="o">*</span><span class="nv">@positional</span><span class="o">,</span> <span class="o">*</span><span class="nv">%named</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">warn</span> <span class="p">&#34;</span><span class="s2">Calling &#39;</span><span class="nv">&amp;code</span><span class="o">.</span><span class="nf">name</span><span class="p">()</span><span class="s2">&#39; with arguments </span><span class="p">&#34;</span>
    <span class="o">~</span> <span class="p">&#34;</span><span class="nv">@positional</span><span class="o">.</span><span class="nf">perl</span><span class="p">()</span><span class="s2">, </span><span class="nv">%named</span><span class="o">.</span><span class="nf">perl</span><span class="p">()</span><span class="s2">\n</span><span class="p">&#34;;</span>
    <span class="nb">code</span><span class="p">(</span><span class="o">|</span><span class="nv">@positional</span><span class="o">,</span> <span class="o">|</span><span class="nv">%named</span><span class="p">);</span>
    <span class="nb">warn</span> <span class="p">&#34;</span><span class="s2">... back from &#39;</span><span class="nv">&amp;code</span><span class="o">.</span><span class="nf">name</span><span class="p">()</span><span class="s2">&#39;\n</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">debug-wrapper</span><span class="p">(</span><span class="nv">&amp;order-shrimps</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="s">from</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Atlantic Ocean</span><span class="p">&#39;);</span>
</code></pre></div><h3 id="返回值">返回值</h3>
<p>子例程也能返回值。之前本章中的 ASCII 艺术舞蹈例子会更简单当每个子例程返回一个新字符串：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%moves</span> <span class="o">=</span> <span class="s">hands-over-head</span> <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="p">&#39;</span><span class="s1">/o\ </span><span class="p">&#39;</span>   <span class="p">}</span>,
            <span class="s">bird-arms</span>       <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="p">&#39;</span><span class="s1">|/o\| </span><span class="p">&#39;</span> <span class="p">}</span>,
            <span class="s">left</span>            <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="p">&#39;</span><span class="s1">&gt;o </span><span class="p">&#39;</span>    <span class="p">}</span>,
            <span class="s">right</span>           <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="p">&#39;</span><span class="s1">o&lt; </span><span class="p">&#39;</span>    <span class="p">}</span>,
            <span class="s">arms-up</span>         <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="p">&#39;</span><span class="s1">\o/ </span><span class="p">&#39;</span>   <span class="p">};</span>

<span class="k">my</span> <span class="nv">@awesome-dance</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">arms-up bird-arms right hands-over-head</span><span class="p">&gt;;</span>

<span class="k">for</span> <span class="nv">@awesome-dance</span> <span class="k">-&gt;</span> <span class="nv">$move</span> <span class="p">{</span>
    <span class="nb">print</span> <span class="nv">%moves</span><span class="p">{</span><span class="nv">$move</span><span class="p">}</span><span class="o">.</span><span class="p">();</span>
<span class="p">}</span>

<span class="nb">print</span> <span class="p">&#34;</span><span class="s2">\n</span><span class="p">&#34;;</span>
</code></pre></div><p>子例程也能返回多个值（译者注：那不就是返回一个列表嘛）：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">menu</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">rand</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(&#39;</span><span class="s1">fish</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">white wine</span><span class="p">&#39;)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(&#39;</span><span class="s1">steak</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">red wine</span><span class="p">&#39;);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="p">(</span><span class="nv">$food</span><span class="o">,</span> <span class="nv">$beverage</span><span class="p">)</span> <span class="o">=</span> <span class="nf">menu</span><span class="p">();</span>
</code></pre></div><p>如果你把 return 语句排除在外, 则在子例程内部运行的最后一个语句产生的值被返回。这意味着前一个例子可以简化为：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">menu</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">rand</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">fish</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">white wine</span><span class="p">&#39;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">steak</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">red wine</span><span class="p">&#39;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="p">(</span><span class="nv">$food</span><span class="o">,</span> <span class="nv">$beverage</span><span class="p">)</span> <span class="o">=</span> <span class="nf">menu</span><span class="p">();</span>
</code></pre></div><p>记得：当子例程中的控制流极其复杂时, 添加一个显式的 return 会让代码更清晰, 所以 return 还是加上的好。
return 另外的副作用就是执行后立即退出子例程：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">create-world</span><span class="p">(</span><span class="o">*</span><span class="nv">%characteristics</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$world</span> <span class="o">=</span> <span class="n">World</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">%characteristics</span><span class="p">);</span>
    <span class="k">return</span> <span class="nv">$world</span> <span class="k">if</span> <span class="nv">%characteristics</span><span class="p">&lt;</span><span class="s">temporary</span><span class="p">&gt;;</span>

    <span class="nf">save-world</span><span class="p">(</span><span class="nv">$world</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>&hellip;并且你最好别放错你的新单词 <code>$word</code> 如果它是临时的。因为这是你要获取的仅有的一个。</p>
<h3 id="返回值的类型">返回值的类型</h3>
<p>像其它现代语言一样, Raku 允许你显式地指定子例程返回值的类型。这允许你限制从子例程中返回的值的类型。使用 <code>returns</code> 特性可以做到这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">double-up</span><span class="p">(</span><span class="nv">$i</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">$i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nb">Int</span> <span class="nv">$ultimate-answer</span> <span class="o">=</span> <span class="nf">double-up</span><span class="p">(</span><span class="mi">21</span><span class="p">);</span>  <span class="c1"># 42</span>
</code></pre></div><p>当然, 使用这个 <code>returns</code> 特性是可选的</p>
<h3 id="working-with-types">Working With Types</h3>
<p>很多子例程不能完整意义上使用任意参数工作, 但是要求参数支持确定的方法或有其它属性。这种情况下, 限制参数类型就有意义了, 诸如传递不正确值作为参数, 当调用子例程时, 这会引起 Raku 发出错误, 或者甚至在编译时, 如果编译器足够聪明来捕捉错误。</p>
<h4 id="基本类型">基本类型</h4>
<p>最简单的限制子例程接收可能的值的方法是在参数前写上类型名。例如, 一个子例程对其参数执行数值计算, 这要求它的参数类型是 Numeric：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">mean</span><span class="p">(</span><span class="nb">Numeric</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Numeric</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">mean</span> <span class="mf">2.5</span><span class="o">,</span> <span class="mf">1.5</span><span class="p">;</span>
<span class="nb">say</span> <span class="n">mean</span> <span class="p">&#39;</span><span class="s1">some</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">strings</span><span class="p">&#39;;</span>
</code></pre></div><p>产生输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Nominal type check failed for parameter &#39;$a&#39;;
expected Numeric but got Str instead
</code></pre></div><p>nominal 类型是一个人实际类型的名字, 这里是 Numeric。
如果多个参数有类型限制, 每个参数必须填充它绑定的参数限制的类型</p>
<h4 id="添加限制">添加限制</h4>
<p>有时, 类型的名字不足以描述参数的要求。这种情况下, 你可能使用 <code>where</code> 代码块添加一个额外的限制：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">circle-radius-from-area</span><span class="p">(</span><span class="nb">Real</span> <span class="nv">$area</span> <span class="k">where</span> <span class="p">{</span> <span class="nv">$area</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">})</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$area</span> <span class="o">/</span> <span class="no">pi</span><span class="p">)</span><span class="o">.</span><span class="nb">sqrt</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nf">circle-radius-from-area</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>  <span class="c1"># OK</span>
<span class="nb">say</span> <span class="nf">circle-radius-from-area</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="c1"># Error</span>
</code></pre></div><p>因为这种计算只对非负面积值有意义, 该子例程的参数包含了一个限制, 对于非负值它会返回真。如果这个限制返回一个假的值, 类型检查会失败, 当有些东西调用该子例程时。</p>
<p>where 之后的代码块是可选的。Raku 通过通过智能匹配 where 后面的参数来执行检查。
例如, 它可能接受在某一确定范围中的参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">set-volume</span><span class="p">(</span><span class="nb">Numeric</span> <span class="nv">$volume</span> <span class="k">where</span> <span class="mi">0</span><span class="o">..</span><span class="mi">11</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Turning it up to </span><span class="nv">$volume</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>或者你可以将参数限制为散列的键：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%in-stock</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Staropramen</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">8</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Mori</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">La Trappe</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">9</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">order-beer</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$name</span> <span class="k">where</span> <span class="nv">%in-stock</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Here&#39;s your </span><span class="nv">$name</span><span class="p">&#34;;</span>
    <span class="nv">%in-stock</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="nv">%in-stock</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">OH NO! That was the last </span><span class="nv">$name</span><span class="s2">, folks! :&#39;(</span><span class="p">&#34;;</span>
        <span class="nv">%in-stock</span><span class="o">.</span><span class="nb">delete</span><span class="p">(</span><span class="nv">$name</span><span class="p">);</span>
     <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="抽象参数和具体参数">抽象参数和具体参数</h3>
<p>下面检测变量是否定义。在 Raku 中这样写:</p>
<div class="highlight"><pre class="chroma"><code class="language-perl" data-lang="perl"> <span class="k">sub</span> <span class="nf">foo</span><span class="p">(Int:D $arg) {</span>
     <span class="c1"># Do something</span>
 <span class="p">}</span>
</code></pre></div><p>留意附加在参数类型后面的 <code>:D</code> 笑脸。这个动词表明给定的参数必须被绑定到一个具体的对象上。如果不是的话, 会抛出一个运行时异常。这就是为什么它那么高兴！作为对比, 动词 <code>:U</code> 用于表明该参数需要一个未定义的或抽象的对象。此外, 动词 <code>:_</code> 允许定义或未定义的值。实际上, 使用 <code>:_</code> 有点多余。</p>
<p>最后, 动词 <code>:T</code> 能用于表明参数只能是类型对象, 例如</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">say-foobar</span><span class="p">(</span><span class="nb">Int</span><span class="p">:</span><span class="s">T</span> <span class="nv">$arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">FOOBAR!</span><span class="p">&#39;;</span>
<span class="p">}</span>

<span class="nf">say-foobar</span><span class="p">(</span><span class="nb">Int</span><span class="p">);</span>
<span class="c1"># FOOBAR!</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[自定义 when]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-02-28-custom-when/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/?utm_source=atom_feed" rel="related" type="text/html" title="为最年轻的 Raku 贡献力量" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="related" type="text/html" title="如果集合如我所想" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-17-method-isd/?utm_source=atom_feed" rel="related" type="text/html" title="Method-ish" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/?utm_source=atom_feed" rel="related" type="text/html" title="模式分派" />
            
                <id>https://ohmyweekly.github.io/notes/2021-02-28-custom-when/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-28T00:00:00+08:00</published>
            <updated>2021-02-28T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Custom When</blockquote><p>我不太喜欢上一篇文章中使用匹配的语法。它的参数列表中的逗号看起来很奇怪，不合适。也许是因为我的眼睛习惯了给定的块。睡一觉就好了。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">accord</span><span class="p">(</span><span class="nv">&amp;c</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="n">CALLER::</span><span class="p">&lt;</span><span class="s">$_</span><span class="p">&gt;);</span> <span class="k">succeed</span><span class="p">)</span> <span class="k">if</span> <span class="nv">&amp;c</span><span class="o">.</span><span class="nb">cando</span><span class="p">(</span>\<span class="p">(</span><span class="n">CALLER::</span><span class="p">&lt;</span><span class="s">$_</span><span class="p">&gt;))</span> <span class="p">}</span>

<span class="k">given</span> <span class="n">Err</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">msg</span><span class="p">&lt;</span><span class="s">a</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="n">accord</span> <span class="k">-&gt;</span> <span class="n">Hold</span> <span class="p">(</span><span class="o">:</span><span class="nv">$key</span><span class="p">)</span> <span class="p">{</span> <span class="nb">put</span> „<span class="n">holding</span> <span class="nv">$key</span>“<span class="p">;</span> <span class="p">}</span>
    <span class="n">accord</span> <span class="k">-&gt;</span> <span class="n">Err</span> <span class="p">(</span><span class="o">:</span><span class="nv">$msg</span><span class="p">)</span> <span class="p">{</span> <span class="nb">warn</span> „<span class="n">ERR:</span> <span class="nv">$msg</span>“ <span class="p">}</span>
    <span class="k">default</span> <span class="p">{</span> <span class="nb">fail</span> ‚<span class="n">unsupported</span>‘ <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这是因为 <code>accord</code> 模仿了 <code>when</code> 的工作。它做了一些匹配，当 True 时调用一个块，并在每个块的结尾添加一个 success（通过抛出一个控制异常）。given 所做的只是设置主题。它还充当了 caller 的角色，所以我们可以通过一个伪包来访问它的 <code>$_</code>。利用 pointy 的签名来做<a href="https://docs.raku.org/type/Signature#Destructuring_arguments">解构</a>是相当强大的。把这个添加到 CORE 中可能是个好主意。</p>
<p>我们可能要把 Raku 的定义改成: &ldquo;Raku 是一种高度可组合的编程语言&rdquo;, 在这里，所有的东西都会落到实处。&quot;</p>
<p>更新一下。</p>
<p>有些情况下，<code>$_</code> 不是动态的。另外，success 正在抛出一个控制异常，而这些的处理程序是由 when 或默认添加的。这种情况是在编译时发生的，目前不能用宏来解决。第一个问题可以用黑魔法解决。后一个问题需要用默认块。我没有找到一种方法来提供一个合理的错误信息，如果缺少这个块。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">accord</span><span class="p">(</span><span class="nv">&amp;c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nb">nqp</span><span class="p">;</span>
    <span class="nv">$_</span> <span class="o">:=</span> <span class="nf">nqp::getlexcaller</span><span class="p">(&#39;</span><span class="s1">$_</span><span class="p">&#39;);</span>
    <span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="nv">$_</span><span class="p">);</span> <span class="k">succeed</span><span class="p">)</span> <span class="k">if</span> <span class="nv">&amp;c</span><span class="o">.</span><span class="nb">cando</span><span class="p">(</span>\<span class="p">(</span><span class="nv">$_</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nv">@possibilities</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$needle</span> <span class="p">{</span>
    <span class="k">given</span> <span class="nv">$needle</span> <span class="p">{</span>
        <span class="n">accord</span> <span class="k">-&gt;</span> <span class="n">Hold</span> <span class="p">(</span><span class="o">:</span><span class="nv">$key</span><span class="p">)</span> <span class="p">{</span> <span class="nb">put</span> „<span class="n">holding</span> <span class="nv">$key</span>“<span class="p">;</span> <span class="p">}</span>
        <span class="n">accord</span> <span class="k">-&gt;</span> <span class="n">Err</span> <span class="p">(</span><span class="o">:</span><span class="nv">$msg</span><span class="p">)</span> <span class="p">{</span> <span class="nb">warn</span> „<span class="n">ERR:</span> <span class="nv">$msg</span>“ <span class="p">}</span>
        <span class="k">default</span> <span class="p">{</span> <span class="nb">warn</span> ‚<span class="n">unsopported</span>‘ <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>原文链接: <a href="https://gfldex.wordpress.com/2021/02/25/custom-when/">https://gfldex.wordpress.com/2021/02/25/custom-when/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/raku" term="raku" label="Raku" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[为最年轻的 Raku 贡献力量]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="related" type="text/html" title="如果集合如我所想" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-16T00:00:00+08:00</published>
            <updated>2021-02-16T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Contributing to Raku</blockquote><p>在过去的几周里，我看到了一些<a href="https://mydeveloperplanet.com/2021/01/20/how-to-start-contributing-to-open-source/">文章</a>和<a href="https://youtu.be/GAqfMNB-YBU">视频</a>，讲述了在开源软件中构思是多么的伟大。这次我又想起了另一篇旧文<a href="http://strangelyconsistent.org/blog/perl-6-is-my-mmorpg">Raku 是我的 MMORPG</a>。它说，你可以从以下几个方面受益于开源软件。比如说，可以做一个大侠，基于一些开源软件来写软件。作为写手，可以写博客、微博等，对所选软件产生兴趣。或者你可以成为一个法师 - 实现新的功能和修复 bug。今天小编就带着弓箭手来告诉大家如何成为 <a href="https://raku.org/">Raku</a> 编程语言的法师。</p>
<h2 id="选择一个任务">选择一个任务</h2>
<p>让我们挑选一些编译器的 bug，并修复它。让我们去 <a href="https://rakudo.org/">Rakudo</a> 编译器 <a href="https://github.com/rakudo/rakudo/issues">issues</a>中选择我们想要修复的 bug。我滚动了一下 bug 列表，遇到了解析 - 运气不错，我前段时间一直在研究<a href="https://www.apress.com/gp/book/9781484232279">编译器语法</a>，看了一本这方面的好书。找到了四个问题。</p>
<p><img src="https://rakurs.atroxaper.net/assets/img/posts/2021-02-13-contributing-raku-1.png" alt="img"></p>
<ol>
<li>标签为 LTA （Less Than Awesome - 当真实行为与直觉预期不同时）- 我们暂时把它划掉。</li>
<li>标签 &ldquo;需要共识&rdquo; - 我们只想修复一个不复杂的 bug - 肯定要划掉。</li>
<li>标签为 &ldquo;grammar and actions&rdquo; 的关于一个可能死的代码是一个很好的候选人的第一个任务。</li>
</ol>
<p>任务确定后，现在我们需要配置工作环境。在 Windows、Linux 和 macOS 中，一切应该都差不多。我将通过 macOS 的例子来告诉你。</p>
<h2 id="建立工作环境">建立工作环境</h2>
<p>为源码和我们建立的编译器建立文件夹。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">mkdir ~/dev-rakudo <span class="o">&amp;&amp;</span> mkdir ~/dev-rakudo-install
</code></pre></div><p>Rakudo 编译器由三部分组成。</p>
<ol>
<li>虚拟机。现在有三种 - JVM、JS 和 MoarVM。我们以 MoarVM 为最稳定的一个。</li>
<li>NQP（Not Quite Perl），是一种低级（中级）语言的实现，它是 Raku 的一个 &ldquo;子集&rdquo;。虚拟机可以执行用 NQP 编写的代码。</li>
<li>Rakudo 编译器本身，用 NQP 和 Raku 编写。</li>
</ol>
<p>下载并编译这三个组件。我分别花了一分半钟、半分钟和两分半钟才编好。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:MoarVM/MoarVM.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> MoarVM
perl Configure.pl --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install

<span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:Raku/nqp.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> nqp
perl Configure.pl --backend<span class="o">=</span>moar --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install

<span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:rakudo/rakudo.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> rakudo
perl Configure.pl --backend<span class="o">=</span>moar --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install
</code></pre></div><p>注意参数。<code>--prefix</code> 显示了 <code>make install</code> 命令后可执行文件的复制位置，<code>--backend=moar</code> 表示正在使用的虚拟机，而 <code>-j 4</code> 则要求跨多线程并行化（以防加快进度）。现在我们已经建立了 Rakudo 编译器 <code>~/dev-rakudo-install/bin/raku</code>。我们还需要官方的编译器测试套件。你应该把它和它的代码一起放在文件夹里。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">cd</span> ~/dev-rakudo/rakudo <span class="o">&amp;&amp;</span> git clone https://github.com/Raku/roast.git t/spec
</code></pre></div><p>我们先进行测试。这种情况很常见，有些测试甚至在新的变化之前就失败了。我们需要辨别出来，这样以后就不会害怕这些变化破坏了一些不必要的东西。</p>
<p>这里和下面我将在 <code>~/dev-rakudo/rakudo</code> 文件夹中工作，除非另有说明。</p>
<pre><code>&gt; make spectest
[...]
Test Summary Report
-------------------
t/spec/S32-str/utf8-c8.t    (Wstat: 65280 Tests: 54 Failed: 0)
  Non-zero exit status: 255
  Parse errors: Bad plan.  You planned 66 tests but ran 54.
Files=1346, Tests=117144, 829 wallclock secs (27.70 usr  6.04 sys + 2638.79 cusr 210.98 csys = 2883.51 CPU)
Result: FAIL
make: *** [m-spectest5] Error 1
</code></pre><p>14分钟内共运行了1,346个文件中的117,144次测试。一些与utf8相关的测试由于某种原因失败了，其他的都能正常工作。我们已经准备好去工作了!</p>
<h2 id="让我们来看看问题的陈述">让我们来看看问题的陈述</h2>
<p>问题陈述说，某个元运算符 <code>R</code> 在 colonpair 上出了问题。我打开文档，搜索 R 这个词，但下拉列表中没有这个名字的元运算符。我试着输入 metaop，看到的是反向元操作符(R)。原来，如果你想把二元运算的操作数按相反的顺序写出来，你可以在其符号前使用前缀 R。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">3</span> <span class="ow">R</span><span class="o">-</span> <span class="mi">2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># Output: True</span>
</code></pre></div><p>Colonpair 是命名对的语法。它看起来就像名字前面有一个冒号，前面有一个括号，有一个值。例如 <code>:foo(42)</code> 是一个名称为 <code>foo</code>、值为 <code>42</code> 的对儿。这个语法通常用于在调用函数时，向函数传递一个命名参数中的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-with-named-parameter</span><span class="p">(</span><span class="o">:</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-with-named-parameter</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1"># Output: 42</span>
</code></pre></div><p>如果一个函数参数不是命名的，而是位置的，那么在用命名对调用时，就会出现编译错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-without-named-parameter</span><span class="p">(</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># &lt;- 没有冒号</span>
  <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-without-named-parameter</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1"># Unexpected named argument &#39;foo&#39; passed</span>
</code></pre></div><p>如果你在调用这样的函数时用括号包围一个参数，整个参数对将被传递到位置参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-without-named-parameter</span><span class="p">(</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-without-named-parameter</span><span class="p">((:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">)));</span> <span class="c1"># Output: foo =&gt; 42</span>
</code></pre></div><p>在 Raku 中，你可以写一个函数来捕获所有传递给它的参数并分析它们。这是在单个参数 - 捕获前用竖线完成的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-with-capture</span><span class="p">(</span><span class="o">|</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># &lt;- 参数捕获</span>
  <span class="nb">say</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-with-capture</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>     <span class="c1"># Output: \(:foo(42))</span>
<span class="nf">sub-with-capture</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>           <span class="c1"># Output: \(42)</span>
<span class="nf">sub-with-capture</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">3</span> <span class="ow">Z</span><span class="o">-</span> <span class="mi">2</span><span class="p">));</span> <span class="c1"># Output: \(:foo((1,).Seq))</span>
<span class="nf">sub-with-capture</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">3</span> <span class="ow">R</span><span class="o">-</span> <span class="mi">2</span><span class="p">));</span> <span class="c1"># Output: \(-1)</span>
</code></pre></div><p>倒数第二行使用了 Z 元操作符 - zip 操作符。它将左右两部分作为一个列表，按顺序每次从它们中抽取一个元素，并进行操作，从而形成一个序列。</p>
<p>在最后一行，只用了我们需要的 R 元操作符。在这种情况下，它不是一个对，而是一个常量，它被传递到函数中。我们可以假设这是元运算符工作方式的一些特殊性，但用 Z 的例子表明并非如此。其实这是一个 bug - 当一个对被传递到一个使用 R 元运算符的函数中时，它的值会被转换。</p>
<h2 id="我们需要一个新的测试">我们需要一个新的测试</h2>
<p>为了确保未来的变化能够修复错误的行为，我们需要写一个新的测试。在测试文件中不难找到 R 元操作符的测试（<a href="https://github.com/Raku/roast/blob/fea1d16d993eb851d2935155e0b0d074fa3593bf/S03-metaops/reverse.t">S03-metops/reverse.t</a>）。下面我将补充以下测试。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># https://github.com/rakudo/rakudo/issues/1632</span>
<span class="p">{</span>
  <span class="k">sub</span> <span class="nf">subroutine</span><span class="p">(</span><span class="nv">$expected</span><span class="o">,</span> <span class="o">|</span><span class="n">actual</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">is</span> <span class="nc">actual</span><span class="o">.</span><span class="nb">gist</span><span class="o">,</span> <span class="nv">$expected</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Сolonpair exists</span><span class="p">&#34;</span>
  <span class="p">}</span>

  <span class="nf">subroutine</span><span class="p">(&#39;</span><span class="s1">\(:foo(-1))</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">foo</span><span class="p">(</span><span class="mi">3</span> <span class="ow">R</span><span class="o">-</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div><p>该测试有一个功能，有两个参数 - 正常和捕获。在函数体中，第一个参数和传递的 Capture 的字符串表示进行比较。你可以使用 <code>make</code> 对新构建的编译器进行单独测试。</p>
<pre><code>&gt; make t/spec/S03-metaops/reverse.t
[...]
ok 69 - [R~]=
not ok 70 - Colonpair exists
# Failed test 'Colonpair exists'
# at t/spec/S03-metaops/reverse.t line 191
# expected: '\(:foo(-1))'
#      got: '\(-1)'
# You planned 69 tests, but ran 70
# You failed 1 test of 70
</code></pre><p>你可以看到，测试失败了（如预期）。还有一个单独的说明，系统预计69次测试，但收到70次。这是基于 TAP 的测试系统的特点 - 必须在文件的顶部修正传递给 <code>plan</code> 函数的数字。现在测试崩溃了，但编号没有受到影响。你可以开始修复它。</p>
<h2 id="凝视法">凝视法</h2>
<p>一开始我很相信任务上的标签 - 如果是解析的话，一定是源码解析阶段的某个地方出现了问题。目前我的认识如下：</p>
<ol>
<li>基础解析器代码在文件 <code>rakudo/src/Perl6/Grammar.nqp</code> 中。</li>
<li>这个解析器是从 <code>nqp/src/HLL/Grammar.nqp</code> 文件中的基础解析器继承的。</li>
<li>元操作符的解析和工作方式都差不多，你可以通过仔细观察来发现不同之处。</li>
</ol>
<p>我在基础解析器代码中找到了对元操作符的引用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">infix_prefix_meta_operator:sym</span>&lt;R&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">infixish</span><span class="p">(&#39;</span><span class="s1">R</span><span class="p">&#39;)&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">can_meta</span><span class="p">(</span><span class="nv">$&lt;infixish&gt;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">reverse the args of</span><span class="p">&#34;)&gt;</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="nv">O</span><span class="o">=.</span><span class="nf">revO</span><span class="p">(</span><span class="nv">$&lt;infixish&gt;</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>

<span class="k">token</span> <span class="nf">infix_prefix_meta_operator:sym</span>&lt;Z&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">infixish</span><span class="p">(&#39;</span><span class="s1">Z</span><span class="p">&#39;)&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">can_meta</span><span class="p">(</span><span class="nv">$&lt;infixish&gt;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">zip with</span><span class="p">&#34;)&gt;</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="sr">O(|</span><span class="nv">%list_infix</span><span class="sr">)</span><span class="p">&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>这需要对 Raku grammar 有一定的了解。据我所知，原来这两个元运算符在解析上并没有根本的区别。一段时间后，在解析器的源代码中挖得够多了，我开始怀疑解析工作是否正确。认为代码 <code>my $r = :foo(3 R- 2); say $r; # Output: foo =&gt; -1</code> 正确工作的建议 - 问题恰恰发生在调用函数时。显然，我白白相信了任务栏上的标签。</p>
<h2 id="编译器将帮助我们">编译器将帮助我们</h2>
<p>颇为迟钝的我想起了我从一开始就应该做的事情。Rakudo 编译器有 <code>--target</code> 调试开关。它取编译器阶段的名称，你想将其结果输出到控制台并退出。我想看看 <code>--target=parse</code>（因为我只知道这一个）。</p>
<p>我从 <code>~/dev-rakudo/rakudo</code> 文件夹中使用 <code>rakumo-m</code>，这样我就不必等待通过 <code>make install</code> 命令将所需文件复制到 <code>~/dev-rakudo-install</code>。简单的脚本可以这样运行。更复杂的脚本必须在 <code>make install</code> 之后从 <code>-install</code> 中运行。</p>
<pre><code>&gt; cat ~/test.raku
sub s(|c) { say c }
s(:foo(3 R- 2));
s(:foo(3 Z- 2));

&gt; ./rakudo-m --target=parse ~/test.raku
[...]
- args: (:foo(3 R- 2))
  - semiarglist: :foo(3 R- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 R- 2)
        - colonpair: :foo(3 R- 2)
          - identifier: foo
          - coloncircumfix: (3 R- 2)
            - circumfix: (3 R- 2)
              - semilist: 3 R- 2
                - statement: 1 matches
                  - EXPR: R- 2
[...]
- args: (:foo(3 Z- 2))
  - semiarglist: :foo(3 Z- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 Z- 2)
        - colonpair: :foo(3 Z- 2)
          - identifier: foo
          - coloncircumfix: (3 Z- 2)
            - circumfix: (3 Z- 2)
              - semilist: 3 Z- 2
                - statement: 1 matches
                  - EXPR: Z- 2
[...]
</code></pre><p>结论：R 和 Z 的解析是一样的。</p>
<h2 id="这不是解析">这不是解析</h2>
<p>所有被解析的东西都会被传递给所谓的 Action，把字词变成一棵语法树。在我们的例子中，Actions 位于文件 <code>rakudo/src/Perl6/Actions.nqp</code> 和 <code>nqp/src/HLL/Actions.nqp</code> 中。这里就比较容易搞清楚了，毕竟是代码，是 grammar。</p>
<p>我在主 Actions 中找到了以下代码。</p>
<pre><code>[...]
elsif $&lt;infix_prefix_meta_operator&gt; {
[...]
  if    $metasym eq 'R' { $helper := '&amp;METAOP_REVERSE'; $t := nqp::flip($t) if $t; }
  elsif $metasym eq 'X' { $helper := '&amp;METAOP_CROSS'; $t := nqp::uc($t); }
  elsif $metasym eq 'Z' { $helper := '&amp;METAOP_ZIP'; $t := nqp::uc($t); }
  
  my $metapast := QAST::Op.new( :op&lt;call&gt;, :name($helper), WANTED($basepast,'infixish') );
  $metapast.push(QAST::Var.new(:name(baseop_reduce($base&lt;OPER&gt;&lt;O&gt;.made)), :scope&lt;lexical&gt;))
    if $metasym eq 'X' || $metasym eq 'Z';
[...]
</code></pre><p>它说，如果在代码中解析了元操作符 <code>R</code>、<code>Z</code> 或 <code>X</code>，就应该在语法树中添加一些 <code>METAOP_</code> 函数调用。在 <code>Z</code> 和 <code>X</code> 的情况下，它会多一个参数，即某种还原函数。所有这些功能都可以在 <code>rakudo/src/core.c/metaops.pm6</code> 中找到。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">METAOP_REVERSE</span><span class="p">(</span>\<span class="n">op</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
  <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">args</span> <span class="p">{</span> <span class="n">op</span><span class="o">.</span><span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="o">.</span><span class="nb">reverse</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">METAOP_ZIP</span><span class="p">(</span>\<span class="n">op</span><span class="o">,</span> <span class="nv">&amp;reduce</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
 <span class="nf">nqp::if</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="nf">prec</span><span class="p">(&#39;</span><span class="s1">thunky</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">starts-with</span><span class="p">(&#39;</span><span class="s1">.</span><span class="p">&#39;)</span><span class="o">,</span>
  <span class="k">-&gt;</span> <span class="o">+</span><span class="n">lol</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$arity</span> <span class="o">=</span> <span class="n">lol</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
    <span class="o">[...]</span>
  <span class="p">}</span><span class="o">,</span>
  <span class="k">-&gt;</span> <span class="o">+</span><span class="n">lol</span> <span class="p">{</span>
    <span class="nb">Seq</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="n">Rakudo::Iterator</span><span class="o">.</span><span class="nf">ZipIterablesOp</span><span class="p">(</span><span class="n">lol</span><span class="o">,</span><span class="n">op</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>给你：</p>
<ol>
<li><code>\op</code> 是由我们的元操作符，即-，在前面的操作。</li>
<li>Trait <code>implementation-detail</code> 只是表明这不是公共代码，是编译器实现的一部分。</li>
<li>由于-操作没有笨重的特性，所以 <code>&amp;reduce</code> 函数不会参与计算，<code>Z</code> 的结果是 <code>Seq.new(...)</code>。</li>
<li><code>R</code> 的结果是一个操作调用 - 参数顺序相反。</li>
</ol>
<p>这时我想起还有一个 - 目标，即星。它将显示行动的结果。</p>
<pre><code>&gt; ./rakudo-m --target=ast ~/test.raku
[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-
    - QAST::Op(call &amp;METAOP_REVERSE) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;7&gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(:named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;8&gt; :before_promotion&lt;?&gt; Z-
    - QAST::Op(call &amp;METAOP_ZIP) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
      - QAST::Var(lexical &amp;METAOP_REDUCE_LEFT)
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
</code></pre><p>一如所料。除了调用不同的 <code>METAOP_</code> 函数外，所有的东西几乎都是一样的。从它们的代码中我们可以知道，原则上这些函数的不同之处在于返回值的类型 - 分别是 <code>Int</code> 和 <code>Seq</code>。众所周知，Raku 对不同类型的对象的上下文相当敏感&hellip;&hellip;我想，它关注的可能是返回值。我试着用下面的方式修改代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">METAOP_REVERSE</span><span class="p">(</span>\<span class="n">op</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
  <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">args</span> <span class="p">{</span> <span class="nb">Seq</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="o">.</span><span class="nb">reverse</span><span class="p">))</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>编译、运行。</p>
<pre><code>&gt; make
[...]
Stage start      :   0.000
Stage parse      :  61.026
Stage syntaxcheck:   0.000
Stage ast        :   0.000
Stage optimize   :   7.076
Stage mast       :  14.120
Stage mbc        :   3.941
[...]
&gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
</code></pre><p>一切都没有改变。所以，不是返回值&hellip;&hellip;想了想，不知道为什么结果又是 <code>-1</code> 而不是 <code>(-1,).Seq</code>。而且，从代码来看，<code>Seq</code> 根本就没有一个合适的构造函数。下一次，作为一些疯狂的事情，我尝试调用 <code>METAOP_REVERSE</code> 结果只是为了崩溃。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">METAOP_REVERSE</span><span class="p">(</span>\<span class="n">op</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
  <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">args</span> <span class="p">{</span> <span class="nb">die</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>编译、运行。</p>
<pre><code>&gt; make
[...]
&gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
</code></pre><p>怎么会呢？语法树中包含了对 <code>METAOP_REVERSE</code> 的调用，它的代码应该是折叠的，但计算仍然进行，我们得到 <code>-1</code>。</p>
<p>这些都不是《行动》。</p>
<p>这里我的目光落在编译器的构建日志上。它是一些阶段被列在那里。我随机试了 <code>--target=mast</code>。</p>
<pre><code>&gt; ./rakudo-m --target=mast ~/test.raku
[...]
MAST::Frame name&lt;s&gt;, cuuid&lt;1&gt;
  Local types: 0&lt;obj&gt;, 1&lt;obj&gt;, 2&lt;obj&gt;, 3&lt;obj&gt;, 4&lt;int&gt;, 5&lt;str&gt;, 6&lt;obj&gt;, 7&lt;obj&gt;, 8&lt;obj&gt;,
  Lexical types: 0&lt;obj&gt;, 1&lt;obj&gt;, 2&lt;obj&gt;, 3&lt;obj&gt;, 4&lt;obj&gt;,
  Lexical names: 0&lt;c&gt;, 1&lt;$¢&gt;, 2&lt;$!&gt;, 3&lt;$/&gt;, 4&lt;$*DISPATCHER&gt;,
  Lexical map: $!&lt;2&gt;, c&lt;0&gt;, $*DISPATCHER&lt;4&gt;, $¢&lt;1&gt;, $/&lt;3&gt;,
  Outer: name&lt;&lt;unit&gt;&gt;, cuuid&lt;2&gt;
[...]
</code></pre><p>某种不可读的矩阵。星号和桅杆之间有一个阶段性的优化。</p>
<pre><code>&gt; ./rakudo-m --target=optimize ~/test.raku
[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;infix:&lt;-&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;7&gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;8&gt; :before_promotion&lt;?&gt; Z-
    - QAST::Op(callstatic &amp;METAOP_ZIP) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
      - QAST::Var(lexical &amp;METAOP_REDUCE_LEFT)
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
</code></pre><p>哈，就是这样。在优化阶段后，行将失踪。</p>
<ul>
<li><code>QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-.</code>
并将整个 <code>METAOP_REVERSE</code> 调用替换为通常的操作 <code>(&amp;infix:&lt;-&gt;)</code>。所以问题一定在优化器的某个地方。</li>
</ul>
<p>只有在 <code>optim_nameless_call</code> 方法中才会提到 <code>&amp;METAOP_ASSIGN</code>，其中 <code>QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;)</code>。显然，这个操作负责生成一个命名对 - 它已经有了一个名字（命名参数），它需要计算值。从优化 <code>_</code> 无名方法的执行路径来看，我们可以得出结论，我们对最后一个块感兴趣。</p>
<pre><code>[...]
  elsif self.op_eq_core($metaop, '&amp;METAOP_REVERSE') {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;&amp; nqp::elems($op) == 3;
    return QAST::Op.new(:op&lt;call&gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;
  }
[...]
</code></pre><p>让我提醒你，优化前的树是这样的。</p>
<pre><code>[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-
    - QAST::Op(call &amp;METAOP_REVERSE) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
    - QAST::Want &lt;wanted&gt; 3
    - QAST::Want &lt;wanted&gt; 2
[...]
</code></pre><p>而精简之后，是这样的。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;infix:&lt;-&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
    - QAST::Want &lt;wanted&gt; 3
[...]
</code></pre><p>也就是说，优化 <code>_nameless_call</code> 做了以下工作。</p>
<p>如果我们的 <code>QAST::Op+{QAST::SpecialArg}</code> 操作没有三个参数，如果 <code>METAOP_REVERSE</code> 调用没有一个正确的类型，我们就返回空。这不是我们的情况。
否则，我们将返回一个新的操作，代替我们的 <code>QAST::Op+{QAST::SpecialArg}</code> 操作，以相反的顺序调用 <code>&amp;infix:&lt;-&gt;</code> 参数。就是说，把结果打包成一对就没了。</p>
<p>在摸索了一下如何解决这个问题，并阅读了 <code>QAST::SpecialArg</code> 和 <code>QAST::Node</code> 的实现后，我想到了下面的代码。</p>
<pre><code>[...]
  elsif self.op_eq_core($metaop, '&amp;METAOP_REVERSE') {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;&amp; nqp::elems($op) == 3;
    my $opt_result := QAST::Op.new(:op&lt;call&gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;
    if $op.named { $opt_result.named($op.named) } # 添加选项 named 
    if $op.flat { $opt_result.flat($op.flat) }    # 添加选项 flat
    return $opt_result;
  }
[...]
</code></pre><p>还有木头。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call &amp;infix:&lt;-&gt; :named&lt;foo&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
    - QAST::Want &lt;wanted&gt; 3
[...]
</code></pre><p>命名的参数返回到它的位置。测试也开始通过。</p>
<pre><code>&gt; make t/spec/S03-metaops/reverse.t
[...]
All tests successful.
Files=1, Tests=70,  3 wallclock secs ( 0.03 usr  0.01 sys +  3.61 cusr  0.17 csys =  3.82 CPU)
Result: PASS
</code></pre><p>我们本可以就此打住，但这是编译器优化器的代码，它的结果是一个有两个整数参数的方法调用。我认为这在某种程度上是次优的。如果我们将返回表达式改为返回 <code>self.visit_op: $opt_result;</code>，对产生的非优化操作调用优化器，那么产生的树就会像这样。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Want+{QAST::SpecialArg}(:named&lt;foo&gt;)
    - QAST::WVal+{QAST::SpecialArg}(Int :named&lt;foo&gt;)
    - QAST::IVal(-1)
[...]
</code></pre><p>现在一切都很理想。</p>
<h2 id="分享成果">分享成果</h2>
<p>我们已经到了终点线。现在我们只需要分享我们的经验。</p>
<ol>
<li>重要的是：运行所有的 <code>make spectest</code> 测试，确保没有新的东西被破坏。</li>
<li>在 GitHub 上使用 Rakudo 编译器和测试制作 fork 仓库。</li>
<li>将 fork 仓库添加为新的 git 远程仓库。</li>
<li>cd ~/dev-rakudo/rakudo &amp;&amp; git remote add fork <!-- raw HTML omitted -->。</li>
<li>cd ~/dev-rakudo/t/spec &amp;&amp; git remote add fork <!-- raw HTML omitted -->。</li>
</ol>
<p>重要：确保两个仓库在 git 中都有正确的用户名和用户邮箱。</p>
<p>提交到两个版本库，详细说明你为什么做了哪些改动，并添加对原始问题跟踪器的引用。</p>
<p>运行提交。</p>
<pre><code>cd ~/dev-rakudo/rakudo &amp;&amp; git push fork
cd ~/dev-rakudo/t/spec &amp;&amp; git push fork
</code></pre><p>向两个仓库提出拉取请求。在他们的描述中，最好是相互参照和原任务。</p>
<h2 id="结论">结论</h2>
<p>对开源软件的贡献是：</p>
<ol>
<li>趣味性和趣味性。</li>
<li>给你的感觉是，你正在做一些有用的事情，你真的是。</li>
<li>让你认识新的有趣和专业的人（任何关于 Raku 的问题都会在 <code>#raku IRC</code> 频道中得到回答）。</li>
<li>解决非标准任务，没有截止日期的压力，是一种很好的体验。</li>
</ol>
<p>选择你觉得最舒服的角色等级，去做新的任务吧!</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Caesarean Substrings With Raku and Perl]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="related" type="text/html" title="如果集合如我所想" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-07T00:00:00+08:00</published>
            <updated>2021-02-07T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Caesarean Substrings With Raku and Perl</blockquote><p>[113] 发表于2021年1月30日。
这是我对 <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-097/">Perl 每周挑战#097</a> 的回应。</p>
<h2 id="挑战-0971-凯撒密码">挑战 #097.1: 凯撒密码</h2>
<p>给你一个只包含字母 <code>A..Z</code> 的字符串 <code>$S</code> 和一个数字 <code>$N</code>。
写一个脚本，用<a href="https://en.wikipedia.org/wiki/Caesar_cipher">凯撒密码</a>对给定的字符串 <code>$S</code> 进行加密，左移大小为 <code>$N</code>。</p>
<p>例子:
输入: $S = &ldquo;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&rdquo;, $N = 3
输出: &ldquo;QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD&rdquo;</p>
<p>Plain:    ABCDEFGHIJKLMNOPQRSTUVWXYZ
Cipher:   XYZABCDEFGHIJKLMNOPQRSTUVW</p>
<p>Plaintext:  THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG
Ciphertext: QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD</p>
<p>&ldquo;只用字母 <code>A...Z</code>&rdquo; 的表述是错误的，因为例子中也有几个空格。因此，应该允许这些空格。</p>
<p>文件: caesar-cipher</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">subset</span> <span class="nc">AZ-space</span> <span class="k">of</span> <span class="nb">Str</span> <span class="k">where</span> <span class="o">/^</span> <span class="p">&lt;</span><span class="s">[ A .. Z \s ]</span><span class="p">&gt;</span><span class="o">+</span> <span class="nv">$/</span><span class="p">;</span>   <span class="c1"># [1]</span>
<span class="k">subset</span> <span class="nc">PosInt</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">where</span> <span class="o">-</span><span class="mi">25</span> <span class="o">&lt;=</span> <span class="nv">$_</span> <span class="o">&lt;=</span> <span class="mi">25</span><span class="p">;</span>            <span class="c1"># [2]</span>

<span class="k">unit</span> <span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="n">AZ-space</span> <span class="nv">$S</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</span><span class="p">&#39;</span><span class="o">,</span>
               <span class="n">PosInt</span> <span class="nv">$N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">);</span>                         <span class="c1"># [3]</span>

<span class="nb">say</span> <span class="nv">$S</span><span class="o">.</span><span class="nb">comb</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="nf">caesar</span><span class="p">(</span><span class="nv">$_</span><span class="o">,</span> <span class="nv">$N</span><span class="p">)</span> <span class="p">})</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>              <span class="c1"># [4]</span>

<span class="k">sub</span> <span class="nf">caesar</span> <span class="p">(</span><span class="nv">$char</span><span class="o">,</span> <span class="nv">$shift</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nv">$char</span> <span class="k">if</span> <span class="nv">$char</span> <span class="ow">eq</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;;</span>                        <span class="c1"># [5]</span>

  <span class="k">my</span> <span class="nv">$code</span> <span class="o">=</span> <span class="nv">$char</span><span class="o">.</span><span class="nb">ord</span><span class="p">;</span>                                <span class="c1"># [6]</span>

  <span class="nv">$code</span> <span class="o">-=</span> <span class="nv">$shift</span><span class="p">;</span>                                     <span class="c1"># [7]</span>

  <span class="nv">$code</span> <span class="o">+=</span> <span class="mi">26</span> <span class="k">if</span> <span class="nv">$code</span> <span class="o">&lt;</span> <span class="mi">65</span><span class="p">;</span>  <span class="c1"># &#39;A&#39;                    # [8]</span>
  <span class="nv">$code</span> <span class="o">-=</span> <span class="mi">26</span> <span class="k">if</span> <span class="nv">$code</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">;</span>  <span class="c1"># &#39;Z&#39;                    # [8a]</span>

  <span class="k">return</span> <span class="nv">$code</span><span class="o">.</span><span class="nb">chr</span><span class="p">;</span>                                    <span class="c1"># [9]</span>
<span class="p">}</span>
</code></pre></div><p>[1] 所允许的字符 (或 «特定领域字母»).</p>
<p>[2] 挑战说左移值是一个数字。允许除整数以外的任何东西是没有意义的，所以我把值限制在这个类型。负值应该是可以的，它们意味着右移值（而不是左移）。</p>
<p>[3] 参数，默认值为挑战中给出的值。</p>
<p>[4] 将字符串分割成单个字符（用梳子(comb)，在每个字符上应用 &ldquo;caesar&rdquo; 函数（用map），再次将字符连接成一个字符串（用join），然后打印出来。</p>
<p>[5] 不移动空格。</p>
<p>[6] 获取字符的代码点。</p>
<p>[7] 减去移位值（当我们向左移位时，或在字母表中降低移位值）。</p>
<p>[8] 绕回, 如果我们移出A-Z范围，这里为更低 - 或更高的 [8b]。</p>
<p>[9] 获取指定代码点的字符。</p>
<p>查看 docs.raku.org/routine/ord 获取更多关于 ord 的信息。</p>
<p>查看 docs.raku.org/routine/chr 获取更多关于 chr 的信息。</p>
<p>运行它:</p>
<pre><code>$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
</code></pre><p>Raku 有一个 ords 变体，它接收一整个字符串，而不是一个字符作为 ord。还有 chrs，它接收一个代码点数组，并将它们变成一个字符串，而不是像 chr 那样接收一个字符的代码点。让我们用它们来写一个更短的程序。</p>
<p>文件: caesar-cipher-map</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">subset</span> <span class="nc">AZ-space</span> <span class="k">of</span> <span class="nb">Str</span> <span class="k">where</span> <span class="o">/^</span> <span class="p">&lt;</span><span class="s">[ A .. Z \s ]</span><span class="p">&gt;</span><span class="o">+</span> <span class="nv">$/</span><span class="p">;</span>
<span class="k">subset</span> <span class="nc">PosInt</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">where</span> <span class="o">-</span><span class="mi">25</span> <span class="o">&lt;=</span> <span class="nv">$_</span> <span class="o">&lt;=</span> <span class="mi">25</span><span class="p">;</span>

<span class="k">unit</span> <span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="n">AZ-space</span> <span class="nv">$S</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</span><span class="p">&#39;</span><span class="o">,</span>
               <span class="n">PosInt</span> <span class="nv">$N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">);</span>

<span class="nb">say</span> <span class="nf">caesar</span><span class="p">(</span><span class="nv">$S</span><span class="o">,</span> <span class="nv">$N</span><span class="p">);</span>

<span class="k">sub</span> <span class="nf">caesar</span> <span class="p">(</span><span class="nv">$string</span><span class="o">,</span> <span class="nv">$shift</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nv">$string</span><span class="o">.</span><span class="nb">ords</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span><span class="nv">$_</span> <span class="o">==</span> <span class="mi">32</span> <span class="o">??</span> <span class="mi">32</span> <span class="o">!!</span> <span class="p">((</span><span class="nv">$_</span> <span class="o">-</span> <span class="nv">$shift</span> <span class="o">-</span> <span class="mi">65</span><span class="p">)</span> <span class="nv">%</span> <span class="mi">26</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">65</span><span class="p">})</span><span class="o">.</span><span class="nb">chrs</span><span class="p">;</span>
    <span class="c1"># #################### # 1a ############# ############ # 1b  # 1c ## 1d</span>
<span class="p">}</span>
</code></pre></div><p>[1] 我们使用map来改变各个代码点。我们让代码点为32的空间单独存在[1a]。每一个其他的值我们都还原成0到25之间的数字（通过减去第一个字母的代码点（A：65）和移位值[1b]）。模数运算符 (%) 为我们处理负值，做正确的事情。例如：-2 % 26 -&gt; 24 [1c]。然后我们添加调整值到它们应该在的位置(从A到Z)[1d]，然后我们将整个数组的代码点变成一个字符串。</p>
<p>查看 docs.raku.org/routine/ords 获取更多关于 ords 的信息。</p>
<p>查看 docs.raku.org/routine/chrs 获取更多关于 chrs 的信息。</p>
<p>运行它的结果和之前一样。</p>
<pre><code>$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
</code></pre><h2 id="perl-版本">Perl 版本</h2>
<p>这是对第一个 Raku 版的直接翻译。</p>
<p>File: caesar-cipher-perl</p>
<div class="highlight"><pre class="chroma"><code class="language-perl" data-lang="perl"><span class="ch">#! /usr/bin/env perl</span>

<span class="k">use</span> <span class="nn">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">feature</span> <span class="s">&#39;say&#39;</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">feature</span> <span class="s">&#39;signatures&#39;</span><span class="p">;</span>

<span class="k">no</span> <span class="nn">warnings</span> <span class="s">&#34;experimental::signatures&#34;</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$S</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="sr">//</span> <span class="s">&#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39;</span><span class="p">;</span>

<span class="nb">die</span> <span class="s">&#34;Illegal characters&#34;</span> <span class="k">unless</span> <span class="nv">$S</span> <span class="o">=~</span><span class="sr"> /^[A-Z\s]+$/</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$N</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="sr">//</span> <span class="mi">3</span><span class="p">;</span>

<span class="nb">die</span> <span class="s">&#34;Illegal shift $N&#34;</span> <span class="k">if</span> <span class="nv">$N</span> <span class="o">!~</span> <span class="sr">/^\-?\d+$/</span> <span class="o">||</span> <span class="nv">$N</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">25</span> <span class="o">||</span> <span class="nv">$N</span> <span class="o">&gt;</span> <span class="mi">25</span><span class="p">;</span>

<span class="n">say</span> <span class="nb">join</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nb">map</span> <span class="p">{</span> <span class="n">caesar</span><span class="p">(</span><span class="nv">$_</span><span class="p">,</span> <span class="nv">$N</span><span class="p">)</span> <span class="p">}</span> <span class="nb">split</span><span class="p">(</span><span class="sr">//</span><span class="p">,</span> <span class="nv">$S</span><span class="p">));</span>

<span class="k">sub</span> <span class="nf">caesar</span> <span class="p">($char, $shift)
</span><span class="p">{</span>
  <span class="k">return</span> <span class="nv">$char</span> <span class="k">if</span> <span class="nv">$char</span> <span class="ow">eq</span> <span class="s">&#34; &#34;</span><span class="p">;</span>

  <span class="k">my</span> <span class="nv">$code</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="nv">$char</span><span class="p">);</span>

  <span class="nv">$code</span> <span class="o">-=</span> <span class="nv">$shift</span><span class="p">;</span>

  <span class="nv">$code</span> <span class="o">+=</span> <span class="mi">26</span> <span class="k">if</span> <span class="nv">$code</span> <span class="o">&lt;</span> <span class="mi">65</span><span class="p">;</span>  <span class="c1"># &#39;A&#39;</span>
  <span class="nv">$code</span> <span class="o">-=</span> <span class="mi">26</span> <span class="k">if</span> <span class="nv">$code</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">;</span>  <span class="c1"># &#39;Z&#39;</span>

  <span class="k">return</span> <span class="nb">chr</span><span class="p">(</span><span class="nv">$code</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>运行它的结果和 Raku 版一样。</p>
<pre><code>$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
</code></pre><h2 id="挑战-0972二进制子字符串binary-substrings">挑战 #097.2：二进制子字符串(Binary Substrings)</h2>
<p>给你一个二进制字符串 <code>$B</code> 和一个整数 <code>$S</code>。</p>
<p>写一个脚本来拆分大小为 <code>$S</code> 的二进制字符串 <code>$B</code>，然后找出使其相同的最小翻转次数。</p>
<p>例 1:
输入: $B = “101100101”, $S = 3
输出: 1</p>
<p>二进制子字符串:
&ldquo;101&rdquo;: 0 flip
&ldquo;100&rdquo;: 1 flip to make it &ldquo;101&rdquo;
&ldquo;101&rdquo;: 0 flip</p>
<p>例 2:
输入 $B = “10110111”, $S = 4
输出: 2</p>
<p>二进制子字符串:
&ldquo;1011&rdquo;: 0 flip
&ldquo;0111&rdquo;: 2 flips to make it &ldquo;1011&rdquo;</p>
<p>我们先从第一个例子中的二进制子字符串中砍掉3个字符块。</p>
<pre><code>&gt; say &quot;101100101&quot;.comb(3);   # -&gt; (101 100 101)
&gt; say &quot;1011001010&quot;.comb(3);  # -&gt; (101 100 101 0)
</code></pre><p>第二行显示了如果长度不匹配会发生什么。这就给了我们一个非法的值，因为我们不能将一位数翻转为三位数的值。所以我们必须添加一个检查。</p>
<p>然后我们将第一个子串与其余的子串进行比较，一次一个。在这里使用bitwise XOR（Exclusive OR）运算符是一个合理的选择。这给了我们一个二进制值，其中1的数量就是该子串的翻转次数。Raku确实有一个XOR运算符。+^. 但是它 &ldquo;将两个参数都强制为Int，并进行位智XOR操作&rdquo;(根据文档&quot;；参见docs.raku.org/language/operators#infix_+^)。</p>
<p>我们可以在进行XOR操作之前，将二进制值转换为十进制值。让我们试试。</p>
<p>获取翻转的次数。</p>
<pre><code>&gt; say (&quot;10101&quot;.parse-base(2) +^ &quot;10111&quot;.parse-base(2)).base(2).comb.sum;  # -&gt; 1
&gt; say (&quot;11101&quot;.parse-base(2) +^ &quot;10111&quot;.parse-base(2)).base(2).comb.sum;  # -&gt; 2
</code></pre><p>这当然可行，但需要大量的代码。所以我将使用一个更简单的方法 - 逐个比较每个数字。</p>
<p>File: binary-substring</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">subset</span> <span class="nc">BinaryString</span> <span class="k">where</span> <span class="o">/^</span> <span class="p">&lt;</span><span class="s">[01]</span><span class="p">&gt;</span><span class="o">+</span> <span class="nv">$/</span><span class="p">;</span>                    <span class="c1"># [1]</span>
<span class="k">subset</span> <span class="nc">PosInt</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">where</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>                           <span class="c1"># [2]</span>

<span class="k">unit</span> <span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="n">BinaryString</span> <span class="nv">$B</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">101100101</span><span class="p">&#39;</span><span class="o">,</span>               <span class="c1"># [1]</span>
               <span class="n">PosInt</span> <span class="nv">$S</span> <span class="k">where</span> <span class="nv">$B</span><span class="o">.</span><span class="nb">chars</span> <span class="nv">%%</span> <span class="nv">$S</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span>          <span class="c1"># [2]</span>
	       <span class="p">:</span><span class="s">v</span><span class="p">(</span><span class="o">:</span><span class="nv">$verbose</span><span class="p">));</span>

<span class="k">my</span> <span class="nv">@B</span>     <span class="o">=</span> <span class="nv">$B</span><span class="o">.</span><span class="nb">comb</span><span class="p">(</span><span class="nv">$S</span><span class="o">.</span><span class="nb">Int</span><span class="p">);</span>                                <span class="c1"># [3]</span>
<span class="k">my</span> <span class="nv">$first</span> <span class="o">=</span> <span class="nv">@B</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>                                       <span class="c1"># [4]</span>
<span class="k">my</span> <span class="nv">$total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                              <span class="c1"># [5]</span>

<span class="k">for</span> <span class="nv">@B</span> <span class="k">-&gt;</span> <span class="nv">$current</span>                                          <span class="c1"># [6]</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="nv">$flip</span> <span class="o">=</span> <span class="nf">bit-diff</span><span class="p">(</span><span class="nv">$first</span><span class="o">,</span> <span class="nv">$current</span><span class="p">);</span>                    <span class="c1"># [7]</span>
  <span class="nv">$total</span> <span class="o">+=</span> <span class="nv">$flip</span><span class="p">;</span>                                          <span class="c1"># [8]</span>
  <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">: </span><span class="nv">$first</span><span class="s2"> -&gt; </span><span class="nv">$current</span><span class="s2"> -&gt; Flip: </span><span class="nv">$flip</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$verbose</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nv">$total</span><span class="p">;</span>                                                 <span class="c1"># [9]</span>

<span class="k">sub</span> <span class="nf">bit-diff</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span>                                       <span class="c1"># [7]</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="nv">$flip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                             <span class="c1"># [10]</span>

  <span class="k">for</span> <span class="o">^</span><span class="nv">$a</span><span class="o">.</span><span class="nb">chars</span> <span class="k">-&gt;</span> <span class="nv">$index</span>                                   <span class="c1"># [11]</span>
  <span class="p">{</span>
    <span class="nv">$flip</span><span class="o">++</span> <span class="k">if</span> <span class="nv">$a</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="nv">$index</span><span class="o">,</span><span class="mi">1</span><span class="p">)</span> <span class="ow">ne</span> <span class="nv">$b</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="nv">$index</span><span class="o">,</span><span class="mi">1</span><span class="p">);</span>  <span class="c1"># [12]</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nv">$flip</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>[1] 确保二进制字符串是合法的（只包含 &ldquo;0 &ldquo;和 &ldquo;1&rdquo;）。</p>
<p>[2] 确保是一个正整数，同时确保字符串是被它偶数分割的。(例如，&ldquo;4 &ldquo;给我们提供了长度为4的子串，如果最后一个较短，程序将中止。)</p>
<p>[3] 梳子通常用于将一个字符串分割成单个字符，但我们可以通过指定长度来获得每个子字符串中的多个字符，比如这样。</p>
<p>[4] 例子首先将第一个子串与自己进行比较，给出零翻转。这是愚蠢的(ish)，所以我跳过这一点，把第一个子串移出。</p>
<p>[5] 结果会到这里。</p>
<p>[6] 对于每一个子串（除了第一个，见[4]）。</p>
<p>[7] 获取每个子串的翻转次数。</p>
<p>[8] 并将其添加到总数中。</p>
<p>[9] 打印它。</p>
<p>[10] 翻转的数量会在这里。</p>
<p>[11] 对于两个子串中的每个索引（具有相同的长度）。</p>
<p>[12] - 如果给定位置上的字符不同，则在总数的基础上加1，意味着移动。</p>
<p>See docs.raku.org/routine/comb for more information about comb.</p>
<p>运行它。</p>
<pre><code>$ ./binary-substring &quot;101100101&quot; 3
 1

$ ./binary-substring -v &quot;101100101&quot; 3
: 101 -&gt; 100 -&gt; Flip: 1
: 101 -&gt; 101 -&gt; Flip: 0
1

$ ./binary-substring &quot;10110111&quot; 4
2

$ ./binary-substring -v &quot;10110111&quot; 4
: 1011 -&gt; 0111 -&gt; Flip: 2
2
</code></pre><p>看起来不错。</p>
<h2 id="perl">Perl</h2>
<p>这是对 Raku 版本的直接翻译，只是我必须实现 &ldquo;comb&rdquo;。</p>
<p>文件： binary-substring-perl</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env perl</span>

<span class="k">use</span> <span class="nb">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="nb">feature</span> <span class="p">&#39;</span><span class="s1">say</span><span class="p">&#39;;</span>
<span class="k">use</span> <span class="nb">feature</span> <span class="p">&#39;</span><span class="s1">signatures</span><span class="p">&#39;;</span>
<span class="k">use</span> <span class="nn">Getopt::Long</span><span class="p">;</span>

<span class="k">no</span> <span class="nf">warnings</span> <span class="p">&#34;</span><span class="s2">experimental::signatures</span><span class="p">&#34;;</span>

<span class="k">my</span> <span class="nv">$verbose</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nf">GetOptions</span><span class="p">(&#34;</span><span class="s2">verbose</span><span class="p">&#34;</span>  <span class="o">=&gt;</span> \<span class="nv">$verbose</span><span class="p">);</span>

<span class="k">my</span> <span class="nv">$B</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="o">//</span> <span class="p">&#39;</span><span class="s1">101100101</span><span class="p">&#39;;</span>

<span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Not a binary number</span><span class="p">&#34;</span> <span class="k">unless</span> <span class="nv">$B</span> <span class="o">=~</span> <span class="o">/^[</span><span class="mo">01</span><span class="o">]+</span><span class="nv">$/</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$S</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span><span class="p">;</span>

<span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Not an integer</span><span class="p">&#34;</span> <span class="k">unless</span> <span class="nv">$S</span> <span class="o">=~</span> <span class="o">/^[</span><span class="mi">1</span><span class="o">-</span><span class="mi">9</span><span class="o">][</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="o">]*</span><span class="nv">$/</span><span class="p">;</span>
<span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Not a legal length</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nf">length</span><span class="p">(</span><span class="nv">$B</span><span class="p">)</span> <span class="nv">%</span> <span class="nv">$S</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">@B</span>     <span class="o">=</span>  <span class="nb">comb</span><span class="p">(</span><span class="nv">$B</span><span class="o">,</span> <span class="nv">$S</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$first</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@B</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">for</span> <span class="k">my</span> <span class="nv">$current</span> <span class="p">(</span><span class="nv">@B</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="nv">$flip</span> <span class="o">=</span> <span class="nf">bit_diff</span><span class="p">(</span><span class="nv">$first</span><span class="o">,</span> <span class="nv">$current</span><span class="p">);</span>
  <span class="nv">$total</span> <span class="o">+=</span> <span class="nv">$flip</span><span class="p">;</span>
  <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">: </span><span class="nv">$first</span><span class="s2"> -&gt; </span><span class="nv">$current</span><span class="s2"> -&gt; Flip: </span><span class="nv">$flip</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$verbose</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nv">$total</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">bit_diff</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="nv">$flip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="k">my</span> <span class="nv">$index</span> <span class="p">(</span><span class="mi">0</span> <span class="o">..</span> <span class="nf">length</span><span class="p">(</span><span class="nv">$a</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="nv">$flip</span><span class="o">++</span> <span class="k">if</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$index</span><span class="o">,</span><span class="mi">1</span><span class="p">)</span> <span class="ow">ne</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$b</span><span class="o">,</span> <span class="nv">$index</span><span class="o">,</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nv">$flip</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">comb</span> <span class="p">(</span><span class="nv">$string</span><span class="o">,</span> <span class="nv">$length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># [1]</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="nv">@result</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="nv">$string</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="nb">push</span><span class="p">(</span><span class="nv">@result</span><span class="o">,</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">$length</span><span class="p">));</span>
    <span class="nv">$string</span> <span class="o">=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="o">,</span> <span class="nv">$length</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nv">@result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>[1] 缺失的 Raku 例程 &ldquo;comb&rdquo;。可选的第二个参数指定了它所返回的每个子串中所包含的（第一个参数的）子串长度。</p>
<p>运行它的结果与 Raku 版本相同。</p>
<pre><code>$ ./binary-substring-perl &quot;101100101&quot; 3
1

$ ./binary-substring-perl -v &quot;101100101&quot; 3
: 101 -&gt; 100 -&gt; Flip: 1
: 101 -&gt; 101 -&gt; Flip: 0
1

$ ./binary-substring-perl &quot;101100111&quot; 3
2

$ ./binary-substring-perl -v &quot;101100111&quot; 3
: 101 -&gt; 100 -&gt; Flip: 1
: 101 -&gt; 111 -&gt; Flip: 1
2
</code></pre><p>就是这样。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/raku" term="raku" label="Raku" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[如果集合如我所想]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-07T00:00:00+08:00</published>
            <updated>2021-02-07T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>If Sets Would DWIM</blockquote><h1 id="if-sets-would-dwimhttpsdonaldhwtf202101if-sets-would-dwim"><a href="https://donaldh.wtf/2021/01/if-sets-would-dwim/">If Sets Would DWIM</a></h1>
<p>每当我在 Raku 中使用集合的时候，它们经常无法 <a href="https://docs.raku.org/language/glossary#DWIM">DWIM</a>。这是一个简短的探索，看看是否可以改进 DWIMminess。</p>
<p>我最近重新审视了我前段时间写的一个利用 <code>(-)</code> 集差运算符的脚本。这段代码有一个 bug 潜伏在那里，显而易见，因为下面的代码并没有按照我的直觉去做。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">  <span class="k">my</span> <span class="nv">@allowed</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">m c i p l o t</span><span class="p">&gt;;</span>
  <span class="k">my</span> <span class="nv">@chars</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">impolitic</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">comb</span><span class="p">;</span>

  <span class="k">my</span> <span class="nv">@remainder</span> <span class="o">=</span> <span class="nv">@allowed</span> <span class="ow">(-)</span> <span class="nv">@chars</span><span class="p">;</span>

  <span class="k">if</span> <span class="o">+</span><span class="nv">@remainder</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
     <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">pangram</span><span class="p">&#39;;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">unused: [</span><span class="p">{</span><span class="nv">@remainder</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;)}</span><span class="s2">]</span><span class="p">&#34;;</span>
  <span class="p">}</span>
<span class="n">unused:</span> <span class="o">[]</span>
</code></pre></div><p>错误的原因是 <code>(-)</code> 产生了一个 Set，而赋值给 <code>@remainder</code> 会产生1项的 Array。总是这样。但不方便的是，当它是一个空集合时，它就会字符串化为一个空字符串，这只是帮助掩盖了这个潜伏的错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@items</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="nb">d</span> <span class="nb">e</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@items</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">+</span><span class="nv">@items</span><span class="p">;</span>
</code></pre></div><pre><code>[Set.new()]
1
</code></pre><p>解决方法比较简单。只要不赋值给数组就可以了。使用一个标量容器来代替。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$items</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$items</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">+</span><span class="nv">$items</span><span class="p">;</span>
</code></pre></div><pre><code>Set.new(&quot;e&quot;,&quot;c&quot;)
2
</code></pre><p>甚至是关联容器也可以。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%items</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">%items</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">+</span><span class="nv">%items</span><span class="p">;</span>
</code></pre></div><pre><code>{:c(Bool::True), :e(Bool::True)}
2
</code></pre><p>或在赋值前明确地取出键的列表。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@items</span> <span class="o">=</span> <span class="p">(&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span><span class="p">)</span><span class="o">.</span><span class="nb">keys</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@items</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">+</span><span class="nv">@items</span><span class="p">;</span>
</code></pre></div><pre><code>[&quot;e&quot;, &quot;c&quot;]
2
</code></pre><p>很好，起作用了。只是不要用数组容器来处理 <code>Setty</code> 这样的东西。只是这并不能阻止我的直觉时不时地碰上这个错误。同一类的 bug 在我的代码中出现过好几次，因为它实在是太容易犯错了。Raku 不会告诉我，我做错了什么，因为也许是故意的。但重要的是， Raku 没有设法 DWIM。</p>
<p>我可以采取的另一个方法是养成添加类型信息的习惯。这样确实可以让 Raku 在我掉进这个陷阱的时候告诉我。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Str</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div><pre><code>Type check failed in assignment to @a; expected Str but got Set (Set.new(&quot;e&quot;,&quot;c&quot;))
  in sub  at EVAL_0 line 3
  in block &lt;unit&gt; at EVAL_0 line 5
  in block &lt;unit&gt; at -e line 1
</code></pre><p>这是一个明显的例子，添加类型信息有助于 Raku 编译器帮助我避免引入这种 bug。</p>
<h2 id="实验---为-set-自定义数组存储">实验 - 为 Set 自定义数组存储</h2>
<p>我开始研究核心设置(core setting)，看看可以做什么。我惊喜地发现，我可以在 <code>Array.STORE</code> 的多重分派中添加我正在寻找的语义。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nn">MONKEY</span><span class="p">;</span>

<span class="k">augment</span> <span class="k">class</span> <span class="nb">Array</span> <span class="p">{</span>
   <span class="k">multi</span> <span class="k">method</span> <span class="nb">STORE</span><span class="p">(</span><span class="nb">Array</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nb">Set</span> \<span class="nb">item</span> <span class="k">--&gt;</span> <span class="nb">Array:D</span><span class="p">)</span> <span class="p">{</span>
       <span class="nb">self</span><span class="o">.</span><span class="nb">STORE</span><span class="p">(</span><span class="nb">item</span><span class="o">.</span><span class="nb">keys</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">+</span><span class="nv">@a</span><span class="p">;</span>
</code></pre></div><pre><code>[&quot;c&quot;, &quot;e&quot;]
2
</code></pre><p>分享这个似乎是谨慎的，看看我的小 DWIM 是否有任何我没有考虑到的问题或缺点。一个可能的缺点是，如果你需要这样做的话，你需要使用 <code>,</code> 来强制将一个集合变成一个数组。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span> <span class="o">,</span> <span class="p">;</span>
<span class="nb">say</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
</code></pre></div><pre><code>[Set.new(&quot;e&quot;,&quot;c&quot;)]
</code></pre><h2 id="下一步是什么">下一步是什么</h2>
<p>我希望这能引发关于这个问题以及其他我们的直觉和 Raku 的行为不太一致的情况的讨论。也许还有其他相关的语言边缘可以被磨平，以消除这种危害。</p>
<h2 id="后续">后续</h2>
<p>在 <a href="https://t.co/0QSoMxrSXf?amp=1">Reddit</a> 上有一些非常有启发性的讨论，涵盖了语言语义和各种替代方法。公平地说，我建议的方法引入了更多的不一致性，而不是价值，但讨论可能会导致一个语言一致的解决方案。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/flink" term="flink" label="Flink" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
</feed>
