<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.85.0">Hugo</generator><title type="html"><![CDATA[rakulang on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/rakulang/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/rakulang/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/rakulang/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/rakulang/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2021-07-11T22:08:29+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/rakulang/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Guess Who]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-04-an-example-of-raku-subset-and-multi/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 的 subsets 和 multi 辨别年龄" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中怎么为已存在的类添加方法" />
            
                <id>https://ohmyweekly.github.io/notes/2015-11-20-guess-who/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Guess Who</blockquote><p>你是一个刚成立的小公司里的一名软件工程师, 有天晚上你收到了一封来自 CEO 的电子邮件:</p>
<blockquote>
<p>亲爱的工程师,</p>
<p>​    好新闻！看起来我们的网站越来越受欢迎。我们要变的有钱了! 每秒钟有成千上万的人在同时访问我们的网站, 而且还在快速增长。</p>
<p>我们必须立即识别出谁的通信量最大。幸运的是我的朋友给我发送了一份巨大的 IP 地址和名字的列表。很酷不是吗？你能写一段程序接收我们大量的访问者, 把它和地址/名字列表相比, 并创建一些统计吗？我的意思是, 生成一个国家的名字列表。</p>
<p>做好了的话我给你们开个披萨聚会。</p>
</blockquote>
<blockquote>
<p>邮件的附件文件包含了一个 IP 地址和名字的列表。写一个程序来统计下有多少 IP 访问了你的网站。</p>
</blockquote>
<h2 id="输入描述">输入描述</h2>
<p>输入来自两部分。第一个是一个文本文件, 包含 IP 地址范围。每行一项,使用两个空格分割 IP 和名字。</p>
<p>第二个文件是一个 IP 地址的列表, 每行一个, 它们是必须被查询的IP。</p>
<h2 id="ip-输入样本">IP 输入样本</h2>
<p>输入是有包含两个 IP 地址和一个跟 IP 范围关联的名字的大量行组成。</p>
<pre><code>123.45.17.8 123.45.123.45 University of Vestige
123.50.1.1 123.50.10.1 National Center for Pointlessness
188.0.0.3 200.0.0.250 Mayo Tarkington
200.0.0.251 200.0.0.255 Daubs Haywire Committee
200.0.1.1 200.255.255.255 Geopolitical Encyclopedia
222.222.222.222 233.233.233.233 SAP Rostov
250.1.2.3 250.4.5.6 Shavian Refillable Committee
123.45.100.0 123.60.32.1 United Adverbs
190.0.0.1 201.1.1.1 Shavian Refillable Committee
238.0.0.1 254.1.2.3 National Center for Pointlessness
</code></pre><p>注意: 这些 IP 范围不能保证是 IPv4 &ldquo;子网&rdquo;。这意味着它们可能不能精确地由基于前缀的 CIDR 块来表示。</p>
<p>范围可以重叠。可能多余2层深。</p>
<p>可可有多个范围关联同一个名字。</p>
<h2 id="查询输入样本">查询输入样本</h2>
<pre><code>250.1.3.4
123.50.1.20
189.133.73.57
123.50.1.21
250.1.2.4
123.50.1.21
250.1.3.100
250.1.3.5
188.0.0.5
123.50.1.100
123.50.2.34
123.50.1.100
123.51.100.52
127.0.0.1
123.50.1.22
123.50.1.21
188.0.0.5
123.45.101.100
123.45.31.52
230.230.230.230
</code></pre><h2 id="输出格式化">输出格式化</h2>
<p>倒序输出访问次数。</p>
<pre><code>8 - National Center for Pointlessness
4 - Shavian Refillable Committee
3 - Mayo Tarkington
2 - University of Vestige
1 - SAP Rostov
1 - United Adverbs
1 - &lt;unknown&gt;
</code></pre><h2 id="解释">解释</h2>
<p>这儿是一个输入 IP 和它的名字的映射:</p>
<pre><code>National Center for Pointlessness
123.50.1.20
123.50.1.21
123.50.1.22
123.50.1.21
123.50.1.21
123.50.1.100
123.50.1.100
123.50.2.34

Shavian Refillable Committee
250.1.2.4
250.1.3.4
250.1.3.5
250.1.3.100

Mayo Tarkington
188.0.0.5
188.0.0.5
189.133.73.57

University of Vestige
123.45.101.100
123.45.31.52

SAP Rostov
230.230.230.230

United Adverbs
123.51.100.52

&lt;unknown&gt;
127.0.0.1
</code></pre><p>smls 的解决方法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">ip-to-number</span> <span class="p">(</span><span class="nv">$ip</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">do</span> <span class="k">given</span> <span class="nv">$ip</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">.</span><span class="p">&#39;)</span> <span class="p">{</span>
        <span class="o">.[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+&lt;</span> <span class="mi">24</span> <span class="o">+</span>
        <span class="o">.[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+&lt;</span> <span class="mi">16</span> <span class="o">+</span>
        <span class="o">.[</span><span class="mi">2</span><span class="o">]</span> <span class="o">+&lt;</span>  <span class="mi">8</span> <span class="o">+</span>
        <span class="o">.[</span><span class="mi">3</span><span class="o">]</span> <span class="o">+&lt;</span>  <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">IntervalTree</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.min</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.max</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$!center</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$!min</span> <span class="o">+</span> <span class="nv">$!max</span><span class="p">)</span> <span class="ow">div</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@!intervals</span><span class="p">;</span>
    <span class="k">has</span> <span class="n">IntervalTree</span> <span class="nv">$!left</span><span class="p">;</span>
    <span class="k">has</span> <span class="n">IntervalTree</span> <span class="nv">$!right</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">new</span> <span class="p">(</span><span class="nv">$min</span><span class="o">,</span> <span class="nv">$max</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span><span class="o">:</span><span class="nv">$min</span><span class="o">,</span> <span class="o">:</span><span class="nv">$max</span><span class="p">)</span> <span class="p">}</span>

    <span class="k">method</span> <span class="nf">insert</span> <span class="p">(</span><span class="o">|</span><span class="n">c</span> <span class="p">(</span><span class="nv">$start</span><span class="o">,</span> <span class="nv">$end</span><span class="o">,</span> <span class="nv">$name</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$end</span> <span class="o">&lt;</span> <span class="nv">$!center</span> <span class="ow">and</span> <span class="nv">$!min</span> <span class="o">&lt;</span> <span class="nv">$!center</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="p">(</span><span class="nv">$!left</span> <span class="o">//=</span> <span class="nb">self</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$!min</span><span class="o">,</span> <span class="nv">$!center</span><span class="p">))</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">elsif</span> <span class="nv">$start</span> <span class="o">&gt;</span> <span class="nv">$!center</span> <span class="ow">and</span> <span class="nv">$!max</span> <span class="o">&gt;</span> <span class="nv">$!center</span> <span class="p">{</span>
            <span class="p">(</span><span class="nv">$!right</span> <span class="o">//=</span> <span class="nb">self</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$!center</span><span class="o">,</span> <span class="nv">$!max</span><span class="p">))</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nv">@!intervals</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="o">[</span><span class="nv">$start</span><span class="o">,</span> <span class="nv">$end</span><span class="o">,</span> <span class="nv">$name</span><span class="o">,</span> <span class="nv">$end-$start</span><span class="o">]</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">prepare</span> <span class="p">{</span>
        <span class="nv">@!intervals</span><span class="o">.=</span><span class="nb">sort</span><span class="p">(</span><span class="o">*[</span><span class="mi">3</span><span class="o">]</span><span class="p">);</span>
        <span class="nv">$!left</span> <span class="o">.</span><span class="nf">prepare</span> <span class="k">if</span> <span class="nv">$!left</span><span class="p">;</span>
        <span class="nv">$!right</span><span class="o">.</span><span class="nf">prepare</span> <span class="k">if</span> <span class="nv">$!right</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nb">lookup</span> <span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$best</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$n</span> <span class="o">&lt;</span> <span class="nv">$!center</span> <span class="o">??</span> <span class="p">(</span><span class="nv">$!left</span> <span class="o">.</span><span class="nb">lookup</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="k">if</span> <span class="nv">$!left</span><span class="p">)</span>
                                  <span class="o">!!</span> <span class="p">(</span><span class="nv">$!right</span><span class="o">.</span><span class="nb">lookup</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="k">if</span> <span class="nv">$!right</span><span class="p">));</span>
        <span class="nv">$best</span> <span class="o">??</span> <span class="nv">@!intervals</span><span class="o">.</span><span class="nb">first</span><span class="p">({</span> <span class="k">return</span> <span class="nv">$best</span> <span class="k">if</span> <span class="o">.[</span><span class="mi">3</span><span class="o">]</span> <span class="o">&gt;</span> <span class="nv">$best</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">;</span>
                                     <span class="o">.[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="nv">$n</span> <span class="o">&lt;=</span> <span class="o">.[</span><span class="mi">1</span><span class="o">]</span> <span class="p">})</span> <span class="o">//</span> <span class="nv">$best</span>
              <span class="o">!!</span> <span class="nv">@!intervals</span><span class="o">.</span><span class="nb">first</span><span class="p">({</span> <span class="o">.[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="nv">$n</span> <span class="o">&lt;=</span> <span class="o">.[</span><span class="mi">1</span><span class="o">]</span> <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="nv">$ip-file</span><span class="o">,</span> <span class="nv">$query-file</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$index</span> <span class="o">=</span> <span class="n">IntervalTree</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">ip-to-number</span> <span class="p">&#39;</span><span class="s1">255.255.255.255</span><span class="p">&#39;);</span>

    <span class="k">for</span> <span class="nv">$ip-file</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span> <span class="p">{</span>
        <span class="k">my</span> <span class="p">(</span><span class="nv">$start</span><span class="o">,</span> <span class="nv">$end</span><span class="o">,</span> <span class="nv">$name</span><span class="p">)</span> <span class="o">=</span> <span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="nv">$index</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nf">ip-to-number</span><span class="p">(</span><span class="nv">$start</span><span class="p">)</span><span class="o">,</span> <span class="nf">ip-to-number</span><span class="p">(</span><span class="nv">$end</span><span class="p">)</span><span class="o">,</span> <span class="nv">$name</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nv">$index</span><span class="o">.</span><span class="nf">prepare</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="nv">$query-file</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$ip</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$name</span> <span class="o">=</span> <span class="nv">$index</span><span class="o">.</span><span class="nb">lookup</span><span class="p">(</span><span class="n">ip-to-number</span> <span class="nv">$ip</span><span class="p">)</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$ip</span><span class="s2"> </span><span class="p">{</span><span class="nv">$name</span> <span class="o">//</span> <span class="p">&#39;</span><span class="s1">&lt;unknown&gt;</span><span class="p">&#39;}&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[List in Raku]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-04-an-example-of-raku-subset-and-multi/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 的 subsets 和 multi 辨别年龄" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中怎么为已存在的类添加方法" />
            
                <id>https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>List in Raku</blockquote><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">class</span> <span class="nb">List</span> <span class="k">is</span> <span class="nb">Iterable</span> <span class="k">does</span> <span class="nb">Positional</span> <span class="p">{</span> <span class="o">..</span> <span class="p">}</span>
</code></pre></div><p><strong>List</strong> 以序列化的方式存储 items并且潜在是惰性的。</p>
<p>默认列表和数组的索引从 0 开始。</p>
<p>你可以给列表中的元素赋值如果它们是容器的话。使用数组以使列表中的每个元素存储在容器中。</p>
<h2 id="itemsflattening-和-sigils">Items、Flattening 和 Sigils</h2>
<p>在 Raku 中, 把 <strong>List</strong> 赋值给一个标量变量不会丢失信息。不同之处在于迭代通常会把标量中的列表当作单个元素。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">for</span> <span class="nv">@a</span> <span class="p">{</span> <span class="p">}</span>      <span class="c1"># 三次迭代</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="nv">@a</span><span class="p">;</span>
<span class="k">for</span> <span class="nv">$s</span> <span class="p">{</span> <span class="p">}</span>      <span class="c1"># 一次迭代</span>
<span class="k">for</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">item</span> <span class="p">{</span> <span class="p">}</span> <span class="c1"># 一次迭代</span>
<span class="k">for</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">list</span> <span class="p">{</span> <span class="p">}</span> <span class="c1"># 三次迭代</span>
</code></pre></div><p><strong>Lists</strong> 通常会插值(展开)除非它们通过一个 item(scalar)容器访问:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@flat</span>   <span class="o">=</span> <span class="nv">@a</span><span class="o">,</span> <span class="nv">@a</span><span class="p">;</span>           <span class="c1"># two elements</span>
<span class="k">my</span> <span class="nv">@nested</span> <span class="o">=</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">item</span><span class="o">,</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">item</span><span class="p">;</span> <span class="c1"># two elements</span>
</code></pre></div><p><code>.item</code> 通常能被写为 <code>$( ... )</code>, 而在数组变量上甚至写为 <code>$@a</code>。</p>
<h2 id="methods">Methods</h2>
<h3 id="elems">elems</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">elems</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>  <span class="k">returns</span> <span class="nb">Int:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">elems</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>返回列表中元素的个数。</p>
<h3 id="end">end</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">end</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>  <span class="k">returns</span> <span class="nb">Int:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">end</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>返回列表中最后一个元素的索引</p>
<h3 id="keys">keys</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">keys</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>  <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">keys</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回一个索引列表( 例如 <code>0..(@list.elems-1)</code> )</p>
<h3 id="values">values</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">values</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>  <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">values</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回列表的一份拷贝。</p>
<h3 id="kv">kv</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">kv</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>  <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">kv</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回索引和值的交替的列表。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">kv</span>
</code></pre></div><p>返回:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">0</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;</span>
</code></pre></div><h3 id="pairs">pairs</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">pairs</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>   <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">pairs</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回一个 pairs 的列表, 使用索引作为键, 列表值作为键值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">pairs</span>   <span class="c1"># 0 =&gt; &#39;a&#39;, 1 =&gt; &#39;b&#39;, 2 =&gt; &#39;c&#39;</span>
</code></pre></div><h3 id="join">join</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">join</span><span class="p">(</span><span class="nv">$separator</span><span class="o">,</span> <span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">join</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">$separator</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str:D</span>
</code></pre></div><p>把列表中元素当作字符串, 在元素之间插入 <code>$separator</code> 并把所有东西连接成单个字符串。</p>
<p>例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">join</span> <span class="p">&#39;</span><span class="s1">, </span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;;</span>     <span class="c1"># &#39;a, b, c&#39;</span>
</code></pre></div><h3 id="map">map</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">map</span><span class="p">(</span><span class="nv">&amp;code</span><span class="o">,</span> <span class="o">*</span><span class="nv">@elems</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">map</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">&amp;code</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>对每个元素调用 <code>&amp;code</code> 并且把值收集到另外一个列表中并返回它。这个过程是惰性的。<code>&amp;code</code>只在返回值被访问的时候调用。</p>
<p>例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span> <span class="o">.</span><span class="nb">WHAT</span><span class="o">.</span><span class="nb">raku</span> <span class="p">};</span> <span class="c1"># Str Int Rat Int Str</span>
<span class="nb">map</span> <span class="o">*.</span><span class="nb">Str</span><span class="o">.</span><span class="nb">chars</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;;</span>      <span class="c1"># 5 1 8 2 5</span>
</code></pre></div><h3 id="grep">grep</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">grep</span><span class="p">(</span><span class="nb">Mu</span> <span class="nv">$matcher</span><span class="o">,</span> <span class="o">*</span><span class="nv">@elems</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">grep</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span>  <span class="nb">Mu</span> <span class="nv">$matcher</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回一个使用 <code>$matcher</code> 智能匹配的惰性列表。元素是以出现在原列表中的顺序返回的。</p>
<p>例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="nb">Int</span><span class="p">;</span>              <span class="c1"># 1 42</span>
<span class="nb">grep</span> <span class="p">{</span> <span class="o">.</span><span class="nb">Str</span><span class="o">.</span><span class="nb">chars</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="p">}</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;;</span> <span class="c1"># hello 3.142857 world</span>
</code></pre></div><h3 id="first">first</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">first</span><span class="p">(</span><span class="nb">Mu</span> <span class="nv">$matcher</span><span class="o">,</span> <span class="o">*</span><span class="nv">@elems</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">first</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span>  <span class="nb">Mu</span> <span class="nv">$matcher</span><span class="p">)</span>
</code></pre></div><p>返回列表中第一个匹配 <code>$matcher</code> 的元素, 当没有匹配值时, 失败。</p>
<p>例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="nb">first</span><span class="o">:</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">;</span> <span class="c1"># 42</span>
<span class="nb">say</span> <span class="nv">$f</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">first</span><span class="o">:</span> <span class="nb">Complex</span><span class="p">;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;</span><span class="o">,</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="no">i</span><span class="p">)</span><span class="o">.</span><span class="nb">first</span><span class="o">:</span> <span class="nb">Complex</span><span class="p">;</span> <span class="c1"># 1+2i</span>
<span class="nb">say</span> <span class="nv">$f</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span> 
<span class="c1"># Failure.new(exception =&gt; X::AdHoc.new(payload =&gt; &#34;No values matched&#34;))</span>
</code></pre></div><h3 id="classify">classify</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">classify</span><span class="p">(</span><span class="nv">&amp;mapper</span><span class="o">,</span> <span class="o">*</span><span class="nv">@values</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Hash:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">classify</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">&amp;mapper</span><span class="p">)</span>   <span class="k">returns</span> <span class="nb">Hash:D</span>
</code></pre></div><p>根据映射器把一列值转换成代表那些值的类别的散列; 散列的每个键代表着将要归入列表的一个或多个值的类别。比如字符个数,  元素多少, 键值就是根据 mapper 得到的这个类别下的元素,  它来自于原始列表：</p>
<p>例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nb">classify</span> <span class="p">{</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">even</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">odd</span><span class="p">&#39;</span> <span class="p">}</span><span class="o">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="c1"># (&#34;odd&#34; =&gt; [1, 7, 3], &#34;even&#34; =&gt; [6, 2]).hash;</span>

<span class="nb">say</span> <span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">classify</span><span class="o">:</span> <span class="p">{</span> <span class="o">.</span><span class="nb">Str</span><span class="o">.</span><span class="nb">chars</span> <span class="p">};</span>
<span class="c1"># (&#34;5&#34; =&gt; [&#34;hello&#34;, &#34;world&#34;], &#34;1&#34; =&gt; [1], &#34;8&#34; =&gt; [22/7], &#34;2&#34; =&gt; [42]).hash</span>
</code></pre></div><h3 id="bool">Bool</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">Bool</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>如果列表至少含有一个元素则返回 True, 如果列表为空则返回 False。</p>
<h3 id="str">Str</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">Str</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str:D</span>
</code></pre></div><p>字符串化列表中的元素并使用空格把这些元素连接起来。( 和 <code>.join(' ')</code> 一样)。</p>
<h3 id="int">Int</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">Int</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">return</span> <span class="nb">Int:D</span>
</code></pre></div><p>返回列表中元素的数量(和 <code>.elems</code> 一样)</p>
<h3 id="pick">pick</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">pick</span><span class="p">(</span><span class="nv">$count</span><span class="o">,</span> <span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">pick</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">$count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div><p>从调用者身上随机返回 <code>$count</code> 个不重复的元素。 如果 <code>*</code> 作为 <code>$count</code> 传递进来或 <code>$count</code> 大于或等于列表的大小, 那么就以随机序列的方式返回列表中的所有元素。</p>
<p>例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">pick</span><span class="p">;</span>     <span class="c1"># b</span>
<span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">pick</span><span class="o">:</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1"># c a e</span>
<span class="nb">say</span>  <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">pick</span><span class="o">:</span> <span class="o">*</span><span class="p">;</span> <span class="c1"># e d a b c</span>
</code></pre></div><h3 id="roll">roll</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">roll</span><span class="p">(</span><span class="nv">$count</span><span class="o">,</span> <span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">roll</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">$count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div><p>返回一个 <code>$count</code> 个元素的惰性列表, 每个元素都从列表中随机选择。每个随机选择都是独立的.</p>
<p>如果给 <code>$count</code> 传递了 <code>*</code> 号, 则返回一个惰性的, 从原列表中随机选取元素的无限列表。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">roll</span><span class="p">;</span>       <span class="c1"># b</span>
<span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">roll</span><span class="o">:</span> <span class="mi">3</span><span class="p">;</span>    <span class="c1"># c c e</span>
<span class="nb">say</span> <span class="nb">roll</span> <span class="mi">8</span><span class="o">,</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;;</span>    <span class="c1"># b a e d a e b c</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$random_digits</span> <span class="o">:=</span> <span class="p">(</span><span class="o">^</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="o">*</span><span class="p">);</span><span class="mi">1</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$random_digits</span><span class="o">[^</span><span class="mi">15</span><span class="o">]</span><span class="p">;</span>    <span class="c1"># 3 8 7 6 0 1 3 2 0 8 8 5 8 0 5</span>
</code></pre></div><h3 id="eager">eager</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">eager</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>急切地计算列表中的所有元素, 并返回调用者。如果列表标示它是 &ldquo;konw inifinite&rdquo; 的, 急切求值可以停止在探测到的无限的点上。</p>
<h3 id="reverse">reverse</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">reverse</span><span class="p">(</span><span class="o">*</span><span class="nv">@list</span> <span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">reverse</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>以相反的顺序返回一个含有相同元素的列表。
注意 <code>reverse</code> 总是指反转列表中的元素, 如果你想反转字符串中的字符, 那么使用 flip。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">hello world!</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">reverse</span>      <span class="c1">#  world! hello</span>
<span class="nb">say</span> <span class="nb">reverse</span> <span class="o">^</span><span class="mi">10</span>                 <span class="c1"># 9 8 7 6 5 4 3 2 1 0</span>
</code></pre></div><h3 id="rotate">rotate</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">rotate</span><span class="p">(</span><span class="nv">@list</span><span class="o">,</span>  <span class="nb">Int:D</span> <span class="nv">$n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">rotate</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nb">Int:D</span> <span class="nv">$n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>以 <code>$n</code> 个元素旋转列表, 这把原列表分成两部分, 旋转中心就是在这两部分之间:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>   <span class="c1"># &lt;c d e a b&gt;</span>
<span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>  <span class="c1"># &lt;e a b c d&gt;</span>
</code></pre></div><h3 id="sort">sort</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">sort</span><span class="p">(</span><span class="o">*</span><span class="nv">@elems</span><span class="p">)</span>      <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">sub</span>    <span class="nb">sort</span><span class="p">(</span><span class="nv">&amp;by</span><span class="o">,</span> <span class="o">*</span><span class="nv">@elems</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">sort</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span>      <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">sort</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:,</span> <span class="nv">&amp;by</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>列表排序, 最小的元素首先。默认使用 <code>infix:&lt;cmp&gt;</code> 排序列表中的元素。</p>
<p>如果提供了 <code>&amp;by</code>, 那么它接收两个参数, 它由列表元素对儿调用, 并且应该返回 <code>Order::Increase</code>, <code>Order::Same</code> 或 <code>Order::Decrease</code>。</p>
<p>如果 <code>&amp;by</code> 只接受一个参数, 那么列表元素是通过 <code>by($a) cmp by($b)</code> 来排序的。<code>&amp;by</code> 的返回值被缓存起来, 以使每个列表元素只调用一次 <code>&amp;by</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="p">;</span>                  <span class="c1"># -4 -1 0 2 3 7</span>
<span class="nb">say</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="o">*.</span><span class="nb">abs</span><span class="p">;</span>           <span class="c1"># 0 -1 2 3 -4 7</span>
<span class="nb">say</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^b</span> <span class="ow">leg</span> <span class="nv">$^a</span> <span class="p">};</span> <span class="c1"># 7 3 2 0 -4 -1</span>
</code></pre></div><h3 id="reduce">reduce</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">reduce</span><span class="p">(</span><span class="nv">&amp;with</span><span class="o">,</span> <span class="o">*</span><span class="nv">@elems</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">reduce</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">&amp;with</span><span class="p">)</span>
</code></pre></div><p>把 <code>&amp;with</code> 应用到列表中的第一个和第二个值上, 然后把 <code>&amp;with</code> 应用到那个计算的结果值和第三个值上, 以此类推。按照那种方式生成单个项。</p>
<p>注意 <code>reduce</code> 是一个隐式的循环。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">reduce</span><span class="o">:</span> <span class="o">*</span> <span class="o">-</span> <span class="o">*</span><span class="p">;</span> <span class="c1"># -4</span>
</code></pre></div><h3 id="splice">splice</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">splice</span><span class="p">(</span><span class="nv">@list</span><span class="o">,</span>  <span class="nv">$start</span><span class="o">,</span> <span class="nv">$elems</span><span class="o">?,</span> <span class="o">*</span><span class="nv">@replacement</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">splice</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">$start</span><span class="o">,</span> <span class="nv">$elems</span><span class="o">?,</span> <span class="o">*</span><span class="nv">@replacement</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>从列表中删除从 <code>$start</code> 索引开始的 <code>$elems</code> 个元素, 返回删除的元素并用 <code>@replacement</code> 来代替它。如果省略了 <code>$elems</code>, 所有从 <code>$index</code> 开始的元素都被删除。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e f g</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">splice</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="p">&lt;</span><span class="s">M N O P</span><span class="p">&gt;);</span> <span class="c1"># c d e</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="p">;</span>                         <span class="c1"># a b M N O P f g</span>
</code></pre></div><h3 id="pop">pop</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">pop</span><span class="p">(</span><span class="nb">List:D</span> <span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">pop</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span>
</code></pre></div><p>从列表中移除并返回最后一项。如果列表为空则失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b</span><span class="p">&gt;;</span>
<span class="o">&gt;</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">pop</span><span class="p">;</span>  <span class="c1"># b</span>
<span class="o">&gt;</span> <span class="nb">pop</span> <span class="nv">@foo</span>   <span class="c1"># a</span>
<span class="o">&gt;</span> <span class="nb">pop</span> <span class="nv">@foo</span>   <span class="c1"># Element popped from empty list</span>
</code></pre></div><h3 id="push">push</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">push</span><span class="p">(</span><span class="nb">List:D</span><span class="o">,</span> <span class="o">*</span><span class="nv">@values</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">push</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="o">*</span><span class="nv">@values</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>把 <code>@values</code> 添加到列表的末尾, 并返回修改后的列表。 如果列表是无限列表则失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;;</span>
<span class="nv">@foo</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span> <span class="o">...</span> <span class="mi">11</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="p">;</span>                   <span class="c1"># a b c 1 3 5 7 9 11</span>
</code></pre></div><h3 id="shift">shift</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">shift</span><span class="p">(</span><span class="nb">List:D</span> <span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">shift</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span>
</code></pre></div><p>从列表中移除并返回第一项元素。如果列表为空则失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>     <span class="c1"># a</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>     <span class="c1"># b</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>     <span class="c1"># Element shifted from empty list</span>
</code></pre></div><h3 id="unshift">unshift</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">unshift</span><span class="p">(</span><span class="nb">List:D</span><span class="o">,</span> <span class="o">*</span><span class="nv">@values</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">unshift</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="o">*</span><span class="nv">@values</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>添加 <code>@values</code> 到列表的开头, 并返回修改后的列表。如果列表是无限列表则失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;;</span>
<span class="nv">@foo</span><span class="o">.</span><span class="nb">unshift</span><span class="o">:</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span> <span class="o">...</span> <span class="mi">11</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="p">;</span> <span class="c1"># 1 3 5 7 9 11 a b c</span>
</code></pre></div><h5 id="combinations">combinations</h5>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">combinations</span> <span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nb">Int:D</span> <span class="nv">$of</span><span class="p">)</span>          <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">combinations</span> <span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nb">Range:D</span> <span class="nv">$of</span> <span class="o">=</span> <span class="mi">0</span><span class="o">..*</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">sub</span>    <span class="nb">combinations</span> <span class="p">(</span><span class="nv">$n</span><span class="o">,</span> <span class="nv">$k</span><span class="p">)</span>                     <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>Int 变体返回调用者列表所有的 <code>$of-combinations</code> 组合。例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;)</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">combinations</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div><p>打印</p>
<pre><code>a|b
a|c
b|c
</code></pre><p>因为  &lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo; 的所有 2-combinations 是  [&lsquo;a&rsquo;, &lsquo;b&rsquo;], [&lsquo;a&rsquo;, &lsquo;c&rsquo;], [&lsquo;b&rsquo;, &lsquo;c&rsquo;].</p>
<p>Range 变体把所有单独的组合组合到单个列表中, 所以:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;)</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">combinations</span><span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="mi">3</span><span class="p">);</span>
</code></pre></div><p>打印：</p>
<pre><code>a|b
a|c
b|c
a|b|c
</code></pre><p>因为那是一个所有 2-和3-combinations 组合的列表。</p>
<p>子例程 <code>combinations($n, $k)</code> 等价于 <code>(^$n).combinations($k)</code>, 所以：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nb">combinations</span><span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div><p>打印：</p>
<pre><code>0 1
0 2
0 3
1 2
1 3
2 3
</code></pre><h3 id="permutations">permutations</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">permutations</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">sub</span>    <span class="nb">permutations</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span>      <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回列表所有可能的组合作为数组的列表。所以:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;)</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">permutations</span>
</code></pre></div><p>打印：</p>
<pre><code>a|b|c
a|c|b
b|a|c
b|c|a
c|a|b
c|b|a
</code></pre><p><code>permutations</code> 把所有列表元素当作可区别的, 所以 <code>(1, 1, 2).permutations</code> 仍旧返回 6 个元素的列表, 即使只有 3 个不同的排列。</p>
<p><code>permutations($n)</code> 等价于 <code>(^$n).permutations</code>, 所以:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nb">permutations</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div><p>打印：</p>
<pre><code>1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
</code></pre>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 S/// 操作符]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-04-an-example-of-raku-subset-and-multi/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 的 subsets 和 multi 辨别年龄" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中怎么为已存在的类添加方法" />
            
                <id>https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>The S Operator in Raku</blockquote><h1 id="raku-s-操作符httpblogsperlorguserszoffix_znet201604perl-6-the-s-operatorhtml"><a href="http://blogs.perl.org/users/zoffix_znet/2016/04/perl-6-the-s-operator.html">Raku: S/// 操作符</a></h1>
<p>By <a href="http://blogs.perl.org/users/zoffix_znet/">Zoffix Znet</a></p>
<p>来自 Perl 5 背景的我, 第一次使用 Raku 的非破坏性替换操作符 <code>S///</code> 的经历就像下面这样:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-3a07abee4665adaf.gif?imageMogr2/auto-orient/strip" alt="img"></p>
<p>进展会更好的。我不但会改善错误信息, 而且会解释当前的所有事情。</p>
<h2 id="智能匹配">智能匹配</h2>
<p>我有问题的原因是因为, 看到外形相似的操作符, 我就简单地把 Perl 5 中的绑定操作符(<code>=~</code>)转换为 Raku 中的智能匹配操作符(<code>~~</code>) 还期望它能正常工作。事实上我是异想天开。<code>S///</code> 操作符没有文档, 并且结合令人困惑的(那个时候)警告信息, 这就是我痛苦的根源：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$orig</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$new</span>  <span class="o">=</span> <span class="nv">$orig</span> <span class="o">~~</span> <span class="k">S</span><span class="p">/</span><span class="sr">me</span><span class="p">/</span><span class="s2">c</span><span class="p">/;</span>
<span class="nb">say</span> <span class="nv">$new</span><span class="p">;</span>

<span class="c1"># OUTPUT warning:</span>
<span class="c1"># Smartmatch with S/// can never succeed</span>
</code></pre></div><p>这个丑陋的警告说这儿的 <code>~~</code> 操作符是个错误的选择并且确实如此。<code>~~</code> 操作符不是 Perl 5 的 <code>=~</code> 操作符的等价物。<code>~~</code> 智能操作符把它左边的东西起了个叫做 <code>$_</code> 的别名, 然后 <code>~~</code> 计算它右侧的东西, 然后在右侧这个东西身上调用 <code>.ACCEPTS($_)</code> 方法。这就是所有的魔法。</p>
<p>所以上面的例子实际上发生了:</p>
<ul>
<li>我们到达 <code>S///</code> 的时候, <code>$orig</code> 被起了个叫做 <code>$_</code> 的别名。</li>
<li><code>S///</code> 非破坏性地在 <code>$_</code> 身上执行了替换并返回那个结果字符串。这是智能匹配将要操作的东西。</li>
<li>智能匹配, 按照 Str 与 Str 相匹配的规则, 会根据替换是否发生来给出 True 或 False（令人困惑的是, True 意味着没发生）</li>
</ul>
<p>结果一路下来, 我们并没有得到我们想要的：替换过的字符串。</p>
<h2 id="使用-given">使用 Given</h2>
<p>既然我们知道了 <code>S///</code> 总是作用在 <code>$_</code> 上并且返回替换后的结果, 很容易就想到几种方法把 <code>$_</code> 设置为我们原来的字符串并把 <code>S///</code> 的返回值收集回来, 我们来看几个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$orig</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$new</span>  <span class="o">=</span> <span class="k">S</span><span class="p">/</span><span class="sr">me</span><span class="p">/</span><span class="s2">c</span><span class="p">/</span> <span class="k">given</span> <span class="nv">$orig</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$orig</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$new</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">@orig</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">meow cow sow vow</span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">@new</span>  <span class="o">=</span> <span class="nb">do</span> <span class="k">for</span> <span class="nv">@orig</span> <span class="p">{</span> <span class="k">S</span><span class="p">/</span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="ow">before</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">ow</span><span class="p">&#39;&gt;/</span><span class="s2">w</span><span class="p">/</span> <span class="p">};</span>
<span class="nb">say</span> <span class="nv">@orig</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@new</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># meowmix</span>
<span class="c1"># cowmix</span>
<span class="c1"># [meow cow sow vow]</span>
<span class="c1"># [wow wow wow wow]</span>
</code></pre></div><p>第一个作用在单个值上。我们使用后置形式的 <em>given</em> 块儿, 这让我们避免了花括号（你可以使用 <em>with</em> 代替 <em>given</em> 得到同样的结果）。<code>given $orig</code> 会给 <code>$orig</code> 起个叫做 <code>$_</code> 的别名。从输出来看, 原字符串没有被更改。</p>
<p>第二个例子作用在数组中的一堆字符串身上并且我们使用 <em>do</em> 关键字来执行常规的 <em>for</em> 循环(那种情况下, 它把循环变量别名给 <code>$_</code> 了)并把结果赋值给 <code>@new</code> 数组。再次, 输出显示原来的数组并没有发生改变。</p>
<h2 id="副词">副词</h2>
<p><code>S///</code> 操作符 - 就像 <code>s///</code> 操作符和某些方法一样 - 允许你使用正则表达式副词：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">Lörem Ipsum Dolor Sit Amet</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">g</span>      <span class="p">/</span><span class="sr">m</span><span class="p">/</span><span class="s2">g</span><span class="p">/;</span>  <span class="c1"># Löreg Ipsug Dolor Sit Aget</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">i</span>      <span class="p">/</span><span class="sr">l</span><span class="p">/</span><span class="s2">b</span><span class="p">/;</span>  <span class="c1"># börem Ipsum Dolor Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">ii</span>     <span class="p">/</span><span class="sr">l</span><span class="p">/</span><span class="s2">b</span><span class="p">/;</span>  <span class="c1"># Börem Ipsum Dolor Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">mm</span>     <span class="p">/</span><span class="sr">o</span><span class="p">/</span><span class="s2">u</span><span class="p">/;</span>  <span class="c1"># Lürem Ipsum Dolor Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">nth</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">/</span><span class="sr">m </span><span class="p">/</span><span class="s2">g</span><span class="p">/;</span> <span class="c1"># Lörem Ipsug Dolor Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>   <span class="p">/</span><span class="sr">m </span><span class="p">/</span><span class="s2">g</span><span class="p">/;</span> <span class="c1"># Löreg Ipsug Dolor Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">ss</span><span class="p">/</span><span class="sr">Ipsum Dolor</span><span class="p">/</span><span class="s2">Gipsum\nColor</span><span class="p">/;</span> <span class="c1"># Lörem Gipsum Color Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">g</span><span class="p">:</span><span class="na">ii</span><span class="p">:</span><span class="na">nth</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">/</span><span class="sr">m</span><span class="p">/</span><span class="s2">g</span><span class="p">/;</span>             <span class="c1"># Lörem Ipsug Dolor Sit Amet</span>
<span class="p">}</span>
</code></pre></div><p>如你所见, 它们以 <em>:foo</em> 的形式添加在操作符 <strong>S</strong> 这个部件的后面。你可以大大方方地使用空白符号并且几个副词可以同时使用。下面是它们的意义：</p>
<ul>
<li>:g —(长形式：<code>:global</code>)全局匹配：替换掉所有的出现</li>
<li>:i —不区分大小写的匹配</li>
<li>:ii —(长形式： <code>:samecase</code>) 保留大小写：不管用作替换字母的大小写, 使用原来被替换的字母的大小写</li>
<li>:mm —(长形式：<code>:samemark</code>) 保留重音符号：在上面的例子中, 字母 o 上的分音符号被保留并被应用到替换字母 u 上</li>
<li>:nth(n) —只替换第 n 次出现的</li>
<li>:x(n) —至多替换 n 次（助记符: &lsquo;x&rsquo; 作为及时）</li>
<li>:ss —(长形式：<code>samespace</code>)保留空白类型：空白字符的类型被保留, 而不管替换字符串中使用的是什么空白字符。在上面的例子中, 我们使用换行作为替换, 但是原来的空白被保留了。</li>
</ul>
<h2 id="方法形式">方法形式</h2>
<p><code>S///</code> 操作符很好, 但是有时候有点笨拙。不要害怕, Raku 提供了 <code>.subst</code> 方法能满足你所有的替换需求并且消除你对 <code>.subst/.substr</code> 的困惑。下面来看例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">me</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">/</span><span class="sr">m</span><span class="ni">.</span><span class="p">/</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># cowmix</span>
<span class="c1"># cowmix</span>
</code></pre></div><p>这个方法要么接收一个正则表达式要么接收一个普通的字符串作为它的第一个位置参数, 它是要在调用者里面(&ldquo;meowmix&rdquo;)查找的东西。第二个参数是替换字符串。</p>
<p>通过简单地把它们列为具名 Bool 参数, 你也可以使用副词。在 <code>S///</code> 形式中, 副词 <code>:ss</code> 和 <code>:ii</code> 分别表明 <code>:s</code>(使空白有意义) 的出现和  <code>:i</code>(不区分大小写的匹配) 的出现。在方法形式中, 你必须把这些副词应用到正则表达式自身身上：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">Lorem Ipsum Dolor Sit Amet</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">/:</span><span class="na">i</span><span class="sr"> l</span><span class="p">/</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">ii</span><span class="p">;</span>
    <span class="nb">say</span> <span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">/:</span><span class="na">s</span><span class="sr"> Ipsum Dolor</span><span class="p">/</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Gipsum\nColor</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">:</span><span class="s">ss</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># Borem Ipsum Dolor Sit Amet</span>
<span class="c1"># Lorem Gipsum Color Sit Amet</span>
</code></pre></div><h2 id="方法形式的捕获">方法形式的捕获</h2>
<p>捕获对于替换操作来说不陌生, 所以我们来尝试捕获下方法调用形式的替换：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">/</span><span class="sr">me </span><span class="p">(</span><span class="ni">.</span><span class="o">+</span><span class="p">)/</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">c</span><span class="nv">$0</span><span class="p">&#34;;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># Use of Nil in string context  in block &lt;unit&gt; at test.p6 line 1</span>
<span class="c1"># c</span>
</code></pre></div><p>不是我们要找的。我们的替换字符串构建在达到 <code>.subst</code> 方法之前, 并且里面的 <code>$0</code> 变量实际上指向任何这个方法调用之前的东西, 而不是 <code>.subst</code> 正则表达式中的捕获。所以我们怎么来修正它呢？</p>
<p><code>.subst</code> 方法的第二个参数也可以接受一个 <a href="http://docs.raku.org/type/Callable">Callable</a>。在它里面, 你可以使用 <code>$0, $1, ... $n</code> 变量, 直到你想要的编号, 并从捕获中得到正确的值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">/</span><span class="sr">me </span><span class="p">(</span><span class="ni">.</span><span class="o">+</span><span class="p">)/</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">c</span><span class="nv">$0</span><span class="p">&#34;</span> <span class="p">};</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># cowmix</span>
</code></pre></div><p>这里, 我们为我们的 <strong>Callable</strong> 使用了尖号块儿, 但是 <strong>WhateverCode</strong> 和子例程也有效。每次替换都会调用这个 Callable, 并且把 <a href="http://docs.raku.org/type/Match">Match</a> 对象作为第一个位置参数传递给 Callable, 如果你需要访问它的话。</p>
<h2 id="结论">结论</h2>
<p><code>S///</code> 操作符在 Raku 中是 <code>s///</code> 操作符的战友, 它不是修改原来的字符串, 而是拷贝原来的字符串, 修改, 然后返回修改过的版本。这个操作符的使用方式跟 Perl 5 中的非破坏性替换操作符的使用方式不同。作为备选, 方法版本的 <code>.subst</code> 也能使用。 方法形式和操作符形式的替换都能接收一组副词以修改它们的行为, 来满足你的需求。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 twigil]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-04-an-example-of-raku-subset-and-multi/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 的 subsets 和 multi 辨别年龄" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中怎么为已存在的类添加方法" />
            
                <id>https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Twigils in Raku</blockquote><h2 id="raku-中的--和--twigil-是什么">Raku 中的 <code>.</code> 和 <code>!</code> <strong>twigil</strong> 是什么？</h2>
<p><code>.</code> <strong>twigil</strong> 的意思是&quot;这是类公用的&quot;, <code>!</code> <strong>twigil</strong> 的意思是“这是类私有的”, 只能用在类的内部。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">ScoreKeeper</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">@.options</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">%!player-points</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>普通的符号表明了词法作用域或包作用域, 但是 <strong>twigils</strong> 就像是 <strong>sigils</strong> 的兄弟, 表明了不同的作用域, 它影响了变量的作用域。<code>.</code> 和 <code>!</code> 是二级 <strong>sigils</strong>。</p>
<p>属性存在于每个类的实例中, 在类的内部, 可以直接使用 <code>!</code> 访问到实例的属性:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">Str</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">&#34;</span><span class="s2">(</span><span class="nv">$!x</span><span class="s2">, </span><span class="nv">$!y</span><span class="s2">)</span><span class="p">&#34;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>那么 <code>.</code> <strong>twigil</strong> 和 <code>!</code> <strong>twigil</strong> 之间有什么关系呢？下面看一个例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">Str</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1"># 注意这次我们使用 . 而非 !</span>
        <span class="p">&#34;</span><span class="s2">\$.x 等价于 self.x()</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span>  <span class="k">if</span> <span class="nv">$.x</span> <span class="o">==</span> <span class="nb">self</span><span class="o">.</span><span class="nb">x</span><span class="p">();</span>
        <span class="p">&#34;</span><span class="s2">\$.y 等价于 self.y()</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span>  <span class="k">if</span> <span class="nv">$.y</span> <span class="o">==</span> <span class="nb">self</span><span class="o">.</span><span class="nf">y</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nb">print</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nb">self</span><span class="o">.</span><span class="nb">x</span><span class="p">();</span> <span class="c1"># 调用实例的名为 x 的方法</span>
        <span class="nb">say</span> <span class="nb">self</span><span class="o">.</span><span class="nf">y</span><span class="p">();</span> <span class="c1"># 调用实例的名为 y 的方法</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$point</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">10</span>, <span class="s">y</span> <span class="o">=&gt;</span> <span class="mi">20</span><span class="p">);</span>
<span class="nv">$point</span><span class="o">.</span><span class="nb">Str</span><span class="p">;</span>   
<span class="nv">$point</span><span class="o">.</span><span class="nb">print</span><span class="p">;</span>
</code></pre></div><p>会输出:</p>
<pre><code>$.x 等价于 self.x()
$.y 等价于 self.y()
10
20
</code></pre><p>注意到, 属性被声明为 <code>$.x</code> 和 <code>$.y</code>, 但是在类的内部仍旧能通过 <code>$!x</code> 和 <code>$!y</code> 来访问属性。这是因为在 Raku 中所有的属性都是私有的并且在类中可以通过 <code>$!attribute-name</code> 直接访问这些属性。Raku 可以为你自动生成存取方法。</p>
<p>公共属性拥有 <code>.</code> twigil, 私有属性拥有 <code>!</code> twigil。</p>
<p><code>has $.x</code> 就是私有属性 <code>has $!x</code> 加上一个<code>getter</code>方法, 即 <code>method x() { ... }</code>。</p>
<p><code>has $.x is rw</code> 就是私有属性 <code>has $!x</code> 加上一个<code>getter/setter</code>方法。</p>
<h2 id="-twigil-就是调用了与属性同名的方法">. <strong>twigil</strong> 就是调用了与属性同名的方法</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">SaySomething</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;;</span>  <span class="p">}</span>
    <span class="k">method</span> <span class="nf">b</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$.a</span><span class="p">;</span>      <span class="p">}</span>
    <span class="k">method</span> <span class="nf">c</span><span class="p">()</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nf">a</span><span class="p">();</span> <span class="p">}</span> <span class="c1"># 这证明了 $.a 的 . twigil 做了一次隐式的实例方法调用。</span>
<span class="p">}</span>

<span class="n">SaySomething</span><span class="o">.</span><span class="nf">b</span><span class="p">;</span> <span class="c1"># 打印 &#34;a&#34;</span>
<span class="n">SaySomething</span><span class="o">.</span><span class="nf">c</span><span class="p">;</span> <span class="c1"># 打印 &#34;a&#34;</span>
</code></pre></div><h2 id="-twigil-中自动生成的方法可以被子类重写">. <strong>twigil</strong> 中自动生成的方法可以被子类重写</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Circle</span> <span class="k">is</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$!radius</span><span class="p">;</span>

    <span class="c1"># 重写父类中的 x() 方法和 y() 方法</span>
    <span class="k">method</span> <span class="nb">x</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">&#34;</span><span class="s2">I am x point in a Circle</span><span class="p">&#34;;</span>
    <span class="p">}</span>
    <span class="k">method</span> <span class="nf">y</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">&#34;</span><span class="s2">I am y point in a Circle</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$circle</span> <span class="o">=</span> <span class="n">Circle</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">radius</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">);</span>
<span class="nv">$circle</span><span class="o">.</span><span class="nb">x</span><span class="p">()</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># I am x point in a Circle</span>
<span class="nv">$circle</span><span class="o">.</span><span class="nf">y</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>   <span class="c1"># I am y point in a Circle</span>
</code></pre></div><p>如果不想子类重写父类中的方法, 那么在父类中声明属性的时候, 使用 <code>!</code> <strong>twigil</strong> 替代 <code>.</code> <strong>twigil</strong>。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[使用 Raku 的 subsets 和 multi 辨别年龄]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-01-04-an-example-of-raku-subset-and-multi/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中怎么为已存在的类添加方法" />
            
                <id>https://ohmyweekly.github.io/notes/2016-01-04-an-example-of-raku-subset-and-multi/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>An Example of Raku Subset and Multi</blockquote><p>举个例子, 假设 person 有一个 age 属性. 我能写一个 <code>multimethod</code>, 让它接收一个 person 作为参数, 并返回这样的结果吗:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">return</span> <span class="p">&#34;</span><span class="s2">child</span><span class="p">&#34;</span>  <span class="k">if</span> <span class="n">age</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span>
<span class="k">return</span> <span class="p">&#34;</span><span class="s2">adult</span><span class="p">&#34;</span>  <span class="k">if</span> <span class="mi">16</span> <span class="o">&lt;=</span> <span class="n">age</span> <span class="o">&lt;</span> <span class="mi">66</span><span class="p">;</span>
<span class="k">return</span> <span class="p">&#34;</span><span class="s2">senior</span><span class="p">&#34;</span> <span class="k">if</span> <span class="n">age</span> <span class="o">&gt;=</span> <span class="mi">66</span><span class="p">;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-r" data-lang="r"><span class="n">class</span> <span class="n">Person</span> <span class="p">{</span>
    <span class="n">has</span> <span class="n">Int</span> <span class="o">$</span><span class="n">.age</span><span class="p">;</span>
    <span class="n">has</span> <span class="n">Str</span> <span class="o">$</span><span class="n">.name</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这仅仅定义了一个拥有两个属性, 叫做 Person 的类. age 必须是 Int 型, name 必须是 Str 型. <code>.</code> 语法会生成一个只读访问器, 以使我们能从类的外部访问 getter 方法.</p>
<p>现在我们来定义一个 <code>age-group</code> multi 来告诉一个 person 属于哪个 age-group:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">age-group</span> <span class="p">(</span><span class="nv">$person</span> <span class="k">where</span> <span class="p">(</span><span class="o">*.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>  <span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">child</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span> <span class="p">(</span><span class="nv">$person</span> <span class="k">where</span> <span class="p">(</span><span class="o">*.</span><span class="nf">age</span> <span class="o">&gt;=</span> <span class="mi">66</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">senior</span><span class="p">&#34;}</span>
<span class="k">multi</span> <span class="nf">age-group</span> <span class="p">(</span><span class="nv">$person</span><span class="p">)</span>                      <span class="p">{</span> <span class="p">&#34;</span><span class="s2">adult</span><span class="p">&#34;</span> <span class="p">}</span>
</code></pre></div><p><code>where</code>从句给参数添加了一个<code>约束</code>, 这个约束告诉参数必须匹配这个参数右边的东西.这用于区别将要选取的 multi. <code>where</code>从句可以是一个 regex, 类型, 一个确切的值, 一个断言 block,或者一些其它东西.</p>
<p><code>*.age &lt; 16</code> 部分可能看起来更让人迷惑. 星号是什么? 星号是一个特殊的值, 叫做 Whatever. 它通常在给定情况下满足你的需求. 在智能匹配中, 它总是匹配, 所以你可以在 <code>given/when</code> block 中将它用作默认值. 但是 Whatever 最有用的地方之一是创建匿名 block. 对于大部分操作符, 如果你在 Whatever 上执行它们, 它会产生一个匿名 block 并使用它们的参数执行操作符. 如果一个表达式中有多个 Whatever, 则生成的匿名 block 会有多个参数对应于相应的 Whatever 位置.</p>
<p>例如, <code>* + 1</code> 产生一个 block,使参数的值加1. <code>* + *</code> 产生一个 block 使它的两个参数相加. 这个例子中, 我们调用 Whatever 的 <code>age</code>方法, 并询问它是否小于 16. 我们能用其它几种方式达到同样的效果, 但是更啰嗦:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="p">(</span><span class="nv">$person</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$person</span><span class="o">.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">-&gt;</span> <span class="nv">$person</span>    <span class="p">{</span> <span class="nv">$person</span><span class="o">.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">{</span> <span class="o">.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="p">}</span>
</code></pre></div><p>但是对于像这种简单的操作, Whatever 通常比其它方式更易读也更简洁. 不幸的是, 在参数列表的 where 从句中, 你需要使用括号括起很多复杂的表达式, 包括 Whatever block.</p>
<p>现在让我们在 Rakudo 的 REPL 中试试它吧:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="n">age-group</span> <span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">&lt;</span><span class="s">timmy</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">age</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="nb">child</span>
<span class="o">&gt;</span> <span class="n">age-group</span> <span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">&lt;</span><span class="s">john</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">age</span><span class="p">(</span><span class="mi">23</span><span class="p">))</span>
<span class="n">adult</span>
<span class="o">&gt;</span> <span class="n">age-group</span> <span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">&lt;</span><span class="s">ezekiel</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">age</span><span class="p">(</span><span class="mi">89</span><span class="p">))</span>
<span class="n">senior</span>
</code></pre></div><p>目前为止, 很好. 但是如果我们意外地传递了一个 age 而不是 Person 给 age-group 呢?</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="n">age-group</span> <span class="mi">15</span>
<span class="nb">Method</span> <span class="p">&#39;</span><span class="s1">age</span><span class="p">&#39;</span> <span class="nb">not</span> <span class="n">found</span> <span class="k">for</span> <span class="nb">invocant</span> <span class="k">of</span> <span class="k">class</span> <span class="nc">&#39;Int&#39;</span>
</code></pre></div><p>我们能指定只有 Person 对于 age-group 是合法的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">age-group</span> <span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span> <span class="k">where</span> <span class="p">(</span><span class="o">*.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">))</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">child</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span> <span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span> <span class="k">where</span> <span class="p">(</span><span class="o">*.</span><span class="nf">age</span> <span class="o">&gt;=</span> <span class="mi">66</span><span class="p">))</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">senior</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span> <span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">adult</span><span class="p">&#34;</span> <span class="p">}</span>
</code></pre></div><p>这正确地处理了 Person 问题. 调用带有 age 参数的 age-group 会怎样呢?</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="n">age-group</span> <span class="mi">15</span>
<span class="n">No</span> <span class="n">applicable</span> <span class="nb">candidates</span> <span class="n">found</span> <span class="nb">to</span> <span class="n">dispatch</span> <span class="nb">to</span> <span class="k">for</span> <span class="p">&#39;</span><span class="s1">age-group</span><span class="p">&#39;</span><span class="o">.</span> <span class="n">Available</span> <span class="nb">candidates</span> <span class="n">are:</span>
<span class="o">:</span><span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span> <span class="k">where</span> <span class="p">({</span> <span class="o">...</span> <span class="p">}))</span>
<span class="o">:</span><span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span> <span class="k">where</span> <span class="p">({</span> <span class="o">...</span> <span class="p">}))</span>
<span class="o">:</span><span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span><span class="p">)</span>
</code></pre></div><p>看起来更好. 假如我们允许询问 age 所属的 age-group 呢?</p>
<p>我们能重写 age-group 的 Person 变体, 接收 Int 类型的 age, 并写一个单个的 Person 变体来调用 age-group:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$age</span> <span class="k">where</span> <span class="p">(</span><span class="o">*</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>  <span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">child</span><span class="p">&#34;</span>  <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$age</span> <span class="k">where</span> <span class="p">(</span><span class="o">*</span> <span class="o">&gt;=</span> <span class="mi">66</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">senior</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$age</span><span class="p">)</span>                  <span class="p">{</span> <span class="p">&#34;</span><span class="s2">adult</span><span class="p">&#34;</span>  <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span><span class="p">)</span> <span class="p">{</span> <span class="n">age-group</span> <span class="nv">$person</span><span class="o">.</span><span class="nf">age</span> <span class="p">}</span>
</code></pre></div><p>这对于每个 Person 例子都有效, 还有它们的 ages.</p>
<p>现在,让我们使用 <code>age-group</code> 定义一个叫做 <code>print-name</code> 的 <code>multi</code> 来分发.
根据 <code>age-group</code> 分发最明显的方法是使用 where 从句.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">print-name</span><span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span> <span class="k">where</span> <span class="p">(</span><span class="nf">age-group</span><span class="p">(</span><span class="nv">$person</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#34;</span><span class="s2">child</span><span class="p">&#34;))</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Little </span><span class="p">{</span><span class="nv">$person</span><span class="o">.</span><span class="nb">name</span><span class="p">}&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">print-name</span><span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span> <span class="k">where</span> <span class="p">(</span><span class="nf">age-group</span><span class="p">(</span><span class="nv">$person</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#34;</span><span class="s2">adult</span><span class="p">&#34;))</span> <span class="p">{</span> <span class="nv">$person</span><span class="o">.</span><span class="nb">name</span>            <span class="p">}</span>
<span class="k">multi</span> <span class="nf">print-name</span><span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span> <span class="k">where</span> <span class="p">(</span><span class="nf">age-group</span><span class="p">(</span><span class="nv">$person</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#34;</span><span class="s2">senior</span><span class="p">&#34;)){</span> <span class="p">&#34;</span><span class="s2">Old Man </span><span class="p">{</span><span class="nv">$person</span><span class="o">.</span><span class="nb">name</span><span class="p">}&#34;}</span>
</code></pre></div><p>双引号字符串中的 <code>{$person.name}</code> 将 block 的结果插值到字符串中.</p>
<p>让我们再试试:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">&gt; print-name Person.new<span class="o">(</span>:name&lt;timmy&gt;, :age<span class="o">(</span>10<span class="o">))</span>
Little Timmy
&gt; print-name Person.new<span class="o">(</span>:name&lt;john&gt;, :age<span class="o">(</span>23<span class="o">))</span>
John
&gt; print-name Person.new<span class="o">(</span>:name&lt;ezekiel&gt;, :age<span class="o">(</span>89<span class="o">))</span>
Old Man Ezekiel
</code></pre></div><p>那很棒. 但是如果我们有更多的基于 person 的 <code>age-group</code> 的 multis 要分发呢? 难道我们真的每次都要写出 <code>(Person $person where (age-group($person) eq &quot;child&quot;))</code> 这样的代码吗? 不, 我们不需要, 感谢 subset 类型.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">subset</span> <span class="nc">Child</span>  <span class="k">of</span> <span class="nc">Person</span> <span class="k">where</span> <span class="o">*.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span>
<span class="k">subset</span> <span class="nc">Adult</span>  <span class="k">of</span> <span class="nc">Person</span> <span class="k">where</span> <span class="k">-&gt;</span> <span class="nv">$person</span> <span class="p">{</span> <span class="mi">16</span> <span class="o">&lt;=</span> <span class="nv">$person</span><span class="o">.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">66</span> <span class="p">};</span>
<span class="k">subset</span> <span class="nc">Senior</span> <span class="k">of</span> <span class="nc">Person</span> <span class="k">where</span> <span class="o">*.</span><span class="nf">age</span> <span class="o">&gt;=</span> <span class="mi">66</span><span class="p">;</span>

<span class="k">multi</span> <span class="nf">print-name</span><span class="p">(</span><span class="n">Child</span> <span class="nv">$person</span><span class="p">)</span>  <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Little </span><span class="p">{</span><span class="nv">$person</span><span class="o">.</span><span class="nb">name</span><span class="p">}&#34;</span>  <span class="p">}</span>
<span class="k">multi</span> <span class="nf">print-name</span><span class="p">(</span><span class="n">Adult</span> <span class="nv">$person</span><span class="p">)</span>  <span class="p">{</span> <span class="nv">$person</span><span class="o">.</span><span class="nb">name</span>             <span class="p">}</span>
<span class="k">multi</span> <span class="nf">print-name</span><span class="p">(</span><span class="n">Senior</span> <span class="nv">$person</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Old Man </span><span class="p">{</span><span class="nv">$person</span><span class="o">.</span><span class="nb">name</span><span class="p">}&#34;</span> <span class="p">}</span>
</code></pre></div><p>由于 Rakudo 在处理含有组合的链式比较操作符的 Whatever 时有一个 bug, 我们不得不为 Adult 写一个显式的 block.</p>
<p>这个 bug 现已修复, 所以:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">subset</span> <span class="nc">Adult</span>  <span class="k">of</span> <span class="nc">Person</span> <span class="k">where</span> <span class="k">-&gt;</span> <span class="nv">$person</span> <span class="p">{</span> <span class="mi">16</span> <span class="o">&lt;=</span> <span class="nv">$person</span><span class="o">.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">66</span> <span class="p">};</span>
</code></pre></div><p>等价于:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">subset</span> <span class="nc">Adult</span>  <span class="k">of</span> <span class="nc">Person</span> <span class="k">where</span>  <span class="mi">16</span> <span class="o">&lt;=</span> <span class="o">*.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">66</span><span class="p">;</span>
</code></pre></div><p>这个新版本的 <code>print-name</code> 与之前旧版本产生同样的结果. 现在我们能从 <code>Child/Adult/Senior</code> 的角度重写 <code>age-group</code> :</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="n">Child</span><span class="p">)</span>  <span class="p">{</span> <span class="p">&#34;</span><span class="s2">child</span><span class="p">&#34;</span>  <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="n">Adult</span><span class="p">)</span>  <span class="p">{</span> <span class="p">&#34;</span><span class="s2">adult</span><span class="p">&#34;</span>  <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="n">Senior</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">senior</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$age</span><span class="p">)</span> <span class="p">{</span> <span class="n">age-group</span> <span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">:</span><span class="nv">$age</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p><code>:$age</code> 是 <code>:age($age)</code> 的简写方式.</p>
<p>又一次, 我们有了产生想要的结果的更清晰的代码, 多亏了 multiple 分发和 subset 类型.</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[在 Raku 中怎么为已存在的类添加方法]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-04-an-example-of-raku-subset-and-multi/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 的 subsets 和 multi 辨别年龄" />
            
                <id>https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Add a Method to an Existing Class in Raku</blockquote><h2 id="raku-中怎么为已存在的类添加方法">Raku 中怎么为已存在的类添加方法</h2>
<p>Int 类有一个方法叫做 <code>is-prime</code>, 我想为 <code>Int</code> 类型添加其它的方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">MyInt</span> <span class="k">is</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">is-even</span> <span class="p">()</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">False</span> <span class="k">if</span> <span class="nb">self</span> <span class="nv">%</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">True</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="n">MyInt</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">138</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$n</span><span class="o">.</span><span class="nf">is-even</span><span class="p">;</span>
</code></pre></div><p>通过类的继承也是一种方法, 但是不是我想要的。Swift 中可以通过扩展来实现, Raku 中有一个 <code>add_method</code> 方法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nb">add_method</span><span class="p">(</span><span class="n">Metamodel::MethodContainer:</span> <span class="nv">$obj</span><span class="o">,</span> <span class="nv">$name</span><span class="o">,</span> <span class="nv">$code</span><span class="p">)</span>
</code></pre></div><p>这会给元类(meta class)添加一个方法, 使用 <code>$name</code> 作为调用的方法名。这只会在类型被组合前使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">Int</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">is-even</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">method</span> <span class="p">()</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">False</span> <span class="k">if</span> <span class="nb">self</span> <span class="nv">%</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">True</span><span class="p">;</span>
    <span class="p">}</span> <span class="p">);</span>

<span class="nb">say</span> <span class="mi">137</span><span class="o">.</span><span class="nf">is-even</span><span class="p">;</span>
<span class="nb">say</span> <span class="nb">Int</span><span class="o">.^</span><span class="nb">methods</span><span class="p">;</span>
</code></pre></div><p>如果我调用 <code>Int.^methods</code> 时, <code>is-even</code> 没有出现。但是上面的代码能被调用并起作用了。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">Int</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(&#39;</span><span class="s1">fac</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">method</span> <span class="p">()</span> <span class="k">returns</span> <span class="nb">Int:D</span> <span class="p">{</span>
     <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">self</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
     <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">self</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
     <span class="k">my</span> <span class="nv">$sum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="nb">self</span>  <span class="p">{</span><span class="nv">$sum</span> <span class="o">*=</span> <span class="nv">$_</span><span class="p">};</span> <span class="k">return</span> <span class="nv">$sum</span><span class="p">;</span>
<span class="p">});</span>

<span class="mi">1</span><span class="o">.</span><span class="nf">fac</span> <span class="c1"># 1</span>
<span class="mi">5</span><span class="o">.</span><span class="nf">fac</span> <span class="c1"># 120</span>
</code></pre></div><p><code>method</code> 后面的圆括号是方法的签名：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">Int</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(&#39;</span><span class="s1">power</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">method</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$num</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nb">self</span> <span class="o">**</span> <span class="nv">$num</span><span class="p">;</span>
<span class="p">});</span>

<span class="mi">2</span><span class="o">.</span><span class="nf">power</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>  <span class="c1"># 8</span>
<span class="mi">2</span><span class="o">.</span><span class="nf">power</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># 1024</span>
</code></pre></div><h2 id="词法方法">词法方法</h2>
<p>我可以让方法不依附于任何类, 并且能在对象上调用该方法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">&amp;is-even</span> <span class="o">=</span> <span class="k">method</span> <span class="p">(</span><span class="nb">Int:D</span> <span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="p">{</span> <span class="nb">self</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="p">};</span>
</code></pre></div><p>这构建了一个 <code>Callable</code>（查看以下 <code>&amp;is-even.WHAT</code>）。 在签名中, 我把它约束为一个定义了的 Int 类型的值(<code>Int:D</code>), 但是没有给它名字。我在类型约束后面添加冒号来说明第一个参数是调用者。现在我能把这个方法应用到任何我想要的对象上:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">137</span><span class="o">.&amp;</span><span class="nf">is-even</span><span class="p">;</span>
<span class="nb">say</span> <span class="mi">138</span><span class="o">.&amp;</span><span class="nf">is-even</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span><span class="o">.&amp;</span><span class="nf">is-even</span><span class="p">;</span>  <span class="c1"># works, although inside is-even blow up</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的特性(二)]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-16-features-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-03-23-sneaking-into-a-loop/?utm_source=atom_feed" rel="related" type="text/html" title="Sneaking Into a Loop" />
                <link href="https://ohmyweekly.github.io/notes/2015-03-14-using-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Using Raku" />
            
                <id>https://ohmyweekly.github.io/notes/2015-03-16-features-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+08:00</published>
            <updated>2021-07-10T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Features in Raku</blockquote><h2 id="set">Set</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$keywords</span> <span class="o">=</span> <span class="nb">set</span> <span class="p">&lt;</span><span class="s">if for unless while</span><span class="p">&gt;;</span> <span class="c1"># create a set</span>

<span class="k">sub</span> <span class="nf">has-keyword</span><span class="p">(</span><span class="o">*</span><span class="nv">@words</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nv">@words</span> <span class="k">-&gt;</span> <span class="nv">$word</span> <span class="p">{</span>
        <span class="c1"># 依次检查数组中的元素是否属于集合 $keywords</span>
        <span class="k">return</span> <span class="nb">True</span> <span class="k">if</span> <span class="nv">$word</span> <span class="ow">(elem)</span> <span class="nv">$keywords</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nb">False</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">has-keyword</span> <span class="p">&#39;</span><span class="s1">not</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">one</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">here</span><span class="p">&#39;;</span>  <span class="c1"># False</span>
<span class="nb">say</span> <span class="n">has-keyword</span> <span class="p">&#39;</span><span class="s1">but</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">here</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">for</span><span class="p">&#39;;</span>  <span class="c1"># True</span>
</code></pre></div><h2 id="series-operator">Series Operator</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span><span class="o">=</span><span class="p">&lt;</span><span class="s">A G C T</span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">$x</span><span class="o">=</span><span class="nv">@a</span><span class="p">;</span>

<span class="k">for</span> <span class="mi">1</span> <span class="o">...</span> <span class="o">*</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span>  
  <span class="p">((</span> <span class="o">[</span><span class="ow">X</span><span class="o">~]</span> <span class="nv">$x</span> <span class="ow">xx</span> <span class="nv">$a</span> <span class="p">))</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
  <span class="nb">last</span> <span class="k">if</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>倒序的 range:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="mi">10</span> <span class="o">...</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="o">.</span><span class="nb">say</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><h2 id="flipplop">flip/plop</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$file</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#39;</span><span class="s1">flip_flop.txt</span><span class="p">&#39;;</span>

<span class="k">for</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$line</span> <span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="nv">$line</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="ni">^</span><span class="sr">\;</span><span class="p">/</span> <span class="ow">ff</span> <span class="nv">$line</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="ni">^</span><span class="sr">\&#34;</span><span class="p">/);</span>
<span class="p">}</span>
</code></pre></div><p><code>$line ~~ m/^\;/ ff $line ~~ m/^\&quot;/</code> 过滤掉 <code>;</code> 和 <code>&quot;</code> 之间的内容, 再对它进行取反操作就是过滤后剩下的文本。</p>
<p>flip_flop.txt 内容如下：</p>
<pre><code>; next is some lines to skip,include this line
fuck fuck fuck
dam dam dam
mie mie mie
&quot; next is subject
There is more than one way to do it
                                -- Larry Wall

We hope Raku is wrote by the hole Socfilia
                                -- Larry Wall
; next is some lines to skip,include this line
fuck fuck fuck
dam dam dam
mie mie mie
&quot; next is subject
programming is hard,Let's go shopping
                               -- Larry Wall
Ruby is Another Raku
                               -- Larry Wall
</code></pre><p>输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">There is more than one way to do it
                                -- Larry Wall
We hope Raku is wrote by the hole Socfilia
                                -- Larry Wall
programming is hard,Let&#39;s go shopping
                               -- Larry Wall
Ruby is Another Raku
                               -- Larry Wall
</code></pre></div><p><code>ff</code> 操作符左右两侧的 <code>^</code> 表示排除:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">20</span> <span class="p">{</span><span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">9</span> <span class="ow">ff</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">16</span><span class="p">}</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">20</span> <span class="p">{</span><span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">9</span> <span class="ow">^ff</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">16</span><span class="p">}</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">20</span> <span class="p">{</span><span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">9</span> <span class="ow">ff^</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">16</span><span class="p">}</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">20</span> <span class="p">{</span><span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">9</span> <span class="ow">^ff</span><span class="o">^</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">16</span><span class="p">}</span>
</code></pre></div><p>输出:</p>
<pre><code>9
10
11
12
13
14
15
16
----------
10
11
12
13
14
15
16
----------
9
10
11
12
13
14
15
----------
10
11
12
13
14
15
</code></pre><h2 id="grammars">Grammars</h2>
<p>解析 CSV:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">﻿<span class="k">grammar</span> <span class="n">CSV</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">line</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">?</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">line</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="ni">^^</span><span class="sr">            </span><span class="c1"># Beginning of a line
</span><span class="c1"></span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">value</span><span class="p">&gt;</span><span class="o">*</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> \, </span><span class="c1"># Any number of &lt;value&gt;s with commas in `between` them
</span><span class="c1"></span><span class="sr">        </span><span class="ni">$$</span><span class="sr">            </span><span class="c1"># End of a line
</span><span class="c1"></span><span class="sr">    </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">value</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">[</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">&#34;,</span><span class="se">\n</span><span class="p">]&gt;</span><span class="sr">     </span><span class="c1"># Anything not a double quote, comma or newline
</span><span class="c1"></span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quoted-text</span><span class="p">&gt;</span><span class="sr"> </span><span class="c1"># Or some quoted text
</span><span class="c1"></span><span class="sr">        </span><span class="p">]</span><span class="o">*</span><span class="sr">              </span><span class="c1"># Any number of times
</span><span class="c1"></span><span class="sr">    </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">quoted-text</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        \&#34;
</span><span class="sr">        </span><span class="p">[</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">&#34;\\</span><span class="p">]&gt;</span><span class="sr"> </span><span class="c1"># Anything not a &#34; or \
</span><span class="c1"></span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">\&#34;</span><span class="p">&#39;</span><span class="sr">     </span><span class="c1"># Or \&#34;, an escaped quotation mark
</span><span class="c1"></span><span class="sr">        </span><span class="p">]</span><span class="o">*</span><span class="sr">         </span><span class="c1"># Any number of times
</span><span class="c1"></span><span class="sr">        \&#34;
</span><span class="sr">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1"># method parse($str, :$rule = &#39;TOP&#39;, :$actions) returns Match:D</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Valid CSV file!</span><span class="p">&#34;</span> <span class="k">if</span> <span class="n">CSV</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOCSV/ </span><span class="s">);
</span><span class="s">    Year,Make,Model,Length
</span><span class="s">    1997,Ford,E350,2.34
</span><span class="s">    2000,Mercury,Cougar,2.38
</span><span class="s">    </span><span class="p">EOCSV</span>

<span class="nb">say</span> <span class="n">CSV</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOCSV/,</span><span class="s"> &#39;line&#39;, :$actions );
</span><span class="s">    Year,Make,Model,Length
</span><span class="s">    1997,Ford,E350,2.34
</span><span class="s">    2000,Mercury,Cougar,2.38
</span><span class="s">    </span><span class="p">EOCSV</span>
</code></pre></div><p>解析天气数据:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">StationDataParser</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span>          <span class="p">{</span><span class="sr"> </span><span class="ni">^</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">keyval</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">observations</span><span class="p">&gt;</span><span class="sr"> </span><span class="ni">$</span><span class="sr">             </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">keyval</span>       <span class="p">{</span><span class="sr"> </span><span class="nv">$&lt;key&gt;</span><span class="o">=</span><span class="p">[&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">=</span><span class="p">]&gt;</span><span class="o">+</span><span class="p">]</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="nv">$&lt;val&gt;</span><span class="o">=</span><span class="p">[</span><span class="se">\N</span><span class="o">+</span><span class="p">]</span><span class="sr"> </span><span class="se">\n</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">observations</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">Obs:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="se">\n</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">observation</span><span class="p">&gt;</span><span class="o">+</span><span class="sr">             </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">observation</span>  <span class="p">{</span><span class="sr"> </span><span class="nv">$&lt;year&gt;</span><span class="o">=</span><span class="p">[</span><span class="se">\d</span><span class="o">+</span><span class="p">]</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">temp</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="nv">%%</span><span class="sr"> </span><span class="p">[</span><span class="se">\h</span><span class="o">*</span><span class="p">]</span><span class="sr"> </span><span class="se">\n</span><span class="sr">    </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">temp</span>         <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="o">?</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> \</span><span class="ni">.</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr">                          </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">StationData</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.country</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@.data</span><span class="p">;</span>

    <span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(</span><span class="o">:</span><span class="nv">%info</span> <span class="p">(:</span><span class="s">Name</span><span class="p">(</span><span class="nv">$!name</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">Country</span><span class="p">(</span><span class="nv">$!country</span><span class="p">)</span><span class="o">,</span> <span class="o">*</span><span class="nv">%</span><span class="p">)</span><span class="o">,</span> <span class="o">:</span><span class="nv">@!data</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">StationDataActions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="n">StationData</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
            <span class="s">info</span> <span class="o">=&gt;</span> <span class="nv">$&lt;keyval&gt;</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">ast</span><span class="p">)</span><span class="o">.</span><span class="nb">hash</span>,
            <span class="s">data</span> <span class="o">=&gt;</span> <span class="nv">$&lt;observations&gt;</span><span class="o">.</span><span class="nb">ast</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">keyval</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="o">~</span><span class="nv">$&lt;key&gt;</span> <span class="o">=&gt;</span> <span class="o">~</span><span class="nv">$&lt;val&gt;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">method</span> <span class="nf">observations</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="nv">$&lt;observation&gt;</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">ast</span><span class="p">)</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*.</span><span class="nb">value</span><span class="o">.</span><span class="nb">none</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">99</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">method</span> <span class="nf">observation</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="o">+</span><span class="nv">$&lt;year&gt;</span> <span class="o">=&gt;</span> <span class="nv">$&lt;temp&gt;</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">Num</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">StationDataParser</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOCSV/,</span><span class="s"> :actions(StationDataActions)).ast
</span><span class="s">Name= Jan Mayen
</span><span class="s">Country= NORWAY
</span><span class="s">Lat=   70.9
</span><span class="s">Long=    8.7
</span><span class="s">Height= 10
</span><span class="s">Start year= 1921
</span><span class="s">End year= 2009
</span><span class="s">Obs:
</span><span class="s">1921 -4.4 -7.1 -6.8 -4.3 -0.8  2.2  4.7  5.8  2.7 -2.0 -2.1 -4.0  
</span><span class="s">1922 -0.9 -1.7 -6.2 -3.7 -1.6  2.9  4.8  6.3  2.7 -0.2 -3.8 -2.6  
</span><span class="s">2008 -2.8 -2.7 -4.6 -1.8  1.1  3.3  6.1  6.9  5.8  1.2 -3.5 -0.8  
</span><span class="s">2009 -2.3 -5.3 -3.2 -1.6  2.0  2.9  6.7  7.2  3.8  0.6 -0.3 -1.3
</span><span class="s"></span><span class="p">EOCSV</span>
</code></pre></div><h2 id="raku-examples">Raku Examples</h2>
<ul>
<li>1、生成8位随机密码</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span>  <span class="nv">@char_set</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">A</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">~</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">!</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">@</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">#</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">$</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">%</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">^</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">&amp;</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">*</span><span class="p">&#39;);</span>
<span class="nb">say</span> <span class="nv">@char_set</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;&#34;)</span> <span class="c1"># 不重复的8位密码</span>

<span class="nb">say</span> <span class="nv">@char_set</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;&#34;)</span> <span class="c1"># 可以重复</span>
</code></pre></div><ul>
<li>2、打印前5个数字</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="o">[^</span><span class="mi">5</span><span class="o">]</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span> <span class="o">...</span> <span class="o">[^</span><span class="mi">10</span><span class="o">]</span>  <span class="c1"># 这个会无限循环</span>
</code></pre></div><ul>
<li>
<p>3、排序</p>
</li>
<li>
<p>3.1 按数值排序</p>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%hash</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Perl</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">Python</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">Go</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">CMD</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">20</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">Php</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">80</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">Java</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">85</span><span class="p">;</span>

<span class="nv">%hash</span><span class="o">.</span><span class="nb">values</span><span class="o">.</span><span class="nb">sort</span><span class="p">;</span>
<span class="nv">%hash</span><span class="o">.</span><span class="nb">values</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*</span><span class="p">);</span>
</code></pre></div><ul>
<li>3.2 按分数排序散列：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%hash</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Perl</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">80</span><span class="o">,</span>
         <span class="p">&#39;</span><span class="s1">Python</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="o">,</span>
             <span class="p">&#39;</span><span class="s1">Go</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">95</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">CMD</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">20</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">Php</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">80</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">Java</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">85</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">%hash</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span><span class="o">-.</span><span class="nb">value</span><span class="p">})</span><span class="o">.</span><span class="nb">hash</span><span class="o">.</span><span class="nb">keys</span> <span class="k">-&gt;</span> <span class="nv">$key</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$key</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">\t</span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">%hash</span><span class="p">{&#34;</span><span class="nv">$key</span><span class="p">&#34;}</span>
<span class="p">}</span>
</code></pre></div><p>输出:</p>
<pre><code>Python	100
Go	95
Java	85
Perl	80
Php	80
CMD	20
</code></pre><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(&#39;</span><span class="s1">xx</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">zz</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">classify</span><span class="p">(</span><span class="o">*.</span><span class="nb">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">))&lt;</span><span class="s">z</span><span class="p">&gt;;</span> <span class="c1"># xz yz zz</span>
</code></pre></div><p>加密：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">rot13</span> <span class="p">{</span> <span class="nv">$^s</span><span class="o">.</span><span class="nb">trans</span><span class="p">(&#39;</span><span class="s1">a..z</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">n..za..m</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">A..Z</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">N..ZA..M</span><span class="p">&#39;)</span> <span class="p">}</span>
</code></pre></div><ul>
<li>4、求 1! + 2! + 3! + 4! +5! + 6! +7! +8! +9! +10!</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!</span><span class="p">&gt;(</span><span class="nb">Int</span> <span class="nv">$x</span><span class="p">){</span> <span class="o">[*]</span> <span class="mi">1</span><span class="o">..</span><span class="nv">$x</span> <span class="p">}</span>
<span class="nb">say</span> <span class="o">[+]</span> <span class="mi">1</span><span class="o">!,</span><span class="mi">2</span><span class="o">!,</span><span class="mi">3</span><span class="o">!,</span><span class="mi">4</span><span class="o">!,</span><span class="mi">5</span><span class="o">!,</span><span class="mi">6</span><span class="o">!,</span><span class="mi">7</span><span class="o">!,</span><span class="mi">8</span><span class="o">!,</span><span class="mi">9</span><span class="o">!,</span><span class="mi">10</span><span class="o">!</span> <span class="c1"># 4037913</span>
</code></pre></div><ul>
<li>5、列出对象所有可用的方法</li>
</ul>
<p>使用元对象协议， 即 <code>对象名.^methods</code></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="p">&#34;</span><span class="s2">JZY</span><span class="p">&#34;</span><span class="o">.^</span><span class="nb">methods</span>
</code></pre></div><blockquote>
<p>BUILD Int Num chomp chop substr pred succ match ords lines samecase samespace tr
im-leading trim-trailing trim words encode wordcase trans indent codes path WHIC
H Bool Str Stringy DUMP ACCEPTS Numeric gist perl comb subst split</p>
</blockquote>
<ul>
<li>6、 匿名子例程</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="k">sub</span><span class="p">(</span><span class="nv">$a</span><span class="p">){</span> <span class="nv">$a</span><span class="o">+</span><span class="mi">2</span> <span class="p">};</span><span class="nb">say</span> <span class="nv">$x</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">4</span>
<span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="nv">$a</span><span class="o">+</span><span class="mi">2</span> <span class="p">};</span><span class="nb">say</span> <span class="nv">$x</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">4</span>
<span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="o">*</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span><span class="nb">say</span> <span class="nv">$x</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">4</span>
</code></pre></div><ul>
<li>7、字符串翻转与分割</li>
</ul>
<pre><code>&gt; 1223.flip
3221
&gt; 'abcd'.flip
dcba
&gt; 1234.comb
1 2 3 4
&gt; 1234.comb(/./)
1 2 3 4
&gt; 'abcd'.comb
a b c d
</code></pre><ul>
<li>8、有这么一个四位数 A，其个位数相加得到 B，将 B 乘以 B 的反转数后得到 A，请求出这个数字。</li>
</ul>
<p>举例， 1458 就符合这个条件，1+4+5+8 ＝ 18， 18 ＊ 81 ＝1458</p>
<p>请找出另一个符合上面条件的四位数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="o">^</span><span class="mi">37</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span>
  <span class="k">my</span> <span class="nv">$r</span> <span class="o">=</span> <span class="nv">$_</span> <span class="o">*</span> <span class="o">.</span><span class="nb">flip</span><span class="p">;</span>
  <span class="mi">1000</span> <span class="o">&lt;</span> <span class="nv">$r</span> <span class="ow">and</span> <span class="nv">$_</span> <span class="o">==</span> <span class="o">[+]</span> <span class="nv">$r</span><span class="o">.</span><span class="nb">comb</span> <span class="ow">and</span> <span class="nb">say</span> <span class="nv">$r</span>
<span class="p">}</span>
</code></pre></div><p><code>^37</code> 产生一个范围  0 .. ^37, 就是 0到36之前的数，在表达式中代表 B</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$b</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1000</span><span class="o">..^</span><span class="mi">10000</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
  <span class="nv">$b</span><span class="o">=[+]</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">comb</span><span class="p">;</span>
  <span class="nb">say</span> <span class="nv">$i</span> <span class="k">if</span> <span class="nv">$b</span><span class="o">*</span><span class="nv">$b</span><span class="o">.</span><span class="nb">flip</span> <span class="o">==</span> <span class="nv">$i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>输出:</p>
<pre><code>1458
1729
</code></pre><ul>
<li>9、 大小写转换</li>
</ul>
<pre><code>&gt; my $word= &quot;I Love Raku&quot;
I Love Raku
&gt; $word.wordcase()
I Love Raku
&gt; my $lowercase = &quot;i love perl 6&quot;
i love perl 6
&gt; $lowercase.wordcase()
I Love Raku
&gt; $word.samecase('A')
I LOVE PERL 6
&gt; $word.samecase('a')
i love perl 6
&gt; $word.samecase('a').wordcase()
I Love Raku
</code></pre><ul>
<li>10、 多行文本</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$string</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/THE END/;</span><span class="s">
</span><span class="s">Norway
</span><span class="s">    Oslo : 59.914289,10.738739 : 2
</span><span class="s">    Bergen : 60.388533,5.331856 : 4
</span><span class="s">Ukraine
</span><span class="s">    Kiev : 50.456001,30.50384 : 3
</span><span class="s">Switzerland
</span><span class="s">    Wengen : 46.608265,7.922065 : 3
</span><span class="s"></span><span class="p">THE END</span>

<span class="nb">say</span> <span class="nv">$string</span><span class="p">;</span>
</code></pre></div><ul>
<li>11、 超运算符与子例程</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">1 2 3 4</span><span class="p">&gt;;</span>

<span class="k">sub</span> <span class="nf">by2</span><span class="p">(</span><span class="nv">$n</span><span class="p">){</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="nv">$n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">power2</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">$n</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@b</span> <span class="o">=</span> <span class="nv">@a</span><span class="o">».&amp;</span><span class="nf">by2</span><span class="o">».&amp;</span><span class="nf">power2</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@b</span><span class="p">;</span> <span class="c1"># 4 16 36 64</span>
</code></pre></div><p>为什么是 <code>&amp;function</code> 呢：</p>
<blockquote>
<p>the name of the by2 function is &amp;by2, just as the name of the foo scalar is $foo and the name of the foo array is @foo</p>
</blockquote>
<ul>
<li>12、 如何在 Raku 中执行外部命令并捕获输出</li>
</ul>
<pre><code>&gt; my $res = qqx{mkdir 123456}

# 或使用 qx{ }
&gt; my $res = qx{mkdir 112233}
</code></pre><ul>
<li>13、Does Raku support something equivalent to Perl5&rsquo;s <strong>DATA</strong> and <strong>END</strong> sections?</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">=foo</span><span class="sd"> This is a Pod block. A single line one. This Pod block&#39;s name is &#39;foo&#39;.
</span><span class="sd"></span>
<span class="k">=begin</span><span class="sd"> </span><span class="k">qux</span><span class="sd">
</span><span class="sd">This is another syntax for defining a Pod block.
</span><span class="sd">It allows for multi line content.
</span><span class="sd">This block&#39;s name is &#39;qux&#39;.
</span><span class="sd"></span><span class="k">=end qux</span>

<span class="k">=data</span><span class="sd"> A data block -- a Pod block with the name &#39;data&#39;.
</span><span class="sd"></span>
<span class="c1"># Data blocks are P6&#39;s version of P5&#39;s __DATA__.</span>
<span class="c1"># But you can have multiple data blocks:</span>

<span class="k">=begin</span><span class="sd"> </span><span class="k">data</span><span class="sd">
</span><span class="sd">Another data block.
</span><span class="sd">This time a multi line one.
</span><span class="sd"></span><span class="k">=end data</span>

<span class="nv">$=pod</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*.</span><span class="nb">name</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">data</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">contents</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">contents</span><span class="o">.</span><span class="nb">say</span><span class="p">);</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">45</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@$=pod</span> <span class="p">{</span>
  <span class="k">if</span> <span class="o">.</span><span class="nb">name</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">data</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="o">.</span><span class="nb">contents</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">contents</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>14、生成含有26个英文字母和下划线的 junction</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">any</span><span class="p">(&#39;</span><span class="s1">A</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">_</span><span class="p">&#39;);</span>
</code></pre></div><ul>
<li>15、判断一个字符是否在某个集合中</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span>  <span class="nb">so</span> <span class="nb">any</span><span class="p">(&#39;</span><span class="s1">A</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;)</span> <span class="o">∈</span> <span class="nb">set</span><span class="p">(&#34;</span><span class="s2">12a34</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">comb</span><span class="p">)</span>
</code></pre></div><p>&ldquo;12a34&rdquo;.comb 会把字符串分割为单个字符，返回一个字符数组。</p>
<ul>
<li>16、生成 IP 地址范围</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="p">&#34;</span><span class="s2">192.168.10.</span><span class="p">&#34;</span> <span class="p">«</span><span class="s2">~</span><span class="p">»</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="nb">list</span>
</code></pre></div><ul>
<li>17、 生成 OC 中的测试数组</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="p">&#34;</span><span class="s2">@</span><span class="p">&#34;</span> <span class="p">«</span><span class="s2">~</span><span class="p">»</span> <span class="p">&#39;</span><span class="s1">&#34;Perl</span><span class="p">&#39;</span> <span class="p">«</span><span class="s2">~</span><span class="p">»</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">30</span><span class="p">)</span><span class="o">.</span><span class="nb">list</span> <span class="p">«</span><span class="s2">~</span><span class="p">»</span> <span class="p">&#39;</span><span class="s1">&#34;,</span><span class="p">&#39;</span>
</code></pre></div><pre><code>@&quot;Perl&quot;1&quot;,
@&quot;Perl&quot;2&quot;,
@&quot;Perl&quot;3&quot;,
@&quot;Perl&quot;4&quot;,
@&quot;Perl&quot;5&quot;,
…
</code></pre>
<ul>
<li>18、我想以 AGCT 4 种字母为基础生成字符串。</li>
</ul>
<p>比如希望长度为1，输出A,G,C,T。</p>
<p>如果长度为2，输出 AA,AG,AC,AT,GA,GG,GC,GT,CA,CG,CC,CT,TA,TG,TC,TT。这样的结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="p">&#34;&#34;</span>             <span class="c1"># 长度为1</span>
<span class="p">(</span><span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span><span class="p">)</span>           <span class="c1"># 长度为2</span>
<span class="p">(</span><span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span><span class="p">)</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span>     <span class="c1"># 长度为3</span>
<span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span> <span class="c1"># 长度为4</span>
</code></pre></div><pre><code>&gt; my @a=&lt;A G C T&gt;
A G C T
&gt; my $x=@a
A G C T
&gt; $x xx 2
A G C T A G C T
&gt; $x xx 3
A G C T A G C T A G C T
&gt; ($x xx 3).WHAT
(List)
&gt; $x.WHAT
(Array)

&gt; ([X~] $x xx 2).join(',')
AA,AG,AC,AT,GA,GG,GC,GT,CA,CG,CC,CT,TA,TG,TC,TT
</code></pre><p>惰性操作符：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span><span class="o">=</span><span class="p">&lt;</span><span class="s">A G C T</span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">$x</span><span class="o">=</span><span class="nv">@a</span><span class="p">;</span>  <span class="c1"># 或者使用 $x = @(&#39;A&#39;,&#39;G&#39;,&#39;C&#39;,&#39;T&#39;)</span>
<span class="k">for</span> <span class="mi">1</span> <span class="o">...^</span> <span class="o">*</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{((</span><span class="o">[</span><span class="ow">X</span><span class="o">~]</span> <span class="nv">$x</span> <span class="ow">xx</span> <span class="nv">$a</span><span class="p">))</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span><span class="nb">last</span> <span class="k">if</span> <span class="nv">$a</span><span class="o">==</span><span class="mi">4</span><span class="p">;};</span>
</code></pre></div><h2 id="best-of-raku">Best Of Raku</h2>
<ul>
<li>Command Line 命令行</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#               Perl 5                                     Raku</span>
 <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">bananas are good\n</span><span class="p">&#34;;</span>                     <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">bananas are good</span><span class="p">&#34;;</span>
 <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">and I said: </span><span class="nv">$quotes</span><span class="p">{</span>\&#34;<span class="n">me</span>\&#34;<span class="p">}</span><span class="s2">\n</span><span class="p">&#34;;</span>          <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">and I said: </span><span class="nv">%quotes</span><span class="p">{&#34;</span><span class="s2">me</span><span class="p">&#34;}</span><span class="s2">.</span><span class="p">&#34;;</span>
 <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">and I said: </span><span class="nv">$quotes</span><span class="p">{</span>\&#34;<span class="n">me</span>\&#34;<span class="p">}</span><span class="s2">\n</span><span class="p">&#34;;</span>          <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">and I said: </span><span class="nv">%quotes</span><span class="p">&lt;</span><span class="s">me</span><span class="p">&gt;</span><span class="s2">.</span><span class="p">&#34;;</span>
 <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">What is ... </span><span class="p">&#34;;</span>                           <span class="nv">$result</span> <span class="o">=</span> <span class="nb">prompt</span> <span class="p">&#34;</span><span class="s2">What is ... </span><span class="p">&#34;;</span>
 <span class="nb">chomp</span><span class="p">(</span><span class="nv">$result</span> <span class="o">=</span> <span class="o">&lt;&gt;</span><span class="p">);</span>
</code></pre></div><ul>
<li>File IO</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#              Perl 5                                     Raku</span>
 <span class="nv">$content</span> <span class="o">=</span> <span class="nb">do</span> <span class="p">{</span> <span class="nb">local</span> <span class="nv">$/</span><span class="p">;</span>                       <span class="nv">$content</span> <span class="o">=</span> <span class="nb">slurp</span> <span class="p">&#34;</span><span class="s2">poetry.txt</span><span class="p">&#34;;</span>
    <span class="nb">open</span> <span class="k">my</span> <span class="nv">$FH</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">poetry.txt</span><span class="p">&#34;;</span> <span class="p">&lt;</span><span class="s">$FH</span><span class="p">&gt;</span>
 <span class="p">};</span>

<span class="nb">chomp</span><span class="p">(</span><span class="nv">@content</span> <span class="o">=</span> <span class="nb">do</span> <span class="p">{</span>                            <span class="nv">@content</span> <span class="o">=</span> <span class="nb">lines</span> <span class="p">&#34;</span><span class="s2">poetry.txt</span><span class="p">&#34;;</span>
    <span class="nb">open</span> <span class="k">my</span> <span class="nv">$FH</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">poetry.txt</span><span class="p">&#34;;</span> <span class="p">&lt;</span><span class="s">$FH</span><span class="p">&gt;</span>
<span class="p">});</span>
</code></pre></div><ul>
<li>Automatic multithreading</li>
</ul>
<p>Applying operations to junctions and arrays is now syntactically compact and readable.
Raku will create threads where appropriate to use multiple processors, cores or hyperthreading for high level language SIMD concurrent processing.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#              Perl 5                                     Raku</span>
 <span class="k">my</span> <span class="nv">$sum</span><span class="p">;</span>                                        <span class="k">my</span> <span class="nv">$sum</span> <span class="o">=</span> <span class="o">[+]</span> <span class="nv">@numbers</span><span class="p">;</span>
 <span class="nv">$sum</span> <span class="o">+=</span> <span class="nv">$_</span> <span class="k">for</span> <span class="nv">@numbers</span><span class="p">;</span>
 <span class="k">for</span> <span class="p">(</span><span class="mi">0</span> <span class="o">..</span> <span class="nv">$</span><span class="c1">#factor1) {                          @product = @factor1 &gt;&gt;*&lt;&lt; @factor2;</span>
   <span class="nv">$product</span><span class="o">[</span><span class="nv">$</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$factor1</span><span class="o">[</span><span class="nv">$</span><span class="o">]</span> <span class="o">*</span> <span class="nv">$factor2</span><span class="o">[</span><span class="nv">$_</span><span class="o">]</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div><p>The Perl 5 code is a simplification, of course Raku &ldquo;does the right thing&rdquo; when the arrays have different lengths.</p>
<ul>
<li>比较</li>
</ul>
<p>Here are junctions, then chained comparison operators.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#            Perl 5                                     Raku</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">or</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>        <span class="k">if</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">|</span> <span class="mi">4</span> <span class="o">|</span> <span class="mi">7</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">if</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;</span> <span class="nv">$a</span> <span class="ow">and</span> <span class="nv">$a</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                   <span class="k">if</span> <span class="mi">4</span> <span class="o">&lt;</span> <span class="nv">$a</span> <span class="o">&lt;</span> <span class="mi">12</span>    <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">if</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;</span> <span class="nv">$a</span> <span class="ow">and</span> <span class="nv">$a</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                  <span class="k">if</span> <span class="nv">$a</span> <span class="o">~~</span> <span class="mi">4</span><span class="o">^..</span><span class="mi">12</span>   <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="nv">$a</span> <span class="o">=</span> <span class="nb">defined</span> <span class="nv">$b</span> <span class="o">?</span> <span class="nv">$b</span> <span class="o">:</span> <span class="nv">$c</span><span class="p">;</span>                      <span class="nv">$a</span> <span class="o">=</span> <span class="nv">$b</span> <span class="o">//</span> <span class="nv">$c</span><span class="p">;</span>
</code></pre></div><p>The defined-OR operator eases lot of cases where Perl 5 newbies could fall into traps.</p>
<ul>
<li>Case 结构</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">  <span class="c1">#            Perl 5                                      Raku</span>
                                                     <span class="k">given</span> <span class="nv">$a</span> <span class="p">{</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="p">}}</span>                      <span class="k">when</span> <span class="mi">2</span> <span class="o">|</span> <span class="mi">5</span>  <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">elsif</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">==</span> <span class="mi">6</span> <span class="ow">or</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">7</span> <span class="ow">or</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">8</span> <span class="ow">or</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{}</span>   <span class="k">when</span> <span class="mi">6</span> <span class="o">..</span> <span class="mi">9</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">elsif</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">=~</span> <span class="o">/</span><span class="n">g</span><span class="o">/</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                               <span class="k">when</span> <span class="p">&#39;</span><span class="s1">g</span><span class="p">&#39;</span>    <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">else</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                                            <span class="k">default</span>     <span class="p">{</span><span class="o">...</span><span class="p">}</span>
                                                     <span class="p">}</span>
</code></pre></div><p>That new construct (backported to 5.10) is clear to read, very versatile and when used in combination with junctions, becomes even clearer.</p>
<ul>
<li>强大的循环</li>
</ul>
<p>List iteration via for is now much more versatile.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#            Perl 5                                     Raku</span>
 <span class="k">for</span> <span class="k">my</span> <span class="nv">$i</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">15</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                         <span class="k">for</span> <span class="o">^</span><span class="mi">16</span> <span class="k">-&gt;</span> <span class="nv">$i</span>        <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">for</span> <span class="p">(</span><span class="k">my</span> <span class="nv">$i</span><span class="o">=</span><span class="mi">15</span><span class="p">;</span> <span class="nv">$i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span> <span class="nv">$i-2</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                <span class="k">for</span> <span class="mi">15</span><span class="o">,*-</span><span class="mi">2</span><span class="o">...</span><span class="mi">1</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">for</span> <span class="k">my</span> <span class="nv">$key</span> <span class="p">(</span><span class="nb">keys</span> <span class="nv">%hash</span><span class="p">)</span> <span class="p">{</span>                      <span class="k">for</span> <span class="nv">%hash</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$key</span><span class="o">,</span> <span class="nv">$value</span> <span class="p">{</span>
   <span class="nb">print</span> <span class="p">&#34;</span><span class="nv">$key</span><span class="s2"> =&gt; </span><span class="nv">$hash</span><span class="p">{</span><span class="nv">$key</span><span class="p">}</span><span class="s2">\n</span><span class="p">&#34;;</span> <span class="o">...</span>              <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$key</span><span class="s2"> =&gt; </span><span class="nv">$value</span><span class="p">&#34;;</span> <span class="o">...</span>
 <span class="k">for</span> <span class="k">my</span> <span class="nv">$i</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="nv">$</span><span class="c1">#a) {                            for zip(@a; @b; @c) -&gt; $a, $b, $c {...}</span>
   <span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="nv">@a</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="nv">@b</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="nv">@c</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span><span class="p">;</span> <span class="o">...</span>
</code></pre></div><ul>
<li>子例程中的具名参数</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#            Perl 5                                     Raku</span>
 <span class="k">sub</span> <span class="nf">routine</span> <span class="p">{</span>                                   <span class="k">sub</span> <span class="nf">routine</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="o">,</span> <span class="o">*</span><span class="nv">@rest</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
   <span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">@rest</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div><ul>
<li>Objects with auto generated new and getters and setters</li>
</ul>
<p>Simple Object creation is now as easy as it gets.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#              Perl 5                                     Raku</span>
 <span class="nb">package</span> <span class="nn">Heart::Gold</span><span class="p">;</span>                            <span class="k">class</span> <span class="nc">Heart::Gold</span> <span class="p">{</span>
                                                   <span class="k">has</span> <span class="nv">$.speed</span><span class="p">;</span>
 <span class="k">sub</span> <span class="nb">new</span> <span class="p">{</span>                                         <span class="k">method</span> <span class="nf">stop</span> <span class="p">{</span> <span class="nv">$.speed</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">}</span>
   <span class="nb">bless</span> <span class="p">{</span><span class="s">speed</span> <span class="o">=&gt;</span> <span class="mi">0</span> <span class="p">}</span>, <span class="nb">shift</span><span class="p">;</span>                   <span class="p">}</span>  
 <span class="p">}</span>
                                                 <span class="k">my</span> <span class="n">Heart::Gold</span> <span class="nv">$hg1</span> <span class="o">.=</span> <span class="nb">new</span><span class="p">;</span>
 <span class="k">sub</span> <span class="nf">speed</span> <span class="p">{</span>                                     <span class="nv">$hg1</span><span class="o">.</span><span class="nf">speed</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">$self</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>                             <span class="k">my</span> <span class="nv">$hg2</span> <span class="o">=</span> <span class="nv">$hg1</span><span class="o">.</span><span class="nb">clone</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">$speed</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="nb">defined</span> <span class="nv">$speed</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$self-</span><span class="o">&gt;</span><span class="p">{</span><span class="n">speed</span><span class="p">}</span> <span class="o">=</span> <span class="nv">$speed</span> <span class="p">}</span>
   <span class="k">else</span> <span class="p">{</span> <span class="nv">$self-</span><span class="o">&gt;</span><span class="p">{</span><span class="n">speed</span><span class="p">}</span> <span class="p">}</span>
 <span class="p">}</span>

 <span class="k">sub</span> <span class="nf">stop</span> <span class="p">{</span>
   <span class="k">my</span> <span class="nv">$self</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
   <span class="nv">$self-</span><span class="o">&gt;</span><span class="p">{</span><span class="n">speed</span><span class="p">}</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div><h2 id="raku-variable">Raku Variable</h2>
<ul>
<li>Variable Types</li>
</ul>
<p>Raku (as Perl 5) knows 3 basic types of variables: Scalars (single values), Arrays (ordered and indexed lists of several values) and Hashes (2 column table, with ID and associated value pairs). They can be easily distinguished, because in front of their name is a special character called sigil (latin for sign). It&rsquo;s the $ (similar to S) for Scalars, @ (like an a) for Arrays and a % (kv pair icon) for a Hash. They are now invariant (not changing), which means for instance, an array vaiable starts always with an @, even if you just want a slice of the content.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$scalar</span>
<span class="nv">@array</span>
<span class="nv">@array</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>              <span class="c1"># $array[1]   in Perl 5</span>
<span class="nv">@array</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>            <span class="c1"># @array[1,2] in Perl 5</span>
<span class="nv">%hash</span>
<span class="nv">%hash</span><span class="p">{&#39;</span><span class="s1">ba</span><span class="p">&#39;}</span>            <span class="c1"># $hash{&#39;ba&#39;} in Perl 5</span>
<span class="nv">%hash</span><span class="p">{&#39;</span><span class="s1">ba</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">da</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">bim</span><span class="p">&#39;}</span> <span class="c1"># @hash{&#39;ba&#39;,&#39;da&#39;,&#39;bim&#39;} in Perl 5</span>
</code></pre></div><p>The sigils also mark distinct namespaces, meaning: in one lexical scope you can have 3 different variables named $stuff, @stuff and %stuff. These sigils can also be used as an operator to enforce a context in which the following data will be seen.</p>
<p>The fourth namespace is for subroutines and similar, even if you don&rsquo;t usually think of them as variables. It&rsquo;s sigil &amp; is used to refer to subroutines without calling them.</p>
<p>All special namespaces from Perl 5 (often marked with special syntax), like tokens (<strong>PACKAGE</strong>), formats, file or dir handles, or builtins are now regular variables or routines.</p>
<p>Because all variables contain objects, they have methods. In fact, all operators, including square or curly bracket subscripts, are just methods of an object with a fancy name.</p>
<p>The primary sigil can be followed by a secondary sigil, called a twigil, which indicates a special scope for that variable.</p>
<h3 id="scalar">Scalar</h3>
<p>This type stores one value, usually a reference to something: a value of a data type, a code object, an object or a compound of values like a pair, junction, array, hash or capture. The scalar context is now called item context, hence the scalar instruction from Perl 5 was renamed to item.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$CHAPTER</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>              <span class="c1"># first comment!</span>
<span class="nv">$bin</span> <span class="o">=</span> <span class="mb">0b11</span><span class="p">;</span>               <span class="c1"># same value in binary format</span>
<span class="nv">$pi</span> <span class="o">=</span> <span class="mf">3.14159_26535_89793</span><span class="p">;</span> <span class="c1"># the underscores just ease reading</span>
<span class="nv">$float</span> <span class="o">=</span> <span class="mf">6.02e-23</span><span class="p">;</span>         <span class="c1"># floating number in scientific notation</span>
<span class="nv">$text</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Welcome all!</span><span class="p">&#39;;</span>    <span class="c1"># single quoted string</span>

<span class="c1"># double quoted string, does eval $pi to it&#39;s content</span>
<span class="nv">$text</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2"> What is </span><span class="nv">$pi</span><span class="s2">?</span><span class="p">&#34;;</span>
<span class="nv">$text</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">&#39;EOT&#39;;</span><span class="s">         # heredoc string
</span><span class="s">
</span><span class="s">    handy for multiline text
</span><span class="s">    like HTML templates or email
</span><span class="s">
</span><span class="s"></span><span class="p">EOT</span>
<span class="nv">$handle</span> <span class="o">=</span> <span class="nb">open</span> <span class="nv">$file_name</span><span class="p">;</span> <span class="c1"># file handle</span>
<span class="c1"># an object from a class with a nested namespace</span>
<span class="nv">$object</span> <span class="o">=</span> <span class="n">Class::Name</span><span class="o">.</span><span class="nb">new</span><span class="p">();</span>
<span class="nv">$condition</span> <span class="o">=</span> <span class="mi">3</span><span class="o">|</span><span class="mi">5</span><span class="o">|</span><span class="mi">7</span><span class="p">;</span>                <span class="c1"># a junction, a logical conjunction of values</span>
<span class="nv">$arrayref</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">21</span><span class="o">]</span><span class="p">;</span> <span class="c1"># an array stored as a single item</span>

<span class="c1"># a hash stored as a single item</span>
<span class="nv">$hashref</span> <span class="o">=</span> <span class="p">{&#39;</span><span class="s1">audreyt</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">pugs</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">pm</span><span class="p">&#39;</span>      <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">pct</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">damian</span><span class="p">&#39;</span>  <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">larrys evil henchman</span><span class="p">&#39;};</span>
<span class="c1"># pointing to a callable</span>
<span class="nv">$coderef</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{</span> <span class="nf">do_something_completely_diffenent</span><span class="p">(</span><span class="nv">@_</span><span class="p">)</span> <span class="p">};</span>
</code></pre></div><p>(For info on some of those terms: comment, binary format, the underscores ease reading, scientific notation, single-quoted string, double-quoted string, heredoc string, file handle, class, junction, list of values, hash, callable.)</p>
<p>Unlike Perl 5, references are automatically dereferenced to a fitting context. So you could use these $arrayrefs and $hashrefs similarly to an array or hash, making $ the universal variable prefix, pretty much like in PHP. The primary difference is that $ prefixed lists are not flattened in lists.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">for</span> <span class="nv">$a</span> <span class="p">{</span> <span class="p">}</span>          <span class="c1"># just one iteration</span>
<span class="k">for</span> <span class="nv">@a</span> <span class="p">{</span> <span class="p">}</span>          <span class="c1"># three iterations</span>
</code></pre></div><h3 id="scalar-methods">Scalar Methods</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$chapter</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">undefine</span> <span class="nv">$chapter</span><span class="p">;</span>
<span class="nb">defined</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1"># false, returns 0</span>
</code></pre></div><ul>
<li>Array</li>
</ul>
<p>An array is an ordered and indexed list of scalars. If not specified otherwise, they can be changed, expanded and shortened anytime and used as a list, stack, queue and much more. As in Haskell, lists are processed lazily, which means: the compiler looks only at the part it currently needs. This way Raku can handle infinite lists or do computation on lists that have not been computed yet. The lazy command enforces this and the eager command forces all values to be computed.</p>
<p>The list context is forced with a @() operator or list() command. That&rsquo;s not autoflattening like in Perl 5 (automatically convert a List of Lists into one List). If you still want that, say flat(). Or say lol() to explicitly prevent autoflattening.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@primes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">19</span><span class="o">,</span><span class="mi">23</span><span class="p">);</span> <span class="c1"># an array gets filled like in Perl 5</span>
<span class="nv">@primes</span> <span class="o">=</span>  <span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">19</span><span class="o">,</span><span class="mi">23</span> <span class="p">;</span> <span class="c1"># same thing, since unlike P5 round braces just do group</span>
<span class="nv">@primes</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">2 3 5 7 11 13 17 19 23</span><span class="p">&gt;;</span> <span class="c1"># ditto, &lt;&gt; is the new qw()</span>
<span class="nv">$primes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">19</span><span class="o">,</span><span class="mi">23</span><span class="p">);</span> <span class="c1"># same array object just sits in $primes, $primes[0] is 2</span>
<span class="nv">$primes</span> <span class="o">=</span> <span class="nb">item</span> <span class="nv">@primes</span><span class="p">;</span>             <span class="c1"># same thing, more explicit</span>
<span class="nv">$primes</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span><span class="p">;</span>                       <span class="c1"># just 2, first element of the Parcel</span>
<span class="nv">@primes</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>                        <span class="c1"># array with one element</span>
<span class="nv">@primes</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">19</span><span class="o">,</span><span class="mi">23</span><span class="o">]</span><span class="p">;</span> <span class="c1"># array with one element (List of Lists - LoL)</span>
<span class="nv">@dev</span>    <span class="o">=</span> <span class="p">{&#39;</span><span class="s1">dan</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">parrot</span><span class="p">&#39;};</span>      <span class="c1"># array with one element (a Hash)</span>
<span class="nv">@data</span>   <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="o">],[</span><span class="mi">6</span><span class="o">..</span><span class="mi">10</span><span class="o">],[</span><span class="mi">11</span><span class="o">..</span><span class="mi">15</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># Array of Arrays (LoL)</span>
<span class="nv">@list</span>   <span class="o">=</span> <span class="n">lol</span> <span class="nv">@data</span><span class="p">;</span>                <span class="c1"># no change</span>
<span class="nv">@list</span>   <span class="o">=</span> <span class="nb">flat</span> <span class="nv">@data</span><span class="p">;</span>               <span class="c1"># returns 1..15</span>
</code></pre></div><ul>
<li>Array Slices</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@primes</span>                       <span class="c1"># all values as list</span>
<span class="nv">@primes</span><span class="o">.</span><span class="nb">values</span>                <span class="c1"># same thing</span>
<span class="nv">@primes</span><span class="o">.</span><span class="nb">keys</span>                  <span class="c1"># list of all indices</span>
<span class="p">&#34;</span><span class="nv">@primes</span><span class="o">[]</span><span class="p">&#34;</span>                   <span class="c1"># insert all values in a string, uses [] to distinguish from mail adresses</span>
<span class="nv">$prime</span> <span class="o">=</span> <span class="nv">@primes</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>          <span class="c1"># get the first prime</span>
<span class="nv">$prime</span> <span class="o">=</span> <span class="nv">@primes</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>        <span class="c1"># get the last one</span>
<span class="nv">@some</span> <span class="o">=</span> <span class="nv">@primes</span><span class="o">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">5</span><span class="o">]</span><span class="p">;</span>        <span class="c1"># get several</span>
<span class="nv">$cell</span> <span class="o">=</span> <span class="nv">@data</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>          <span class="c1"># get 8, third value of second value (list)</span>
<span class="nv">$cell</span> <span class="o">=</span> <span class="nv">@data</span><span class="o">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>           <span class="c1"># same thing, shorten syntax</span>
<span class="nv">@numbers</span> <span class="o">=</span> <span class="nv">@data</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>          <span class="c1"># get a copy of the second subarray (6..10)</span>
<span class="nv">@copy</span> <span class="o">=</span> <span class="nv">@data</span><span class="p">;</span>                <span class="c1"># shallow copy of the array</span>
</code></pre></div><ul>
<li>Array Methods</li>
</ul>
<p>Some of the more important things you can do with lists. All the methods can also used like ops in &ldquo;elems @array;&rdquo;</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">?</span> <span class="nv">@array</span><span class="p">;</span>              <span class="c1"># boolean context, Bool::True if array has any value in it, even if it&#39;s a 0</span>
<span class="o">+</span> <span class="nv">@array</span><span class="p">;</span>              <span class="c1"># numeric context, number of elements (like in Perl 5 scalar @a)</span>
<span class="o">~</span> <span class="nv">@array</span><span class="p">;</span>              <span class="c1"># string context, you get content of all cells, stringified and joined, same as &#34;@primes[]&#34;</span>

<span class="nv">@array</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>          <span class="c1"># same as + @array</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">end</span><span class="p">;</span>            <span class="c1"># number of the last element, equal to @array.elems-1</span>
<span class="nv">@array</span><span class="o">.</span><span class="nf">cat</span><span class="p">;</span>            <span class="c1"># same ~ @array</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;&#39;);</span>       <span class="c1"># also same result, you can put another string as parameter that gets between all values</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">unshift</span><span class="p">;</span>        <span class="c1"># prepend one value to the array</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>          <span class="c1"># remove the first value and return it</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">push</span><span class="p">;</span>           <span class="c1"># add one value on the end</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">pop</span><span class="p">;</span>            <span class="c1"># remove one value from the end and return it</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">splice</span><span class="p">(</span><span class="nv">$pos</span><span class="o">,</span><span class="nv">$n</span><span class="p">);</span><span class="c1"># starting at $pos remove $n values and replace them with values that follow those two</span>
</code></pre></div><ul>
<li>parameters</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@array</span><span class="o">.</span><span class="nb">delete</span><span class="p">(</span><span class="nv">@ind</span><span class="p">);</span>   <span class="c1"># delete all cells with indices in @ind</span>
<span class="nv">@array</span><span class="o">.</span><span class="nf">exists</span><span class="p">(</span><span class="nv">@ind</span><span class="p">);</span>   <span class="c1"># Bool::True if all indices of @ind have a value (can be 0 or &#39;&#39;)</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="o">[</span><span class="nv">$n</span><span class="o">]</span><span class="p">);</span>     <span class="c1"># return $n (default is 1) randomly selected values, without duplication</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="o">[</span><span class="nv">$n</span><span class="o">]</span><span class="p">);</span>     <span class="c1"># return $n (default is 1) randomly selected values, duplication possible (like roll dice)</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>        <span class="c1"># all elements in reversed order</span>
<span class="c1"># returns a list where $n times first item is taken to last</span>
<span class="c1"># position if $n is positive, if negative the other way around</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="nv">$n</span><span class="p">);</span>

<span class="nv">@array</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="nv">$coderef</span><span class="p">);</span> <span class="c1"># returns a list sorted by a user-defined criteria, default is alphanumerical sorting</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">min</span><span class="p">;</span>            <span class="c1"># numerical smallest value of that array</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">max</span><span class="p">;</span>            <span class="c1"># numerical largest value of that array</span>
<span class="nv">$a</span><span class="o">,</span><span class="nv">$b</span><span class="o">=</span> <span class="nv">@array</span><span class="o">.</span><span class="nb">minmax</span><span class="p">;</span>  <span class="c1"># both at once, like in .sort,  .min, or .max, a sorting algorithm can be provided</span>

<span class="nv">@array</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="nv">$coderef</span><span class="p">);</span>  <span class="c1"># high oder map function, runs $coderef with every value as $_ and returns the list or results</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">classify</span><span class="p">(</span><span class="nv">$cr</span><span class="p">);</span>  <span class="c1"># kind of map, but creates a hash, where keys are the results of $cr and values are from @array</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">categorize</span><span class="p">(</span><span class="nv">$cr</span><span class="p">);</span><span class="c1"># kind of classify, but closure can have no (Nil) or several results, so a key can have a list of values</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span><span class="nv">$_</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">});</span>   <span class="c1"># high order grep, returns only these elements that pass a condition ($cr returns something positive)</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">first</span><span class="p">(</span><span class="nv">$coder</span><span class="p">);</span>  <span class="c1"># kind of grep, return just the first matching value</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">zip</span><span class="p">;</span>            <span class="c1"># join arrays by picking first element left successively from here and then there</span>
<span class="n">There</span> <span class="k">is</span> <span class="nc">even</span> <span class="n">a</span> <span class="n">whole</span> <span class="k">class</span> <span class="k">of</span> <span class="nc">metaoperators</span> <span class="n">that</span> <span class="n">work</span> <span class="n">upon</span> <span class="n">lists</span><span class="o">.</span>
</code></pre></div><ul>
<li>Hash</li>
</ul>
<p>In Raku a Hash is an unordered list of Pairs. A Pair is a single key =&gt; value association and appears in many places of the language syntax. A hash allows lookup of values by key using {} or &lt;&gt; syntax.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%dev</span> <span class="o">=</span>  <span class="p">&#39;</span><span class="s1">pugs</span><span class="p">&#39;</span><span class="o">=&gt;</span><span class="p">&#39;</span><span class="s1">audreyt</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">pct</span><span class="p">&#39;</span><span class="o">=&gt;</span><span class="p">&#39;</span><span class="s1">pm</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">STD</span><span class="p">&#34;</span><span class="o">=&gt;</span><span class="p">&#39;</span><span class="s1">larry</span><span class="p">&#39;;</span>
<span class="nv">%dev</span> <span class="o">=</span> <span class="p">:</span><span class="s">rakudo</span><span class="p">(&#39;</span><span class="s1">jnthn</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">testsuite</span><span class="p">(&#39;</span><span class="s1">moritz</span><span class="p">&#39;);</span>            <span class="c1"># adverb (pair) syntax works as well</span>
<span class="nv">%dev</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">audreyt</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">pugs</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">pm</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">pct</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">larry</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">STD</span><span class="p">&#34;);</span>  <span class="c1"># lists get autoconverted in hash context</span>
<span class="nv">%compiler</span> <span class="o">=</span> <span class="s">Parrot</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="s">Rakudo</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">jnthn</span><span class="p">&#39;}</span>, <span class="s">SMOP</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="s">Mildew</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">ruoso</span><span class="p">&#39;};</span>       <span class="c1"># hash of hashes (HoH)</span>
</code></pre></div><ul>
<li>Hash Slices</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$value</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">{&#39;</span><span class="s1">key</span><span class="p">&#39;};</span>      <span class="c1"># just give me the value related to that key, like in P5</span>
<span class="nv">$value</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">&lt;</span><span class="s">pm</span><span class="p">&gt;;</span>         <span class="c1"># &lt;&gt; autoquotes like qw() in P5</span>
<span class="nv">$value</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">&lt;&lt;</span><span class="nv">$name</span><span class="p">&gt;&gt;;</span>    <span class="c1"># same thing, just with eval</span>
<span class="nv">@values</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">{&#39;</span><span class="s1">key1</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">key2</span><span class="p">&#39;};</span>
<span class="nv">@values</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">&lt;</span><span class="s">key1 key2</span><span class="p">&gt;;</span>
<span class="nv">@values</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">&lt;&lt;</span><span class="s2">key1 key2 </span><span class="nv">$key3</span><span class="p">&gt;&gt;;</span>
<span class="nv">%compiler</span><span class="p">&lt;</span><span class="s">Parrot</span><span class="p">&gt;&lt;</span><span class="s">Rakudo</span><span class="p">&gt;;</span> <span class="c1"># value in a HoH, returns &#39;jnthn&#39;</span>
<span class="nv">%compiler</span><span class="p">&lt;</span><span class="s">SMOP</span><span class="p">&gt;;</span>           <span class="c1"># returns the Pair: Mildew =&gt; &#39;ruoso&#39;</span>

<span class="nv">%dev</span>   <span class="p">{&#39;</span><span class="s1">audrey</span><span class="p">&#39;};</span>         <span class="c1"># error, spaces between varname and braces (postcircumfix operator) are no longer allowed</span>
<span class="nv">%dev</span>\  <span class="p">{&#39;</span><span class="s1">allison</span><span class="p">&#39;};</span>        <span class="c1"># works, quote the space</span>
<span class="nv">%dev</span>   <span class="o">.</span><span class="p">&lt;</span><span class="s">dukeleto</span><span class="p">&gt;;</span>        <span class="c1"># error</span>
<span class="nv">%dev</span>\ <span class="o">.</span><span class="p">{&#39;</span><span class="s1">patrick</span><span class="p">&#39;};</span>        <span class="c1"># works too, &#34;long dot style&#34;, because it&#39;s an object in truth</span>
</code></pre></div><ul>
<li>Hash Methods</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">?</span> <span class="nv">%dev</span>                     <span class="c1"># bool context, true if hash has any pairs</span>
<span class="o">+</span> <span class="nv">%dev</span>                     <span class="c1"># numeric context, returns number of pairs(keys)</span>
<span class="o">~</span> <span class="nv">%dev</span>                     <span class="c1"># string context, nicely formatted 2 column table using \t and \n</span>

<span class="nv">$table</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">;</span>             <span class="c1"># same as ~ %dev</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                  <span class="c1"># stringified, but only $key and $value are separated by \t</span>
<span class="nv">@pairs</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">;</span>             <span class="c1"># list of all containing pairs</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">pairs</span>                 <span class="c1"># same thing in all context</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">elems</span>                 <span class="c1"># same as + %dev or + %dev.pairs</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">keys</span>                  <span class="c1"># returns a list of all keys</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">values</span>                <span class="c1"># list of all values</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">kv</span>                    <span class="c1"># flat list with key1, value1, key 2 ...</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">invert</span>                <span class="c1"># reverse all key =&gt; value relations</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">push</span> <span class="p">(</span><span class="nv">@pairs</span><span class="p">)</span>         <span class="c1"># inserts a list of pairs, if a key is already present in %dev, both values gets added to an array</span>
</code></pre></div><ul>
<li>Callable</li>
</ul>
<p>Internally subroutines, methods and alike are variables with the sigil &amp; and stored in a fourth namespace. Unlike Perl 5, all subroutines can be overwritten or augmented with user defined routines. Of course scalars can also contain routines.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">&amp;function</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span>         <span class="c1"># store subroutine in callable namespace</span>
<span class="nf">function</span><span class="p">();</span>                      <span class="c1"># call/run it</span>

<span class="nv">$coderef</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span>          <span class="c1"># store it in a scalar</span>
<span class="nv">$coderef</span><span class="p">(</span><span class="nv">$several</span><span class="o">,</span> <span class="nv">$parameter</span><span class="p">);</span>  <span class="c1"># run that code</span>
</code></pre></div><ul>
<li>Data Types</li>
</ul>
<p>In contrast to variable types (container types) every value has a type too. These are organized internally as classes or roles and can be categorized into 3 piles: the undefined, immutable, and the mutable types.</p>
<p>You can assign one of these types to scalar, array, or hash variables, which enforces the contents to be that type.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Int</span> <span class="nv">$a</span><span class="p">;</span>
<span class="k">my</span> <span class="nb">Int</span> <span class="nv">@a</span><span class="p">;</span>  <span class="c1"># array of Int</span>
</code></pre></div><ul>
<li>Pair</li>
</ul>
<p>Pairs are new and their syntax is used nearly everywhere in the language where there is an association between a name and a value.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$pair</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">jakub</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">helena</span><span class="p">&#39;;</span>  <span class="c1"># &#34;=&gt;&#34; is the pair constructor</span>
<span class="nv">$pair</span> <span class="o">=</span> <span class="p">:</span><span class="s">jakub</span><span class="p">(&#39;</span><span class="s1">helena</span><span class="p">&#39;);</span>     <span class="c1"># same in adverbial notation</span>
<span class="nv">$pair</span> <span class="o">=</span> <span class="p">:</span><span class="s">jakub</span><span class="p">&lt;</span><span class="s">helena</span><span class="p">&gt;;</span>       <span class="c1"># same using &lt;&gt;, the new qw()</span>
<span class="nv">$pair</span><span class="o">.</span><span class="nb">key</span>                     <span class="c1"># returns &#39;jakub&#39;</span>
<span class="nv">$pair</span><span class="o">.</span><span class="nb">value</span>                   <span class="c1"># returns &#39;helena&#39;</span>
<span class="nv">$pair</span><span class="o">.</span><span class="nb">isa</span><span class="p">(</span><span class="nb">Pair</span><span class="p">)</span>               <span class="c1"># Bool::True</span>
</code></pre></div><ul>
<li>Capture</li>
</ul>
<p>Captures are also a new type, which holds the parameters a routine gets. Because Perl now knows both positional and named parameters, it is a mixture of a list and array.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$cap</span> <span class="o">=</span> \<span class="p">(</span><span class="nv">@a</span><span class="o">,</span><span class="nv">$s</span><span class="o">,</span><span class="nv">%h</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">=&gt;</span><span class="mi">3</span><span class="p">);</span>    <span class="c1"># creating a capture, &#34;\&#34; was free since there are no references anymore</span>
<span class="o">|</span><span class="nv">$cap</span>                         <span class="c1"># flatten into argument list (without |, it will pass it as a single value)</span>
<span class="o">||</span><span class="nv">$cap</span>                        <span class="c1"># flatten into semicolon list (meant for variadic functions that take list of lists)</span>
</code></pre></div><p>One important difference between a capture and a compound structure of lists and hashes: While assignments with = will copy the complete content of the named variables, this is not so in the case of a capture. When I change sinthelastexample, thecontentofcap changes too, because when parameters to a routine are variables, they are also interpolated in the moment the routine is called, not when it&rsquo;s defined.</p>
<ul>
<li>
<p>Assignment and Binding</p>
</li>
<li>
<p>Assignment</p>
</li>
</ul>
<p>As rightfully expected, assignments are done with the equal sign. But unlike Perl 5 you always get a copy of the right side data assigned to the left, no matter how nested the data structure was (lists of lists eg). You never get in Raku a reference with =. The only exception may be seen captures.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@original</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$copy</span> <span class="o">=</span> <span class="nv">@original</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span> <span class="c1"># $copy points to [1,2]</span>
<span class="nv">@original</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">fresh stuff</span><span class="p">&#39;;</span> <span class="c1"># $copy[0] holds still 1</span>
</code></pre></div><ul>
<li>Binding</li>
</ul>
<p>Since every variable in Raku is a reference, programmers can use binding to get 2 variables that point to the same memory location.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$original</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nv">$original</span> <span class="o">:=</span> <span class="nv">$mirror</span><span class="p">;</span>       <span class="c1"># normal binding, done on runtime</span>
<span class="nv">$original</span> <span class="o">::=</span> <span class="nv">$mirror</span><span class="p">;</span>      <span class="c1"># same thing, but done during compile time</span>
<span class="nv">$original</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$mirror</span><span class="p">;</span>                <span class="c1"># prints 3</span>
<span class="nv">$original</span> <span class="o">=:=</span> <span class="nv">$mirror</span>       <span class="c1"># true, because they&#39;re bound together</span>
<span class="nv">$original</span> <span class="o">===</span> <span class="nv">$mirror</span>       <span class="c1"># also true, because content and type are equal</span>
</code></pre></div><ul>
<li>FP oriented</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">balanced</span><span class="p">(</span><span class="nv">$s</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">.</span><span class="nb">none</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="o">.[*-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">given</span> <span class="o">[</span>\<span class="o">+]</span> <span class="p">&#39;</span><span class="s1">\\</span><span class="p">&#39;</span> <span class="o">«</span><span class="ow">leg</span><span class="o">«</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">comb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="nb">prompt</span> <span class="p">&#34;</span><span class="s2">Number of bracket pairs: </span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">[ ]</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="nv">$n</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$s</span><span class="s2"> </span><span class="p">{</span> <span class="nf">balanced</span><span class="p">(</span><span class="nv">$s</span><span class="p">)</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2">is</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="s2">is not</span><span class="p">&#34;</span> <span class="p">}</span><span class="s2"> well-balanced</span><span class="p">&#34;</span>
</code></pre></div><ul>
<li>String munging</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">balanced</span><span class="p">(</span><span class="nv">$_</span> <span class="k">is</span> <span class="nb">copy</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">while</span> <span class="k">s</span><span class="p">:</span><span class="na">g</span><span class="p">/&#39;</span><span class="s1">[]</span><span class="p">&#39;//;</span>
    <span class="nv">$_</span> <span class="ow">eq</span> <span class="p">&#39;&#39;;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="nb">prompt</span> <span class="p">&#34;</span><span class="s2">Number of bracket pairs: </span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">[ ]</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="nv">$n</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$s</span><span class="s2"> is</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1"> not</span><span class="p">&#39;</span> <span class="ow">xx</span> <span class="nb">not</span> <span class="nf">balanced</span><span class="p">(</span><span class="nv">$s</span><span class="p">))</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2"> well-balanced</span><span class="p">&#34;;</span>
</code></pre></div><ul>
<li>Parsing with a grammar</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">BalBrack</span> <span class="p">{</span> <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">TOP</span><span class="p">&gt;</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span> <span class="p">}</span>

<span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="nb">prompt</span> <span class="p">&#34;</span><span class="s2">Number of bracket pairs: </span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">[</span><span class="p">&#39;</span> <span class="ow">xx</span> <span class="nv">$n</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span> <span class="ow">xx</span> <span class="nv">$n</span><span class="p">)</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$s</span><span class="s2"> </span><span class="p">{</span> <span class="n">BalBrack</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$s</span><span class="p">)</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2">is</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="s2">is not</span><span class="p">&#34;</span> <span class="p">}</span><span class="s2"> well-balanced</span><span class="p">&#34;;</span>
</code></pre></div><ul>
<li>凯撒加密</li>
</ul>
<p>实现一个凯撒加密， 编码和解码都要有</p>
<p>key 是一个 1 到 25 之间的整数</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@alpha</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">A</span><span class="p">&#39;</span> <span class="o">..</span> <span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;;</span>

<span class="k">sub</span> <span class="nf">encrypt</span> <span class="p">(</span> <span class="nv">$key</span> <span class="k">where</span> <span class="mi">1</span><span class="o">..</span><span class="mi">25</span><span class="o">,</span> <span class="nv">$plaintext</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nv">$plaintext</span><span class="o">.</span><span class="nb">trans</span><span class="p">(</span> <span class="nv">@alpha</span> <span class="ow">Z</span><span class="o">=&gt;</span> <span class="nv">@alpha</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="nv">$key</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">decrypt</span> <span class="p">(</span> <span class="nv">$key</span> <span class="k">where</span> <span class="mi">1</span><span class="o">..</span><span class="mi">25</span><span class="o">,</span> <span class="nv">$cyphertext</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nv">$cyphertext</span><span class="o">.</span><span class="nb">trans</span><span class="p">(</span> <span class="nv">@alpha</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="nv">$key</span><span class="p">)</span> <span class="ow">Z</span><span class="o">=&gt;</span> <span class="nv">@alpha</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$original</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">THE FIVE BOXING WIZARDS JUMP QUICKLY</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$en</span> <span class="o">=</span> <span class="nf">encrypt</span><span class="p">(</span> <span class="mi">13</span><span class="o">,</span> <span class="nv">$original</span> <span class="p">);</span>
<span class="k">my</span> <span class="nv">$de</span> <span class="o">=</span> <span class="nf">decrypt</span><span class="p">(</span> <span class="mi">13</span><span class="o">,</span> <span class="nv">$en</span> <span class="p">);</span>

<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">$original</span><span class="o">,</span> <span class="nv">$en</span><span class="o">,</span> <span class="nv">$de</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">OK</span><span class="p">&#39;</span> <span class="k">if</span> <span class="nv">$original</span> <span class="ow">eq</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">map</span> <span class="p">{</span> <span class="o">.&amp;</span><span class="nf">decrypt</span><span class="p">(</span><span class="o">.&amp;</span><span class="nf">encrypt</span><span class="p">(</span><span class="nv">$original</span><span class="p">))</span> <span class="p">}</span><span class="o">,</span> <span class="mi">1</span><span class="o">..</span><span class="mi">25</span> <span class="p">);</span>
</code></pre></div><pre><code>Output:
THE FIVE BOXING WIZARDS JUMP QUICKLY
GUR SVIR OBKVAT JVMNEQF WHZC DHVPXYL
THE FIVE BOXING WIZARDS JUMP QUICKLY
OK
</code></pre>
<ul>
<li>日期格式化</li>
</ul>
<p>使用 &ldquo;2007-11-10&rdquo; 和 &ldquo;Sunday, November 10, 2007&rdquo; 日期格式显式当前日期:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nb">DateTime</span><span class="o">:</span><span class="p">:</span><span class="s">Utils</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$dt</span> <span class="o">=</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">now</span><span class="p">;</span>

<span class="nb">say</span> <span class="nf">strftime</span><span class="p">(&#39;</span><span class="s1">%Y-%m-%d</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$dt</span><span class="p">);</span>
<span class="nb">say</span> <span class="nf">strftime</span><span class="p">(&#39;</span><span class="s1">%A, %B %d, %Y</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$dt</span><span class="p">);</span>
</code></pre></div><ul>
<li>阶乘</li>
</ul>
<p>n 的阶乘定义为 <code>n*(n-1)*(n-2)…*1</code>, 零的阶乘为1.</p>
<p>定义一个函数返回一个数字的阶乘。</p>
<ul>
<li>使用自定义后缀操作符</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">
<span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!</span><span class="p">&gt;(</span><span class="nv">$n</span> <span class="k">where</span> <span class="nv">$n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">[*]</span> <span class="mi">2</span><span class="o">..</span><span class="nv">$n</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="mi">5</span><span class="o">!</span>
</code></pre></div><ul>
<li>[*]</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="o">[</span>\<span class="o">*]</span> <span class="mi">1</span><span class="o">..*</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span><span class="p">;</span>
</code></pre></div><p>标量容器中存储的对象不会在 flattening 上下文中插值，即使那个对象是可迭代的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nv">@a</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span> <span class="c1"># 5次迭代</span>
</code></pre></div><p>输出:</p>
<pre><code>1
2
3
4
5
</code></pre><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="nv">@a</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nv">$s</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># 3次迭代</span>
</code></pre></div><p>输出:</p>
<pre><code>1
2
3 4 5
</code></pre><p>这里，<code>$s</code> 和 <code>@a</code> 指向同一个数组对象，但是标量容器的出现阻止 <code>$s</code> 被展开到 for 循环中。</p>
<p>.list 和 .flat 方法能被用于还原展开行为：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">list</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span>    <span class="c1"># 5次遍历</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nv">@</span><span class="p">(</span><span class="nv">$s</span><span class="p">)</span>   <span class="p">{</span> <span class="o">.</span><span class="nb">say</span>  <span class="p">}</span>   <span class="c1"># 5次遍历，@()会强制为列表上下文</span>
</code></pre></div><p>输出:</p>
<pre><code>1
2
3
4
5
</code></pre><p>相反，<code>.item</code> 方法和 <code>$()</code> 能用于防止插值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="nv">@a</span><span class="p">;</span>           <span class="c1"># @b 有5个元素</span>
<span class="k">my</span> <span class="nv">@c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="nv">@a</span><span class="o">.</span><span class="nb">item</span><span class="p">;</span>      <span class="c1"># @c 有3个元素</span>
<span class="k">my</span> <span class="nv">@c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="nv">$</span><span class="p">(</span><span class="nv">@a</span><span class="p">);</span>        <span class="c1"># 同上</span>

<span class="nb">say</span> <span class="o">+</span><span class="nv">@c</span><span class="p">;</span> <span class="c1"># 3</span>
</code></pre></div><ul>
<li>Feed operators</li>
</ul>
<p>feed 操作符是完全懒惰的，意味着在使用者要求任何元素之前不会执行任何操作。这就是</p>
<pre><code class="language-rraku" data-lang="rraku">my @a &lt;== grep { ... } &lt;== map { ... } &lt;== grep { ... } &lt;== 1, 2, 3
</code></pre><p>是完全懒惰的。</p>
<ul>
<li>Grammars</li>
</ul>
<p>文法是一种强大的工具, 用于拆解文本,并通常返回数据结构
例如, Raku 是使用 Raku 风格的文法解析和执行的.
对普通 Raku 用户来说,一个更实用的例子就是 JSON::Simple 模块, 这个模块能反序列化任何有效的 JSON 文件, 反序列化代码还写了不到 100 行, 简单,可扩展.</p>
<p>词法允许你组织正则, 就像类允许你组织普通代码的方法一样.</p>
<h2 id="命名正则">命名正则</h2>
<p>命名正则有特殊的语法, 与<strong>子例程</strong>的定义类似:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">number</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">[</span><span class="sr"> \</span><span class="ni">.</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">?</span><span class="sr"> </span><span class="p">}</span>
</code></pre></div><p>这个例子中, 我们必须使用 <strong>my</strong> 关键词指定这个正则是词法作用域的, 因为 <strong>命名正则</strong> 通常用在 词法中.
给正则命名后有利于在其他地方<code>复用</code>正则:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">32.51</span><span class="p">&#34;</span>    <span class="o">~~</span> <span class="nv">&amp;number</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">15 + 4.5</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">number</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">number</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/</span>
</code></pre></div><p>首先说下, 使用 <code>regex/token/rule</code> 定义了一个正则表达式后怎么去调用它。就像调用一个子例程那样, 使用 <code>&amp;</code> 符号:
<code>&amp;</code> 后面跟正则表达式的名字,  即 <code>&amp;regex_name</code>。</p>
<p>regex 不是命名正则仅有的标识符 &ndash; 实际上, 它用的不多. 大多数时候, 用的最多的是 <code>token</code> 和 <code>rule</code> 标识符. 它们都是<code>不能回溯</code>的, 这意味着正则引擎在匹配失败时不会备份和重试. 这通常是你想要的, 但不是对所有场合都合适:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">works-but-slow</span> <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">+</span><span class="sr"> q }
</span><span class="sr">my token fails-but-fast </span><span class="p">{</span> <span class="o">.+</span> <span class="n">q</span> <span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr"></span><span class="c1"># Tokens 不会沿原路返回, 这让它们更快地失败!
</span><span class="c1"></span><span class="sr">my </span><span class="nv">$s</span><span class="sr"> </span><span class="o">=</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">Tokens won\&#39;t backtrack, which makes them fail quicker!</span><span class="p">&#39;</span><span class="sr">;
</span><span class="sr">
</span><span class="sr">say so </span><span class="nv">$s</span><span class="sr"> </span><span class="o">~~</span><span class="sr"> </span><span class="nv">&amp;works-but-slow</span><span class="sr">; </span><span class="c1"># True
</span><span class="c1"></span><span class="sr">say so </span><span class="nv">$s</span><span class="sr"> </span><span class="o">~~</span><span class="sr"> </span><span class="nv">&amp;fails-but-fast</span><span class="sr">; </span><span class="c1"># False, the entire string get taken by the .+
</span></code></pre></div><p><code>token</code> 和 <code>rule</code> 标识符的不同之处在于 <code>rule</code> 标识符让 <code>Regex</code> 的 <code>:sigspace</code> 起作用了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">token</span> <span class="nf">non-space-y</span> <span class="p">{</span><span class="sr"> once upon a time </span><span class="p">}</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">space-y</span>      <span class="p">{</span><span class="sr"> once upon a time </span><span class="p">}</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">onceuponatime</span><span class="p">&#39;</span>    <span class="o">~~</span> <span class="nv">&amp;non-space-y</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">once upon a time</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="nv">&amp;space-y</span><span class="p">;</span>
</code></pre></div><h2 id="action-classes">Action Classes</h2>
<p>实际上, 命名正则甚至能接受额外的参数, 它使用的语法跟子例程参数列表的语法一样.</p>
<p>​写一个程序打印从 1  到 100 的整数，但是对 3 的倍数打印 &ldquo;Fizz&rdquo;, 对 5 的倍数打印 &ldquo;Buzz&rdquo;, 对于即是 3 的倍数，又是 5 的倍数的打印 &ldquo;FizzBuzz&rdquo;.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">100</span> <span class="p">{</span>
    <span class="k">when</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&amp;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">FizzBuzz</span><span class="p">&#39;;</span> <span class="p">}</span>
    <span class="k">when</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">3</span>       <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Fizz</span><span class="p">&#39;;</span>     <span class="p">}</span>
    <span class="k">when</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">5</span>       <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Buzz</span><span class="p">&#39;;</span>     <span class="p">}</span>
    <span class="k">default</span>            <span class="p">{</span> <span class="o">.</span><span class="nb">say</span><span class="p">;</span>           <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Or abusing multi subs:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">fizzbuzz</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$</span> <span class="k">where</span> <span class="o">*</span> <span class="nv">%%</span> <span class="mi">15</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#39;</span><span class="s1">FizzBuzz</span><span class="p">&#39;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nf">fizzbuzz</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$</span> <span class="k">where</span> <span class="o">*</span> <span class="nv">%%</span> <span class="mi">5</span><span class="p">)</span>  <span class="p">{</span> <span class="p">&#39;</span><span class="s1">Buzz</span><span class="p">&#39;</span>     <span class="p">}</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nf">fizzbuzz</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$</span> <span class="k">where</span> <span class="o">*</span> <span class="nv">%%</span> <span class="mi">3</span><span class="p">)</span>  <span class="p">{</span> <span class="p">&#39;</span><span class="s1">Fizz</span><span class="p">&#39;</span>     <span class="p">}</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nf">fizzbuzz</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$number</span> <span class="p">)</span>        <span class="p">{</span> <span class="nv">$number</span>    <span class="p">}</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">100</span><span class="p">)</span><span class="o">».</span><span class="nv">&amp;fizzbuzz</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</code></pre></div><p>Most concisely:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Fizz</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">3</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">Buzz</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">5</span> <span class="o">||</span> <span class="nv">$_</span> <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">100</span><span class="p">;</span>
</code></pre></div><p>And here&rsquo;s an implementation that never checks for divisibility:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span>
    <span class="p">((&#39;&#39;</span> <span class="ow">xx</span> <span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Fizz</span><span class="p">&#39;)</span> <span class="ow">xx</span> <span class="o">*</span> <span class="ow">Z</span><span class="o">~</span>
    <span class="p">(&#39;&#39;</span> <span class="ow">xx</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Buzz</span><span class="p">&#39;)</span> <span class="ow">xx</span> <span class="o">*</span><span class="p">)</span> <span class="ow">Z</span><span class="o">||</span><span class="err">1</span> <span class="o">..</span> <span class="mi">100</span><span class="p">;</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Sneaking Into a Loop]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-23-sneaking-into-a-loop/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-03-16-features-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的特性(二)" />
                <link href="https://ohmyweekly.github.io/notes/2015-03-14-using-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Using Raku" />
            
                <id>https://ohmyweekly.github.io/notes/2015-03-23-sneaking-into-a-loop/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+08:00</published>
            <updated>2021-07-10T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Sneaking Into a Loop</blockquote><h2 id="sneaking-into-a-loop">Sneaking into a loop</h2>
<p>Zoffix 回答了一个关于 Perl 5 的 <code>&lt;&gt;</code> 操作符的<a href="http://irclog.perlgeek.de/raku/2016-08-09#i_12993090">问题</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">slurp</span><span class="o">.</span><span class="nb">words</span><span class="o">.</span><span class="nb">Bag</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*.</span><span class="nb">value</span><span class="p">)</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#34;</span><span class="nv">%10s3d</span><span class="s2">\n</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</code></pre></div><p><code>slurp</code> 会从 STDIN 中读取整个 &ldquo;file&rdquo; 并返回一个 Str。方法 <code>Str::words</code> 会按照某种 Unicode 意义的单词把该字符串分割成一个列表。把列表强转为 Bag 则创建一个计数 Hash, 它是如下表述的快捷方式。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%h</span><span class="p">;</span>
<span class="nv">%h</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span><span class="o">++</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">peter paul marry</span><span class="p">&gt;;</span>
<span class="n">dd</span> <span class="nv">%h</span><span class="p">;</span>

<span class="c1"># OUTPUT«Hash %h = {:marry(1), :paul(1), :peter(1)}␤»</span>
</code></pre></div><p>在关联数组上调用 <code>.sort(-*.value)</code> 会按照值的降序排序并返回一个排序后的 Pairs 列表。List::fmt 会调用 Pair::fmt, 它调用 fmt 方法, <code>.key</code> 作为其第二个参数, <code>.value</code> 也作为参数。say 会会使用一个空格连接各个元素并输出到标准输出。最后一步有一点错误因为除了第一行之外的每一行前面都会有一个额外的空格。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">slurp</span><span class="o">.</span><span class="nb">words</span><span class="o">.</span><span class="nb">Bag</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*.</span><span class="nb">value</span><span class="p">)</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#34;</span><span class="nv">%10s</span><span class="s2"> =&gt; </span><span class="nv">%3d</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</code></pre></div><p>手动连接字符串更好。这对于简短的单行程序来说有点多了。我们需要找到最长的单词并使用 <code>.chars</code> 来获取列宽。</p>
<p>slurp 会在 <code>$*IN</code> 身上调用 <code>.slurp-rest</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="vg">$*IN</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">peter paul marry peter paul paul</span><span class="p">&gt;</span> <span class="k">but</span> <span class="k">role</span> <span class="p">{</span> <span class="k">method</span> <span class="nb">slurp-rest</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nb">Str</span> <span class="p">}</span> <span class="p">};</span>
</code></pre></div><p>这是一种 hack 因为它会在任何形式的类型检测上失败并且它除了 slurp 之外不会对任何东西起作用。还有, 实际上我们从 <code>$*IN</code> 那里解绑 STDIN。不要在工作中使用这个奇淫技巧。</p>
<p>现在我们能开心地吞噬并开始计数了。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%counted-words</span> <span class="o">=</span> <span class="nb">slurp</span><span class="o">.</span><span class="nb">words</span><span class="o">.</span><span class="nb">Bag</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$word-width</span> <span class="o">=</span> <span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="nv">%counted-words</span><span class="o">.</span><span class="nb">keys</span><span class="o">».</span><span class="nb">chars</span><span class="p">;</span>
</code></pre></div><p>并且继续在链子断开的地方继续。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%counted-words</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*.</span><span class="nb">value</span><span class="p">)</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#34;</span><span class="s2">%</span><span class="p">{</span><span class="nv">$word-width</span><span class="p">}</span><span class="s2">s3d</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</code></pre></div><p>问题解决了但是很丑陋。我们把一个单行程序拆开了。我们来修复 fmt 以使它再次完整。</p>
<p>我们想要的是一个 fmt 方法, 它接收一个位置的(Positional), 一个 printf 风格的格式字符串和一个格式字符串中的 block per <code>%*</code>。还有, 我们可能需要在 self.fmt 前面放上一个分隔符。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">multi</span> <span class="k">method</span> <span class="nb">fmt</span><span class="p">(</span><span class="n">Positional:D:</span> <span class="nv">$fmt-str</span><span class="o">,</span> 
                    <span class="o">*</span><span class="nv">@width</span> <span class="k">where</span> <span class="o">*.</span><span class="nb">all</span> <span class="o">~~</span> <span class="nb">Callable</span><span class="o">,</span>
                    <span class="o">:</span><span class="nv">$separator</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;){</span>
    <span class="nb">self</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(</span>
        <span class="nv">$fmt-str</span><span class="o">.</span><span class="nb">subst</span><span class="p">(:</span><span class="s">g</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">%*</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">{</span>
            <span class="k">my</span> <span class="nv">&amp;width</span> <span class="o">=</span> <span class="nv">@width</span><span class="o">[</span><span class="nv">$</span><span class="o">++]</span> <span class="o">//</span> <span class="nb">Failure</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">missingh block</span><span class="p">&#34;);</span>
            <span class="p">&#39;</span><span class="s1">%</span><span class="p">&#39;</span> <span class="o">~</span> <span class="p">(</span><span class="nv">&amp;width</span><span class="o">.</span><span class="nb">count</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">??</span> <span class="nf">width</span><span class="p">(</span><span class="nb">self</span><span class="o">,</span> <span class="nv">$_</span><span class="p">)</span> <span class="o">!!</span> <span class="nf">width</span><span class="p">(</span><span class="nb">self</span><span class="p">))</span>
        <span class="p">})</span><span class="o">,</span> <span class="nv">$separator</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>表达式 <code>*.all ~~ Callable</code> 检查 <a href="https://docs.raku.org/type/Signature#Slurpy_(A.K.A._Variadic)_Parameters">slurp array</a>中的所有元素是否实现了 CALL-ME(那是实际被执行的方法在你执行 foo()的时候)。</p>
<p>然后我们在格式字符串上使用了 <code>subst</code> 来替换 <code>%*</code>, 替换是一个(闭包)块儿, 它每次匹配被调用一次。而且这儿我们有不错的惯用法。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">1-a 2-b 3-c</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">subst</span><span class="p">(:</span><span class="s">g</span><span class="o">,</span> <span class="p">/</span><span class="se">\d</span><span class="p">/</span><span class="o">,</span> <span class="p">{&lt;</span><span class="s">one two three</span><span class="p">&gt;</span><span class="o">[</span><span class="nv">$</span><span class="o">++]</span><span class="p">});</span>
<span class="c1"># one-a two-b three-c</span>
</code></pre></div><p>匿名状态变量 <code>$</code> 从 0  开始计数, 每次代码块执行时增 1。实际上我们在这儿做的就是移除一个循环并给 subst 偷偷加入一个额外的计数器和数组下标。或者可以说我们注册了一个迭代器到 subst 里面的循环中。有人可能会质疑 subst 应该接收一个 Seq 作为它的第二个位置参数, 它会让调用变得冗长。无论如何, 我们把洞补上了。</p>
<p>在第 11 行, 我们从吞噬数组中拿出一个元素或者在没有元素时创建一个 Failure。我们把 block 存储在一个变量中因为我们想在第 12 行中内省。如果那个 block 接收两个位置参数,we feed the topic subst is calling the block with as a 2nd parameter to our stored block. 那碰巧是一个 Match 并且对于影响所匹配的东西可能有用。在我们这个例子中我们对 <code>%*</code> 进行匹配并且当前位置由 <code>$++</code> 计数。做完那个之后我们得到了一个格式字符串, 它带有一个由用户提供的 fmt 版本的列宽参数。</p>
<p>用户提供的块儿使用一组 Pairs 调用。我们不得不深入一层以得到更大的键。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">{</span><span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="o">.</span><span class="nb">values</span><span class="o">».</span><span class="nb">keys</span><span class="o">».</span><span class="nb">chars</span><span class="p">}</span>
</code></pre></div><p>得到第一列的列宽。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">print</span> <span class="nv">%counted-words</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*.</span><span class="nb">value</span><span class="p">)</span><span class="o">.&amp;</span><span class="nb">fmt</span><span class="p">(</span>
    <span class="p">&#34;</span><span class="nv">%*s3d</span><span class="p">&#34;</span><span class="o">,</span> 
    <span class="p">{</span><span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="o">.</span><span class="nb">values</span><span class="o">».</span><span class="nb">keys</span><span class="o">».</span><span class="nb">chars</span><span class="p">}</span><span class="o">,</span> 
    <span class="s">separator</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">\n</span><span class="p">&#34;);</span>
</code></pre></div><p>那个时髦的 <code>.&amp;fmt</code> 调用是必须的因为我们免费的浮点方法不是 List 的方法。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Using Raku]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-14-using-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-03-14-using-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-07T00:00:00+08:00</published>
            <updated>2021-07-07T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Using Raku</blockquote><h2 id="第一章-概要">第一章 概要</h2>
<p>略</p>
<h2 id="第二章-基础">第二章 基础</h2>
<p>假设有一场乒乓球比赛, 比赛结果以这种格式记录：</p>
<pre><code>Player1 Player2 | 3:2
</code></pre><p>这意味着选手1与选手2的比分为 3:2, 你需要一个脚本算出每位选手赢了几场比赛并且胜了几局。输入数据(存储在一个叫做 scores 的文件中)像下面这样：</p>
<pre><code>Beth Ana Charlie Dave
Ana Dave        | 3:0
Charlie Beth    | 3:1
Ana Beth        | 2:3
Dave Charlie    | 3:0
Ana Charlie     | 3:1
Beth Dave       | 0:3
</code></pre><p>第一行是选手清单。随后每一行记录着比赛结果。</p>
<p>这里使用 Raku 给出一种解决方案：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!/usr/bin/env raku</span>

<span class="k">my</span> <span class="nv">$file</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#39;</span><span class="s1">scores</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">get</span><span class="o">.</span><span class="nb">words</span> <span class="p">;</span>  <span class="c1"># get 方法读入一行, 每调用一次 get, 读取一行</span>
<span class="k">my</span> <span class="nv">%matches</span><span class="p">;</span>                   <span class="c1"># 赢得比赛次数</span>
<span class="k">my</span> <span class="nv">%sets</span><span class="p">;</span>                      <span class="c1"># 赢得比赛局数</span>

<span class="k">for</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>                       <span class="c1"># .lines 是惰性的</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$pairing</span><span class="o">,</span> <span class="nv">$result</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> | </span><span class="p">&#39;);</span> <span class="c1"># 对剩下的每一行调用 split 操作</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$p1</span><span class="o">,</span> <span class="nv">$p2</span><span class="p">)</span>          <span class="o">=</span> <span class="nv">$pairing</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>     <span class="c1"># 提取选手1和选手2的名字</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$r1</span><span class="o">,</span> <span class="nv">$r2</span><span class="p">)</span>          <span class="o">=</span> <span class="nv">$result</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">:</span><span class="p">&#39;);</span> <span class="c1"># 提取比赛比分</span>

    <span class="nv">%sets</span><span class="p">{</span><span class="nv">$p1</span><span class="p">}</span> <span class="o">+=</span> <span class="nv">$r1</span><span class="p">;</span>  <span class="c1"># 选手1赢得的比赛局数</span>
    <span class="nv">%sets</span><span class="p">{</span><span class="nv">$p2</span><span class="p">}</span> <span class="o">+=</span> <span class="nv">$r2</span><span class="p">;</span>  <span class="c1"># 选手2赢得的比赛局数</span>

    <span class="k">if</span> <span class="nv">$r1</span> <span class="o">&gt;</span> <span class="nv">$r2</span> <span class="p">{</span> <span class="c1"># 如果每场比赛中, 选手1赢的局数多于选手2, 则选手1赢得的比赛数+1, 反之选手2的+1</span>
        <span class="nv">%matches</span><span class="p">{</span><span class="nv">$p1</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nv">%matches</span><span class="p">{</span><span class="nv">$p2</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@names</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span> <span class="p">{</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@sorted</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$n</span><span class="s2"> has won </span><span class="nv">%matches</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span><span class="s2"> matches and </span><span class="nv">%sets</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span><span class="s2"> sets</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>输出如下：</p>
<pre><code>Ana has won 2 matches and 8 sets
Dave has won 2 matches and 6 sets
Charlie has won 1 matches and 4 sets
Beth has won 1 matches and 4 sets
</code></pre><p>每个 Raku 程序应该以 <code>#!/usr/bin/env raku</code> 作为开始。</p>
<p>在 Raku 中, 变量名以一个魔符打头, 这个魔符是一个非字母数字符号, 诸如 <code>$</code>, <code>@</code>, <code>%</code> 或者 <code>&amp;</code>, 还有更少见的双冒号 <code>::</code>。
内置函数 <a href="https://docs.raku.org/routine/open">open</a> 打开了一个名叫 scores 的文件, 并返回一个文件句柄, 即一个代表该文件的对象。赋值符号 <code>=</code> 将句柄赋值给左边的变量, 这意味着 <code>$file</code> 现在存储着该文件句柄。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">get</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>
</code></pre></div><p>上边这句的右侧对存储在 <code>$file</code> 中的文件句柄调用了 <a href="https://docs.raku.org/routine/get">get</a> 方法, <code>get</code> 方法从文件中读取并返回一行, 并去掉行的末尾。<a href="https://docs.raku.org/routine/words">.words</a> 也是一个方法, 用于从 get 方法返回的字符串上。<code>.words</code> 方法将它的组件 - 它操作的字符串, 分解成一组单词, 这里即意味着不含空格的字符串。它把单个字符串 &lsquo;Beth Ana Charlie Dave&rsquo; 转换成一组字符串 &lsquo;Beth&rsquo;, &lsquo;Ana&rsquo;, &lsquo;Charlie&rsquo;, &lsquo;Dave&rsquo;。最后, 这组字符串存储在数组 <code>@names</code> 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%matches</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">%sets</span><span class="p">;</span>
</code></pre></div><p>在比分计数程序中, <code>%matches</code> 存储每位选手赢得的比赛数, <code>%sets</code> 存储每位选手赢得的比赛局数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>for 循环中 $file.lines 产生一组从文件 scores 读取的行, 从上次 $file.lines 离开的地方开始, 一直到文件末尾结束。
在第一次循环中, $line 会包含字符串 <code>Ana Dave | 3:0;</code> 在第二次循环中, $line 会包含 <code>Charlie Beth | 3:1</code>,以此类推。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="p">(</span><span class="nv">$pairing</span><span class="o">,</span> <span class="nv">$result</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> | </span><span class="p">&#39;);</span>
</code></pre></div><p>split此处是一个方法, 字符串 &lsquo;|&rsquo; 是它的参数。</p>
<p>第一次循环结束：</p>
<pre><code>Variable       Contents
$line           'Ana Dave | 3:0'
$pairing        'Ana Dave'
$result         '3:0'
$p1             'Ana'
$p2             'Dave'
$r1              '3'
$r2              '0'
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@names</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>
</code></pre></div><p>这一句是排序, 先按比赛局数多少排序, 再按赢得的比赛数排序, 然后反转。打印选手名字的时候以胜负次序排序, 代码必须使用选手的分数, 而非他们的名字来进行排序。sort 方法的参数是一个代码块, 用于将数组元素（选手的名字）转换成用于排序的数据。数组的元素通过变量 <code>$_</code> 传递到代码块中。</p>
<p>最简单的使用分数排序选手的方法应该是:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@names</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span> <span class="p">{</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">}</span> <span class="p">)</span>
</code></pre></div><p>这是通过使用赢得比赛的次数来进行排序。然而, Ana 和 Dave都赢了两场比赛。还需要比较谁赢的的比赛局数多, 才能决定比赛的排名。</p>
<p>在双引号括起的字符串中, 标量和花括号中的变量能进行变量插值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$names</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">things</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Do not call me $names</span><span class="p">&#39;;</span> <span class="c1"># Do not call me $names</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Do not call me </span><span class="nv">$names</span><span class="p">&#34;;</span> <span class="c1"># Do not call me things</span>
</code></pre></div><p>花括号中的数组进行插值后会变成用空格分隔的条目。花括号中的散列插值后每个散列键值对单独成为一行, 每行包含一个健, 随后是一个 tab 制表符, 然后是键值, 最后是一个新行符。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Math: </span><span class="p">{</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">}&#34;</span>     <span class="c1"># Math: 3</span>
<span class="k">my</span> <span class="nv">@people</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">Luke Matthew Mark</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The synoptics are: </span><span class="p">{</span><span class="nv">@people</span><span class="p">}&#34;</span> <span class="c1"># The synoptics are: Luke Matthew Mark</span>

<span class="nb">say</span> <span class="p">&#34;{</span><span class="nv">%sets</span><span class="p">}&#34;;</span> <span class="c1"># From the table tennis tournament</span>

<span class="c1"># Charlie 4</span>
<span class="c1"># Dave 6</span>
<span class="c1"># Ana 8</span>
<span class="c1"># Beth 4</span>
</code></pre></div><p>当数组和散列变量直接出现在双引号字符串中(并且不在花括号 <code>{}</code> 里), 它们只在它们的名字后跟着一个 postcircumfix - 一对括号, 后面跟着语句时才会进行插值。在变量名和后置环缀之间进行方法调用也是可以的(例如 <code>@flavours.sort()</code>)</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@flavours</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">vanilla peach</span><span class="p">&gt;;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavours</span><span class="p">&#34;;</span>    <span class="c1"># we have @flavours, 这里没进行插值</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavours</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">&#34;;</span> <span class="c1"># we have vanilla, 后置环缀, 变量名字后面跟着一对儿括号</span>
<span class="c1"># so-called &#34;Zen slice&#34;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavours</span><span class="o">[]</span><span class="p">&#34;;</span>  <span class="c1"># we have vanilla peach</span>

<span class="c1"># 以后置环缀结尾的方法调用</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavours</span><span class="o">.</span><span class="nf">sort</span><span class="p">()&#34;;</span> <span class="c1"># we have peach vanilla</span>

<span class="c1"># 链式方法调用:</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavours</span><span class="o">.</span><span class="nf">sort.join</span><span class="p">(&#39;</span><span class="s1">, </span><span class="p">&#39;)&#34;;</span>
<span class="c1"># we have peach, vanilla</span>
</code></pre></div><h3 id="练习">练习</h3>
<p>例子中的第一行选手的名字是多余的, 你可以在参加比赛的选手中找出所有选手的名字！如果例子中的第一行被省略了, 你如何更改程序？提示：<code>%hash.keys</code> 返回散列 <code>%hash</code> 中的所有键。</p>
<p>答案: 移除此行：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">get</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>
</code></pre></div><p>并且将</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@names</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>
</code></pre></div><p>变成:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">%sets</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>
</code></pre></div><p>除了移除冗余, 你也可以用它来提醒我们, 如果一个选手没有在第一行的名字清单中被提到, 例如因为输入错误, 你该怎样修改你的程序？</p>
<p>答案: 引入另外一个散列, 合法选手的名字作为键, 当读取选手名字的时候查找该散列：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">get</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;);</span>
<span class="k">my</span> <span class="nv">%legitimate-players</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@names</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span> <span class="c1">#  -&gt; 两侧要有空格</span>
    <span class="nv">%legitimate-players</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$pairing</span><span class="o">,</span> <span class="nv">$result</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> | </span><span class="p">&#39;);</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$p1</span><span class="o">,</span> <span class="nv">$p2</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$pairing</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;);</span>
    
    <span class="k">for</span> <span class="nv">$p1</span><span class="o">,</span> <span class="nv">$p2</span> <span class="k">-&gt;</span> <span class="nv">$p</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="nv">%legitimate-players</span><span class="p">{</span><span class="nv">$p</span><span class="p">}</span> <span class="p">{</span>
            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Warning: &#39;</span><span class="nv">$p&#39;</span><span class="s2"> is not on our list!</span><span class="p">&#34;;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><h2 id="第三章-操作符">第三章 操作符</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Ana</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">8</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dave</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">6</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Charlie</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Beth</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$screen-width</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$label-area-width</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="nv">@scores</span><span class="o">».</span><span class="nb">key</span><span class="o">».</span><span class="nb">chars</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$max-score</span> <span class="o">=</span> <span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="nv">@scores</span><span class="o">».</span><span class="nb">value</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$unit</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$screen-width</span> <span class="o">-</span> <span class="nv">$label-area-width</span><span class="p">)</span> <span class="o">/</span> <span class="nv">$max-score</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$format</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">%- </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$label-area-width</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">s</span><span class="nv">%s</span><span class="s2">\n</span><span class="p">&#34;;</span>

<span class="k">for</span> <span class="nv">@scores</span> <span class="p">{</span>
    <span class="nb">printf</span> <span class="nv">$format</span><span class="o">,</span> <span class="o">.</span><span class="nb">key</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">X</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="p">(</span><span class="nv">$unit</span> <span class="o">*</span> <span class="o">.</span><span class="nb">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>在这个例子中, 我们计算一下每位选手在竞标赛中赢得比赛的局数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Ana</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">8</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dave</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">6</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Charlie</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Beth</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>  
</code></pre></div><p>这一句局包含了三个不同的操作符 <code>=</code> 和 <code>=&gt;</code> 和 <code>,</code>。以字符串连接操作符 <code>~</code> 为例, <code>$string ~= &quot;text&quot;</code> 等价于 <code>$string = $string ~ &quot;text&quot;</code>。</p>
<p><code>=&gt;</code> 操作符(大键号)创建了一个键值对对象, 一个键值对存储着键和值；键在 <code>=&gt;</code> 操作符的左侧, 值在右侧。这个操作符有一个特殊的特性：编译器会把 <code>=&gt;</code> 操作符左侧的任何裸标识符解释为一个字符串。你也可以这样写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="s">Ana</span> <span class="o">=&gt;</span> <span class="mi">8</span>, <span class="s">Dave</span> <span class="o">=&gt;</span> <span class="mi">6</span>, <span class="s">Charlie</span> <span class="o">=&gt;</span> <span class="mi">4</span>, <span class="s">Beth</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div><p>最后逗号操作符 <code>,</code> 构建了一个对象序列, 在该情况下, 所谓的对象就是键值对。</p>
<p>这三个操作符都是中缀操作符, 这意味着它在两个条目之间。</p>
<p>一个项前面可以有0个或多个前缀操作符, 所以你可以写比如 <code>4 + -5</code>。<code>+</code> 号（一个中缀操作符）的后面, 编译器期望一个项, 为了将 <code>-</code> 号解释为项 5 的一个前缀。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$label-area-width</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="nv">@scores</span><span class="o">».</span><span class="nb">key</span><span class="o">».</span><span class="nb">chars</span><span class="p">;</span>
</code></pre></div><p><code>»</code> 是一个特殊的符号, 打印不出来可以用两个大于号 <code>&gt;&gt;</code> 代替。中缀操作符 <code>max</code> 返回两个值中的较大者, 所以 <code>2 max 3</code> 返回 3。方括号包裹着一个中缀操作符让 Raku 将该中缀操作符应用到列表中的元素之间。<code>[max] 1,5,3,7</code> 和 <code>1 max 5 max 3 max 7</code> 一样, 结果都为 7。</p>
<p>同样地, <code>[+]</code> 用来计算列表元素的和, <code>[*]</code> 用来计算列表元素的积, <code>[&lt;=]</code> 用来检查一个列表的值是否按递增排序。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">».</span><span class="nb">key</span><span class="o">».</span><span class="nb">chars</span>
<span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="s">Ana</span> <span class="o">=&gt;</span> <span class="mi">8</span>, <span class="s">Dave</span> <span class="o">=&gt;</span> <span class="mi">6</span>, <span class="s">Charlie</span> <span class="o">=&gt;</span> <span class="mi">4</span>, <span class="s">Beth</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">Ana</span>     <span class="mi">8</span> <span class="n">Dave</span>  <span class="mi">6</span> <span class="n">Charlie</span>       <span class="mi">4</span> <span class="n">Beth</span>  <span class="mi">4</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">.</span><span class="nb">key</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Method &#39;key&#39; not found for invocant of class &#39;Array&#39;
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">&gt;&gt;.</span><span class="nb">key</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Ana Dave Charlie Beth
</code></pre></div><p>就像 <code>@variable.method</code> 在 <code>@variable</code> 上调用一个方法一样, <code>@array».method</code> 对 <code>@array</code> 中的每一项调用 <code>method</code> 方法, 并且返回一个返回值的列表。即 <code>@scores&gt;&gt;.key</code> 返回一个列表。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">&gt;&gt;.</span><span class="nb">key</span><span class="o">&gt;&gt;.</span><span class="nb">chars</span>  <span class="c1"># 每个名字含有几个字符</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">4 7 4
</code></pre></div><p>表达式 <code>[max] @scores».key».chars</code> 给出 (3,4,7,4) 中的最大值。它与下面的表达式相同：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">key</span><span class="o">.</span><span class="nb">chars</span>
<span class="nb">max</span> <span class="nv">@scores</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="nb">key</span><span class="o">.</span><span class="nb">chars</span>
<span class="nb">max</span> <span class="nv">@scores</span><span class="o">[</span><span class="mi">2</span><span class="o">].</span><span class="nb">key</span><span class="o">.</span><span class="nb">chars</span>
<span class="nb">max</span> <span class="o">...</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#34;</span><span class="s2">Ana</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="mi">8</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">key</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Ana
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$format</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">%- </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$label-area-width</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">s</span><span class="nv">%s</span><span class="s2">\n</span><span class="p">&#34;;</span>

<span class="k">for</span> <span class="nv">@scores</span> <span class="p">{</span>
    <span class="nb">printf</span> <span class="nv">$format</span><span class="o">,</span> <span class="o">.</span><span class="nb">key</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">X</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="p">(</span><span class="nv">$unit</span> <span class="o">*</span> <span class="o">.</span><span class="nb">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>定义一个格式, <code>%-</code> 表示左对齐, <code>~</code> 是字符串连接操作符 <code>.for</code> 循环中, <code>@scores</code> 中的每一项被绑定给特殊变量 <code>$_</code>, <code>.key</code> 是每项的键, 即名字, <code>.value</code> 是每项的键值, 即得分。小 x 是字符串重复操作符。</p>
<h3 id="关于优先级的的一句话">关于优先级的的一句话</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Ana</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">8</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dave</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">6</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Charlie</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Beth</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div><p>等号右侧产生一个列表（因为逗号, 操作符）, 这个列表由对儿组成(因为 <code>=&gt;</code>), 并且结果赋值给数组变量。
在 Perl5 中会这样解释:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Ana</span><span class="p">&#39;)</span> <span class="o">=&gt;</span> <span class="mi">8</span>, <span class="p">&#39;</span><span class="s1">Dave</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">6</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Charlie</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Beth</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div><p>以至于数组 <code>@scores</code> 中只有一个项, 表达式的其余部分被计算后丢弃。</p>
<p>优先级规则控制着编译器如何解释这一行。Raku 的优先级规则申明 中缀操作符 <code>=&gt;</code> 比 <code>,</code> 中缀操作符对于参数的绑定更紧, 而逗号操作符比等号赋值操作符绑定的更紧。</p>
<p>实际上有两种不同优先级的赋值操作符。当赋值操作符右侧是一个标量时, 使用较紧优先级的项赋值操作符, 否则使用较松优先级的列表赋值操作符。(如同螺丝的松紧)
比较 <code>$a = 1, $b = 2</code> 和 <code>@a = 1, 2,</code> 前者是在一个列表中赋值给两个变量, 后者是将含有两个项的一个列表赋值给一个变量。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">5</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>   <span class="c1"># 5 - 3.5 = 1.5</span>
<span class="nb">say</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1"># (-2) / 2 = -1</span>
</code></pre></div><p>Raku 中的优先级可以用圆括号改变, 但是如果圆括号直接跟在标识符的后面而不加空格的话, 则会被解释为参数列表。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span><span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1"># -2</span>
</code></pre></div><p>只打印出了 <code>5-7</code> 的值。</p>
<p>优先级表</p>
<table>
<thead>
<tr>
<th style="text-align:left">expression</th>
<th style="text-align:left">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">(), 42.5</td>
<td style="text-align:left">(tightest precedence)</td>
</tr>
<tr>
<td style="text-align:left">42.rand</td>
<td style="text-align:left">term</td>
</tr>
<tr>
<td style="text-align:left">$x++</td>
<td style="text-align:left">method calls and postcircumfixes</td>
</tr>
<tr>
<td style="text-align:left">$x**2</td>
<td style="text-align:left">autoincrement and autodecrement</td>
</tr>
<tr>
<td style="text-align:left">?$x, !$x</td>
<td style="text-align:left">exponentiation operator</td>
</tr>
<tr>
<td style="text-align:left">+$x, ~$x</td>
<td style="text-align:left">boolean prefix</td>
</tr>
<tr>
<td style="text-align:left">2*3, 7/5</td>
<td style="text-align:left">prefix context operators</td>
</tr>
<tr>
<td style="text-align:left">1+2, 7-5</td>
<td style="text-align:left">multiplicative infix operators</td>
</tr>
<tr>
<td style="text-align:left">$a x 3</td>
<td style="text-align:left">additive infix operators</td>
</tr>
<tr>
<td style="text-align:left">$x ~&quot;.nn&quot;</td>
<td style="text-align:left">replication operators</td>
</tr>
<tr>
<td style="text-align:left">1&amp;2</td>
<td style="text-align:left">string concatenation</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">abs $x</td>
<td style="text-align:left">junctive OR</td>
</tr>
<tr>
<td style="text-align:left">$x cmp 3</td>
<td style="text-align:left">named unary prefix</td>
</tr>
<tr>
<td style="text-align:left">$x == 3</td>
<td style="text-align:left">non-chaining binary operators</td>
</tr>
<tr>
<td style="text-align:left">$x &amp;&amp; $y</td>
<td style="text-align:left">chaining binary operators</td>
</tr>
<tr>
<td style="text-align:left">$x</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$x &gt; 0 ?? 1 !! -1</td>
<td style="text-align:left">tight OR infix</td>
</tr>
<tr>
<td style="text-align:left">$x = 1</td>
<td style="text-align:left">conditional operator</td>
</tr>
<tr>
<td style="text-align:left">not $x</td>
<td style="text-align:left">item assignment</td>
</tr>
<tr>
<td style="text-align:left">1, 2</td>
<td style="text-align:left">loose unary prefix</td>
</tr>
<tr>
<td style="text-align:left">1, 2 Z @a</td>
<td style="text-align:left">comma</td>
</tr>
<tr>
<td style="text-align:left">@a = 1, 2</td>
<td style="text-align:left">list infix</td>
</tr>
<tr>
<td style="text-align:left">$x and say &ldquo;Yes&rdquo;</td>
<td style="text-align:left">list prefix, list assignment</td>
</tr>
<tr>
<td style="text-align:left">$x or die &ldquo;No&rdquo;</td>
<td style="text-align:left">loose AND infix</td>
</tr>
<tr>
<td style="text-align:left">;</td>
<td style="text-align:left">loose OR infix</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">statement terminator</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">(loosest precedence)</td>
</tr>
</tbody>
</table>
<h3 id="比较和智能匹配">比较和智能匹配</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>

<span class="nb">say</span> <span class="nv">@a</span> <span class="o">===</span> <span class="nv">@a</span><span class="p">;</span> <span class="c1"># Bool::True</span>
<span class="nb">say</span> <span class="nv">@a</span> <span class="o">===</span> <span class="nv">@b</span><span class="p">;</span> <span class="c1"># Bool::False</span>

<span class="c1"># these use identity for value</span>
<span class="nb">say</span> <span class="mi">3</span> <span class="o">===</span> <span class="mi">3</span> <span class="c1"># Bool::True</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">===</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span> <span class="c1"># Bool::True</span>

<span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="nv">$a</span> <span class="o">===</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span> <span class="c1"># Bool::True</span>

<span class="nv">@b</span><span class="o">===</span><span class="nv">@a</span><span class="p">;</span>   <span class="c1"># False</span>
<span class="nv">@a</span> <span class="ow">eqv</span> <span class="nv">@b</span><span class="p">;</span> <span class="c1"># True</span>
<span class="p">&#39;</span><span class="s1">2</span><span class="p">&#39;</span> <span class="ow">eqv</span> <span class="mi">2</span><span class="p">;</span> <span class="c1"># False</span>
</code></pre></div><p>只有当两个对象有相同的类型和相同的结构时, eqv 操作符才返回 True。在前面定义的例子中, @a  eqv  @b 结果为 True, 因为 @a 和 @b 各自包含相同的值, 另一方面, &lsquo;2&rsquo; eqv 2 返回 &lsquo;False&rsquo; ,因为一个参数是字符串, 另一个是整数, 类型不相同。</p>
<h4 id="数字比较">数字比较</h4>
<p>使用 == 中缀操作符查看两个对象是否有相同的数字值。如果某个对象不是数字, Perl 会在比较之前尽力使其数字化。如果没有更好的方式将对象转换为数字, Perl 会使用默认的数字 0 。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">1</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">;</span>  <span class="c1"># Bool::True</span>
<span class="nb">say</span> <span class="mi">1</span> <span class="o">==</span> <span class="p">&#39;</span><span class="s1">1</span><span class="p">&#39;;</span>  <span class="c1"># Bool::True</span>
<span class="nb">say</span> <span class="mi">1</span> <span class="o">==</span> <span class="p">&#39;</span><span class="s1">2</span><span class="p">&#39;;</span>  <span class="c1"># Bool::False</span>
<span class="nb">say</span> <span class="mi">3</span> <span class="o">==</span> <span class="p">&#39;</span><span class="s1">3b</span><span class="p">&#39;;</span> <span class="c1"># fails</span>
</code></pre></div><p>跟数字比较相关的还有 <code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>,<code>&gt;=</code>。如果两个对象的数字值不同, 使用 <code>!=</code> 会返回 True 。</p>
<p>如果你将数组或列表作为数字, 它会计算列表中项的个数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@colors</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">red blue green</span><span class="p">&gt;;</span>

<span class="k">if</span> <span class="nv">@colors</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">It&#39;s true, </span><span class="nv">@colors</span><span class="s2"> contains 3 items</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><h4 id="字符串比较">字符串比较</h4>
<p>Raku 中使用 eq 比较字符串, 必要时会将其参数转换为字符串。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$greeting</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">hello</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">welcome</span><span class="p">&#39;;</span>
<span class="p">}</span>
</code></pre></div><p>Table 3.2: Operators and Comparisons</p>
<table>
<thead>
<tr>
<th style="text-align:left">数字比较</th>
<th style="text-align:left">字符串比较</th>
<th style="text-align:left">意思</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">==</td>
<td style="text-align:left">eq</td>
<td style="text-align:left">等于</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">ne</td>
<td style="text-align:left">不等于</td>
</tr>
<tr>
<td style="text-align:left">!==</td>
<td style="text-align:left">!eq</td>
<td style="text-align:left">不等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">lt</td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">le</td>
<td style="text-align:left">小于或等于</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">gt</td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">ge</td>
<td style="text-align:left">大于或等于</td>
</tr>
</tbody>
</table>
<p>例如, <code>'a' lt 'b'</code> 为 true, <code>'a' lt 'aa'</code> 也为 true。 != 是 <code>!==</code> 的便捷形式, 它实际是 <code>!</code> 元操作符加在 中缀操作符 <code>==</code> 之前。同样地, <code>ne</code> 和 <code>!eq</code>s 是一样的。</p>
<p>三路操作符</p>
<p>三路操作符有两个操作数, 如果左侧较小, 返回 Order::Increase , 两侧相等则返回 Order::Same, 如果右侧较小则返回 Order::Decrease。对于数字使用三路操作符 <code>&lt;=&gt;</code>,对于字符串, 使用三路操作符 <code>leg</code> （取自 lesser, equal, greater）。中缀操作符 cmp 是一个对类型敏感的三路操作符, 它像 <code>&lt;=&gt;</code> 一样比较数字, 像 leg 一样比较字符串, 并且比较键值对儿时, 先比较键, 如果键相同再比较键值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">10</span> <span class="o">&lt;=&gt;</span> <span class="mi">5</span><span class="p">;</span>     <span class="c1"># +1</span>
<span class="nb">say</span> <span class="mi">10</span> <span class="ow">leg</span> <span class="mi">5</span><span class="p">;</span>     <span class="c1"># because &#39;1&#39; lt &#39;5&#39;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">ab</span><span class="p">&#39;</span> <span class="ow">leg</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span> <span class="c1"># +1, lexicographic comparison</span>
</code></pre></div><p>三路操作符的典型用处就是用在排序中。列表中的 <code>.sort</code> 方法能使用一个含有两个值的块或一个函数, 比较它们, 并返回一个小于, 等于或大于 0 的值。 sort 方法根据该返回值进行排序：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">~&lt;</span><span class="n">abstract</span> <span class="n">Concrete</span><span class="o">&gt;.</span><span class="nb">sort</span><span class="p">;</span>
<span class="c1"># output: Concrete abstract</span>

<span class="nb">say</span> <span class="o">~&lt;</span><span class="n">abstract</span> <span class="n">Concrete</span><span class="o">&gt;.</span><span class="nb">sort</span><span class="o">:</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="nb">uc</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="ow">leg</span> <span class="nb">uc</span><span class="p">(</span><span class="nv">$b</span><span class="p">)</span> <span class="p">};</span>
<span class="c1"># output: abstract Concrete</span>
</code></pre></div><p>默认的, 比较是大小写敏感的, 通过比较它们的大写变形, 而不是比较它们的值, 这个例子使用了大小写敏感排序。</p>
<h4 id="智能匹配">智能匹配</h4>
<p>使用 <code>~~</code> 做正确的事情。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$pints-drunk</span> <span class="o">~~</span> <span class="mi">8</span> <span class="p">{</span>
   <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Go home, you&#39;ve had enough!</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nv">$country</span> <span class="o">~~</span> <span class="p">&#39;</span><span class="s1">Sweden</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Meatballs with lingonberries and potato moose, please.</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="k">unless</span> <span class="nv">$group-size</span> <span class="o">~~</span> <span class="mi">2</span><span class="o">..</span><span class="mi">4</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">You must have between 2 and 4 people to book this tour.</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>智能匹配总是根据 <code>~~</code> 右侧值的类型来决定使用哪种比较。上个例子中, 比较的是数字、字符串和范围。
智能匹配的工作方式 <code>$answer ~~ 42</code> 等价于 <code>42.ACCPETS( $answer )</code>。对 <code>~~</code> 操作符右侧的操作数调用 ACCEPTS 方法, 并将左操作数作为参数传入。</p>
<h2 id="第四章-子例程和签名">第四章 子例程和签名</h2>
<p>一个子例程就是一段执行特殊任务的代码片段。它可以对提供的数据(<code>实参</code>)操作, 并产生结果（返回值）。子例程的签名是它<code>所含的参数</code>和它产生的<code>返回值</code>的描述。从某一意义上来说, 第三章描述的操作符也是 Raku 用特殊方式解释的子例程。</p>
<h3 id="申明子例程">申明子例程</h3>
<p>子例程申明由几部分组成。首先, <code>sub</code> 表明你在申明一个子例程, 然后是可选的子例程的名称和可选的签名。子例程的主体是一个用花括号扩起来的代码块。
默认的, 子例程是本地作用域的, 就像任何使用 <code>my</code> 申明的变量一样。这意味着, 一个子例程只能在它被申明的作用域内被调用。使用 <code>our</code> 来申明子例程可以使其在当前包中可见。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">{</span>
    <span class="k">our</span> <span class="k">sub</span> <span class="nf">eat</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">om nom nom</span><span class="p">&#34;;</span>
    <span class="p">}</span>

    <span class="k">sub</span> <span class="nf">drink</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">glug glug</span><span class="p">&#34;;</span>
    <span class="p">}</span>
 <span class="p">}</span>

<span class="k">our</span> <span class="nv">&amp;eat</span><span class="p">;</span> <span class="c1"># makes the package-scoped sub eat available in this lexical scope</span>

<span class="nf">eat</span><span class="p">();</span>   <span class="c1"># om nom nom</span>
<span class="nf">drink</span><span class="p">();</span> <span class="c1"># 失败, can&#39;t drink outside of the block</span>
</code></pre></div><p>our 也能让子例程从包或模块的外部是可见的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">module</span> <span class="nn">EatAndDrink</span> <span class="p">{</span>
    <span class="k">our</span> <span class="k">sub</span> <span class="nf">eat</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">om nom nom</span><span class="p">&#34;;</span>
    <span class="p">}</span>

    <span class="k">sub</span> <span class="nf">drink</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">glug glug</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">EatAndDrink::eat</span><span class="p">();</span> <span class="c1"># om nom nom</span>
<span class="nf">EatAndDrink::drink</span><span class="p">();</span> <span class="c1"># fails, not declared with &#34;our&#34;</span>
</code></pre></div><p>你也可以<code>导出</code>一个子例程, 让它在另外的作用域内可见。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># in file Math/Trivial.pm</span>
<span class="k">module</span> <span class="nn">Math::Trivial</span> <span class="p">{</span>
    <span class="k">sub</span> <span class="nf">double</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nv">$x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>然后在其它程序或模块中你可以这样写:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nn">Math::Trivial</span><span class="p">;</span> <span class="c1"># imports sub double</span>
<span class="nb">say</span> <span class="nf">double</span><span class="p">(</span><span class="mi">21</span><span class="p">);</span>    <span class="c1"># 21 is only half the truth</span>
</code></pre></div><p>Raku 的子例程都是对象。你可以将它们随意传递并存储在数据结构中。编程语言设计者常常将它们称之为 first-class 子例程；它们就像数组和散列一样作为语言的基础。</p>
<p>First-class 子例程能帮助你解决复杂的问题。例如, 为了做出一个微型的ASCII艺术舞蹈图, 你可能要建立一个散列, 键是舞蹈动作的名称, 键值是匿名散列。假使使用者能键入一系列舞蹈动作（可能是站在舞蹈平台上或其它外部输入设备）。 你怎么保持一个变量清单中都是合法的行为, 允许使用者输入, 并限制输入是一系列安全的行为呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%moves</span> <span class="o">=</span>
<span class="s">hands-over-head</span>       <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">/o\ </span><span class="p">&#39;</span>  <span class="p">}</span>,
<span class="s">bird-arms</span>             <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">|/o\| </span><span class="p">&#39;}</span>,
<span class="s">left</span>                  <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">&gt;o </span><span class="p">&#39;</span>   <span class="p">}</span>,
<span class="s">right</span>                 <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">o&lt; </span><span class="p">&#39;</span>   <span class="p">}</span>,
<span class="s">arms-up</span>               <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">\o/ </span><span class="p">&#39;</span>  <span class="p">};</span>

<span class="k">my</span> <span class="nv">@awesome-dance</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">arms-up bird-arms right hands-over-head</span><span class="p">&gt;;</span>

<span class="k">for</span> <span class="nv">@awesome-dance</span> <span class="k">-&gt;</span> <span class="nv">$move</span> <span class="p">{</span>
    <span class="nv">%moves</span><span class="p">{</span><span class="nv">$move</span><span class="p">}</span><span class="o">.</span><span class="p">();</span>  <span class="c1"># 在散列上调用方法</span>
<span class="p">}</span>
</code></pre></div><pre><code>outputs:
 \o/
|/o\|
  o&lt;
 /o\.
</code></pre>
<h3 id="adding-signatures">Adding Signatures</h3>
<p>子例程的签名执行两个任务。首先, 它申明哪个调用者可能或必须将参数传递给子例程。第二, 它申明子例程中的变量被绑定到哪些参数上。这些变量叫做参数。Raku 的签名更深入, 它们允许你限制参数的类型, 值和参数的定义, 并准确匹配复杂数据结构的某一部分。此外, 它们也允许你显式地指定子例程返回值的类型。</p>
<h4 id="基础">基础</h4>
<p>签名最简单的形式是, 绑定到输入参数上的用逗号分隔的一列变量的名字。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-beer</span><span class="p">(</span><span class="nv">$type</span><span class="o">,</span> <span class="nv">$pints</span><span class="p">)</span> <span class="p">{</span>
   <span class="nb">say</span> <span class="p">(</span><span class="nv">$pints</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">A pint</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="nv">$pints</span><span class="s2"> pints</span><span class="p">&#34;)</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> of </span><span class="nv">$type</span><span class="s2">, please.</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="nf">order-beer</span><span class="p">(&#39;</span><span class="s1">Hobgoblin</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>    <span class="c1"># A pint of Hobgoblin, please.</span>
<span class="nf">order-beer</span><span class="p">(&#39;</span><span class="s1">Zlatý Bažant</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1"># 3 pints of Zlatý Bažant, please.</span>
</code></pre></div><p>这里使用的关系绑定而非赋值就是签名。默认地, 在 Raku 中, 子例程中引用到传入参数的签名的变量是只读的。这意味着你不能从子例程内部修改它们。
如果只读绑定太受限制了, 你可以将 <code>is rw</code> (rw 是 read/write 的缩写) 特性应用到参数上以降低这种限制。这个特性说明参数是可读可写的, 这允许你从子例程内部修改参数。使用的时候必须小心, 因为它会修改传入的原始对象。如果你试图传入一个字面值, 一个常量, 或其它类型的不可变对象到一个有 <code>is rw</code> 特性的参数中, 绑定会在调用时失败并抛出异常:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">make-it-more-so</span><span class="p">(</span><span class="nv">$it</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$it</span> <span class="o">~=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$it</span><span class="o">,</span> <span class="nv">$it</span><span class="o">.</span><span class="nb">chars</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="nb">x</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$happy</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">yay!</span><span class="p">&#34;;</span>
<span class="nf">make-it-more-so</span><span class="p">(</span><span class="nv">$happy</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$happy</span><span class="p">;</span> <span class="c1"># yay!!!!!!   # 原始传入对象被修改了</span>
<span class="nf">make-it-more-so</span><span class="p">(&#34;</span><span class="s2">uh-oh</span><span class="p">&#34;);</span> <span class="c1"># 失败, 不能修改一个常量</span>
</code></pre></div><p>如果你想将参数的本地副本用在子例程内部而不改变调用者的变量, 使用 <code>is copy</code> 特性：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">say-it-one-higher</span><span class="p">(</span><span class="nv">$it</span> <span class="k">is</span> <span class="nb">copy</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$it</span><span class="o">++</span><span class="p">;</span>
    <span class="nb">say</span> <span class="nv">$it</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$unanswer</span> <span class="o">=</span> <span class="mi">41</span><span class="p">;</span>
<span class="nf">say-it-one-higher</span><span class="p">(</span><span class="nv">$unanswer</span><span class="p">);</span> <span class="c1"># 42</span>
<span class="nf">say-it-one-higher</span><span class="p">(</span><span class="mi">41</span><span class="p">);</span>        <span class="c1"># 42</span>
<span class="nb">say</span> <span class="nv">$unanswer</span><span class="p">;</span>                <span class="c1"># 41</span>
</code></pre></div><p>在诸如 <code>C/C++</code> 和 Scheme 等其它类型的编程语言中,这种广为人知的求值策略就是按值传递。当使用 <code>is copy</code> 特性时, 只有本地副本被赋值。其它任何传递给子例程的参数在调用者的作用域内保持不变。（一个不可变对象是当这个对象被创建后, 它的状态不会改变, 作为比较, 一个可变对象的状态在创建后是会被改变的）</p>
<h4 id="传递数组散列和代码">传递数组、散列和代码</h4>
<p>一个变量的魔符表明它的本意用途。在签名中, 变量的魔符也起着限制传入的参数类型的作用。例如, <code>@</code> 符号检查传入的对象行使位置角色（一个角色包含像数组和列表的类型）。如果传递的东西不能匹配这样的限制, 会引起调用失败：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">shout-them</span><span class="p">(</span><span class="nv">@words</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nv">@words</span> <span class="k">-&gt;</span> <span class="nv">$w</span> <span class="p">{</span>
        <span class="nb">print</span> <span class="nb">uc</span><span class="p">(&#34;</span><span class="nv">$w</span><span class="s2"> </span><span class="p">&#34;);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@last_words</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">do not want</span><span class="p">&gt;;</span>

<span class="nf">shout-them</span><span class="p">(</span><span class="nv">@last_words</span><span class="p">);</span> <span class="c1"># DO NOT WANT</span>
<span class="nf">shout-them</span><span class="p">(&#39;</span><span class="s1">help</span><span class="p">&#39;);</span>      <span class="c1"># 失败了, 字符串不是位置参数</span>
</code></pre></div><p>类似地, <code>%</code> 符号表明调用者必须传递一个行使关系角色的对象；即允许通过 <code>&lt;...&gt;</code> 或 <code>{...}</code> 进行索引的东西。 <code>&amp;</code> 符号要求调用者传递一个诸如匿名散列之类的行使能调用的角色的对象。在那种情况下, 你也可以不用 <code>&amp;</code> 符号调用可调用的参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">do-it-lots</span><span class="p">(</span><span class="nv">&amp;it</span><span class="o">,</span> <span class="nv">$how-many-times</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="nv">$how-many-times</span> <span class="p">{</span>
        <span class="nf">it</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">do-it-lots</span><span class="p">(</span><span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Eating a stroopwafel</span><span class="p">&#34;</span> <span class="p">}</span><span class="o">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1"># 此处是一个匿名子例程</span>
</code></pre></div><p>标量使用 <code>$</code> 符号, 并表明没有限制。什么都可以绑定在它上面, 即使它使用另外的符号绑定到一个对象上。</p>
<h4 id="插值数组和散列">插值、数组和散列</h4>
<p>有时你想从数组中填充占位参数。你可以通过在数组前添加一个垂直竖条或管道字符 ( <code>|</code> ): <code>eat(|@food)</code>, 而不是写作 <code>eat(@food[0], @food[1], @food[2], ...)</code> 等将它们吸进参数列表( <code>|</code> 像不像一个吸管, ^_^)。</p>
<p>同样地, 你可以将散列插值进具名参数:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-shrimps</span><span class="p">(</span><span class="nv">$count</span><span class="o">,</span> <span class="o">:</span><span class="nv">$from</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I&#39;d like </span><span class="nv">$count</span><span class="s2"> pieces of shrimp from the </span><span class="nv">$from</span><span class="s2">, please</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">%user-preferences</span> <span class="o">=</span> <span class="s">from</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Northern Sea</span><span class="p">&#39;;</span>

<span class="nf">order-shrimps</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="o">|</span><span class="nv">%user-preferences</span><span class="p">);</span>
<span class="c1"># I&#39;d like 3 pieces of shrimp from the Northern Sea, please</span>
</code></pre></div><h4 id="可选参数">可选参数</h4>
<p>为使参数可选, 要么给签名的参数赋值为默认值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-steak</span><span class="p">(</span><span class="nv">$how</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">medium</span><span class="p">&#39;)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I&#39;d like a steak, </span><span class="nv">$how</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">order-steak</span><span class="p">();</span>
<span class="nf">order-steak</span><span class="p">(&#39;</span><span class="s1">well done</span><span class="p">&#39;);</span>
</code></pre></div><p>或者在参数名字的后面添加一个问号(?):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-burger</span><span class="p">(</span><span class="nv">$type</span><span class="o">,</span> <span class="nv">$side</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I&#39;d like a </span><span class="nv">$type</span><span class="s2"> burger</span><span class="p">&#34;</span> <span class="o">~</span>
    <span class="p">(</span> <span class="nb">defined</span><span class="p">(</span><span class="nv">$side</span><span class="p">)</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2"> with a side of </span><span class="nv">$side</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;&#34;</span> <span class="p">);</span>
<span class="p">}</span>

<span class="nf">order-burger</span><span class="p">(&#34;</span><span class="s2">triple bacon</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">deep fried onion rings</span><span class="p">&#34;);</span>
</code></pre></div><p>如果没有参数被传递, 参数会被绑定成一个未定义的值。<code>defined(...)</code> 函数用来检查是否有值。</p>
<h4 id="强制参数">强制参数</h4>
<p>默认地, 位置参数是必不可少的。然而, 你可以通过在参数后面追加一个感叹号来显式地指定该参数是必须的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-drink</span><span class="p">(</span><span class="nv">$size</span><span class="o">,</span> <span class="nv">$flavor</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$size</span><span class="s2"> </span><span class="nv">$flavor</span><span class="s2">, coming right up!</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">order-drink</span><span class="p">(&#39;</span><span class="s1">Large</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Mountain Dew</span><span class="p">&#39;);</span> <span class="c1"># OK</span>
<span class="nf">order-drink</span><span class="p">(&#39;</span><span class="s1">Small</span><span class="p">&#39;);</span>                 <span class="c1"># Error</span>
</code></pre></div><h4 id="具名实参和形参">具名实参和形参</h4>
<ul>
<li>arguments  实参</li>
<li>parameters 形参</li>
</ul>
<p>当一个子例程有很多参数时, 调用者很难记清传递参数的顺序。这种情况下, 通过名字传递参数往往更容易。这样, 参数出现的顺序就无关紧要了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-beer</span><span class="p">(</span><span class="nv">$type</span><span class="o">,</span> <span class="nv">$pints</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">(</span><span class="nv">$pints</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">A pint</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="nv">$pints</span><span class="s2"> pints</span><span class="p">&#34;)</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> of </span><span class="nv">$type</span><span class="s2">, please.</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="nf">order-beer</span><span class="p">(</span><span class="s">type</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Hobgoblin</span><span class="p">&#39;</span>, <span class="s">pints</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1"># A pint of Hobgoblin, please.</span>

<span class="nf">order-beer</span><span class="p">(</span><span class="s">pints</span> <span class="o">=&gt;</span> <span class="mi">3</span>, <span class="s">type</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Zlatý Bažant</span><span class="p">&#39;);</span>
<span class="c1"># 3 pints of Zlatý Bažant, please.</span>
</code></pre></div><p>你也可以指定参数只能按名字被传递（这意味着它不允许按位置传递）。这样的话, 在参数名字前加一个冒号：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-shrimps</span><span class="p">(</span><span class="nv">$count</span><span class="o">,</span> <span class="o">:</span><span class="nv">$from</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Northern Sea</span><span class="p">&#39;)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I&#39;d like </span><span class="nv">$count</span><span class="s2"> pieces of shrimp from the </span><span class="nv">$from</span><span class="s2">, please</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">order-shrimps</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> <span class="c1"># takes &#39;Northern Sea&#39;</span>
<span class="nf">order-shrimps</span><span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="s">from</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Atlantic Ocean</span><span class="p">&#39;);</span>
<span class="nf">order-shrimps</span><span class="p">(</span><span class="mi">22</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Mediterranean Sea</span><span class="p">&#39;);</span>   <span class="c1"># 不允许, :$from is named only</span>
</code></pre></div><p>不像位置参数, 命名参数默认是可选的。在命名参数后面追加一个 <code>!</code> 号使命名参数强制性存在。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">design-ice-cream-mixture</span><span class="p">(</span><span class="nv">$base</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Vanilla</span><span class="p">&#39;</span><span class="o">,</span> <span class="o">:</span><span class="nv">$name</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Creating a new recipe named </span><span class="nv">$name</span><span class="s2">!</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="nf">design-ice-cream-mixture</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Plain</span><span class="p">&#39;);</span>
<span class="nf">design-ice-cream-mixture</span><span class="p">(</span><span class="s">base</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Strawberry chip</span><span class="p">&#39;);</span> <span class="c1"># 错误</span>,<span class="n">没有指定</span> <span class="nv">$name</span>
</code></pre></div><p><strong>重命名参数</strong></p>
<p>因为按名字传递实参给形参是合理的, 形参的名字应该应该作为子例程公共 API 的一部分被考虑在内. 小心地挑选它们吧! 有时候, 使用一个名字暴露形参而使用另外一个名字绑定到变量会很方便:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">announce-time</span><span class="p">(:</span><span class="s">dinner</span><span class="p">(</span><span class="nv">$supper</span><span class="p">)</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">8pm</span><span class="p">&#39;)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">We eat dinner at </span><span class="nv">$supper</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">announce-time</span><span class="p">(</span><span class="s">dinner</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">9pm</span><span class="p">&#39;);</span> <span class="c1"># We eat dinner at 9pm</span>
</code></pre></div><p>参数可以有多个名字, 如果你的用户有些是英国人, 有些是美国人, 你可能这样写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">paint-rectangle</span><span class="p">(</span>
    <span class="o">:</span><span class="nv">$x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">:</span><span class="nv">$y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">:</span><span class="nv">$width</span> <span class="o">=</span> <span class="mi">100</span><span class="o">,</span>
    <span class="o">:</span><span class="nv">$height</span> <span class="o">=</span> <span class="mi">50</span><span class="o">,</span>
    <span class="p">:</span><span class="s">color</span><span class="p">(:</span><span class="s">colour</span><span class="p">(</span><span class="nv">$c</span><span class="p">)))</span> <span class="p">{</span>

    <span class="c1"># print a piece of SVG that represents a rectangle</span>
    <span class="nb">say</span> <span class="k">qq</span><span class="p">[</span><span class="s2">&lt;rect x=&#34;</span><span class="nv">$x</span><span class="s2">&#34; y=&#34;</span><span class="nv">$y</span><span class="s2">&#34; width=&#34;</span><span class="nv">$width</span><span class="s2">&#34; height=&#34;</span><span class="nv">$height</span><span class="s2">&#34; &gt;</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1"># both calls work the same</span>
<span class="n">paint-rectangle</span> <span class="p">:</span><span class="s">color</span><span class="p">&lt;</span><span class="s">Blue</span><span class="p">&gt;;</span>
<span class="n">paint-rectangle</span> <span class="p">:</span><span class="s">colour</span><span class="p">&lt;</span><span class="s">Blue</span><span class="p">&gt;;</span>

<span class="c1"># of course you can still fill the other options</span>
<span class="n">paint-rectangle</span> <span class="p">:</span><span class="s">width</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">height</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">colour</span><span class="p">&lt;</span><span class="s">Blue</span><span class="p">&gt;;</span>
</code></pre></div><p><strong>可选的命名参数语法</strong></p>
<p>命名变量通常是成对的（键值对）。写一个 <code>Pairs</code> 有多种方式。各种方法的不同之处就是清晰性, 因为每种选择提供不同的引述机制。下面的三种调用是一样的意思：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">announce-time</span><span class="p">(</span><span class="s">dinner</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">9pm</span><span class="p">&#39;);</span>
<span class="nf">announce-time</span><span class="p">(:</span><span class="s">dinner</span><span class="p">(&#39;</span><span class="s1">9pm</span><span class="p">&#39;));</span>
<span class="nf">announce-time</span><span class="p">(:</span><span class="s">dinner</span><span class="p">&lt;</span><span class="s">9pm</span><span class="p">&gt;);</span>
</code></pre></div><p>如果传递的是布尔值, 你可以省略键值对的键值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">toggle-blender</span><span class="p">(</span> <span class="p">:</span><span class="s">enabled</span><span class="p">);</span> <span class="c1"># enables the blender 开启果汁机</span>
<span class="nf">toggle-blender</span><span class="p">(:!</span><span class="s">enabled</span><span class="p">);</span> <span class="c1"># disables the blender 关闭果汁机</span>
</code></pre></div><p>形如 <code>:name</code> 但不带值的命名参数有一个隐式的布尔真值 <code>Bool::True</code>。它的对立形式是 <code>:!name</code> , 其值是隐式的布尔假值 <code>Bool::false</code>。如果你使用变量创建了一个 <code>Pair</code>, 你可以将变量名作为 <code>Pair</code> 的键复用.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$dinner</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">9pm</span><span class="p">&#39;;</span>
<span class="n">announce-dinner</span> <span class="o">:</span><span class="nv">$dinner</span><span class="p">;</span> <span class="c1"># same as dinner =&gt; $dinner;</span>
</code></pre></div><pre><code>                        Pair forms and their meanings.

    Shorthand      Long form                          Description
:allowed           allowed =&gt; Bool::True               Boolean flag
:!allowed          allowed =&gt; Bool::False              Boolean flag
:bev&lt;tea coffee&gt;   bev =&gt; ('tea', 'coffee')            List
:times[1, 3]       times =&gt; [1, 3]                     Array
:opts{ a =&gt; 2 }    opts =&gt; { a =&gt; 2 }                  Hash
:$var              var =&gt; $var Scalar                  variable
:@var              var =&gt; @var Array                   variable
:%var              var =&gt; %var Hash                    variable
:&amp;var              vaf =&gt; &amp;var Callable/ Subroutine    variable
</code></pre>
<p>你可以使用在任何可以使用 Pair 对象的上下文使用表中的任意一种形式. 例如, 生成散列:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># TODO: better example</span>
<span class="k">my</span> <span class="nv">$black</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">%color-popularities</span> <span class="o">=</span> <span class="o">:</span><span class="nv">$black</span><span class="o">,</span> <span class="p">:</span><span class="s">blue</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">,</span> <span class="s">red</span> <span class="o">=&gt;</span> <span class="mi">18</span>, <span class="p">:</span><span class="s">white</span><span class="p">&lt;</span><span class="s">0</span><span class="p">&gt;;</span>

<span class="c1"># 与此相同：</span>
<span class="c1"># my %color-popularities =</span>
<span class="c1"># black =&gt; 12,</span>
<span class="c1"># blue =&gt; 8,</span>
<span class="c1"># red =&gt; 18,</span>
<span class="c1"># white =&gt; 0;</span>
</code></pre></div><p>最后, 通过位置而非名字传递一个已存在的 Pair 对象到子例程中, 要么把它放在圆括号中 ( 就像 (<code>:$thing</code>) ), 或者使用 <code>=&gt;</code> 操作符引起左侧的字符串: <code>&quot;thing&quot; =&gt; $thing</code>。</p>
<p><strong>参数的顺序</strong></p>
<p>当位置参数和命名参数都出现在签名中时, 所有的位置参数都要出现在命名参数之前：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">mix</span><span class="p">(</span><span class="nv">@ingredients</span><span class="o">,</span> <span class="o">:</span><span class="nv">$name</span><span class="p">)</span>    <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># OK</span>
<span class="k">sub</span> <span class="nf">notmix</span><span class="p">(</span><span class="o">:</span><span class="nv">$name</span><span class="o">,</span> <span class="nv">@ingredients</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># Error</span>
</code></pre></div><p>必须的位置参数要在可选的位置参数之前。然而, 命名参数没有这种限制。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">copy-machine</span><span class="p">(</span><span class="nv">$amount</span><span class="o">,</span> <span class="nv">$size</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">A4</span><span class="p">&#39;</span><span class="o">,</span> <span class="o">:</span><span class="nv">$color</span><span class="o">!,</span> <span class="o">:</span><span class="nv">$quality</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># OK</span>
<span class="k">sub</span> <span class="nf">fax-machine</span><span class="p">(</span><span class="nv">$amount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="nv">$number</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># Error</span>
</code></pre></div><h4 id="slurpy-参数">Slurpy 参数</h4>
<p>有时候, 你会希望让子例程接受任何数量的参数, 并且将所有这些参数收集到一个数组中。为了达到这个目的, 给签名添加一个数组参数, 就是在数组前添加一个 <code>*</code> 号前缀：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">shout-them</span><span class="p">(</span><span class="o">*</span><span class="nv">@words</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nv">@words</span> <span class="k">-&gt;</span> <span class="nv">$w</span> <span class="p">{</span>
        <span class="nb">print</span> <span class="nb">uc</span><span class="p">(&#34;</span><span class="nv">$w</span><span class="s2"> </span><span class="p">&#34;);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># 现在你可以传递项</span>
<span class="nf">shout-them</span><span class="p">(&#39;</span><span class="s1">go</span><span class="p">&#39;);</span>         <span class="c1"># GO</span>
<span class="nf">shout-them</span><span class="p">(&#39;</span><span class="s1">go</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">home</span><span class="p">&#39;);</span> <span class="c1"># GO HOME</span>
</code></pre></div><p>除了集合所有的值之外, slurpy 参数会展平任何它接收到的数组, 最后你只会得到一个展平的列表, 因此：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@words</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">go</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">home</span><span class="p">&#39;);</span>
<span class="nf">shout-them</span><span class="p">(</span><span class="nv">@words</span><span class="p">);</span>
</code></pre></div><p>会导致 <code>*@words</code> 参数有两个字符串元素, 而非只有单个数组元素。</p>
<p>你可以选择将某些参数捕获到位置参数中, 并让其它参数被吸进数组参数里。这种情况下, <code>slupy</code> 应该放到最后。相似地, <code>*%hash</code> slurps 所有剩下的未绑定的命名参数到散列 <code>%hash</code> 中。<code>Slurpy</code> 数组和散列允许你传递所有的位置参数和命名参数到另一个子例程中。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">
<span class="k">sub</span> <span class="nf">debug-wrapper</span><span class="p">(</span><span class="nv">&amp;code</span><span class="o">,</span> <span class="o">*</span><span class="nv">@positional</span><span class="o">,</span> <span class="o">*</span><span class="nv">%named</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">warn</span> <span class="p">&#34;</span><span class="s2">Calling &#39;</span><span class="nv">&amp;code</span><span class="o">.</span><span class="nf">name</span><span class="p">()</span><span class="s2">&#39; with arguments </span><span class="p">&#34;</span>
    <span class="o">~</span> <span class="p">&#34;</span><span class="nv">@positional</span><span class="o">.</span><span class="nf">perl</span><span class="p">()</span><span class="s2">, </span><span class="nv">%named</span><span class="o">.</span><span class="nf">perl</span><span class="p">()</span><span class="s2">\n</span><span class="p">&#34;;</span>
    <span class="nb">code</span><span class="p">(</span><span class="o">|</span><span class="nv">@positional</span><span class="o">,</span> <span class="o">|</span><span class="nv">%named</span><span class="p">);</span>
    <span class="nb">warn</span> <span class="p">&#34;</span><span class="s2">... back from &#39;</span><span class="nv">&amp;code</span><span class="o">.</span><span class="nf">name</span><span class="p">()</span><span class="s2">&#39;\n</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">debug-wrapper</span><span class="p">(</span><span class="nv">&amp;order-shrimps</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="s">from</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Atlantic Ocean</span><span class="p">&#39;);</span>
</code></pre></div><h3 id="返回值">返回值</h3>
<p>子例程也能返回值。之前本章中的 ASCII 艺术舞蹈例子会更简单当每个子例程返回一个新字符串：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%moves</span> <span class="o">=</span> <span class="s">hands-over-head</span> <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="p">&#39;</span><span class="s1">/o\ </span><span class="p">&#39;</span>   <span class="p">}</span>,
            <span class="s">bird-arms</span>       <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="p">&#39;</span><span class="s1">|/o\| </span><span class="p">&#39;</span> <span class="p">}</span>,
            <span class="s">left</span>            <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="p">&#39;</span><span class="s1">&gt;o </span><span class="p">&#39;</span>    <span class="p">}</span>,
            <span class="s">right</span>           <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="p">&#39;</span><span class="s1">o&lt; </span><span class="p">&#39;</span>    <span class="p">}</span>,
            <span class="s">arms-up</span>         <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="p">&#39;</span><span class="s1">\o/ </span><span class="p">&#39;</span>   <span class="p">};</span>

<span class="k">my</span> <span class="nv">@awesome-dance</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">arms-up bird-arms right hands-over-head</span><span class="p">&gt;;</span>

<span class="k">for</span> <span class="nv">@awesome-dance</span> <span class="k">-&gt;</span> <span class="nv">$move</span> <span class="p">{</span>
    <span class="nb">print</span> <span class="nv">%moves</span><span class="p">{</span><span class="nv">$move</span><span class="p">}</span><span class="o">.</span><span class="p">();</span>
<span class="p">}</span>

<span class="nb">print</span> <span class="p">&#34;</span><span class="s2">\n</span><span class="p">&#34;;</span>
</code></pre></div><p>子例程也能返回多个值（译者注：那不就是返回一个列表嘛）：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">menu</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">rand</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(&#39;</span><span class="s1">fish</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">white wine</span><span class="p">&#39;)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(&#39;</span><span class="s1">steak</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">red wine</span><span class="p">&#39;);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="p">(</span><span class="nv">$food</span><span class="o">,</span> <span class="nv">$beverage</span><span class="p">)</span> <span class="o">=</span> <span class="nf">menu</span><span class="p">();</span>
</code></pre></div><p>如果你把 return 语句排除在外, 则在子例程内部运行的最后一个语句产生的值被返回。这意味着前一个例子可以简化为：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">menu</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">rand</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">fish</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">white wine</span><span class="p">&#39;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">steak</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">red wine</span><span class="p">&#39;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="p">(</span><span class="nv">$food</span><span class="o">,</span> <span class="nv">$beverage</span><span class="p">)</span> <span class="o">=</span> <span class="nf">menu</span><span class="p">();</span>
</code></pre></div><p>记得：当子例程中的控制流极其复杂时, 添加一个显式的 return 会让代码更清晰, 所以 return 还是加上的好。
return 另外的副作用就是执行后立即退出子例程：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">create-world</span><span class="p">(</span><span class="o">*</span><span class="nv">%characteristics</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$world</span> <span class="o">=</span> <span class="n">World</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">%characteristics</span><span class="p">);</span>
    <span class="k">return</span> <span class="nv">$world</span> <span class="k">if</span> <span class="nv">%characteristics</span><span class="p">&lt;</span><span class="s">temporary</span><span class="p">&gt;;</span>

    <span class="nf">save-world</span><span class="p">(</span><span class="nv">$world</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>&hellip;并且你最好别放错你的新单词 <code>$word</code> 如果它是临时的。因为这是你要获取的仅有的一个。</p>
<h3 id="返回值的类型">返回值的类型</h3>
<p>像其它现代语言一样, Raku 允许你显式地指定子例程返回值的类型。这允许你限制从子例程中返回的值的类型。使用 <code>returns</code> 特性可以做到这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">double-up</span><span class="p">(</span><span class="nv">$i</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">$i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nb">Int</span> <span class="nv">$ultimate-answer</span> <span class="o">=</span> <span class="nf">double-up</span><span class="p">(</span><span class="mi">21</span><span class="p">);</span>  <span class="c1"># 42</span>
</code></pre></div><p>当然, 使用这个 <code>returns</code> 特性是可选的</p>
<h3 id="working-with-types">Working With Types</h3>
<p>很多子例程不能完整意义上使用任意参数工作, 但是要求参数支持确定的方法或有其它属性。这种情况下, 限制参数类型就有意义了, 诸如传递不正确值作为参数, 当调用子例程时, 这会引起 Raku 发出错误, 或者甚至在编译时, 如果编译器足够聪明来捕捉错误。</p>
<h4 id="基本类型">基本类型</h4>
<p>最简单的限制子例程接收可能的值的方法是在参数前写上类型名。例如, 一个子例程对其参数执行数值计算, 这要求它的参数类型是 Numeric：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">mean</span><span class="p">(</span><span class="nb">Numeric</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Numeric</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">mean</span> <span class="mf">2.5</span><span class="o">,</span> <span class="mf">1.5</span><span class="p">;</span>
<span class="nb">say</span> <span class="n">mean</span> <span class="p">&#39;</span><span class="s1">some</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">strings</span><span class="p">&#39;;</span>
</code></pre></div><p>产生输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Nominal type check failed for parameter &#39;$a&#39;;
expected Numeric but got Str instead
</code></pre></div><p>nominal 类型是一个人实际类型的名字, 这里是 Numeric。
如果多个参数有类型限制, 每个参数必须填充它绑定的参数限制的类型</p>
<h4 id="添加限制">添加限制</h4>
<p>有时, 类型的名字不足以描述参数的要求。这种情况下, 你可能使用 <code>where</code> 代码块添加一个额外的限制：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">circle-radius-from-area</span><span class="p">(</span><span class="nb">Real</span> <span class="nv">$area</span> <span class="k">where</span> <span class="p">{</span> <span class="nv">$area</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">})</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$area</span> <span class="o">/</span> <span class="no">pi</span><span class="p">)</span><span class="o">.</span><span class="nb">sqrt</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nf">circle-radius-from-area</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>  <span class="c1"># OK</span>
<span class="nb">say</span> <span class="nf">circle-radius-from-area</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="c1"># Error</span>
</code></pre></div><p>因为这种计算只对非负面积值有意义, 该子例程的参数包含了一个限制, 对于非负值它会返回真。如果这个限制返回一个假的值, 类型检查会失败, 当有些东西调用该子例程时。</p>
<p>where 之后的代码块是可选的。Raku 通过通过智能匹配 where 后面的参数来执行检查。
例如, 它可能接受在某一确定范围中的参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">set-volume</span><span class="p">(</span><span class="nb">Numeric</span> <span class="nv">$volume</span> <span class="k">where</span> <span class="mi">0</span><span class="o">..</span><span class="mi">11</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Turning it up to </span><span class="nv">$volume</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>或者你可以将参数限制为散列的键：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%in-stock</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Staropramen</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">8</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Mori</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">La Trappe</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">9</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">order-beer</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$name</span> <span class="k">where</span> <span class="nv">%in-stock</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Here&#39;s your </span><span class="nv">$name</span><span class="p">&#34;;</span>
    <span class="nv">%in-stock</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="nv">%in-stock</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">OH NO! That was the last </span><span class="nv">$name</span><span class="s2">, folks! :&#39;(</span><span class="p">&#34;;</span>
        <span class="nv">%in-stock</span><span class="o">.</span><span class="nb">delete</span><span class="p">(</span><span class="nv">$name</span><span class="p">);</span>
     <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="抽象参数和具体参数">抽象参数和具体参数</h3>
<p>下面检测变量是否定义。在 Raku 中这样写:</p>
<div class="highlight"><pre class="chroma"><code class="language-perl" data-lang="perl"> <span class="k">sub</span> <span class="nf">foo</span><span class="p">(Int:D $arg) {</span>
     <span class="c1"># Do something</span>
 <span class="p">}</span>
</code></pre></div><p>留意附加在参数类型后面的 <code>:D</code> 笑脸。这个动词表明给定的参数必须被绑定到一个具体的对象上。如果不是的话, 会抛出一个运行时异常。这就是为什么它那么高兴！作为对比, 动词 <code>:U</code> 用于表明该参数需要一个未定义的或抽象的对象。此外, 动词 <code>:_</code> 允许定义或未定义的值。实际上, 使用 <code>:_</code> 有点多余。</p>
<p>最后, 动词 <code>:T</code> 能用于表明参数只能是类型对象, 例如</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">say-foobar</span><span class="p">(</span><span class="nb">Int</span><span class="p">:</span><span class="s">T</span> <span class="nv">$arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">FOOBAR!</span><span class="p">&#39;;</span>
<span class="p">}</span>

<span class="nf">say-foobar</span><span class="p">(</span><span class="nb">Int</span><span class="p">);</span>
<span class="c1"># FOOBAR!</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[自定义 when]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-02-28-custom-when/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/?utm_source=atom_feed" rel="related" type="text/html" title="为最年轻的 Raku 贡献力量" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="related" type="text/html" title="如果集合如我所想" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-17-method-isd/?utm_source=atom_feed" rel="related" type="text/html" title="Method-ish" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/?utm_source=atom_feed" rel="related" type="text/html" title="模式分派" />
            
                <id>https://ohmyweekly.github.io/notes/2021-02-28-custom-when/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-28T00:00:00+08:00</published>
            <updated>2021-02-28T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Custom When</blockquote><p>我不太喜欢上一篇文章中使用匹配的语法。它的参数列表中的逗号看起来很奇怪，不合适。也许是因为我的眼睛习惯了给定的块。睡一觉就好了。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">accord</span><span class="p">(</span><span class="nv">&amp;c</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="n">CALLER::</span><span class="p">&lt;</span><span class="s">$_</span><span class="p">&gt;);</span> <span class="k">succeed</span><span class="p">)</span> <span class="k">if</span> <span class="nv">&amp;c</span><span class="o">.</span><span class="nb">cando</span><span class="p">(</span>\<span class="p">(</span><span class="n">CALLER::</span><span class="p">&lt;</span><span class="s">$_</span><span class="p">&gt;))</span> <span class="p">}</span>

<span class="k">given</span> <span class="n">Err</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">msg</span><span class="p">&lt;</span><span class="s">a</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="n">accord</span> <span class="k">-&gt;</span> <span class="n">Hold</span> <span class="p">(</span><span class="o">:</span><span class="nv">$key</span><span class="p">)</span> <span class="p">{</span> <span class="nb">put</span> „<span class="n">holding</span> <span class="nv">$key</span>“<span class="p">;</span> <span class="p">}</span>
    <span class="n">accord</span> <span class="k">-&gt;</span> <span class="n">Err</span> <span class="p">(</span><span class="o">:</span><span class="nv">$msg</span><span class="p">)</span> <span class="p">{</span> <span class="nb">warn</span> „<span class="n">ERR:</span> <span class="nv">$msg</span>“ <span class="p">}</span>
    <span class="k">default</span> <span class="p">{</span> <span class="nb">fail</span> ‚<span class="n">unsupported</span>‘ <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这是因为 <code>accord</code> 模仿了 <code>when</code> 的工作。它做了一些匹配，当 True 时调用一个块，并在每个块的结尾添加一个 success（通过抛出一个控制异常）。given 所做的只是设置主题。它还充当了 caller 的角色，所以我们可以通过一个伪包来访问它的 <code>$_</code>。利用 pointy 的签名来做<a href="https://docs.raku.org/type/Signature#Destructuring_arguments">解构</a>是相当强大的。把这个添加到 CORE 中可能是个好主意。</p>
<p>我们可能要把 Raku 的定义改成: &ldquo;Raku 是一种高度可组合的编程语言&rdquo;, 在这里，所有的东西都会落到实处。&quot;</p>
<p>更新一下。</p>
<p>有些情况下，<code>$_</code> 不是动态的。另外，success 正在抛出一个控制异常，而这些的处理程序是由 when 或默认添加的。这种情况是在编译时发生的，目前不能用宏来解决。第一个问题可以用黑魔法解决。后一个问题需要用默认块。我没有找到一种方法来提供一个合理的错误信息，如果缺少这个块。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">accord</span><span class="p">(</span><span class="nv">&amp;c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nb">nqp</span><span class="p">;</span>
    <span class="nv">$_</span> <span class="o">:=</span> <span class="nf">nqp::getlexcaller</span><span class="p">(&#39;</span><span class="s1">$_</span><span class="p">&#39;);</span>
    <span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="nv">$_</span><span class="p">);</span> <span class="k">succeed</span><span class="p">)</span> <span class="k">if</span> <span class="nv">&amp;c</span><span class="o">.</span><span class="nb">cando</span><span class="p">(</span>\<span class="p">(</span><span class="nv">$_</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nv">@possibilities</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$needle</span> <span class="p">{</span>
    <span class="k">given</span> <span class="nv">$needle</span> <span class="p">{</span>
        <span class="n">accord</span> <span class="k">-&gt;</span> <span class="n">Hold</span> <span class="p">(</span><span class="o">:</span><span class="nv">$key</span><span class="p">)</span> <span class="p">{</span> <span class="nb">put</span> „<span class="n">holding</span> <span class="nv">$key</span>“<span class="p">;</span> <span class="p">}</span>
        <span class="n">accord</span> <span class="k">-&gt;</span> <span class="n">Err</span> <span class="p">(</span><span class="o">:</span><span class="nv">$msg</span><span class="p">)</span> <span class="p">{</span> <span class="nb">warn</span> „<span class="n">ERR:</span> <span class="nv">$msg</span>“ <span class="p">}</span>
        <span class="k">default</span> <span class="p">{</span> <span class="nb">warn</span> ‚<span class="n">unsopported</span>‘ <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>原文链接: <a href="https://gfldex.wordpress.com/2021/02/25/custom-when/">https://gfldex.wordpress.com/2021/02/25/custom-when/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/raku" term="raku" label="Raku" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[为最年轻的 Raku 贡献力量]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="related" type="text/html" title="如果集合如我所想" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-16T00:00:00+08:00</published>
            <updated>2021-02-16T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Contributing to Raku</blockquote><p>在过去的几周里，我看到了一些<a href="https://mydeveloperplanet.com/2021/01/20/how-to-start-contributing-to-open-source/">文章</a>和<a href="https://youtu.be/GAqfMNB-YBU">视频</a>，讲述了在开源软件中构思是多么的伟大。这次我又想起了另一篇旧文<a href="http://strangelyconsistent.org/blog/perl-6-is-my-mmorpg">Raku 是我的 MMORPG</a>。它说，你可以从以下几个方面受益于开源软件。比如说，可以做一个大侠，基于一些开源软件来写软件。作为写手，可以写博客、微博等，对所选软件产生兴趣。或者你可以成为一个法师 - 实现新的功能和修复 bug。今天小编就带着弓箭手来告诉大家如何成为 <a href="https://raku.org/">Raku</a> 编程语言的法师。</p>
<h2 id="选择一个任务">选择一个任务</h2>
<p>让我们挑选一些编译器的 bug，并修复它。让我们去 <a href="https://rakudo.org/">Rakudo</a> 编译器 <a href="https://github.com/rakudo/rakudo/issues">issues</a>中选择我们想要修复的 bug。我滚动了一下 bug 列表，遇到了解析 - 运气不错，我前段时间一直在研究<a href="https://www.apress.com/gp/book/9781484232279">编译器语法</a>，看了一本这方面的好书。找到了四个问题。</p>
<p><img src="https://rakurs.atroxaper.net/assets/img/posts/2021-02-13-contributing-raku-1.png" alt="img"></p>
<ol>
<li>标签为 LTA （Less Than Awesome - 当真实行为与直觉预期不同时）- 我们暂时把它划掉。</li>
<li>标签 &ldquo;需要共识&rdquo; - 我们只想修复一个不复杂的 bug - 肯定要划掉。</li>
<li>标签为 &ldquo;grammar and actions&rdquo; 的关于一个可能死的代码是一个很好的候选人的第一个任务。</li>
</ol>
<p>任务确定后，现在我们需要配置工作环境。在 Windows、Linux 和 macOS 中，一切应该都差不多。我将通过 macOS 的例子来告诉你。</p>
<h2 id="建立工作环境">建立工作环境</h2>
<p>为源码和我们建立的编译器建立文件夹。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">mkdir ~/dev-rakudo <span class="o">&amp;&amp;</span> mkdir ~/dev-rakudo-install
</code></pre></div><p>Rakudo 编译器由三部分组成。</p>
<ol>
<li>虚拟机。现在有三种 - JVM、JS 和 MoarVM。我们以 MoarVM 为最稳定的一个。</li>
<li>NQP（Not Quite Perl），是一种低级（中级）语言的实现，它是 Raku 的一个 &ldquo;子集&rdquo;。虚拟机可以执行用 NQP 编写的代码。</li>
<li>Rakudo 编译器本身，用 NQP 和 Raku 编写。</li>
</ol>
<p>下载并编译这三个组件。我分别花了一分半钟、半分钟和两分半钟才编好。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:MoarVM/MoarVM.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> MoarVM
perl Configure.pl --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install

<span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:Raku/nqp.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> nqp
perl Configure.pl --backend<span class="o">=</span>moar --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install

<span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:rakudo/rakudo.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> rakudo
perl Configure.pl --backend<span class="o">=</span>moar --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install
</code></pre></div><p>注意参数。<code>--prefix</code> 显示了 <code>make install</code> 命令后可执行文件的复制位置，<code>--backend=moar</code> 表示正在使用的虚拟机，而 <code>-j 4</code> 则要求跨多线程并行化（以防加快进度）。现在我们已经建立了 Rakudo 编译器 <code>~/dev-rakudo-install/bin/raku</code>。我们还需要官方的编译器测试套件。你应该把它和它的代码一起放在文件夹里。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">cd</span> ~/dev-rakudo/rakudo <span class="o">&amp;&amp;</span> git clone https://github.com/Raku/roast.git t/spec
</code></pre></div><p>我们先进行测试。这种情况很常见，有些测试甚至在新的变化之前就失败了。我们需要辨别出来，这样以后就不会害怕这些变化破坏了一些不必要的东西。</p>
<p>这里和下面我将在 <code>~/dev-rakudo/rakudo</code> 文件夹中工作，除非另有说明。</p>
<pre><code>&gt; make spectest
[...]
Test Summary Report
-------------------
t/spec/S32-str/utf8-c8.t    (Wstat: 65280 Tests: 54 Failed: 0)
  Non-zero exit status: 255
  Parse errors: Bad plan.  You planned 66 tests but ran 54.
Files=1346, Tests=117144, 829 wallclock secs (27.70 usr  6.04 sys + 2638.79 cusr 210.98 csys = 2883.51 CPU)
Result: FAIL
make: *** [m-spectest5] Error 1
</code></pre><p>14分钟内共运行了1,346个文件中的117,144次测试。一些与utf8相关的测试由于某种原因失败了，其他的都能正常工作。我们已经准备好去工作了!</p>
<h2 id="让我们来看看问题的陈述">让我们来看看问题的陈述</h2>
<p>问题陈述说，某个元运算符 <code>R</code> 在 colonpair 上出了问题。我打开文档，搜索 R 这个词，但下拉列表中没有这个名字的元运算符。我试着输入 metaop，看到的是反向元操作符(R)。原来，如果你想把二元运算的操作数按相反的顺序写出来，你可以在其符号前使用前缀 R。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">3</span> <span class="ow">R</span><span class="o">-</span> <span class="mi">2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># Output: True</span>
</code></pre></div><p>Colonpair 是命名对的语法。它看起来就像名字前面有一个冒号，前面有一个括号，有一个值。例如 <code>:foo(42)</code> 是一个名称为 <code>foo</code>、值为 <code>42</code> 的对儿。这个语法通常用于在调用函数时，向函数传递一个命名参数中的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-with-named-parameter</span><span class="p">(</span><span class="o">:</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-with-named-parameter</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1"># Output: 42</span>
</code></pre></div><p>如果一个函数参数不是命名的，而是位置的，那么在用命名对调用时，就会出现编译错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-without-named-parameter</span><span class="p">(</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># &lt;- 没有冒号</span>
  <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-without-named-parameter</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1"># Unexpected named argument &#39;foo&#39; passed</span>
</code></pre></div><p>如果你在调用这样的函数时用括号包围一个参数，整个参数对将被传递到位置参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-without-named-parameter</span><span class="p">(</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-without-named-parameter</span><span class="p">((:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">)));</span> <span class="c1"># Output: foo =&gt; 42</span>
</code></pre></div><p>在 Raku 中，你可以写一个函数来捕获所有传递给它的参数并分析它们。这是在单个参数 - 捕获前用竖线完成的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-with-capture</span><span class="p">(</span><span class="o">|</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># &lt;- 参数捕获</span>
  <span class="nb">say</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-with-capture</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>     <span class="c1"># Output: \(:foo(42))</span>
<span class="nf">sub-with-capture</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>           <span class="c1"># Output: \(42)</span>
<span class="nf">sub-with-capture</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">3</span> <span class="ow">Z</span><span class="o">-</span> <span class="mi">2</span><span class="p">));</span> <span class="c1"># Output: \(:foo((1,).Seq))</span>
<span class="nf">sub-with-capture</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">3</span> <span class="ow">R</span><span class="o">-</span> <span class="mi">2</span><span class="p">));</span> <span class="c1"># Output: \(-1)</span>
</code></pre></div><p>倒数第二行使用了 Z 元操作符 - zip 操作符。它将左右两部分作为一个列表，按顺序每次从它们中抽取一个元素，并进行操作，从而形成一个序列。</p>
<p>在最后一行，只用了我们需要的 R 元操作符。在这种情况下，它不是一个对，而是一个常量，它被传递到函数中。我们可以假设这是元运算符工作方式的一些特殊性，但用 Z 的例子表明并非如此。其实这是一个 bug - 当一个对被传递到一个使用 R 元运算符的函数中时，它的值会被转换。</p>
<h2 id="我们需要一个新的测试">我们需要一个新的测试</h2>
<p>为了确保未来的变化能够修复错误的行为，我们需要写一个新的测试。在测试文件中不难找到 R 元操作符的测试（<a href="https://github.com/Raku/roast/blob/fea1d16d993eb851d2935155e0b0d074fa3593bf/S03-metaops/reverse.t">S03-metops/reverse.t</a>）。下面我将补充以下测试。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># https://github.com/rakudo/rakudo/issues/1632</span>
<span class="p">{</span>
  <span class="k">sub</span> <span class="nf">subroutine</span><span class="p">(</span><span class="nv">$expected</span><span class="o">,</span> <span class="o">|</span><span class="n">actual</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">is</span> <span class="nc">actual</span><span class="o">.</span><span class="nb">gist</span><span class="o">,</span> <span class="nv">$expected</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Сolonpair exists</span><span class="p">&#34;</span>
  <span class="p">}</span>

  <span class="nf">subroutine</span><span class="p">(&#39;</span><span class="s1">\(:foo(-1))</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">foo</span><span class="p">(</span><span class="mi">3</span> <span class="ow">R</span><span class="o">-</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div><p>该测试有一个功能，有两个参数 - 正常和捕获。在函数体中，第一个参数和传递的 Capture 的字符串表示进行比较。你可以使用 <code>make</code> 对新构建的编译器进行单独测试。</p>
<pre><code>&gt; make t/spec/S03-metaops/reverse.t
[...]
ok 69 - [R~]=
not ok 70 - Colonpair exists
# Failed test 'Colonpair exists'
# at t/spec/S03-metaops/reverse.t line 191
# expected: '\(:foo(-1))'
#      got: '\(-1)'
# You planned 69 tests, but ran 70
# You failed 1 test of 70
</code></pre><p>你可以看到，测试失败了（如预期）。还有一个单独的说明，系统预计69次测试，但收到70次。这是基于 TAP 的测试系统的特点 - 必须在文件的顶部修正传递给 <code>plan</code> 函数的数字。现在测试崩溃了，但编号没有受到影响。你可以开始修复它。</p>
<h2 id="凝视法">凝视法</h2>
<p>一开始我很相信任务上的标签 - 如果是解析的话，一定是源码解析阶段的某个地方出现了问题。目前我的认识如下：</p>
<ol>
<li>基础解析器代码在文件 <code>rakudo/src/Perl6/Grammar.nqp</code> 中。</li>
<li>这个解析器是从 <code>nqp/src/HLL/Grammar.nqp</code> 文件中的基础解析器继承的。</li>
<li>元操作符的解析和工作方式都差不多，你可以通过仔细观察来发现不同之处。</li>
</ol>
<p>我在基础解析器代码中找到了对元操作符的引用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">infix_prefix_meta_operator:sym</span>&lt;R&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">infixish</span><span class="p">(&#39;</span><span class="s1">R</span><span class="p">&#39;)&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">can_meta</span><span class="p">(</span><span class="nv">$&lt;infixish&gt;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">reverse the args of</span><span class="p">&#34;)&gt;</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="nv">O</span><span class="o">=.</span><span class="nf">revO</span><span class="p">(</span><span class="nv">$&lt;infixish&gt;</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>

<span class="k">token</span> <span class="nf">infix_prefix_meta_operator:sym</span>&lt;Z&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">infixish</span><span class="p">(&#39;</span><span class="s1">Z</span><span class="p">&#39;)&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">can_meta</span><span class="p">(</span><span class="nv">$&lt;infixish&gt;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">zip with</span><span class="p">&#34;)&gt;</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="sr">O(|</span><span class="nv">%list_infix</span><span class="sr">)</span><span class="p">&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>这需要对 Raku grammar 有一定的了解。据我所知，原来这两个元运算符在解析上并没有根本的区别。一段时间后，在解析器的源代码中挖得够多了，我开始怀疑解析工作是否正确。认为代码 <code>my $r = :foo(3 R- 2); say $r; # Output: foo =&gt; -1</code> 正确工作的建议 - 问题恰恰发生在调用函数时。显然，我白白相信了任务栏上的标签。</p>
<h2 id="编译器将帮助我们">编译器将帮助我们</h2>
<p>颇为迟钝的我想起了我从一开始就应该做的事情。Rakudo 编译器有 <code>--target</code> 调试开关。它取编译器阶段的名称，你想将其结果输出到控制台并退出。我想看看 <code>--target=parse</code>（因为我只知道这一个）。</p>
<p>我从 <code>~/dev-rakudo/rakudo</code> 文件夹中使用 <code>rakumo-m</code>，这样我就不必等待通过 <code>make install</code> 命令将所需文件复制到 <code>~/dev-rakudo-install</code>。简单的脚本可以这样运行。更复杂的脚本必须在 <code>make install</code> 之后从 <code>-install</code> 中运行。</p>
<pre><code>&gt; cat ~/test.raku
sub s(|c) { say c }
s(:foo(3 R- 2));
s(:foo(3 Z- 2));

&gt; ./rakudo-m --target=parse ~/test.raku
[...]
- args: (:foo(3 R- 2))
  - semiarglist: :foo(3 R- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 R- 2)
        - colonpair: :foo(3 R- 2)
          - identifier: foo
          - coloncircumfix: (3 R- 2)
            - circumfix: (3 R- 2)
              - semilist: 3 R- 2
                - statement: 1 matches
                  - EXPR: R- 2
[...]
- args: (:foo(3 Z- 2))
  - semiarglist: :foo(3 Z- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 Z- 2)
        - colonpair: :foo(3 Z- 2)
          - identifier: foo
          - coloncircumfix: (3 Z- 2)
            - circumfix: (3 Z- 2)
              - semilist: 3 Z- 2
                - statement: 1 matches
                  - EXPR: Z- 2
[...]
</code></pre><p>结论：R 和 Z 的解析是一样的。</p>
<h2 id="这不是解析">这不是解析</h2>
<p>所有被解析的东西都会被传递给所谓的 Action，把字词变成一棵语法树。在我们的例子中，Actions 位于文件 <code>rakudo/src/Perl6/Actions.nqp</code> 和 <code>nqp/src/HLL/Actions.nqp</code> 中。这里就比较容易搞清楚了，毕竟是代码，是 grammar。</p>
<p>我在主 Actions 中找到了以下代码。</p>
<pre><code>[...]
elsif $&lt;infix_prefix_meta_operator&gt; {
[...]
  if    $metasym eq 'R' { $helper := '&amp;METAOP_REVERSE'; $t := nqp::flip($t) if $t; }
  elsif $metasym eq 'X' { $helper := '&amp;METAOP_CROSS'; $t := nqp::uc($t); }
  elsif $metasym eq 'Z' { $helper := '&amp;METAOP_ZIP'; $t := nqp::uc($t); }
  
  my $metapast := QAST::Op.new( :op&lt;call&gt;, :name($helper), WANTED($basepast,'infixish') );
  $metapast.push(QAST::Var.new(:name(baseop_reduce($base&lt;OPER&gt;&lt;O&gt;.made)), :scope&lt;lexical&gt;))
    if $metasym eq 'X' || $metasym eq 'Z';
[...]
</code></pre><p>它说，如果在代码中解析了元操作符 <code>R</code>、<code>Z</code> 或 <code>X</code>，就应该在语法树中添加一些 <code>METAOP_</code> 函数调用。在 <code>Z</code> 和 <code>X</code> 的情况下，它会多一个参数，即某种还原函数。所有这些功能都可以在 <code>rakudo/src/core.c/metaops.pm6</code> 中找到。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">METAOP_REVERSE</span><span class="p">(</span>\<span class="n">op</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
  <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">args</span> <span class="p">{</span> <span class="n">op</span><span class="o">.</span><span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="o">.</span><span class="nb">reverse</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">METAOP_ZIP</span><span class="p">(</span>\<span class="n">op</span><span class="o">,</span> <span class="nv">&amp;reduce</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
 <span class="nf">nqp::if</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="nf">prec</span><span class="p">(&#39;</span><span class="s1">thunky</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">starts-with</span><span class="p">(&#39;</span><span class="s1">.</span><span class="p">&#39;)</span><span class="o">,</span>
  <span class="k">-&gt;</span> <span class="o">+</span><span class="n">lol</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$arity</span> <span class="o">=</span> <span class="n">lol</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
    <span class="o">[...]</span>
  <span class="p">}</span><span class="o">,</span>
  <span class="k">-&gt;</span> <span class="o">+</span><span class="n">lol</span> <span class="p">{</span>
    <span class="nb">Seq</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="n">Rakudo::Iterator</span><span class="o">.</span><span class="nf">ZipIterablesOp</span><span class="p">(</span><span class="n">lol</span><span class="o">,</span><span class="n">op</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>给你：</p>
<ol>
<li><code>\op</code> 是由我们的元操作符，即-，在前面的操作。</li>
<li>Trait <code>implementation-detail</code> 只是表明这不是公共代码，是编译器实现的一部分。</li>
<li>由于-操作没有笨重的特性，所以 <code>&amp;reduce</code> 函数不会参与计算，<code>Z</code> 的结果是 <code>Seq.new(...)</code>。</li>
<li><code>R</code> 的结果是一个操作调用 - 参数顺序相反。</li>
</ol>
<p>这时我想起还有一个 - 目标，即星。它将显示行动的结果。</p>
<pre><code>&gt; ./rakudo-m --target=ast ~/test.raku
[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-
    - QAST::Op(call &amp;METAOP_REVERSE) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;7&gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(:named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;8&gt; :before_promotion&lt;?&gt; Z-
    - QAST::Op(call &amp;METAOP_ZIP) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
      - QAST::Var(lexical &amp;METAOP_REDUCE_LEFT)
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
</code></pre><p>一如所料。除了调用不同的 <code>METAOP_</code> 函数外，所有的东西几乎都是一样的。从它们的代码中我们可以知道，原则上这些函数的不同之处在于返回值的类型 - 分别是 <code>Int</code> 和 <code>Seq</code>。众所周知，Raku 对不同类型的对象的上下文相当敏感&hellip;&hellip;我想，它关注的可能是返回值。我试着用下面的方式修改代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">METAOP_REVERSE</span><span class="p">(</span>\<span class="n">op</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
  <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">args</span> <span class="p">{</span> <span class="nb">Seq</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="o">.</span><span class="nb">reverse</span><span class="p">))</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>编译、运行。</p>
<pre><code>&gt; make
[...]
Stage start      :   0.000
Stage parse      :  61.026
Stage syntaxcheck:   0.000
Stage ast        :   0.000
Stage optimize   :   7.076
Stage mast       :  14.120
Stage mbc        :   3.941
[...]
&gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
</code></pre><p>一切都没有改变。所以，不是返回值&hellip;&hellip;想了想，不知道为什么结果又是 <code>-1</code> 而不是 <code>(-1,).Seq</code>。而且，从代码来看，<code>Seq</code> 根本就没有一个合适的构造函数。下一次，作为一些疯狂的事情，我尝试调用 <code>METAOP_REVERSE</code> 结果只是为了崩溃。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">METAOP_REVERSE</span><span class="p">(</span>\<span class="n">op</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
  <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">args</span> <span class="p">{</span> <span class="nb">die</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>编译、运行。</p>
<pre><code>&gt; make
[...]
&gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
</code></pre><p>怎么会呢？语法树中包含了对 <code>METAOP_REVERSE</code> 的调用，它的代码应该是折叠的，但计算仍然进行，我们得到 <code>-1</code>。</p>
<p>这些都不是《行动》。</p>
<p>这里我的目光落在编译器的构建日志上。它是一些阶段被列在那里。我随机试了 <code>--target=mast</code>。</p>
<pre><code>&gt; ./rakudo-m --target=mast ~/test.raku
[...]
MAST::Frame name&lt;s&gt;, cuuid&lt;1&gt;
  Local types: 0&lt;obj&gt;, 1&lt;obj&gt;, 2&lt;obj&gt;, 3&lt;obj&gt;, 4&lt;int&gt;, 5&lt;str&gt;, 6&lt;obj&gt;, 7&lt;obj&gt;, 8&lt;obj&gt;,
  Lexical types: 0&lt;obj&gt;, 1&lt;obj&gt;, 2&lt;obj&gt;, 3&lt;obj&gt;, 4&lt;obj&gt;,
  Lexical names: 0&lt;c&gt;, 1&lt;$¢&gt;, 2&lt;$!&gt;, 3&lt;$/&gt;, 4&lt;$*DISPATCHER&gt;,
  Lexical map: $!&lt;2&gt;, c&lt;0&gt;, $*DISPATCHER&lt;4&gt;, $¢&lt;1&gt;, $/&lt;3&gt;,
  Outer: name&lt;&lt;unit&gt;&gt;, cuuid&lt;2&gt;
[...]
</code></pre><p>某种不可读的矩阵。星号和桅杆之间有一个阶段性的优化。</p>
<pre><code>&gt; ./rakudo-m --target=optimize ~/test.raku
[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;infix:&lt;-&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;7&gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;8&gt; :before_promotion&lt;?&gt; Z-
    - QAST::Op(callstatic &amp;METAOP_ZIP) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
      - QAST::Var(lexical &amp;METAOP_REDUCE_LEFT)
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
</code></pre><p>哈，就是这样。在优化阶段后，行将失踪。</p>
<ul>
<li><code>QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-.</code>
并将整个 <code>METAOP_REVERSE</code> 调用替换为通常的操作 <code>(&amp;infix:&lt;-&gt;)</code>。所以问题一定在优化器的某个地方。</li>
</ul>
<p>只有在 <code>optim_nameless_call</code> 方法中才会提到 <code>&amp;METAOP_ASSIGN</code>，其中 <code>QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;)</code>。显然，这个操作负责生成一个命名对 - 它已经有了一个名字（命名参数），它需要计算值。从优化 <code>_</code> 无名方法的执行路径来看，我们可以得出结论，我们对最后一个块感兴趣。</p>
<pre><code>[...]
  elsif self.op_eq_core($metaop, '&amp;METAOP_REVERSE') {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;&amp; nqp::elems($op) == 3;
    return QAST::Op.new(:op&lt;call&gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;
  }
[...]
</code></pre><p>让我提醒你，优化前的树是这样的。</p>
<pre><code>[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-
    - QAST::Op(call &amp;METAOP_REVERSE) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
    - QAST::Want &lt;wanted&gt; 3
    - QAST::Want &lt;wanted&gt; 2
[...]
</code></pre><p>而精简之后，是这样的。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;infix:&lt;-&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
    - QAST::Want &lt;wanted&gt; 3
[...]
</code></pre><p>也就是说，优化 <code>_nameless_call</code> 做了以下工作。</p>
<p>如果我们的 <code>QAST::Op+{QAST::SpecialArg}</code> 操作没有三个参数，如果 <code>METAOP_REVERSE</code> 调用没有一个正确的类型，我们就返回空。这不是我们的情况。
否则，我们将返回一个新的操作，代替我们的 <code>QAST::Op+{QAST::SpecialArg}</code> 操作，以相反的顺序调用 <code>&amp;infix:&lt;-&gt;</code> 参数。就是说，把结果打包成一对就没了。</p>
<p>在摸索了一下如何解决这个问题，并阅读了 <code>QAST::SpecialArg</code> 和 <code>QAST::Node</code> 的实现后，我想到了下面的代码。</p>
<pre><code>[...]
  elsif self.op_eq_core($metaop, '&amp;METAOP_REVERSE') {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;&amp; nqp::elems($op) == 3;
    my $opt_result := QAST::Op.new(:op&lt;call&gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;
    if $op.named { $opt_result.named($op.named) } # 添加选项 named 
    if $op.flat { $opt_result.flat($op.flat) }    # 添加选项 flat
    return $opt_result;
  }
[...]
</code></pre><p>还有木头。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call &amp;infix:&lt;-&gt; :named&lt;foo&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
    - QAST::Want &lt;wanted&gt; 3
[...]
</code></pre><p>命名的参数返回到它的位置。测试也开始通过。</p>
<pre><code>&gt; make t/spec/S03-metaops/reverse.t
[...]
All tests successful.
Files=1, Tests=70,  3 wallclock secs ( 0.03 usr  0.01 sys +  3.61 cusr  0.17 csys =  3.82 CPU)
Result: PASS
</code></pre><p>我们本可以就此打住，但这是编译器优化器的代码，它的结果是一个有两个整数参数的方法调用。我认为这在某种程度上是次优的。如果我们将返回表达式改为返回 <code>self.visit_op: $opt_result;</code>，对产生的非优化操作调用优化器，那么产生的树就会像这样。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Want+{QAST::SpecialArg}(:named&lt;foo&gt;)
    - QAST::WVal+{QAST::SpecialArg}(Int :named&lt;foo&gt;)
    - QAST::IVal(-1)
[...]
</code></pre><p>现在一切都很理想。</p>
<h2 id="分享成果">分享成果</h2>
<p>我们已经到了终点线。现在我们只需要分享我们的经验。</p>
<ol>
<li>重要的是：运行所有的 <code>make spectest</code> 测试，确保没有新的东西被破坏。</li>
<li>在 GitHub 上使用 Rakudo 编译器和测试制作 fork 仓库。</li>
<li>将 fork 仓库添加为新的 git 远程仓库。</li>
<li>cd ~/dev-rakudo/rakudo &amp;&amp; git remote add fork <!-- raw HTML omitted -->。</li>
<li>cd ~/dev-rakudo/t/spec &amp;&amp; git remote add fork <!-- raw HTML omitted -->。</li>
</ol>
<p>重要：确保两个仓库在 git 中都有正确的用户名和用户邮箱。</p>
<p>提交到两个版本库，详细说明你为什么做了哪些改动，并添加对原始问题跟踪器的引用。</p>
<p>运行提交。</p>
<pre><code>cd ~/dev-rakudo/rakudo &amp;&amp; git push fork
cd ~/dev-rakudo/t/spec &amp;&amp; git push fork
</code></pre><p>向两个仓库提出拉取请求。在他们的描述中，最好是相互参照和原任务。</p>
<h2 id="结论">结论</h2>
<p>对开源软件的贡献是：</p>
<ol>
<li>趣味性和趣味性。</li>
<li>给你的感觉是，你正在做一些有用的事情，你真的是。</li>
<li>让你认识新的有趣和专业的人（任何关于 Raku 的问题都会在 <code>#raku IRC</code> 频道中得到回答）。</li>
<li>解决非标准任务，没有截止日期的压力，是一种很好的体验。</li>
</ol>
<p>选择你觉得最舒服的角色等级，去做新的任务吧!</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Caesarean Substrings With Raku and Perl]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="related" type="text/html" title="如果集合如我所想" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-07T00:00:00+08:00</published>
            <updated>2021-02-07T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Caesarean Substrings With Raku and Perl</blockquote><p>[113] 发表于2021年1月30日。
这是我对 <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-097/">Perl 每周挑战#097</a> 的回应。</p>
<h2 id="挑战-0971-凯撒密码">挑战 #097.1: 凯撒密码</h2>
<p>给你一个只包含字母 <code>A..Z</code> 的字符串 <code>$S</code> 和一个数字 <code>$N</code>。
写一个脚本，用<a href="https://en.wikipedia.org/wiki/Caesar_cipher">凯撒密码</a>对给定的字符串 <code>$S</code> 进行加密，左移大小为 <code>$N</code>。</p>
<p>例子:
输入: $S = &ldquo;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&rdquo;, $N = 3
输出: &ldquo;QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD&rdquo;</p>
<p>Plain:    ABCDEFGHIJKLMNOPQRSTUVWXYZ
Cipher:   XYZABCDEFGHIJKLMNOPQRSTUVW</p>
<p>Plaintext:  THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG
Ciphertext: QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD</p>
<p>&ldquo;只用字母 <code>A...Z</code>&rdquo; 的表述是错误的，因为例子中也有几个空格。因此，应该允许这些空格。</p>
<p>文件: caesar-cipher</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">subset</span> <span class="nc">AZ-space</span> <span class="k">of</span> <span class="nb">Str</span> <span class="k">where</span> <span class="o">/^</span> <span class="p">&lt;</span><span class="s">[ A .. Z \s ]</span><span class="p">&gt;</span><span class="o">+</span> <span class="nv">$/</span><span class="p">;</span>   <span class="c1"># [1]</span>
<span class="k">subset</span> <span class="nc">PosInt</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">where</span> <span class="o">-</span><span class="mi">25</span> <span class="o">&lt;=</span> <span class="nv">$_</span> <span class="o">&lt;=</span> <span class="mi">25</span><span class="p">;</span>            <span class="c1"># [2]</span>

<span class="k">unit</span> <span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="n">AZ-space</span> <span class="nv">$S</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</span><span class="p">&#39;</span><span class="o">,</span>
               <span class="n">PosInt</span> <span class="nv">$N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">);</span>                         <span class="c1"># [3]</span>

<span class="nb">say</span> <span class="nv">$S</span><span class="o">.</span><span class="nb">comb</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="nf">caesar</span><span class="p">(</span><span class="nv">$_</span><span class="o">,</span> <span class="nv">$N</span><span class="p">)</span> <span class="p">})</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>              <span class="c1"># [4]</span>

<span class="k">sub</span> <span class="nf">caesar</span> <span class="p">(</span><span class="nv">$char</span><span class="o">,</span> <span class="nv">$shift</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nv">$char</span> <span class="k">if</span> <span class="nv">$char</span> <span class="ow">eq</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;;</span>                        <span class="c1"># [5]</span>

  <span class="k">my</span> <span class="nv">$code</span> <span class="o">=</span> <span class="nv">$char</span><span class="o">.</span><span class="nb">ord</span><span class="p">;</span>                                <span class="c1"># [6]</span>

  <span class="nv">$code</span> <span class="o">-=</span> <span class="nv">$shift</span><span class="p">;</span>                                     <span class="c1"># [7]</span>

  <span class="nv">$code</span> <span class="o">+=</span> <span class="mi">26</span> <span class="k">if</span> <span class="nv">$code</span> <span class="o">&lt;</span> <span class="mi">65</span><span class="p">;</span>  <span class="c1"># &#39;A&#39;                    # [8]</span>
  <span class="nv">$code</span> <span class="o">-=</span> <span class="mi">26</span> <span class="k">if</span> <span class="nv">$code</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">;</span>  <span class="c1"># &#39;Z&#39;                    # [8a]</span>

  <span class="k">return</span> <span class="nv">$code</span><span class="o">.</span><span class="nb">chr</span><span class="p">;</span>                                    <span class="c1"># [9]</span>
<span class="p">}</span>
</code></pre></div><p>[1] 所允许的字符 (或 «特定领域字母»).</p>
<p>[2] 挑战说左移值是一个数字。允许除整数以外的任何东西是没有意义的，所以我把值限制在这个类型。负值应该是可以的，它们意味着右移值（而不是左移）。</p>
<p>[3] 参数，默认值为挑战中给出的值。</p>
<p>[4] 将字符串分割成单个字符（用梳子(comb)，在每个字符上应用 &ldquo;caesar&rdquo; 函数（用map），再次将字符连接成一个字符串（用join），然后打印出来。</p>
<p>[5] 不移动空格。</p>
<p>[6] 获取字符的代码点。</p>
<p>[7] 减去移位值（当我们向左移位时，或在字母表中降低移位值）。</p>
<p>[8] 绕回, 如果我们移出A-Z范围，这里为更低 - 或更高的 [8b]。</p>
<p>[9] 获取指定代码点的字符。</p>
<p>查看 docs.raku.org/routine/ord 获取更多关于 ord 的信息。</p>
<p>查看 docs.raku.org/routine/chr 获取更多关于 chr 的信息。</p>
<p>运行它:</p>
<pre><code>$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
</code></pre><p>Raku 有一个 ords 变体，它接收一整个字符串，而不是一个字符作为 ord。还有 chrs，它接收一个代码点数组，并将它们变成一个字符串，而不是像 chr 那样接收一个字符的代码点。让我们用它们来写一个更短的程序。</p>
<p>文件: caesar-cipher-map</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">subset</span> <span class="nc">AZ-space</span> <span class="k">of</span> <span class="nb">Str</span> <span class="k">where</span> <span class="o">/^</span> <span class="p">&lt;</span><span class="s">[ A .. Z \s ]</span><span class="p">&gt;</span><span class="o">+</span> <span class="nv">$/</span><span class="p">;</span>
<span class="k">subset</span> <span class="nc">PosInt</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">where</span> <span class="o">-</span><span class="mi">25</span> <span class="o">&lt;=</span> <span class="nv">$_</span> <span class="o">&lt;=</span> <span class="mi">25</span><span class="p">;</span>

<span class="k">unit</span> <span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="n">AZ-space</span> <span class="nv">$S</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</span><span class="p">&#39;</span><span class="o">,</span>
               <span class="n">PosInt</span> <span class="nv">$N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">);</span>

<span class="nb">say</span> <span class="nf">caesar</span><span class="p">(</span><span class="nv">$S</span><span class="o">,</span> <span class="nv">$N</span><span class="p">);</span>

<span class="k">sub</span> <span class="nf">caesar</span> <span class="p">(</span><span class="nv">$string</span><span class="o">,</span> <span class="nv">$shift</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nv">$string</span><span class="o">.</span><span class="nb">ords</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span><span class="nv">$_</span> <span class="o">==</span> <span class="mi">32</span> <span class="o">??</span> <span class="mi">32</span> <span class="o">!!</span> <span class="p">((</span><span class="nv">$_</span> <span class="o">-</span> <span class="nv">$shift</span> <span class="o">-</span> <span class="mi">65</span><span class="p">)</span> <span class="nv">%</span> <span class="mi">26</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">65</span><span class="p">})</span><span class="o">.</span><span class="nb">chrs</span><span class="p">;</span>
    <span class="c1"># #################### # 1a ############# ############ # 1b  # 1c ## 1d</span>
<span class="p">}</span>
</code></pre></div><p>[1] 我们使用map来改变各个代码点。我们让代码点为32的空间单独存在[1a]。每一个其他的值我们都还原成0到25之间的数字（通过减去第一个字母的代码点（A：65）和移位值[1b]）。模数运算符 (%) 为我们处理负值，做正确的事情。例如：-2 % 26 -&gt; 24 [1c]。然后我们添加调整值到它们应该在的位置(从A到Z)[1d]，然后我们将整个数组的代码点变成一个字符串。</p>
<p>查看 docs.raku.org/routine/ords 获取更多关于 ords 的信息。</p>
<p>查看 docs.raku.org/routine/chrs 获取更多关于 chrs 的信息。</p>
<p>运行它的结果和之前一样。</p>
<pre><code>$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
</code></pre><h2 id="perl-版本">Perl 版本</h2>
<p>这是对第一个 Raku 版的直接翻译。</p>
<p>File: caesar-cipher-perl</p>
<div class="highlight"><pre class="chroma"><code class="language-perl" data-lang="perl"><span class="ch">#! /usr/bin/env perl</span>

<span class="k">use</span> <span class="nn">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">feature</span> <span class="s">&#39;say&#39;</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">feature</span> <span class="s">&#39;signatures&#39;</span><span class="p">;</span>

<span class="k">no</span> <span class="nn">warnings</span> <span class="s">&#34;experimental::signatures&#34;</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$S</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="sr">//</span> <span class="s">&#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39;</span><span class="p">;</span>

<span class="nb">die</span> <span class="s">&#34;Illegal characters&#34;</span> <span class="k">unless</span> <span class="nv">$S</span> <span class="o">=~</span><span class="sr"> /^[A-Z\s]+$/</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$N</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="sr">//</span> <span class="mi">3</span><span class="p">;</span>

<span class="nb">die</span> <span class="s">&#34;Illegal shift $N&#34;</span> <span class="k">if</span> <span class="nv">$N</span> <span class="o">!~</span> <span class="sr">/^\-?\d+$/</span> <span class="o">||</span> <span class="nv">$N</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">25</span> <span class="o">||</span> <span class="nv">$N</span> <span class="o">&gt;</span> <span class="mi">25</span><span class="p">;</span>

<span class="n">say</span> <span class="nb">join</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nb">map</span> <span class="p">{</span> <span class="n">caesar</span><span class="p">(</span><span class="nv">$_</span><span class="p">,</span> <span class="nv">$N</span><span class="p">)</span> <span class="p">}</span> <span class="nb">split</span><span class="p">(</span><span class="sr">//</span><span class="p">,</span> <span class="nv">$S</span><span class="p">));</span>

<span class="k">sub</span> <span class="nf">caesar</span> <span class="p">($char, $shift)
</span><span class="p">{</span>
  <span class="k">return</span> <span class="nv">$char</span> <span class="k">if</span> <span class="nv">$char</span> <span class="ow">eq</span> <span class="s">&#34; &#34;</span><span class="p">;</span>

  <span class="k">my</span> <span class="nv">$code</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="nv">$char</span><span class="p">);</span>

  <span class="nv">$code</span> <span class="o">-=</span> <span class="nv">$shift</span><span class="p">;</span>

  <span class="nv">$code</span> <span class="o">+=</span> <span class="mi">26</span> <span class="k">if</span> <span class="nv">$code</span> <span class="o">&lt;</span> <span class="mi">65</span><span class="p">;</span>  <span class="c1"># &#39;A&#39;</span>
  <span class="nv">$code</span> <span class="o">-=</span> <span class="mi">26</span> <span class="k">if</span> <span class="nv">$code</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">;</span>  <span class="c1"># &#39;Z&#39;</span>

  <span class="k">return</span> <span class="nb">chr</span><span class="p">(</span><span class="nv">$code</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>运行它的结果和 Raku 版一样。</p>
<pre><code>$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
</code></pre><h2 id="挑战-0972二进制子字符串binary-substrings">挑战 #097.2：二进制子字符串(Binary Substrings)</h2>
<p>给你一个二进制字符串 <code>$B</code> 和一个整数 <code>$S</code>。</p>
<p>写一个脚本来拆分大小为 <code>$S</code> 的二进制字符串 <code>$B</code>，然后找出使其相同的最小翻转次数。</p>
<p>例 1:
输入: $B = “101100101”, $S = 3
输出: 1</p>
<p>二进制子字符串:
&ldquo;101&rdquo;: 0 flip
&ldquo;100&rdquo;: 1 flip to make it &ldquo;101&rdquo;
&ldquo;101&rdquo;: 0 flip</p>
<p>例 2:
输入 $B = “10110111”, $S = 4
输出: 2</p>
<p>二进制子字符串:
&ldquo;1011&rdquo;: 0 flip
&ldquo;0111&rdquo;: 2 flips to make it &ldquo;1011&rdquo;</p>
<p>我们先从第一个例子中的二进制子字符串中砍掉3个字符块。</p>
<pre><code>&gt; say &quot;101100101&quot;.comb(3);   # -&gt; (101 100 101)
&gt; say &quot;1011001010&quot;.comb(3);  # -&gt; (101 100 101 0)
</code></pre><p>第二行显示了如果长度不匹配会发生什么。这就给了我们一个非法的值，因为我们不能将一位数翻转为三位数的值。所以我们必须添加一个检查。</p>
<p>然后我们将第一个子串与其余的子串进行比较，一次一个。在这里使用bitwise XOR（Exclusive OR）运算符是一个合理的选择。这给了我们一个二进制值，其中1的数量就是该子串的翻转次数。Raku确实有一个XOR运算符。+^. 但是它 &ldquo;将两个参数都强制为Int，并进行位智XOR操作&rdquo;(根据文档&quot;；参见docs.raku.org/language/operators#infix_+^)。</p>
<p>我们可以在进行XOR操作之前，将二进制值转换为十进制值。让我们试试。</p>
<p>获取翻转的次数。</p>
<pre><code>&gt; say (&quot;10101&quot;.parse-base(2) +^ &quot;10111&quot;.parse-base(2)).base(2).comb.sum;  # -&gt; 1
&gt; say (&quot;11101&quot;.parse-base(2) +^ &quot;10111&quot;.parse-base(2)).base(2).comb.sum;  # -&gt; 2
</code></pre><p>这当然可行，但需要大量的代码。所以我将使用一个更简单的方法 - 逐个比较每个数字。</p>
<p>File: binary-substring</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">subset</span> <span class="nc">BinaryString</span> <span class="k">where</span> <span class="o">/^</span> <span class="p">&lt;</span><span class="s">[01]</span><span class="p">&gt;</span><span class="o">+</span> <span class="nv">$/</span><span class="p">;</span>                    <span class="c1"># [1]</span>
<span class="k">subset</span> <span class="nc">PosInt</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">where</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>                           <span class="c1"># [2]</span>

<span class="k">unit</span> <span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="n">BinaryString</span> <span class="nv">$B</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">101100101</span><span class="p">&#39;</span><span class="o">,</span>               <span class="c1"># [1]</span>
               <span class="n">PosInt</span> <span class="nv">$S</span> <span class="k">where</span> <span class="nv">$B</span><span class="o">.</span><span class="nb">chars</span> <span class="nv">%%</span> <span class="nv">$S</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span>          <span class="c1"># [2]</span>
	       <span class="p">:</span><span class="s">v</span><span class="p">(</span><span class="o">:</span><span class="nv">$verbose</span><span class="p">));</span>

<span class="k">my</span> <span class="nv">@B</span>     <span class="o">=</span> <span class="nv">$B</span><span class="o">.</span><span class="nb">comb</span><span class="p">(</span><span class="nv">$S</span><span class="o">.</span><span class="nb">Int</span><span class="p">);</span>                                <span class="c1"># [3]</span>
<span class="k">my</span> <span class="nv">$first</span> <span class="o">=</span> <span class="nv">@B</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>                                       <span class="c1"># [4]</span>
<span class="k">my</span> <span class="nv">$total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                              <span class="c1"># [5]</span>

<span class="k">for</span> <span class="nv">@B</span> <span class="k">-&gt;</span> <span class="nv">$current</span>                                          <span class="c1"># [6]</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="nv">$flip</span> <span class="o">=</span> <span class="nf">bit-diff</span><span class="p">(</span><span class="nv">$first</span><span class="o">,</span> <span class="nv">$current</span><span class="p">);</span>                    <span class="c1"># [7]</span>
  <span class="nv">$total</span> <span class="o">+=</span> <span class="nv">$flip</span><span class="p">;</span>                                          <span class="c1"># [8]</span>
  <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">: </span><span class="nv">$first</span><span class="s2"> -&gt; </span><span class="nv">$current</span><span class="s2"> -&gt; Flip: </span><span class="nv">$flip</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$verbose</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nv">$total</span><span class="p">;</span>                                                 <span class="c1"># [9]</span>

<span class="k">sub</span> <span class="nf">bit-diff</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span>                                       <span class="c1"># [7]</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="nv">$flip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                             <span class="c1"># [10]</span>

  <span class="k">for</span> <span class="o">^</span><span class="nv">$a</span><span class="o">.</span><span class="nb">chars</span> <span class="k">-&gt;</span> <span class="nv">$index</span>                                   <span class="c1"># [11]</span>
  <span class="p">{</span>
    <span class="nv">$flip</span><span class="o">++</span> <span class="k">if</span> <span class="nv">$a</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="nv">$index</span><span class="o">,</span><span class="mi">1</span><span class="p">)</span> <span class="ow">ne</span> <span class="nv">$b</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="nv">$index</span><span class="o">,</span><span class="mi">1</span><span class="p">);</span>  <span class="c1"># [12]</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nv">$flip</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>[1] 确保二进制字符串是合法的（只包含 &ldquo;0 &ldquo;和 &ldquo;1&rdquo;）。</p>
<p>[2] 确保是一个正整数，同时确保字符串是被它偶数分割的。(例如，&ldquo;4 &ldquo;给我们提供了长度为4的子串，如果最后一个较短，程序将中止。)</p>
<p>[3] 梳子通常用于将一个字符串分割成单个字符，但我们可以通过指定长度来获得每个子字符串中的多个字符，比如这样。</p>
<p>[4] 例子首先将第一个子串与自己进行比较，给出零翻转。这是愚蠢的(ish)，所以我跳过这一点，把第一个子串移出。</p>
<p>[5] 结果会到这里。</p>
<p>[6] 对于每一个子串（除了第一个，见[4]）。</p>
<p>[7] 获取每个子串的翻转次数。</p>
<p>[8] 并将其添加到总数中。</p>
<p>[9] 打印它。</p>
<p>[10] 翻转的数量会在这里。</p>
<p>[11] 对于两个子串中的每个索引（具有相同的长度）。</p>
<p>[12] - 如果给定位置上的字符不同，则在总数的基础上加1，意味着移动。</p>
<p>See docs.raku.org/routine/comb for more information about comb.</p>
<p>运行它。</p>
<pre><code>$ ./binary-substring &quot;101100101&quot; 3
 1

$ ./binary-substring -v &quot;101100101&quot; 3
: 101 -&gt; 100 -&gt; Flip: 1
: 101 -&gt; 101 -&gt; Flip: 0
1

$ ./binary-substring &quot;10110111&quot; 4
2

$ ./binary-substring -v &quot;10110111&quot; 4
: 1011 -&gt; 0111 -&gt; Flip: 2
2
</code></pre><p>看起来不错。</p>
<h2 id="perl">Perl</h2>
<p>这是对 Raku 版本的直接翻译，只是我必须实现 &ldquo;comb&rdquo;。</p>
<p>文件： binary-substring-perl</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env perl</span>

<span class="k">use</span> <span class="nb">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="nb">feature</span> <span class="p">&#39;</span><span class="s1">say</span><span class="p">&#39;;</span>
<span class="k">use</span> <span class="nb">feature</span> <span class="p">&#39;</span><span class="s1">signatures</span><span class="p">&#39;;</span>
<span class="k">use</span> <span class="nn">Getopt::Long</span><span class="p">;</span>

<span class="k">no</span> <span class="nf">warnings</span> <span class="p">&#34;</span><span class="s2">experimental::signatures</span><span class="p">&#34;;</span>

<span class="k">my</span> <span class="nv">$verbose</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nf">GetOptions</span><span class="p">(&#34;</span><span class="s2">verbose</span><span class="p">&#34;</span>  <span class="o">=&gt;</span> \<span class="nv">$verbose</span><span class="p">);</span>

<span class="k">my</span> <span class="nv">$B</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="o">//</span> <span class="p">&#39;</span><span class="s1">101100101</span><span class="p">&#39;;</span>

<span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Not a binary number</span><span class="p">&#34;</span> <span class="k">unless</span> <span class="nv">$B</span> <span class="o">=~</span> <span class="o">/^[</span><span class="mo">01</span><span class="o">]+</span><span class="nv">$/</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$S</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span><span class="p">;</span>

<span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Not an integer</span><span class="p">&#34;</span> <span class="k">unless</span> <span class="nv">$S</span> <span class="o">=~</span> <span class="o">/^[</span><span class="mi">1</span><span class="o">-</span><span class="mi">9</span><span class="o">][</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="o">]*</span><span class="nv">$/</span><span class="p">;</span>
<span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Not a legal length</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nf">length</span><span class="p">(</span><span class="nv">$B</span><span class="p">)</span> <span class="nv">%</span> <span class="nv">$S</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">@B</span>     <span class="o">=</span>  <span class="nb">comb</span><span class="p">(</span><span class="nv">$B</span><span class="o">,</span> <span class="nv">$S</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$first</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@B</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">for</span> <span class="k">my</span> <span class="nv">$current</span> <span class="p">(</span><span class="nv">@B</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="nv">$flip</span> <span class="o">=</span> <span class="nf">bit_diff</span><span class="p">(</span><span class="nv">$first</span><span class="o">,</span> <span class="nv">$current</span><span class="p">);</span>
  <span class="nv">$total</span> <span class="o">+=</span> <span class="nv">$flip</span><span class="p">;</span>
  <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">: </span><span class="nv">$first</span><span class="s2"> -&gt; </span><span class="nv">$current</span><span class="s2"> -&gt; Flip: </span><span class="nv">$flip</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$verbose</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nv">$total</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">bit_diff</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="nv">$flip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="k">my</span> <span class="nv">$index</span> <span class="p">(</span><span class="mi">0</span> <span class="o">..</span> <span class="nf">length</span><span class="p">(</span><span class="nv">$a</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="nv">$flip</span><span class="o">++</span> <span class="k">if</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$index</span><span class="o">,</span><span class="mi">1</span><span class="p">)</span> <span class="ow">ne</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$b</span><span class="o">,</span> <span class="nv">$index</span><span class="o">,</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nv">$flip</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">comb</span> <span class="p">(</span><span class="nv">$string</span><span class="o">,</span> <span class="nv">$length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># [1]</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="nv">@result</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="nv">$string</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="nb">push</span><span class="p">(</span><span class="nv">@result</span><span class="o">,</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">$length</span><span class="p">));</span>
    <span class="nv">$string</span> <span class="o">=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="o">,</span> <span class="nv">$length</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nv">@result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>[1] 缺失的 Raku 例程 &ldquo;comb&rdquo;。可选的第二个参数指定了它所返回的每个子串中所包含的（第一个参数的）子串长度。</p>
<p>运行它的结果与 Raku 版本相同。</p>
<pre><code>$ ./binary-substring-perl &quot;101100101&quot; 3
1

$ ./binary-substring-perl -v &quot;101100101&quot; 3
: 101 -&gt; 100 -&gt; Flip: 1
: 101 -&gt; 101 -&gt; Flip: 0
1

$ ./binary-substring-perl &quot;101100111&quot; 3
2

$ ./binary-substring-perl -v &quot;101100111&quot; 3
: 101 -&gt; 100 -&gt; Flip: 1
: 101 -&gt; 111 -&gt; Flip: 1
2
</code></pre><p>就是这样。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/raku" term="raku" label="Raku" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[如果集合如我所想]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-07T00:00:00+08:00</published>
            <updated>2021-02-07T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>If Sets Would DWIM</blockquote><h1 id="if-sets-would-dwimhttpsdonaldhwtf202101if-sets-would-dwim"><a href="https://donaldh.wtf/2021/01/if-sets-would-dwim/">If Sets Would DWIM</a></h1>
<p>每当我在 Raku 中使用集合的时候，它们经常无法 <a href="https://docs.raku.org/language/glossary#DWIM">DWIM</a>。这是一个简短的探索，看看是否可以改进 DWIMminess。</p>
<p>我最近重新审视了我前段时间写的一个利用 <code>(-)</code> 集差运算符的脚本。这段代码有一个 bug 潜伏在那里，显而易见，因为下面的代码并没有按照我的直觉去做。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">  <span class="k">my</span> <span class="nv">@allowed</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">m c i p l o t</span><span class="p">&gt;;</span>
  <span class="k">my</span> <span class="nv">@chars</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">impolitic</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">comb</span><span class="p">;</span>

  <span class="k">my</span> <span class="nv">@remainder</span> <span class="o">=</span> <span class="nv">@allowed</span> <span class="ow">(-)</span> <span class="nv">@chars</span><span class="p">;</span>

  <span class="k">if</span> <span class="o">+</span><span class="nv">@remainder</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
     <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">pangram</span><span class="p">&#39;;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">unused: [</span><span class="p">{</span><span class="nv">@remainder</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;)}</span><span class="s2">]</span><span class="p">&#34;;</span>
  <span class="p">}</span>
<span class="n">unused:</span> <span class="o">[]</span>
</code></pre></div><p>错误的原因是 <code>(-)</code> 产生了一个 Set，而赋值给 <code>@remainder</code> 会产生1项的 Array。总是这样。但不方便的是，当它是一个空集合时，它就会字符串化为一个空字符串，这只是帮助掩盖了这个潜伏的错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@items</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="nb">d</span> <span class="nb">e</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@items</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">+</span><span class="nv">@items</span><span class="p">;</span>
</code></pre></div><pre><code>[Set.new()]
1
</code></pre><p>解决方法比较简单。只要不赋值给数组就可以了。使用一个标量容器来代替。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$items</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$items</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">+</span><span class="nv">$items</span><span class="p">;</span>
</code></pre></div><pre><code>Set.new(&quot;e&quot;,&quot;c&quot;)
2
</code></pre><p>甚至是关联容器也可以。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%items</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">%items</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">+</span><span class="nv">%items</span><span class="p">;</span>
</code></pre></div><pre><code>{:c(Bool::True), :e(Bool::True)}
2
</code></pre><p>或在赋值前明确地取出键的列表。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@items</span> <span class="o">=</span> <span class="p">(&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span><span class="p">)</span><span class="o">.</span><span class="nb">keys</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@items</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">+</span><span class="nv">@items</span><span class="p">;</span>
</code></pre></div><pre><code>[&quot;e&quot;, &quot;c&quot;]
2
</code></pre><p>很好，起作用了。只是不要用数组容器来处理 <code>Setty</code> 这样的东西。只是这并不能阻止我的直觉时不时地碰上这个错误。同一类的 bug 在我的代码中出现过好几次，因为它实在是太容易犯错了。Raku 不会告诉我，我做错了什么，因为也许是故意的。但重要的是， Raku 没有设法 DWIM。</p>
<p>我可以采取的另一个方法是养成添加类型信息的习惯。这样确实可以让 Raku 在我掉进这个陷阱的时候告诉我。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Str</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div><pre><code>Type check failed in assignment to @a; expected Str but got Set (Set.new(&quot;e&quot;,&quot;c&quot;))
  in sub  at EVAL_0 line 3
  in block &lt;unit&gt; at EVAL_0 line 5
  in block &lt;unit&gt; at -e line 1
</code></pre><p>这是一个明显的例子，添加类型信息有助于 Raku 编译器帮助我避免引入这种 bug。</p>
<h2 id="实验---为-set-自定义数组存储">实验 - 为 Set 自定义数组存储</h2>
<p>我开始研究核心设置(core setting)，看看可以做什么。我惊喜地发现，我可以在 <code>Array.STORE</code> 的多重分派中添加我正在寻找的语义。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nn">MONKEY</span><span class="p">;</span>

<span class="k">augment</span> <span class="k">class</span> <span class="nb">Array</span> <span class="p">{</span>
   <span class="k">multi</span> <span class="k">method</span> <span class="nb">STORE</span><span class="p">(</span><span class="nb">Array</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nb">Set</span> \<span class="nb">item</span> <span class="k">--&gt;</span> <span class="nb">Array:D</span><span class="p">)</span> <span class="p">{</span>
       <span class="nb">self</span><span class="o">.</span><span class="nb">STORE</span><span class="p">(</span><span class="nb">item</span><span class="o">.</span><span class="nb">keys</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">+</span><span class="nv">@a</span><span class="p">;</span>
</code></pre></div><pre><code>[&quot;c&quot;, &quot;e&quot;]
2
</code></pre><p>分享这个似乎是谨慎的，看看我的小 DWIM 是否有任何我没有考虑到的问题或缺点。一个可能的缺点是，如果你需要这样做的话，你需要使用 <code>,</code> 来强制将一个集合变成一个数组。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span> <span class="ow">(-)</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="nb">d</span><span class="o">&gt;</span> <span class="o">,</span> <span class="p">;</span>
<span class="nb">say</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
</code></pre></div><pre><code>[Set.new(&quot;e&quot;,&quot;c&quot;)]
</code></pre><h2 id="下一步是什么">下一步是什么</h2>
<p>我希望这能引发关于这个问题以及其他我们的直觉和 Raku 的行为不太一致的情况的讨论。也许还有其他相关的语言边缘可以被磨平，以消除这种危害。</p>
<h2 id="后续">后续</h2>
<p>在 <a href="https://t.co/0QSoMxrSXf?amp=1">Reddit</a> 上有一些非常有启发性的讨论，涵盖了语言语义和各种替代方法。公平地说，我建议的方法引入了更多的不一致性，而不是价值，但讨论可能会导致一个语言一致的解决方案。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/flink" term="flink" label="Flink" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
</feed>
