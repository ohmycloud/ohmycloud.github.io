<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.63.2">Hugo</generator><title type="html"><![CDATA[raku on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/raku/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/raku/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/raku/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/raku/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2020-08-05T11:46:08+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/raku/</id>
    
        
        <entry>
            <title type="html"><![CDATA[通过函数式编程实现更简洁的代码]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-07-26-cleaner-code-with-functional-programming/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-07-21-checklist-for-6-dot-d/?utm_source=atom_feed" rel="related" type="text/html" title="Checklist for Raku 6.d" />
            
                <id>https://ohmyweekly.github.io/notes/2020-07-26-cleaner-code-with-functional-programming/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-26T00:00:00+08:00</published>
            <updated>2020-07-26T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Cleaner code with functional programming</blockquote><p>函数式编程是一种编程风格，现代语言或多或少都支持这种风格。在这篇文章中，我想解释一下函数式编程如何为你提供强大的抽象，使你的代码更加简洁。我将用 Raku 和 Python 中的例子来说明这一点，我们将看到这两种语言都是函数式编程的优秀语言。</p>
<h2 id="raku-简介">Raku: 简介</h2>
<p>本文的代码示例是用 Python 和 Raku 编写的。我想大多数人都熟悉 Python，但 Raku 不太为人所知，所以我先解释一下基础知识。本文中的代码不是很习惯，所以如果你懂得其他编程语言，应该很容易理解。</p>
<p>Raku 与 Perl 最为相似。两种语言在语法上都与 C/C++、Java 和 JavaScript 相似：基于块，语句用分号隔开，块用大括号分界，参数列表放在括号中，用逗号隔开。将 Perl 和 Raku 与其他语言区分开来的主要特征是使用魔符（&ldquo;有趣的字符&rdquo;）来识别变量的类型：<code>$</code> 代表标量，<code>@</code> 代表数组，<code>%</code> 代表哈希（映射），<code>&amp;</code> 代表子程序。变量也有关键字来标识它们的作用域，我只用 <code>my</code> 来标识变量的词法作用域。子程序是用 <code>sub</code> 关键字来声明的，子程序可以是命名的，也可以是匿名的。</p>
<pre><code class="language-perl6" data-lang="perl6">sub square ($x) {
    $x*$x;
}
# anonymous subroutine 
my $anon_square = sub ($x) {
    $x*$x;
}
</code></pre><p>在 Python 中，这将是：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>

<span class="c1"># anonymous subroutine </span>
<span class="n">anon_square</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
</code></pre></div><p>Raku 支持无符号变量，并使用 <code>\</code> 语法来声明它们。更多关于普通变量和无符号变量之间的区别，请参见 <a href="https://docs.raku.org/language/variables#Sigilless_variables">Raku 文档</a>。例如(<code>say</code> 打印它的参数，后面加一个换行)。</p>
<pre><code class="language-perl6" data-lang="perl6">my \x = 42; # sigilless
my $y = 43; 
say x + $y; 
</code></pre><p>在本文的代码中，我将尽可能地使用无符号变量。</p>
<p>Raku 有几种类型的序列数据结构。在下面的代码中，我将使用<a href="https://docs.raku.org/language/list">列表和数组</a>以及<a href="https://docs.raku.org/type/Range">范围</a>。在 Raku 中，列表和数组的主要区别在于，列表是不可变的，这意味着一旦创建，就不能修改。所以它是一个只读的数据结构。要&quot;更新&quot;一个不可变的数据结构，你需要创建一个更新的副本。另一方面，数组是可变的，所以我们可以更新它们的元素，扩展它们，缩小它们等等。所有的更新都发生在原始数据的位置上。</p>
<p>Raku 的数组类似于 Python 的 list，Raku 的 list 类似于 Python 的 tuple，也是不可变的。除了语法之外，Raku 中的范围与 Python 中的范围相似，都是不可变的。</p>
<pre><code class="language-perl6" data-lang="perl6">my @array1 = 1,2,3; #=&gt; an array because of the '@' sigil
my \array2 = [1,2,3]; #=&gt; an array, because of the '[...]'

my \range1 = 1 .. 10; #=&gt; a range 1 .. 10
my @array3 = 1 .. 10; #=&gt; an array from a range, because of the '@' sigil

my \list1 = 1,2,3; #=&gt; a list
my $list2 = (1,2,3); #=&gt; also a list
my \list3 = |(1 .. 10);  #=&gt; an array from a range because of the '|' flattening operation
</code></pre><p>相应的 Python 代码为:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">list1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="p">)</span> <span class="c1">#=&gt; a list from a tuple</span>
<span class="n">list2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="p">;</span> <span class="c1">#=&gt; a list, because of the &#39;[...]&#39;</span>

<span class="n">range1</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span> <span class="c1">#=&gt; a range 1 .. 10</span>
<span class="n">list3</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span><span class="p">)</span><span class="p">;</span> <span class="c1">#=&gt; a list from a range</span>

<span class="n">tuple1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">;</span> <span class="c1">#=&gt; a tuple</span>
<span class="n">tuple2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="p">)</span> <span class="c1">#=&gt; a tuple from a list</span>
<span class="n">tuple3</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span><span class="p">)</span> <span class="c1">#=&gt; creates a tuple from a range</span>
</code></pre></div><p>其他具体的语法或功能将针对具体的例子进行解释。</p>
<h2 id="其他任何名称的函数---作为值的函数"><em>其他任何名称的函数</em> - 作为值的函数</h2>
<p>函数是函数式编程的精髓。正如我在<a href="https://wimvanderbauwhede.github.io/articles/everything-is-a-function">&ldquo;万物皆函数&rdquo;</a>一文中所解释的那样，在适当的函数式语言中，所有的结构都是由函数构建的。</p>
<p>所有现代编程语言都有函数、程序、子程序或方法的概念。它们是代码重用的重要机制。通常，我们认为函数是对一些输入值进行操作以产生一个或多个输出值的东西。输入值可以是全局声明的，也可以是一个类的属性，或者作为参数传递给函数。同样，输出值可以直接返回，到全局变量，作为类的属性或通过修改输入值。</p>
<p>要想从函数式编程中获益最多，最好是函数是纯粹的，这意味着对函数的调用总是对相同的输入产生相同的输出。在实践中，如果函数只接受输入作为参数，并直接返回输出，这一点比较容易实现，但这并不是必不可少的。</p>
<p>函数式编程的关键特征是，函数的输入值和输出值本身可以是函数。所以函数必须是你语言中的值。有时这被称为 &ldquo;函数必须是一等公民&rdquo;，一个接收和/或返回函数的函数有时被称为&quot;高阶函数&rdquo;。</p>
<p>如果函数是值，那么我们就可以将它们赋值给变量。特别是我们会将它们赋值给其他函数的参数。但我们也可以将它们赋值给普通的变量。</p>
<p>让我们考虑以下函数，<code>choose</code>，它需要三个参数 <code>t</code>，<code>f</code> 和 <code>c</code>。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub choose (\t, \f, \d) {
    if (d) {t} else {f}
}
# Python
def choose (t, f, d):
  if d:
    return t 
  else:
    return f
</code></pre><p>首先让我们用字符串作为前两个参数的值来调用 <code>choose</code>。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \tstr = &quot;True!&quot;;
my \fstr = &quot;False!&quot;;

my \res_str = choose(tstr, fstr, True);

say res_str; #=&gt; says &quot;True!&quot;
# Python
tstr = &quot;True!&quot;
fstr = &quot;False!&quot;

res_str = choose(tstr,fstr,True)

print(res_str) #=&gt; says &quot;True!&quot;
</code></pre><p>现在让我们尝试用函数作为参数:</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub tt (\s) { say &quot;True {s}!&quot; }
sub ff (\s) { say &quot;False {s}!&quot; }

my &amp;res_f = choose(&amp;tt, &amp;ff, False);

say &amp;res_f; #=&gt; says &amp;ff
res_f(&quot;rumour&quot;); #=&gt; says &quot;False rumour!&quot;
# Python
def tt(s):
  print( &quot;True &quot;+s+&quot;!&quot;)
def ff(s):  
  print( &quot;False&quot;+s+&quot;!&quot;)

res_f = choose(tt,ff,True)

print(res_f) #=&gt; says &lt;function tt at 0x7f829c3aa310&gt;
res_f(&quot;rumour&quot;) #=&gt; says &quot;False rumour!&quot;
</code></pre><p>因此，我们的函数 <code>choose</code>  接收两个函数作为它的前两个参数，并返回一个函数。在 Raku 中，我们需要在函数名上加上 <code>&amp;</code> 符号，因为否则它们会被求值：像 <code>tt</code> 这样的裸函数名就等于调用没有参数的函数 <code>tt()</code>。通过将这个函数赋值给一个变量(<code>res_f</code>)，我们现在可以将 <code>res_f</code> 作为一个函数来调用，它最终会根据选择来调用 <code>tt</code> 或 <code>ff</code>。</p>
<h2 id="函数不需要名字">函数不需要名字</h2>
<p>现在，如果我们可以将函数赋值给变量，它们本身其实并不需要一个名字。所以我们的函数可以是匿名的。大多数语言都支持匿名函数，在函数式语言中，它们通常被称为 &ldquo;lambda 函数&rdquo;。在 Raku 中，我们有两种方法来创建匿名函数。</p>
<p>使用 <code>sub (...)</code> 语法:</p>
<pre><code class="language-perl6" data-lang="perl6">my \tt = sub (\s) { say &quot;True {s}!&quot; };
</code></pre><p>或者使用<a href="https://docs.raku.org/language/functions#index-entry-pointy_blocks">&lsquo;尖号块&rsquo;</a>语法，这样更紧凑一些:</p>
<pre><code class="language-perl6" data-lang="perl6">my \ff = -&gt; \s { say &quot;False {s}!&quot; };
</code></pre><p>Python 使用 <code>lambda</code> 关键字:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">tt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span> <span class="p">:</span> <span class="k">print</span><span class="p">(</span> <span class="sa"></span><span class="s2">&#34;</span><span class="s2">True </span><span class="s2">&#34;</span><span class="o">+</span><span class="n">s</span><span class="o">+</span><span class="sa"></span><span class="s2">&#34;</span><span class="s2">!</span><span class="s2">&#34;</span> <span class="p">)</span>
<span class="n">ff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span> <span class="p">:</span> <span class="k">print</span><span class="p">(</span> <span class="sa"></span><span class="s2">&#34;</span><span class="s2">False </span><span class="s2">&#34;</span><span class="o">+</span><span class="n">s</span><span class="o">+</span><span class="sa"></span><span class="s2">&#34;</span><span class="s2">!</span><span class="s2">&#34;</span> <span class="p">)</span>
</code></pre></div><p>所以现在我们可以说:</p>
<pre><code class="language-perl6" data-lang="perl6">my &amp;res_f = choose(tt, ff, True);

say &amp;res_f; #=&gt; says sub { }
res_f(&quot;story&quot;); #=&gt; says &quot;True story!&quot;
</code></pre><p>当我们打印出函数所绑定的变量时，Raku 返回 <code>sub { }</code> 来表示该变量包含一个函数。</p>
<p>在 Python 中:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">res_f</span> <span class="o">=</span> <span class="n">choose</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span><span class="p">;</span>

<span class="k">print</span><span class="p">(</span> <span class="n">res_f</span><span class="p">)</span> <span class="c1">#=&gt; says &lt;function &lt;lambda&gt; at 0x7f829b298b80&gt;</span>
<span class="n">res_f</span><span class="p">(</span><span class="sa"></span><span class="s2">&#34;</span><span class="s2">story</span><span class="s2">&#34;</span><span class="p">)</span> <span class="c1">#=&gt; says &#34;True story!&#34;</span>
</code></pre></div><h2 id="例子-map-grep-和-reduce">例子: <code>map</code>、 <code>grep</code> 和 <code>reduce</code></h2>
<p>函数的功能有很多用途，我只想重点介绍三个在 Raku 中现成的例子：<code>map</code>、<code>reduce</code> 和 <code>grep</code>。Python 有 <code>map</code> 和 <code>filter</code>，并通过 <code>functools</code> 模块提供 <code>reduce</code>。这些函数的共同点是，它们提供了一种对列表进行 <code>for</code> 循环的替代方法。</p>
<h3 id="map--对列表中的所有元素进行函数应用"><code>map</code> : 对列表中的所有元素进行函数应用</h3>
<p><code>map</code> 有两个参数：一个函数和一个列表。它将函数按顺序应用于列表中的所有值，并返回结果，例如将列表中的所有值平方。</p>
<pre><code class="language-perl6" data-lang="perl6">my \res = map -&gt; \x {x*x} , 1 .. 10;
</code></pre><p>在 Python 中，我们需要显式地创建元组，但除了语法上的差异，结构是完全一样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">res</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span> <span class="nb">map</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span><span class="p">)</span><span class="p">)</span>
</code></pre></div><p>这是对传统 <code>for</code> 循环的功能替代。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \res = [];
for 1 .. 10 -&gt; \x {
    res.push(x*x);
}
# Python
res = []
for x in range(1,11):
    res.append(x*x)
</code></pre><p>请注意，在 Raku 和 Python 中，我们需要为 <code>for</code> 循环版本使用一个可变的数据结构，而 <code>map</code> 版本则使用不可变的数据结构。</p>
<h3 id="grep--过滤列表"><code>grep</code> : 过滤列表</h3>
<p><code>grep</code> (在 Python 中称为 <code>filter</code>)也接受参数，一个函数和一个列表，但它只返回函数返回真的列表中的值。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \res = grep -&gt; \x { x % 5 == 0 }, 1 .. 30;
# Python
res = tuple(filter( lambda x : x % 5 == 0 ,range(1,31)))
</code></pre><p>当然我们也可以用 <code>for</code> 循环和 <code>if</code> 语句来写，但这又需要一个可变的数据结构。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \res = [];
for 1 .. 30 -&gt; \x {
    if (x % 5 == 0) {
    res.push(x);
    }
}
# Python
res = []
for x in range(1,31): 
  if (x % 5 == 0):
    res.append(x)
</code></pre><p><code>map</code> 和 <code>grep</code> 的好处是，你可以很容易地把它们链在一起。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
grep -&gt; \x { x % 5 == 0 }, map -&gt; \x {x*x}, 1..30
# Python
res = tuple(filter( lambda x : x % 5 == 0 ,map( lambda x : x*x ,range(1,31))))
</code></pre><p>这是因为 <code>map</code> 和 <code>grep</code> 接受一个列表并返回一个列表，所以只要你需要对一个列表进行操作，就可以通过链式调用来实现。</p>
<h3 id="reduce--化整为零"><code>reduce</code> : 化整为零</h3>
<p><code>reduce</code> 也接受一个函数和一个 list，但它使用函数将 list 的所有元素合并成一个结果。所以函数必须接受两个参数。第二个参数是从列表中取出的元素，第一个参数作为状态变量来组合所有元素。例如，计算一个数字列表的和:</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \sum = reduce sub (\acc,\elt) {acc+elt}, 1 .. 10;

say sum; #=&gt; says 55
# Python
from functools import reduce

sum = reduce(lambda acc,elt: acc+elt, range(1,11))

print( sum); #=&gt; says 55
</code></pre><p>这里发生的情况是，首先将 <code>acc</code> 设置为列表中的第一个元素(1)，然后加上第二个元素，所以 <code>acc</code> 变成 1+2=3；然后加上第三个元素(3)，以此类推。其效果是将列表中的所有数字连续相加。</p>
<p>为了更清楚地说明这一点，我们来写一个我们自己的 <code>reduce</code> 版本。</p>
<h3 id="编写你自己的">编写你自己的</h3>
<p>在许多函数式语言中，从左到右（从最低索引开始）和从右到左（从最高索引开始）的还原是有区别的。这一点很重要，因为根据做还原的函数，如果从左边或右边消耗列表，结果可能会不同。例如，假设我们的化简函数是</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
-&gt; \x,\y {x+y}
# Python
lambda x,y: x+y
</code></pre><p>那么我们从哪个方向遍历列表并不重要。但考虑以下函数:</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
-&gt; \x,\y { x &lt; y ?? x+y !! x }

# Python
lambda x,y: x+y if x&lt;y else x
</code></pre><p>( <code>... ?? ... !! ...</code> 是条件操作符的 Raku 句法，在大多数其他语言中是 <code>... ? ... : ...</code> 在 Python 中是 <code>... if ... else ...</code>)。</p>
<p>在这种情况下，如果列表从左或从右还原，结果会有所不同。在 Raku 和 Python 中，<code>reduce</code> 是一种从左到右的还原。</p>
<p>另外，<code>reduce</code> 函数可以不使用列表的第一个元素，而是取一个额外的参数，通常称为累加器。在函数式语言中，<code>reduce</code> 通常被称为 <code>fold</code>，所以我们可以有一个左折和一个右折。让我们来看看如何实现这些。</p>
<h4 id="left-fold">Left fold</h4>
<p>实现左折的直接方法（所以和 <code>reduce</code> 一样）是在函数内部使用 <code>for</code> 循环。这意味着我们必须在循环的每次迭代上更新累加器的值。在 Raku 中，无符号变量是不可变的（我在这里简化了，完整的故事请看 <a href="https://docs.raku.org/language/containers#Binding">Raku 文档</a>），所以我们需要使用一个有符号的变量，<code>$acc</code>。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub foldll (&amp;f, \iacc, \lst) { 
  my $acc = iacc; 
  for lst -&gt; \elt {
    $acc = f($acc,elt);
  }
  $acc;
}

# Python
def foldll (f, iacc, lst):
  acc = iacc
  for elt in lst:
    acc = f(acc,elt)  
  return acc
</code></pre><p>如果我们只想使用不可变的变量，我们可以使用递归。Raku 使这一点变得简单，因为它允许一个子程序有多个签名(<code>multi sub</code>)，并且它会调用与签名相匹配的变量。</p>
<p>我们的 <code>foldl</code> 将消耗输入列表 <code>lst</code>，并使用 <code>f</code> 将其元素组合到累加器 <code>acc</code> 中，当列表被消耗后，计算结束，我们可以返回 <code>acc</code> 作为结果。所以我们的第一个变体说，如果输入列表是空的，我们应该返回 <code>acc</code>。 第二个变体从列表中取出一个元素 <code>elt</code> (关于 <code>*</code> 的细节请参见 <a href="https://docs.raku.org/type/Range">Raku 文档</a>)，并将其与 <code>acc</code> 结合到 <code>f(acc,elt)</code> 中。然后用这个新的累加器和 list 的剩余部分 <code>rest</code> 再次调用 <code>foldl</code>。</p>
<pre><code class="language-perl6" data-lang="perl6"># When the list is empty, return the accumulator
multi sub foldl (&amp;f, \acc, ()) { acc }
multi sub foldl (&amp;f, \acc, \lst) {
  # Raku's way of splitting a list in the first elt and the rest
  # The '*' is a shorthand for the end of the list
   my (\elt,\rest) = lst[0, 1 .. * ]; 
   # The actual recursion
   foldl( &amp;f, f(acc, elt), rest);
}
</code></pre><p>Python 不允许这种模式匹配，所以我们需要使用条件来编写递归。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">foldl</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">lst</span><span class="p">)</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">lst</span> <span class="o">==</span> <span class="p">(</span><span class="p">)</span><span class="p">:</span> 
    <span class="k">return</span> <span class="n">acc</span> 
  <span class="k">else</span><span class="p">:</span>
  <span class="c1"># Python&#39;s way of splitting a tuple in the first elt and the rest</span>
  <span class="c1"># rest will be a list, not a tuple, but we&#39;ll let that pass</span>
   <span class="p">(</span><span class="n">elt</span><span class="p">,</span><span class="o">*</span><span class="n">rest</span><span class="p">)</span> <span class="o">=</span> <span class="n">lst</span> 
   <span class="c1"># The actual recursion</span>
   <span class="k">return</span> <span class="n">foldl</span><span class="p">(</span> <span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">elt</span><span class="p">)</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span>
</code></pre></div><p>在这个实现中，所有的变量都不会被更新。所以所有的变量都可以是不可变的。</p>
<h4 id="right-fold">Right fold</h4>
<p>右折与左折颇为相似。对于基于循环的版本，我们所做的只是将列表反转(<code>reverse</code>)。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub foldrl (&amp;f, \acc, \lst) { 
  my $res = acc;
  for  lst.reverse -&gt; \elt {
    $res = f($res,elt);
  }
  $res;
}

# Python
def foldlr (f, iacc, lst):
  acc = iacc
  for elt in lst.reverse():
    acc = f(acc,elt)  
  return acc
</code></pre><p>在递归版本中，我们从列表中取最后一个元素而不是第一个元素。关于 <code>..^ * - 1</code> 语法的细节，请参见 <a href="https://docs.raku.org/language/operators#infix_..%5E">Raku 文档</a>。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
multi sub foldr ( &amp;f, \acc, ()) { acc }
multi sub foldr (&amp;f, \acc, \lst) {
    my (\rest,\elt) = lst[0..^*-1, *  ];
    foldr( &amp;f, f(acc, elt), rest);
}

# Python
def foldr (f, acc, lst):
  if lst == (): 
    return acc 
  else:
   (*rest,elt) = lst 
   return foldr( f, f(acc, elt), rest)
</code></pre><h4 id="map-and-grep-are-folds"><code>map</code> and <code>grep</code> are folds</h4>
<p>现在，<code>map</code> 和 <code>grep</code> 呢？我们当然可以用 <code>for</code> 循环来实现，但我们也可以用我们的 <code>foldl</code> 来实现它们。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub map (&amp;f,\lst) {
    foldl( sub (\acc,\elt) {
            (|acc,f(elt))
            }, (), lst);
}

# Python
def map (f,lst):
    return foldl( 
      lambda acc,elt:(*acc, f(elt))
      ,()
      ,lst
    )
</code></pre><p>因为函数 <code>f</code> 是可映射的，所以它只有一个参数。但是 <code>foldl</code> 需要一个有两个参数的函数，第一个参数为累加器。所以我们用两个参数的匿名函数调用 <code>foldl</code>。累积器本身是一个空列表。虽然我们前面说过，还原将原来列表的所有元素合并成一个返回值，当然这个返回值可以是任何数据类型，所以也是一个列表。所以我们对原始列表中的每一个元素都调用 <code>f</code>，并将其添加到累加器列表的末尾。(<code>|</code> 将列表扁平化，所以 <code>(|acc,f(elt))</code> 是一个由 <code>acc</code> 的元素和 <code>f(elt)</code> 的结果建立的新列表。)</p>
<p>类似地，我们也可以定义 <code>grep</code>:</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub grep (&amp;f,\lst) {
    foldl( sub (\acc,\elt) {
      if (f(elt)) {
          (|acc,elt)
      } else {
          acc
      }
    }, (), lst);
}

# Python
def filter (f,lst):
    return foldl( 
      lambda acc,elt:
        (*acc,elt) if f(elt) else acc
      , (), lst)
</code></pre><p>就像在 <code>map</code> 实现中一样，我们用一个匿名函数调用 <code>foldl</code>。在这个函数中，我们测试 <code>lst</code> 中的每个 <code>elt</code> 是否为 <code>f(elt)</code> 为真。如果是真，我们就从 <code>acc</code> 和 <code>elt</code> 创建一个新的列表，否则我们就只返回 <code>acc</code>。 因为 <code>map</code> 和 <code>grep</code> 分别对列表中的每个元素进行操作，所以我们也可以使用右折来实现它们。</p>
<p>通过这些例子，我希望无论是对函数工作的概念，还是对函数可能的实现方式，都变得更加清晰。递归实现的优点是它允许我们使用不可变的数据结构。</p>
<h3 id="为什么是不可变的数据结构">为什么是不可变的数据结构？</h3>
<p>你可能会好奇为什么我关注这些不可变的数据结构。正如我们将看到的那样，函数式编程与不可改变的数据结构配合得非常好。而且它们有一个很大的优势：你永远不用担心是否不小心修改了你的数据，也不用担心是否应该做一个副本来确定。所以使用不可变数据结构可以使代码不易出错，更容易调试。它们还具有潜在的性能优势。而我们接下来会看到，在 Raku 中还有另一个优势。</p>
<h2 id="返回函数的函数">返回函数的函数</h2>
<p>函数也可以返回函数。如果我们想拥有一个可参数化的函数，这一点尤其有用。举个简单的例子，假设我们想要一系列以固定值递增一个数字的函数：<code>add1</code>、<code>add2</code> 等。当然，我们可以分别写出每一个函数。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub add_1 (\x) {x+1}
sub add_2 (\x) {x+2}
sub add_3 (\x) {x+3}
sub add_4 (\x) {x+4}
sub add_5 (\x) {x+5}

say add_1(4); #=&gt; says 5
# Python
def add_1 (x) : return x+1
def add_2 (x) : return x+2
def add_3 (x) : return x+3
def add_4 (x) : return x+4
def add_5 (x) : return x+5

print( add_1(4)) #=&gt; says 5
</code></pre><p>或者我们可以使用一个充满匿名函数的列表。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \add =
sub (\x) {x},
sub (\x) {x+1},
sub (\x) {x+2},
sub (\x) {x+3},
sub (\x) {x+4},
sub (\x) {x+5};

say add[0].(4); #=&gt; says 5


# Python
add = (
lambda x : x+1,
lambda x : x+2,
lambda x : x+3,
lambda x : x+4,
lambda x : x+5
)

print( add[0](4)) #=&gt; says 5
</code></pre><p>我们可以做得更好，用一个循环来填充一个匿名函数的数组。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \add = [];
for 0 .. 5 -&gt; \n {
  add.push(sub (\x) {x+n});
}

say add[1].(4); #=&gt; says 5

# Python
add = []
for n in range(0,6):
  add.append(lambda x: x+n)
</code></pre><p>我们每次循环迭代都会创建一个新的匿名函数，并将其添加到数组中。但是，我们可以使用一个函数来创建这些匿名函数，然后我们可以使用 <code>map</code> 来代替循环，并使用一个不可改变的数据结构。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub gen_add(\n) {  
  sub (\x) {x+n}
}

my \add = map &amp;gen_add, 0..5;

say add[1].(4); #=&gt; says 5

# Python
def gen_add(n):  
  return lambda x : x+n

add = tuple(map( gen_add, range(0,6)))

print( add[1](4)) #=&gt; says 5
</code></pre><h3 id="laziness">Laziness</h3>
<p>在 Raku 中，使用(不可改变的)范围有一个额外的好处：我们可以将范围的末端设置为无穷大，在 Raku 中可以写成 <code>∞</code>(unicode 221E)、<code>*</code> 或 <code>Inf</code>。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \add = map &amp;gen_add, 0 .. ∞;  

say add[244].(7124); #=&gt; says 7368
</code></pre><p>这是一个所谓的&quot;懒惰求值&quot;的例子，简称 laziness：Raku 不会尝试（和失败）处理这个无限的列表。相反，它将在我们实际使用该列表中的一个元素时进行处理。表达式的评估会延迟到需要结果的时候，所以当我们调用 <code>add[244]</code> 时，发生的情况是 <code>gen_add(244)</code> 被调用来生成该函数。请注意，这在 <code>for</code> 循环中是行不通的，因为要使用 <code>for</code> 循环，我们需要一个可变的数据结构，而惰性列表必须是不可变的。所以这是一个很好的例子，说明函数式编程风格如何让你从懒惰中获益。</p>
<p>这也是为什么我们递归地实现了 <code>foldl</code>，然后用它来实现我们自己的 <code>map</code> 和 <code>grep</code>：基于递归的版本不需要更新任何变量，所以它们可以与不可变的惰性数据结构一起工作。</p>
<h2 id="函数组合">函数组合</h2>
<p>我们在上面看到，你可以把 <code>map</code> 和 <code>grep</code> 的调用链在一起。通常情况下，你只需要将 <code>map</code> 调用链在一起，例如</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
map -&gt; \x { x + 5 }, map -&gt; \x {x*x}, 1..30;

# Python
map( lambda x : x + 5, map( lambda x : x*x, range(1,31)))
</code></pre><p>在这种情况下，我们可以做得更有效率一些：比起创建一个列表，然后在这个列表上调用 <code>map</code>，我们可以通过组合函数一次完成两个计算。Raku 为此提供了一个特殊的操作符。</p>
<pre><code class="language-perl6" data-lang="perl6">map -&gt; \x { x + 5 } ∘ -&gt; \x { x * x }, 1..30;
</code></pre><p>操作符 <code>∘</code>（&ldquo;环形操作符&rdquo;，unicode 2218，但你也可以用普通的 <code>o</code>）是函数组成操作符，它的发音是 &ldquo;after&rdquo;，所以 <code>f ∘ g</code> 是 &ldquo;f after g&rdquo;。它的作用是将两个现有的函数组合起来，创建一个新的函数。</p>
<pre><code class="language-perl6" data-lang="perl6">my &amp;h = &amp;f ∘ &amp;g;
</code></pre><p>是下面的代码是一样的:</p>
<pre><code class="language-perl6" data-lang="perl6">sub h (\x) {
    f(g(x))
}
</code></pre><p>组成运算符的优点是，它可以适用于任何函数，包括匿名函数。但实际上，它只是另一个高阶函数。它只是下面函数的运算符形式。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub compose(&amp;f,&amp;g) {
    sub (\x) { f(g(x)) }
}
</code></pre><p>Python 没有函数组成操作符，但你也可以很容易地在 Python 中拥有 <code>compose</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># Python</span>
<span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">)</span><span class="p">:</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">)</span>
</code></pre></div><h2 id="结论">结论</h2>
<p>在这篇文章中，我用 Raku 和 Python 的例子介绍了三种关键的函数式编程技术：对函数进行操作的函数、返回函数的函数和函数组成。我已经展示了你如何使用函数 <code>map</code>、<code>reduce</code>(折叠)和 <code>grep</code>(过滤)来操作不可变的列表。我已经解释了哟(如何用递归和不递归实现这样的函数，以及递归实现的优势是什么。下面是《 <a href="https://github.com/wimvanderbauwhede/raku-examples/blob/master/decluttering-with-functional-programming.raku">Raku</a> 与 <a href="https://github.com/wimvanderbauwhede/raku-examples/blob/master/decluttering-with-functional-programming.py">Python</a>》一文中的代码。</p>
<p>当然，函数式编程的内容还有很多，我也写了<a href="https://wimvanderbauwhede.github.io/articles/">几篇更高级的文章</a>。本文介绍的概念应该为理解那些更高级的主题打下良好的基础。如果你想了解更多关于函数式编程的知识，你可以考虑我的<a href="https://www.futurelearn.com/courses/functional-programming-haskell">免费在线课程</a>。</p>
<p>原文: <a href="https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/">https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/functional-programming" term="functional-programming" label="functional programming" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Checklist for Raku 6.d]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-07-21-checklist-for-6-dot-d/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2020-07-21-checklist-for-6-dot-d/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-21T00:00:00+08:00</published>
            <updated>2020-07-21T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Checklist for 6.d</blockquote><h2 id="问题">问题</h2>
<p>在 6.d 版本中, 很多东西都发生了变化, 我们至少需要发布一个版本。<a href="https://github.com/perl6/roast/blob/master/docs/announce/6.d.md">这里有个列表</a>。然而, 覆盖面是不完整的。弃用通知采取了不同的形式, 一些新的类型和方法在那里, 一些则没有&hellip;&hellip;</p>
<p>用 <code>#2632</code> 引用这个问题, 并检查项目, 当你的工作, 无论是通过改变后的文档, 看到没有变化, 需要做它。在这种情况下, 请通过评论或如何解释为什么是这种情况。</p>
<h2 id="版本控制的变更">版本控制的变更</h2>
<ul>
<li><strong>[6.d]</strong> <code>&amp;await</code> 在等待的时候不再阻塞线程</li>
<li><strong>[6.d]</strong> <code>whenever</code> 不在 <code>react</code> 抛出的词法作用域内</li>
<li><strong>[6.d]</strong> 在 <code>sub MAIN</code> 里面的 <code>$*ARGFILES</code> 总是由 <code>$*IN</code> 馈入</li>
<li><strong>[6.d]</strong> 结构(字面上的) <code>$()</code>、<code>@()</code> 和 <code>%()</code> 不复存在</li>
<li><strong>[6.d]</strong> 带有 <code>:D</code>/<code>:U</code> 类型约束的变量默认为约束类型的类型对象(例如, 你可以在它们身上使用 <code>.new</code>)</li>
<li><strong>[6.d]</strong> <code>start</code> 块在 sink 上下文中附加异常处理程序</li>
<li>~~**[6.d]** 例程必须使用 <code>return-rw</code> 来返回一个 <code>Proxy</code>, 即使例程被标记为 <code>is raw</code> 或 <code>is rw</code>~~</li>
<li><strong>[6.d]</strong> 原生的 <code>num</code> 类型默认为 <code>0e0</code> 而不是 <code>NaN</code></li>
<li><strong>[6.d]</strong> 在子程序名中, 保留了键名为 <code>sym</code> 的冒号对（如<code>:sym&lt;foo&gt;</code>）, 以备将来使用</li>
</ul>
<h2 id="废弃">废弃</h2>
<p>这些方法在 6.d 语言中已被废弃, 并将在 6.e 中被删除。实现者可以选择发出弃用警告, 或者在 6.e 版本发布后更长的时间内提供这些方法。</p>
<ul>
<li>使用 <code>'-'</code> (单连字符)作为 <code>&amp;open</code> 的特殊路径, 表示特殊的句柄(使用 <code>IO::Special</code> 对象代替)</li>
<li><code>IO::Handle.slurp-rest</code> (使用 <code>.slurp</code> 代替)</li>
<li><code>Any.flatmap</code> (使用<code>.flat</code> 和 <code>.map</code> 方法的组合来代替)</li>
<li><code>Cool.path</code> (使用 <code>.IO</code> 代替)</li>
<li><code>Pair.freeze</code> (使用去容器化的参数的 <code>Pair.new</code> 来代替)</li>
<li><code>Str.subst-mutate</code> (使用带有 <code>.=</code> 方法调用赋值元运算符的 <code>Str.subst</code> 代替)</li>
<li><code>Rational.norm</code> (现在 <code>Rational</code> 类型必须在创建时标准化)</li>
<li><code>IO::Path.child</code> (使用 <code>.add</code> 代替)</li>
<li><code>&amp;undefine</code> (直接分配 <code>Empty</code>/<code>Nil</code> 代替)</li>
<li><code>:count</code> <code>&amp;lines</code>/<code>Str.lines</code> 例程上的参数(使用所返回的 <code>Seq</code> 上的 <code>.elems</code> 代替)</li>
<li><code>&amp;is_approx</code> in Test.pm6 (使用与 <code>&amp;is-approx</code> 非常相似的行为来代替)</li>
</ul>
<h2 id="新的行为">新的行为</h2>
<ul>
<li>通过新的可定义的 <code>&amp;RUN-MAIN</code>、<code>&amp;ARGS-TO-CAPTURE</code> 和 <code>&amp;GENERATE-USAGE</code> 子例程改善 <code>sub MAIN</code> 的自定义处理</li>
<li><code>%</code> 变量中的 <code>QuantHash</code>/<code>Map</code> 和 <code>@</code> 变量中的 <code>List</code> 可以用 <code>is</code> 特性来声明（例如，<code>my %h is Set</code>）</li>
<li>新的 <code>&lt;ww&gt;</code> regex 规则: 只在单词内匹配</li>
<li>循环可以从上一条语句的值中产生一个值的列表</li>
<li>循环中的 <code>next</code>/<code>last</code> 收集其最后的语句值, 对它们运行的迭代返回 <code>Empty</code></li>
<li><code>.perl</code> 可以在消耗过的 <code>Seq</code>、多维数组、<code>Date</code> 和 <code>CallFrame</code> 上调用</li>
<li><code>.gist</code> 可以在 <code>Attribute</code> 上调用</li>
<li>对自动生成的 <code>USAGE</code> 信息进行了大量改进</li>
<li><code>is hidden-from-USAGE</code> 特性，从自动生成的 <code>USAGE</code> 消息中隐藏 <code>sub MAIN</code> 候选者</li>
<li><code>Parameter.perl</code> 包括可内省的默认值</li>
<li><code>%*ENV</code> 值是同素异形的</li>
<li>尝试使用变量 <code>$;</code>、<code>$,</code>、<code>$.</code>、<code>$\</code>、<code>$(</code>、<code>$)</code>、<code>$&lt;</code>、<code>$&gt;</code>、<code>$/</code>、<code>$\</code>、<code>$[</code>、<code>$-</code>、<code>$+</code> 和 <code>$@</code> 会抛出 <code>X::Syntax::Perl5Var</code></li>
<li>默认的 <code>Hash.keyof</code> 返回一个 <code>Str(Any)</code> 强转类型对象</li>
<li>非 ASCII 数字可以在 <code>:42foo</code> 冒号对快捷方式中使用</li>
<li><code>StrDistance</code> 字符串化为 <code>.after</code> 字符串</li>
<li>更明确的 Pod 表格格式</li>
<li><code>Enumeration.enums</code> 返回一个 <code>Map</code></li>
<li>各种整数类型的 <code>.Range</code> 返回它们支持的值的范围</li>
<li><code>min</code>/<code>max</code>  例程也适用于 <code>Hash</code></li>
<li><code>Signature</code> 字面值可以包含字符串/数字字面值以及调用者标记</li>
<li><code>List.invert</code> 通过所需的 <code>Pair</code> 绑定映射, 导致潜在的类型检查失败</li>
<li><code>:exists</code> 可以与多维关联下标一起使用</li>
<li>动态创建的列表可以用来定义一个枚举</li>
<li>在 <code>.first</code> 中, Junction 可以作为匹配器使用</li>
<li>原生属性可以作为参数中的绑定目标</li>
<li><code>Proc</code> 可以与其他 <code>Proc</code> 中的 <code>IO::Pipe</code> 一起工作</li>
<li>类型数组可以用 <code>my SomeType @array</code> 和 <code>my @array of SomeType</code> 创建</li>
<li>当把 <code>Mixy</code> 强转为 <code>Setty</code>/<code>Baggy </code> 时, 负数权重的项将被删除</li>
<li><code>:nth</code> 副词在 <code>m//</code> 上接受一个 <code>Junction</code> 作为参数</li>
<li><code>CX::Warn' 和 </code>CX::Done<code>可以在</code>CONTROL` phaser 中捕获</li>
<li><code>next</code> 可用于 <code>whenever</code> 中</li>
<li><code>require</code> 符号不再过境性地暴露出来</li>
<li>通过 <code>{...}</code> 进行多维访问, 类似于 <code>[...]</code> 的工作方式</li>
<li>在 <code>END</code> 时间打开的任何手柄都会自动关闭</li>
<li>在缓存的 <code>Seq</code> 上, 当 <code>&amp;infix:&lt;eqv&gt;</code>、<code>.Slip</code>、<code>.join</code>、<code>.List</code>、<code>.list</code>、<code>.eager</code>、<code>.Array</code> 和 <code>.is-lazy</code> 被调用时, 就会使用缓存列表</li>
<li><code>IO::Handle.encoding</code> 以 <code>Nil</code> 表示切换到二进制模式</li>
<li><code>is default</code> 特质与属性一起工作</li>
<li>在多重分派中, 带有 <code>is rw</code> 特性的参数被认为比没有特性的参数窄</li>
<li><code>Array</code>、<code>Blob</code> 和 <code>Map</code> 的 <code>.gist</code> 被裁剪成100个元素</li>
<li>新的 <code>for</code> 语句修饰符 <code>hyper for</code>、<code>race for</code> 和 <code>lazy for</code></li>
<li><code>for</code> 循环自动序列化 <code>RaceSeq</code>/<code>HyperSeq</code>；使用新的 <code>for</code> 语句修饰符<code>hyper for</code>/<code>race for</code>避免</li>
<li><code>&amp;infix:&lt;does&gt;</code> 可用于 RHS 上的非组合实例</li>
<li>数值比较器可以与 <code>DateTime </code> 对象一起使用</li>
<li><code>Pod</code> 保留空白类型</li>
<li>定义了带 <code>@</code>、<code>%</code> 和 <code>&amp;</code> 魔符常数的语义</li>
</ul>
<h2 id="math">Math</h2>
<ul>
<li><code>Rational</code> 总是在创建时被化简, 并在其一生中保持不变</li>
<li><code>Inf</code>、<code>Inf</code> 和 <code>NaN</code> 可以分别用 <code>&lt;-1/0&gt;</code>、<code>&lt;1/0&gt;</code> 和 <code>&lt;0/0</code>&gt; 表示, 通过<code>Rational</code> 类型进行舍去。零分母 <code>Rational</code> 被标准化为这三个值之一</li>
<li>在 ±<code>Inf</code> 和 <code>NaN</code> 上调用 <code>.Int</code>, 会抛出异常</li>
<li>改进了 <code>Num</code> 运算符和数学函数的 IEEE 754-2008 合规性</li>
<li>负零 <code>Num</code>(<code>-0e0</code>)被所有例程和语法结构正确处理</li>
<li><code>Num</code> 类型的字符串化必须是可舍弃到原始 <code>Num</code> 的</li>
<li>定义了涉及零的 <code>Complex </code> 指数</li>
<li><code>.expmod</code> 中的负数幂有效</li>
</ul>
<h2 id="setsbagsmixesaka-quanthashes和集合运算符">Sets、Bags、Mixes(aka QuantHashes)和集合运算符</h2>
<ul>
<li>Set 运算符可以用在任何对象上, 在需要的时候会被强转
<ul>
<li>所以, 不需要也不希望有任何预先的强转</li>
<li>如果没有 QuantHash 就能实现所需的功能, 那么 Set 运算符可以自由地不创建任何 QuantHash</li>
</ul>
</li>
<li>对不同类型的 QuantHashes 的 Set 操作将强转到最自由的形式（Set -&gt; Bag -&gt; Mix）</li>
<li>集合运算符的 set_precedes 家族( <code>(&lt;+)</code>、<code>≼</code>、<code>(&gt;+)</code>、<code>≽</code>) 已被移除
<ul>
<li>曾经是子集运算符的 Baggy 形式</li>
<li>QuantHash 升级为最自由的形式, 所以 <code>(&lt;=)</code>、<code>⊆</code>、<code>(&gt;=)</code>、<code>⊇</code> 做正确的事情</li>
</ul>
</li>
<li><code>.classify-list</code> 方法可用于 <code>Baggy</code> 类型</li>
<li><code>.categorize-list</code> 方法可用于 <code>Baggy</code> 类型</li>
<li><code>.invert</code> 方法可用于核心 <code>QuantHash</code> 类型</li>
<li><code>.antipairs</code> 方法可用于 <code>QuantHash</code> 类型</li>
<li><code>QuantHash</code> 类型有 <code>.new-from-pairs</code> 和将一个 <code>QuantHash</code> 类型转换为另一个 <code>QuantHash</code> 类型的方法(例如 <code>Set</code> 类型的 <code>.Bag</code> 方法)</li>
<li><code>QuantHash</code> 类型上的 <code>.hash</code> 对键值进行了字符串化</li>
</ul>
<h2 id="新的形参和实参">新的形参和实参</h2>
<ul>
<li><code>Date.new</code> 接受一个 <code>:&amp;formatter</code></li>
<li><code>.first</code> 可以接受 <code>:kv</code></li>
<li><code>unique</code> 和 <code>.repeated</code> 可以接受 <code>:&amp;as</code> 和 <code>:&amp;with</code></li>
<li>Test.pm6 中的 <code>&amp;plan</code> 可以接受 <code>:skip-all</code></li>
<li><code>&amp;run</code>/<code>&amp;shell</code> 可以接受 <code>:merge</code></li>
<li><code>&amp;note</code> 可以在没有参数的情况下调用</li>
<li><code>open</code> 接受 <code>:$out-buffer</code></li>
<li><code>IO::Path.resolve</code> 可以接受 <code>:completely</code></li>
<li><code>IO::Path.parent</code> 可以接受一个 <code>Int</code> 表示父级</li>
<li><code>Proc::Async.new</code> 吞噬位置参数</li>
<li><code>Signature.ACCEPTS</code> 接受非 <code>Signature</code>/<code>Capture</code> 参数</li>
<li><code>&amp;EVAL</code> 可以接受一个 <code>Blob</code></li>
<li><code>Promise.keep</code>/<code>.break</code> 可以在没有参数的情况下调用</li>
<li>原生数组上的 <code>.sum</code> 可以接受 <code>:wrap</code></li>
<li><code>is required</code> 现在可以接受一个表示理由的参数</li>
<li><code>IO::Socket::Async.listen</code> 可以绑定到端口 <code>0</code> 以向操作系统申请免费端口</li>
<li><code>.encode</code> 可以接受 <code>:translate-nl</code></li>
</ul>
<h2 id="新的例程和运算符">新的例程和运算符</h2>
<ul>
<li>新的 <code>atomicint</code> Unicode 运算符和 ASCII 等价物, 保证线程安全, 原子操作:
<code>&amp;infix:&lt;⚛=&gt;</code>/<code>&amp;atomic-assign</code>、<code>&amp;prefix:&lt;⚛&gt;</code>/<code>&amp;atomic-fetch</code>、
<code>&amp;prefix:&lt;++⚛&gt;</code>/<code>&amp;atomic-inc-fetch</code>、<code>&amp;postfix:&lt;⚛++&gt;</code>/<code>&amp;atomic-fetch-inc</code>、
<code>&amp;prefix:&lt;--⚛&gt;</code>/<code>&amp;atomic-dec-fetch</code>、<code>&amp;postfix:&lt;⚛--&gt;</code>/<code>&amp;atomic-fetch-dec</code>、
<code>&amp;infix:&lt;⚛-=&gt;</code>/<code>&amp;infix:&lt;⚛−=&gt;</code>/<code>&amp;atomic-fetch-sub</code> 和 <code>&amp;infix:&lt;⚛+=&gt;</code>/<code>&amp;atomic-fetch-add</code></li>
<li><code>&amp;cas</code>: 原子比较与交换</li>
<li><code>≤</code>、<code>≥</code> 和 <code>≠</code> 运算符是 Unicode 运算符, 分别等价于 <code>&lt;=</code>、<code>&gt;=</code> 和 <code>!=</code></li>
<li><code>&amp;infix:&lt;unicmp&gt;</code>/<code>&amp;infix:&lt;coll&gt;</code>: <code>&amp;infix:&lt;cmp&gt;</code> 的替代行为</li>
<li><code>TR///</code>: <code>tr///</code> 的非变异版本</li>
<li><code>submethod TWEAK</code>: 与 <code>BUILD</code> 类似, 除了它与属性默认值兼容之外</li>
<li><code>&amp;duckmap</code>: 应用 <code>&amp;callable</code> 到每个元素上</li>
<li><code>&amp;deepmap</code>: 应用 <code>&amp;callable</code> 到每个元素上, 下降到 <code>Iterable</code> 中</li>
<li><code>&amp;take-rw</code>: 像 <code>&amp;take</code> 一样, 但有一个可写的容器</li>
<li><code>&amp;indir</code>: 在给定的 <code>$*CWD</code> 中执行代码</li>
<li><code>&amp;spurt</code>: 参见 <code>IO::Path.spurt</code></li>
<li><code>&amp;prompt</code>: 提示用户输入</li>
<li><code>uniprops</code>: <code>uniprop</code> 的多字符版本</li>
<li><code>symlink</code>: 建立文件符号链接</li>
<li><code>link</code>: 创建文件硬连接</li>
<li><code>.hyper</code>/<code>.race</code>: 并行处理值的列表</li>
<li><code>Seq.from-loop</code>: 从 <code>Callable</code> 生产一个 <code>Seq</code></li>
<li><code>Str.uniparse</code>: 将一个或多个 Unicode 字符名解析为实际字符</li>
<li><code>Str.parse-base</code>: <code>Int.base</code> 操作的反转</li>
<li><code>IO::Path</code> 提供了 <code>.ACCEPTS</code>、<code>.SPEC</code>、<code>.CWD</code>、<code>.Numeric</code>、<code>.add</code>、<code>.extension</code>、<code>.mode</code> 和各种文件测试、<code>.parts</code>、<code>.sibling</code> 和 <code>.spurt</code></li>
<li><code>IO::Handle</code> 提供了 <code>.READ</code>、<code>.WRITE</code>、<code>.EOF</code>、<code>.DESTROY</code>,
<code>.readchars</code>、<code>.flush</code>、<code>.lock</code>、<code>.unlock</code>、<code>.out-buffer</code>、<code>.tell</code>,
<code>.say</code>、<code>.slurp</code>、<code>.seek</code>、<code>.printf</code>、<code>.print-nl</code> 和 <code>.watch</code></li>
<li><code>IO::Pipe</code> 提供了 <code>.proc</code></li>
<li><code>Iterator</code> 提供了 <code>.skip-one</code>、<code>.skip-at-least</code> 和 <code>.skip-at-least-pull-one</code></li>
<li><code>Mu.emit</code>: <code>&amp;emit</code> 的方法形式</li>
<li>Test.pm6 模块中的 <code>&amp;fails-like</code>: 允许测试失败</li>
<li>Test.pm6 模块中的 <code>&amp;bail-out</code>: 退出失败的测试套件</li>
<li>Test.pm6 模块中的 <code>&amp;is-approx</code>: 测试一个数字近似于另一个</li>
<li><code>Buf</code> 拥有 <code>.allocate</code>、<code>.reallocate</code>、<code>.append</code>、<code>.push</code>、<code>.pop</code>、<code>.splice</code>、<code>.subbuf-rw</code>、<code>.prepend</code> 和 <code>.unshift</code> 方法</li>
<li><code>Range</code> 支持了 <code>.rand</code></li>
<li><code>Backtrace</code> 拥有方法 <code>.map</code>、<code>.flat</code>、<code>.concise</code> 和 <code>.summary</code></li>
<li><code>.classify-list</code> 方法可用于 <code>Hash</code> 类型</li>
<li><code>.categorize-list</code> 方法可用于 <code>Hash</code> 类型</li>
<li><code>Code.of</code>: 返回返回类型约束</li>
<li><code>Code.line</code>/<code>.file</code>: 返回定义的行/文件</li>
<li><code>Proc::Async</code> 提供了 <code>.Supply</code>、<code>.ready</code>、<code>.pid</code>、<code>.bind-stdin</code>、<code>.bind-stdout</code> 和 <code>.bind-stderr</code></li>
<li><code>Proc.command</code>/<code>Proc::Async.command</code>: 我们要执行的命令</li>
<li><code>Proc</code> 提供了 <code>.signal</code>、<code>.pid</code> 和 <del><code>.encoding</code></del></li>
<li><code>Complex</code> 提供了 <code>.cis</code>、<code>.reals</code>、<code>.ceiling</code>、<code>.floor</code>、<code>.round</code>、<code>.truncate</code> 和 <code>.abs</code> 方法, 并可以使用 <code>&lt;=&gt;</code> 进行比较(只要虚部可以忽略不计)</li>
<li><code>DateTime</code> 提供了 <code>.offset-in-hours</code>、<code>.hh-mm-ss</code> 和 <code>.Date</code></li>
<li><code>DateTime</code> 可以使用 <code>&lt;=&gt;</code> 运算符和其它 <code>DateTime</code> 对象进行比较</li>
<li><code>Date</code> 提供了 <code>.DateTime</code> 方法</li>
<li><code>&amp;infix:&lt;+&gt;</code>/<code>&amp;infix:&lt;-&gt;</code> 可以被 <code>Duration</code>、<code>DateTime</code> 和 <code>Real</code> 类型调用</li>
<li><code>Enumeration</code> 提供了 <code>.Int</code>、<code>.pred</code>、<code>.succ</code>、<code>.kv</code> 和 <code>.pair</code></li>
<li><code>.Date</code> 可以在 <code>Instant</code> 上调用</li>
<li>Junction 能使用 <code>Junction.new</code> 调用来创建</li>
<li><code>List</code> 类型拥有 <code>.to</code> 和 <code>.from</code> 方法</li>
<li><code>Map</code> type 提供了 <code>Int</code> 方法, 返回 pair 的数量</li>
<li><code>Any.skip</code>: 跳过列表中的值</li>
<li><code>Any.batch</code>: <code>.rotor</code> 的更基本的表兄弟</li>
<li><code>Mu.iterator</code>: 为一个列表中的值生成一个 <code>Iterator</code></li>
<li><code>IO::Spec::*</code> 类型提供了 <code>.tmpdir</code>、<code>.extension</code> 和 <code>.path</code></li>
<li><code>Pair</code> 提供了 <code>.ACCEPTS</code>、<code>.Pair</code> 和 <code>.invert</code></li>
<li><code>.Capture</code> 方法对所有核心类型都有明确定义</li>
<li>定义了 <code>.ACCEPTS</code> 在同素异形体上的语义</li>
<li><code>Failure.self</code> 使未处理的 <code>Failure</code> 爆发</li>
<li><code>Thread.is-initial-thread</code>: 我们是在初始线程中运行吗</li>
<li><code>Match</code> 提供了 <code>.Int</code> 和 <code>.actions</code></li>
<li><code>IO::Socket::Async</code> 提供了 <code>.socket-port</code> 和 <code>.peer-port</code></li>
<li><code>Promise</code> 提供了另一种构造函器 <code>.kept</code> 和 <code>.broken</code></li>
<li><code>WhateverCode</code> 提供了 <code>.assuming</code></li>
<li><code>WhateverCode</code> 和 <code>Block</code> 提供了 <code>.cando</code></li>
<li><code>.:&lt;…&gt;</code> 语法用于调用前缀运算符作为后缀</li>
<li><code>$*KERNEL</code> 提供了 <code>.hostname</code></li>
<li><code>Nil</code> 拥有定义的 <code>.FALLBACK</code> 特殊方法来返回 <code>Nil</code></li>
</ul>
<h2 id="新类型">新类型</h2>
<ul>
<li><code>atomicint</code>: 原生的 <code>int</code>, 大小可用于新的原子运算符</li>
<li><code>Lock::Async</code>: 互斥的非阻塞机制</li>
<li><code>Encoding::Registry</code>: 管理可用的编码</li>
<li><code>Encoding::Encoder</code>: 编码器, 用于特定的编码</li>
<li><code>Encoding::Decoder</code>: 解码器, 用于特定的编码</li>
<li><code>IO::CatHandle</code>: 将多个只读的 <code>IO::Handle</code> 视同一个</li>
<li>原生的 <code>str</code> 数组</li>
<li><code>Supplier::Preserving</code>: 缓存的实时 <code>Supply</code> 工厂</li>
<li><code>Semaphore</code>: 控制多线程对共享资源的访问</li>
<li><code>IO::Special</code>: 特殊I/O设备的路径 (例如 <code>STDOUT</code>)</li>
<li><code>Exceptions::JSON</code> 自定义异常处理程序的实现(可与<code>PERL6_EXCEPTIONS_HANDLER</code> 环境变量一起使用)</li>
<li><code>SeekType</code> 枚举: <code>IO::Handle.seek</code> 中使用的值</li>
</ul>
<h2 id="新的变量">新的变量</h2>
<ul>
<li>
<p><code>$*USAGE</code>: 可在 <code>MAIN</code> 子例程中使用, 包含自动生成的 <code>USAGE</code> 信息</p>
</li>
<li>
<p>%*SUB-MAIN-OPTS: 设置 <code>sub MAIN</code> 的行为</p>
<ul>
<li><code>%*SUB-MAIN-OPTS&lt;named-anywhere&gt;</code> 允许将命名参数放在命令行的任何位置</li>
</ul>
</li>
<li>
<p><code>$*COLLATION</code>: 配置四个 Unicode 校对级别</p>
</li>
<li>
<p><code>$*INIT-INSTANT</code>: 代表程序启动时间的 <code>Instant</code></p>
</li>
<li>
<p><code>$*HOME</code>: 用户的主目录, 如果存在的话</p>
</li>
<li>
<p><code>&amp;*chdir</code>: <code>Callable</code> 包含 <code>IO::Path.chdir</code> 的变体, 也设置进程的当前目录</p>
</li>
<li>
<p><code>PERL6_TEST_DIE_ON_FAIL</code> 环境变量: 在第一次失败时停止测试套件</p>
</li>
<li>
<p><code>PERL6_EXCEPTIONS_HANDLER</code> 环境变量: 指定自定义异常处理类</p>
</li>
</ul>
<h2 id="对边缘情况强转行为的澄清">对边缘情况/强转行为的澄清</h2>
<ul>
<li><code>UInt</code> 与 <code>Int</code> 类型对象智能匹配为 <code>True</code></li>
<li><code>sink</code> 语句前缀爆炸 <code>Failure</code></li>
<li>定义了1项和0项列表以及负参数和非整数参数的 <code>permutations</code>/<code>combinations</code> 的行为</li>
<li><code>&amp;val</code>、<code>Str.Numeric</code> 和其他 <code>Str</code> 数字转换方法在试图转换 Unicode <code>No</code> 字符组或合成数字时会 <code>fail</code></li>
<li><code>:42foo</code> 冒号对快捷方式中不能使用合成数字</li>
<li>现在、<code>Enumeration</code> 可以作为一个数组形状指定器使用</li>
<li>含有空格的 <code>Str</code> 的数值转换现在返回 <code>0</code></li>
<li>带空的模式参数的 <code>samark</code>, 简单地返回调用者</li>
<li><code>.polymod</code> 可用于 <code>lazy</code> 但有限的除数列表</li>
<li>定义了 <code>.[*-0]</code> 索引</li>
<li><code>.rotor</code> 中大于子列表的负数空隙抛出异常</li>
<li><code>.rotor</code> 的非 <code>Int</code> 参数被强转为 <code>Int</code> 参数</li>
<li>读取 <code>/proc</code> 文件时定义了 <code>.lines</code></li>
<li>定义了字符串上后缀/前缀  <code>++</code>/<code>--</code> 中泰语数字的行为</li>
<li>sunk <code>for</code> 里面的 <code>map</code> 被视为 sunk</li>
<li>Sunk <code>for</code> 循环将上一条语句的方法调用值下沉</li>
<li><code>Bool</code> 对象上的 <code>.Int</code> 返回一个 <code>Int</code> 对象</li>
<li><code>splice</code> 可用于扩展数组</li>
<li><code>classify</code> 可以与 <code>Junction</code> 配合使用</li>
<li><code>.pairup</code> on a type object returns an empty <code>Seq</code></li>
<li><code>.pairup</code> 总是返回一个 <code>Seq</code></li>
<li>拒绝接受  <code>Date</code>/<code>DateTime</code> 构造函数中的合成代码点</li>
<li><code>⸨</code>/<code>⸩</code> 对儿现在可以作为引号结构中的匹配字符使用</li>
<li><code>Array</code> 类型对象上的 <code>.flat</code> 简单地返回该类型对象</li>
<li>混合级 <code>classify</code> 在 <code>Hash</code> 上抛出异常</li>
<li><code>Junction</code> 可以用于给 <code>Hash</code> 指定多个键</li>
<li>给 <code>.classify-list</code> 的 <code>Callable</code> 现在保证每项只执行一次</li>
<li><code>:delete</code> 对 <code>Hash</code> 类型对象进行关联查找时返回 <code>Nil</code></li>
<li>Test.pm6 中的 <code>&amp;is-deeply</code> 会自动 <code>.cache</code> 作为参数的 <code>Seq</code>, 并使用返回的 <code>List</code> 进行测试</li>
<li><code>Complex.new()</code> 给出 <code>&lt;0+0i&gt;</code></li>
<li><code>Int.new</code> 现在可以保证构建一个新的 <code>Int</code> (而不是, 比如说, 从常量缓存中重用一个)</li>
<li>定义了一个参数(1-arg)版本的 <code>&amp;infix:&lt;=:=&gt;</code> 和 <code>&amp;infix:&lt;eqv&gt;</code></li>
<li>如果直接或间接地调用 <code>.BIND-POS</code>、<code>.BIND-KEY</code>、<code>.ASSIGN-POS</code>、<code>.ASSIGN-KEY</code>、<code>.STORE</code>、<code>.push</code>、<code>.append</code>、<code>.unshift</code>、<code>.prepend</code>、<code>Nil</code> 类型现在抛出异常</li>
<li><code>Nil.ord</code> 返回一个空的 <code>Seq</code></li>
<li><code>Nil.chrs</code> 返回一个 <code>&quot;\0&quot;</code></li>
<li><code>Num.new</code> 强转参数为 <code>Num</code></li>
<li><code>infix:&lt;Z&gt;()</code> 返回一个空的 <code>Seq</code></li>
<li><code>.comb</code> 总是返回一个 <code>Seq</code></li>
<li>用 <code>&amp;infix:&lt;+&gt;</code> 化简一个项, 简单地返回该项</li>
<li><code>()[0]</code> 返回 <code>Nil</code></li>
<li>允许在(可能是无限的) <code>Seq</code> 上使用 Regex 智能匹配</li>
<li>定义了 <code>Range</code> 对象的智能匹配</li>
<li><code>Set</code> 转换为<code>Mix</code>/<code>Bag</code> 不再有 <code>Bool</code> 权重</li>
<li>当一个或多个操作数为 <code>0</code> 时、<code>gcd</code> 是有定义的</li>
<li><code>defined</code> 例程中的 <code>Junction</code> 自动线程化</li>
<li><code>sum</code> 可以处理含有 <code>Junction</code> 的列表</li>
<li><code>Grammar.parse</code> 让顶级 <code>regex</code> 回溯</li>
<li><code>U+2212 MINUS SIGN [Sm] (-)</code> 现在得到更多结构的支持, 如 <code>Str.Numeric</code> 和 <code>&amp;val</code></li>
<li>Arity-1 <code>&amp;infix:&lt;~&gt;</code> 与 <code>Blob</code> 可以一起工作</li>
<li>在签名中, 所有的 <code>Numeric</code> 字面值都支持作为值字面值</li>
<li>正则表达式中的 <code>\b</code> 和 <code>\B</code> 抛出 <code>X::Obsolete</code></li>
<li><code>True</code> 和 <code>False</code> 作为签名中的值字面量发出警告</li>
<li><code>.sort</code> 和 <code>IO::Spec::Unix.path</code> 的返回值总是 <code>Seq</code></li>
<li><code>Range</code> 对象上的 Out-of-range <code>.AT-POS</code> 返回 <code>Nil</code></li>
<li>对于不存在的键、<code>Pair.AT-KEY</code> 返回 <code>Nil</code></li>
<li>所有的 <code>Cool</code> 类型都提供了 <code>.Rat</code>/<code>.FatRat</code> 强转器</li>
<li><code>IO::Path</code> 文件测试不缓存先前测试执行的结果</li>
<li><code>Seq</code> eqv <code>List</code> 仅根据类型不匹配就定为 <code>False</code></li>
<li><del><input disabled="" type="checkbox">在 <code>Hash </code>、<code>Hash </code> 和 <code>QuantHash</code> 上, 来自 <code>.kv</code>、<code>.values</code> 和 <code>.pair</code> 序列的值是可写的</del> 参见 <a href="https://github.com/Raku/roast/issues/614">Raku/roast#614</a> 和 <a href="https://github.com/Raku/doc/issues/3519">#3519</a></li>
<li><code>&amp;infix:&lt;∘&gt;</code>/<code>&amp;infix:&lt;o&gt;</code> 保留 LHF 的 <code>.of</code> 和 RHS 的 <code>.arity</code> 和 <code>.count</code></li>
<li>完善了 regex 运算符副词中的可接受参数(例如:<code>:in(…)</code>)</li>
<li>完善了 <code>IO::Handle.open</code> 中可接受的参数组合</li>
<li><code>IO::Path.Str</code> 不包含 <code>.CWD</code> 属性的值</li>
<li><code>IO::Path</code> 类型拒绝带有  <code>nul</code> 字节 (<code>&quot;\0&quot;</code>) 的路径</li>
<li><code>IO::Pipe</code> 的 <code>.path</code>/<code>.IO</code> 返回一个 <code>IO::Path</code> 类型对象</li>
<li>如果目的路径和源路径是一样的 <code>IO::Path</code> 的 <code>.copy</code>/<code>.move</code> 会 <code>fail</code></li>
<li><code>dir</code> 创建的 <code>IO::Path</code> 绝对性由调用者控制</li>
<li>更多定义的边缘行为、<code>Callable </code> 处理、<code>. defined</code> 调用, 以及 <code>&amp;infix:&lt;andthen&gt;</code>、<code>&amp;infix:&lt;orelse&gt;</code> 和 <code>&amp;infix:&lt;notandthen&gt;</code> 操作符的链接</li>
<li><code>Seq</code> 的禅切不缓存它们</li>
<li><code>List.Capture</code> 将任何包含的 <code>Pair</code> 对象的键字符串化</li>
<li>带处理的 <code>Failure</code> 参数的 <code>&amp;fail</code> 把它标记为是未处理的</li>
<li><code>use lib</code> 接受 <code>IO::Path</code> 对象</li>
<li>锚点 <code>^</code>、<code>^^</code>、<code>$</code> 和 <code>$$</code> 在环视中有效</li>
<li><code>Grammar.made</code> 支持类型对象</li>
<li><code>.isa</code> 支持 <code>subset </code> 类型对象</li>
<li><code>:delete</code> 可用于惰性数组</li>
<li><code>&amp;infix:&lt;eqv&gt;</code> 可以在某些情况下对惰性参数起作用</li>
<li>动态查询(<code>::(...)</code>) 是限制性的 regex 语法, 并且需要 <code>use MONKEY-SEE-NO-EVAL</code> 的许可</li>
<li>定义了带孔数组的 <code>.Slip</code> 和 <code>.List</code></li>
<li><code>Promise.in</code>/<code>.at</code> 和 <code>Supply.interval</code> 可以用零值和负值工作</li>
<li><code>Supply.interval</code> 最小值为 <code>0.001</code>；较低值被处理为 <code>0.001</code>, 并发出警告#, 参见 <a href="https://github.com/Raku/doc/pull/2649">https://docs.perl6.org/type/Supply#method_interval PR [#2649]</a></li>
<li><code>Supply</code> 提供了 <code>.Seq</code>、<code>.list</code> 和 <code>.zip</code></li>
<li>可以在构建方法中绑定到原生类型属性</li>
<li><code>WhateverCode</code> 传播 <code>use fatal</code></li>
<li><code>say</code>、<code>note</code>、<code>put</code>、<code>print</code> 和 <code>printf</code> 例程自动线程化 <code>Junction</code></li>
<li><code>IO::Handle.eof</code> 值在 <code>.seek</code> 过终点后再返回时也会相应改变</li>
<li>定义了 <code>.succ'、</code>.pred<code>和</code>.Bool` 的同质异形体</li>
<li>在核心 <code>Numeric</code> 上定义了 <code>.Bridge</code></li>
<li><del><input disabled="" type="checkbox">在核心 <code>Numeric</code> 的类型对象上定义了 <code>.Numeric</code>/<code>.Real</code></del></li>
<li>定义了关于零分母有理数的 <code>Rational.Bool</code></li>
<li><code>say</code>/<code>note</code> 保证在 <code>Str</code> 的子类上调用 <code>.gist</code></li>
<li>定义了 <code>Junction.Str</code> 返回 <code>Junction</code></li>
<li>定义了 <code>Junction.gist</code>/<code>.perl</code> 返回一个 <code>Str</code></li>
<li><code>Map</code>/<code>Hash</code> 的 <code>.list</code>/<code>.cache</code> 返回一个 <code>List</code></li>
<li>定义了 <code>.round</code> 的返回类型</li>
<li>定义了 <code>Enumeration:D</code>  不  <code>.ACCEPT</code> 一个 <code>Enumeration:U</code> , 参见 <a href="https://github.com/rakudo/rakudo/issues/2073">rakudo/rakudo#2073</a></li>
</ul>
<h2 id="杂项">杂项</h2>
<ul>
<li><code>IO::ArgFiles</code> 类型只是 <code>IO::CatHandle</code> 的一个空的子类</li>
<li>对常量的约束
<ul>
<li>约束是完全强制的</li>
<li>试图在常量上使用参数化类型约束(例如使用 <code>my Foo constant @int</code>) 会引发 <code>X::ParametricConstant</code> 异常</li>
</ul>
</li>
<li><code>Pod</code> <code>=defn</code>(定义列表)指令可用</li>
<li><code>Pod</code> 提供了 <code>:numbered</code> 配置键</li>
<li><code>.^ver</code>、<code>.^auth</code> 和 <code>.^name</code> 元方法在 <code>module</code> 中可用, 而在 <code>package</code> 中则没有, 这是设计上的原因</li>
<li><code>qww&lt;…&gt;</code> 中支持花哨的引号(<code>’…’</code>、<code>“…”</code>、<code>｢…｣</code> 和变体)</li>
<li><code>&amp;infix:&lt; &gt;</code> 支持查找自动生成的 <code>Callables</code> (例如: <code>&amp;infix:&lt;XX&gt;</code>)</li>
<li>使用命名的 <code>anon</code> 子例程不再产生重声明警告</li>
<li><code>::?MODULE</code>/<code>$?MODULE</code> 变量的扩展规范</li>
<li><code>sub MAIN</code> 可以接受一个参数上的 <code>Enumeration</code> 类型约束和 <code>where</code> 子句</li>
<li>笑脸型约束可以用在子集上</li>
<li><code>start</code> 块和 thunks 得到新的 <code>$/</code> 和 <code>$!</code></li>
<li>定义了与列表关联运算符一起使用的 <code>R</code> 元运算符</li>
<li>类型强转可以用在签名返回类型约束中</li>
<li><code>&amp;infix:&lt;x&gt;</code>/<code>&amp;infix:&lt;x&gt;</code> 抛出了 <code>-Inf</code>/<code>NaN</code> 重复参数</li>
<li>字面结构 <code>put</code> 和 <code>put for</code> 抛出, 需要使用括号</li>
<li>扩大了 Unicode 例程和功能的规范覆盖面-将覆盖面升级到 Unicode 第11版</li>
<li><code>$.</code> 方法调用语法能用在元方法中了</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/6.d" term="6.d" label="6.d" />
                            
                        
                    
                
            
        </entry>
    
</feed>
