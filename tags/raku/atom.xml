<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.79.0">Hugo</generator><title type="html"><![CDATA[raku on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/raku/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/raku/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/raku/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/raku/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2021-04-14T23:11:23+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/raku/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Psql]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-05-psql/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/?utm_source=atom_feed" rel="related" type="text/html" title="争取在 MoarVM 中建立一个新的总调度机制" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-07-difference-between-build-and-tweak-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="BUILD 和 TWEAK 的区别" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="如何在 Raku 中输入 Unicode" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-17-method-isd/?utm_source=atom_feed" rel="related" type="text/html" title="Method-ish" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/?utm_source=atom_feed" rel="related" type="text/html" title="模式分派" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-05-psql/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-05T00:00:00+08:00</published>
            <updated>2021-04-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Psql</blockquote><h1 id="raku-与-postgresql-的连接性一览">Raku 与 PostgreSQL 的连接性一览</h1>
<p>在我看来，Raku 是一门伟大的语言，我每天都在使用它，而且越来越多。我可以说它将取代我的 Perl 脚本。</p>
<p>Raku 有一个广泛的模块库，当然包括数据库连接，这反过来又包括连接 PostgreSQL 的功能。
在这篇简单的文章中，我将快速演示如何使用 Raku 的一段代码来完成许多比数据库应用程序还琐碎的任务。
脚本是以增量的方式呈现的，所以连接数据库部分必须始终作为脚本的前言。</p>
<p>DB::Pg 模块在某种程度上与 Perl 5 的 DBD::Pg 很相似，所以很多概念和方法名都会让人想起后者。</p>
<h2 id="安装方法">安装方法</h2>
<p>可以使用 zef 来安装 DB::Pg 模块。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">% zef install DB::Pg
</code></pre></div><p>根据你的系统速度和已经安装的库，可能需要几分钟的时间。</p>
<p>如果你要使用 LISTEN/NOTIFY，你需要同时安装 epoLl.NET 和 EPOLl.NET。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">% zef install epoll
</code></pre></div><h2 id="连接到数据库">连接到数据库</h2>
<p>现在可以使用 DB::Pg 模块连接到数据库。例如，一个简单的脚本可以接受命令行上的所有参数（清晰的文本！），可以是：</p>
<pre><code class="language-raku" data-lang="raku">#!raku

use DB::Pg;

sub MAIN( Str :$host = 'miguel',
          Str :$username = 'luca',
          Str :$password = 'secet',
          Str :$database = 'testdb' ) {

    &quot;Connecting $username @ $host/$database&quot;.say;

    my $connection = DB::Pg.new: conninfo =&gt; &quot;host=$host user=$username password=$password dbname=$database&quot;;
</code></pre><p>如你所见，DB::Pg模块接受一个 conninfo 字符串。</p>
<h2 id="读取查询和结果">读取查询和结果</h2>
<p><code>.query</code> 方法允许向数据库发出读取查询。结果是一个 Result 类对象，它可以通过不同的方法来使用，最著名的是 <code>.hash</code> 和 <code>.arrays</code>，它们返回一连串的 hash 或 arrays，从查询中提取的每一行都有一个 <code>.rows</code> 和 <code>.column</code> 等特殊方法分别提供了查询返回的行数和结果集的列名。</p>
<p>举个例子，这里是一个简单的查询。</p>
<pre><code class="language-raku" data-lang="raku">my $query = 'SELECT current_role, current_time';
my $results = $connection.query: $query;

say &quot;The query { $query } returned { $results.rows } rows with columns: { $results.columns.join( ', ' ) }&quot;;
for $results.hashes -&gt; $row {
    for $row.kv -&gt; $column, $value {
        say &quot;Column $column = $value&quot;;
    }
}
</code></pre><p>上面这段代码提供了一个类似于下面的输出。</p>
<p>查询 <code>SELECT current_role, current_time</code> 返回1行，列数为： current_role, current_time。</p>
<pre><code>Column current_role = luca
Column current_time = 14:48:47.147983+02
</code></pre><h2 id="光标">光标</h2>
<p>默认情况下，<code>.query</code> 方法将从查询中获取所有的行，这对于较大的数据集来说是一个问题。可以使用 <code>.cursor</code> 方法，它可以接受可选的批量大小（默认为1000个元组），并可选地接受将结果获取为哈希序列的指定器。</p>
<p>作为一个简单的例子。</p>
<pre><code class="language-raku" data-lang="raku">for $connection.cursor( 'select * from raku', fetch =&gt; 2, :hash ) -&gt; %row {
    say &quot;====================&quot;;
    for %row.kv -&gt; $column, $value {
        say &quot;Column [ $column ] = $value&quot;;
    }
    say &quot;====================&quot;;
}
</code></pre><p>产生和输出像这样的东西。</p>
<pre><code>====================
Column [ pk ] = 2
Column [ t ] = This is value 0
====================
====================
Column [ pk ] = 3
Column [ t ] = This is value 1
====================
====================
Column [ t ] = This is value 2
Column [ pk ] = 4
====================
====================
Column [ pk ] = 5
Column [ t ] = This is value 3
====================
...
</code></pre><h2 id="撰写声明">撰写声明</h2>
<p>编写语句可以通过 <code>.execute</code> 方法来执行，如:</p>
<pre><code class="language-raku" data-lang="raku">$connection.execute: q&lt; insert into raku( t ) values( 'Hello World' )&gt;;
</code></pre><h2 id="交易和编制报表">交易和编制报表</h2>
<p>为了处理事务，你需要访问被&quot;屏蔽&quot;到 DB::Pg 主对象中的数据库处理程序。数据库对象像往常一样提供了 <code>.begin</code>、<code>.rollback</code>、<code>.commit</code>等方法。</p>
<p>此外，还可以使用 <code>.prepare</code> 方法来获得一个已准备好的语句，该语句可以被缓存并用于循环和重复性任务中。值得注意的是，<code>.prepare</code> 方法使用了 <code>$1</code>、<code>$2</code> 等参数占位符，当语句接受单个值时，必须在 <code>.execute</code> 中不指定索引。</p>
<p>举个例子</p>
<pre><code class="language-raku" data-lang="raku">my $database-handler = $connection.db;
my $statement = $database-handler.prepare: 'insert into raku( t ) values( $1 )';

$database-handler.begin;
$statement.execute( &quot;This is value $_&quot; )  for 0 .. 10;
$database-handler.commit;
$database-handler.finish;
</code></pre><p>上述循环相当于一个SQL事务，如:</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">BEGIN</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">raku</span><span class="p">(</span> <span class="n">t</span> <span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;This is value 0&#39;</span> <span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">raku</span><span class="p">(</span> <span class="n">t</span> <span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;This is value 1&#39;</span> <span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">raku</span><span class="p">(</span> <span class="n">t</span> <span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;This is value 2&#39;</span> <span class="p">);</span>
<span class="p">...</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">raku</span><span class="p">(</span> <span class="n">t</span> <span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;This is value 10&#39;</span> <span class="p">);</span>
<span class="k">COMMIT</span><span class="p">;</span>
</code></pre></div><p><code>.finish</code> 方法是必需的，因为 DB::Pg 处理缓存。请注意，<code>.commit</code> 和 <code>.rollback</code> 方法是流畅的，并返回一个对象实例，这样你就可以调用 <code>.commit.finish</code>。</p>
<h2 id="数据库与连接">数据库与连接</h2>
<p>缓存的处理方式是，当发出一个查询时，会打开一个新的连接并使用。一旦工作完成，连接就会返回到内部池中。DB::Pg::Database 对象做的工作和 DB::Pg 的一样，不同的是它不会自动将连接返回到池中，所以需要自己进行 <code>.</code> 完成。</p>
<p>因此，你可以在两个对象上使用相同的 <code>.query</code> 和 <code>.execute</code> 方法，但 DB::Pg 会自动将连接返回到内部池中，而数据库对象则允许你对何时将连接返回到池中进行细粒度的控制。</p>
<h2 id="复制">复制</h2>
<p>PostgreSQL 提供了特殊的 COPY 命令，可以用来复制从和进入。有一个方法 <code>.copy-in</code> 可以执行 <code>COPY FROM</code>，而 <code>COPY TO</code> 可以在迭代循环中使用。</p>
<pre><code class="language-raku" data-lang="raku">my $file = '/tmp/raku.csv'.IO.open: :w;
for $connection.query: 'COPY raku TO stdout (FORMAT CSV)'  -&gt; $row {
    $file.print: $row;
}
</code></pre><p>以上将 CSV 结果导出到文本文件上。
如果要读回数据，可以发出 <code>.copy-in</code> 方法，但首先需要发出 <code>SQL COPY</code>。工作流程是</p>
<pre><code>issue a COPY FROM STDIN;
use .copy-data to slurp all the data;
use .copy-end to notify the database that the COPY is concluded.
</code></pre><p>对.copy-end的需求是一个建议：可以在一次运行中发出不同的.copy-data，例如从不同文件中导入数据。</p>
<pre><code class="language-raku" data-lang="raku">$database-handler = $connection.db;
$database-handler.query: 'COPY raku FROM STDIN (FORMAT CSV)';
$database-handler.copy-data:  '/tmp/raku1.csv'.IO.slurp;
$database-handler.copy-data:  '/tmp/raku2.csv'.IO.slurp;
$database-handler.copy-end;
</code></pre><h2 id="转换器">转换器</h2>
<p>可以指定转换器，即处理进出数据库的值的特殊角色；这让我想起了 DBI::Class 的 <code>inflate</code> 和 <code>deflate</code> 选项。
第一步是在 <code>DB::Pg</code> 中给转换器实例添加一个角色，这样的实例必须。</p>
<ul>
<li>增加一个新的类型转换方法。</li>
<li>增加一个转换方法来处理类型字符串化的值，并返回新值（在任何 Raku 实例中）。</li>
</ul>
<p>作为一个例子，下面将一个文本 PostgreSQL 类型转换为一个 Str Raku 对象，并在其内容上进行反转。</p>
<pre><code class="language-raku" data-lang="raku">$connection.converter does role fluca-converter
{
    submethod BUILD { self.add-type( text =&gt; Str ) }
    multi method convert( Str:U, Str:D $value) {
        $value.flip.uc;
    }

}

.say for $connection.query( 'select * from raku' ).arrays;
</code></pre><p>产生类似于的输出。</p>
<pre><code>[442 DLROW OLLEH]
[454 DLROW OLLEH]
[466 DLROW OLLEH]
</code></pre><p>其中字符串 Hello World 被翻转。</p>
<h2 id="listen-和-notify">listen 和 notify</h2>
<p>DB::Pg也可以处理LISTEN和NOTIFY，它们能够与Raku的react动态功能进行交互。
首先，创建一个简单的机制来通知一些事件。</p>
<pre><code class="language-raku" data-lang="raku">testdb=&gt; create or replace rule r_raku_insert 
         as on insert to raku 
         do also 
         SELECT pg_notify( 'insert_event', 'INSERTING ROW(S)' );
CREATE RULE

testdb=&gt; create or replace rule r_raku_delete
         as on delete to raku 
         do also 
         SELECT pg_notify( 'delete_event', 'DELETING ROW(S)' );
CREATE RULE
</code></pre><p>现在，可以创建一个等待传入事件的 Raku 脚本。</p>
<pre><code class="language-raku" data-lang="raku">react {
    whenever $connection.listen( 'delete_event' ) { .say; }
    whenever $connection.listen( 'insert_event' ) { .say; }
}
</code></pre><p>目的是，每次发出一个事件，<code>.listen</code> 都会将消息有效载荷传递给 react 代码块。因此，发出一些 <code>DELETE</code> 和 <code>INSERT</code> 会导致输出。</p>
<pre><code>DELETING ROW(S)
INSERTING ROW(S)
INSERTING ROW(S)
</code></pre><p>可以通过 <code>.unlisten</code> 方法停止监听反应块。也可以通过 <code>.notify</code> 方法发出事件。</p>
<h2 id="总结">总结</h2>
<p>DB::Pg 是 PostgreSQL 的一个很好的驱动程序，它允许 Raku 直接在语言中利用很多功能。</p>
<p>文章 A glance at Raku connectivity towards PostgreSQL 已经由 Luca Ferrari 发布在博客上。</p>
<p>原文链接: <a href="https://fluca1978.github.io/2021/03/29/RakuPostgreSQL.html">https://fluca1978.github.io/2021/03/29/RakuPostgreSQL.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[争取在 MoarVM 中建立一个新的总调度机制]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-03-07-difference-between-build-and-tweak-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="BUILD 和 TWEAK 的区别" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="如何在 Raku 中输入 Unicode" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-17-method-isd/?utm_source=atom_feed" rel="related" type="text/html" title="Method-ish" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/?utm_source=atom_feed" rel="related" type="text/html" title="模式分派" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-custom-when/?utm_source=atom_feed" rel="related" type="text/html" title="自定义 when" />
            
                <id>https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-03-15T00:00:00+08:00</published>
            <updated>2021-03-15T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Towards a New General Dispatch Mechanism in Moarvm</blockquote><p>我的天啊，看来我是两年多来第一次写 Raku 内部的博文了。当然，两年前还不叫 Raku。总之，话不多说，继续说说这个共同的脑洞吧。</p>
<h2 id="什么是调度">什么是调度？</h2>
<p>我用 &ldquo;dispatch&rdquo; 来表示我们接受一组参数，最后根据这些参数采取一些行动的过程。一些熟悉的例子包括:</p>
<ul>
<li>
<p>进行一个方法调用，比如 <code>$basket.add($product, $quantity)</code>。传统上，我们可能只调用 <code>$product</code> 和 <code>$qauntity</code> 作为参数，但就我的目的而言，所有的 <code>$basket</code>、方法名  &ldquo;add&rdquo;、<code>$product</code> 和 <code>$quantity</code> 都是 dispatch 的参数：它们是我们需要的东西，以便决定我们要做什么。</p>
</li>
<li>
<p>进行子程序调用，如 <code>uc($youtube-comment)</code>。由于 Raku sub 调用是词法解析的，所以在这种情况下，调度的参数是 <code>&amp;uc</code>（查找子程序的结果）和 <code>$youtube-comment</code>。</p>
</li>
<li>
<p>调用多个调度子程序或方法，根据参数的数量和类型来决定调用一组候选程序中的哪一个。这个过程可以看作是发生在上述两个调度中的一个 &ldquo;内部&rdquo;，因为我们在 Raku 中既有多重调度子程序，也有方法。</p>
</li>
</ul>
<p>乍一看，也许前两个看起来相当简单，第三个就有点手忙脚乱了 - 这也算是事实。然而，Raku 还有一些其他的特性，使得调度变得相当，嗯，有趣。例如：</p>
<ul>
<li>
<p><code>wrap</code> 允许我们包装任何 Routine (sub 或方法); 包装器可以选择用原来的参数或新的参数来服从原来的例程。</p>
</li>
<li>
<p>当进行多重调度时，我们可以写一个原型例程，让它选择何时 - 甚至是否 - 调用合适的候选者。</p>
</li>
<li>
<p>我们可以使用 <code>callsame</code> 这样的例程，以便在调度中推迟到下一个候选者。但这意味着什么呢？如果我们是在一个多重调度中，它意味着下一个最适用的候选者，如果有的话。如果我们是在一个方法调度中，那么它意味着一个基类的方法。(同样的事情也被用来实现去下一个封装者，或者，最终也是去最初封装的例程)。而且这些都可以结合起来：我们可以包装一个 multi 方法，这意味着我们可以有 3 个层次的东西，都有可能贡献下一个要调用的东西!</p>
</li>
</ul>
<p>多亏了这一点，dispatch - 至少在 Raku 中 - 并不总是我们所做的事情并产生一个结果，而是一个可能会被要求继续多次进行的过程!</p>
<p>最后，虽然我上面所写的例子都可以很清楚地看成是调度的例子，但在 Raku 中，其他一些常见的构造也可以表达为一种调度。分配是一个例子：它的语义取决于分配的目标和被分配的值，因此我们需要选择正确的语义。强制类型转换(Coercion)是另一个例子，返回值类型检查又是一个例子。</p>
<h2 id="为什么调度很重要">为什么调度很重要？</h2>
<p>Dispatch 在我们的程序中无处不在，它悄悄地把想做事情的代码和做事情的代码联系在一起。它的无处不在意味着它在程序性能中扮演着重要的角色。在最好的情况下，我们可以将成本降为零。在最坏的情况下，调度的成本高到足以超过作为调度结果的工作的成本。</p>
<p>初步估计，当运行时&quot;理解&quot;调度时，性能至少会有些不错，但当运行时不理解时，很有可能会很糟糕。调度往往涉及到一个可以缓存的工作量，往往会有一些廉价的防护措施来验证缓存结果的有效性。例如，在方法调度中，天真地我们需要走一个线性化的继承图，并询问沿途遇到的每个类是否有指定名称的方法。显然，如果我们在每次方法调用时都这样做，速度不会非常快。然而，特定类型上的特定方法名（精确识别，不考虑子类）每次都会解析到同一个方法。因此，我们可以缓存查找的结果，只要调用者的类型与用于产生缓存结果的类型相匹配，就可以使用它。</p>
<h2 id="语言运行时的专门化与通用化机制">语言运行时的专门化与通用化机制</h2>
<p>当一个人开始构建一个针对特定语言的运行时，并且必须在相当紧张的预算下完成时，要想获得某种可容忍的性能，最明显的方法就是将各种热路径语言语义烘焙到运行时中。这正是 MoarVM 的起步方式。因此，如果我们看看 MoarVM 几年前的样子，我们会发现这样的事情。</p>
<ul>
<li>对方法缓存的一些支持</li>
<li>一个与 Raku 的多重调度语义高度绑定的多重调度缓存，只有在调度都是名义类型的时候才真正能够起到帮助作用（所以使用 <code>where</code> 的代价非常高）。</li>
<li>一种机制，用于指定如何在封装代码对象内部找到实际的代码句柄（例如，<code>Sub</code> 对象有一个私有属性，它持有识别要运行的字节码的低级代码句柄）。</li>
<li>一些有限的尝试，让我们能够在知道一个调度不会继续的情况下正确地进行优化 - 这需要编译器和运行时之间的谨慎合作（或者不那么外交地讲，这都是一个大黑客）。</li>
</ul>
<p>这些今天都还在，然而也都在淘汰的路上。这个榜单最能说明问题的是什么，不包括在内。比如：</p>
<ul>
<li>私有方法调用，需要不同的缓存 但最初的虚拟机设计限制了每一种类型的调用</li>
<li>合格的方法调用(<code>$obj.SomeType::method-name()</code>)</li>
<li>体面优化调度恢复的方法</li>
</ul>
<p>几年前，我开始部分解决这个问题，引入了一种机制，我称之为 &ldquo;specializer 插件&rdquo;。但首先，什么是特化器(specializer)？</p>
<p>MoarVM 刚开始的时候，它是一个比较简单的字节码解释器。它只需要足够快的速度击败 Parrot VM 就可以获得相当的使用量，我认为在继续实现一些更有趣的优化之前，这一点非常重要（当时我们还没有今天这样的发布前自动测试基础设施，因此更多的是依赖于早期采用者的反馈）。总之，在能够像其他后端一样运行 Raku 语言后不久，我就开始了动态优化器的开发。它在程序被解释时收集类型统计，识别热代码，将其放入 <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA 形式</a>，使用类型统计插入防护，将这些与字节码的静态属性一起使用来分析和优化，并为相关函数生成专门的字节码。这个字节码可以省略类型检查和各种查找，也可以使用一系列的内部操作，做出各种假设，由于优化器证明了程序的属性，这些假设是安全的。这被称为专门化的字节码，因为它的很多通用性 - 这将使它能够正确地工作在我们可能遇到的所有类型的值上 - 被删除了，转而工作在运行时实际发生的特殊情况下。(代码，尤其是动态语言中的代码，一般来说，理论上的通用性远远大于实践中的通用性。)</p>
<p>这个组件 - 内部称为 &ldquo;spesh&rdquo; 的 specializer - 为 Raku 程序的性能带来了显著的进一步提升，随着时间的推移，它的复杂程度也在不断提高，并采用了<a href="https://en.wikipedia.org/wiki/Inline_expansion">内联</a>和<a href="https://en.wikipedia.org/wiki/Escape_analysis">带有标量替换的转义分析</a>等优化功能。这些并不是容易构建的东西 - 但一旦运行时拥有了它们，它们就会创造出以前不存在的设计可能性，并使在没有它们的情况下做出的决定看起来是次优的。</p>
<p>值得注意的是，那些特殊情况下的语言特定机制，在早期为了获得一些速度而被嵌入到运行时中，反而成为了一种负担和瓶颈。它们具有复杂的语义，这意味着它们对优化器来说要么是不透明的（所以优化器无法对它们进行推理，意味着优化受到抑制），要么就是需要在优化器中进行特殊的封装（一种负担）。</p>
<p>所以，回到 specializer 插件。我到了一个地步，我想承担像 <code>$obj.?meth(&quot;call me maybe&quot;, dispatch)</code>、<code>$obj.SomeType::meth()</code>(用类开始寻找的调度限定)，以及角色中的私有方法调用(不能静态解析)这样的性能。同时，我还准备实现一定量的转义分析，但意识到它的作用将非常有限，因为赋值在虚拟机中也被特例化了，有一大块不透明的 C 代码在做热路径的事情。</p>
<p>但为什么我们要让 C 代码来做那些热路径的事情呢？嗯，因为让每个赋值都调用一个虚拟机级别的函数，做一堆检查和逻辑，花费太大了。为什么这样做成本很高？因为函数调用的开销和解释的成本。这在以前都是正确的。但是，若干年后的发展。</p>
<ul>
<li>内联被实现了，并且可以消除做一个函数调用的开销。</li>
<li>我们可以编译成机器代码，消除解释开销。</li>
<li>我们当时的处境是，我们手头有 specializer 的类型信息，可以让我们消除 C 代码中的分支，但由于我们调用的只是一个不透明的函数，所以没有办法抓住这个机会</li>
</ul>
<p>我解决了上面提到的分配问题和调度问题，引入了一个新的机制：specializer 插件。它们的工作原理如下。</p>
<ul>
<li>当我们第一次到达字节码中的一个给定的调用点时，我们就会运行这个插件。它产生了一个要调用的代码对象，以及一组守卫（为了使用该代码对象结果而必须满足的条件）。</li>
<li>下一次到达时，我们检查是否满足守卫，如果满足，就用结果</li>
<li>如果没有，我们再运行一次插件，并在 callsite 处堆积一个防护集。</li>
<li>我们统计了一个给定的防护集成功的频率，然后将其用于 specializer</li>
</ul>
<p>绝大多数情况下都是单态的，这意味着只产生一组守卫，而且之后总是成功的。因此，特殊化器可以将这些守卫编译到专门的字节码中，然后假设给定的目标调用者就是将被调用的守卫。(进一步，重复的守卫可以被消除，所以某个插件引入的守卫可能会减少到零)。</p>
<p>Specializer 插件感觉挺好的。一个新机制解决了多个优化头疼的问题。</p>
<p>新的 MoarVM 调度机制是对一个相当简单的问题的回答：如果我们把所有与调度相关的特例机制去掉，而采用有点像 specializer 插件的机制，会怎么样？由此产生的机制需要是一个比 specializer 插件更强大的机制。进一步说，我可以学习特殊器插件的一些缺点。因此，虽然它们会在比较短的寿命后消失，但我认为可以说，如果没有这些经验，我就不会有能力设计新的 MoarVM 调度机制。</p>
<h2 id="调度操作和引导调度器">调度操作和引导调度器</h2>
<p>所有的方法缓存。所有的多重调度缓存。所有的 specializer 插件。所有用于在代码对象中解包字节码句柄的调用协议的东西。这一切都将被取消，取而代之的是一个新的调度指令。它的名字很无聊，叫 <code>dispatch</code>。它看起来像这样。</p>
<pre><code class="language-raku" data-lang="raku">dispatch_o result, 'dispatcher-name', callsite, arg0, arg1, ..., argN
</code></pre><p>这意味着：</p>
<ul>
<li>使用名为 dispatcher-name 的调度器。</li>
<li>给它指定的参数寄存器（所引用的调用点表示参数的数量）。</li>
<li>将调度的对象结果放入寄存器结果中。</li>
</ul>
<p>(旁白：这意味着一个新的调用约定，即我们不再将参数复制到参数缓冲区，而是将寄存器集的基数和一个指针传递到找到寄存器参数映射的字节码中，然后做一个查询 <code>registers[map[argument_index]]</code> 来获取一个参数的值。仅此一点，我们在解释时就很省事，因为我们不再需要每个参数绕着解释器循环了）。)</p>
<p>有些参数可能是我们传统上称之为参数的东西。有些则是针对调度过程本身。这其实并不重要 - 但如果我们安排将只针对调度的参数放在前面（例如，方法名），而将针对调度目标的参数放在后面（例如，方法参数），则会更加理想。</p>
<p>新的 bootstrap 机制提供了少量的内置调度器，它们的名字以 &ldquo;boot-&rdquo; 开头。它们是：</p>
<ul>
<li><code>boot-value</code> - 取第一个参数并将其作为结果（身份函数，除了丢弃任何其他参数）。</li>
<li><code>boot-constant</code> - 取第一个参数并将其作为结果，但同时也将其视为一个将始终产生的常量值（因此意味着优化器可以将任何用于计算该值的纯代码视为死值）。</li>
<li><code>boot-code</code> - 取第一个参数（必须是虚拟机字节码句柄），并运行该字节码，将其余参数作为参数传给它；评估为字节码的返回值。</li>
<li><code>boot-syscall</code> - 将第一个参数视为虚拟机提供的内置操作的名称，然后调用它，并将其余参数作为其参数。</li>
<li><code>boot-resume</code> - 恢复正在进行的最上层调度。</li>
</ul>
<p>差不多就是这样。我们构建的每一个调度器，为了教给运行时一些其他的调度行为，最终都会终止于其中一个。</p>
<h2 id="在引导程序的基础上">在引导程序的基础上</h2>
<p>教 MoarVM 了解不同种类的调度，不外乎使用调度机制本身! 在大多数情况下，<code>boot-syscall</code> 被用来注册一个调度器，设置守卫，并提供与它们相匹配的结果。</p>
<p>这里是一个最小的例子，取自 dispatcher 测试套件，展示了一个提供同一性功能的 dispatcher 的样子。</p>
<pre><code class="language-raku" data-lang="raku">nqp::dispatch('boot-syscall', 'dispatcher-register', 'identity', -&gt; $capture {
    nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'boot-value', $capture);
});
sub identity($x) {
    nqp::dispatch('identity', $x)
}
ok(identity(42) == 42, 'Can define identity dispatch (1)');
ok(identity('foo') eq 'foo', 'Can define identity dispatch (2)');
</code></pre><p>在第一条语句中，我们调用 dispatcher-register MoarVM 系统调用，传递一个 dispatcher 的名称以及一个闭包，每次我们需要处理调度时，都会调用这个闭包（我倾向于将其称为&quot;调度回调&quot;）。它接收一个单一的参数，这是一个参数的捕获（其实不是 Raku 级别的捕获，但想法 - 一个包含一组调用参数的对象 - 是一样的）。</p>
<p>每一个用户定义的调度器最终都应该使用 dispatcher-delegate，以便确定另一个调度器将控制权传递给它。在这种情况下，它立即委托给 <code>boot-value</code> - 这意味着它除了是 <code>boot-value</code> 内置调度器的包装器外，其实什么都不是。</p>
<p>sub <code>identity</code> 包含一个调度操作的静态出现。鉴于我们两次调用 sub，我们在运行时将两次遇到这个 op，但这两次是非常不同的。</p>
<p>第一次是 &ldquo;记录&rdquo; 阶段。参数形成一个捕获，回调运行，回调又将其传给引导值调度器，产生结果。这样就形成了一个极其简单的调度程序，它说结果应该是捕获中的第一个参数。由于没有守卫，所以这将永远是一个有效的结果。</p>
<p>第二次遇到调度操作时，它那里已经记录了一个调度程序，所以我们处于运行模式。在 MoarVM 源码中开启调试模式，我们可以看到结果的调度程序是这样的。</p>
<pre><code>Dispatch program (1 temporaries)
  Ops:
    Load argument 0 into temporary 0
    Set result object value from temporary 0
</code></pre><p>也就是说，它将参数 0 读入一个临时位置，然后将其设置为调度的结果。请注意，没有提到我们经过了额外的一层调度，这些在结果调度程序中的成本为零。</p>
<h2 id="捕获操作">捕获操作</h2>
<p>参数捕获是不可改变的。各种虚拟机系统调用的存在，可以通过一些调整将它们转化为新的参数捕获，例如删除或插入参数。这里还有一个测试套件的例子。</p>
<pre><code class="language-raku" data-lang="raku">nqp::dispatch('boot-syscall', 'dispatcher-register', 'drop-first', -&gt; $capture {
    my $capture-derived := nqp::dispatch('boot-syscall', 'dispatcher-drop-arg', $capture, 0);
    nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'boot-value', $capture-derived);
});
ok(nqp::dispatch('drop-first', 'first', 'second') eq 'second',
    'dispatcher-drop-arg works');
</code></pre><p>这就在将捕获传递给引导值调度器之前丢弃了第一个参数 - 意味着它将返回第二个参数。回头看一下之前的身份函数的调度程序。你能猜到这个程序会是什么样子吗？</p>
<p>好吧，就是这样。</p>
<pre><code>Dispatch program (1 temporaries)
  Ops:
    Load argument 1 into temporary 0
    Set result string value from temporary 0
</code></pre><p>同样，虽然在这样一个调度器的记录阶段，我们确实是创建了捕获对象，并做了一个调度器代理，但由此产生的调度程序要简单得多。</p>
<p>下面是一个稍微复杂一点的例子。</p>
<pre><code class="language-raku" data-lang="raku">my $target := -&gt; $x { $x + 1 }
nqp::dispatch('boot-syscall', 'dispatcher-register', 'call-on-target', -&gt; $capture {
    my $capture-derived := nqp::dispatch('boot-syscall',
            'dispatcher-insert-arg-literal-obj', $capture, 0, $target);
    nqp::dispatch('boot-syscall', 'dispatcher-delegate',
            'boot-code-constant', $capture-derived);
});
sub cot() { nqp::dispatch('call-on-target', 49) }
ok(cot() == 50,
    'dispatcher-insert-arg-literal-obj works at start of capture');
ok(cot() == 50,
    'dispatcher-insert-arg-literal-obj works at start of capture after link too');
</code></pre><p>这里，我们有一个存储在变量 <code>$target</code> 中的闭包。我们把它作为捕获的第一个参数插入，然后委托给 <code>boot-code-constant</code>，它将调用那个代码对象，并把其他调度参数传递给它。再次，在记录阶段，我们真正要做的事情是这样的。</p>
<ul>
<li>创建一个新的捕获 在开始的时候插入一个代码对象。</li>
<li>委托给引导代码常量分配器，它&hellip;。</li>
<li>&hellip;在没有原始参数的情况下创建一个新的捕获，并使用这些参数运行字节码。</li>
</ul>
<p>由此产生的调度程序呢？就是这个</p>
<pre><code>Dispatch program (1 temporaries)
  Ops:
    Load collectable constant at index 0 into temporary 0
    Skip first 0 args of incoming capture; callsite from 0
    Invoke MVMCode in temporary 0
</code></pre><p>也就是说，加载我们要调用的常量字节码句柄，设置 <code>args</code>（在本例中等于传入捕获的参数），然后用这些参数调用字节码。参数的洗牌，又一次消失了。一般来说，只要我们做最终的字节码调用的参数是初始调度参数的尾巴，参数转换就会变得不过是一个指针的添加。</p>
<h2 id="守卫">守卫</h2>
<p>目前看到的所有调度方案都是无条件的：一旦在某一通话地点记录下来，就应一直使用。要使这样的机制具有实用性，缺少的一大块就是守卫。守卫断言了一些属性，比如参数的类型或者参数是确定的（<code>Int:D</code>）还是不确定的（<code>Int:U</code>）。</p>
<p>下面是一个有点长的测试用例，并在其中放置了一些解释。</p>
<pre><code class="language-raku" data-lang="raku"># A couple of classes for test purposes
my class C1 { }
my class C2 { }
 
# A counter used to make sure we're only invokving the dispatch callback as
# many times as we expect.
my $count := 0;
 
# A type-name dispatcher that maps a type into a constant string value that
# is its name. This isn't terribly useful, but it is a decent small example.
nqp::dispatch('boot-syscall', 'dispatcher-register', 'type-name', -&gt; $capture {
    # Bump the counter, just for testing purposes.
    $count++;
 
    # Obtain the value of the argument from the capture (using an existing
    # MoarVM op, though in the future this may go away in place of a syscall)
    # and then obtain the string typename also.
    my $arg-val := nqp::captureposarg($capture, 0);
    my str $name := $arg-val.HOW.name($arg-val);
 
    # This outcome is only going to be valid for a particular type. We track
    # the argument (which gives us an object back that we can use to guard
    # it) and then add the type guard.
    my $arg := nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $capture, 0);
    nqp::dispatch('boot-syscall', 'dispatcher-guard-type', $arg);
 
    # Finally, insert the type name at the start of the capture and then
    # delegate to the boot-constant dispatcher.
    nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'boot-constant',
        nqp::dispatch('boot-syscall', 'dispatcher-insert-arg-literal-str',
            $capture, 0, $name));
});
 
# A use of the dispatch for the tests. Put into a sub so there's a single
# static dispatch op, which all dispatch programs will hang off.
sub type-name($obj) {
    nqp::dispatch('type-name', $obj)
}
 
# Check with the first type, making sure the guard matches when it should
# (although this test would pass if the guard were ignored too).
ok(type-name(C1) eq 'C1', 'Dispatcher setting guard works');
ok($count == 1, 'Dispatch callback ran once');
ok(type-name(C1) eq 'C1', 'Can use it another time with the same type');
ok($count == 1, 'Dispatch callback was not run again');
 
# Test it with a second type, both record and run modes. This ensures the
# guard really is being checked.
ok(type-name(C2) eq 'C2', 'Can handle polymorphic sites when guard fails');
ok($count == 2, 'Dispatch callback ran a second time for new type');
ok(type-name(C2) eq 'C2', 'Second call with new type works');
 
# Check that we can use it with the original type too, and it has stacked
# the dispatch programs up at the same callsite.
ok(type-name(C1) eq 'C1', 'Call with original type still works');
ok($count == 2, 'Dispatch callback only ran a total of 2 times');
</code></pre><p>这个时候就会产生两个调度程序，一个是 C1。</p>
<pre><code>Dispatch program (1 temporaries)
  Ops:
    Guard arg 0 (type=C1)
    Load collectable constant at index 1 into temporary 0
    Set result string value from temporary 0
</code></pre><p>另一个是 C2:</p>
<pre><code>Dispatch program (1 temporaries)
  Ops:
    Guard arg 0 (type=C2)
    Load collectable constant at index 1 into temporary 0
    Set result string value from temporary 0
</code></pre><p>再一次，没有捕获操作、跟踪或调度器委托的遗留问题；调度程序对一个参数进行类型防护，然后产生结果字符串。整个对 <code>$arg-val.HOW.name($arg-val)</code> 的调用都被省略了，我们写的调度程序将知识进行了编码 - 以虚拟机能够理解的方式 - 一个类型的名称可以被认为是不可改变的。</p>
<p>这个例子有点造作，但现在考虑一下，我们反而要查找一个方法，并在调用者类型上进行守卫：这就是一个方法缓存! 守护更多参数的类型，我们就有了一个多缓存。两者都做，我们就有了一个多方法缓存。</p>
<p>后者很有意思，因为方法调度和多调度都想对调用者进行守护。事实上，在 MoarVM 中，今天会有两个这样的类型测试，直到我们到了特殊化器做工作并消除这些重复的守卫。然而，新的调度器并没有将调度器 - guard-类型当作一种命令式操作，将守卫写入结果调度程序中。相反，它声明相关的参数必须被防护。如果其他的调度器已经这样做了，那它就是幂等的。一旦我们委派通过的所有调度程序，在通往最终结果的路径上，都有了自己的发言权，就会发出守卫。</p>
<p>有趣的是：特别细心的人会注意到，调度机制也被用作实现新的调度程序的一部分，事实上，这最终也将意味着特殊化者可以将调度程序特殊化，让它们也被 JIT 编译成更高效的东西。毕竟，从 MoarVM 的角度来看，这一切都只是要运行的字节码，只是有些字节码是告诉 VM 如何更高效地执行 Raku 程序的!</p>
<h2 id="恢复调度">恢复调度</h2>
<p>可恢复调度器需要做两件事。</p>
<ul>
<li>在注册调度器的时候，提供一个恢复回调和一个调度回调。</li>
<li>在 dispatch 回调中，指定一个捕获，这将形成恢复初始化状态。</li>
</ul>
<p>当发生恢复时，将调用恢复回调，并提供恢复的任何参数。它还可以获得在 dispatch 回调中设置的 resume 初始化状态。resume 初始化状态包含了第一次恢复调度时继续进行调度所需要的东西。我们先来看看方法调度的工作原理，看一个具体的例子。我也会在此时，切换到看真正的 Rakudo 调度器，而不是简化的测试用例。</p>
<p>Rakudo 调度器利用授权、重复守卫和捕获操作都没有运行时成本的优势，在结果调度程序中，至少在我看来，很好地因素了一个有些复杂的调度过程。方法调度有多个切入点：普通无聊的 <code>$obj.meth()</code>，限定的 <code>$obj.Type::meth()</code>，以及调用我也许 <code>$obj.?meth()</code>。这些都有共同的 resume 语义 - 或者至少，只要我们在 resume 初始化状态中始终携带一个起始类型，也就是我们做方法调度的对象的类型，就可以使它们成为。</p>
<p>这里是普通方法调度的切入点，去掉了报告缺失方法错误的无聊细节。</p>
<pre><code class="language-raku" data-lang="raku"># A standard method call of the form $obj.meth($arg); also used for the
# indirect form $obj.&quot;$name&quot;($arg). It receives the decontainerized invocant,
# the method name, and the the args (starting with the invocant including any
# container).
nqp::dispatch('boot-syscall', 'dispatcher-register', 'raku-meth-call', -&gt; $capture {
    # Try to resolve the method call using the MOP.
    my $obj := nqp::captureposarg($capture, 0);
    my str $name := nqp::captureposarg_s($capture, 1);
    my $meth := $obj.HOW.find_method($obj, $name);
 
    # Report an error if there is no such method.
    unless nqp::isconcrete($meth) {
        !!! 'Error reporting logic elided for brevity';
    }
 
    # Establish a guard on the invocant type and method name (however the name
    # may well be a literal, in which case this is free).
    nqp::dispatch('boot-syscall', 'dispatcher-guard-type',
        nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $capture, 0));
    nqp::dispatch('boot-syscall', 'dispatcher-guard-literal',
        nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $capture, 1));
 
    # Add the resolved method and delegate to the resolved method dispatcher.
    my $capture-delegate := nqp::dispatch('boot-syscall',
        'dispatcher-insert-arg-literal-obj', $capture, 0, $meth);
    nqp::dispatch('boot-syscall', 'dispatcher-delegate',
        'raku-meth-call-resolved', $capture-delegate);
});
</code></pre><p>现在是解析方法 dispatcher，也就是处理恢复的地方。首先，让我们看看正常的 dispatch 回调（恢复回调是包含的，但是是空的，我稍后会展示它）。</p>
<pre><code class="language-raku" data-lang="raku"># Resolved method call dispatcher. This is used to call a method, once we have
# already resolved it to a callee. Its first arg is the callee, the second and
# third are the type and name (used in deferral), and the rest are the args to
# the method.
nqp::dispatch('boot-syscall', 'dispatcher-register', 'raku-meth-call-resolved',
    # Initial dispatch
    -&gt; $capture {
        # Save dispatch state for resumption. We don't need the method that will
        # be called now, so drop it.
        my $resume-capture := nqp::dispatch('boot-syscall', 'dispatcher-drop-arg',
            $capture, 0);
        nqp::dispatch('boot-syscall', 'dispatcher-set-resume-init-args', $resume-capture);
 
        # Drop the dispatch start type and name, and delegate to multi-dispatch or
        # just invoke if it's single dispatch.
        my $delegate_capture := nqp::dispatch('boot-syscall', 'dispatcher-drop-arg',
            nqp::dispatch('boot-syscall', 'dispatcher-drop-arg', $capture, 1), 1);
        my $method := nqp::captureposarg($delegate_capture, 0);
        if nqp::istype($method, Routine) &amp;&amp; $method.is_dispatcher {
            nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-multi', $delegate_capture);
        }
        else {
            nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-invoke', $delegate_capture);
        }
    },
    # Resumption
    -&gt; $capture {
        ... 'Will be shown later';
    });
</code></pre><p>raku-meth-call 中有一个可以论证的欺骗：它实际上并没有插入调用者的类型对象来代替调用者。事实证明，这并不重要。否则，我认为注释（在真正的实现中也可以找到）很好地说明了这个问题。</p>
<p>有一个重要的点可能并不清楚 - 但遵循了一个重复的主题 - 那就是恢复初始化状态的设置也更多的是一种声明式而不是命令式的东西：在调度的时候并没有运行时成本，而是我们在周围保留了足够的信息，以便能够在我们需要的时候重建恢复初始化状态。事实上，当我们处于恢复的运行阶段时，我们甚至不需要在创建捕获对象的意义上重建它）。</p>
<p>现在说说复盘。我将介绍一个严重简化的版本，它只处理 callsame 语义（完整的东西也要处理 lastcall 和 nextcallee 这样的乐趣）。resume 初始化状态的存在是为了给 resumption 过程播种。一旦我们知道我们实际上确实要处理恢复，我们就可以做一些事情，比如计算我们想要走过的继承图中的全部方法列表。每个可恢复的调度器在调用栈上得到一个单一的存储槽，它可以用于它的状态。它可以在恢复的第一步中初始化这个，然后在我们走的时候更新它。或者更准确的说，它可以设置一个调度程序，在运行时就会这样做。</p>
<p>对于我们将要走过的候选链来说，链接列表原来是一个非常方便的数据结构。我们可以通过跟踪当前节点来完成链接列表的工作，也就是说只需要有一个东西发生突变，也就是当前调度的状态。调度程序机制还提供了一种从对象中读取属性的方法，这就足以将遍历链接列表表达到调度程序中。这也意味着零分配。</p>
<p>所以，不多说了，下面是链接列表（在 NQP 这个受限的 Raku 子集中，相当不如在完整的 Raku 中漂亮）。</p>
<pre><code class="language-raku" data-lang="raku"># A linked list is used to model the state of a dispatch that is deferring
# through a set of methods, multi candidates, or wrappers. The Exhausted class
# is used as a sentinel for the end of the chain. The current state of the
# dispatch points into the linked list at the appropriate point; the chain
# itself is immutable, and shared over (runtime) dispatches.
my class DeferralChain {
    has $!code;
    has $!next;
    method new($code, $next) {
        my $obj := nqp::create(self);
        nqp::bindattr($obj, DeferralChain, '$!code', $code);
        nqp::bindattr($obj, DeferralChain, '$!next', $next);
        $obj
    }
    method code() { $!code }
    method next() { $!next }
};
my class Exhausted {};
</code></pre><p>最后是恢复处理。</p>
<pre><code class="language-raku" data-lang="raku">nqp::dispatch('boot-syscall', 'dispatcher-register', 'raku-meth-call-resolved',
    # Initial dispatch
    -&gt; $capture {
        ... 'Presented earlier;
    },
    # Resumption. The resume init capture's first two arguments are the type
    # that we initially did a method dispatch against and the method name
    # respectively.
    -&gt; $capture {
        # Work out the next method to call, if any. This depends on if we have
        # an existing dispatch state (that is, a method deferral is already in
        # progress).
        my $init := nqp::dispatch('boot-syscall', 'dispatcher-get-resume-init-args');
        my $state := nqp::dispatch('boot-syscall', 'dispatcher-get-resume-state');
        my $next_method;
        if nqp::isnull($state) {
            # No state, so just starting the resumption. Guard on the
            # invocant type and name.
            my $track_start_type := nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $init, 0);
            nqp::dispatch('boot-syscall', 'dispatcher-guard-type', $track_start_type);
            my $track_name := nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $init, 1);
            nqp::dispatch('boot-syscall', 'dispatcher-guard-literal', $track_name);
 
            # Also guard on there being no dispatch state.
            my $track_state := nqp::dispatch('boot-syscall', 'dispatcher-track-resume-state');
            nqp::dispatch('boot-syscall', 'dispatcher-guard-literal', $track_state);
 
            # Build up the list of methods to defer through.
            my $start_type := nqp::captureposarg($init, 0);
            my str $name := nqp::captureposarg_s($init, 1);
            my @mro := nqp::can($start_type.HOW, 'mro_unhidden')
                ?? $start_type.HOW.mro_unhidden($start_type)
                !! $start_type.HOW.mro($start_type);
            my @methods;
            for @mro {
                my %mt := nqp::hllize($_.HOW.method_table($_));
                if nqp::existskey(%mt, $name) {
                    @methods.push(%mt{$name});
                }
            }
 
            # If there's nothing to defer to, we'll evaluate to Nil (just don't set
            # the next method, and it happens below).
            if nqp::elems(@methods) &gt;= 2 {
                # We can defer. Populate next method.
                @methods.shift; # Discard the first one, which we initially called
                $next_method := @methods.shift; # The immediate next one
 
                # Build chain of further methods and set it as the state.
                my $chain := Exhausted;
                while @methods {
                    $chain := DeferralChain.new(@methods.pop, $chain);
                }
                nqp::dispatch('boot-syscall', 'dispatcher-set-resume-state-literal', $chain);
            }
        }
        elsif !nqp::istype($state, Exhausted) {
            # Already working through a chain of method deferrals. Obtain
            # the tracking object for the dispatch state, and guard against
            # the next code object to run.
            my $track_state := nqp::dispatch('boot-syscall', 'dispatcher-track-resume-state');
            my $track_method := nqp::dispatch('boot-syscall', 'dispatcher-track-attr',
                $track_state, DeferralChain, '$!code');
            nqp::dispatch('boot-syscall', 'dispatcher-guard-literal', $track_method);
 
            # Update dispatch state to point to next method.
            my $track_next := nqp::dispatch('boot-syscall', 'dispatcher-track-attr',
                $track_state, DeferralChain, '$!next');
            nqp::dispatch('boot-syscall', 'dispatcher-set-resume-state', $track_next);
 
            # Set next method, which we shall defer to.
            $next_method := $state.code;
        }
        else {
            # Dispatch already exhausted; guard on that and fall through to returning
            # Nil.
            my $track_state := nqp::dispatch('boot-syscall', 'dispatcher-track-resume-state');
            nqp::dispatch('boot-syscall', 'dispatcher-guard-literal', $track_state);
        }
 
        # If we found a next method...
        if nqp::isconcrete($next_method) {
            # Call with same (that is, original) arguments. Invoke with those.
            # We drop the first two arguments (which are only there for the
            # resumption), add the code object to invoke, and then leave it
            # to the invoke or multi dispatcher.
            my $just_args := nqp::dispatch('boot-syscall', 'dispatcher-drop-arg',
                nqp::dispatch('boot-syscall', 'dispatcher-drop-arg', $init, 0),
                0);
            my $delegate_capture := nqp::dispatch('boot-syscall',
                'dispatcher-insert-arg-literal-obj', $just_args, 0, $next_method);
            if nqp::istype($next_method, Routine) &amp;&amp; $next_method.is_dispatcher {
                nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-multi',
                        $delegate_capture);
            }
            else {
                nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-invoke',
                        $delegate_capture);
            }
        }
        else {
            # No method, so evaluate to Nil (boot-constant disregards all but
            # the first argument).
            nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'boot-constant',
                nqp::dispatch('boot-syscall', 'dispatcher-insert-arg-literal-obj',
                    $capture, 0, Nil));
        }
    });
</code></pre><p>这是相当多的内容，也是相当多的代码。但请记住，这只是运行在调度恢复的记录阶段。它还会在 callsame 的 callsite 产生一个调度程序，并带有通常的守卫和结果。隐式守卫是为我们在该点恢复的调度程序创建的。在最常见的情况下，这最终将是单形或双形的，尽管涉及多个调度或方法调度的嵌套的情况可能会产生一个更有形态的 callsite。</p>
<p>我选取的设计迫使 resume 回调处理两种情况：第一次复用和后一次复用。这在几个方面都不理想。</p>
<p>这对那些编写调度简历回调的人来说有点不方便。然而，这又不是特别常见的活动!</p>
<p>这种差异导致两个调度程序堆积在一个调用点，而在其他情况下，这个调用点可能只得到一个
只有其中第二项真正重要。之所以不统一，是为了确保绝大多数从未恢复调度的电话，不会因其最终从未使用的功能而产生每次调度的费用。如果结果是使用该功能的人多花了一点成本，那就这样吧。事实上，早期的基准测试显示，使用新调度器的 callsame 与 wrap 和方法调用似乎比当前 Rakudo 中的速度快了 10 倍，这还没等专门人员对它有足够的了解，就已经进一步改进了!</p>
<h2 id="目前所做的事情">目前所做的事情</h2>
<p>我上面讨论的所有内容都已经实现了，只是我可能在某个地方给人的印象是，使用新的 dispatcher 已经完全实现了多重调度，而现在还不是这样（没有处理 where 子句，也不支持调度恢复）。</p>
<h2 id="今后的步骤">今后的步骤</h2>
<p>下一步显然是要完全实现多调度的缺失部分。另一个缺失的语义是对 callwith 和 nextwith 的支持，当我们希望改变移动到下一个候选人时使用的参数。抛开其他一些小问题不谈，理论上来说，这至少可以让所有的 Raku 调度语义得到支持。</p>
<p>目前，所有的标准方法调用（$obj.meth()）和其他调用（foo()和$foo()）都会通过现有的调度机制，而不是新的调度器。这些也需要迁移到新的调度器上，而且任何发现的错误都需要修复。这将使事情达到新调度器在语义上已经准备好的程度。</p>
<p>之后是性能工作：确保专用器能够处理调度程序的防护和结果。最初的目标是，让常见调用形式的稳态性能至少与当前乐道主分支中的性能相同。已经很清楚了，对于一些到目前为止还很冰冷的东西来说，会有一些大的胜利，但它不应该以最常见的调度种类的退步为代价，因为这些调度种类之前已经得到了大量的优化努力。</p>
<p>此外，NQP - 乐道编译器和运行时内脏的其他位写的乐的限制形式 - 也需要迁移到使用新的调度器。只有做到这一点，才有可能从 MoarVM 中扯出当前的方法缓存、多调度缓存等。</p>
<p>一个悬而未决的问题是，如何处理 MoarVM 以外的后端。理想情况下，新的调度机制将被移植到这些地方。相当多的内容应该可以用 JVM 的 invokedynamic 来表达（而这一切可能会在基于 Truffle 的 Raku 实现中发挥得相当好，尽管我不确定目前是否有这方面的积极努力）。</p>
<h2 id="未来的机会">未来的机会</h2>
<p>虽然我目前的重点是发布一个使用新调度机制的 Rakudo 和 MoarVM 版本，但这不会是旅程的终点。一些眼前的想法。</p>
<ul>
<li>对角色的方法调用需要把角色打入一个类中， 所以方法查找会返回一个闭包来完成这个任务并替换调用者。这是一个很大的间接性；新的调度者可以获得 pun，并产生一个调度程序，用 punn 化的类类型对象替换角色类型对象，这将使每次调用的成本大大降低。</li>
<li>我期望使用新的 dispatcher 可以使句柄（dlegated）和 fallback（处理缺失的方法调用）机制都能有更好的表现</li>
<li>当前的 assuming - 用于为例程讨价还价或其他首要参数 - 的实现并不理想，利用新调度器的参数重写能力的实现可能会有更好的表现。
在新的调度机制的帮助下，一些新的语言功能也可能以高效的方式提供。例如，目前没有一种可靠的方式来尝试调用一段代码，如果签名绑定了就运行它，如果没有绑定就做其他事情。相反，像 Cro 路由器这样的东西，必须先做签名的试绑定，然后再做调用，这使得路由的成本相当高。还有一个建议已久的想法，就是通过签名与 <code>when</code> 构造提供模式匹配 (例如，<code>when * -&gt; ($x) {}; when * -&gt; ($x, *@tail) { }</code>)，这和需求差不多，只是在一个不太动态的环境下。</li>
</ul>
<h2 id="最后">最后&hellip;</h2>
<p>在新的调度机制上的工作比我最初预期的历程要长。设计的恢复部分特别具有挑战性，而且还有一些重要的细节需要处理。一路走来，大概有四种潜在的方法被抛弃了（虽然其中的元素都影响了我在这篇文章中描述的内容）。能坚持下来的抽象真的非常非常难。</p>
<p>我最终也不得不从根本上离开几个月做 Raku 工作，在其他一些工作中感觉有点被压垮了，并且一直在与同样重要的 RakuAST 项目（它将因为能够承担新的调度器的存在而被简化，并且还为我提供了一系列更柔和的 Raku 黑客任务，而调度器的工作提供了很少的轻松选择）。</p>
<p>鉴于这些，我很高兴终于看到了隧道尽头的光亮。剩下的工作是数不胜数的，而我们使用新的调度器发布 Rakudo 和 MoarVM 的那一天，感觉还需要几个月的时间（我希望写下这句话不是在诱惑命运！）。</p>
<p>新的调度器可能是 MoarVM 自我创建以来最重要的变化，因为它看到我们删除了一堆从一开始就存在的东西。RakuAST 也将为 Rakudo 编译器带来十年来最大的架构变化。两者都是一个机会，将多年来学习的东西硬生生地折合到运行时和编译器中。我希望再过十年，当我回顾这一切的时候，至少会觉得自己这次犯了更多有趣的错误。</p>
<p>原文链接: <a href="https://6guts.wordpress.com/2021/03/15/towards-a-new-general-dispatch-mechanism-in-moarvm/">https://6guts.wordpress.com/2021/03/15/towards-a-new-general-dispatch-mechanism-in-moarvm/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[BUILD 和 TWEAK 的区别]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-03-07-difference-between-build-and-tweak-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="如何在 Raku 中输入 Unicode" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-17-method-isd/?utm_source=atom_feed" rel="related" type="text/html" title="Method-ish" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/?utm_source=atom_feed" rel="related" type="text/html" title="模式分派" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-custom-when/?utm_source=atom_feed" rel="related" type="text/html" title="自定义 when" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/?utm_source=atom_feed" rel="related" type="text/html" title="为最年轻的 Raku 贡献力量" />
            
                <id>https://ohmyweekly.github.io/notes/2021-03-07-difference-between-build-and-tweak-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-03-07T00:00:00+08:00</published>
            <updated>2021-03-07T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Difference Between Build and Tweak in Raku</blockquote><pre><code class="language-raku" data-lang="raku">class Student {
    has $.name;
    has $.sex;
    has $!age;

    method BUILD(:$!name) {

    }
}

my $stu = Student.new(:name('赵今麦'), :sex('女'));
dd $stu;
# Student $stu = Student.new(name =&gt; &quot;赵今麦&quot;, sex =&gt; Any)
</code></pre><p>如果你加上 <code>BUILD</code> 方法, 你必须自己全权负责设置所有的东西。也就是既包括公共属性, 也包括私有属性。</p>
<p>但你可以通过巧妙地命名参数来让你的生活更轻松。</p>
<pre><code class="language-raku" data-lang="raku">method BUILD (:$!name, :$!sex, :$!age) { }
</code></pre><p><code>BUILD</code> 方法可以初始化私有属性:</p>
<pre><code class="language-raku" data-lang="raku">class Student {
    has $.name;
    has $.sex;
    has $!age;

    method BUILD(:$name, :$sex, :$age) {
        $!name = $name;
        $!sex = $sex;
        $!age = $age;
    }

    method heart() { return '♥ ' ~ $!age }
}

my $stu = Student.new(:name('赵今麦'), :sex('女'), :age(18));
dd $stu;
say $stu;
say $stu.heart(); 
</code></pre><p>也可以在 TWEAK 方法中初始化私有属性:</p>
<pre><code class="language-raku" data-lang="raku">class Student {
    has $.name;
    has $.sex;
    has $!age;

    method TWEAK(:$name, :$sex, :$age) {
        $!age = $age + 1;
    }

    method heart() { return '♥' ~ $!age }
}

my $stu = Student.new(:name('赵今麦'), :sex('女'), :age(18));
dd $stu;
say $stu;
say $stu.heart(); 
</code></pre><p>使用 <code>TWEAK</code>，你会得到与 <code>BUILD</code> 相同的参数，但所有的初始设置都已经完成了（<code>BUILD</code> 或公共属性的自动绑定，以及所有的默认值，再加上保证所需值的存在）。你只是有机会做一些最后的调整。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/raku" term="raku" label="Raku" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/build" term="build" label="BUILD" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/tweak" term="tweak" label="TWEAK" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/object" term="object" label="Object" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[如何在 Raku 中输入 Unicode]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-02-17-method-isd/?utm_source=atom_feed" rel="related" type="text/html" title="Method-ish" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/?utm_source=atom_feed" rel="related" type="text/html" title="模式分派" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-custom-when/?utm_source=atom_feed" rel="related" type="text/html" title="自定义 when" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/?utm_source=atom_feed" rel="related" type="text/html" title="为最年轻的 Raku 贡献力量" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
            
                <id>https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-03-01T00:00:00+08:00</published>
            <updated>2021-03-01T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>How to Type Unicode in Raku</blockquote><p>Raku 有非常好的 Unicode 支持, 但是输入 Unicode 一直是一个很大的问题。在 REPL 中, 输入 Unicode 都不太方便。下面介绍几种方法来方便地输入 Unicode。</p>
<h1 id="comma">Comma</h1>
<p>最方便的是使用 Raku 自己的 IDE, <a href="http://commaide.com">Comma</a>。但是需要做两个设置:</p>
<p>首先, 切换到 Comma IDE, 点击左上角菜单栏的 <strong>Comma</strong> 选项, 在弹出的 <strong>Preference</strong> 窗口中, 找到左侧菜单栏中的 <strong>Editor</strong> 选项, 点击 <strong>Code Style</strong> 中的 <strong>Raku</strong>, 在右侧的窗口的最上面, 找到 <strong>Schema</strong> 一行, 点击倒三角图标, 在下拉菜单中选择 <strong>Project</strong>。然后在第二行文字中找到 <strong>Editor Behavior</strong>, 勾选 <strong>Convert operators to Unicode</strong>。完成后点击右下角的 <strong>Apply</strong>, 然后点击 <strong>OK</strong>。</p>
<p>这样当你在 Comma 中键入 <code>&gt;&gt;</code> 这样的运算符后, Comma 会自动把它转为 Unicode 形式的 <code>»</code>。目前已支持大部分 Unicode 运算符了。Comma 是跨平台的 Raku 编辑器, 支持 Windows、Linux 和 MacOS, 所以你想跨平台开发的话, Comma 值得一试。</p>
<h1 id="kitty">Kitty</h1>
<p>如果你想在 Vim 中开发 Raku, 又不想失去输入 Unicode 的乐趣, 请使用 <a href="https://github.com/kovidgoyal/kitty">Kitty</a> 终端。点开 Kitty 终端, 使用快捷键 Ctrl + Shift + U 即可触发输入 Unnicode 的界面(也可以键入命令 kitty +kitten unicode_input 来触发)。再通过快捷键  F1、F2、F3 和 F4 (或通过 Ctrl+[ 和 Ctrl+] 切换标签)可以分别按代码搜索 Unicode、按名字搜索 Unicode、按表情搜索和收藏。</p>
<p>例如在 REPL 中键入 Unicode 字符:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ raku
Welcome to 𝐑𝐚𝐤𝐮𝐝𝐨™ v2021.02.
Implementing the 𝐑𝐚𝐤𝐮™ programming language v6.d.
Built on MoarVM version 2021.02.

To <span class="nb">exit</span> <span class="nb">type</span> <span class="s1">&#39;exit&#39;</span> or <span class="s1">&#39;^D&#39;</span>
&gt; my @a <span class="o">=</span> 1..5<span class="p">;</span>
&gt; @a».sin
</code></pre></div><p>借助 Kitty, 数组 <code>@a</code> 后面的 <code>»</code> 可以这样输入, 先输入 <code>@a</code>, 然后使用快捷键 Shift + Ctrl + U 调出 Kitty 的 <strong>Unicode input</strong> 界面, 一般有两种方法, 第一种是通过快捷键 F1, 然后输入对应的 Unicode 编码, 再回车。第二种是通过快捷键 F2, 通过名字搜索, 例如输入单词 quota, 会出现一堆引号符号供你选择, 按上下方向键选中 <code>»</code>, 再回车即可。Vim 中同理。</p>
<h1 id="julia-repl">Julia REPL</h1>
<p>在 REPL 中输入 <code>\′ + 单词 + Tab, 例如输入 </code>\heartsuit` 再按 Tab, 就会自动变成 ♡</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">julia&gt; <span class="se">\h</span>eartsuit
</code></pre></div><h1 id="ipython">IPython</h1>
<p><code>\^</code> 输入上标, <code>\_p</code> 输入下标。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ipython
<span class="se">\^</span>a
<span class="se">\_</span>p
</code></pre></div><h1 id="vscode">VScode</h1>
<p><code>\\′ + 完整的单词 + Tab, VsCode 会自动转换为 Unicode。 例如 </code>^a<code>和</code>_p`</p>
<h1 id="dmenu">dmenu</h1>
<div class="highlight"><pre class="chroma"><code class="language-perl" data-lang="perl"><span class="ch">#!/usr/bin/perl</span>

<span class="c1">#use strict;</span>
<span class="c1">#use warnings;</span>
<span class="c1">#use autodie;</span>
<span class="c1">#use utf8;</span>


<span class="nb">open</span> <span class="nv">$FH</span><span class="p">,</span> <span class="s">&#34; | dmenu -i -l 30 -fn &#39;-xos4-terminus-medium-r-*-*-10-*&#39; | sed &#39;s/^\\(.\\).*/\\1/&#39; | tr -d &#39;\n&#39; | { pbcopy; pbpaste; } &#34;</span><span class="p">;</span>

<span class="c1"># if you do not have the xos4-terminus font that makes characters a little bigger :</span>
<span class="c1"># uncoment this line and use the second here document</span>
<span class="c1">#open $FH, &#34; | dmenu -i -l 30 | sed &#39;s/^\\(.\\).*/\\1/&#39; | tr -d &#39;\n&#39; | { xsel -ib; xsel -ip; } &#34;;</span>

<span class="c1"># also you can compile dmenu from source and change the font size directly in the C done</span>
<span class="c1"># in the file config.h / config.def.h</span>

<span class="c1"># this heredoc is well aligned with the -xos4-terminus-medium-r-*-*-10-* font</span>

<span class="k">print</span> <span class="nv">$FH</span> <span class="s">&lt;&lt;&#39;</span><span class="dl">EOF</span><span class="s">&#39;
</span><span class="s">«         hyper operator
</span><span class="s">»         hyper operator
</span><span class="s">∈        membership
</span><span class="s">∉        non-membership
</span><span class="s">∪         set union
</span><span class="s">∩         set intersection
</span><span class="s">∖         set difference
</span><span class="s">≡         set equality
</span><span class="s">≢        set inequality
</span><span class="s">⊖        symmetric set difference
</span><span class="s">⊍         baggy multiplication
</span><span class="s">⊎         baggy addition
</span><span class="s">∅        empty set
</span><span class="s">⊆        subset
</span><span class="s">⊈         not a subset
</span><span class="s">⊂        strict subset
</span><span class="s">⊄        not a strict subset
</span><span class="s">∋        reverse membership
</span><span class="s">∌          reverse non-membership
</span><span class="s">⊇        superset
</span><span class="s">⊉         not a superset
</span><span class="s">⊃        strict superset
</span><span class="s">⊅        not a strict superset
</span><span class="s">∞         infinity
</span><span class="s">⚛        atomic operator
</span><span class="s">π        pi
</span><span class="s">τ         tau
</span><span class="s">𝑒         Euler&#39;s number
</span><span class="s">∘         function composition
</span><span class="s">×        multiplication 
</span><span class="s">÷        division
</span><span class="s">≤         inferior or equal
</span><span class="s">≥         greater or equal
</span><span class="s">≠   	     inequality
</span><span class="s">−        substraction
</span><span class="s">≅       approximatively equal
</span><span class="s">…      sequence operator
</span><span class="s">‘         left single quotation mark
</span><span class="s">’         right single quotation mark
</span><span class="s">‚         single low-9 quotation mark 
</span><span class="s">”         right double quotation mark
</span><span class="s">“         left double quotation mark
</span><span class="s">„         double low-9 quotation mark
</span><span class="s">｢         halfwidth left corner bracket
</span><span class="s">｣         halfwidth right corner bracket
</span><span class="s">⁺         plus superscript
</span><span class="s">⁻         minus superscript
</span><span class="s">⁰         0 superscript
</span><span class="s">¹         1 superscript 
</span><span class="s">²         2 superscript 
</span><span class="s">³         3 superscript 
</span><span class="s">⁴         4 superscript 
</span><span class="s">⁵         5 superscript 
</span><span class="s">⁶         6 superscript 
</span><span class="s">⁷         7 superscript 
</span><span class="s">⁸         8 superscript 
</span><span class="s">⁹         9 superscript 
</span><span class="s"></span><span class="dl">EOF</span>
<span class="p">;</span>

<span class="c1"># use this without -xos4-terminus-medium-r-*-*-10-* font</span>
<span class="c1"># the default font may change given which font packages are installed and given the font configurations</span>

<span class="c1">#print $FH &lt;&lt;&#39;EOF&#39;</span>
<span class="c1">#«         hyper operator</span>
<span class="c1">#»         hyper operator</span>
<span class="c1">#∈         membership</span>
<span class="c1">#∉         non-membership</span>
<span class="c1">#∪         set union</span>
<span class="c1">#∩         set intersection</span>
<span class="c1">#∖         set difference</span>
<span class="c1">#≡         set equality</span>
<span class="c1">#≢         set inequality</span>
<span class="c1">#⊖         symmetric set difference</span>
<span class="c1">#⊍         baggy multiplication</span>
<span class="c1">#⊎         baggy addition</span>
<span class="c1">#∅         empty set</span>
<span class="c1">#⊆         subset</span>
<span class="c1">#⊈         not a subset</span>
<span class="c1">#⊂         strict subset</span>
<span class="c1">#⊄         not a strict subset</span>
<span class="c1">#∋         reverse membership</span>
<span class="c1">#∌         reverse non-membership</span>
<span class="c1">#⊇         superset</span>
<span class="c1">#⊉         not a superset</span>
<span class="c1">#⊃         strict superset</span>
<span class="c1">#⊅         not a strict superset</span>
<span class="c1">#∞         infinity</span>
<span class="c1">#⚛         atomic operator</span>
<span class="c1">#π         pi</span>
<span class="c1">#τ         tau</span>
<span class="c1">#𝑒         Euler&#39;s number</span>
<span class="c1">#∘         function composition</span>
<span class="c1">#×         multiplication </span>
<span class="c1">#÷         division</span>
<span class="c1">#≤         inferior or equal</span>
<span class="c1">#≥         greater or equal</span>
<span class="c1">#≠         inequality</span>
<span class="c1">#−         substraction</span>
<span class="c1">#≅         approximatively equal</span>
<span class="c1">#…         sequence operator</span>
<span class="c1">#‘         left single quotation mark</span>
<span class="c1">#’         right single quotation mark</span>
<span class="c1">#‚         single low-9 quotation mark </span>
<span class="c1">#”         right double quotation mark</span>
<span class="c1">#“         left double quotation mark</span>
<span class="c1">#„         double low-9 quotation mark</span>
<span class="c1">#｢         halfwidth left corner bracket</span>
<span class="c1">#｣         halfwidth right corner bracket</span>
<span class="c1">#⁺         plus superscript</span>
<span class="c1">#⁻         minus superscript</span>
<span class="c1">#⁰         0 superscript</span>
<span class="c1">#¹         1 superscript </span>
<span class="c1">#²         2 superscript </span>
<span class="c1">#³         3 superscript </span>
<span class="c1">#⁴         4 superscript </span>
<span class="c1">#⁵         5 superscript </span>
<span class="c1">#⁶         6 superscript </span>
<span class="c1">#⁷         7 superscript </span>
<span class="c1">#⁸         8 superscript </span>
<span class="c1">#⁹         9 superscript </span>
<span class="c1">#EOF</span>
<span class="c1">#;</span>



<span class="nb">close</span> <span class="nv">$FH</span><span class="p">;</span>



<span class="cp">__END__
</span><span class="cp">
</span><span class="cp">
</span><span class="cp">=pod 
</span><span class="cp">
</span><span class="cp">=head1 NAME
</span><span class="cp">
</span><span class="cp">lazy_raku_unicode.pl
</span><span class="cp">
</span><span class="cp">=head1 SYNOPSIS
</span><span class="cp">
</span><span class="cp">This script allows you to select a Unicode symbol from a drop-down menu that you can simply paste into your text editor, terminal or IDE.
</span><span class="cp">
</span><span class="cp">All it does is send a heredoc through a pipe to dmenu, and copy to the clipboard the character that you selected.
</span><span class="cp">
</span><span class="cp">Dmenu is a program that reads lines from stdin, display them in a menu, and write to stdout the lines selected.
</span><span class="cp">
</span><span class="cp">It is not practical to execute this script from a terminal each time you want a character though. This is why it should be executed by sxhkd.
</span><span class="cp">
</span><span class="cp">Sxhkd is the program that will call this script each time you press the right key combination.
</span><span class="cp">
</span><span class="cp">Only the most useful Unicode characters are present to not make dmenu get too slow. (It is usually very fast when there is only ascii text.)
</span><span class="cp">
</span><span class="cp">This include most of the Raku operators that have a Unicode version, plus some quoting characters, superscripts, and mathematical constants.
</span><span class="cp">
</span><span class="cp">=head1 MANUAL INSTALLATION STEPS
</span><span class="cp">
</span><span class="cp">
</span><span class="cp">=head2 INSTALLING DMENU
</span><span class="cp">
</span><span class="cp">B&lt;On Debian or Ubuntu :&gt;
</span><span class="cp">
</span><span class="cp">	sudo apt install suckless-tools
</span><span class="cp">
</span><span class="cp">B&lt;On Archlinux :&gt;
</span><span class="cp">
</span><span class="cp">	sudo pacman -Sy dmenu
</span><span class="cp">
</span><span class="cp">B&lt;Compile it from source :&gt;
</span><span class="cp">
</span><span class="cp">	https://tools.suckless.org/dmenu/
</span><span class="cp">
</span><span class="cp">=head2 CHANGING DMENU FONT SIZE (OPTIIONAL)
</span><span class="cp">
</span><span class="cp">You have only two ways of changing the font size :
</span><span class="cp">
</span><span class="cp">Change the default font with the B&lt;-fn&gt; flag (See dmenu(1) for the specifics).
</span><span class="cp">	
</span><span class="cp">	dmenu -l 30 -fn &#39;-xos4-terminus-medium-r-*-*-10-*&#39;
</span><span class="cp">
</span><span class="cp">
</span><span class="cp">Modify directly the C source code of dmenu. Only the files B&lt;config.h / config.def.h&gt;.
</span><span class="cp">
</span><span class="cp">Simply edit this line and change 10 by 14 for example.
</span><span class="cp">
</span><span class="cp">	static const char *fonts[] = {
</span><span class="cp">		&#34;monospace:size=10&#34;
</span><span class="cp">	};
</span><span class="cp">
</span><span class="cp">Then execute sudo make install and you&#39;re ready to go.
</span><span class="cp">
</span><span class="cp">=head2 INSTALLING SXHKD
</span><span class="cp">
</span><span class="cp">
</span><span class="cp">B&lt;On Debian or Ubuntu :&gt;
</span><span class="cp">
</span><span class="cp">	sudo apt install sxhkd
</span><span class="cp">
</span><span class="cp">B&lt;On Archlinux :&gt;
</span><span class="cp">
</span><span class="cp">	sudo pacman -Sy sxhkd
</span><span class="cp">
</span><span class="cp">
</span><span class="cp">=head2 CONFIGURING SXHKD
</span><span class="cp">
</span><span class="cp">B&lt;Autostarting sxhkd at startup :&gt;
</span><span class="cp">
</span><span class="cp">simply put this line in B&lt;~/.xprofile&gt; :
</span><span class="cp">
</span><span class="cp">	sxhkd &amp;
</span><span class="cp">
</span><span class="cp">
</span><span class="cp">B&lt;Setting the keybinding :&gt;
</span><span class="cp">	
</span><span class="cp">
</span><span class="cp">Add these two lines in B&lt;~/.config/sxhkd/sxhkdrc&gt;
</span><span class="cp">
</span><span class="cp">	ctrl + apostrophe
</span><span class="cp">		/path/to/lazy_raku_unicode.pl
</span><span class="cp">
</span><span class="cp">The keybinding have to start at the beginning of a line, and the command has to follow on the next line and be preceded by a tabulation.
</span><span class="cp">
</span><span class="cp">To make sxhkd reload the config file, either kill it and relaunch it, or send a SIGUSR1 signal. This command can do it :
</span><span class="cp">
</span><span class="cp">	pidof sxhkd | kill -SIGUSR1 $(cat /dev/stdin)
</span><span class="cp">
</span><span class="cp">If you want to use a different keybinding, please see sxhkd(1) and use xev(1) to find the name of keys.
</span><span class="cp">
</span><span class="cp">Here the name of some of the keys : ctrl, super, alt, Return .
</span><span class="cp">
</span><span class="cp">=head1 SEE ALSO
</span><span class="cp">
</span><span class="cp">dmenu(1), sxhkd(1), xev(1)
</span><span class="cp">
</span><span class="cp">
</span><span class="cp">=cut
</span></code></pre></div><p>参考链接: <a href="https://docs.raku.org/language/unicode_entry">https://docs.raku.org/language/unicode_entry</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/raku" term="raku" label="Raku" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/unicode" term="unicode" label="Unicode" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Method-ish]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-02-17-method-isd/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/?utm_source=atom_feed" rel="related" type="text/html" title="模式分派" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-custom-when/?utm_source=atom_feed" rel="related" type="text/html" title="自定义 when" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/?utm_source=atom_feed" rel="related" type="text/html" title="为最年轻的 Raku 贡献力量" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="related" type="text/html" title="如果集合如我所想" />
            
                <id>https://ohmyweekly.github.io/notes/2021-02-17-method-isd/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-28T00:00:00+08:00</published>
            <updated>2021-02-28T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Method-ish</blockquote><p>在我的上一篇文章中，我又一次为从 CORE 中增强类的方法而苦恼。这种挣扎完全没有必要，因为我并没有用增加的方法改变对象的状态。对于做更高级的东西，我可能不得不这样做。把手伸进 Raku 的内部这么深，我可能会把自己烫伤。既然我想做的是把我的代码绑在编译器的变化上，反正我可能会全身心地投入到 nqp-land 中去。</p>
<pre><code class="language-raku" data-lang="raku">my \j = 1 | 2 | 3;
dd j;
use nqp;
.say for nqp::getattr(j, Junction, '$!eigenstates');
# OUTPUT: any(1, 2, 3)
          1
          2
          3
</code></pre><p>我们可以使用 nqp 来获取私有属性，而不需要添加任何方法。这就有点儿不伦不类了。所以，让我们用一个伪方法来做一些 deboilerplating。</p>
<pre><code class="language-raku" data-lang="raku">sub pry(Mu $the-object is raw) {
    use InterceptAllMethods;

    class Interceptor {
        has Mu $!the-object;
        method ^find_method(Mu \type, Str $name) {
            my method (Mu \SELF:) is raw {
                use nqp;
                my $the-object := nqp::getattr(SELF, Interceptor, '$!the-object');
                nqp::getattr($the-object, $the-object.WHAT, '$!' ~ $name)
            }
        }
    }

    use nqp;
    nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object);
}

.say for j.&amp;pry.eigenstates;
# OUTPUT: 1
          2
          3
</code></pre><p>通过 InterceptAllMethods，lizmat 改变了类关键字的行为，允许我们提供一个 FALLBACK-method 来捕获任何方法，包括从 Mu 继承的方法。这反过来又允许 pry 返回的对象将任何方法调用转移到一个自定义的方法。在这个方法中，我们可以对 <code>.&amp;pry</code> 被调用的对象做任何我们想做的事情。</p>
<p>由于我们的特殊对象会拦截任何调用，甚至是 Mu 的调用，我们需要找到另一种方法来调用 <code>.new</code>。由于 <code>.^</code> 不是 <code>.</code> 的特殊形式，我们可以用它来获得对类方法的访问。</p>
<pre><code class="language-raku" data-lang="raku">sub interceptor(Method $the-method){
    use InterceptAllMethods;
    use nqp;

    sub (Mu $the-object is raw) {
        my class Interceptor {
            has Mu $!the-object;
            has Code $!the-method;

            method ^find_method(Mu \type, Mu:D $name) {
                my method (Mu \SELF: |c) is raw {
                    $!the-method.($!the-object, $name, |c)
                }
            }
            method ^introspect(Mu \type, Mu \obj) {
                my method call-it() is raw {
                    $!the-object
                }
                obj.&amp;call-it;
            }
            method ^new(Mu \type, $the-object!, $the-method) {
                nqp::p6bindattrinvres(
                        nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object),
                        Interceptor, '$!the-method', $the-method)
            }
        }

            # nqp::p6bindattrinvres(
                #     nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object),
                #   Interceptor, '$!the-method', $the-method);
        Interceptor.^new($the-object, $the-method)
    }
}

my &amp;first-defined = interceptor(
    my method (Positional \SELF: $name) {
        for SELF.flat -&gt; $e {
            with $e.&quot;$name&quot;(|%_) {
                .return
            }
        }
        Nil
    }
);

my $file = &lt;file1.txt file2.txt file3.txt nohup.out&gt;».IO.&amp;first-defined.open(:r);
dd $file;
# OUTPUT: Handle $file = IO::Handle.new(path =&gt; IO::Path.new(&quot;nohup.out&quot;, :SPEC(IO::Spec::Unix), :CWD(&quot;/home/dex/projects/raku/tmp&quot;)), chomp =&gt; Bool::True, nl-in =&gt; $[&quot;\n&quot;, &quot;\r\n&quot;], nl-out =&gt; &quot;\n&quot;, encoding =&gt; &quot;utf8&quot;)
</code></pre><p>sub <code>interceptor</code> 接受一个方法并返回一个 sub。如果这个 sub 像方法一样被调用，它将把要被调用的方法的名称和调用者转发给一个自定义方法。当 <code>.&amp;first-defined</code> 被调用时，会返回一个特殊的对象。让我们来看看它是什么。</p>
<pre><code class="language-raku" data-lang="raku">my \uhhh-special = &lt;a b c&gt;.&amp;first-defined;
dd uhhh-special.^introspect(uhhh-special);
# OUTPUT: ($(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), method &lt;anon&gt; (Positional \SELF: $name, *%_) { #`(Method|93927752146784) ... })
</code></pre><p>我们必须给 <code>.^introspect</code> 一个我们想看的对象，因为它的调用者是类 Interceptor 的类型对象。</p>
<p>目前，我还不知道有什么办法（毕竟，我知道的只是足够多的东西，真的很危险。这是不幸的，因为 lizmat 决定重载关键字 <code>class</code>，而不是用不同的名字导出特殊的 <code>Metamodel::ClassHOW</code>。如果我们不想或不能有外部依赖，我们可以使用 MOP 来创建我们的类型对象。</p>
<pre><code class="language-raku" data-lang="raku">class InterceptHOW is Metamodel::ClassHOW {
    method publish_method_cache(|) { }
}

sub ipry(Mu $the-object is raw) {
    my \Interceptor = InterceptHOW.new_type(:name&lt;Interceptor&gt;);
    Interceptor.^add_attribute(Attribute.new(:name&lt;$!the-object&gt;, :type(Mu), :package(Interceptor)));
    Interceptor.^add_meta_method('find_method',
        my method find_method(Mu \type, Str $name) {
            # say „looking for $name“;
            my method (Mu \SELF:) is raw {
                use nqp;
                my $the-object := nqp::getattr(SELF, Interceptor, '$!the-object');
                nqp::getattr($the-object, $the-object.WHAT, '$!' ~ $name)
            }
    });
    Interceptor.^compose;

    use nqp;
    nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object);
}
</code></pre><p>当我写这篇文章的时候，我发现 <code>.^add_meta_method</code> 只有在提供给它的方法的第一个参数的名字和 <code>Str</code> 相同的时候才会工作。起初，我尝试了一个匿名方法，它最终出现在 <code>.^meta_method_table</code> 中，但从未被调用。我想这个 bug 其实并不重要，因为这个元方法根本没有被记录下来。如果我玩火，我没有权利抱怨烧伤。你会在野外的 <code>Actions.nqp</code> 中发现这个方法。Class 关键字并没有什么神奇的作用。Rakudo 只是使用 MOP 来构造类型对象。</p>
<p>我们不能在 Raku 中重载赋值操作符。这其实并不需要，因为赋值是通过调用一个名为 STORE 的方法来实现的。由于我们得到了对 dispatch 的完全控制，我们可以拦截任何方法调用，包括一连串的方法调用。</p>
<pre><code class="language-raku" data-lang="raku">multi sub methodify(%h, :$deeply!) {
    sub interceptor(%h, $parent = Nil){
        use InterceptAllMethods;
        use nqp;

        class Interceptor is Callable {
            has Mu $!the-object;
            has Mu @!stack;

            method ^find_method(Mu \type, Mu:D $name) {
                my method (Mu \SELF: |c) is raw {
                    my @new-stack = @!stack;
                    my $the-object = $!the-object;

                    if $name eq 'STORE' {
                        # workaround for rakudobug#4203
                        $the-object{||@new-stack.head(*-1)}:delete if $the-object{||@new-stack.head(*-1)}:exists;

                        $the-object{||@new-stack} = c;
                        return-rw c
                    } else {
                        @new-stack.push: $name;
                        my \nextlevel = SELF.^new($!the-object, @new-stack, $name);
                        nextlevel
                    }
                }
            }
            method ^introspect(Mu \type, Mu \obj) {
                my method call-it() is raw {
                    $!the-object, @!stack
                }
                obj.&amp;call-it;
            }
            method ^new(Mu \type, $the-object!, @new-stack?, $name?) {
                $name
                    ?? nqp::p6bindattrinvres(
                        nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object),
                        Interceptor, '@!stack', @new-stack)
                    !! nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object)
                }
        }

        Interceptor.^new(%h)
    }

    interceptor(%h)
}

my %h2;
my $o2 = methodify(%h2, :deeply);
$o2.a.b = 42;
dd %h2;
$o2.a.b.c = &lt;answer&gt;;
dd %h2;
say $o2.a.b.c;
# OUTPUT: Hash %h2 = {:a(${:b(\(42))})}
          Hash %h2 = {:a(${:b(${:c(\(&quot;answer&quot;))})})}
          This type cannot unbox to a native string: P6opaque, Interceptor
            in block &lt;unit&gt; at /home/dex/projects/raku/any-chain.raku line 310
</code></pre><p>每当我们调用一个方法时，都会创建一个新的 Interceptor 实例，它存储了前一个方法的名称。这样我们就可以沿着方法调用链移动。由于赋值调用 STORE，我们可以将赋值转移到我们用作实际数据结构的 Hash 中。唉，检索值就不一样了，因为 Raku 不区分方法调用和 FETCH。在这里，龙比我强。我还是包含了这个一半失败的尝试，因为我对 slippy 半列表有很好的利用。这需要使用 <code>v6.e.preview</code>，让我踩到了一个 bug。可能还有更多这样的情况。所以请使用同样的，这样我们就可以在 <code>.e</code> 发布到野外之前，把所有的野兽都杀掉。</p>
<p>能够完全控制方法调用链将是一件好事。也许我们可以用 RakuAST 来做到这一点。</p>
<p>有了这些已经可以工作的东西，我们可以做一些有趣的事情。那些烦人的异常总是在拖我们的后腿。我们可以用 <code>try</code> 来化解它们，但那会破坏一个方法调用链。</p>
<pre><code class="language-raku" data-lang="raku">constant no-argument-given = Mu.new;
sub try(Mu $obj is raw, Mu $alternate-value = no-argument-given) {
    interceptor(my method (Mu \SELF: $name, |c) {
        my $o = SELF;
        my \m = $o.^lookup($name) orelse {
            my $bt = Backtrace.new;
            my $idx = $bt.next-interesting-index($bt.next-interesting-index + 1);
            (X::Method::NotFound.new(:method($name), :typename($o.^name)) but role :: { method vault-backtrace { False }}).throw(Backtrace.new($idx + 1));
        }

        try {
            $o = $o.&quot;$name&quot;(|c);
        }
 
        $! ~~ Exception
            ?? $alternate-value.WHICH eqv no-argument-given.WHICH
                ?? $o
                !! $alternate-value
            !! $o
    }).($obj)
}

class C {
    has $.greeting;
    method might-throw { die &quot;Not today love!&quot; }
    method greet { say $.greeting }
}

C.new(greeting =&gt; ‚Let's make love!‘).&amp;try.might-throw.greet;
# OUTPUT: Let's make love!
</code></pre><p>伪方法 try 将会化解任何异常，并允许继续调用 C 语言的方法。我必须用一个特殊的值来标记没有可选的参数 <code>$alternate-value</code>，因为它实际上可能会把异常对象变成 <code>Nil</code>。</p>
<p>我很肯定还有很多这样的小帮手在等着我们去发现。未来可能会有一个模块，希望能帮助 Raku 成为一个好的<a href="https://ftp.fau.de/fosdem/2021/D.perl/programming_lang_for_free_software.webm">编程语言</a>。</p>
<p>原文链接: <a href="https://gfldex.wordpress.com/2021/02/17/method-ish/">https://gfldex.wordpress.com/2021/02/17/method-ish/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/raku" term="raku" label="Raku" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku-%E5%8D%9A%E5%AE%A2" term="raku-%E5%8D%9A%E5%AE%A2" label="Raku 博客" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[模式分派]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-02-17-method-isd/?utm_source=atom_feed" rel="related" type="text/html" title="Method-ish" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-custom-when/?utm_source=atom_feed" rel="related" type="text/html" title="自定义 when" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/?utm_source=atom_feed" rel="related" type="text/html" title="为最年轻的 Raku 贡献力量" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="related" type="text/html" title="如果集合如我所想" />
            
                <id>https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-28T00:00:00+08:00</published>
            <updated>2021-02-28T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Pattern Dispatch</blockquote><p>一直以来乐于助人的 <a href="https://stackoverflow.com/users/1077672/raiph">raiph</a> 在回答一个关于模式匹配的<a href="https://stackoverflow.com/questions/66233465/haskell-like-pattern-matching-in-raku">问题</a>时希望得到 RakuAST，就像在 Haskell 中一样。有人提出用 MMD 来解决这个问题。这样做，得到一个贯穿的默认路径是无解的。由于 dispatch 简单来说就是模式匹配，我们只需要做一些额外的工作。简而言之，dispatcher 得到一个函数列表和一个带参数的列表。第一个接受所有参数的函数获胜。</p>
<pre><code class="language-raku" data-lang="raku">class Hold { has $.key; }
class Press { has $.key; }
class Err { has $.msg; }

sub else(&amp;code) { &amp;code }

sub match($needle, *@tests) {
    for @tests.head(*-1) -&gt; &amp;f {
        if &amp;f.cando(\($needle)) {
            return f($needle);
        }
    }
    @tests.tail.();
}

match Hold.new(:key&lt;a&gt;),
    -&gt; Hold (:$key) { put „holding $key“; },
    -&gt; Press (:$key) { put „pressing $key“; },
    -&gt; Err (:$msg) { warn „ERR: $msg“ },
    else { fail ‚unsopported‘ };
</code></pre><p>方法 <code>.cando</code> 需要一个 <a href="https://docs.raku.org/type/Capture">Capture</a> 来告诉我们一个 Routine 是否可以用一个给定的参数列表来调用。为了创建这样一个捕获，我们使用字面的 <code>\($arguments, $go, $here)</code>。我们不在最后测试默认值。相反，当没有其他函数匹配时，我们会调用该函数。声明 sub <code>else</code> 只是为了美化。</p>
<p>由于我们是在函数式的土地上，我们可以使用 Raku 提供给我们的所有方便的功能。</p>
<pre><code class="language-raku" data-lang="raku">my &amp;key-matcher = &amp;match.assuming(*,[
        -&gt; Hold (:$key) { put „holding $key“; },
        -&gt; Press (:$key) { put „pressing $key“; },
        -&gt; Err (:$msg) { warn „ERR: $msg“ },
        else { fail ‚unsopported‘ };
]);

sub key-source {
    gather loop {
        sleep 1;
        take (Hold.new(:key&lt;a&gt;), Press.new(:key&lt;b&gt;), Err.new(:msg&lt;WELP!&gt;), 'unsupported').pick;
    }
}

.&amp;key-matcher for key-source;
</code></pre><p>我们要帮助 <code>.assuming</code> 有点理解 slurpies，把函数列表放在一个显式 Array 中。</p>
<p>总有一种函数式的方法来解决一个问题。有时我们甚至可以从中得到一个整齐的语法。</p>
<p>原文链接: <a href="https://gfldex.wordpress.com/2021/02/24/pattern-dispatch/">https://gfldex.wordpress.com/2021/02/24/pattern-dispatch/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/raku" term="raku" label="Raku" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku-%E5%8D%9A%E5%AE%A2" term="raku-%E5%8D%9A%E5%AE%A2" label="Raku 博客" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[自定义 when]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-02-28-custom-when/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/?utm_source=atom_feed" rel="related" type="text/html" title="为最年轻的 Raku 贡献力量" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="related" type="text/html" title="如果集合如我所想" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-17-method-isd/?utm_source=atom_feed" rel="related" type="text/html" title="Method-ish" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/?utm_source=atom_feed" rel="related" type="text/html" title="模式分派" />
            
                <id>https://ohmyweekly.github.io/notes/2021-02-28-custom-when/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-28T00:00:00+08:00</published>
            <updated>2021-02-28T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Custom When</blockquote><p>我不太喜欢上一篇文章中使用匹配的语法。它的参数列表中的逗号看起来很奇怪，不合适。也许是因为我的眼睛习惯了给定的块。睡一觉就好了。</p>
<pre><code class="language-raku" data-lang="raku">sub accord(&amp;c) { (c(CALLER::&lt;$_&gt;); succeed) if &amp;c.cando(\(CALLER::&lt;$_&gt;)) }

given Err.new(:msg&lt;a&gt;) {
    accord -&gt; Hold (:$key) { put „holding $key“; }
    accord -&gt; Err (:$msg) { warn „ERR: $msg“ }
    default { fail ‚unsupported‘ }
}
</code></pre><p>这是因为 <code>accord</code> 模仿了 <code>when</code> 的工作。它做了一些匹配，当 True 时调用一个块，并在每个块的结尾添加一个 success（通过抛出一个控制异常）。given 所做的只是设置主题。它还充当了 caller 的角色，所以我们可以通过一个伪包来访问它的 <code>$_</code>。利用 pointy 的签名来做<a href="https://docs.raku.org/type/Signature#Destructuring_arguments">解构</a>是相当强大的。把这个添加到 CORE 中可能是个好主意。</p>
<p>我们可能要把 Raku 的定义改成: &ldquo;Raku 是一种高度可组合的编程语言&rdquo;, 在这里，所有的东西都会落到实处。&quot;</p>
<p>更新一下。</p>
<p>有些情况下，<code>$_</code> 不是动态的。另外，success 正在抛出一个控制异常，而这些的处理程序是由 when 或默认添加的。这种情况是在编译时发生的，目前不能用宏来解决。第一个问题可以用黑魔法解决。后一个问题需要用默认块。我没有找到一种方法来提供一个合理的错误信息，如果缺少这个块。</p>
<pre><code class="language-raku" data-lang="raku">multi sub accord(&amp;c) {
    use nqp;
    $_ := nqp::getlexcaller('$_');
    (c($_); succeed) if &amp;c.cando(\($_))
}

for @possibilities.roll(1) -&gt; $needle {
    given $needle {
        accord -&gt; Hold (:$key) { put „holding $key“; }
        accord -&gt; Err (:$msg) { warn „ERR: $msg“ }
        default { warn ‚unsopported‘ }
    }
}
</code></pre><p>原文链接: <a href="https://gfldex.wordpress.com/2021/02/25/custom-when/">https://gfldex.wordpress.com/2021/02/25/custom-when/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/raku" term="raku" label="Raku" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[为最年轻的 Raku 贡献力量]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="related" type="text/html" title="如果集合如我所想" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-16T00:00:00+08:00</published>
            <updated>2021-02-16T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Contributing to Raku</blockquote><p>在过去的几周里，我看到了一些<a href="https://mydeveloperplanet.com/2021/01/20/how-to-start-contributing-to-open-source/">文章</a>和<a href="https://youtu.be/GAqfMNB-YBU">视频</a>，讲述了在开源软件中构思是多么的伟大。这次我又想起了另一篇旧文<a href="http://strangelyconsistent.org/blog/perl-6-is-my-mmorpg">Raku 是我的 MMORPG</a>。它说，你可以从以下几个方面受益于开源软件。比如说，可以做一个大侠，基于一些开源软件来写软件。作为写手，可以写博客、微博等，对所选软件产生兴趣。或者你可以成为一个法师 - 实现新的功能和修复 bug。今天小编就带着弓箭手来告诉大家如何成为 <a href="https://raku.org/">Raku</a> 编程语言的法师。</p>
<h2 id="选择一个任务">选择一个任务</h2>
<p>让我们挑选一些编译器的 bug，并修复它。让我们去 <a href="https://rakudo.org/">Rakudo</a> 编译器 <a href="https://github.com/rakudo/rakudo/issues">issues</a>中选择我们想要修复的 bug。我滚动了一下 bug 列表，遇到了解析 - 运气不错，我前段时间一直在研究<a href="https://www.apress.com/gp/book/9781484232279">编译器语法</a>，看了一本这方面的好书。找到了四个问题。</p>
<p><img src="https://rakurs.atroxaper.net/assets/img/posts/2021-02-13-contributing-raku-1.png" alt="img"></p>
<ol>
<li>标签为 LTA （Less Than Awesome - 当真实行为与直觉预期不同时）- 我们暂时把它划掉。</li>
<li>标签 &ldquo;需要共识&rdquo; - 我们只想修复一个不复杂的 bug - 肯定要划掉。</li>
<li>标签为 &ldquo;grammar and actions&rdquo; 的关于一个可能死的代码是一个很好的候选人的第一个任务。</li>
</ol>
<p>任务确定后，现在我们需要配置工作环境。在 Windows、Linux 和 macOS 中，一切应该都差不多。我将通过 macOS 的例子来告诉你。</p>
<h2 id="建立工作环境">建立工作环境</h2>
<p>为源码和我们建立的编译器建立文件夹。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">mkdir ~/dev-rakudo <span class="o">&amp;&amp;</span> mkdir ~/dev-rakudo-install
</code></pre></div><p>Rakudo 编译器由三部分组成。</p>
<ol>
<li>虚拟机。现在有三种 - JVM、JS 和 MoarVM。我们以 MoarVM 为最稳定的一个。</li>
<li>NQP（Not Quite Perl），是一种低级（中级）语言的实现，它是 Raku 的一个 &ldquo;子集&rdquo;。虚拟机可以执行用 NQP 编写的代码。</li>
<li>Rakudo 编译器本身，用 NQP 和 Raku 编写。</li>
</ol>
<p>下载并编译这三个组件。我分别花了一分半钟、半分钟和两分半钟才编好。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:MoarVM/MoarVM.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> MoarVM
perl Configure.pl --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install

<span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:Raku/nqp.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> nqp
perl Configure.pl --backend<span class="o">=</span>moar --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install

<span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:rakudo/rakudo.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> rakudo
perl Configure.pl --backend<span class="o">=</span>moar --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install
</code></pre></div><p>注意参数。<code>--prefix</code> 显示了 <code>make install</code> 命令后可执行文件的复制位置，<code>--backend=moar</code> 表示正在使用的虚拟机，而 <code>-j 4</code> 则要求跨多线程并行化（以防加快进度）。现在我们已经建立了 Rakudo 编译器 <code>~/dev-rakudo-install/bin/raku</code>。我们还需要官方的编译器测试套件。你应该把它和它的代码一起放在文件夹里。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">cd</span> ~/dev-rakudo/rakudo <span class="o">&amp;&amp;</span> git clone https://github.com/Raku/roast.git t/spec
</code></pre></div><p>我们先进行测试。这种情况很常见，有些测试甚至在新的变化之前就失败了。我们需要辨别出来，这样以后就不会害怕这些变化破坏了一些不必要的东西。</p>
<p>这里和下面我将在 <code>~/dev-rakudo/rakudo</code> 文件夹中工作，除非另有说明。</p>
<pre><code>&gt; make spectest
[...]
Test Summary Report
-------------------
t/spec/S32-str/utf8-c8.t    (Wstat: 65280 Tests: 54 Failed: 0)
  Non-zero exit status: 255
  Parse errors: Bad plan.  You planned 66 tests but ran 54.
Files=1346, Tests=117144, 829 wallclock secs (27.70 usr  6.04 sys + 2638.79 cusr 210.98 csys = 2883.51 CPU)
Result: FAIL
make: *** [m-spectest5] Error 1
</code></pre><p>14分钟内共运行了1,346个文件中的117,144次测试。一些与utf8相关的测试由于某种原因失败了，其他的都能正常工作。我们已经准备好去工作了!</p>
<h2 id="让我们来看看问题的陈述">让我们来看看问题的陈述</h2>
<p>问题陈述说，某个元运算符 <code>R</code> 在 colonpair 上出了问题。我打开文档，搜索 R 这个词，但下拉列表中没有这个名字的元运算符。我试着输入 metaop，看到的是反向元操作符(R)。原来，如果你想把二元运算的操作数按相反的顺序写出来，你可以在其符号前使用前缀 R。</p>
<pre><code class="language-raku" data-lang="raku">say 3 R- 2 == -1 # Output: True
</code></pre><p>Colonpair 是命名对的语法。它看起来就像名字前面有一个冒号，前面有一个括号，有一个值。例如 <code>:foo(42)</code> 是一个名称为 <code>foo</code>、值为 <code>42</code> 的对儿。这个语法通常用于在调用函数时，向函数传递一个命名参数中的值。</p>
<pre><code class="language-raku" data-lang="raku">sub sub-with-named-parameter(:$foo) {
    say $foo;
}

sub-with-named-parameter(:foo(42)); # Output: 42
</code></pre><p>如果一个函数参数不是命名的，而是位置的，那么在用命名对调用时，就会出现编译错误。</p>
<pre><code class="language-raku" data-lang="raku">sub sub-without-named-parameter($foo) { # &lt;- 没有冒号
  say $foo;
}

sub-without-named-parameter(:foo(42)); # Unexpected named argument 'foo' passed
</code></pre><p>如果你在调用这样的函数时用括号包围一个参数，整个参数对将被传递到位置参数。</p>
<pre><code class="language-raku" data-lang="raku">sub sub-without-named-parameter($foo) {
  say $foo;
}

sub-without-named-parameter((:foo(42))); # Output: foo =&gt; 42
</code></pre><p>在 Raku 中，你可以写一个函数来捕获所有传递给它的参数并分析它们。这是在单个参数 - 捕获前用竖线完成的。</p>
<pre><code class="language-raku" data-lang="raku">sub sub-with-capture(|foo) { # &lt;- 参数捕获
  say foo;
}

sub-with-capture(:foo(42));     # Output: \(:foo(42))
sub-with-capture(42);           # Output: \(42)
sub-with-capture(:foo(3 Z- 2)); # Output: \(:foo((1,).Seq))
sub-with-capture(:foo(3 R- 2)); # Output: \(-1)
</code></pre><p>倒数第二行使用了 Z 元操作符 - zip 操作符。它将左右两部分作为一个列表，按顺序每次从它们中抽取一个元素，并进行操作，从而形成一个序列。</p>
<p>在最后一行，只用了我们需要的 R 元操作符。在这种情况下，它不是一个对，而是一个常量，它被传递到函数中。我们可以假设这是元运算符工作方式的一些特殊性，但用 Z 的例子表明并非如此。其实这是一个 bug - 当一个对被传递到一个使用 R 元运算符的函数中时，它的值会被转换。</p>
<h2 id="我们需要一个新的测试">我们需要一个新的测试</h2>
<p>为了确保未来的变化能够修复错误的行为，我们需要写一个新的测试。在测试文件中不难找到 R 元操作符的测试（<a href="https://github.com/Raku/roast/blob/fea1d16d993eb851d2935155e0b0d074fa3593bf/S03-metaops/reverse.t">S03-metops/reverse.t</a>）。下面我将补充以下测试。</p>
<pre><code class="language-raku" data-lang="raku"># https://github.com/rakudo/rakudo/issues/1632
{
  sub subroutine($expected, |actual) {
    is actual.gist, $expected, &quot;Сolonpair exists&quot;
  }

  subroutine('\(:foo(-1))', :foo(3 R- 2));
}
</code></pre><p>该测试有一个功能，有两个参数 - 正常和捕获。在函数体中，第一个参数和传递的 Capture 的字符串表示进行比较。你可以使用 <code>make</code> 对新构建的编译器进行单独测试。</p>
<pre><code>&gt; make t/spec/S03-metaops/reverse.t
[...]
ok 69 - [R~]=
not ok 70 - Colonpair exists
# Failed test 'Colonpair exists'
# at t/spec/S03-metaops/reverse.t line 191
# expected: '\(:foo(-1))'
#      got: '\(-1)'
# You planned 69 tests, but ran 70
# You failed 1 test of 70
</code></pre><p>你可以看到，测试失败了（如预期）。还有一个单独的说明，系统预计69次测试，但收到70次。这是基于 TAP 的测试系统的特点 - 必须在文件的顶部修正传递给 <code>plan</code> 函数的数字。现在测试崩溃了，但编号没有受到影响。你可以开始修复它。</p>
<h2 id="凝视法">凝视法</h2>
<p>一开始我很相信任务上的标签 - 如果是解析的话，一定是源码解析阶段的某个地方出现了问题。目前我的认识如下：</p>
<ol>
<li>基础解析器代码在文件 <code>rakudo/src/Perl6/Grammar.nqp</code> 中。</li>
<li>这个解析器是从 <code>nqp/src/HLL/Grammar.nqp</code> 文件中的基础解析器继承的。</li>
<li>元操作符的解析和工作方式都差不多，你可以通过仔细观察来发现不同之处。</li>
</ol>
<p>我在基础解析器代码中找到了对元操作符的引用。</p>
<pre><code class="language-raku" data-lang="raku">token infix_prefix_meta_operator:sym&lt;R&gt; {
  &lt;sym&gt; &lt;infixish('R')&gt; {}
  &lt;.can_meta($&lt;infixish&gt;, &quot;reverse the args of&quot;)&gt;
  &lt;O=.revO($&lt;infixish&gt;)&gt;
}

token infix_prefix_meta_operator:sym&lt;Z&gt; {
  &lt;sym&gt; &lt;infixish('Z')&gt; {}
  &lt;.can_meta($&lt;infixish&gt;, &quot;zip with&quot;)&gt;
  &lt;O(|%list_infix)&gt;
}
</code></pre><p>这需要对 Raku grammar 有一定的了解。据我所知，原来这两个元运算符在解析上并没有根本的区别。一段时间后，在解析器的源代码中挖得够多了，我开始怀疑解析工作是否正确。认为代码 <code>my $r = :foo(3 R- 2); say $r; # Output: foo =&gt; -1</code> 正确工作的建议 - 问题恰恰发生在调用函数时。显然，我白白相信了任务栏上的标签。</p>
<h2 id="编译器将帮助我们">编译器将帮助我们</h2>
<p>颇为迟钝的我想起了我从一开始就应该做的事情。Rakudo 编译器有 <code>--target</code> 调试开关。它取编译器阶段的名称，你想将其结果输出到控制台并退出。我想看看 <code>--target=parse</code>（因为我只知道这一个）。</p>
<p>我从 <code>~/dev-rakudo/rakudo</code> 文件夹中使用 <code>rakumo-m</code>，这样我就不必等待通过 <code>make install</code> 命令将所需文件复制到 <code>~/dev-rakudo-install</code>。简单的脚本可以这样运行。更复杂的脚本必须在 <code>make install</code> 之后从 <code>-install</code> 中运行。</p>
<pre><code>&gt; cat ~/test.raku
sub s(|c) { say c }
s(:foo(3 R- 2));
s(:foo(3 Z- 2));

&gt; ./rakudo-m --target=parse ~/test.raku
[...]
- args: (:foo(3 R- 2))
  - semiarglist: :foo(3 R- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 R- 2)
        - colonpair: :foo(3 R- 2)
          - identifier: foo
          - coloncircumfix: (3 R- 2)
            - circumfix: (3 R- 2)
              - semilist: 3 R- 2
                - statement: 1 matches
                  - EXPR: R- 2
[...]
- args: (:foo(3 Z- 2))
  - semiarglist: :foo(3 Z- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 Z- 2)
        - colonpair: :foo(3 Z- 2)
          - identifier: foo
          - coloncircumfix: (3 Z- 2)
            - circumfix: (3 Z- 2)
              - semilist: 3 Z- 2
                - statement: 1 matches
                  - EXPR: Z- 2
[...]
</code></pre><p>结论：R 和 Z 的解析是一样的。</p>
<h2 id="这不是解析">这不是解析</h2>
<p>所有被解析的东西都会被传递给所谓的 Action，把字词变成一棵语法树。在我们的例子中，Actions 位于文件 <code>rakudo/src/Perl6/Actions.nqp</code> 和 <code>nqp/src/HLL/Actions.nqp</code> 中。这里就比较容易搞清楚了，毕竟是代码，是 grammar。</p>
<p>我在主 Actions 中找到了以下代码。</p>
<pre><code>[...]
elsif $&lt;infix_prefix_meta_operator&gt; {
[...]
  if    $metasym eq 'R' { $helper := '&amp;METAOP_REVERSE'; $t := nqp::flip($t) if $t; }
  elsif $metasym eq 'X' { $helper := '&amp;METAOP_CROSS'; $t := nqp::uc($t); }
  elsif $metasym eq 'Z' { $helper := '&amp;METAOP_ZIP'; $t := nqp::uc($t); }
  
  my $metapast := QAST::Op.new( :op&lt;call&gt;, :name($helper), WANTED($basepast,'infixish') );
  $metapast.push(QAST::Var.new(:name(baseop_reduce($base&lt;OPER&gt;&lt;O&gt;.made)), :scope&lt;lexical&gt;))
    if $metasym eq 'X' || $metasym eq 'Z';
[...]
</code></pre><p>它说，如果在代码中解析了元操作符 <code>R</code>、<code>Z</code> 或 <code>X</code>，就应该在语法树中添加一些 <code>METAOP_</code> 函数调用。在 <code>Z</code> 和 <code>X</code> 的情况下，它会多一个参数，即某种还原函数。所有这些功能都可以在 <code>rakudo/src/core.c/metaops.pm6</code> 中找到。</p>
<pre><code class="language-raku" data-lang="raku">sub METAOP_REVERSE(\op) is implementation-detail {
  -&gt; |args { op.(|args.reverse) }
}

sub METAOP_ZIP(\op, &amp;reduce) is implementation-detail {
 nqp::if(op.prec('thunky').starts-with('.'),
  -&gt; +lol {
    my $arity = lol.elems;
    [...]
  },
  -&gt; +lol {
    Seq.new(Rakudo::Iterator.ZipIterablesOp(lol,op))
  }
  )
}
</code></pre><p>给你：</p>
<ol>
<li><code>\op</code> 是由我们的元操作符，即-，在前面的操作。</li>
<li>Trait <code>implementation-detail</code> 只是表明这不是公共代码，是编译器实现的一部分。</li>
<li>由于-操作没有笨重的特性，所以 <code>&amp;reduce</code> 函数不会参与计算，<code>Z</code> 的结果是 <code>Seq.new(...)</code>。</li>
<li><code>R</code> 的结果是一个操作调用 - 参数顺序相反。</li>
</ol>
<p>这时我想起还有一个 - 目标，即星。它将显示行动的结果。</p>
<pre><code>&gt; ./rakudo-m --target=ast ~/test.raku
[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-
    - QAST::Op(call &amp;METAOP_REVERSE) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;7&gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(:named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;8&gt; :before_promotion&lt;?&gt; Z-
    - QAST::Op(call &amp;METAOP_ZIP) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
      - QAST::Var(lexical &amp;METAOP_REDUCE_LEFT)
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
</code></pre><p>一如所料。除了调用不同的 <code>METAOP_</code> 函数外，所有的东西几乎都是一样的。从它们的代码中我们可以知道，原则上这些函数的不同之处在于返回值的类型 - 分别是 <code>Int</code> 和 <code>Seq</code>。众所周知，Raku 对不同类型的对象的上下文相当敏感&hellip;&hellip;我想，它关注的可能是返回值。我试着用下面的方式修改代码。</p>
<pre><code class="language-raku" data-lang="raku">sub METAOP_REVERSE(\op) is implementation-detail {
  -&gt; |args { Seq.new(op.(|args.reverse)) }
}
</code></pre><p>编译、运行。</p>
<pre><code>&gt; make
[...]
Stage start      :   0.000
Stage parse      :  61.026
Stage syntaxcheck:   0.000
Stage ast        :   0.000
Stage optimize   :   7.076
Stage mast       :  14.120
Stage mbc        :   3.941
[...]
&gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
</code></pre><p>一切都没有改变。所以，不是返回值&hellip;&hellip;想了想，不知道为什么结果又是 <code>-1</code> 而不是 <code>(-1,).Seq</code>。而且，从代码来看，<code>Seq</code> 根本就没有一个合适的构造函数。下一次，作为一些疯狂的事情，我尝试调用 <code>METAOP_REVERSE</code> 结果只是为了崩溃。</p>
<pre><code class="language-raku" data-lang="raku">sub METAOP_REVERSE(\op) is implementation-detail {
  -&gt; |args { die }
}
</code></pre><p>编译、运行。</p>
<pre><code>&gt; make
[...]
&gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
</code></pre><p>怎么会呢？语法树中包含了对 <code>METAOP_REVERSE</code> 的调用，它的代码应该是折叠的，但计算仍然进行，我们得到 <code>-1</code>。</p>
<p>这些都不是《行动》。</p>
<p>这里我的目光落在编译器的构建日志上。它是一些阶段被列在那里。我随机试了 <code>--target=mast</code>。</p>
<pre><code>&gt; ./rakudo-m --target=mast ~/test.raku
[...]
MAST::Frame name&lt;s&gt;, cuuid&lt;1&gt;
  Local types: 0&lt;obj&gt;, 1&lt;obj&gt;, 2&lt;obj&gt;, 3&lt;obj&gt;, 4&lt;int&gt;, 5&lt;str&gt;, 6&lt;obj&gt;, 7&lt;obj&gt;, 8&lt;obj&gt;,
  Lexical types: 0&lt;obj&gt;, 1&lt;obj&gt;, 2&lt;obj&gt;, 3&lt;obj&gt;, 4&lt;obj&gt;,
  Lexical names: 0&lt;c&gt;, 1&lt;$¢&gt;, 2&lt;$!&gt;, 3&lt;$/&gt;, 4&lt;$*DISPATCHER&gt;,
  Lexical map: $!&lt;2&gt;, c&lt;0&gt;, $*DISPATCHER&lt;4&gt;, $¢&lt;1&gt;, $/&lt;3&gt;,
  Outer: name&lt;&lt;unit&gt;&gt;, cuuid&lt;2&gt;
[...]
</code></pre><p>某种不可读的矩阵。星号和桅杆之间有一个阶段性的优化。</p>
<pre><code>&gt; ./rakudo-m --target=optimize ~/test.raku
[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;infix:&lt;-&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;7&gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;8&gt; :before_promotion&lt;?&gt; Z-
    - QAST::Op(callstatic &amp;METAOP_ZIP) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
      - QAST::Var(lexical &amp;METAOP_REDUCE_LEFT)
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
</code></pre><p>哈，就是这样。在优化阶段后，行将失踪。</p>
<ul>
<li><code>QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-.</code>
并将整个 <code>METAOP_REVERSE</code> 调用替换为通常的操作 <code>(&amp;infix:&lt;-&gt;)</code>。所以问题一定在优化器的某个地方。</li>
</ul>
<p>只有在 <code>optim_nameless_call</code> 方法中才会提到 <code>&amp;METAOP_ASSIGN</code>，其中 <code>QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;)</code>。显然，这个操作负责生成一个命名对 - 它已经有了一个名字（命名参数），它需要计算值。从优化 <code>_</code> 无名方法的执行路径来看，我们可以得出结论，我们对最后一个块感兴趣。</p>
<pre><code>[...]
  elsif self.op_eq_core($metaop, '&amp;METAOP_REVERSE') {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;&amp; nqp::elems($op) == 3;
    return QAST::Op.new(:op&lt;call&gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;
  }
[...]
</code></pre><p>让我提醒你，优化前的树是这样的。</p>
<pre><code>[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-
    - QAST::Op(call &amp;METAOP_REVERSE) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
    - QAST::Want &lt;wanted&gt; 3
    - QAST::Want &lt;wanted&gt; 2
[...]
</code></pre><p>而精简之后，是这样的。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;infix:&lt;-&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
    - QAST::Want &lt;wanted&gt; 3
[...]
</code></pre><p>也就是说，优化 <code>_nameless_call</code> 做了以下工作。</p>
<p>如果我们的 <code>QAST::Op+{QAST::SpecialArg}</code> 操作没有三个参数，如果 <code>METAOP_REVERSE</code> 调用没有一个正确的类型，我们就返回空。这不是我们的情况。
否则，我们将返回一个新的操作，代替我们的 <code>QAST::Op+{QAST::SpecialArg}</code> 操作，以相反的顺序调用 <code>&amp;infix:&lt;-&gt;</code> 参数。就是说，把结果打包成一对就没了。</p>
<p>在摸索了一下如何解决这个问题，并阅读了 <code>QAST::SpecialArg</code> 和 <code>QAST::Node</code> 的实现后，我想到了下面的代码。</p>
<pre><code>[...]
  elsif self.op_eq_core($metaop, '&amp;METAOP_REVERSE') {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;&amp; nqp::elems($op) == 3;
    my $opt_result := QAST::Op.new(:op&lt;call&gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;
    if $op.named { $opt_result.named($op.named) } # 添加选项 named 
    if $op.flat { $opt_result.flat($op.flat) }    # 添加选项 flat
    return $opt_result;
  }
[...]
</code></pre><p>还有木头。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call &amp;infix:&lt;-&gt; :named&lt;foo&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
    - QAST::Want &lt;wanted&gt; 3
[...]
</code></pre><p>命名的参数返回到它的位置。测试也开始通过。</p>
<pre><code>&gt; make t/spec/S03-metaops/reverse.t
[...]
All tests successful.
Files=1, Tests=70,  3 wallclock secs ( 0.03 usr  0.01 sys +  3.61 cusr  0.17 csys =  3.82 CPU)
Result: PASS
</code></pre><p>我们本可以就此打住，但这是编译器优化器的代码，它的结果是一个有两个整数参数的方法调用。我认为这在某种程度上是次优的。如果我们将返回表达式改为返回 <code>self.visit_op: $opt_result;</code>，对产生的非优化操作调用优化器，那么产生的树就会像这样。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Want+{QAST::SpecialArg}(:named&lt;foo&gt;)
    - QAST::WVal+{QAST::SpecialArg}(Int :named&lt;foo&gt;)
    - QAST::IVal(-1)
[...]
</code></pre><p>现在一切都很理想。</p>
<h2 id="分享成果">分享成果</h2>
<p>我们已经到了终点线。现在我们只需要分享我们的经验。</p>
<ol>
<li>重要的是：运行所有的 <code>make spectest</code> 测试，确保没有新的东西被破坏。</li>
<li>在 GitHub 上使用 Rakudo 编译器和测试制作 fork 仓库。</li>
<li>将 fork 仓库添加为新的 git 远程仓库。</li>
<li>cd ~/dev-rakudo/rakudo &amp;&amp; git remote add fork <!-- raw HTML omitted -->。</li>
<li>cd ~/dev-rakudo/t/spec &amp;&amp; git remote add fork <!-- raw HTML omitted -->。</li>
</ol>
<p>重要：确保两个仓库在 git 中都有正确的用户名和用户邮箱。</p>
<p>提交到两个版本库，详细说明你为什么做了哪些改动，并添加对原始问题跟踪器的引用。</p>
<p>运行提交。</p>
<pre><code>cd ~/dev-rakudo/rakudo &amp;&amp; git push fork
cd ~/dev-rakudo/t/spec &amp;&amp; git push fork
</code></pre><p>向两个仓库提出拉取请求。在他们的描述中，最好是相互参照和原任务。</p>
<h2 id="结论">结论</h2>
<p>对开源软件的贡献是：</p>
<ol>
<li>趣味性和趣味性。</li>
<li>给你的感觉是，你正在做一些有用的事情，你真的是。</li>
<li>让你认识新的有趣和专业的人（任何关于 Raku 的问题都会在 <code>#raku IRC</code> 频道中得到回答）。</li>
<li>解决非标准任务，没有截止日期的压力，是一种很好的体验。</li>
</ol>
<p>选择你觉得最舒服的角色等级，去做新的任务吧!</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Caesarean Substrings With Raku and Perl]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="related" type="text/html" title="如果集合如我所想" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-07T00:00:00+08:00</published>
            <updated>2021-02-07T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Caesarean Substrings With Raku and Perl</blockquote><p>[113] 发表于2021年1月30日。
这是我对 <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-097/">Perl 每周挑战#097</a> 的回应。</p>
<h2 id="挑战-0971-凯撒密码">挑战 #097.1: 凯撒密码</h2>
<p>给你一个只包含字母 <code>A..Z</code> 的字符串 <code>$S</code> 和一个数字 <code>$N</code>。
写一个脚本，用<a href="https://en.wikipedia.org/wiki/Caesar_cipher">凯撒密码</a>对给定的字符串 <code>$S</code> 进行加密，左移大小为 <code>$N</code>。</p>
<p>例子:
输入: $S = &ldquo;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&rdquo;, $N = 3
输出: &ldquo;QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD&rdquo;</p>
<p>Plain:    ABCDEFGHIJKLMNOPQRSTUVWXYZ
Cipher:   XYZABCDEFGHIJKLMNOPQRSTUVW</p>
<p>Plaintext:  THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG
Ciphertext: QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD</p>
<p>&ldquo;只用字母 <code>A...Z</code>&rdquo; 的表述是错误的，因为例子中也有几个空格。因此，应该允许这些空格。</p>
<p>文件: caesar-cipher</p>
<pre><code class="language-raku" data-lang="raku">#! /usr/bin/env raku

subset AZ-space of Str where /^ &lt;[ A .. Z \s ]&gt;+ $/;   # [1]
subset PosInt of Int where -25 &lt;= $_ &lt;= 25;            # [2]

unit sub MAIN (AZ-space $S = 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG',
               PosInt $N = 3);                         # [3]

say $S.comb.map({ caesar($_, $N) }).join;              # [4]

sub caesar ($char, $shift)
{
  return $char if $char eq &quot; &quot;;                        # [5]

  my $code = $char.ord;                                # [6]

  $code -= $shift;                                     # [7]

  $code += 26 if $code &lt; 65;  # 'A'                    # [8]
  $code -= 26 if $code &gt; 90;  # 'Z'                    # [8a]

  return $code.chr;                                    # [9]
}
</code></pre><p>[1] 所允许的字符 (或 «特定领域字母»).</p>
<p>[2] 挑战说左移值是一个数字。允许除整数以外的任何东西是没有意义的，所以我把值限制在这个类型。负值应该是可以的，它们意味着右移值（而不是左移）。</p>
<p>[3] 参数，默认值为挑战中给出的值。</p>
<p>[4] 将字符串分割成单个字符（用梳子(comb)，在每个字符上应用 &ldquo;caesar&rdquo; 函数（用map），再次将字符连接成一个字符串（用join），然后打印出来。</p>
<p>[5] 不移动空格。</p>
<p>[6] 获取字符的代码点。</p>
<p>[7] 减去移位值（当我们向左移位时，或在字母表中降低移位值）。</p>
<p>[8] 绕回, 如果我们移出A-Z范围，这里为更低 - 或更高的 [8b]。</p>
<p>[9] 获取指定代码点的字符。</p>
<p>查看 docs.raku.org/routine/ord 获取更多关于 ord 的信息。</p>
<p>查看 docs.raku.org/routine/chr 获取更多关于 chr 的信息。</p>
<p>运行它:</p>
<pre><code>$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
</code></pre><p>Raku 有一个 ords 变体，它接收一整个字符串，而不是一个字符作为 ord。还有 chrs，它接收一个代码点数组，并将它们变成一个字符串，而不是像 chr 那样接收一个字符的代码点。让我们用它们来写一个更短的程序。</p>
<p>文件: caesar-cipher-map</p>
<pre><code class="language-raku" data-lang="raku">#! /usr/bin/env raku

subset AZ-space of Str where /^ &lt;[ A .. Z \s ]&gt;+ $/;
subset PosInt of Int where -25 &lt;= $_ &lt;= 25;

unit sub MAIN (AZ-space $S = 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG',
               PosInt $N = 3);

say caesar($S, $N);

sub caesar ($string, $shift)
{
  return $string.ords.map({$_ == 32 ?? 32 !! (($_ - $shift - 65) % 26 ) + 65}).chrs;
    # #################### # 1a ############# ############ # 1b  # 1c ## 1d
}
</code></pre><p>[1] 我们使用map来改变各个代码点。我们让代码点为32的空间单独存在[1a]。每一个其他的值我们都还原成0到25之间的数字（通过减去第一个字母的代码点（A：65）和移位值[1b]）。模数运算符 (%) 为我们处理负值，做正确的事情。例如：-2 % 26 -&gt; 24 [1c]。然后我们添加调整值到它们应该在的位置(从A到Z)[1d]，然后我们将整个数组的代码点变成一个字符串。</p>
<p>查看 docs.raku.org/routine/ords 获取更多关于 ords 的信息。</p>
<p>查看 docs.raku.org/routine/chrs 获取更多关于 chrs 的信息。</p>
<p>运行它的结果和之前一样。</p>
<pre><code>$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
</code></pre><h2 id="perl-版本">Perl 版本</h2>
<p>这是对第一个 Raku 版的直接翻译。</p>
<p>File: caesar-cipher-perl</p>
<div class="highlight"><pre class="chroma"><code class="language-perl" data-lang="perl"><span class="ch">#! /usr/bin/env perl</span>

<span class="k">use</span> <span class="nn">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">feature</span> <span class="s">&#39;say&#39;</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">feature</span> <span class="s">&#39;signatures&#39;</span><span class="p">;</span>

<span class="k">no</span> <span class="nn">warnings</span> <span class="s">&#34;experimental::signatures&#34;</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$S</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="sr">//</span> <span class="s">&#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39;</span><span class="p">;</span>

<span class="nb">die</span> <span class="s">&#34;Illegal characters&#34;</span> <span class="k">unless</span> <span class="nv">$S</span> <span class="o">=~</span><span class="sr"> /^[A-Z\s]+$/</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$N</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">)</span> <span class="sr">//</span> <span class="mi">3</span><span class="p">;</span>

<span class="nb">die</span> <span class="s">&#34;Illegal shift $N&#34;</span> <span class="k">if</span> <span class="nv">$N</span> <span class="o">!~</span> <span class="sr">/^\-?\d+$/</span> <span class="o">||</span> <span class="nv">$N</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">25</span> <span class="o">||</span> <span class="nv">$N</span> <span class="o">&gt;</span> <span class="mi">25</span><span class="p">;</span>

<span class="n">say</span> <span class="nb">join</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nb">map</span> <span class="p">{</span> <span class="n">caesar</span><span class="p">(</span><span class="nv">$_</span><span class="p">,</span> <span class="nv">$N</span><span class="p">)</span> <span class="p">}</span> <span class="nb">split</span><span class="p">(</span><span class="sr">//</span><span class="p">,</span> <span class="nv">$S</span><span class="p">));</span>

<span class="k">sub</span> <span class="nf">caesar</span> <span class="p">($char, $shift)
</span><span class="p">{</span>
  <span class="k">return</span> <span class="nv">$char</span> <span class="k">if</span> <span class="nv">$char</span> <span class="ow">eq</span> <span class="s">&#34; &#34;</span><span class="p">;</span>

  <span class="k">my</span> <span class="nv">$code</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="nv">$char</span><span class="p">);</span>

  <span class="nv">$code</span> <span class="o">-=</span> <span class="nv">$shift</span><span class="p">;</span>

  <span class="nv">$code</span> <span class="o">+=</span> <span class="mi">26</span> <span class="k">if</span> <span class="nv">$code</span> <span class="o">&lt;</span> <span class="mi">65</span><span class="p">;</span>  <span class="c1"># &#39;A&#39;</span>
  <span class="nv">$code</span> <span class="o">-=</span> <span class="mi">26</span> <span class="k">if</span> <span class="nv">$code</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">;</span>  <span class="c1"># &#39;Z&#39;</span>

  <span class="k">return</span> <span class="nb">chr</span><span class="p">(</span><span class="nv">$code</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>运行它的结果和 Raku 版一样。</p>
<pre><code>$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD

$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3
WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ

$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT

$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13
GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT
</code></pre><h2 id="挑战-0972二进制子字符串binary-substrings">挑战 #097.2：二进制子字符串(Binary Substrings)</h2>
<p>给你一个二进制字符串 <code>$B</code> 和一个整数 <code>$S</code>。</p>
<p>写一个脚本来拆分大小为 <code>$S</code> 的二进制字符串 <code>$B</code>，然后找出使其相同的最小翻转次数。</p>
<p>例 1:
输入: $B = “101100101”, $S = 3
输出: 1</p>
<p>二进制子字符串:
&ldquo;101&rdquo;: 0 flip
&ldquo;100&rdquo;: 1 flip to make it &ldquo;101&rdquo;
&ldquo;101&rdquo;: 0 flip</p>
<p>例 2:
输入 $B = “10110111”, $S = 4
输出: 2</p>
<p>二进制子字符串:
&ldquo;1011&rdquo;: 0 flip
&ldquo;0111&rdquo;: 2 flips to make it &ldquo;1011&rdquo;</p>
<p>我们先从第一个例子中的二进制子字符串中砍掉3个字符块。</p>
<pre><code>&gt; say &quot;101100101&quot;.comb(3);   # -&gt; (101 100 101)
&gt; say &quot;1011001010&quot;.comb(3);  # -&gt; (101 100 101 0)
</code></pre><p>第二行显示了如果长度不匹配会发生什么。这就给了我们一个非法的值，因为我们不能将一位数翻转为三位数的值。所以我们必须添加一个检查。</p>
<p>然后我们将第一个子串与其余的子串进行比较，一次一个。在这里使用bitwise XOR（Exclusive OR）运算符是一个合理的选择。这给了我们一个二进制值，其中1的数量就是该子串的翻转次数。Raku确实有一个XOR运算符。+^. 但是它 &ldquo;将两个参数都强制为Int，并进行位智XOR操作&rdquo;(根据文档&quot;；参见docs.raku.org/language/operators#infix_+^)。</p>
<p>我们可以在进行XOR操作之前，将二进制值转换为十进制值。让我们试试。</p>
<p>获取翻转的次数。</p>
<pre><code>&gt; say (&quot;10101&quot;.parse-base(2) +^ &quot;10111&quot;.parse-base(2)).base(2).comb.sum;  # -&gt; 1
&gt; say (&quot;11101&quot;.parse-base(2) +^ &quot;10111&quot;.parse-base(2)).base(2).comb.sum;  # -&gt; 2
</code></pre><p>这当然可行，但需要大量的代码。所以我将使用一个更简单的方法 - 逐个比较每个数字。</p>
<p>File: binary-substring</p>
<pre><code class="language-raku" data-lang="raku">#! /usr/bin/env raku

subset BinaryString where /^ &lt;[01]&gt;+ $/;                    # [1]
subset PosInt of Int where * &gt; 0;                           # [2]

unit sub MAIN (BinaryString $B = '101100101',               # [1]
               PosInt $S where $B.chars %% $S = 3,          # [2]
	       :v(:$verbose));

my @B     = $B.comb($S.Int);                                # [3]
my $first = @B.shift;                                       # [4]
my $total = 0;                                              # [5]

for @B -&gt; $current                                          # [6]
{
  my $flip = bit-diff($first, $current);                    # [7]
  $total += $flip;                                          # [8]
  say &quot;: $first -&gt; $current -&gt; Flip: $flip&quot; if $verbose;
}

say $total;                                                 # [9]

sub bit-diff ($a, $b)                                       # [7]
{
  my $flip = 0;                                             # [10]

  for ^$a.chars -&gt; $index                                   # [11]
  {
    $flip++ if $a.substr($index,1) ne $b.substr($index,1);  # [12]
  }

  return $flip;
}
</code></pre><p>[1] 确保二进制字符串是合法的（只包含 &ldquo;0 &ldquo;和 &ldquo;1&rdquo;）。</p>
<p>[2] 确保是一个正整数，同时确保字符串是被它偶数分割的。(例如，&ldquo;4 &ldquo;给我们提供了长度为4的子串，如果最后一个较短，程序将中止。)</p>
<p>[3] 梳子通常用于将一个字符串分割成单个字符，但我们可以通过指定长度来获得每个子字符串中的多个字符，比如这样。</p>
<p>[4] 例子首先将第一个子串与自己进行比较，给出零翻转。这是愚蠢的(ish)，所以我跳过这一点，把第一个子串移出。</p>
<p>[5] 结果会到这里。</p>
<p>[6] 对于每一个子串（除了第一个，见[4]）。</p>
<p>[7] 获取每个子串的翻转次数。</p>
<p>[8] 并将其添加到总数中。</p>
<p>[9] 打印它。</p>
<p>[10] 翻转的数量会在这里。</p>
<p>[11] 对于两个子串中的每个索引（具有相同的长度）。</p>
<p>[12] - 如果给定位置上的字符不同，则在总数的基础上加1，意味着移动。</p>
<p>See docs.raku.org/routine/comb for more information about comb.</p>
<p>运行它。</p>
<pre><code>$ ./binary-substring &quot;101100101&quot; 3
 1

$ ./binary-substring -v &quot;101100101&quot; 3
: 101 -&gt; 100 -&gt; Flip: 1
: 101 -&gt; 101 -&gt; Flip: 0
1

$ ./binary-substring &quot;10110111&quot; 4
2

$ ./binary-substring -v &quot;10110111&quot; 4
: 1011 -&gt; 0111 -&gt; Flip: 2
2
</code></pre><p>看起来不错。</p>
<h2 id="perl">Perl</h2>
<p>这是对 Raku 版本的直接翻译，只是我必须实现 &ldquo;comb&rdquo;。</p>
<p>文件： binary-substring-perl</p>
<pre><code class="language-raku" data-lang="raku">#! /usr/bin/env perl

use strict;
use warnings;
use feature 'say';
use feature 'signatures';
use Getopt::Long;

no warnings &quot;experimental::signatures&quot;;

my $verbose = 0;

GetOptions(&quot;verbose&quot;  =&gt; \$verbose);

my $B = shift(@ARGV) // '101100101';

die &quot;Not a binary number&quot; unless $B =~ /^[01]+$/;

my $S = shift(@ARGV) // 3;

die &quot;Not an integer&quot; unless $S =~ /^[1-9][0-9]*$/;
die &quot;Not a legal length&quot; if length($B) % $S;

my @B     =  comb($B, $S);
my $first = shift(@B);
my $total = 0;

for my $current (@B)
{
  my $flip = bit_diff($first, $current);
  $total += $flip;
  say &quot;: $first -&gt; $current -&gt; Flip: $flip&quot; if $verbose;
}

say $total;

sub bit_diff ($a, $b)
{
  my $flip = 0;

  for my $index (0 .. length($a))
  {
    $flip++ if substr($a, $index,1) ne substr($b, $index,1);
  }

  return $flip;
}

sub comb ($string, $length = 1)  # [1]
{
  my @result;

  while ($string)
  {
    push(@result, substr($string, 0, $length));
    $string = substr($string, $length);
  }
  return @result;
}
</code></pre><p>[1] 缺失的 Raku 例程 &ldquo;comb&rdquo;。可选的第二个参数指定了它所返回的每个子串中所包含的（第一个参数的）子串长度。</p>
<p>运行它的结果与 Raku 版本相同。</p>
<pre><code>$ ./binary-substring-perl &quot;101100101&quot; 3
1

$ ./binary-substring-perl -v &quot;101100101&quot; 3
: 101 -&gt; 100 -&gt; Flip: 1
: 101 -&gt; 101 -&gt; Flip: 0
1

$ ./binary-substring-perl &quot;101100111&quot; 3
2

$ ./binary-substring-perl -v &quot;101100111&quot; 3
: 101 -&gt; 100 -&gt; Flip: 1
: 101 -&gt; 111 -&gt; Flip: 1
2
</code></pre><p>就是这样。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/raku" term="raku" label="Raku" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[如果集合如我所想]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-07T00:00:00+08:00</published>
            <updated>2021-02-07T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>If Sets Would DWIM</blockquote><h1 id="if-sets-would-dwimhttpsdonaldhwtf202101if-sets-would-dwim"><a href="https://donaldh.wtf/2021/01/if-sets-would-dwim/">If Sets Would DWIM</a></h1>
<p>每当我在 Raku 中使用集合的时候，它们经常无法 <a href="https://docs.raku.org/language/glossary#DWIM">DWIM</a>。这是一个简短的探索，看看是否可以改进 DWIMminess。</p>
<p>我最近重新审视了我前段时间写的一个利用 <code>(-)</code> 集差运算符的脚本。这段代码有一个 bug 潜伏在那里，显而易见，因为下面的代码并没有按照我的直觉去做。</p>
<pre><code class="language-raku" data-lang="raku">  my @allowed = &lt;m c i p l o t&gt;;
  my @chars = 'impolitic'.comb;

  my @remainder = @allowed (-) @chars;

  if +@remainder == 0 {
     say 'pangram';
  } else {
     say &quot;unused: [{@remainder.join(' ')}]&quot;;
  }
unused: []
</code></pre><p>错误的原因是 <code>(-)</code> 产生了一个 Set，而赋值给 <code>@remainder</code> 会产生1项的 Array。总是这样。但不方便的是，当它是一个空集合时，它就会字符串化为一个空字符串，这只是帮助掩盖了这个潜伏的错误。</p>
<pre><code class="language-raku" data-lang="raku">my @items = &lt;a b c d e&gt; (-) &lt;a b c d e&gt;;
say @items.raku;
say +@items;
</code></pre><pre><code>[Set.new()]
1
</code></pre><p>解决方法比较简单。只要不赋值给数组就可以了。使用一个标量容器来代替。</p>
<pre><code class="language-raku" data-lang="raku">my $items = &lt;a b c d e&gt; (-) &lt;a b d&gt;;
say $items.raku;
say +$items;
</code></pre><pre><code>Set.new(&quot;e&quot;,&quot;c&quot;)
2
</code></pre><p>甚至是关联容器也可以。</p>
<pre><code class="language-raku" data-lang="raku">my %items = &lt;a b c d e&gt; (-) &lt;a b d&gt;;
say %items.raku;
say +%items;
</code></pre><pre><code>{:c(Bool::True), :e(Bool::True)}
2
</code></pre><p>或在赋值前明确地取出键的列表。</p>
<pre><code class="language-raku" data-lang="raku">my @items = (&lt;a b c d e&gt; (-) &lt;a b d&gt;).keys;
say @items.raku;
say +@items;
</code></pre><pre><code>[&quot;e&quot;, &quot;c&quot;]
2
</code></pre><p>很好，起作用了。只是不要用数组容器来处理 <code>Setty</code> 这样的东西。只是这并不能阻止我的直觉时不时地碰上这个错误。同一类的 bug 在我的代码中出现过好几次，因为它实在是太容易犯错了。Raku 不会告诉我，我做错了什么，因为也许是故意的。但重要的是， Raku 没有设法 DWIM。</p>
<p>我可以采取的另一个方法是养成添加类型信息的习惯。这样确实可以让 Raku 在我掉进这个陷阱的时候告诉我。</p>
<pre><code class="language-raku" data-lang="raku">my Str @a = &lt;a b c d e&gt; (-) &lt;a b d&gt;;
</code></pre><pre><code>Type check failed in assignment to @a; expected Str but got Set (Set.new(&quot;e&quot;,&quot;c&quot;))
  in sub  at EVAL_0 line 3
  in block &lt;unit&gt; at EVAL_0 line 5
  in block &lt;unit&gt; at -e line 1
</code></pre><p>这是一个明显的例子，添加类型信息有助于 Raku 编译器帮助我避免引入这种 bug。</p>
<h2 id="实验---为-set-自定义数组存储">实验 - 为 Set 自定义数组存储</h2>
<p>我开始研究核心设置(core setting)，看看可以做什么。我惊喜地发现，我可以在 <code>Array.STORE</code> 的多重分派中添加我正在寻找的语义。</p>
<pre><code class="language-raku" data-lang="raku">use MONKEY;

augment class Array {
   multi method STORE(Array:D: Set \item --&gt; Array:D) {
       self.STORE(item.keys)
   }
}

my @a = &lt;a b c d e&gt; (-) &lt;a b d&gt;;
say @a.raku;
say +@a;
</code></pre><pre><code>[&quot;c&quot;, &quot;e&quot;]
2
</code></pre><p>分享这个似乎是谨慎的，看看我的小 DWIM 是否有任何我没有考虑到的问题或缺点。一个可能的缺点是，如果你需要这样做的话，你需要使用 <code>,</code> 来强制将一个集合变成一个数组。</p>
<pre><code class="language-raku" data-lang="raku">my @a = &lt;a b c d e&gt; (-) &lt;a b d&gt; , ;
say @a.raku;
</code></pre><pre><code>[Set.new(&quot;e&quot;,&quot;c&quot;)]
</code></pre><h2 id="下一步是什么">下一步是什么</h2>
<p>我希望这能引发关于这个问题以及其他我们的直觉和 Raku 的行为不太一致的情况的讨论。也许还有其他相关的语言边缘可以被磨平，以消除这种危害。</p>
<h2 id="后续">后续</h2>
<p>在 <a href="https://t.co/0QSoMxrSXf?amp=1">Reddit</a> 上有一些非常有启发性的讨论，涵盖了语言语义和各种替代方法。公平地说，我建议的方法引入了更多的不一致性，而不是价值，但讨论可能会导致一个语言一致的解决方案。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/flink" term="flink" label="Flink" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[贪婪 Junction 的奇闻异事]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-10-04T00:00:00+08:00</published>
            <updated>2020-10-04T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>The Strange Case of the Greedy Junction</blockquote><h2 id="贪婪-junction-的奇闻异事">贪婪 junction 的奇闻异事</h2>
<p>说明 Raku 的 junction 是如何贪婪的设计，以及一个建议。</p>
<p><a href="https://raku.org/">Raku</a> 有一个整洁的功能，叫做 <a href="https://docs.raku.org/type/Junction">Junction</a>。在这篇短文中，我想强调一下 junction 与函数交互的一个特殊后果：它们是贪婪的，我的意思是它们会无意中把函数的其他参数变成 junction。为了说明这种行为，我将使用一个闭包创建一个 <code>pair</code> 数据结构，它可以接受两个不同类型的值。</p>
<pre><code class="language-raku" data-lang="raku">enum RGB &lt;R G B&gt;;

# Pair Constructor: the arguments of pair() are captured
# in a closure that is returned
sub pair(\x, \y) {
    sub (&amp;p){ p(x, y) } 
}
</code></pre><p>所以 <code>pair</code> 接受两个任意类型的参数，并返回一个以函数为参数的闭包。我们将使用这个函数来访问存储在 <code>pair</code> 中的值。我将把这些访问(accessor)函数称为 <code>fst</code> 和 <code>snd</code>。</p>
<pre><code class="language-raku" data-lang="raku"># Accessors to get the values from the closure
my sub fst (&amp;p) {p( sub (\x,\y){x})}
my sub snd (&amp;p) {p( sub (\x,\y){y})}
</code></pre><p>做实际选择的函数是由 <code>fst</code> 和 <code>snd</code> 返回的匿名子程序，这纯粹是为了让我可以将它们应用于 <code>pair</code>，而不是必须将它们作为参数传递。让我们看一个例子，一个 <code>Int</code> 和一个 <code>RGB</code> 的 pair。</p>
<pre><code class="language-raku" data-lang="raku">my \p1 = pair 42, R;

if ( 42 == fst p1) {
    say snd p1;	#=&gt; says &quot;R&quot;
}
</code></pre><p>所以我们用两个值调用 <code>pair</code> 来创建一个 pair，并使用 <code>fst</code> 和 <code>snd</code> 来访问 pair 中的值。这是一个不可变的数据结构，所以不可能进行更新。</p>
<p>现在让我们使用 junction 作为其中一个参数。</p>
<pre><code class="language-raku" data-lang="raku"># Example instance with a 'one'-type junction
my Junction \p1j = pair (42^43),R;

if ( 42 == fst p1j) {
    say snd p1j; #=&gt; one(R, R)
}
</code></pre><p>这里发生的情况是，原始参数 <code>R</code> 已经不可逆转地变成了与自己的 junction，尽管我们从未明确地在 <code>R</code> 上创建过 junction，但还是发生了这种情况。这是将 junction 类型应用于函数的结果，它不是一个 bug，只是 junction 行为的一个影响。更详细的解释，请看我的文章&quot;<a href="https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e">重构 Raku 的 Junction</a>&quot;。</p>
<p><a href="https://docs.raku.org/type/Junction">Raku 关于 junction 的文档</a>中说，你不应该真正尝试从 junction 中获取值。</p>
<p>&ldquo;Junction 是用来作为布尔上下文中的匹配器，不支持 junction 的自省。如果你觉得有自省 junction 的冲动，请使用 Set 或相关类型代替。&rdquo;</p>
<p>然而，有一个 FAQ <a href="https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)">勉强地告诉你如何做</a>。FAQ 再次警告不要这样做。</p>
<p>&ldquo;如果你想从 junction 中提取值（特征态），你可能做错了什么，应该用 Set 来代替。&rdquo;</p>
<p>然而，正如我所举的例子所证明的那样，从 junction 中恢复值是有明确的用例的。当然，仅仅因为另一个值恰好是 junction，存储在 pair 中的其中一个值就变得不可访问，这不是我们的本意。</p>
<p>因此，我建议增加一个折叠(<code>collapse</code>)函数，允许将这些无意中出现的 junction 值折叠成它们的原始值。</p>
<pre><code class="language-raku" data-lang="raku">if ( 42 == fst p1j) {
    say collapse(snd p1j); #=&gt; says 'R'
}
</code></pre><p>该函数的实现取自<a href="https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)">上述常见问题</a>，并增加了一个检查，以确保 junction 上的所有值都相同。</p>
<pre><code class="language-raku" data-lang="raku">sub collapse(Junction \j) {    
    my @vvs;
    -&gt; Any \s { push @vvs, s }.(j);    
    my $v =  shift @vvs;        
    my @ts = grep {!($_ ~~ $v)}, @vvs;
    if (@ts.elems==0) {  
        $v
    } else {
        die &quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}&quot;;
    }
}
</code></pre><p>如果能把这个功能作为一个 <code>collapse</code> 方法添加到 <code>Junction</code> 类中就更好了。</p>
<p>原文链接: <a href="https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8">https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/junction" term="junction" label="Junction" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[重构 Raku 的 Junction]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
            
                <id>https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-10-04T00:00:00+08:00</published>
            <updated>2020-10-04T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Reconstructing Raku&rsquo;s Junctions</blockquote><h2 id="重构-raku-的-junction">重构 Raku 的 Junction</h2>
<p>Raku 中的 junction 很酷，但乍一看它们并没有遵循静态类型化的规则。我对它们的形式化类型语义很好奇，所以我从功能、静态类型的角度对 junction 进行了解构和重构。</p>
<h3 id="raku-中的-junction">Raku 中的 Junction</h3>
<p><a href="https://docs.raku.org/">Raku</a> 有一个整洁的功能叫做 <a href="https://docs.raku.org/type/Junction">Junction</a>。Junction 是一个无序的复合值。当使用 junction 代替值时，会对每个结点(junction)元素进行操作，结果是所有这些操作符的返回值的结点(junction)。当在布尔上下文中使用 junction 时，结点(junction)会折叠成一个值。Junction 的类型可以是 all(<code>&amp;</code>)、any(<code>|</code>)、one(<code>^</code>) 或 <code>none</code> (空结点)。</p>
<p>例如:</p>
<pre><code class="language-raku" data-lang="raku">my $j = 11|22; # short for any(11,22)
if 33 == $j + 11 {
    say 'yes';
}

say so 3 == (1..30).one;         #=&gt; True 
say so (&quot;a&quot; ^ &quot;b&quot; ^ &quot;c&quot;) eq &quot;a&quot;; #=&gt; True
</code></pre><p>函数 <code>so</code> 强制使用布尔上下文。</p>
<p>Junction 有 <code>Junction</code> 类型，我很好奇 Junction 的类型规则，因为乍一看有些奇怪。比方说我们有一个函数 <code>sq</code> 从 <code>Int</code> 到 <code>Int</code>。</p>
<pre><code class="language-raku" data-lang="raku">sub sq(Int $x --&gt; Int) { $x*$x }

my Int $res = sq(11); # OK
say $res; #=&gt; 121
</code></pre><p>现在让我们定义一个类型为任何 <code>Int</code> 值的 Junction。</p>
<pre><code class="language-raku" data-lang="raku">my Junction $j = 11 | 22; 
</code></pre><p>当我们将 <code>sq</code> 应用于 <code>$j</code> 时，我们没有得到一个类型错误，即使函数的类型是 <code>:(Int --&gt; Int)</code>，Junction 的类型是 <code>Junction</code>。相反，我们得到的是一个结果的 Junction。</p>
<pre><code class="language-raku" data-lang="raku">say sq($j); #=&gt; any(121, 484)
</code></pre><p>如果我们像之前一样将其赋值给一个类型为 <code>Int</code> 的变量，我们会得到一个类型错误。</p>
<pre><code class="language-raku" data-lang="raku">my Int $rj = sq($j); #=&gt; Type check failed in assignment to $rj; expected Int but got Junction (any(121, 484))
</code></pre><p>取而代之的是，现在返回值的类型为 <code>Junction</code>。</p>
<pre><code class="language-raku" data-lang="raku">my Junction $rj = sq(11|22); # OK
</code></pre><p>所以，Junction 类型可以代替任何其他类型，但这样一来，操作也变成了 Junction。</p>
<p>另一方面，Junction 是由其组成值隐式类型的，尽管它们看起来是不透明的 <code>Junction</code> 类型。例如，如果我们创建了一个由 <code>Str</code> 值组成的 Junction，并试图将这个 Junction 的值传递到 <code>sq</code> 中，我们会得到一个类型错误。</p>
<pre><code class="language-raku" data-lang="raku">my $sj = '11' | '22';
say $sj.WHAT; #=&gt;(Junction)

my Junction $svj = sq($sj); #=&gt; Type check failed in binding to parameter 'x'; expected Int but got Str (&quot;11&quot;)
</code></pre><h3 id="junction-不遵循静态类型规则">Junction 不遵循静态类型规则</h3>
<p>虽然这样做是有道理的(如果原始函数期望使用 <code>Int</code>，我们不希望它与 <code>Str</code> 一起工作)，但这确实违背了静态类型化的规则，即使是子类型化。如果一个参数的类型是 <code>Int</code>，那么可以使用类型图中低于它的任何类型来代替。但是 <code>Int</code> 和 <code>Junction</code> 的简化类型图如下。</p>
<pre><code>Int -&gt; Cool -&gt; Any -&gt; Mu &lt;- Junction
</code></pre>
<p>所以 Junction 永远不是 <code>Any</code> 以下任何东西的子类型。因此，将 Junction 放在类型为 <code>Any</code> 或其子类型的槽中应该是一个类型错误。</p>
<p>此外，由于 Junction 类型是不透明的（即它不是一个参数化的类型），它不应该持有任何关于 Junction 内部值的类型的信息。然而它却对这些不可见、不可访问的值进行了类型检查。</p>
<p>那么这里到底发生了什么？</p>
<h3 id="一个工作假设">一个工作假设</h3>
<p>一个工作假设是，Junction 类型并不真正取代任何其他类型：它只是一个语法糖，使它看起来如此。</p>
<h3 id="重构-junction-的第一部分类型">重构 Junction 的第一部分：类型</h3>
<p>让我们试着重建这个。我们的目的是想出一个数据类型和一些动作，以复制观察到的 Raku Junction 的行为。首先我们讨论一下类型，为了清晰起见，使用 Haskell 符号。然后我介绍 Raku 中的实现。这个实现将像 Raku 的原生 Junction 一样，但没有神奇的语法糖。通过这种方式，我证明了 Raku 的 Junction 毕竟遵循了正确的类型规则。</p>
<h4 id="junction-类型">Junction 类型</h4>
<p>Junction 是一个由 Junction 类型 <code>JType</code> 和一组值组成的数据结构。为了方便起见，我将这个值集限制为单一类型，同时也是因为混合类型的 Junction 其实没有什么意义。我使用一个列表来模拟这个集合，同样是为了方便。因为 Junction 可以包含任何类型的值，所以它是一个多态的代数数据类型。</p>
<pre><code class="language-raku" data-lang="raku">data JType = JAny | JAll | JOne | JNone

data Junction a = Junction JType [a]
</code></pre><h4 id="应用结点">应用结点</h4>
<p>对一个 Junction 做任何事情都意味着对它应用一个函数。我们可以考虑三种情况，我为每一种情况介绍一个特别定制的操作符。</p>
<ul>
<li>将非 Junction 函数应用于 Junction 表达式</li>
</ul>
<pre><code class="language-raku" data-lang="raku">(•￮) :: (a -&gt; b) -&gt; Junction a -&gt;  Junction b
</code></pre><ul>
<li>将 Junction 函数应用于非 Junction 表达式。</li>
</ul>
<pre><code class="language-raku" data-lang="raku">(￮•) ::  Junction (b -&gt; c) -&gt; b -&gt; Junction c
</code></pre><ul>
<li>将 Junction 函数应用于 Junction 表达式，创建一个嵌套 Junction。</li>
</ul>
<pre><code class="language-raku" data-lang="raku">(￮￮) ::  Junction (b -&gt; c) -&gt; Junction b -&gt; Junction (Junction c)
</code></pre><p>为了方便，我们还可以在 Junction a 和 a 之间创建自定义比较运算符。</p>
<pre><code class="language-raku" data-lang="raku">-- and similar for /-, &gt;, &lt;, &lt;=,&gt;=
(￮==•) :: Junction a -&gt; a -&gt; Bool
</code></pre><h4 id="折叠-junction">折叠 Junction</h4>
<p>那么我们就有了 <code>so</code>，布尔强制函数。它的作用是将一个布尔的 Junction 折叠成一个布尔。</p>
<pre><code class="language-raku" data-lang="raku">so :: Junction Bool -&gt; Bool
</code></pre><p>最后我们有 <code>collapse</code>，它从一个 Junction 返回值，前提是它是一个 Junction，所有存储的值都是一样的。</p>
<pre><code class="language-raku" data-lang="raku">collapse :: (Show a,Eq a) =&gt; Junction a -&gt; a
</code></pre><p>这似乎是一个奇怪的函数，但由于 Junction 的行为，它是必要的。正如我们将看到的，上述语义意味着 Junction 是贪婪的：如果一个函数的一个参数是 Junction，那么所有其他参数也会成为 Junction，但 Junction 中的所有值都是相同的。我已经在&quot;<a href="https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8">贪婪 Junction 的奇怪情况</a>&ldquo;中讨论过这个问题，但我们现在可以将这种行为形式化。</p>
<h4 id="重新审视贪婪-junction-的奇怪情况">重新审视贪婪 Junction 的奇怪情况</h4>
<p>假设我们有一个两个参数的函数 <code>f :: a -&gt; b -&gt; c</code>，我们对第一个参数应用一个结点 <code>j :: Junction</code> a 应用到第一个参数 <code>f •￮ j</code> 上，那么结果是一个部分应用的函数，包裹在一个 Junction 上：<code>fp :: Junction b -&gt; c</code>。如果我们现在想用 <code>fp ￮• v</code> 将这个函数应用于一个非结点的值 <code>v :: b</code>，那么结果就是 <code>Junction c</code> 类型的。</p>
<p>现在，让我们考虑类型 <code>c</code> 是 <code>forall d . (a -&gt; b -&gt; d) -&gt; d</code> 的特殊情况。所以我们有 <code>Junction</code>(<code>forall d . (a-&gt;b-&gt;d) -&gt; d</code>)。这是一个函数，它接受一个函数参数并返回该函数的返回类型的东西。我们使用 <code>forall</code>，所以 <code>d</code> 可以是任何东西，但在实践中我们希望它是 <code>a</code> 或 <code>b</code>。</p>
<p>假设我们将这个函数(称它为 <code>p</code>)应用于 <code>fst :: a-&gt;b-&gt;a</code>，使用 <code>p ￮• fst</code>，那么我们得到 <code>Junction a</code>。但是如果我们将它应用于 <code>snd :: a-&gt;b-&gt;b</code>，使用 <code>p ￮• snd</code>，那么我们得到 <code>Junction b</code>。</p>
<p>这就是形式上基于类型的分析，为什么我们不能从一个 pair 中返回一个非 Junction 的值，在&rdquo;<a href="https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8">贪婪 Junction 的奇怪情况</a>&ldquo;中已经解释过。而这也是我们需要 <code>collapse</code> 函数的原因。</p>
<h4 id="重构-junction-的第2部分raku-的实现">重构 Junction 的第2部分：Raku 的实现。</h4>
<p>我们从创建 Junction 类型开始，为四种 Junction 类型使用一个枚举，为实际的 Junction 数据类型使用一个角色。</p>
<pre><code class="language-raku" data-lang="raku"># The types of Junctions
enum JType &lt;JAny  JAll  JOne  JNone &gt;;

# The actual Junction type
role Junction[\jt, @vs] {
    has JType $.junction-type=jt;
    has @.values=@vs;
}
</code></pre><p>接下来是四种类型的 Junction 的构造函数（下划线，避免与内建函数的名称冲突）。</p>
<pre><code class="language-raku" data-lang="raku">our sub all_(@vs) {
    Junction[ JAll, @vs].new;
}

our sub any_(@vs) {
    Junction[ JAny, @vs].new;
}

our sub one_(@vs) {
    Junction[ JOne, @vs].new;
}

our sub none_(@vs) {
    Junction[ JNone, @vs].new;
}
</code></pre><p>将一个（单参数）函数应用于 junction 参数。</p>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;●○&gt;( &amp;f, \j ) is export {
    my \jt=j.junction-type; 
    my @vs = j.values;
  
    Junction[ jt, map( {&amp;f($_)}, @vs)].new;
}
</code></pre><p>要将 Junction 内的函数应用于非 Junction 的参数:</p>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;○●&gt;( \jf, \v ) is export {
    my \jt=jf.junction-type; 
    my @fs = jf.values;

    Junction[ jt, map( {$_( v)}, @fs)].new;
}
</code></pre><p>将一个函数应用于两个 junction 参数，相当于将一个 junction 内的函数应用于一个 junction。这里有一个复杂的问题。Raku 对嵌套施加了一个排序，即所有的嵌套总是外嵌套。因此，我们必须检查 junction 的类型，如果需要的话，我们必须交换映射。</p>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;○○&gt;( \jf, \jv ) is export {
    my \jft= jf.junction-type; 
    my @fs = jf.values;
    my \jvt = jv.junction-type;
    my @vs = jv.values;
    if (jvt == JAll and jft != JAll) {        
        Junction[ jvt, map( sub (\v){jf ○● v}, @vs)].new;  
    } else {        
        Junction[ jft, map( sub (&amp;f){ &amp;f ●○ jv}, @fs)].new;
    }
}
</code></pre><p>为了完整，这里是 <code>○==●</code> 的定义。<code>○!=●</code>、<code>○&gt;●</code> 等的定义是类似的。</p>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt; ○==● &gt;( \j, \v ) is export {
    sub (\x){x==v} ●○ j
}
</code></pre><p>接下来我们有 <code>so</code>，它把布尔值的 junction 变成了布尔值。</p>
<pre><code class="language-raku" data-lang="raku">our sub so (\jv) { 
    my @vs = jv.values;
    given jv.junction-type {
        when JAny { elems(grep {$_},  @vs) &gt;0}
        when JAll { elems(grep {!$_}, @vs)==0}
        when JOne { elems(grep {$_},  @vs)==1}
        when JOne { elems(grep {$_},  @vs)==0}
    }
}
</code></pre><p>最后我们有 <code>collapse</code>，正如<a href="https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8">贪婪 Junction 的文章</a>中所定义的那样， <code>collapse</code> 返回 Junction 的值，只要它们都是一样的。</p>
<pre><code class="language-raku" data-lang="raku">our sub collapse( \j ) {
    my \jt=j.junction-type; 
    my @vvs = j.values;
    my $v =  shift @vvs;        
    my @ts = grep {!($_ ~~ $v)}, @vvs;
    if (@ts.elems==0) {  
        $v
    } else {
        die &quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}&quot;;
    }
}
</code></pre><h3 id="junction-清理">Junction 清理</h3>
<p>现在我们再来看看我们的工作假说，将 Raku 的 Junction 上的动作解释为上述类型和操作符的语法糖。</p>
<pre><code class="language-raku" data-lang="raku">sub sq(Int $x --&gt; Int) { $x*$x }
my Junction $j = 11 | 22; 
my Junction $rj = sq($j); 
</code></pre><p>去语法塘后这变成了:</p>
<pre><code class="language-raku" data-lang="raku">my Junction $j = any_ [11,22];
my Junction $rj = &amp;sq ●○ $j;
</code></pre><p>类似地,</p>
<pre><code class="language-raku" data-lang="raku">if ($j == 42) {...} 
</code></pre><p>变成了:</p>
<pre><code class="language-raku" data-lang="raku">if (so ($j ○==● 42)) {...}
</code></pre><p>和其他布尔上下文类似。</p>
<p>如果我们仔细看<a href="https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8">贪婪 Junction 文章</a>中的 pair 例子，那么将 junction 应用到一个有多个参数的函数上:</p>
<pre><code class="language-raku" data-lang="raku">my Junction \p1j = pair R,(42^43);
</code></pre><p>去语法塘后变为:</p>
<pre><code class="language-raku" data-lang="raku">my Junction \p1j = &amp;pair.assuming(R) ●○ one_ [42,43];
</code></pre><p>我们使用 <code>.assuming()</code> 是因为我们需要部分应用。不管我们是先应用非 Junction 参数还是 Junction 参数，都没有关系。</p>
<pre><code class="language-raku" data-lang="raku">my \p1jr = ( sub ($y){ &amp;pair.assuming(*,$y) } ●○ one_ [42,43] ) ○● R;
</code></pre><p>最后，举一个两个参数都是 Junction 的例子。由于 <code>○○</code> 的定义，应用的顺序并不重要。</p>
<pre><code class="language-raku" data-lang="raku">sub m(\x,\y){x*y}

my \p4 = ( sub (\x){ &amp;m.assuming(x) } ●○ any_ [11,22] ) ○○ all_ [33,44];
my \p4r = ( sub (\x){ &amp;m.assuming(*,x) } ●○ all_ [33,44] ) ○○ any_ [11,22];
</code></pre><h3 id="结论">结论</h3>
<p>从 Raku 的 junction 的神奇类型行为实际上是语法糖的假设出发，我使用多态代数数据类型重构了 junction 类型和它的动作，并表明 Raku 的行为作为语法糖的解释对于所提出的实现是成立的。换句话说，Raku 的 Junction 确实遵循静态类型规则。</p>
<p>原文链接: <a href="https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e">https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/junction" term="junction" label="Junction" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[通过函数式编程实现更简洁的代码]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-07-26-cleaner-code-with-functional-programming/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-07-21-checklist-for-6-dot-d/?utm_source=atom_feed" rel="related" type="text/html" title="Checklist for Raku 6.d" />
            
                <id>https://ohmyweekly.github.io/notes/2020-07-26-cleaner-code-with-functional-programming/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-26T00:00:00+08:00</published>
            <updated>2020-07-26T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Cleaner code with functional programming</blockquote><p>函数式编程是一种编程风格，现代语言或多或少都支持这种风格。在这篇文章中，我想解释一下函数式编程如何为你提供强大的抽象，使你的代码更加简洁。我将用 Raku 和 Python 中的例子来说明这一点，我们将看到这两种语言都是函数式编程的优秀语言。</p>
<h2 id="raku-简介">Raku: 简介</h2>
<p>本文的代码示例是用 Python 和 Raku 编写的。我想大多数人都熟悉 Python，但 Raku 不太为人所知，所以我先解释一下基础知识。本文中的代码不是很习惯，所以如果你懂得其他编程语言，应该很容易理解。</p>
<p>Raku 与 Perl 最为相似。两种语言在语法上都与 C/C++、Java 和 JavaScript 相似：基于块，语句用分号隔开，块用大括号分界，参数列表放在括号中，用逗号隔开。将 Perl 和 Raku 与其他语言区分开来的主要特征是使用魔符（&ldquo;有趣的字符&rdquo;）来识别变量的类型：<code>$</code> 代表标量，<code>@</code> 代表数组，<code>%</code> 代表哈希（映射），<code>&amp;</code> 代表子程序。变量也有关键字来标识它们的作用域，我只用 <code>my</code> 来标识变量的词法作用域。子程序是用 <code>sub</code> 关键字来声明的，子程序可以是命名的，也可以是匿名的。</p>
<pre><code class="language-perl6" data-lang="perl6">sub square ($x) {
    $x*$x;
}
# anonymous subroutine 
my $anon_square = sub ($x) {
    $x*$x;
}
</code></pre><p>在 Python 中，这将是：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>

<span class="c1"># anonymous subroutine </span>
<span class="n">anon_square</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
</code></pre></div><p>Raku 支持无符号变量，并使用 <code>\</code> 语法来声明它们。更多关于普通变量和无符号变量之间的区别，请参见 <a href="https://docs.raku.org/language/variables#Sigilless_variables">Raku 文档</a>。例如(<code>say</code> 打印它的参数，后面加一个换行)。</p>
<pre><code class="language-perl6" data-lang="perl6">my \x = 42; # sigilless
my $y = 43; 
say x + $y; 
</code></pre><p>在本文的代码中，我将尽可能地使用无符号变量。</p>
<p>Raku 有几种类型的序列数据结构。在下面的代码中，我将使用<a href="https://docs.raku.org/language/list">列表和数组</a>以及<a href="https://docs.raku.org/type/Range">范围</a>。在 Raku 中，列表和数组的主要区别在于，列表是不可变的，这意味着一旦创建，就不能修改。所以它是一个只读的数据结构。要&quot;更新&quot;一个不可变的数据结构，你需要创建一个更新的副本。另一方面，数组是可变的，所以我们可以更新它们的元素，扩展它们，缩小它们等等。所有的更新都发生在原始数据的位置上。</p>
<p>Raku 的数组类似于 Python 的 list，Raku 的 list 类似于 Python 的 tuple，也是不可变的。除了语法之外，Raku 中的范围与 Python 中的范围相似，都是不可变的。</p>
<pre><code class="language-perl6" data-lang="perl6">my @array1 = 1,2,3; #=&gt; an array because of the '@' sigil
my \array2 = [1,2,3]; #=&gt; an array, because of the '[...]'

my \range1 = 1 .. 10; #=&gt; a range 1 .. 10
my @array3 = 1 .. 10; #=&gt; an array from a range, because of the '@' sigil

my \list1 = 1,2,3; #=&gt; a list
my $list2 = (1,2,3); #=&gt; also a list
my \list3 = |(1 .. 10);  #=&gt; an array from a range because of the '|' flattening operation
</code></pre><p>相应的 Python 代码为:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">list1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="c1">#=&gt; a list from a tuple</span>
<span class="n">list2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span> <span class="c1">#=&gt; a list, because of the &#39;[...]&#39;</span>

<span class="n">range1</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span> <span class="c1">#=&gt; a range 1 .. 10</span>
<span class="n">list3</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">));</span> <span class="c1">#=&gt; a list from a range</span>

<span class="n">tuple1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">;</span> <span class="c1">#=&gt; a tuple</span>
<span class="n">tuple2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="c1">#=&gt; a tuple from a list</span>
<span class="n">tuple3</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">))</span> <span class="c1">#=&gt; creates a tuple from a range</span>
</code></pre></div><p>其他具体的语法或功能将针对具体的例子进行解释。</p>
<h2 id="其他任何名称的函数---作为值的函数"><em>其他任何名称的函数</em> - 作为值的函数</h2>
<p>函数是函数式编程的精髓。正如我在<a href="https://wimvanderbauwhede.github.io/articles/everything-is-a-function">&ldquo;万物皆函数&rdquo;</a>一文中所解释的那样，在适当的函数式语言中，所有的结构都是由函数构建的。</p>
<p>所有现代编程语言都有函数、程序、子程序或方法的概念。它们是代码重用的重要机制。通常，我们认为函数是对一些输入值进行操作以产生一个或多个输出值的东西。输入值可以是全局声明的，也可以是一个类的属性，或者作为参数传递给函数。同样，输出值可以直接返回，到全局变量，作为类的属性或通过修改输入值。</p>
<p>要想从函数式编程中获益最多，最好是函数是纯粹的，这意味着对函数的调用总是对相同的输入产生相同的输出。在实践中，如果函数只接受输入作为参数，并直接返回输出，这一点比较容易实现，但这并不是必不可少的。</p>
<p>函数式编程的关键特征是，函数的输入值和输出值本身可以是函数。所以函数必须是你语言中的值。有时这被称为 &ldquo;函数必须是一等公民&rdquo;，一个接收和/或返回函数的函数有时被称为&quot;高阶函数&quot;。</p>
<p>如果函数是值，那么我们就可以将它们赋值给变量。特别是我们会将它们赋值给其他函数的参数。但我们也可以将它们赋值给普通的变量。</p>
<p>让我们考虑以下函数，<code>choose</code>，它需要三个参数 <code>t</code>，<code>f</code> 和 <code>c</code>。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub choose (\t, \f, \d) {
    if (d) {t} else {f}
}
# Python
def choose (t, f, d):
  if d:
    return t 
  else:
    return f
</code></pre><p>首先让我们用字符串作为前两个参数的值来调用 <code>choose</code>。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \tstr = &quot;True!&quot;;
my \fstr = &quot;False!&quot;;

my \res_str = choose(tstr, fstr, True);

say res_str; #=&gt; says &quot;True!&quot;
# Python
tstr = &quot;True!&quot;
fstr = &quot;False!&quot;

res_str = choose(tstr,fstr,True)

print(res_str) #=&gt; says &quot;True!&quot;
</code></pre><p>现在让我们尝试用函数作为参数:</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub tt (\s) { say &quot;True {s}!&quot; }
sub ff (\s) { say &quot;False {s}!&quot; }

my &amp;res_f = choose(&amp;tt, &amp;ff, False);

say &amp;res_f; #=&gt; says &amp;ff
res_f(&quot;rumour&quot;); #=&gt; says &quot;False rumour!&quot;
# Python
def tt(s):
  print( &quot;True &quot;+s+&quot;!&quot;)
def ff(s):  
  print( &quot;False&quot;+s+&quot;!&quot;)

res_f = choose(tt,ff,True)

print(res_f) #=&gt; says &lt;function tt at 0x7f829c3aa310&gt;
res_f(&quot;rumour&quot;) #=&gt; says &quot;False rumour!&quot;
</code></pre><p>因此，我们的函数 <code>choose</code>  接收两个函数作为它的前两个参数，并返回一个函数。在 Raku 中，我们需要在函数名上加上 <code>&amp;</code> 符号，因为否则它们会被求值：像 <code>tt</code> 这样的裸函数名就等于调用没有参数的函数 <code>tt()</code>。通过将这个函数赋值给一个变量(<code>res_f</code>)，我们现在可以将 <code>res_f</code> 作为一个函数来调用，它最终会根据选择来调用 <code>tt</code> 或 <code>ff</code>。</p>
<h2 id="函数不需要名字">函数不需要名字</h2>
<p>现在，如果我们可以将函数赋值给变量，它们本身其实并不需要一个名字。所以我们的函数可以是匿名的。大多数语言都支持匿名函数，在函数式语言中，它们通常被称为 &ldquo;lambda 函数&rdquo;。在 Raku 中，我们有两种方法来创建匿名函数。</p>
<p>使用 <code>sub (...)</code> 语法:</p>
<pre><code class="language-perl6" data-lang="perl6">my \tt = sub (\s) { say &quot;True {s}!&quot; };
</code></pre><p>或者使用<a href="https://docs.raku.org/language/functions#index-entry-pointy_blocks">&lsquo;尖号块&rsquo;</a>语法，这样更紧凑一些:</p>
<pre><code class="language-perl6" data-lang="perl6">my \ff = -&gt; \s { say &quot;False {s}!&quot; };
</code></pre><p>Python 使用 <code>lambda</code> 关键字:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">tt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span> <span class="p">:</span> <span class="k">print</span><span class="p">(</span> <span class="s2">&#34;True &#34;</span><span class="o">+</span><span class="n">s</span><span class="o">+</span><span class="s2">&#34;!&#34;</span> <span class="p">)</span>
<span class="n">ff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span> <span class="p">:</span> <span class="k">print</span><span class="p">(</span> <span class="s2">&#34;False &#34;</span><span class="o">+</span><span class="n">s</span><span class="o">+</span><span class="s2">&#34;!&#34;</span> <span class="p">)</span>
</code></pre></div><p>所以现在我们可以说:</p>
<pre><code class="language-perl6" data-lang="perl6">my &amp;res_f = choose(tt, ff, True);

say &amp;res_f; #=&gt; says sub { }
res_f(&quot;story&quot;); #=&gt; says &quot;True story!&quot;
</code></pre><p>当我们打印出函数所绑定的变量时，Raku 返回 <code>sub { }</code> 来表示该变量包含一个函数。</p>
<p>在 Python 中:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">res_f</span> <span class="o">=</span> <span class="n">choose</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="bp">True</span><span class="p">);</span>

<span class="k">print</span><span class="p">(</span> <span class="n">res_f</span><span class="p">)</span> <span class="c1">#=&gt; says &lt;function &lt;lambda&gt; at 0x7f829b298b80&gt;</span>
<span class="n">res_f</span><span class="p">(</span><span class="s2">&#34;story&#34;</span><span class="p">)</span> <span class="c1">#=&gt; says &#34;True story!&#34;</span>
</code></pre></div><h2 id="例子-map-grep-和-reduce">例子: <code>map</code>、 <code>grep</code> 和 <code>reduce</code></h2>
<p>函数的功能有很多用途，我只想重点介绍三个在 Raku 中现成的例子：<code>map</code>、<code>reduce</code> 和 <code>grep</code>。Python 有 <code>map</code> 和 <code>filter</code>，并通过 <code>functools</code> 模块提供 <code>reduce</code>。这些函数的共同点是，它们提供了一种对列表进行 <code>for</code> 循环的替代方法。</p>
<h3 id="map--对列表中的所有元素进行函数应用"><code>map</code> : 对列表中的所有元素进行函数应用</h3>
<p><code>map</code> 有两个参数：一个函数和一个列表。它将函数按顺序应用于列表中的所有值，并返回结果，例如将列表中的所有值平方。</p>
<pre><code class="language-perl6" data-lang="perl6">my \res = map -&gt; \x {x*x} , 1 .. 10;
</code></pre><p>在 Python 中，我们需要显式地创建元组，但除了语法上的差异，结构是完全一样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">res</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span> <span class="nb">map</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">)))</span>
</code></pre></div><p>这是对传统 <code>for</code> 循环的功能替代。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \res = [];
for 1 .. 10 -&gt; \x {
    res.push(x*x);
}
# Python
res = []
for x in range(1,11):
    res.append(x*x)
</code></pre><p>请注意，在 Raku 和 Python 中，我们需要为 <code>for</code> 循环版本使用一个可变的数据结构，而 <code>map</code> 版本则使用不可变的数据结构。</p>
<h3 id="grep--过滤列表"><code>grep</code> : 过滤列表</h3>
<p><code>grep</code> (在 Python 中称为 <code>filter</code>)也接受参数，一个函数和一个列表，但它只返回函数返回真的列表中的值。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \res = grep -&gt; \x { x % 5 == 0 }, 1 .. 30;
# Python
res = tuple(filter( lambda x : x % 5 == 0 ,range(1,31)))
</code></pre><p>当然我们也可以用 <code>for</code> 循环和 <code>if</code> 语句来写，但这又需要一个可变的数据结构。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \res = [];
for 1 .. 30 -&gt; \x {
    if (x % 5 == 0) {
    res.push(x);
    }
}
# Python
res = []
for x in range(1,31): 
  if (x % 5 == 0):
    res.append(x)
</code></pre><p><code>map</code> 和 <code>grep</code> 的好处是，你可以很容易地把它们链在一起。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
grep -&gt; \x { x % 5 == 0 }, map -&gt; \x {x*x}, 1..30
# Python
res = tuple(filter( lambda x : x % 5 == 0 ,map( lambda x : x*x ,range(1,31))))
</code></pre><p>这是因为 <code>map</code> 和 <code>grep</code> 接受一个列表并返回一个列表，所以只要你需要对一个列表进行操作，就可以通过链式调用来实现。</p>
<h3 id="reduce--化整为零"><code>reduce</code> : 化整为零</h3>
<p><code>reduce</code> 也接受一个函数和一个 list，但它使用函数将 list 的所有元素合并成一个结果。所以函数必须接受两个参数。第二个参数是从列表中取出的元素，第一个参数作为状态变量来组合所有元素。例如，计算一个数字列表的和:</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \sum = reduce sub (\acc,\elt) {acc+elt}, 1 .. 10;

say sum; #=&gt; says 55
# Python
from functools import reduce

sum = reduce(lambda acc,elt: acc+elt, range(1,11))

print( sum); #=&gt; says 55
</code></pre><p>这里发生的情况是，首先将 <code>acc</code> 设置为列表中的第一个元素(1)，然后加上第二个元素，所以 <code>acc</code> 变成 1+2=3；然后加上第三个元素(3)，以此类推。其效果是将列表中的所有数字连续相加。</p>
<p>为了更清楚地说明这一点，我们来写一个我们自己的 <code>reduce</code> 版本。</p>
<h3 id="编写你自己的">编写你自己的</h3>
<p>在许多函数式语言中，从左到右（从最低索引开始）和从右到左（从最高索引开始）的还原是有区别的。这一点很重要，因为根据做还原的函数，如果从左边或右边消耗列表，结果可能会不同。例如，假设我们的化简函数是</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
-&gt; \x,\y {x+y}
# Python
lambda x,y: x+y
</code></pre><p>那么我们从哪个方向遍历列表并不重要。但考虑以下函数:</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
-&gt; \x,\y { x &lt; y ?? x+y !! x }

# Python
lambda x,y: x+y if x&lt;y else x
</code></pre><p>( <code>... ?? ... !! ...</code> 是条件操作符的 Raku 句法，在大多数其他语言中是 <code>... ? ... : ...</code> 在 Python 中是 <code>... if ... else ...</code>)。</p>
<p>在这种情况下，如果列表从左或从右还原，结果会有所不同。在 Raku 和 Python 中，<code>reduce</code> 是一种从左到右的还原。</p>
<p>另外，<code>reduce</code> 函数可以不使用列表的第一个元素，而是取一个额外的参数，通常称为累加器。在函数式语言中，<code>reduce</code> 通常被称为 <code>fold</code>，所以我们可以有一个左折和一个右折。让我们来看看如何实现这些。</p>
<h4 id="left-fold">Left fold</h4>
<p>实现左折的直接方法（所以和 <code>reduce</code> 一样）是在函数内部使用 <code>for</code> 循环。这意味着我们必须在循环的每次迭代上更新累加器的值。在 Raku 中，无符号变量是不可变的（我在这里简化了，完整的故事请看 <a href="https://docs.raku.org/language/containers#Binding">Raku 文档</a>），所以我们需要使用一个有符号的变量，<code>$acc</code>。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub foldll (&amp;f, \iacc, \lst) { 
  my $acc = iacc; 
  for lst -&gt; \elt {
    $acc = f($acc,elt);
  }
  $acc;
}

# Python
def foldll (f, iacc, lst):
  acc = iacc
  for elt in lst:
    acc = f(acc,elt)  
  return acc
</code></pre><p>如果我们只想使用不可变的变量，我们可以使用递归。Raku 使这一点变得简单，因为它允许一个子程序有多个签名(<code>multi sub</code>)，并且它会调用与签名相匹配的变量。</p>
<p>我们的 <code>foldl</code> 将消耗输入列表 <code>lst</code>，并使用 <code>f</code> 将其元素组合到累加器 <code>acc</code> 中，当列表被消耗后，计算结束，我们可以返回 <code>acc</code> 作为结果。所以我们的第一个变体说，如果输入列表是空的，我们应该返回 <code>acc</code>。 第二个变体从列表中取出一个元素 <code>elt</code> (关于 <code>*</code> 的细节请参见 <a href="https://docs.raku.org/type/Range">Raku 文档</a>)，并将其与 <code>acc</code> 结合到 <code>f(acc,elt)</code> 中。然后用这个新的累加器和 list 的剩余部分 <code>rest</code> 再次调用 <code>foldl</code>。</p>
<pre><code class="language-perl6" data-lang="perl6"># When the list is empty, return the accumulator
multi sub foldl (&amp;f, \acc, ()) { acc }
multi sub foldl (&amp;f, \acc, \lst) {
  # Raku's way of splitting a list in the first elt and the rest
  # The '*' is a shorthand for the end of the list
   my (\elt,\rest) = lst[0, 1 .. * ]; 
   # The actual recursion
   foldl( &amp;f, f(acc, elt), rest);
}
</code></pre><p>Python 不允许这种模式匹配，所以我们需要使用条件来编写递归。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">foldl</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">lst</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">lst</span> <span class="o">==</span> <span class="p">():</span> 
    <span class="k">return</span> <span class="n">acc</span> 
  <span class="k">else</span><span class="p">:</span>
  <span class="c1"># Python&#39;s way of splitting a tuple in the first elt and the rest</span>
  <span class="c1"># rest will be a list, not a tuple, but we&#39;ll let that pass</span>
   <span class="p">(</span><span class="n">elt</span><span class="p">,</span><span class="o">*</span><span class="n">rest</span><span class="p">)</span> <span class="o">=</span> <span class="n">lst</span> 
   <span class="c1"># The actual recursion</span>
   <span class="k">return</span> <span class="n">foldl</span><span class="p">(</span> <span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">elt</span><span class="p">),</span> <span class="n">rest</span><span class="p">)</span>
</code></pre></div><p>在这个实现中，所有的变量都不会被更新。所以所有的变量都可以是不可变的。</p>
<h4 id="right-fold">Right fold</h4>
<p>右折与左折颇为相似。对于基于循环的版本，我们所做的只是将列表反转(<code>reverse</code>)。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub foldrl (&amp;f, \acc, \lst) { 
  my $res = acc;
  for  lst.reverse -&gt; \elt {
    $res = f($res,elt);
  }
  $res;
}

# Python
def foldlr (f, iacc, lst):
  acc = iacc
  for elt in lst.reverse():
    acc = f(acc,elt)  
  return acc
</code></pre><p>在递归版本中，我们从列表中取最后一个元素而不是第一个元素。关于 <code>..^ * - 1</code> 语法的细节，请参见 <a href="https://docs.raku.org/language/operators#infix_..%5E">Raku 文档</a>。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
multi sub foldr ( &amp;f, \acc, ()) { acc }
multi sub foldr (&amp;f, \acc, \lst) {
    my (\rest,\elt) = lst[0..^*-1, *  ];
    foldr( &amp;f, f(acc, elt), rest);
}

# Python
def foldr (f, acc, lst):
  if lst == (): 
    return acc 
  else:
   (*rest,elt) = lst 
   return foldr( f, f(acc, elt), rest)
</code></pre><h4 id="map-and-grep-are-folds"><code>map</code> and <code>grep</code> are folds</h4>
<p>现在，<code>map</code> 和 <code>grep</code> 呢？我们当然可以用 <code>for</code> 循环来实现，但我们也可以用我们的 <code>foldl</code> 来实现它们。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub map (&amp;f,\lst) {
    foldl( sub (\acc,\elt) {
            (|acc,f(elt))
            }, (), lst);
}

# Python
def map (f,lst):
    return foldl( 
      lambda acc,elt:(*acc, f(elt))
      ,()
      ,lst
    )
</code></pre><p>因为函数 <code>f</code> 是可映射的，所以它只有一个参数。但是 <code>foldl</code> 需要一个有两个参数的函数，第一个参数为累加器。所以我们用两个参数的匿名函数调用 <code>foldl</code>。累积器本身是一个空列表。虽然我们前面说过，还原将原来列表的所有元素合并成一个返回值，当然这个返回值可以是任何数据类型，所以也是一个列表。所以我们对原始列表中的每一个元素都调用 <code>f</code>，并将其添加到累加器列表的末尾。(<code>|</code> 将列表扁平化，所以 <code>(|acc,f(elt))</code> 是一个由 <code>acc</code> 的元素和 <code>f(elt)</code> 的结果建立的新列表。)</p>
<p>类似地，我们也可以定义 <code>grep</code>:</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub grep (&amp;f,\lst) {
    foldl( sub (\acc,\elt) {
      if (f(elt)) {
          (|acc,elt)
      } else {
          acc
      }
    }, (), lst);
}

# Python
def filter (f,lst):
    return foldl( 
      lambda acc,elt:
        (*acc,elt) if f(elt) else acc
      , (), lst)
</code></pre><p>就像在 <code>map</code> 实现中一样，我们用一个匿名函数调用 <code>foldl</code>。在这个函数中，我们测试 <code>lst</code> 中的每个 <code>elt</code> 是否为 <code>f(elt)</code> 为真。如果是真，我们就从 <code>acc</code> 和 <code>elt</code> 创建一个新的列表，否则我们就只返回 <code>acc</code>。 因为 <code>map</code> 和 <code>grep</code> 分别对列表中的每个元素进行操作，所以我们也可以使用右折来实现它们。</p>
<p>通过这些例子，我希望无论是对函数工作的概念，还是对函数可能的实现方式，都变得更加清晰。递归实现的优点是它允许我们使用不可变的数据结构。</p>
<h3 id="为什么是不可变的数据结构">为什么是不可变的数据结构？</h3>
<p>你可能会好奇为什么我关注这些不可变的数据结构。正如我们将看到的那样，函数式编程与不可改变的数据结构配合得非常好。而且它们有一个很大的优势：你永远不用担心是否不小心修改了你的数据，也不用担心是否应该做一个副本来确定。所以使用不可变数据结构可以使代码不易出错，更容易调试。它们还具有潜在的性能优势。而我们接下来会看到，在 Raku 中还有另一个优势。</p>
<h2 id="返回函数的函数">返回函数的函数</h2>
<p>函数也可以返回函数。如果我们想拥有一个可参数化的函数，这一点尤其有用。举个简单的例子，假设我们想要一系列以固定值递增一个数字的函数：<code>add1</code>、<code>add2</code> 等。当然，我们可以分别写出每一个函数。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub add_1 (\x) {x+1}
sub add_2 (\x) {x+2}
sub add_3 (\x) {x+3}
sub add_4 (\x) {x+4}
sub add_5 (\x) {x+5}

say add_1(4); #=&gt; says 5
# Python
def add_1 (x) : return x+1
def add_2 (x) : return x+2
def add_3 (x) : return x+3
def add_4 (x) : return x+4
def add_5 (x) : return x+5

print( add_1(4)) #=&gt; says 5
</code></pre><p>或者我们可以使用一个充满匿名函数的列表。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \add =
sub (\x) {x},
sub (\x) {x+1},
sub (\x) {x+2},
sub (\x) {x+3},
sub (\x) {x+4},
sub (\x) {x+5};

say add[0].(4); #=&gt; says 5


# Python
add = (
lambda x : x+1,
lambda x : x+2,
lambda x : x+3,
lambda x : x+4,
lambda x : x+5
)

print( add[0](4)) #=&gt; says 5
</code></pre><p>我们可以做得更好，用一个循环来填充一个匿名函数的数组。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \add = [];
for 0 .. 5 -&gt; \n {
  add.push(sub (\x) {x+n});
}

say add[1].(4); #=&gt; says 5

# Python
add = []
for n in range(0,6):
  add.append(lambda x: x+n)
</code></pre><p>我们每次循环迭代都会创建一个新的匿名函数，并将其添加到数组中。但是，我们可以使用一个函数来创建这些匿名函数，然后我们可以使用 <code>map</code> 来代替循环，并使用一个不可改变的数据结构。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub gen_add(\n) {  
  sub (\x) {x+n}
}

my \add = map &amp;gen_add, 0..5;

say add[1].(4); #=&gt; says 5

# Python
def gen_add(n):  
  return lambda x : x+n

add = tuple(map( gen_add, range(0,6)))

print( add[1](4)) #=&gt; says 5
</code></pre><h3 id="laziness">Laziness</h3>
<p>在 Raku 中，使用(不可改变的)范围有一个额外的好处：我们可以将范围的末端设置为无穷大，在 Raku 中可以写成 <code>∞</code>(unicode 221E)、<code>*</code> 或 <code>Inf</code>。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \add = map &amp;gen_add, 0 .. ∞;  

say add[244].(7124); #=&gt; says 7368
</code></pre><p>这是一个所谓的&quot;懒惰求值&quot;的例子，简称 laziness：Raku 不会尝试（和失败）处理这个无限的列表。相反，它将在我们实际使用该列表中的一个元素时进行处理。表达式的评估会延迟到需要结果的时候，所以当我们调用 <code>add[244]</code> 时，发生的情况是 <code>gen_add(244)</code> 被调用来生成该函数。请注意，这在 <code>for</code> 循环中是行不通的，因为要使用 <code>for</code> 循环，我们需要一个可变的数据结构，而惰性列表必须是不可变的。所以这是一个很好的例子，说明函数式编程风格如何让你从懒惰中获益。</p>
<p>这也是为什么我们递归地实现了 <code>foldl</code>，然后用它来实现我们自己的 <code>map</code> 和 <code>grep</code>：基于递归的版本不需要更新任何变量，所以它们可以与不可变的惰性数据结构一起工作。</p>
<h2 id="函数组合">函数组合</h2>
<p>我们在上面看到，你可以把 <code>map</code> 和 <code>grep</code> 的调用链在一起。通常情况下，你只需要将 <code>map</code> 调用链在一起，例如</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
map -&gt; \x { x + 5 }, map -&gt; \x {x*x}, 1..30;

# Python
map( lambda x : x + 5, map( lambda x : x*x, range(1,31)))
</code></pre><p>在这种情况下，我们可以做得更有效率一些：比起创建一个列表，然后在这个列表上调用 <code>map</code>，我们可以通过组合函数一次完成两个计算。Raku 为此提供了一个特殊的操作符。</p>
<pre><code class="language-perl6" data-lang="perl6">map -&gt; \x { x + 5 } ∘ -&gt; \x { x * x }, 1..30;
</code></pre><p>操作符 <code>∘</code>（&ldquo;环形操作符&rdquo;，unicode 2218，但你也可以用普通的 <code>o</code>）是函数组成操作符，它的发音是 &ldquo;after&rdquo;，所以 <code>f ∘ g</code> 是 &ldquo;f after g&rdquo;。它的作用是将两个现有的函数组合起来，创建一个新的函数。</p>
<pre><code class="language-perl6" data-lang="perl6">my &amp;h = &amp;f ∘ &amp;g;
</code></pre><p>是下面的代码是一样的:</p>
<pre><code class="language-perl6" data-lang="perl6">sub h (\x) {
    f(g(x))
}
</code></pre><p>组成运算符的优点是，它可以适用于任何函数，包括匿名函数。但实际上，它只是另一个高阶函数。它只是下面函数的运算符形式。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub compose(&amp;f,&amp;g) {
    sub (\x) { f(g(x)) }
}
</code></pre><p>Python 没有函数组成操作符，但你也可以很容易地在 Python 中拥有 <code>compose</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># Python</span>
<span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</code></pre></div><h2 id="结论">结论</h2>
<p>在这篇文章中，我用 Raku 和 Python 的例子介绍了三种关键的函数式编程技术：对函数进行操作的函数、返回函数的函数和函数组成。我已经展示了你如何使用函数 <code>map</code>、<code>reduce</code>(折叠)和 <code>grep</code>(过滤)来操作不可变的列表。我已经解释了哟(如何用递归和不递归实现这样的函数，以及递归实现的优势是什么。下面是《 <a href="https://github.com/wimvanderbauwhede/raku-examples/blob/master/decluttering-with-functional-programming.raku">Raku</a> 与 <a href="https://github.com/wimvanderbauwhede/raku-examples/blob/master/decluttering-with-functional-programming.py">Python</a>》一文中的代码。</p>
<p>当然，函数式编程的内容还有很多，我也写了<a href="https://wimvanderbauwhede.github.io/articles/">几篇更高级的文章</a>。本文介绍的概念应该为理解那些更高级的主题打下良好的基础。如果你想了解更多关于函数式编程的知识，你可以考虑我的<a href="https://www.futurelearn.com/courses/functional-programming-haskell">免费在线课程</a>。</p>
<p>原文: <a href="https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/">https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/functional-programming" term="functional-programming" label="functional programming" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Checklist for Raku 6.d]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-07-21-checklist-for-6-dot-d/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2020-07-21-checklist-for-6-dot-d/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-21T00:00:00+08:00</published>
            <updated>2020-07-21T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Checklist for 6.d</blockquote><h2 id="问题">问题</h2>
<p>在 6.d 版本中, 很多东西都发生了变化, 我们至少需要发布一个版本。<a href="https://github.com/perl6/roast/blob/master/docs/announce/6.d.md">这里有个列表</a>。然而, 覆盖面是不完整的。弃用通知采取了不同的形式, 一些新的类型和方法在那里, 一些则没有&hellip;&hellip;</p>
<p>用 <code>#2632</code> 引用这个问题, 并检查项目, 当你的工作, 无论是通过改变后的文档, 看到没有变化, 需要做它。在这种情况下, 请通过评论或如何解释为什么是这种情况。</p>
<h2 id="版本控制的变更">版本控制的变更</h2>
<ul>
<li><strong>[6.d]</strong> <code>&amp;await</code> 在等待的时候不再阻塞线程</li>
<li><strong>[6.d]</strong> <code>whenever</code> 不在 <code>react</code> 抛出的词法作用域内</li>
<li><strong>[6.d]</strong> 在 <code>sub MAIN</code> 里面的 <code>$*ARGFILES</code> 总是由 <code>$*IN</code> 馈入</li>
<li><strong>[6.d]</strong> 结构(字面上的) <code>$()</code>、<code>@()</code> 和 <code>%()</code> 不复存在</li>
<li><strong>[6.d]</strong> 带有 <code>:D</code>/<code>:U</code> 类型约束的变量默认为约束类型的类型对象(例如, 你可以在它们身上使用 <code>.new</code>)</li>
<li><strong>[6.d]</strong> <code>start</code> 块在 sink 上下文中附加异常处理程序</li>
<li><del><strong>[6.d]</strong> 例程必须使用 <code>return-rw</code> 来返回一个 <code>Proxy</code>, 即使例程被标记为 <code>is raw</code> 或 <code>is rw</code></del></li>
<li><strong>[6.d]</strong> 原生的 <code>num</code> 类型默认为 <code>0e0</code> 而不是 <code>NaN</code></li>
<li><strong>[6.d]</strong> 在子程序名中, 保留了键名为 <code>sym</code> 的冒号对（如<code>:sym&lt;foo&gt;</code>）, 以备将来使用</li>
</ul>
<h2 id="废弃">废弃</h2>
<p>这些方法在 6.d 语言中已被废弃, 并将在 6.e 中被删除。实现者可以选择发出弃用警告, 或者在 6.e 版本发布后更长的时间内提供这些方法。</p>
<ul>
<li>使用 <code>'-'</code> (单连字符)作为 <code>&amp;open</code> 的特殊路径, 表示特殊的句柄(使用 <code>IO::Special</code> 对象代替)</li>
<li><code>IO::Handle.slurp-rest</code> (使用 <code>.slurp</code> 代替)</li>
<li><code>Any.flatmap</code> (使用<code>.flat</code> 和 <code>.map</code> 方法的组合来代替)</li>
<li><code>Cool.path</code> (使用 <code>.IO</code> 代替)</li>
<li><code>Pair.freeze</code> (使用去容器化的参数的 <code>Pair.new</code> 来代替)</li>
<li><code>Str.subst-mutate</code> (使用带有 <code>.=</code> 方法调用赋值元运算符的 <code>Str.subst</code> 代替)</li>
<li><code>Rational.norm</code> (现在 <code>Rational</code> 类型必须在创建时标准化)</li>
<li><code>IO::Path.child</code> (使用 <code>.add</code> 代替)</li>
<li><code>&amp;undefine</code> (直接分配 <code>Empty</code>/<code>Nil</code> 代替)</li>
<li><code>:count</code> <code>&amp;lines</code>/<code>Str.lines</code> 例程上的参数(使用所返回的 <code>Seq</code> 上的 <code>.elems</code> 代替)</li>
<li><code>&amp;is_approx</code> in Test.pm6 (使用与 <code>&amp;is-approx</code> 非常相似的行为来代替)</li>
</ul>
<h2 id="新的行为">新的行为</h2>
<ul>
<li>通过新的可定义的 <code>&amp;RUN-MAIN</code>、<code>&amp;ARGS-TO-CAPTURE</code> 和 <code>&amp;GENERATE-USAGE</code> 子例程改善 <code>sub MAIN</code> 的自定义处理</li>
<li><code>%</code> 变量中的 <code>QuantHash</code>/<code>Map</code> 和 <code>@</code> 变量中的 <code>List</code> 可以用 <code>is</code> 特性来声明（例如，<code>my %h is Set</code>）</li>
<li>新的 <code>&lt;ww&gt;</code> regex 规则: 只在单词内匹配</li>
<li>循环可以从上一条语句的值中产生一个值的列表</li>
<li>循环中的 <code>next</code>/<code>last</code> 收集其最后的语句值, 对它们运行的迭代返回 <code>Empty</code></li>
<li><code>.perl</code> 可以在消耗过的 <code>Seq</code>、多维数组、<code>Date</code> 和 <code>CallFrame</code> 上调用</li>
<li><code>.gist</code> 可以在 <code>Attribute</code> 上调用</li>
<li>对自动生成的 <code>USAGE</code> 信息进行了大量改进</li>
<li><code>is hidden-from-USAGE</code> 特性，从自动生成的 <code>USAGE</code> 消息中隐藏 <code>sub MAIN</code> 候选者</li>
<li><code>Parameter.perl</code> 包括可内省的默认值</li>
<li><code>%*ENV</code> 值是同素异形的</li>
<li>尝试使用变量 <code>$;</code>、<code>$,</code>、<code>$.</code>、<code>$\</code>、<code>$(</code>、<code>$)</code>、<code>$&lt;</code>、<code>$&gt;</code>、<code>$/</code>、<code>$\</code>、<code>$[</code>、<code>$-</code>、<code>$+</code> 和 <code>$@</code> 会抛出 <code>X::Syntax::Perl5Var</code></li>
<li>默认的 <code>Hash.keyof</code> 返回一个 <code>Str(Any)</code> 强转类型对象</li>
<li>非 ASCII 数字可以在 <code>:42foo</code> 冒号对快捷方式中使用</li>
<li><code>StrDistance</code> 字符串化为 <code>.after</code> 字符串</li>
<li>更明确的 Pod 表格格式</li>
<li><code>Enumeration.enums</code> 返回一个 <code>Map</code></li>
<li>各种整数类型的 <code>.Range</code> 返回它们支持的值的范围</li>
<li><code>min</code>/<code>max</code>  例程也适用于 <code>Hash</code></li>
<li><code>Signature</code> 字面值可以包含字符串/数字字面值以及调用者标记</li>
<li><code>List.invert</code> 通过所需的 <code>Pair</code> 绑定映射, 导致潜在的类型检查失败</li>
<li><code>:exists</code> 可以与多维关联下标一起使用</li>
<li>动态创建的列表可以用来定义一个枚举</li>
<li>在 <code>.first</code> 中, Junction 可以作为匹配器使用</li>
<li>原生属性可以作为参数中的绑定目标</li>
<li><code>Proc</code> 可以与其他 <code>Proc</code> 中的 <code>IO::Pipe</code> 一起工作</li>
<li>类型数组可以用 <code>my SomeType @array</code> 和 <code>my @array of SomeType</code> 创建</li>
<li>当把 <code>Mixy</code> 强转为 <code>Setty</code>/<code>Baggy </code> 时, 负数权重的项将被删除</li>
<li><code>:nth</code> 副词在 <code>m//</code> 上接受一个 <code>Junction</code> 作为参数</li>
<li><code>CX::Warn' 和 </code>CX::Done<code>可以在</code>CONTROL` phaser 中捕获</li>
<li><code>next</code> 可用于 <code>whenever</code> 中</li>
<li><code>require</code> 符号不再过境性地暴露出来</li>
<li>通过 <code>{...}</code> 进行多维访问, 类似于 <code>[...]</code> 的工作方式</li>
<li>在 <code>END</code> 时间打开的任何手柄都会自动关闭</li>
<li>在缓存的 <code>Seq</code> 上, 当 <code>&amp;infix:&lt;eqv&gt;</code>、<code>.Slip</code>、<code>.join</code>、<code>.List</code>、<code>.list</code>、<code>.eager</code>、<code>.Array</code> 和 <code>.is-lazy</code> 被调用时, 就会使用缓存列表</li>
<li><code>IO::Handle.encoding</code> 以 <code>Nil</code> 表示切换到二进制模式</li>
<li><code>is default</code> 特质与属性一起工作</li>
<li>在多重分派中, 带有 <code>is rw</code> 特性的参数被认为比没有特性的参数窄</li>
<li><code>Array</code>、<code>Blob</code> 和 <code>Map</code> 的 <code>.gist</code> 被裁剪成100个元素</li>
<li>新的 <code>for</code> 语句修饰符 <code>hyper for</code>、<code>race for</code> 和 <code>lazy for</code></li>
<li><code>for</code> 循环自动序列化 <code>RaceSeq</code>/<code>HyperSeq</code>；使用新的 <code>for</code> 语句修饰符<code>hyper for</code>/<code>race for</code>避免</li>
<li><code>&amp;infix:&lt;does&gt;</code> 可用于 RHS 上的非组合实例</li>
<li>数值比较器可以与 <code>DateTime </code> 对象一起使用</li>
<li><code>Pod</code> 保留空白类型</li>
<li>定义了带 <code>@</code>、<code>%</code> 和 <code>&amp;</code> 魔符常数的语义</li>
</ul>
<h2 id="math">Math</h2>
<ul>
<li><code>Rational</code> 总是在创建时被化简, 并在其一生中保持不变</li>
<li><code>Inf</code>、<code>Inf</code> 和 <code>NaN</code> 可以分别用 <code>&lt;-1/0&gt;</code>、<code>&lt;1/0&gt;</code> 和 <code>&lt;0/0</code>&gt; 表示, 通过<code>Rational</code> 类型进行舍去。零分母 <code>Rational</code> 被标准化为这三个值之一</li>
<li>在 ±<code>Inf</code> 和 <code>NaN</code> 上调用 <code>.Int</code>, 会抛出异常</li>
<li>改进了 <code>Num</code> 运算符和数学函数的 IEEE 754-2008 合规性</li>
<li>负零 <code>Num</code>(<code>-0e0</code>)被所有例程和语法结构正确处理</li>
<li><code>Num</code> 类型的字符串化必须是可舍弃到原始 <code>Num</code> 的</li>
<li>定义了涉及零的 <code>Complex </code> 指数</li>
<li><code>.expmod</code> 中的负数幂有效</li>
</ul>
<h2 id="setsbagsmixesaka-quanthashes和集合运算符">Sets、Bags、Mixes(aka QuantHashes)和集合运算符</h2>
<ul>
<li>Set 运算符可以用在任何对象上, 在需要的时候会被强转
<ul>
<li>所以, 不需要也不希望有任何预先的强转</li>
<li>如果没有 QuantHash 就能实现所需的功能, 那么 Set 运算符可以自由地不创建任何 QuantHash</li>
</ul>
</li>
<li>对不同类型的 QuantHashes 的 Set 操作将强转到最自由的形式（Set -&gt; Bag -&gt; Mix）</li>
<li>集合运算符的 set_precedes 家族( <code>(&lt;+)</code>、<code>≼</code>、<code>(&gt;+)</code>、<code>≽</code>) 已被移除
<ul>
<li>曾经是子集运算符的 Baggy 形式</li>
<li>QuantHash 升级为最自由的形式, 所以 <code>(&lt;=)</code>、<code>⊆</code>、<code>(&gt;=)</code>、<code>⊇</code> 做正确的事情</li>
</ul>
</li>
<li><code>.classify-list</code> 方法可用于 <code>Baggy</code> 类型</li>
<li><code>.categorize-list</code> 方法可用于 <code>Baggy</code> 类型</li>
<li><code>.invert</code> 方法可用于核心 <code>QuantHash</code> 类型</li>
<li><code>.antipairs</code> 方法可用于 <code>QuantHash</code> 类型</li>
<li><code>QuantHash</code> 类型有 <code>.new-from-pairs</code> 和将一个 <code>QuantHash</code> 类型转换为另一个 <code>QuantHash</code> 类型的方法(例如 <code>Set</code> 类型的 <code>.Bag</code> 方法)</li>
<li><code>QuantHash</code> 类型上的 <code>.hash</code> 对键值进行了字符串化</li>
</ul>
<h2 id="新的形参和实参">新的形参和实参</h2>
<ul>
<li><code>Date.new</code> 接受一个 <code>:&amp;formatter</code></li>
<li><code>.first</code> 可以接受 <code>:kv</code></li>
<li><code>unique</code> 和 <code>.repeated</code> 可以接受 <code>:&amp;as</code> 和 <code>:&amp;with</code></li>
<li>Test.pm6 中的 <code>&amp;plan</code> 可以接受 <code>:skip-all</code></li>
<li><code>&amp;run</code>/<code>&amp;shell</code> 可以接受 <code>:merge</code></li>
<li><code>&amp;note</code> 可以在没有参数的情况下调用</li>
<li><code>open</code> 接受 <code>:$out-buffer</code></li>
<li><code>IO::Path.resolve</code> 可以接受 <code>:completely</code></li>
<li><code>IO::Path.parent</code> 可以接受一个 <code>Int</code> 表示父级</li>
<li><code>Proc::Async.new</code> 吞噬位置参数</li>
<li><code>Signature.ACCEPTS</code> 接受非 <code>Signature</code>/<code>Capture</code> 参数</li>
<li><code>&amp;EVAL</code> 可以接受一个 <code>Blob</code></li>
<li><code>Promise.keep</code>/<code>.break</code> 可以在没有参数的情况下调用</li>
<li>原生数组上的 <code>.sum</code> 可以接受 <code>:wrap</code></li>
<li><code>is required</code> 现在可以接受一个表示理由的参数</li>
<li><code>IO::Socket::Async.listen</code> 可以绑定到端口 <code>0</code> 以向操作系统申请免费端口</li>
<li><code>.encode</code> 可以接受 <code>:translate-nl</code></li>
</ul>
<h2 id="新的例程和运算符">新的例程和运算符</h2>
<ul>
<li>新的 <code>atomicint</code> Unicode 运算符和 ASCII 等价物, 保证线程安全, 原子操作:
<code>&amp;infix:&lt;⚛=&gt;</code>/<code>&amp;atomic-assign</code>、<code>&amp;prefix:&lt;⚛&gt;</code>/<code>&amp;atomic-fetch</code>、
<code>&amp;prefix:&lt;++⚛&gt;</code>/<code>&amp;atomic-inc-fetch</code>、<code>&amp;postfix:&lt;⚛++&gt;</code>/<code>&amp;atomic-fetch-inc</code>、
<code>&amp;prefix:&lt;--⚛&gt;</code>/<code>&amp;atomic-dec-fetch</code>、<code>&amp;postfix:&lt;⚛--&gt;</code>/<code>&amp;atomic-fetch-dec</code>、
<code>&amp;infix:&lt;⚛-=&gt;</code>/<code>&amp;infix:&lt;⚛−=&gt;</code>/<code>&amp;atomic-fetch-sub</code> 和 <code>&amp;infix:&lt;⚛+=&gt;</code>/<code>&amp;atomic-fetch-add</code></li>
<li><code>&amp;cas</code>: 原子比较与交换</li>
<li><code>≤</code>、<code>≥</code> 和 <code>≠</code> 运算符是 Unicode 运算符, 分别等价于 <code>&lt;=</code>、<code>&gt;=</code> 和 <code>!=</code></li>
<li><code>&amp;infix:&lt;unicmp&gt;</code>/<code>&amp;infix:&lt;coll&gt;</code>: <code>&amp;infix:&lt;cmp&gt;</code> 的替代行为</li>
<li><code>TR///</code>: <code>tr///</code> 的非变异版本</li>
<li><code>submethod TWEAK</code>: 与 <code>BUILD</code> 类似, 除了它与属性默认值兼容之外</li>
<li><code>&amp;duckmap</code>: 应用 <code>&amp;callable</code> 到每个元素上</li>
<li><code>&amp;deepmap</code>: 应用 <code>&amp;callable</code> 到每个元素上, 下降到 <code>Iterable</code> 中</li>
<li><code>&amp;take-rw</code>: 像 <code>&amp;take</code> 一样, 但有一个可写的容器</li>
<li><code>&amp;indir</code>: 在给定的 <code>$*CWD</code> 中执行代码</li>
<li><code>&amp;spurt</code>: 参见 <code>IO::Path.spurt</code></li>
<li><code>&amp;prompt</code>: 提示用户输入</li>
<li><code>uniprops</code>: <code>uniprop</code> 的多字符版本</li>
<li><code>symlink</code>: 建立文件符号链接</li>
<li><code>link</code>: 创建文件硬连接</li>
<li><code>.hyper</code>/<code>.race</code>: 并行处理值的列表</li>
<li><code>Seq.from-loop</code>: 从 <code>Callable</code> 生产一个 <code>Seq</code></li>
<li><code>Str.uniparse</code>: 将一个或多个 Unicode 字符名解析为实际字符</li>
<li><code>Str.parse-base</code>: <code>Int.base</code> 操作的反转</li>
<li><code>IO::Path</code> 提供了 <code>.ACCEPTS</code>、<code>.SPEC</code>、<code>.CWD</code>、<code>.Numeric</code>、<code>.add</code>、<code>.extension</code>、<code>.mode</code> 和各种文件测试、<code>.parts</code>、<code>.sibling</code> 和 <code>.spurt</code></li>
<li><code>IO::Handle</code> 提供了 <code>.READ</code>、<code>.WRITE</code>、<code>.EOF</code>、<code>.DESTROY</code>,
<code>.readchars</code>、<code>.flush</code>、<code>.lock</code>、<code>.unlock</code>、<code>.out-buffer</code>、<code>.tell</code>,
<code>.say</code>、<code>.slurp</code>、<code>.seek</code>、<code>.printf</code>、<code>.print-nl</code> 和 <code>.watch</code></li>
<li><code>IO::Pipe</code> 提供了 <code>.proc</code></li>
<li><code>Iterator</code> 提供了 <code>.skip-one</code>、<code>.skip-at-least</code> 和 <code>.skip-at-least-pull-one</code></li>
<li><code>Mu.emit</code>: <code>&amp;emit</code> 的方法形式</li>
<li>Test.pm6 模块中的 <code>&amp;fails-like</code>: 允许测试失败</li>
<li>Test.pm6 模块中的 <code>&amp;bail-out</code>: 退出失败的测试套件</li>
<li>Test.pm6 模块中的 <code>&amp;is-approx</code>: 测试一个数字近似于另一个</li>
<li><code>Buf</code> 拥有 <code>.allocate</code>、<code>.reallocate</code>、<code>.append</code>、<code>.push</code>、<code>.pop</code>、<code>.splice</code>、<code>.subbuf-rw</code>、<code>.prepend</code> 和 <code>.unshift</code> 方法</li>
<li><code>Range</code> 支持了 <code>.rand</code></li>
<li><code>Backtrace</code> 拥有方法 <code>.map</code>、<code>.flat</code>、<code>.concise</code> 和 <code>.summary</code></li>
<li><code>.classify-list</code> 方法可用于 <code>Hash</code> 类型</li>
<li><code>.categorize-list</code> 方法可用于 <code>Hash</code> 类型</li>
<li><code>Code.of</code>: 返回返回类型约束</li>
<li><code>Code.line</code>/<code>.file</code>: 返回定义的行/文件</li>
<li><code>Proc::Async</code> 提供了 <code>.Supply</code>、<code>.ready</code>、<code>.pid</code>、<code>.bind-stdin</code>、<code>.bind-stdout</code> 和 <code>.bind-stderr</code></li>
<li><code>Proc.command</code>/<code>Proc::Async.command</code>: 我们要执行的命令</li>
<li><code>Proc</code> 提供了 <code>.signal</code>、<code>.pid</code> 和 <del><code>.encoding</code></del></li>
<li><code>Complex</code> 提供了 <code>.cis</code>、<code>.reals</code>、<code>.ceiling</code>、<code>.floor</code>、<code>.round</code>、<code>.truncate</code> 和 <code>.abs</code> 方法, 并可以使用 <code>&lt;=&gt;</code> 进行比较(只要虚部可以忽略不计)</li>
<li><code>DateTime</code> 提供了 <code>.offset-in-hours</code>、<code>.hh-mm-ss</code> 和 <code>.Date</code></li>
<li><code>DateTime</code> 可以使用 <code>&lt;=&gt;</code> 运算符和其它 <code>DateTime</code> 对象进行比较</li>
<li><code>Date</code> 提供了 <code>.DateTime</code> 方法</li>
<li><code>&amp;infix:&lt;+&gt;</code>/<code>&amp;infix:&lt;-&gt;</code> 可以被 <code>Duration</code>、<code>DateTime</code> 和 <code>Real</code> 类型调用</li>
<li><code>Enumeration</code> 提供了 <code>.Int</code>、<code>.pred</code>、<code>.succ</code>、<code>.kv</code> 和 <code>.pair</code></li>
<li><code>.Date</code> 可以在 <code>Instant</code> 上调用</li>
<li>Junction 能使用 <code>Junction.new</code> 调用来创建</li>
<li><code>List</code> 类型拥有 <code>.to</code> 和 <code>.from</code> 方法</li>
<li><code>Map</code> type 提供了 <code>Int</code> 方法, 返回 pair 的数量</li>
<li><code>Any.skip</code>: 跳过列表中的值</li>
<li><code>Any.batch</code>: <code>.rotor</code> 的更基本的表兄弟</li>
<li><code>Mu.iterator</code>: 为一个列表中的值生成一个 <code>Iterator</code></li>
<li><code>IO::Spec::*</code> 类型提供了 <code>.tmpdir</code>、<code>.extension</code> 和 <code>.path</code></li>
<li><code>Pair</code> 提供了 <code>.ACCEPTS</code>、<code>.Pair</code> 和 <code>.invert</code></li>
<li><code>.Capture</code> 方法对所有核心类型都有明确定义</li>
<li>定义了 <code>.ACCEPTS</code> 在同素异形体上的语义</li>
<li><code>Failure.self</code> 使未处理的 <code>Failure</code> 爆发</li>
<li><code>Thread.is-initial-thread</code>: 我们是在初始线程中运行吗</li>
<li><code>Match</code> 提供了 <code>.Int</code> 和 <code>.actions</code></li>
<li><code>IO::Socket::Async</code> 提供了 <code>.socket-port</code> 和 <code>.peer-port</code></li>
<li><code>Promise</code> 提供了另一种构造函器 <code>.kept</code> 和 <code>.broken</code></li>
<li><code>WhateverCode</code> 提供了 <code>.assuming</code></li>
<li><code>WhateverCode</code> 和 <code>Block</code> 提供了 <code>.cando</code></li>
<li><code>.:&lt;…&gt;</code> 语法用于调用前缀运算符作为后缀</li>
<li><code>$*KERNEL</code> 提供了 <code>.hostname</code></li>
<li><code>Nil</code> 拥有定义的 <code>.FALLBACK</code> 特殊方法来返回 <code>Nil</code></li>
</ul>
<h2 id="新类型">新类型</h2>
<ul>
<li><code>atomicint</code>: 原生的 <code>int</code>, 大小可用于新的原子运算符</li>
<li><code>Lock::Async</code>: 互斥的非阻塞机制</li>
<li><code>Encoding::Registry</code>: 管理可用的编码</li>
<li><code>Encoding::Encoder</code>: 编码器, 用于特定的编码</li>
<li><code>Encoding::Decoder</code>: 解码器, 用于特定的编码</li>
<li><code>IO::CatHandle</code>: 将多个只读的 <code>IO::Handle</code> 视同一个</li>
<li>原生的 <code>str</code> 数组</li>
<li><code>Supplier::Preserving</code>: 缓存的实时 <code>Supply</code> 工厂</li>
<li><code>Semaphore</code>: 控制多线程对共享资源的访问</li>
<li><code>IO::Special</code>: 特殊I/O设备的路径 (例如 <code>STDOUT</code>)</li>
<li><code>Exceptions::JSON</code> 自定义异常处理程序的实现(可与<code>PERL6_EXCEPTIONS_HANDLER</code> 环境变量一起使用)</li>
<li><code>SeekType</code> 枚举: <code>IO::Handle.seek</code> 中使用的值</li>
</ul>
<h2 id="新的变量">新的变量</h2>
<ul>
<li>
<p><code>$*USAGE</code>: 可在 <code>MAIN</code> 子例程中使用, 包含自动生成的 <code>USAGE</code> 信息</p>
</li>
<li>
<p>%*SUB-MAIN-OPTS: 设置 <code>sub MAIN</code> 的行为</p>
<ul>
<li><code>%*SUB-MAIN-OPTS&lt;named-anywhere&gt;</code> 允许将命名参数放在命令行的任何位置</li>
</ul>
</li>
<li>
<p><code>$*COLLATION</code>: 配置四个 Unicode 校对级别</p>
</li>
<li>
<p><code>$*INIT-INSTANT</code>: 代表程序启动时间的 <code>Instant</code></p>
</li>
<li>
<p><code>$*HOME</code>: 用户的主目录, 如果存在的话</p>
</li>
<li>
<p><code>&amp;*chdir</code>: <code>Callable</code> 包含 <code>IO::Path.chdir</code> 的变体, 也设置进程的当前目录</p>
</li>
<li>
<p><code>PERL6_TEST_DIE_ON_FAIL</code> 环境变量: 在第一次失败时停止测试套件</p>
</li>
<li>
<p><code>PERL6_EXCEPTIONS_HANDLER</code> 环境变量: 指定自定义异常处理类</p>
</li>
</ul>
<h2 id="对边缘情况强转行为的澄清">对边缘情况/强转行为的澄清</h2>
<ul>
<li><code>UInt</code> 与 <code>Int</code> 类型对象智能匹配为 <code>True</code></li>
<li><code>sink</code> 语句前缀爆炸 <code>Failure</code></li>
<li>定义了1项和0项列表以及负参数和非整数参数的 <code>permutations</code>/<code>combinations</code> 的行为</li>
<li><code>&amp;val</code>、<code>Str.Numeric</code> 和其他 <code>Str</code> 数字转换方法在试图转换 Unicode <code>No</code> 字符组或合成数字时会 <code>fail</code></li>
<li><code>:42foo</code> 冒号对快捷方式中不能使用合成数字</li>
<li>现在、<code>Enumeration</code> 可以作为一个数组形状指定器使用</li>
<li>含有空格的 <code>Str</code> 的数值转换现在返回 <code>0</code></li>
<li>带空的模式参数的 <code>samark</code>, 简单地返回调用者</li>
<li><code>.polymod</code> 可用于 <code>lazy</code> 但有限的除数列表</li>
<li>定义了 <code>.[*-0]</code> 索引</li>
<li><code>.rotor</code> 中大于子列表的负数空隙抛出异常</li>
<li><code>.rotor</code> 的非 <code>Int</code> 参数被强转为 <code>Int</code> 参数</li>
<li>读取 <code>/proc</code> 文件时定义了 <code>.lines</code></li>
<li>定义了字符串上后缀/前缀  <code>++</code>/<code>--</code> 中泰语数字的行为</li>
<li>sunk <code>for</code> 里面的 <code>map</code> 被视为 sunk</li>
<li>Sunk <code>for</code> 循环将上一条语句的方法调用值下沉</li>
<li><code>Bool</code> 对象上的 <code>.Int</code> 返回一个 <code>Int</code> 对象</li>
<li><code>splice</code> 可用于扩展数组</li>
<li><code>classify</code> 可以与 <code>Junction</code> 配合使用</li>
<li><code>.pairup</code> on a type object returns an empty <code>Seq</code></li>
<li><code>.pairup</code> 总是返回一个 <code>Seq</code></li>
<li>拒绝接受  <code>Date</code>/<code>DateTime</code> 构造函数中的合成代码点</li>
<li><code>⸨</code>/<code>⸩</code> 对儿现在可以作为引号结构中的匹配字符使用</li>
<li><code>Array</code> 类型对象上的 <code>.flat</code> 简单地返回该类型对象</li>
<li>混合级 <code>classify</code> 在 <code>Hash</code> 上抛出异常</li>
<li><code>Junction</code> 可以用于给 <code>Hash</code> 指定多个键</li>
<li>给 <code>.classify-list</code> 的 <code>Callable</code> 现在保证每项只执行一次</li>
<li><code>:delete</code> 对 <code>Hash</code> 类型对象进行关联查找时返回 <code>Nil</code></li>
<li>Test.pm6 中的 <code>&amp;is-deeply</code> 会自动 <code>.cache</code> 作为参数的 <code>Seq</code>, 并使用返回的 <code>List</code> 进行测试</li>
<li><code>Complex.new()</code> 给出 <code>&lt;0+0i&gt;</code></li>
<li><code>Int.new</code> 现在可以保证构建一个新的 <code>Int</code> (而不是, 比如说, 从常量缓存中重用一个)</li>
<li>定义了一个参数(1-arg)版本的 <code>&amp;infix:&lt;=:=&gt;</code> 和 <code>&amp;infix:&lt;eqv&gt;</code></li>
<li>如果直接或间接地调用 <code>.BIND-POS</code>、<code>.BIND-KEY</code>、<code>.ASSIGN-POS</code>、<code>.ASSIGN-KEY</code>、<code>.STORE</code>、<code>.push</code>、<code>.append</code>、<code>.unshift</code>、<code>.prepend</code>、<code>Nil</code> 类型现在抛出异常</li>
<li><code>Nil.ord</code> 返回一个空的 <code>Seq</code></li>
<li><code>Nil.chrs</code> 返回一个 <code>&quot;\0&quot;</code></li>
<li><code>Num.new</code> 强转参数为 <code>Num</code></li>
<li><code>infix:&lt;Z&gt;()</code> 返回一个空的 <code>Seq</code></li>
<li><code>.comb</code> 总是返回一个 <code>Seq</code></li>
<li>用 <code>&amp;infix:&lt;+&gt;</code> 化简一个项, 简单地返回该项</li>
<li><code>()[0]</code> 返回 <code>Nil</code></li>
<li>允许在(可能是无限的) <code>Seq</code> 上使用 Regex 智能匹配</li>
<li>定义了 <code>Range</code> 对象的智能匹配</li>
<li><code>Set</code> 转换为<code>Mix</code>/<code>Bag</code> 不再有 <code>Bool</code> 权重</li>
<li>当一个或多个操作数为 <code>0</code> 时、<code>gcd</code> 是有定义的</li>
<li><code>defined</code> 例程中的 <code>Junction</code> 自动线程化</li>
<li><code>sum</code> 可以处理含有 <code>Junction</code> 的列表</li>
<li><code>Grammar.parse</code> 让顶级 <code>regex</code> 回溯</li>
<li><code>U+2212 MINUS SIGN [Sm] (-)</code> 现在得到更多结构的支持, 如 <code>Str.Numeric</code> 和 <code>&amp;val</code></li>
<li>Arity-1 <code>&amp;infix:&lt;~&gt;</code> 与 <code>Blob</code> 可以一起工作</li>
<li>在签名中, 所有的 <code>Numeric</code> 字面值都支持作为值字面值</li>
<li>正则表达式中的 <code>\b</code> 和 <code>\B</code> 抛出 <code>X::Obsolete</code></li>
<li><code>True</code> 和 <code>False</code> 作为签名中的值字面量发出警告</li>
<li><code>.sort</code> 和 <code>IO::Spec::Unix.path</code> 的返回值总是 <code>Seq</code></li>
<li><code>Range</code> 对象上的 Out-of-range <code>.AT-POS</code> 返回 <code>Nil</code></li>
<li>对于不存在的键、<code>Pair.AT-KEY</code> 返回 <code>Nil</code></li>
<li>所有的 <code>Cool</code> 类型都提供了 <code>.Rat</code>/<code>.FatRat</code> 强转器</li>
<li><code>IO::Path</code> 文件测试不缓存先前测试执行的结果</li>
<li><code>Seq</code> eqv <code>List</code> 仅根据类型不匹配就定为 <code>False</code></li>
<li><del><input disabled="" type="checkbox"> 在 <code>Hash </code>、<code>Hash </code> 和 <code>QuantHash</code> 上, 来自 <code>.kv</code>、<code>.values</code> 和 <code>.pair</code> 序列的值是可写的</del> 参见 <a href="https://github.com/Raku/roast/issues/614">Raku/roast#614</a> 和 <a href="https://github.com/Raku/doc/issues/3519">#3519</a></li>
<li><code>&amp;infix:&lt;∘&gt;</code>/<code>&amp;infix:&lt;o&gt;</code> 保留 LHF 的 <code>.of</code> 和 RHS 的 <code>.arity</code> 和 <code>.count</code></li>
<li>完善了 regex 运算符副词中的可接受参数(例如:<code>:in(…)</code>)</li>
<li>完善了 <code>IO::Handle.open</code> 中可接受的参数组合</li>
<li><code>IO::Path.Str</code> 不包含 <code>.CWD</code> 属性的值</li>
<li><code>IO::Path</code> 类型拒绝带有  <code>nul</code> 字节 (<code>&quot;\0&quot;</code>) 的路径</li>
<li><code>IO::Pipe</code> 的 <code>.path</code>/<code>.IO</code> 返回一个 <code>IO::Path</code> 类型对象</li>
<li>如果目的路径和源路径是一样的 <code>IO::Path</code> 的 <code>.copy</code>/<code>.move</code> 会 <code>fail</code></li>
<li><code>dir</code> 创建的 <code>IO::Path</code> 绝对性由调用者控制</li>
<li>更多定义的边缘行为、<code>Callable </code> 处理、<code>. defined</code> 调用, 以及 <code>&amp;infix:&lt;andthen&gt;</code>、<code>&amp;infix:&lt;orelse&gt;</code> 和 <code>&amp;infix:&lt;notandthen&gt;</code> 操作符的链接</li>
<li><code>Seq</code> 的禅切不缓存它们</li>
<li><code>List.Capture</code> 将任何包含的 <code>Pair</code> 对象的键字符串化</li>
<li>带处理的 <code>Failure</code> 参数的 <code>&amp;fail</code> 把它标记为是未处理的</li>
<li><code>use lib</code> 接受 <code>IO::Path</code> 对象</li>
<li>锚点 <code>^</code>、<code>^^</code>、<code>$</code> 和 <code>$$</code> 在环视中有效</li>
<li><code>Grammar.made</code> 支持类型对象</li>
<li><code>.isa</code> 支持 <code>subset </code> 类型对象</li>
<li><code>:delete</code> 可用于惰性数组</li>
<li><code>&amp;infix:&lt;eqv&gt;</code> 可以在某些情况下对惰性参数起作用</li>
<li>动态查询(<code>::(...)</code>) 是限制性的 regex 语法, 并且需要 <code>use MONKEY-SEE-NO-EVAL</code> 的许可</li>
<li>定义了带孔数组的 <code>.Slip</code> 和 <code>.List</code></li>
<li><code>Promise.in</code>/<code>.at</code> 和 <code>Supply.interval</code> 可以用零值和负值工作</li>
<li><code>Supply.interval</code> 最小值为 <code>0.001</code>；较低值被处理为 <code>0.001</code>, 并发出警告#, 参见 <a href="https://github.com/Raku/doc/pull/2649">https://docs.perl6.org/type/Supply#method_interval PR [#2649]</a></li>
<li><code>Supply</code> 提供了 <code>.Seq</code>、<code>.list</code> 和 <code>.zip</code></li>
<li>可以在构建方法中绑定到原生类型属性</li>
<li><code>WhateverCode</code> 传播 <code>use fatal</code></li>
<li><code>say</code>、<code>note</code>、<code>put</code>、<code>print</code> 和 <code>printf</code> 例程自动线程化 <code>Junction</code></li>
<li><code>IO::Handle.eof</code> 值在 <code>.seek</code> 过终点后再返回时也会相应改变</li>
<li>定义了 <code>.succ'、</code>.pred<code>和</code>.Bool` 的同质异形体</li>
<li>在核心 <code>Numeric</code> 上定义了 <code>.Bridge</code></li>
<li><del><input disabled="" type="checkbox"> 在核心 <code>Numeric</code> 的类型对象上定义了 <code>.Numeric</code>/<code>.Real</code></del></li>
<li>定义了关于零分母有理数的 <code>Rational.Bool</code></li>
<li><code>say</code>/<code>note</code> 保证在 <code>Str</code> 的子类上调用 <code>.gist</code></li>
<li>定义了 <code>Junction.Str</code> 返回 <code>Junction</code></li>
<li>定义了 <code>Junction.gist</code>/<code>.perl</code> 返回一个 <code>Str</code></li>
<li><code>Map</code>/<code>Hash</code> 的 <code>.list</code>/<code>.cache</code> 返回一个 <code>List</code></li>
<li>定义了 <code>.round</code> 的返回类型</li>
<li>定义了 <code>Enumeration:D</code>  不  <code>.ACCEPT</code> 一个 <code>Enumeration:U</code> , 参见 <a href="https://github.com/rakudo/rakudo/issues/2073">rakudo/rakudo#2073</a></li>
</ul>
<h2 id="杂项">杂项</h2>
<ul>
<li><code>IO::ArgFiles</code> 类型只是 <code>IO::CatHandle</code> 的一个空的子类</li>
<li>对常量的约束
<ul>
<li>约束是完全强制的</li>
<li>试图在常量上使用参数化类型约束(例如使用 <code>my Foo constant @int</code>) 会引发 <code>X::ParametricConstant</code> 异常</li>
</ul>
</li>
<li><code>Pod</code> <code>=defn</code>(定义列表)指令可用</li>
<li><code>Pod</code> 提供了 <code>:numbered</code> 配置键</li>
<li><code>.^ver</code>、<code>.^auth</code> 和 <code>.^name</code> 元方法在 <code>module</code> 中可用, 而在 <code>package</code> 中则没有, 这是设计上的原因</li>
<li><code>qww&lt;…&gt;</code> 中支持花哨的引号(<code>’…’</code>、<code>“…”</code>、<code>｢…｣</code> 和变体)</li>
<li><code>&amp;infix:&lt; &gt;</code> 支持查找自动生成的 <code>Callables</code> (例如: <code>&amp;infix:&lt;XX&gt;</code>)</li>
<li>使用命名的 <code>anon</code> 子例程不再产生重声明警告</li>
<li><code>::?MODULE</code>/<code>$?MODULE</code> 变量的扩展规范</li>
<li><code>sub MAIN</code> 可以接受一个参数上的 <code>Enumeration</code> 类型约束和 <code>where</code> 子句</li>
<li>笑脸型约束可以用在子集上</li>
<li><code>start</code> 块和 thunks 得到新的 <code>$/</code> 和 <code>$!</code></li>
<li>定义了与列表关联运算符一起使用的 <code>R</code> 元运算符</li>
<li>类型强转可以用在签名返回类型约束中</li>
<li><code>&amp;infix:&lt;x&gt;</code>/<code>&amp;infix:&lt;x&gt;</code> 抛出了 <code>-Inf</code>/<code>NaN</code> 重复参数</li>
<li>字面结构 <code>put</code> 和 <code>put for</code> 抛出, 需要使用括号</li>
<li>扩大了 Unicode 例程和功能的规范覆盖面-将覆盖面升级到 Unicode 第11版</li>
<li><code>$.</code> 方法调用语法能用在元方法中了</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/6.d" term="6.d" label="6.d" />
                            
                        
                    
                
            
        </entry>
    
</feed>
