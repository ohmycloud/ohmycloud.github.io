{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"children":[{"content":{"html":"\u003ch2 id=\"问题\"\u003e问题\u003c/h2\u003e\n\u003cp\u003e在 6.d 版本中, 很多东西都发生了变化, 我们至少需要发布一个版本。\u003ca href=\"https://github.com/perl6/roast/blob/master/docs/announce/6.d.md\"\u003e这里有个列表\u003c/a\u003e。然而, 覆盖面是不完整的。弃用通知采取了不同的形式, 一些新的类型和方法在那里, 一些则没有\u0026hellip;\u0026hellip;\u003c/p\u003e\n\u003cp\u003e用 \u003ccode\u003e#2632\u003c/code\u003e 引用这个问题, 并检查项目, 当你的工作, 无论是通过改变后的文档, 看到没有变化, 需要做它。在这种情况下, 请通过评论或如何解释为什么是这种情况。\u003c/p\u003e\n\u003ch2 id=\"版本控制的变更\"\u003e版本控制的变更\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e \u003ccode\u003e\u0026amp;await\u003c/code\u003e 在等待的时候不再阻塞线程\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e \u003ccode\u003ewhenever\u003c/code\u003e 不在 \u003ccode\u003ereact\u003c/code\u003e 抛出的词法作用域内\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e 在 \u003ccode\u003esub MAIN\u003c/code\u003e 里面的 \u003ccode\u003e$*ARGFILES\u003c/code\u003e 总是由 \u003ccode\u003e$*IN\u003c/code\u003e 馈入\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e 结构(字面上的) \u003ccode\u003e$()\u003c/code\u003e、\u003ccode\u003e@()\u003c/code\u003e 和 \u003ccode\u003e%()\u003c/code\u003e 不复存在\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e 带有 \u003ccode\u003e:D\u003c/code\u003e/\u003ccode\u003e:U\u003c/code\u003e 类型约束的变量默认为约束类型的类型对象(例如, 你可以在它们身上使用 \u003ccode\u003e.new\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e \u003ccode\u003estart\u003c/code\u003e 块在 sink 上下文中附加异常处理程序\u003c/li\u003e\n\u003cli\u003e~~**[6.d]** 例程必须使用 \u003ccode\u003ereturn-rw\u003c/code\u003e 来返回一个 \u003ccode\u003eProxy\u003c/code\u003e, 即使例程被标记为 \u003ccode\u003eis raw\u003c/code\u003e 或 \u003ccode\u003eis rw\u003c/code\u003e~~\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e 原生的 \u003ccode\u003enum\u003c/code\u003e 类型默认为 \u003ccode\u003e0e0\u003c/code\u003e 而不是 \u003ccode\u003eNaN\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e 在子程序名中, 保留了键名为 \u003ccode\u003esym\u003c/code\u003e 的冒号对（如\u003ccode\u003e:sym\u0026lt;foo\u0026gt;\u003c/code\u003e）, 以备将来使用\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"废弃\"\u003e废弃\u003c/h2\u003e\n\u003cp\u003e这些方法在 6.d 语言中已被废弃, 并将在 6.e 中被删除。实现者可以选择发出弃用警告, 或者在 6.e 版本发布后更长的时间内提供这些方法。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用 \u003ccode\u003e'-'\u003c/code\u003e (单连字符)作为 \u003ccode\u003e\u0026amp;open\u003c/code\u003e 的特殊路径, 表示特殊的句柄(使用 \u003ccode\u003eIO::Special\u003c/code\u003e 对象代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Handle.slurp-rest\u003c/code\u003e (使用 \u003ccode\u003e.slurp\u003c/code\u003e 代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAny.flatmap\u003c/code\u003e (使用\u003ccode\u003e.flat\u003c/code\u003e 和 \u003ccode\u003e.map\u003c/code\u003e 方法的组合来代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCool.path\u003c/code\u003e (使用 \u003ccode\u003e.IO\u003c/code\u003e 代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePair.freeze\u003c/code\u003e (使用去容器化的参数的 \u003ccode\u003ePair.new\u003c/code\u003e 来代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eStr.subst-mutate\u003c/code\u003e (使用带有 \u003ccode\u003e.=\u003c/code\u003e 方法调用赋值元运算符的 \u003ccode\u003eStr.subst\u003c/code\u003e 代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRational.norm\u003c/code\u003e (现在 \u003ccode\u003eRational\u003c/code\u003e 类型必须在创建时标准化)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Path.child\u003c/code\u003e (使用 \u003ccode\u003e.add\u003c/code\u003e 代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;undefine\u003c/code\u003e (直接分配 \u003ccode\u003eEmpty\u003c/code\u003e/\u003ccode\u003eNil\u003c/code\u003e 代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e:count\u003c/code\u003e \u003ccode\u003e\u0026amp;lines\u003c/code\u003e/\u003ccode\u003eStr.lines\u003c/code\u003e 例程上的参数(使用所返回的 \u003ccode\u003eSeq\u003c/code\u003e 上的 \u003ccode\u003e.elems\u003c/code\u003e 代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;is_approx\u003c/code\u003e in Test.pm6 (使用与 \u003ccode\u003e\u0026amp;is-approx\u003c/code\u003e 非常相似的行为来代替)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"新的行为\"\u003e新的行为\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e通过新的可定义的 \u003ccode\u003e\u0026amp;RUN-MAIN\u003c/code\u003e、\u003ccode\u003e\u0026amp;ARGS-TO-CAPTURE\u003c/code\u003e 和 \u003ccode\u003e\u0026amp;GENERATE-USAGE\u003c/code\u003e 子例程改善 \u003ccode\u003esub MAIN\u003c/code\u003e 的自定义处理\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e%\u003c/code\u003e 变量中的 \u003ccode\u003eQuantHash\u003c/code\u003e/\u003ccode\u003eMap\u003c/code\u003e 和 \u003ccode\u003e@\u003c/code\u003e 变量中的 \u003ccode\u003eList\u003c/code\u003e 可以用 \u003ccode\u003eis\u003c/code\u003e 特性来声明（例如，\u003ccode\u003emy %h is Set\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e新的 \u003ccode\u003e\u0026lt;ww\u0026gt;\u003c/code\u003e regex 规则: 只在单词内匹配\u003c/li\u003e\n\u003cli\u003e循环可以从上一条语句的值中产生一个值的列表\u003c/li\u003e\n\u003cli\u003e循环中的 \u003ccode\u003enext\u003c/code\u003e/\u003ccode\u003elast\u003c/code\u003e 收集其最后的语句值, 对它们运行的迭代返回 \u003ccode\u003eEmpty\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.perl\u003c/code\u003e 可以在消耗过的 \u003ccode\u003eSeq\u003c/code\u003e、多维数组、\u003ccode\u003eDate\u003c/code\u003e 和 \u003ccode\u003eCallFrame\u003c/code\u003e 上调用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.gist\u003c/code\u003e 可以在 \u003ccode\u003eAttribute\u003c/code\u003e 上调用\u003c/li\u003e\n\u003cli\u003e对自动生成的 \u003ccode\u003eUSAGE\u003c/code\u003e 信息进行了大量改进\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eis hidden-from-USAGE\u003c/code\u003e 特性，从自动生成的 \u003ccode\u003eUSAGE\u003c/code\u003e 消息中隐藏 \u003ccode\u003esub MAIN\u003c/code\u003e 候选者\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eParameter.perl\u003c/code\u003e 包括可内省的默认值\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e%*ENV\u003c/code\u003e 值是同素异形的\u003c/li\u003e\n\u003cli\u003e尝试使用变量 \u003ccode\u003e$;\u003c/code\u003e、\u003ccode\u003e$,\u003c/code\u003e、\u003ccode\u003e$.\u003c/code\u003e、\u003ccode\u003e$\\\u003c/code\u003e、\u003ccode\u003e$(\u003c/code\u003e、\u003ccode\u003e$)\u003c/code\u003e、\u003ccode\u003e$\u0026lt;\u003c/code\u003e、\u003ccode\u003e$\u0026gt;\u003c/code\u003e、\u003ccode\u003e$/\u003c/code\u003e、\u003ccode\u003e$\\\u003c/code\u003e、\u003ccode\u003e$[\u003c/code\u003e、\u003ccode\u003e$-\u003c/code\u003e、\u003ccode\u003e$+\u003c/code\u003e 和 \u003ccode\u003e$@\u003c/code\u003e 会抛出 \u003ccode\u003eX::Syntax::Perl5Var\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e默认的 \u003ccode\u003eHash.keyof\u003c/code\u003e 返回一个 \u003ccode\u003eStr(Any)\u003c/code\u003e 强转类型对象\u003c/li\u003e\n\u003cli\u003e非 ASCII 数字可以在 \u003ccode\u003e:42foo\u003c/code\u003e 冒号对快捷方式中使用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eStrDistance\u003c/code\u003e 字符串化为 \u003ccode\u003e.after\u003c/code\u003e 字符串\u003c/li\u003e\n\u003cli\u003e更明确的 Pod 表格格式\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEnumeration.enums\u003c/code\u003e 返回一个 \u003ccode\u003eMap\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e各种整数类型的 \u003ccode\u003e.Range\u003c/code\u003e 返回它们支持的值的范围\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emin\u003c/code\u003e/\u003ccode\u003emax\u003c/code\u003e  例程也适用于 \u003ccode\u003eHash\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSignature\u003c/code\u003e 字面值可以包含字符串/数字字面值以及调用者标记\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eList.invert\u003c/code\u003e 通过所需的 \u003ccode\u003ePair\u003c/code\u003e 绑定映射, 导致潜在的类型检查失败\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e:exists\u003c/code\u003e 可以与多维关联下标一起使用\u003c/li\u003e\n\u003cli\u003e动态创建的列表可以用来定义一个枚举\u003c/li\u003e\n\u003cli\u003e在 \u003ccode\u003e.first\u003c/code\u003e 中, Junction 可以作为匹配器使用\u003c/li\u003e\n\u003cli\u003e原生属性可以作为参数中的绑定目标\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eProc\u003c/code\u003e 可以与其他 \u003ccode\u003eProc\u003c/code\u003e 中的 \u003ccode\u003eIO::Pipe\u003c/code\u003e 一起工作\u003c/li\u003e\n\u003cli\u003e类型数组可以用 \u003ccode\u003emy SomeType @array\u003c/code\u003e 和 \u003ccode\u003emy @array of SomeType\u003c/code\u003e 创建\u003c/li\u003e\n\u003cli\u003e当把 \u003ccode\u003eMixy\u003c/code\u003e 强转为 \u003ccode\u003eSetty\u003c/code\u003e/\u003ccode\u003eBaggy \u003c/code\u003e 时, 负数权重的项将被删除\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e:nth\u003c/code\u003e 副词在 \u003ccode\u003em//\u003c/code\u003e 上接受一个 \u003ccode\u003eJunction\u003c/code\u003e 作为参数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCX::Warn' 和 \u003c/code\u003eCX::Done\u003ccode\u003e可以在\u003c/code\u003eCONTROL` phaser 中捕获\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enext\u003c/code\u003e 可用于 \u003ccode\u003ewhenever\u003c/code\u003e 中\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erequire\u003c/code\u003e 符号不再过境性地暴露出来\u003c/li\u003e\n\u003cli\u003e通过 \u003ccode\u003e{...}\u003c/code\u003e 进行多维访问, 类似于 \u003ccode\u003e[...]\u003c/code\u003e 的工作方式\u003c/li\u003e\n\u003cli\u003e在 \u003ccode\u003eEND\u003c/code\u003e 时间打开的任何手柄都会自动关闭\u003c/li\u003e\n\u003cli\u003e在缓存的 \u003ccode\u003eSeq\u003c/code\u003e 上, 当 \u003ccode\u003e\u0026amp;infix:\u0026lt;eqv\u0026gt;\u003c/code\u003e、\u003ccode\u003e.Slip\u003c/code\u003e、\u003ccode\u003e.join\u003c/code\u003e、\u003ccode\u003e.List\u003c/code\u003e、\u003ccode\u003e.list\u003c/code\u003e、\u003ccode\u003e.eager\u003c/code\u003e、\u003ccode\u003e.Array\u003c/code\u003e 和 \u003ccode\u003e.is-lazy\u003c/code\u003e 被调用时, 就会使用缓存列表\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Handle.encoding\u003c/code\u003e 以 \u003ccode\u003eNil\u003c/code\u003e 表示切换到二进制模式\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eis default\u003c/code\u003e 特质与属性一起工作\u003c/li\u003e\n\u003cli\u003e在多重分派中, 带有 \u003ccode\u003eis rw\u003c/code\u003e 特性的参数被认为比没有特性的参数窄\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eArray\u003c/code\u003e、\u003ccode\u003eBlob\u003c/code\u003e 和 \u003ccode\u003eMap\u003c/code\u003e 的 \u003ccode\u003e.gist\u003c/code\u003e 被裁剪成100个元素\u003c/li\u003e\n\u003cli\u003e新的 \u003ccode\u003efor\u003c/code\u003e 语句修饰符 \u003ccode\u003ehyper for\u003c/code\u003e、\u003ccode\u003erace for\u003c/code\u003e 和 \u003ccode\u003elazy for\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efor\u003c/code\u003e 循环自动序列化 \u003ccode\u003eRaceSeq\u003c/code\u003e/\u003ccode\u003eHyperSeq\u003c/code\u003e；使用新的 \u003ccode\u003efor\u003c/code\u003e 语句修饰符\u003ccode\u003ehyper for\u003c/code\u003e/\u003ccode\u003erace for\u003c/code\u003e避免\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;infix:\u0026lt;does\u0026gt;\u003c/code\u003e 可用于 RHS 上的非组合实例\u003c/li\u003e\n\u003cli\u003e数值比较器可以与 \u003ccode\u003eDateTime \u003c/code\u003e 对象一起使用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePod\u003c/code\u003e 保留空白类型\u003c/li\u003e\n\u003cli\u003e定义了带 \u003ccode\u003e@\u003c/code\u003e、\u003ccode\u003e%\u003c/code\u003e 和 \u003ccode\u003e\u0026amp;\u003c/code\u003e 魔符常数的语义\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"math\"\u003eMath\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eRational\u003c/code\u003e 总是在创建时被化简, 并在其一生中保持不变\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eInf\u003c/code\u003e、\u003ccode\u003eInf\u003c/code\u003e 和 \u003ccode\u003eNaN\u003c/code\u003e 可以分别用 \u003ccode\u003e\u0026lt;-1/0\u0026gt;\u003c/code\u003e、\u003ccode\u003e\u0026lt;1/0\u0026gt;\u003c/code\u003e 和 \u003ccode\u003e\u0026lt;0/0\u003c/code\u003e\u0026gt; 表示, 通过\u003ccode\u003eRational\u003c/code\u003e 类型进行舍去。零分母 \u003ccode\u003eRational\u003c/code\u003e 被标准化为这三个值之一\u003c/li\u003e\n\u003cli\u003e在 ±\u003ccode\u003eInf\u003c/code\u003e 和 \u003ccode\u003eNaN\u003c/code\u003e 上调用 \u003ccode\u003e.Int\u003c/code\u003e, 会抛出异常\u003c/li\u003e\n\u003cli\u003e改进了 \u003ccode\u003eNum\u003c/code\u003e 运算符和数学函数的 IEEE 754-2008 合规性\u003c/li\u003e\n\u003cli\u003e负零 \u003ccode\u003eNum\u003c/code\u003e(\u003ccode\u003e-0e0\u003c/code\u003e)被所有例程和语法结构正确处理\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNum\u003c/code\u003e 类型的字符串化必须是可舍弃到原始 \u003ccode\u003eNum\u003c/code\u003e 的\u003c/li\u003e\n\u003cli\u003e定义了涉及零的 \u003ccode\u003eComplex \u003c/code\u003e 指数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.expmod\u003c/code\u003e 中的负数幂有效\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"setsbagsmixesaka-quanthashes和集合运算符\"\u003eSets、Bags、Mixes(aka QuantHashes)和集合运算符\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSet 运算符可以用在任何对象上, 在需要的时候会被强转\n\u003cul\u003e\n\u003cli\u003e所以, 不需要也不希望有任何预先的强转\u003c/li\u003e\n\u003cli\u003e如果没有 QuantHash 就能实现所需的功能, 那么 Set 运算符可以自由地不创建任何 QuantHash\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e对不同类型的 QuantHashes 的 Set 操作将强转到最自由的形式（Set -\u0026gt; Bag -\u0026gt; Mix）\u003c/li\u003e\n\u003cli\u003e集合运算符的 set_precedes 家族( \u003ccode\u003e(\u0026lt;+)\u003c/code\u003e、\u003ccode\u003e≼\u003c/code\u003e、\u003ccode\u003e(\u0026gt;+)\u003c/code\u003e、\u003ccode\u003e≽\u003c/code\u003e) 已被移除\n\u003cul\u003e\n\u003cli\u003e曾经是子集运算符的 Baggy 形式\u003c/li\u003e\n\u003cli\u003eQuantHash 升级为最自由的形式, 所以 \u003ccode\u003e(\u0026lt;=)\u003c/code\u003e、\u003ccode\u003e⊆\u003c/code\u003e、\u003ccode\u003e(\u0026gt;=)\u003c/code\u003e、\u003ccode\u003e⊇\u003c/code\u003e 做正确的事情\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.classify-list\u003c/code\u003e 方法可用于 \u003ccode\u003eBaggy\u003c/code\u003e 类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.categorize-list\u003c/code\u003e 方法可用于 \u003ccode\u003eBaggy\u003c/code\u003e 类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.invert\u003c/code\u003e 方法可用于核心 \u003ccode\u003eQuantHash\u003c/code\u003e 类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.antipairs\u003c/code\u003e 方法可用于 \u003ccode\u003eQuantHash\u003c/code\u003e 类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eQuantHash\u003c/code\u003e 类型有 \u003ccode\u003e.new-from-pairs\u003c/code\u003e 和将一个 \u003ccode\u003eQuantHash\u003c/code\u003e 类型转换为另一个 \u003ccode\u003eQuantHash\u003c/code\u003e 类型的方法(例如 \u003ccode\u003eSet\u003c/code\u003e 类型的 \u003ccode\u003e.Bag\u003c/code\u003e 方法)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eQuantHash\u003c/code\u003e 类型上的 \u003ccode\u003e.hash\u003c/code\u003e 对键值进行了字符串化\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"新的形参和实参\"\u003e新的形参和实参\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eDate.new\u003c/code\u003e 接受一个 \u003ccode\u003e:\u0026amp;formatter\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.first\u003c/code\u003e 可以接受 \u003ccode\u003e:kv\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eunique\u003c/code\u003e 和 \u003ccode\u003e.repeated\u003c/code\u003e 可以接受 \u003ccode\u003e:\u0026amp;as\u003c/code\u003e 和 \u003ccode\u003e:\u0026amp;with\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eTest.pm6 中的 \u003ccode\u003e\u0026amp;plan\u003c/code\u003e 可以接受 \u003ccode\u003e:skip-all\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;run\u003c/code\u003e/\u003ccode\u003e\u0026amp;shell\u003c/code\u003e 可以接受 \u003ccode\u003e:merge\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;note\u003c/code\u003e 可以在没有参数的情况下调用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eopen\u003c/code\u003e 接受 \u003ccode\u003e:$out-buffer\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Path.resolve\u003c/code\u003e 可以接受 \u003ccode\u003e:completely\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Path.parent\u003c/code\u003e 可以接受一个 \u003ccode\u003eInt\u003c/code\u003e 表示父级\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eProc::Async.new\u003c/code\u003e 吞噬位置参数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSignature.ACCEPTS\u003c/code\u003e 接受非 \u003ccode\u003eSignature\u003c/code\u003e/\u003ccode\u003eCapture\u003c/code\u003e 参数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;EVAL\u003c/code\u003e 可以接受一个 \u003ccode\u003eBlob\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePromise.keep\u003c/code\u003e/\u003ccode\u003e.break\u003c/code\u003e 可以在没有参数的情况下调用\u003c/li\u003e\n\u003cli\u003e原生数组上的 \u003ccode\u003e.sum\u003c/code\u003e 可以接受 \u003ccode\u003e:wrap\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eis required\u003c/code\u003e 现在可以接受一个表示理由的参数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Socket::Async.listen\u003c/code\u003e 可以绑定到端口 \u003ccode\u003e0\u003c/code\u003e 以向操作系统申请免费端口\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.encode\u003c/code\u003e 可以接受 \u003ccode\u003e:translate-nl\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"新的例程和运算符\"\u003e新的例程和运算符\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e新的 \u003ccode\u003eatomicint\u003c/code\u003e Unicode 运算符和 ASCII 等价物, 保证线程安全, 原子操作:\n\u003ccode\u003e\u0026amp;infix:\u0026lt;⚛=\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-assign\u003c/code\u003e、\u003ccode\u003e\u0026amp;prefix:\u0026lt;⚛\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-fetch\u003c/code\u003e、\n\u003ccode\u003e\u0026amp;prefix:\u0026lt;++⚛\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-inc-fetch\u003c/code\u003e、\u003ccode\u003e\u0026amp;postfix:\u0026lt;⚛++\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-fetch-inc\u003c/code\u003e、\n\u003ccode\u003e\u0026amp;prefix:\u0026lt;--⚛\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-dec-fetch\u003c/code\u003e、\u003ccode\u003e\u0026amp;postfix:\u0026lt;⚛--\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-fetch-dec\u003c/code\u003e、\n\u003ccode\u003e\u0026amp;infix:\u0026lt;⚛-=\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;infix:\u0026lt;⚛−=\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-fetch-sub\u003c/code\u003e 和 \u003ccode\u003e\u0026amp;infix:\u0026lt;⚛+=\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-fetch-add\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;cas\u003c/code\u003e: 原子比较与交换\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e≤\u003c/code\u003e、\u003ccode\u003e≥\u003c/code\u003e 和 \u003ccode\u003e≠\u003c/code\u003e 运算符是 Unicode 运算符, 分别等价于 \u003ccode\u003e\u0026lt;=\u003c/code\u003e、\u003ccode\u003e\u0026gt;=\u003c/code\u003e 和 \u003ccode\u003e!=\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;infix:\u0026lt;unicmp\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;infix:\u0026lt;coll\u0026gt;\u003c/code\u003e: \u003ccode\u003e\u0026amp;infix:\u0026lt;cmp\u0026gt;\u003c/code\u003e 的替代行为\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTR///\u003c/code\u003e: \u003ccode\u003etr///\u003c/code\u003e 的非变异版本\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esubmethod TWEAK\u003c/code\u003e: 与 \u003ccode\u003eBUILD\u003c/code\u003e 类似, 除了它与属性默认值兼容之外\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;duckmap\u003c/code\u003e: 应用 \u003ccode\u003e\u0026amp;callable\u003c/code\u003e 到每个元素上\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;deepmap\u003c/code\u003e: 应用 \u003ccode\u003e\u0026amp;callable\u003c/code\u003e 到每个元素上, 下降到 \u003ccode\u003eIterable\u003c/code\u003e 中\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;take-rw\u003c/code\u003e: 像 \u003ccode\u003e\u0026amp;take\u003c/code\u003e 一样, 但有一个可写的容器\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;indir\u003c/code\u003e: 在给定的 \u003ccode\u003e$*CWD\u003c/code\u003e 中执行代码\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;spurt\u003c/code\u003e: 参见 \u003ccode\u003eIO::Path.spurt\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;prompt\u003c/code\u003e: 提示用户输入\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003euniprops\u003c/code\u003e: \u003ccode\u003euniprop\u003c/code\u003e 的多字符版本\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esymlink\u003c/code\u003e: 建立文件符号链接\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elink\u003c/code\u003e: 创建文件硬连接\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.hyper\u003c/code\u003e/\u003ccode\u003e.race\u003c/code\u003e: 并行处理值的列表\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSeq.from-loop\u003c/code\u003e: 从 \u003ccode\u003eCallable\u003c/code\u003e 生产一个 \u003ccode\u003eSeq\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eStr.uniparse\u003c/code\u003e: 将一个或多个 Unicode 字符名解析为实际字符\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eStr.parse-base\u003c/code\u003e: \u003ccode\u003eInt.base\u003c/code\u003e 操作的反转\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Path\u003c/code\u003e 提供了 \u003ccode\u003e.ACCEPTS\u003c/code\u003e、\u003ccode\u003e.SPEC\u003c/code\u003e、\u003ccode\u003e.CWD\u003c/code\u003e、\u003ccode\u003e.Numeric\u003c/code\u003e、\u003ccode\u003e.add\u003c/code\u003e、\u003ccode\u003e.extension\u003c/code\u003e、\u003ccode\u003e.mode\u003c/code\u003e 和各种文件测试、\u003ccode\u003e.parts\u003c/code\u003e、\u003ccode\u003e.sibling\u003c/code\u003e 和 \u003ccode\u003e.spurt\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Handle\u003c/code\u003e 提供了 \u003ccode\u003e.READ\u003c/code\u003e、\u003ccode\u003e.WRITE\u003c/code\u003e、\u003ccode\u003e.EOF\u003c/code\u003e、\u003ccode\u003e.DESTROY\u003c/code\u003e,\n\u003ccode\u003e.readchars\u003c/code\u003e、\u003ccode\u003e.flush\u003c/code\u003e、\u003ccode\u003e.lock\u003c/code\u003e、\u003ccode\u003e.unlock\u003c/code\u003e、\u003ccode\u003e.out-buffer\u003c/code\u003e、\u003ccode\u003e.tell\u003c/code\u003e,\n\u003ccode\u003e.say\u003c/code\u003e、\u003ccode\u003e.slurp\u003c/code\u003e、\u003ccode\u003e.seek\u003c/code\u003e、\u003ccode\u003e.printf\u003c/code\u003e、\u003ccode\u003e.print-nl\u003c/code\u003e 和 \u003ccode\u003e.watch\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Pipe\u003c/code\u003e 提供了 \u003ccode\u003e.proc\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIterator\u003c/code\u003e 提供了 \u003ccode\u003e.skip-one\u003c/code\u003e、\u003ccode\u003e.skip-at-least\u003c/code\u003e 和 \u003ccode\u003e.skip-at-least-pull-one\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMu.emit\u003c/code\u003e: \u003ccode\u003e\u0026amp;emit\u003c/code\u003e 的方法形式\u003c/li\u003e\n\u003cli\u003eTest.pm6 模块中的 \u003ccode\u003e\u0026amp;fails-like\u003c/code\u003e: 允许测试失败\u003c/li\u003e\n\u003cli\u003eTest.pm6 模块中的 \u003ccode\u003e\u0026amp;bail-out\u003c/code\u003e: 退出失败的测试套件\u003c/li\u003e\n\u003cli\u003eTest.pm6 模块中的 \u003ccode\u003e\u0026amp;is-approx\u003c/code\u003e: 测试一个数字近似于另一个\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBuf\u003c/code\u003e 拥有 \u003ccode\u003e.allocate\u003c/code\u003e、\u003ccode\u003e.reallocate\u003c/code\u003e、\u003ccode\u003e.append\u003c/code\u003e、\u003ccode\u003e.push\u003c/code\u003e、\u003ccode\u003e.pop\u003c/code\u003e、\u003ccode\u003e.splice\u003c/code\u003e、\u003ccode\u003e.subbuf-rw\u003c/code\u003e、\u003ccode\u003e.prepend\u003c/code\u003e 和 \u003ccode\u003e.unshift\u003c/code\u003e 方法\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRange\u003c/code\u003e 支持了 \u003ccode\u003e.rand\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBacktrace\u003c/code\u003e 拥有方法 \u003ccode\u003e.map\u003c/code\u003e、\u003ccode\u003e.flat\u003c/code\u003e、\u003ccode\u003e.concise\u003c/code\u003e 和 \u003ccode\u003e.summary\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.classify-list\u003c/code\u003e 方法可用于 \u003ccode\u003eHash\u003c/code\u003e 类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.categorize-list\u003c/code\u003e 方法可用于 \u003ccode\u003eHash\u003c/code\u003e 类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCode.of\u003c/code\u003e: 返回返回类型约束\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCode.line\u003c/code\u003e/\u003ccode\u003e.file\u003c/code\u003e: 返回定义的行/文件\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eProc::Async\u003c/code\u003e 提供了 \u003ccode\u003e.Supply\u003c/code\u003e、\u003ccode\u003e.ready\u003c/code\u003e、\u003ccode\u003e.pid\u003c/code\u003e、\u003ccode\u003e.bind-stdin\u003c/code\u003e、\u003ccode\u003e.bind-stdout\u003c/code\u003e 和 \u003ccode\u003e.bind-stderr\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eProc.command\u003c/code\u003e/\u003ccode\u003eProc::Async.command\u003c/code\u003e: 我们要执行的命令\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eProc\u003c/code\u003e 提供了 \u003ccode\u003e.signal\u003c/code\u003e、\u003ccode\u003e.pid\u003c/code\u003e 和 \u003cdel\u003e\u003ccode\u003e.encoding\u003c/code\u003e\u003c/del\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eComplex\u003c/code\u003e 提供了 \u003ccode\u003e.cis\u003c/code\u003e、\u003ccode\u003e.reals\u003c/code\u003e、\u003ccode\u003e.ceiling\u003c/code\u003e、\u003ccode\u003e.floor\u003c/code\u003e、\u003ccode\u003e.round\u003c/code\u003e、\u003ccode\u003e.truncate\u003c/code\u003e 和 \u003ccode\u003e.abs\u003c/code\u003e 方法, 并可以使用 \u003ccode\u003e\u0026lt;=\u0026gt;\u003c/code\u003e 进行比较(只要虚部可以忽略不计)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDateTime\u003c/code\u003e 提供了 \u003ccode\u003e.offset-in-hours\u003c/code\u003e、\u003ccode\u003e.hh-mm-ss\u003c/code\u003e 和 \u003ccode\u003e.Date\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDateTime\u003c/code\u003e 可以使用 \u003ccode\u003e\u0026lt;=\u0026gt;\u003c/code\u003e 运算符和其它 \u003ccode\u003eDateTime\u003c/code\u003e 对象进行比较\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDate\u003c/code\u003e 提供了 \u003ccode\u003e.DateTime\u003c/code\u003e 方法\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;infix:\u0026lt;+\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;infix:\u0026lt;-\u0026gt;\u003c/code\u003e 可以被 \u003ccode\u003eDuration\u003c/code\u003e、\u003ccode\u003eDateTime\u003c/code\u003e 和 \u003ccode\u003eReal\u003c/code\u003e 类型调用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEnumeration\u003c/code\u003e 提供了 \u003ccode\u003e.Int\u003c/code\u003e、\u003ccode\u003e.pred\u003c/code\u003e、\u003ccode\u003e.succ\u003c/code\u003e、\u003ccode\u003e.kv\u003c/code\u003e 和 \u003ccode\u003e.pair\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.Date\u003c/code\u003e 可以在 \u003ccode\u003eInstant\u003c/code\u003e 上调用\u003c/li\u003e\n\u003cli\u003eJunction 能使用 \u003ccode\u003eJunction.new\u003c/code\u003e 调用来创建\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eList\u003c/code\u003e 类型拥有 \u003ccode\u003e.to\u003c/code\u003e 和 \u003ccode\u003e.from\u003c/code\u003e 方法\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMap\u003c/code\u003e type 提供了 \u003ccode\u003eInt\u003c/code\u003e 方法, 返回 pair 的数量\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAny.skip\u003c/code\u003e: 跳过列表中的值\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAny.batch\u003c/code\u003e: \u003ccode\u003e.rotor\u003c/code\u003e 的更基本的表兄弟\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMu.iterator\u003c/code\u003e: 为一个列表中的值生成一个 \u003ccode\u003eIterator\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Spec::*\u003c/code\u003e 类型提供了 \u003ccode\u003e.tmpdir\u003c/code\u003e、\u003ccode\u003e.extension\u003c/code\u003e 和 \u003ccode\u003e.path\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePair\u003c/code\u003e 提供了 \u003ccode\u003e.ACCEPTS\u003c/code\u003e、\u003ccode\u003e.Pair\u003c/code\u003e 和 \u003ccode\u003e.invert\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.Capture\u003c/code\u003e 方法对所有核心类型都有明确定义\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003e.ACCEPTS\u003c/code\u003e 在同素异形体上的语义\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFailure.self\u003c/code\u003e 使未处理的 \u003ccode\u003eFailure\u003c/code\u003e 爆发\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eThread.is-initial-thread\u003c/code\u003e: 我们是在初始线程中运行吗\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMatch\u003c/code\u003e 提供了 \u003ccode\u003e.Int\u003c/code\u003e 和 \u003ccode\u003e.actions\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Socket::Async\u003c/code\u003e 提供了 \u003ccode\u003e.socket-port\u003c/code\u003e 和 \u003ccode\u003e.peer-port\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePromise\u003c/code\u003e 提供了另一种构造函器 \u003ccode\u003e.kept\u003c/code\u003e 和 \u003ccode\u003e.broken\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eWhateverCode\u003c/code\u003e 提供了 \u003ccode\u003e.assuming\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eWhateverCode\u003c/code\u003e 和 \u003ccode\u003eBlock\u003c/code\u003e 提供了 \u003ccode\u003e.cando\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.:\u0026lt;…\u0026gt;\u003c/code\u003e 语法用于调用前缀运算符作为后缀\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$*KERNEL\u003c/code\u003e 提供了 \u003ccode\u003e.hostname\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNil\u003c/code\u003e 拥有定义的 \u003ccode\u003e.FALLBACK\u003c/code\u003e 特殊方法来返回 \u003ccode\u003eNil\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"新类型\"\u003e新类型\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eatomicint\u003c/code\u003e: 原生的 \u003ccode\u003eint\u003c/code\u003e, 大小可用于新的原子运算符\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLock::Async\u003c/code\u003e: 互斥的非阻塞机制\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEncoding::Registry\u003c/code\u003e: 管理可用的编码\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEncoding::Encoder\u003c/code\u003e: 编码器, 用于特定的编码\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEncoding::Decoder\u003c/code\u003e: 解码器, 用于特定的编码\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::CatHandle\u003c/code\u003e: 将多个只读的 \u003ccode\u003eIO::Handle\u003c/code\u003e 视同一个\u003c/li\u003e\n\u003cli\u003e原生的 \u003ccode\u003estr\u003c/code\u003e 数组\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSupplier::Preserving\u003c/code\u003e: 缓存的实时 \u003ccode\u003eSupply\u003c/code\u003e 工厂\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSemaphore\u003c/code\u003e: 控制多线程对共享资源的访问\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Special\u003c/code\u003e: 特殊I/O设备的路径 (例如 \u003ccode\u003eSTDOUT\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eExceptions::JSON\u003c/code\u003e 自定义异常处理程序的实现(可与\u003ccode\u003ePERL6_EXCEPTIONS_HANDLER\u003c/code\u003e 环境变量一起使用)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSeekType\u003c/code\u003e 枚举: \u003ccode\u003eIO::Handle.seek\u003c/code\u003e 中使用的值\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"新的变量\"\u003e新的变量\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e$*USAGE\u003c/code\u003e: 可在 \u003ccode\u003eMAIN\u003c/code\u003e 子例程中使用, 包含自动生成的 \u003ccode\u003eUSAGE\u003c/code\u003e 信息\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e%*SUB-MAIN-OPTS: 设置 \u003ccode\u003esub MAIN\u003c/code\u003e 的行为\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e%*SUB-MAIN-OPTS\u0026lt;named-anywhere\u0026gt;\u003c/code\u003e 允许将命名参数放在命令行的任何位置\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e$*COLLATION\u003c/code\u003e: 配置四个 Unicode 校对级别\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e$*INIT-INSTANT\u003c/code\u003e: 代表程序启动时间的 \u003ccode\u003eInstant\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e$*HOME\u003c/code\u003e: 用户的主目录, 如果存在的话\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026amp;*chdir\u003c/code\u003e: \u003ccode\u003eCallable\u003c/code\u003e 包含 \u003ccode\u003eIO::Path.chdir\u003c/code\u003e 的变体, 也设置进程的当前目录\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ePERL6_TEST_DIE_ON_FAIL\u003c/code\u003e 环境变量: 在第一次失败时停止测试套件\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ePERL6_EXCEPTIONS_HANDLER\u003c/code\u003e 环境变量: 指定自定义异常处理类\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"对边缘情况强转行为的澄清\"\u003e对边缘情况/强转行为的澄清\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eUInt\u003c/code\u003e 与 \u003ccode\u003eInt\u003c/code\u003e 类型对象智能匹配为 \u003ccode\u003eTrue\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esink\u003c/code\u003e 语句前缀爆炸 \u003ccode\u003eFailure\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e定义了1项和0项列表以及负参数和非整数参数的 \u003ccode\u003epermutations\u003c/code\u003e/\u003ccode\u003ecombinations\u003c/code\u003e 的行为\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;val\u003c/code\u003e、\u003ccode\u003eStr.Numeric\u003c/code\u003e 和其他 \u003ccode\u003eStr\u003c/code\u003e 数字转换方法在试图转换 Unicode \u003ccode\u003eNo\u003c/code\u003e 字符组或合成数字时会 \u003ccode\u003efail\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e:42foo\u003c/code\u003e 冒号对快捷方式中不能使用合成数字\u003c/li\u003e\n\u003cli\u003e现在、\u003ccode\u003eEnumeration\u003c/code\u003e 可以作为一个数组形状指定器使用\u003c/li\u003e\n\u003cli\u003e含有空格的 \u003ccode\u003eStr\u003c/code\u003e 的数值转换现在返回 \u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e带空的模式参数的 \u003ccode\u003esamark\u003c/code\u003e, 简单地返回调用者\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.polymod\u003c/code\u003e 可用于 \u003ccode\u003elazy\u003c/code\u003e 但有限的除数列表\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003e.[*-0]\u003c/code\u003e 索引\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.rotor\u003c/code\u003e 中大于子列表的负数空隙抛出异常\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.rotor\u003c/code\u003e 的非 \u003ccode\u003eInt\u003c/code\u003e 参数被强转为 \u003ccode\u003eInt\u003c/code\u003e 参数\u003c/li\u003e\n\u003cli\u003e读取 \u003ccode\u003e/proc\u003c/code\u003e 文件时定义了 \u003ccode\u003e.lines\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e定义了字符串上后缀/前缀  \u003ccode\u003e++\u003c/code\u003e/\u003ccode\u003e--\u003c/code\u003e 中泰语数字的行为\u003c/li\u003e\n\u003cli\u003esunk \u003ccode\u003efor\u003c/code\u003e 里面的 \u003ccode\u003emap\u003c/code\u003e 被视为 sunk\u003c/li\u003e\n\u003cli\u003eSunk \u003ccode\u003efor\u003c/code\u003e 循环将上一条语句的方法调用值下沉\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBool\u003c/code\u003e 对象上的 \u003ccode\u003e.Int\u003c/code\u003e 返回一个 \u003ccode\u003eInt\u003c/code\u003e 对象\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esplice\u003c/code\u003e 可用于扩展数组\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eclassify\u003c/code\u003e 可以与 \u003ccode\u003eJunction\u003c/code\u003e 配合使用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.pairup\u003c/code\u003e on a type object returns an empty \u003ccode\u003eSeq\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.pairup\u003c/code\u003e 总是返回一个 \u003ccode\u003eSeq\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e拒绝接受  \u003ccode\u003eDate\u003c/code\u003e/\u003ccode\u003eDateTime\u003c/code\u003e 构造函数中的合成代码点\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e⸨\u003c/code\u003e/\u003ccode\u003e⸩\u003c/code\u003e 对儿现在可以作为引号结构中的匹配字符使用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eArray\u003c/code\u003e 类型对象上的 \u003ccode\u003e.flat\u003c/code\u003e 简单地返回该类型对象\u003c/li\u003e\n\u003cli\u003e混合级 \u003ccode\u003eclassify\u003c/code\u003e 在 \u003ccode\u003eHash\u003c/code\u003e 上抛出异常\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eJunction\u003c/code\u003e 可以用于给 \u003ccode\u003eHash\u003c/code\u003e 指定多个键\u003c/li\u003e\n\u003cli\u003e给 \u003ccode\u003e.classify-list\u003c/code\u003e 的 \u003ccode\u003eCallable\u003c/code\u003e 现在保证每项只执行一次\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e:delete\u003c/code\u003e 对 \u003ccode\u003eHash\u003c/code\u003e 类型对象进行关联查找时返回 \u003ccode\u003eNil\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eTest.pm6 中的 \u003ccode\u003e\u0026amp;is-deeply\u003c/code\u003e 会自动 \u003ccode\u003e.cache\u003c/code\u003e 作为参数的 \u003ccode\u003eSeq\u003c/code\u003e, 并使用返回的 \u003ccode\u003eList\u003c/code\u003e 进行测试\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eComplex.new()\u003c/code\u003e 给出 \u003ccode\u003e\u0026lt;0+0i\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eInt.new\u003c/code\u003e 现在可以保证构建一个新的 \u003ccode\u003eInt\u003c/code\u003e (而不是, 比如说, 从常量缓存中重用一个)\u003c/li\u003e\n\u003cli\u003e定义了一个参数(1-arg)版本的 \u003ccode\u003e\u0026amp;infix:\u0026lt;=:=\u0026gt;\u003c/code\u003e 和 \u003ccode\u003e\u0026amp;infix:\u0026lt;eqv\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e如果直接或间接地调用 \u003ccode\u003e.BIND-POS\u003c/code\u003e、\u003ccode\u003e.BIND-KEY\u003c/code\u003e、\u003ccode\u003e.ASSIGN-POS\u003c/code\u003e、\u003ccode\u003e.ASSIGN-KEY\u003c/code\u003e、\u003ccode\u003e.STORE\u003c/code\u003e、\u003ccode\u003e.push\u003c/code\u003e、\u003ccode\u003e.append\u003c/code\u003e、\u003ccode\u003e.unshift\u003c/code\u003e、\u003ccode\u003e.prepend\u003c/code\u003e、\u003ccode\u003eNil\u003c/code\u003e 类型现在抛出异常\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNil.ord\u003c/code\u003e 返回一个空的 \u003ccode\u003eSeq\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNil.chrs\u003c/code\u003e 返回一个 \u003ccode\u003e\u0026quot;\\0\u0026quot;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNum.new\u003c/code\u003e 强转参数为 \u003ccode\u003eNum\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einfix:\u0026lt;Z\u0026gt;()\u003c/code\u003e 返回一个空的 \u003ccode\u003eSeq\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.comb\u003c/code\u003e 总是返回一个 \u003ccode\u003eSeq\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e用 \u003ccode\u003e\u0026amp;infix:\u0026lt;+\u0026gt;\u003c/code\u003e 化简一个项, 简单地返回该项\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e()[0]\u003c/code\u003e 返回 \u003ccode\u003eNil\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e允许在(可能是无限的) \u003ccode\u003eSeq\u003c/code\u003e 上使用 Regex 智能匹配\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003eRange\u003c/code\u003e 对象的智能匹配\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSet\u003c/code\u003e 转换为\u003ccode\u003eMix\u003c/code\u003e/\u003ccode\u003eBag\u003c/code\u003e 不再有 \u003ccode\u003eBool\u003c/code\u003e 权重\u003c/li\u003e\n\u003cli\u003e当一个或多个操作数为 \u003ccode\u003e0\u003c/code\u003e 时、\u003ccode\u003egcd\u003c/code\u003e 是有定义的\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edefined\u003c/code\u003e 例程中的 \u003ccode\u003eJunction\u003c/code\u003e 自动线程化\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esum\u003c/code\u003e 可以处理含有 \u003ccode\u003eJunction\u003c/code\u003e 的列表\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGrammar.parse\u003c/code\u003e 让顶级 \u003ccode\u003eregex\u003c/code\u003e 回溯\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eU+2212 MINUS SIGN [Sm] (-)\u003c/code\u003e 现在得到更多结构的支持, 如 \u003ccode\u003eStr.Numeric\u003c/code\u003e 和 \u003ccode\u003e\u0026amp;val\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eArity-1 \u003ccode\u003e\u0026amp;infix:\u0026lt;~\u0026gt;\u003c/code\u003e 与 \u003ccode\u003eBlob\u003c/code\u003e 可以一起工作\u003c/li\u003e\n\u003cli\u003e在签名中, 所有的 \u003ccode\u003eNumeric\u003c/code\u003e 字面值都支持作为值字面值\u003c/li\u003e\n\u003cli\u003e正则表达式中的 \u003ccode\u003e\\b\u003c/code\u003e 和 \u003ccode\u003e\\B\u003c/code\u003e 抛出 \u003ccode\u003eX::Obsolete\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTrue\u003c/code\u003e 和 \u003ccode\u003eFalse\u003c/code\u003e 作为签名中的值字面量发出警告\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.sort\u003c/code\u003e 和 \u003ccode\u003eIO::Spec::Unix.path\u003c/code\u003e 的返回值总是 \u003ccode\u003eSeq\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRange\u003c/code\u003e 对象上的 Out-of-range \u003ccode\u003e.AT-POS\u003c/code\u003e 返回 \u003ccode\u003eNil\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e对于不存在的键、\u003ccode\u003ePair.AT-KEY\u003c/code\u003e 返回 \u003ccode\u003eNil\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e所有的 \u003ccode\u003eCool\u003c/code\u003e 类型都提供了 \u003ccode\u003e.Rat\u003c/code\u003e/\u003ccode\u003e.FatRat\u003c/code\u003e 强转器\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Path\u003c/code\u003e 文件测试不缓存先前测试执行的结果\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSeq\u003c/code\u003e eqv \u003ccode\u003eList\u003c/code\u003e 仅根据类型不匹配就定为 \u003ccode\u003eFalse\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cdel\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e在 \u003ccode\u003eHash \u003c/code\u003e、\u003ccode\u003eHash \u003c/code\u003e 和 \u003ccode\u003eQuantHash\u003c/code\u003e 上, 来自 \u003ccode\u003e.kv\u003c/code\u003e、\u003ccode\u003e.values\u003c/code\u003e 和 \u003ccode\u003e.pair\u003c/code\u003e 序列的值是可写的\u003c/del\u003e 参见 \u003ca href=\"https://github.com/Raku/roast/issues/614\"\u003eRaku/roast#614\u003c/a\u003e 和 \u003ca href=\"https://github.com/Raku/doc/issues/3519\"\u003e#3519\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;infix:\u0026lt;∘\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;infix:\u0026lt;o\u0026gt;\u003c/code\u003e 保留 LHF 的 \u003ccode\u003e.of\u003c/code\u003e 和 RHS 的 \u003ccode\u003e.arity\u003c/code\u003e 和 \u003ccode\u003e.count\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e完善了 regex 运算符副词中的可接受参数(例如:\u003ccode\u003e:in(…)\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e完善了 \u003ccode\u003eIO::Handle.open\u003c/code\u003e 中可接受的参数组合\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Path.Str\u003c/code\u003e 不包含 \u003ccode\u003e.CWD\u003c/code\u003e 属性的值\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Path\u003c/code\u003e 类型拒绝带有  \u003ccode\u003enul\u003c/code\u003e 字节 (\u003ccode\u003e\u0026quot;\\0\u0026quot;\u003c/code\u003e) 的路径\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Pipe\u003c/code\u003e 的 \u003ccode\u003e.path\u003c/code\u003e/\u003ccode\u003e.IO\u003c/code\u003e 返回一个 \u003ccode\u003eIO::Path\u003c/code\u003e 类型对象\u003c/li\u003e\n\u003cli\u003e如果目的路径和源路径是一样的 \u003ccode\u003eIO::Path\u003c/code\u003e 的 \u003ccode\u003e.copy\u003c/code\u003e/\u003ccode\u003e.move\u003c/code\u003e 会 \u003ccode\u003efail\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edir\u003c/code\u003e 创建的 \u003ccode\u003eIO::Path\u003c/code\u003e 绝对性由调用者控制\u003c/li\u003e\n\u003cli\u003e更多定义的边缘行为、\u003ccode\u003eCallable \u003c/code\u003e 处理、\u003ccode\u003e. defined\u003c/code\u003e 调用, 以及 \u003ccode\u003e\u0026amp;infix:\u0026lt;andthen\u0026gt;\u003c/code\u003e、\u003ccode\u003e\u0026amp;infix:\u0026lt;orelse\u0026gt;\u003c/code\u003e 和 \u003ccode\u003e\u0026amp;infix:\u0026lt;notandthen\u0026gt;\u003c/code\u003e 操作符的链接\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSeq\u003c/code\u003e 的禅切不缓存它们\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eList.Capture\u003c/code\u003e 将任何包含的 \u003ccode\u003ePair\u003c/code\u003e 对象的键字符串化\u003c/li\u003e\n\u003cli\u003e带处理的 \u003ccode\u003eFailure\u003c/code\u003e 参数的 \u003ccode\u003e\u0026amp;fail\u003c/code\u003e 把它标记为是未处理的\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003euse lib\u003c/code\u003e 接受 \u003ccode\u003eIO::Path\u003c/code\u003e 对象\u003c/li\u003e\n\u003cli\u003e锚点 \u003ccode\u003e^\u003c/code\u003e、\u003ccode\u003e^^\u003c/code\u003e、\u003ccode\u003e$\u003c/code\u003e 和 \u003ccode\u003e$$\u003c/code\u003e 在环视中有效\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGrammar.made\u003c/code\u003e 支持类型对象\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.isa\u003c/code\u003e 支持 \u003ccode\u003esubset \u003c/code\u003e 类型对象\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e:delete\u003c/code\u003e 可用于惰性数组\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;infix:\u0026lt;eqv\u0026gt;\u003c/code\u003e 可以在某些情况下对惰性参数起作用\u003c/li\u003e\n\u003cli\u003e动态查询(\u003ccode\u003e::(...)\u003c/code\u003e) 是限制性的 regex 语法, 并且需要 \u003ccode\u003euse MONKEY-SEE-NO-EVAL\u003c/code\u003e 的许可\u003c/li\u003e\n\u003cli\u003e定义了带孔数组的 \u003ccode\u003e.Slip\u003c/code\u003e 和 \u003ccode\u003e.List\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePromise.in\u003c/code\u003e/\u003ccode\u003e.at\u003c/code\u003e 和 \u003ccode\u003eSupply.interval\u003c/code\u003e 可以用零值和负值工作\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSupply.interval\u003c/code\u003e 最小值为 \u003ccode\u003e0.001\u003c/code\u003e；较低值被处理为 \u003ccode\u003e0.001\u003c/code\u003e, 并发出警告#, 参见 \u003ca href=\"https://github.com/Raku/doc/pull/2649\"\u003ehttps://docs.perl6.org/type/Supply#method_interval PR [#2649]\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSupply\u003c/code\u003e 提供了 \u003ccode\u003e.Seq\u003c/code\u003e、\u003ccode\u003e.list\u003c/code\u003e 和 \u003ccode\u003e.zip\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e可以在构建方法中绑定到原生类型属性\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eWhateverCode\u003c/code\u003e 传播 \u003ccode\u003euse fatal\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esay\u003c/code\u003e、\u003ccode\u003enote\u003c/code\u003e、\u003ccode\u003eput\u003c/code\u003e、\u003ccode\u003eprint\u003c/code\u003e 和 \u003ccode\u003eprintf\u003c/code\u003e 例程自动线程化 \u003ccode\u003eJunction\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Handle.eof\u003c/code\u003e 值在 \u003ccode\u003e.seek\u003c/code\u003e 过终点后再返回时也会相应改变\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003e.succ'、\u003c/code\u003e.pred\u003ccode\u003e和\u003c/code\u003e.Bool` 的同质异形体\u003c/li\u003e\n\u003cli\u003e在核心 \u003ccode\u003eNumeric\u003c/code\u003e 上定义了 \u003ccode\u003e.Bridge\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cdel\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e在核心 \u003ccode\u003eNumeric\u003c/code\u003e 的类型对象上定义了 \u003ccode\u003e.Numeric\u003c/code\u003e/\u003ccode\u003e.Real\u003c/code\u003e\u003c/del\u003e\u003c/li\u003e\n\u003cli\u003e定义了关于零分母有理数的 \u003ccode\u003eRational.Bool\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esay\u003c/code\u003e/\u003ccode\u003enote\u003c/code\u003e 保证在 \u003ccode\u003eStr\u003c/code\u003e 的子类上调用 \u003ccode\u003e.gist\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003eJunction.Str\u003c/code\u003e 返回 \u003ccode\u003eJunction\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003eJunction.gist\u003c/code\u003e/\u003ccode\u003e.perl\u003c/code\u003e 返回一个 \u003ccode\u003eStr\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMap\u003c/code\u003e/\u003ccode\u003eHash\u003c/code\u003e 的 \u003ccode\u003e.list\u003c/code\u003e/\u003ccode\u003e.cache\u003c/code\u003e 返回一个 \u003ccode\u003eList\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003e.round\u003c/code\u003e 的返回类型\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003eEnumeration:D\u003c/code\u003e  不  \u003ccode\u003e.ACCEPT\u003c/code\u003e 一个 \u003ccode\u003eEnumeration:U\u003c/code\u003e , 参见 \u003ca href=\"https://github.com/rakudo/rakudo/issues/2073\"\u003erakudo/rakudo#2073\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"杂项\"\u003e杂项\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eIO::ArgFiles\u003c/code\u003e 类型只是 \u003ccode\u003eIO::CatHandle\u003c/code\u003e 的一个空的子类\u003c/li\u003e\n\u003cli\u003e对常量的约束\n\u003cul\u003e\n\u003cli\u003e约束是完全强制的\u003c/li\u003e\n\u003cli\u003e试图在常量上使用参数化类型约束(例如使用 \u003ccode\u003emy Foo constant @int\u003c/code\u003e) 会引发 \u003ccode\u003eX::ParametricConstant\u003c/code\u003e 异常\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePod\u003c/code\u003e \u003ccode\u003e=defn\u003c/code\u003e(定义列表)指令可用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePod\u003c/code\u003e 提供了 \u003ccode\u003e:numbered\u003c/code\u003e 配置键\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.^ver\u003c/code\u003e、\u003ccode\u003e.^auth\u003c/code\u003e 和 \u003ccode\u003e.^name\u003c/code\u003e 元方法在 \u003ccode\u003emodule\u003c/code\u003e 中可用, 而在 \u003ccode\u003epackage\u003c/code\u003e 中则没有, 这是设计上的原因\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eqww\u0026lt;…\u0026gt;\u003c/code\u003e 中支持花哨的引号(\u003ccode\u003e’…’\u003c/code\u003e、\u003ccode\u003e“…”\u003c/code\u003e、\u003ccode\u003e｢…｣\u003c/code\u003e 和变体)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;infix:\u0026lt; \u0026gt;\u003c/code\u003e 支持查找自动生成的 \u003ccode\u003eCallables\u003c/code\u003e (例如: \u003ccode\u003e\u0026amp;infix:\u0026lt;XX\u0026gt;\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e使用命名的 \u003ccode\u003eanon\u003c/code\u003e 子例程不再产生重声明警告\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e::?MODULE\u003c/code\u003e/\u003ccode\u003e$?MODULE\u003c/code\u003e 变量的扩展规范\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esub MAIN\u003c/code\u003e 可以接受一个参数上的 \u003ccode\u003eEnumeration\u003c/code\u003e 类型约束和 \u003ccode\u003ewhere\u003c/code\u003e 子句\u003c/li\u003e\n\u003cli\u003e笑脸型约束可以用在子集上\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estart\u003c/code\u003e 块和 thunks 得到新的 \u003ccode\u003e$/\u003c/code\u003e 和 \u003ccode\u003e$!\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e定义了与列表关联运算符一起使用的 \u003ccode\u003eR\u003c/code\u003e 元运算符\u003c/li\u003e\n\u003cli\u003e类型强转可以用在签名返回类型约束中\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;infix:\u0026lt;x\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;infix:\u0026lt;x\u0026gt;\u003c/code\u003e 抛出了 \u003ccode\u003e-Inf\u003c/code\u003e/\u003ccode\u003eNaN\u003c/code\u003e 重复参数\u003c/li\u003e\n\u003cli\u003e字面结构 \u003ccode\u003eput\u003c/code\u003e 和 \u003ccode\u003eput for\u003c/code\u003e 抛出, 需要使用括号\u003c/li\u003e\n\u003cli\u003e扩大了 Unicode 例程和功能的规范覆盖面-将覆盖面升级到 Unicode 第11版\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$.\u003c/code\u003e 方法调用语法能用在元方法中了\u003c/li\u003e\n\u003c/ul\u003e\n","text":"问题 在 6.d 版本中, 很多东西都发生了变化, 我们至少需要发布一个版本。这里有个列表。然而, 覆盖面是不完整的。弃用通知采取了不同的形式, 一些新的类型和方法在那里, 一些则没有\u0026hellip;\u0026hellip;\n用 #2632 引用这个问题, 并检查项目, 当你的工作, 无论是通过改变后的文档, 看到没有变化, 需要做它。在这种情况下, 请通过评论或如何解释为什么是这种情况。\n版本控制的变更  [6.d] \u0026amp;await 在等待的时候不再阻塞线程 [6.d] whenever 不在 react 抛出的词法作用域内 [6.d] 在 sub MAIN 里面的 $*ARGFILES 总是由 $*IN 馈入 [6.d] 结构(字面上的) $()、@() 和 %() 不复存在 [6.d] 带有 :D/:U 类型约束的变量默认为约束类型的类型对象(例如, 你可以在它们身上使用 .new) [6.d] start 块在 sink 上下文中附加异常处理程序 ~~**[6.d]** 例程必须使用 return-rw 来返回一个 Proxy, 即使例程被标记为 is raw 或 is rw~~ [6.d] 原生的 num 类型默认为 0e0 而不是 NaN [6.d] 在子程序名中, 保留了键名为 sym 的冒号对（如:sym\u0026lt;foo\u0026gt;）, 以备将来使用  废弃 这些方法在 6.d 语言中已被废弃, 并将在 6.e 中被删除。实现者可以选择发出弃用警告, 或者在 6.e 版本发布后更长的时间内提供这些方法。\n 使用 '-' (单连字符)作为 \u0026amp;open 的特殊路径, 表示特殊的句柄(使用 IO::Special 对象代替) IO::Handle.slurp-rest (使用 .slurp 代替) Any.flatmap (使用.flat 和 .map 方法的组合来代替) Cool.path (使用 .IO 代替) Pair.freeze (使用去容器化的参数的 Pair.new 来代替) Str.subst-mutate (使用带有 .= 方法调用赋值元运算符的 Str.subst 代替) Rational.norm (现在 Rational 类型必须在创建时标准化) IO::Path.child (使用 .add 代替) \u0026amp;undefine (直接分配 Empty/Nil 代替) :count \u0026amp;lines/Str.lines 例程上的参数(使用所返回的 Seq 上的 .elems 代替) \u0026amp;is_approx in Test.pm6 (使用与 \u0026amp;is-approx 非常相似的行为来代替)  新的行为  通过新的可定义的 \u0026amp;RUN-MAIN、\u0026amp;ARGS-TO-CAPTURE 和 \u0026amp;GENERATE-USAGE 子例程改善 sub MAIN 的自定义处理 % 变量中的 QuantHash/Map 和 @ 变量中的 List 可以用 is 特性来声明（例如，my %h is Set） 新的 \u0026lt;ww\u0026gt; regex 规则: 只在单词内匹配 循环可以从上一条语句的值中产生一个值的列表 循环中的 next/last 收集其最后的语句值, 对它们运行的迭代返回 Empty .perl 可以在消耗过的 Seq、多维数组、Date 和 CallFrame 上调用 .gist 可以在 Attribute 上调用 对自动生成的 USAGE 信息进行了大量改进 is hidden-from-USAGE 特性，从自动生成的 USAGE 消息中隐藏 sub MAIN 候选者 Parameter.perl 包括可内省的默认值 %*ENV 值是同素异形的 尝试使用变量 $;、$,、$.、$\\、$(、$)、$\u0026lt;、$\u0026gt;、$/、$\\、$[、$-、$+ 和 $@ 会抛出 X::Syntax::Perl5Var 默认的 Hash.keyof 返回一个 Str(Any) 强转类型对象 非 ASCII 数字可以在 :42foo 冒号对快捷方式中使用 StrDistance 字符串化为 .after 字符串 更明确的 Pod 表格格式 Enumeration.enums 返回一个 Map 各种整数类型的 .Range 返回它们支持的值的范围 min/max 例程也适用于 Hash Signature 字面值可以包含字符串/数字字面值以及调用者标记 List.invert 通过所需的 Pair 绑定映射, 导致潜在的类型检查失败 :exists 可以与多维关联下标一起使用 动态创建的列表可以用来定义一个枚举 在 .first 中, Junction 可以作为匹配器使用 原生属性可以作为参数中的绑定目标 Proc 可以与其他 Proc 中的 IO::Pipe 一起工作 类型数组可以用 my SomeType @array 和 my @array of SomeType 创建 当把 Mixy 强转为 Setty/Baggy  时, 负数权重的项将被删除 :nth 副词在 m// 上接受一个 Junction 作为参数 CX::Warn' 和 CX::Done可以在CONTROL` phaser 中捕获 next 可用于 whenever 中 require 符号不再过境性地暴露出来 通过 {...} 进行多维访问, 类似于 [...] 的工作方式 在 END 时间打开的任何手柄都会自动关闭 在缓存的 Seq 上, 当 \u0026amp;infix:\u0026lt;eqv\u0026gt;、.Slip、.join、.List、.list、.eager、.Array 和 .is-lazy 被调用时, 就会使用缓存列表 IO::Handle.encoding 以 Nil 表示切换到二进制模式 is default 特质与属性一起工作 在多重分派中, 带有 is rw 特性的参数被认为比没有特性的参数窄 Array、Blob 和 Map 的 .gist 被裁剪成100个元素 新的 for 语句修饰符 hyper for、race for 和 lazy for for 循环自动序列化 RaceSeq/HyperSeq；使用新的 for 语句修饰符hyper for/race for避免 \u0026amp;infix:\u0026lt;does\u0026gt; 可用于 RHS 上的非组合实例 数值比较器可以与 DateTime  对象一起使用 Pod 保留空白类型 定义了带 @、% 和 \u0026amp; 魔符常数的语义  Math  Rational 总是在创建时被化简, 并在其一生中保持不变 Inf、Inf 和 NaN 可以分别用 \u0026lt;-1/0\u0026gt;、\u0026lt;1/0\u0026gt; 和 \u0026lt;0/0\u0026gt; 表示, 通过Rational 类型进行舍去。零分母 Rational 被标准化为这三个值之一 在 ±Inf 和 NaN 上调用 .Int, 会抛出异常 改进了 Num 运算符和数学函数的 IEEE 754-2008 合规性 负零 Num(-0e0)被所有例程和语法结构正确处理 Num 类型的字符串化必须是可舍弃到原始 Num 的 定义了涉及零的 Complex  指数 .expmod 中的负数幂有效  Sets、Bags、Mixes(aka QuantHashes)和集合运算符  Set 运算符可以用在任何对象上, 在需要的时候会被强转  所以, 不需要也不希望有任何预先的强转 如果没有 QuantHash 就能实现所需的功能, 那么 Set 运算符可以自由地不创建任何 QuantHash   对不同类型的 QuantHashes 的 Set 操作将强转到最自由的形式（Set -\u0026gt; Bag -\u0026gt; Mix） 集合运算符的 set_precedes 家族( (\u0026lt;+)、≼、(\u0026gt;+)、≽) 已被移除  曾经是子集运算符的 Baggy 形式 QuantHash 升级为最自由的形式, 所以 (\u0026lt;=)、⊆、(\u0026gt;=)、⊇ 做正确的事情   .classify-list 方法可用于 Baggy 类型 .categorize-list 方法可用于 Baggy 类型 .invert 方法可用于核心 QuantHash 类型 .antipairs 方法可用于 QuantHash 类型 QuantHash 类型有 .new-from-pairs 和将一个 QuantHash 类型转换为另一个 QuantHash 类型的方法(例如 Set 类型的 .Bag 方法) QuantHash 类型上的 .hash 对键值进行了字符串化  新的形参和实参  Date.new 接受一个 :\u0026amp;formatter .first 可以接受 :kv unique 和 .repeated 可以接受 :\u0026amp;as 和 :\u0026amp;with Test.pm6 中的 \u0026amp;plan 可以接受 :skip-all \u0026amp;run/\u0026amp;shell 可以接受 :merge \u0026amp;note 可以在没有参数的情况下调用 open 接受 :$out-buffer IO::Path.resolve 可以接受 :completely IO::Path.parent 可以接受一个 Int 表示父级 Proc::Async.new 吞噬位置参数 Signature.ACCEPTS 接受非 Signature/Capture 参数 \u0026amp;EVAL 可以接受一个 Blob Promise.keep/.break 可以在没有参数的情况下调用 原生数组上的 .sum 可以接受 :wrap is required 现在可以接受一个表示理由的参数 IO::Socket::Async.listen 可以绑定到端口 0 以向操作系统申请免费端口 .encode 可以接受 :translate-nl  新的例程和运算符  新的 atomicint Unicode 运算符和 ASCII 等价物, 保证线程安全, 原子操作: \u0026amp;infix:\u0026lt;⚛=\u0026gt;/\u0026amp;atomic-assign、\u0026amp;prefix:\u0026lt;⚛\u0026gt;/\u0026amp;atomic-fetch、 \u0026amp;prefix:\u0026lt;++⚛\u0026gt;/\u0026amp;atomic-inc-fetch、\u0026amp;postfix:\u0026lt;⚛++\u0026gt;/\u0026amp;atomic-fetch-inc、 \u0026amp;prefix:\u0026lt;--⚛\u0026gt;/\u0026amp;atomic-dec-fetch、\u0026amp;postfix:\u0026lt;⚛--\u0026gt;/\u0026amp;atomic-fetch-dec、 \u0026amp;infix:\u0026lt;⚛-=\u0026gt;/\u0026amp;infix:\u0026lt;⚛−=\u0026gt;/\u0026amp;atomic-fetch-sub 和 \u0026amp;infix:\u0026lt;⚛+=\u0026gt;/\u0026amp;atomic-fetch-add \u0026amp;cas: 原子比较与交换 ≤、≥ 和 ≠ 运算符是 Unicode 运算符, 分别等价于 \u0026lt;=、\u0026gt;= 和 != \u0026amp;infix:\u0026lt;unicmp\u0026gt;/\u0026amp;infix:\u0026lt;coll\u0026gt;: \u0026amp;infix:\u0026lt;cmp\u0026gt; 的替代行为 TR///: tr/// 的非变异版本 submethod TWEAK: 与 BUILD 类似, 除了它与属性默认值兼容之外 \u0026amp;duckmap: 应用 \u0026amp;callable 到每个元素上 \u0026amp;deepmap: 应用 \u0026amp;callable 到每个元素上, 下降到 Iterable 中 \u0026amp;take-rw: 像 \u0026amp;take 一样, 但有一个可写的容器 \u0026amp;indir: 在给定的 $*CWD 中执行代码 \u0026amp;spurt: 参见 IO::Path.spurt \u0026amp;prompt: 提示用户输入 uniprops: uniprop 的多字符版本 symlink: 建立文件符号链接 link: 创建文件硬连接 .hyper/.race: 并行处理值的列表 Seq.from-loop: 从 Callable 生产一个 Seq Str.uniparse: 将一个或多个 Unicode 字符名解析为实际字符 Str.parse-base: Int.base 操作的反转 IO::Path 提供了 .ACCEPTS、.SPEC、.CWD、.Numeric、.add、.extension、.mode 和各种文件测试、.parts、.sibling 和 .spurt IO::Handle 提供了 .READ、.WRITE、.EOF、.DESTROY, .readchars、.flush、.lock、.unlock、.out-buffer、.tell, .say、.slurp、.seek、.printf、.print-nl 和 .watch IO::Pipe 提供了 .proc Iterator 提供了 .skip-one、.skip-at-least 和 .skip-at-least-pull-one Mu.emit: \u0026amp;emit 的方法形式 Test.pm6 模块中的 \u0026amp;fails-like: 允许测试失败 Test.pm6 模块中的 \u0026amp;bail-out: 退出失败的测试套件 Test.pm6 模块中的 \u0026amp;is-approx: 测试一个数字近似于另一个 Buf 拥有 .allocate、.reallocate、.append、.push、.pop、.splice、.subbuf-rw、.prepend 和 .unshift 方法 Range 支持了 .rand Backtrace 拥有方法 .map、.flat、.concise 和 .summary .classify-list 方法可用于 Hash 类型 .categorize-list 方法可用于 Hash 类型 Code.of: 返回返回类型约束 Code.line/.file: 返回定义的行/文件 Proc::Async 提供了 .Supply、.ready、.pid、.bind-stdin、.bind-stdout 和 .bind-stderr Proc.command/Proc::Async.command: 我们要执行的命令 Proc 提供了 .signal、.pid 和 .encoding Complex 提供了 .cis、.reals、.ceiling、.floor、.round、.truncate 和 .abs 方法, 并可以使用 \u0026lt;=\u0026gt; 进行比较(只要虚部可以忽略不计) DateTime 提供了 .offset-in-hours、.hh-mm-ss 和 .Date DateTime 可以使用 \u0026lt;=\u0026gt; 运算符和其它 DateTime 对象进行比较 Date 提供了 .DateTime 方法 \u0026amp;infix:\u0026lt;+\u0026gt;/\u0026amp;infix:\u0026lt;-\u0026gt; 可以被 Duration、DateTime 和 Real 类型调用 Enumeration 提供了 .Int、.pred、.succ、.kv 和 .pair .Date 可以在 Instant 上调用 Junction 能使用 Junction.new 调用来创建 List 类型拥有 .to 和 .from 方法 Map type 提供了 Int 方法, 返回 pair 的数量 Any.skip: 跳过列表中的值 Any.batch: .rotor 的更基本的表兄弟 Mu.iterator: 为一个列表中的值生成一个 Iterator IO::Spec::* 类型提供了 .tmpdir、.extension 和 .path Pair 提供了 .ACCEPTS、.Pair 和 .invert .Capture 方法对所有核心类型都有明确定义 定义了 .ACCEPTS 在同素异形体上的语义 Failure.self 使未处理的 Failure 爆发 Thread.is-initial-thread: 我们是在初始线程中运行吗 Match 提供了 .Int 和 .actions IO::Socket::Async 提供了 .socket-port 和 .peer-port Promise 提供了另一种构造函器 .kept 和 .broken WhateverCode 提供了 .assuming WhateverCode 和 Block 提供了 .cando .:\u0026lt;…\u0026gt; 语法用于调用前缀运算符作为后缀 $*KERNEL 提供了 .hostname Nil 拥有定义的 .FALLBACK 特殊方法来返回 Nil  新类型  atomicint: 原生的 int, 大小可用于新的原子运算符 Lock::Async: 互斥的非阻塞机制 Encoding::Registry: 管理可用的编码 Encoding::Encoder: 编码器, 用于特定的编码 Encoding::Decoder: 解码器, 用于特定的编码 IO::CatHandle: 将多个只读的 IO::Handle 视同一个 原生的 str 数组 Supplier::Preserving: 缓存的实时 Supply 工厂 Semaphore: 控制多线程对共享资源的访问 IO::Special: 特殊I/O设备的路径 (例如 STDOUT) Exceptions::JSON 自定义异常处理程序的实现(可与PERL6_EXCEPTIONS_HANDLER 环境变量一起使用) SeekType 枚举: IO::Handle.seek 中使用的值  新的变量   $*USAGE: 可在 MAIN 子例程中使用, 包含自动生成的 USAGE 信息\n  %*SUB-MAIN-OPTS: 设置 sub MAIN 的行为\n %*SUB-MAIN-OPTS\u0026lt;named-anywhere\u0026gt; 允许将命名参数放在命令行的任何位置    $*COLLATION: 配置四个 Unicode 校对级别\n  $*INIT-INSTANT: 代表程序启动时间的 Instant\n  $*HOME: 用户的主目录, 如果存在的话\n  \u0026amp;*chdir: Callable 包含 IO::Path.chdir 的变体, 也设置进程的当前目录\n  PERL6_TEST_DIE_ON_FAIL 环境变量: 在第一次失败时停止测试套件\n  PERL6_EXCEPTIONS_HANDLER 环境变量: 指定自定义异常处理类\n  对边缘情况/强转行为的澄清  UInt 与 Int 类型对象智能匹配为 True sink 语句前缀爆炸 Failure 定义了1项和0项列表以及负参数和非整数参数的 permutations/combinations 的行为 \u0026amp;val、Str.Numeric 和其他 Str 数字转换方法在试图转换 Unicode No 字符组或合成数字时会 fail :42foo 冒号对快捷方式中不能使用合成数字 现在、Enumeration 可以作为一个数组形状指定器使用 含有空格的 Str 的数值转换现在返回 0 带空的模式参数的 samark, 简单地返回调用者 .polymod 可用于 lazy 但有限的除数列表 定义了 .[*-0] 索引 .rotor 中大于子列表的负数空隙抛出异常 .rotor 的非 Int 参数被强转为 Int 参数 读取 /proc 文件时定义了 .lines 定义了字符串上后缀/前缀 ++/-- 中泰语数字的行为 sunk for 里面的 map 被视为 sunk Sunk for 循环将上一条语句的方法调用值下沉 Bool 对象上的 .Int 返回一个 Int 对象 splice 可用于扩展数组 classify 可以与 Junction 配合使用 .pairup on a type object returns an empty Seq .pairup 总是返回一个 Seq 拒绝接受 Date/DateTime 构造函数中的合成代码点 ⸨/⸩ 对儿现在可以作为引号结构中的匹配字符使用 Array 类型对象上的 .flat 简单地返回该类型对象 混合级 classify 在 Hash 上抛出异常 Junction 可以用于给 Hash 指定多个键 给 .classify-list 的 Callable 现在保证每项只执行一次 :delete 对 Hash 类型对象进行关联查找时返回 Nil Test.pm6 中的 \u0026amp;is-deeply 会自动 .cache 作为参数的 Seq, 并使用返回的 List 进行测试 Complex.new() 给出 \u0026lt;0+0i\u0026gt; Int.new 现在可以保证构建一个新的 Int (而不是, 比如说, 从常量缓存中重用一个) 定义了一个参数(1-arg)版本的 \u0026amp;infix:\u0026lt;=:=\u0026gt; 和 \u0026amp;infix:\u0026lt;eqv\u0026gt; 如果直接或间接地调用 .BIND-POS、.BIND-KEY、.ASSIGN-POS、.ASSIGN-KEY、.STORE、.push、.append、.unshift、.prepend、Nil 类型现在抛出异常 Nil.ord 返回一个空的 Seq Nil.chrs 返回一个 \u0026quot;\\0\u0026quot; Num.new 强转参数为 Num infix:\u0026lt;Z\u0026gt;() 返回一个空的 Seq .comb 总是返回一个 Seq 用 \u0026amp;infix:\u0026lt;+\u0026gt; 化简一个项, 简单地返回该项 ()[0] 返回 Nil 允许在(可能是无限的) Seq 上使用 Regex 智能匹配 定义了 Range 对象的智能匹配 Set 转换为Mix/Bag 不再有 Bool 权重 当一个或多个操作数为 0 时、gcd 是有定义的 defined 例程中的 Junction 自动线程化 sum 可以处理含有 Junction 的列表 Grammar.parse 让顶级 regex 回溯 U+2212 MINUS SIGN [Sm] (-) 现在得到更多结构的支持, 如 Str.Numeric 和 \u0026amp;val Arity-1 \u0026amp;infix:\u0026lt;~\u0026gt; 与 Blob 可以一起工作 在签名中, 所有的 Numeric 字面值都支持作为值字面值 正则表达式中的 \\b 和 \\B 抛出 X::Obsolete True 和 False 作为签名中的值字面量发出警告 .sort 和 IO::Spec::Unix.path 的返回值总是 Seq Range 对象上的 Out-of-range .AT-POS 返回 Nil 对于不存在的键、Pair.AT-KEY 返回 Nil 所有的 Cool 类型都提供了 .Rat/.FatRat 强转器 IO::Path 文件测试不缓存先前测试执行的结果 Seq eqv List 仅根据类型不匹配就定为 False 在 Hash 、Hash  和 QuantHash 上, 来自 .kv、.values 和 .pair 序列的值是可写的 参见 Raku/roast#614 和 #3519 \u0026amp;infix:\u0026lt;∘\u0026gt;/\u0026amp;infix:\u0026lt;o\u0026gt; 保留 LHF 的 .of 和 RHS 的 .arity 和 .count 完善了 regex 运算符副词中的可接受参数(例如::in(…)) 完善了 IO::Handle.open 中可接受的参数组合 IO::Path.Str 不包含 .CWD 属性的值 IO::Path 类型拒绝带有 nul 字节 (\u0026quot;\\0\u0026quot;) 的路径 IO::Pipe 的 .path/.IO 返回一个 IO::Path 类型对象 如果目的路径和源路径是一样的 IO::Path 的 .copy/.move 会 fail dir 创建的 IO::Path 绝对性由调用者控制 更多定义的边缘行为、Callable  处理、. defined 调用, 以及 \u0026amp;infix:\u0026lt;andthen\u0026gt;、\u0026amp;infix:\u0026lt;orelse\u0026gt; 和 \u0026amp;infix:\u0026lt;notandthen\u0026gt; 操作符的链接 Seq 的禅切不缓存它们 List.Capture 将任何包含的 Pair 对象的键字符串化 带处理的 Failure 参数的 \u0026amp;fail 把它标记为是未处理的 use lib 接受 IO::Path 对象 锚点 ^、^^、$ 和 $$ 在环视中有效 Grammar.made 支持类型对象 .isa 支持 subset  类型对象 :delete 可用于惰性数组 \u0026amp;infix:\u0026lt;eqv\u0026gt; 可以在某些情况下对惰性参数起作用 动态查询(::(...)) 是限制性的 regex 语法, 并且需要 use MONKEY-SEE-NO-EVAL 的许可 定义了带孔数组的 .Slip 和 .List Promise.in/.at 和 Supply.interval 可以用零值和负值工作 Supply.interval 最小值为 0.001；较低值被处理为 0.001, 并发出警告#, 参见 https://docs.perl6.org/type/Supply#method_interval PR [#2649] Supply 提供了 .Seq、.list 和 .zip 可以在构建方法中绑定到原生类型属性 WhateverCode 传播 use fatal say、note、put、print 和 printf 例程自动线程化 Junction IO::Handle.eof 值在 .seek 过终点后再返回时也会相应改变 定义了 .succ'、.pred和.Bool` 的同质异形体 在核心 Numeric 上定义了 .Bridge 在核心 Numeric 的类型对象上定义了 .Numeric/.Real 定义了关于零分母有理数的 Rational.Bool say/note 保证在 Str 的子类上调用 .gist 定义了 Junction.Str 返回 Junction 定义了 Junction.gist/.perl 返回一个 Str Map/Hash 的 .list/.cache 返回一个 List 定义了 .round 的返回类型 定义了 Enumeration:D 不 .ACCEPT 一个 Enumeration:U , 参见 rakudo/rakudo#2073  杂项  IO::ArgFiles 类型只是 IO::CatHandle 的一个空的子类 对常量的约束  约束是完全强制的 试图在常量上使用参数化类型约束(例如使用 my Foo constant @int) 会引发 X::ParametricConstant 异常   Pod =defn(定义列表)指令可用 Pod 提供了 :numbered 配置键 .^ver、.^auth 和 .^name 元方法在 module 中可用, 而在 package 中则没有, 这是设计上的原因 qww\u0026lt;…\u0026gt; 中支持花哨的引号(’…’、“…”、｢…｣ 和变体) \u0026amp;infix:\u0026lt; \u0026gt; 支持查找自动生成的 Callables (例如: \u0026amp;infix:\u0026lt;XX\u0026gt;) 使用命名的 anon 子例程不再产生重声明警告 ::?MODULE/$?MODULE 变量的扩展规范 sub MAIN 可以接受一个参数上的 Enumeration 类型约束和 where 子句 笑脸型约束可以用在子集上 start 块和 thunks 得到新的 $/ 和 $! 定义了与列表关联运算符一起使用的 R 元运算符 类型强转可以用在签名返回类型约束中 \u0026amp;infix:\u0026lt;x\u0026gt;/\u0026amp;infix:\u0026lt;x\u0026gt; 抛出了 -Inf/NaN 重复参数 字面结构 put 和 put for 抛出, 需要使用括号 扩大了 Unicode 例程和功能的规范覆盖面-将覆盖面升级到 Unicode 第11版 $. 方法调用语法能用在元方法中了  "},"name":"Checklist for Raku 6.d","published":"2020-07-21T00:00:00+08:00","summary":"Checklist for 6.d","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-07-21-checklist-for-6-dot-d/"}],"name":"raku","type":"feed","url":"https://ohmyweekly.github.io/tags/raku/"}