{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"children":[{"content":{"html":"\u003cp\u003e在我的上一篇文章中，我又一次为从 CORE 中增强类的方法而苦恼。这种挣扎完全没有必要，因为我并没有用增加的方法改变对象的状态。对于做更高级的东西，我可能不得不这样做。把手伸进 Raku 的内部这么深，我可能会把自己烫伤。既然我想做的是把我的代码绑在编译器的变化上，反正我可能会全身心地投入到 nqp-land 中去。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \\j = 1 | 2 | 3;\ndd j;\nuse nqp;\n.say for nqp::getattr(j, Junction, '$!eigenstates');\n# OUTPUT: any(1, 2, 3)\n          1\n          2\n          3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们可以使用 nqp 来获取私有属性，而不需要添加任何方法。这就有点儿不伦不类了。所以，让我们用一个伪方法来做一些 deboilerplating。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub pry(Mu $the-object is raw) {\n    use InterceptAllMethods;\n\n    class Interceptor {\n        has Mu $!the-object;\n        method ^find_method(Mu \\type, Str $name) {\n            my method (Mu \\SELF:) is raw {\n                use nqp;\n                my $the-object := nqp::getattr(SELF, Interceptor, '$!the-object');\n                nqp::getattr($the-object, $the-object.WHAT, '$!' ~ $name)\n            }\n        }\n    }\n\n    use nqp;\n    nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object);\n}\n\n.say for j.\u0026amp;pry.eigenstates;\n# OUTPUT: 1\n          2\n          3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通过 InterceptAllMethods，lizmat 改变了类关键字的行为，允许我们提供一个 FALLBACK-method 来捕获任何方法，包括从 Mu 继承的方法。这反过来又允许 pry 返回的对象将任何方法调用转移到一个自定义的方法。在这个方法中，我们可以对 \u003ccode\u003e.\u0026amp;pry\u003c/code\u003e 被调用的对象做任何我们想做的事情。\u003c/p\u003e\n\u003cp\u003e由于我们的特殊对象会拦截任何调用，甚至是 Mu 的调用，我们需要找到另一种方法来调用 \u003ccode\u003e.new\u003c/code\u003e。由于 \u003ccode\u003e.^\u003c/code\u003e 不是 \u003ccode\u003e.\u003c/code\u003e 的特殊形式，我们可以用它来获得对类方法的访问。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub interceptor(Method $the-method){\n    use InterceptAllMethods;\n    use nqp;\n\n    sub (Mu $the-object is raw) {\n        my class Interceptor {\n            has Mu $!the-object;\n            has Code $!the-method;\n\n            method ^find_method(Mu \\type, Mu:D $name) {\n                my method (Mu \\SELF: |c) is raw {\n                    $!the-method.($!the-object, $name, |c)\n                }\n            }\n            method ^introspect(Mu \\type, Mu \\obj) {\n                my method call-it() is raw {\n                    $!the-object\n                }\n                obj.\u0026amp;call-it;\n            }\n            method ^new(Mu \\type, $the-object!, $the-method) {\n                nqp::p6bindattrinvres(\n                        nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object),\n                        Interceptor, '$!the-method', $the-method)\n            }\n        }\n\n            # nqp::p6bindattrinvres(\n                #     nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object),\n                #   Interceptor, '$!the-method', $the-method);\n        Interceptor.^new($the-object, $the-method)\n    }\n}\n\nmy \u0026amp;first-defined = interceptor(\n    my method (Positional \\SELF: $name) {\n        for SELF.flat -\u0026gt; $e {\n            with $e.\u0026quot;$name\u0026quot;(|%_) {\n                .return\n            }\n        }\n        Nil\n    }\n);\n\nmy $file = \u0026lt;file1.txt file2.txt file3.txt nohup.out\u0026gt;».IO.\u0026amp;first-defined.open(:r);\ndd $file;\n# OUTPUT: Handle $file = IO::Handle.new(path =\u0026gt; IO::Path.new(\u0026quot;nohup.out\u0026quot;, :SPEC(IO::Spec::Unix), :CWD(\u0026quot;/home/dex/projects/raku/tmp\u0026quot;)), chomp =\u0026gt; Bool::True, nl-in =\u0026gt; $[\u0026quot;\\n\u0026quot;, \u0026quot;\\r\\n\u0026quot;], nl-out =\u0026gt; \u0026quot;\\n\u0026quot;, encoding =\u0026gt; \u0026quot;utf8\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003esub \u003ccode\u003einterceptor\u003c/code\u003e 接受一个方法并返回一个 sub。如果这个 sub 像方法一样被调用，它将把要被调用的方法的名称和调用者转发给一个自定义方法。当 \u003ccode\u003e.\u0026amp;first-defined\u003c/code\u003e 被调用时，会返回一个特殊的对象。让我们来看看它是什么。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \\uhhh-special = \u0026lt;a b c\u0026gt;.\u0026amp;first-defined;\ndd uhhh-special.^introspect(uhhh-special);\n# OUTPUT: ($(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;), method \u0026lt;anon\u0026gt; (Positional \\SELF: $name, *%_) { #`(Method|93927752146784) ... })\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们必须给 \u003ccode\u003e.^introspect\u003c/code\u003e 一个我们想看的对象，因为它的调用者是类 Interceptor 的类型对象。\u003c/p\u003e\n\u003cp\u003e目前，我还不知道有什么办法（毕竟，我知道的只是足够多的东西，真的很危险。这是不幸的，因为 lizmat 决定重载关键字 \u003ccode\u003eclass\u003c/code\u003e，而不是用不同的名字导出特殊的 \u003ccode\u003eMetamodel::ClassHOW\u003c/code\u003e。如果我们不想或不能有外部依赖，我们可以使用 MOP 来创建我们的类型对象。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eclass InterceptHOW is Metamodel::ClassHOW {\n    method publish_method_cache(|) { }\n}\n\nsub ipry(Mu $the-object is raw) {\n    my \\Interceptor = InterceptHOW.new_type(:name\u0026lt;Interceptor\u0026gt;);\n    Interceptor.^add_attribute(Attribute.new(:name\u0026lt;$!the-object\u0026gt;, :type(Mu), :package(Interceptor)));\n    Interceptor.^add_meta_method('find_method',\n        my method find_method(Mu \\type, Str $name) {\n            # say „looking for $name“;\n            my method (Mu \\SELF:) is raw {\n                use nqp;\n                my $the-object := nqp::getattr(SELF, Interceptor, '$!the-object');\n                nqp::getattr($the-object, $the-object.WHAT, '$!' ~ $name)\n            }\n    });\n    Interceptor.^compose;\n\n    use nqp;\n    nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e当我写这篇文章的时候，我发现 \u003ccode\u003e.^add_meta_method\u003c/code\u003e 只有在提供给它的方法的第一个参数的名字和 \u003ccode\u003eStr\u003c/code\u003e 相同的时候才会工作。起初，我尝试了一个匿名方法，它最终出现在 \u003ccode\u003e.^meta_method_table\u003c/code\u003e 中，但从未被调用。我想这个 bug 其实并不重要，因为这个元方法根本没有被记录下来。如果我玩火，我没有权利抱怨烧伤。你会在野外的 \u003ccode\u003eActions.nqp\u003c/code\u003e 中发现这个方法。Class 关键字并没有什么神奇的作用。Rakudo 只是使用 MOP 来构造类型对象。\u003c/p\u003e\n\u003cp\u003e我们不能在 Raku 中重载赋值操作符。这其实并不需要，因为赋值是通过调用一个名为 STORE 的方法来实现的。由于我们得到了对 dispatch 的完全控制，我们可以拦截任何方法调用，包括一连串的方法调用。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emulti sub methodify(%h, :$deeply!) {\n    sub interceptor(%h, $parent = Nil){\n        use InterceptAllMethods;\n        use nqp;\n\n        class Interceptor is Callable {\n            has Mu $!the-object;\n            has Mu @!stack;\n\n            method ^find_method(Mu \\type, Mu:D $name) {\n                my method (Mu \\SELF: |c) is raw {\n                    my @new-stack = @!stack;\n                    my $the-object = $!the-object;\n\n                    if $name eq 'STORE' {\n                        # workaround for rakudobug#4203\n                        $the-object{||@new-stack.head(*-1)}:delete if $the-object{||@new-stack.head(*-1)}:exists;\n\n                        $the-object{||@new-stack} = c;\n                        return-rw c\n                    } else {\n                        @new-stack.push: $name;\n                        my \\nextlevel = SELF.^new($!the-object, @new-stack, $name);\n                        nextlevel\n                    }\n                }\n            }\n            method ^introspect(Mu \\type, Mu \\obj) {\n                my method call-it() is raw {\n                    $!the-object, @!stack\n                }\n                obj.\u0026amp;call-it;\n            }\n            method ^new(Mu \\type, $the-object!, @new-stack?, $name?) {\n                $name\n                    ?? nqp::p6bindattrinvres(\n                        nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object),\n                        Interceptor, '@!stack', @new-stack)\n                    !! nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object)\n                }\n        }\n\n        Interceptor.^new(%h)\n    }\n\n    interceptor(%h)\n}\n\nmy %h2;\nmy $o2 = methodify(%h2, :deeply);\n$o2.a.b = 42;\ndd %h2;\n$o2.a.b.c = \u0026lt;answer\u0026gt;;\ndd %h2;\nsay $o2.a.b.c;\n# OUTPUT: Hash %h2 = {:a(${:b(\\(42))})}\n          Hash %h2 = {:a(${:b(${:c(\\(\u0026quot;answer\u0026quot;))})})}\n          This type cannot unbox to a native string: P6opaque, Interceptor\n            in block \u0026lt;unit\u0026gt; at /home/dex/projects/raku/any-chain.raku line 310\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e每当我们调用一个方法时，都会创建一个新的 Interceptor 实例，它存储了前一个方法的名称。这样我们就可以沿着方法调用链移动。由于赋值调用 STORE，我们可以将赋值转移到我们用作实际数据结构的 Hash 中。唉，检索值就不一样了，因为 Raku 不区分方法调用和 FETCH。在这里，龙比我强。我还是包含了这个一半失败的尝试，因为我对 slippy 半列表有很好的利用。这需要使用 \u003ccode\u003ev6.e.preview\u003c/code\u003e，让我踩到了一个 bug。可能还有更多这样的情况。所以请使用同样的，这样我们就可以在 \u003ccode\u003e.e\u003c/code\u003e 发布到野外之前，把所有的野兽都杀掉。\u003c/p\u003e\n\u003cp\u003e能够完全控制方法调用链将是一件好事。也许我们可以用 RakuAST 来做到这一点。\u003c/p\u003e\n\u003cp\u003e有了这些已经可以工作的东西，我们可以做一些有趣的事情。那些烦人的异常总是在拖我们的后腿。我们可以用 \u003ccode\u003etry\u003c/code\u003e 来化解它们，但那会破坏一个方法调用链。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003econstant no-argument-given = Mu.new;\nsub try(Mu $obj is raw, Mu $alternate-value = no-argument-given) {\n    interceptor(my method (Mu \\SELF: $name, |c) {\n        my $o = SELF;\n        my \\m = $o.^lookup($name) orelse {\n            my $bt = Backtrace.new;\n            my $idx = $bt.next-interesting-index($bt.next-interesting-index + 1);\n            (X::Method::NotFound.new(:method($name), :typename($o.^name)) but role :: { method vault-backtrace { False }}).throw(Backtrace.new($idx + 1));\n        }\n\n        try {\n            $o = $o.\u0026quot;$name\u0026quot;(|c);\n        }\n \n        $! ~~ Exception\n            ?? $alternate-value.WHICH eqv no-argument-given.WHICH\n                ?? $o\n                !! $alternate-value\n            !! $o\n    }).($obj)\n}\n\nclass C {\n    has $.greeting;\n    method might-throw { die \u0026quot;Not today love!\u0026quot; }\n    method greet { say $.greeting }\n}\n\nC.new(greeting =\u0026gt; ‚Let's make love!‘).\u0026amp;try.might-throw.greet;\n# OUTPUT: Let's make love!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e伪方法 try 将会化解任何异常，并允许继续调用 C 语言的方法。我必须用一个特殊的值来标记没有可选的参数 \u003ccode\u003e$alternate-value\u003c/code\u003e，因为它实际上可能会把异常对象变成 \u003ccode\u003eNil\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e我很肯定还有很多这样的小帮手在等着我们去发现。未来可能会有一个模块，希望能帮助 Raku 成为一个好的\u003ca href=\"https://ftp.fau.de/fosdem/2021/D.perl/programming_lang_for_free_software.webm\"\u003e编程语言\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://gfldex.wordpress.com/2021/02/17/method-ish/\"\u003ehttps://gfldex.wordpress.com/2021/02/17/method-ish/\u003c/a\u003e\u003c/p\u003e\n","text":"在我的上一篇文章中，我又一次为从 CORE 中增强类的方法而苦恼。这种挣扎完全没有必要，因为我并没有用增加的方法改变对象的状态。对于做更高级的东西，我可能不得不这样做。把手伸进 Raku 的内部这么深，我可能会把自己烫伤。既然我想做的是把我的代码绑在编译器的变化上，反正我可能会全身心地投入到 nqp-land 中去。\nmy \\j = 1 | 2 | 3; dd j; use nqp; .say for nqp::getattr(j, Junction, '$!eigenstates'); # OUTPUT: any(1, 2, 3) 1 2 3 我们可以使用 nqp 来获取私有属性，而不需要添加任何方法。这就有点儿不伦不类了。所以，让我们用一个伪方法来做一些 deboilerplating。\nsub pry(Mu $the-object is raw) { use InterceptAllMethods; class Interceptor { has Mu $!the-object; method ^find_method(Mu \\type, Str $name) { my method (Mu \\SELF:) is raw { use nqp; my $the-object := nqp::getattr(SELF, Interceptor, '$!the-object'); nqp::getattr($the-object, $the-object.WHAT, '$!' ~ $name) } } } use nqp; nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object); } .say for j.\u0026amp;pry.eigenstates; # OUTPUT: 1 2 3 通过 InterceptAllMethods，lizmat 改变了类关键字的行为，允许我们提供一个 FALLBACK-method 来捕获任何方法，包括从 Mu 继承的方法。这反过来又允许 pry 返回的对象将任何方法调用转移到一个自定义的方法。在这个方法中，我们可以对 .\u0026amp;pry 被调用的对象做任何我们想做的事情。\n由于我们的特殊对象会拦截任何调用，甚至是 Mu 的调用，我们需要找到另一种方法来调用 .new。由于 .^ 不是 . 的特殊形式，我们可以用它来获得对类方法的访问。\nsub interceptor(Method $the-method){ use InterceptAllMethods; use nqp; sub (Mu $the-object is raw) { my class Interceptor { has Mu $!the-object; has Code $!the-method; method ^find_method(Mu \\type, Mu:D $name) { my method (Mu \\SELF: |c) is raw { $!the-method.($!the-object, $name, |c) } } method ^introspect(Mu \\type, Mu \\obj) { my method call-it() is raw { $!the-object } obj.\u0026amp;call-it; } method ^new(Mu \\type, $the-object!, $the-method) { nqp::p6bindattrinvres( nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object), Interceptor, '$!the-method', $the-method) } } # nqp::p6bindattrinvres( # nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object), # Interceptor, '$!the-method', $the-method); Interceptor.^new($the-object, $the-method) } } my \u0026amp;first-defined = interceptor( my method (Positional \\SELF: $name) { for SELF.flat -\u0026gt; $e { with $e.\u0026quot;$name\u0026quot;(|%_) { .return } } Nil } ); my $file = \u0026lt;file1.txt file2.txt file3.txt nohup.out\u0026gt;».IO.\u0026amp;first-defined.open(:r); dd $file; # OUTPUT: Handle $file = IO::Handle.new(path =\u0026gt; IO::Path.new(\u0026quot;nohup.out\u0026quot;, :SPEC(IO::Spec::Unix), :CWD(\u0026quot;/home/dex/projects/raku/tmp\u0026quot;)), chomp =\u0026gt; Bool::True, nl-in =\u0026gt; $[\u0026quot;\\n\u0026quot;, \u0026quot;\\r\\n\u0026quot;], nl-out =\u0026gt; \u0026quot;\\n\u0026quot;, encoding =\u0026gt; \u0026quot;utf8\u0026quot;) sub interceptor 接受一个方法并返回一个 sub。如果这个 sub 像方法一样被调用，它将把要被调用的方法的名称和调用者转发给一个自定义方法。当 .\u0026amp;first-defined 被调用时，会返回一个特殊的对象。让我们来看看它是什么。\nmy \\uhhh-special = \u0026lt;a b c\u0026gt;.\u0026amp;first-defined; dd uhhh-special.^introspect(uhhh-special); # OUTPUT: ($(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;), method \u0026lt;anon\u0026gt; (Positional \\SELF: $name, *%_) { #`(Method|93927752146784) ... }) 我们必须给 .^introspect 一个我们想看的对象，因为它的调用者是类 Interceptor 的类型对象。\n目前，我还不知道有什么办法（毕竟，我知道的只是足够多的东西，真的很危险。这是不幸的，因为 lizmat 决定重载关键字 class，而不是用不同的名字导出特殊的 Metamodel::ClassHOW。如果我们不想或不能有外部依赖，我们可以使用 MOP 来创建我们的类型对象。\nclass InterceptHOW is Metamodel::ClassHOW { method publish_method_cache(|) { } } sub ipry(Mu $the-object is raw) { my \\Interceptor = InterceptHOW.new_type(:name\u0026lt;Interceptor\u0026gt;); Interceptor.^add_attribute(Attribute.new(:name\u0026lt;$!the-object\u0026gt;, :type(Mu), :package(Interceptor))); Interceptor.^add_meta_method('find_method', my method find_method(Mu \\type, Str $name) { # say „looking for $name“; my method (Mu \\SELF:) is raw { use nqp; my $the-object := nqp::getattr(SELF, Interceptor, '$!the-object'); nqp::getattr($the-object, $the-object.WHAT, '$!' ~ $name) } }); Interceptor.^compose; use nqp; nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object); } 当我写这篇文章的时候，我发现 .^add_meta_method 只有在提供给它的方法的第一个参数的名字和 Str 相同的时候才会工作。起初，我尝试了一个匿名方法，它最终出现在 .^meta_method_table 中，但从未被调用。我想这个 bug 其实并不重要，因为这个元方法根本没有被记录下来。如果我玩火，我没有权利抱怨烧伤。你会在野外的 Actions.nqp 中发现这个方法。Class 关键字并没有什么神奇的作用。Rakudo 只是使用 MOP 来构造类型对象。\n我们不能在 Raku 中重载赋值操作符。这其实并不需要，因为赋值是通过调用一个名为 STORE 的方法来实现的。由于我们得到了对 dispatch 的完全控制，我们可以拦截任何方法调用，包括一连串的方法调用。\nmulti sub methodify(%h, :$deeply!) { sub interceptor(%h, $parent = Nil){ use InterceptAllMethods; use nqp; class Interceptor is Callable { has Mu $!the-object; has Mu @!stack; method ^find_method(Mu \\type, Mu:D $name) { my method (Mu \\SELF: |c) is raw { my @new-stack = @!stack; my $the-object = $!the-object; if $name eq 'STORE' { # workaround for rakudobug#4203 $the-object{||@new-stack.head(*-1)}:delete if $the-object{||@new-stack.head(*-1)}:exists; $the-object{||@new-stack} = c; return-rw c } else { @new-stack.push: $name; my \\nextlevel = SELF.^new($!the-object, @new-stack, $name); nextlevel } } } method ^introspect(Mu \\type, Mu \\obj) { my method call-it() is raw { $!the-object, @!stack } obj.\u0026amp;call-it; } method ^new(Mu \\type, $the-object!, @new-stack?, $name?) { $name ?? nqp::p6bindattrinvres( nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object), Interceptor, '@!stack', @new-stack) !! nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object) } } Interceptor.^new(%h) } interceptor(%h) } my %h2; my $o2 = methodify(%h2, :deeply); $o2.a.b = 42; dd %h2; $o2.a.b.c = \u0026lt;answer\u0026gt;; dd %h2; say $o2.a.b.c; # OUTPUT: Hash %h2 = {:a(${:b(\\(42))})} Hash %h2 = {:a(${:b(${:c(\\(\u0026quot;answer\u0026quot;))})})} This type cannot unbox to a native string: P6opaque, Interceptor in block \u0026lt;unit\u0026gt; at /home/dex/projects/raku/any-chain.raku line 310 每当我们调用一个方法时，都会创建一个新的 Interceptor 实例，它存储了前一个方法的名称。这样我们就可以沿着方法调用链移动。由于赋值调用 STORE，我们可以将赋值转移到我们用作实际数据结构的 Hash 中。唉，检索值就不一样了，因为 Raku 不区分方法调用和 FETCH。在这里，龙比我强。我还是包含了这个一半失败的尝试，因为我对 slippy 半列表有很好的利用。这需要使用 v6.e.preview，让我踩到了一个 bug。可能还有更多这样的情况。所以请使用同样的，这样我们就可以在 .e 发布到野外之前，把所有的野兽都杀掉。\n能够完全控制方法调用链将是一件好事。也许我们可以用 RakuAST 来做到这一点。\n有了这些已经可以工作的东西，我们可以做一些有趣的事情。那些烦人的异常总是在拖我们的后腿。我们可以用 try 来化解它们，但那会破坏一个方法调用链。\nconstant no-argument-given = Mu.new; sub try(Mu $obj is raw, Mu $alternate-value = no-argument-given) { interceptor(my method (Mu \\SELF: $name, |c) { my $o = SELF; my \\m = $o.^lookup($name) orelse { my $bt = Backtrace.new; my $idx = $bt.next-interesting-index($bt.next-interesting-index + 1); (X::Method::NotFound.new(:method($name), :typename($o.^name)) but role :: { method vault-backtrace { False }}).throw(Backtrace.new($idx + 1)); } try { $o = $o.\u0026quot;$name\u0026quot;(|c); } $! ~~ Exception ?? $alternate-value.WHICH eqv no-argument-given.WHICH ?? $o !! $alternate-value !! $o }).($obj) } class C { has $.greeting; method might-throw { die \u0026quot;Not today love!\u0026quot; } method greet { say $.greeting } } C.new(greeting =\u0026gt; ‚Let's make love!‘).\u0026amp;try.might-throw.greet; # OUTPUT: Let's make love! 伪方法 try 将会化解任何异常，并允许继续调用 C 语言的方法。我必须用一个特殊的值来标记没有可选的参数 $alternate-value，因为它实际上可能会把异常对象变成 Nil。\n我很肯定还有很多这样的小帮手在等着我们去发现。未来可能会有一个模块，希望能帮助 Raku 成为一个好的编程语言。\n原文链接: https://gfldex.wordpress.com/2021/02/17/method-ish/\n"},"name":"Method-ish","published":"2021-02-28T00:00:00+08:00","summary":"Method-ish","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-02-17-method-isd/"},{"content":{"html":"\u003cp\u003e一直以来乐于助人的 \u003ca href=\"https://stackoverflow.com/users/1077672/raiph\"\u003eraiph\u003c/a\u003e 在回答一个关于模式匹配的\u003ca href=\"https://stackoverflow.com/questions/66233465/haskell-like-pattern-matching-in-raku\"\u003e问题\u003c/a\u003e时希望得到 RakuAST，就像在 Haskell 中一样。有人提出用 MMD 来解决这个问题。这样做，得到一个贯穿的默认路径是无解的。由于 dispatch 简单来说就是模式匹配，我们只需要做一些额外的工作。简而言之，dispatcher 得到一个函数列表和一个带参数的列表。第一个接受所有参数的函数获胜。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eclass Hold { has $.key; }\nclass Press { has $.key; }\nclass Err { has $.msg; }\n\nsub else(\u0026amp;code) { \u0026amp;code }\n\nsub match($needle, *@tests) {\n    for @tests.head(*-1) -\u0026gt; \u0026amp;f {\n        if \u0026amp;f.cando(\\($needle)) {\n            return f($needle);\n        }\n    }\n    @tests.tail.();\n}\n\nmatch Hold.new(:key\u0026lt;a\u0026gt;),\n    -\u0026gt; Hold (:$key) { put „holding $key“; },\n    -\u0026gt; Press (:$key) { put „pressing $key“; },\n    -\u0026gt; Err (:$msg) { warn „ERR: $msg“ },\n    else { fail ‚unsopported‘ };\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e方法 \u003ccode\u003e.cando\u003c/code\u003e 需要一个 \u003ca href=\"https://docs.raku.org/type/Capture\"\u003eCapture\u003c/a\u003e 来告诉我们一个 Routine 是否可以用一个给定的参数列表来调用。为了创建这样一个捕获，我们使用字面的 \u003ccode\u003e\\($arguments, $go, $here)\u003c/code\u003e。我们不在最后测试默认值。相反，当没有其他函数匹配时，我们会调用该函数。声明 sub \u003ccode\u003eelse\u003c/code\u003e 只是为了美化。\u003c/p\u003e\n\u003cp\u003e由于我们是在函数式的土地上，我们可以使用 Raku 提供给我们的所有方便的功能。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \u0026amp;key-matcher = \u0026amp;match.assuming(*,[\n        -\u0026gt; Hold (:$key) { put „holding $key“; },\n        -\u0026gt; Press (:$key) { put „pressing $key“; },\n        -\u0026gt; Err (:$msg) { warn „ERR: $msg“ },\n        else { fail ‚unsopported‘ };\n]);\n\nsub key-source {\n    gather loop {\n        sleep 1;\n        take (Hold.new(:key\u0026lt;a\u0026gt;), Press.new(:key\u0026lt;b\u0026gt;), Err.new(:msg\u0026lt;WELP!\u0026gt;), 'unsupported').pick;\n    }\n}\n\n.\u0026amp;key-matcher for key-source;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们要帮助 \u003ccode\u003e.assuming\u003c/code\u003e 有点理解 slurpies，把函数列表放在一个显式 Array 中。\u003c/p\u003e\n\u003cp\u003e总有一种函数式的方法来解决一个问题。有时我们甚至可以从中得到一个整齐的语法。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://gfldex.wordpress.com/2021/02/24/pattern-dispatch/\"\u003ehttps://gfldex.wordpress.com/2021/02/24/pattern-dispatch/\u003c/a\u003e\u003c/p\u003e\n","text":"一直以来乐于助人的 raiph 在回答一个关于模式匹配的问题时希望得到 RakuAST，就像在 Haskell 中一样。有人提出用 MMD 来解决这个问题。这样做，得到一个贯穿的默认路径是无解的。由于 dispatch 简单来说就是模式匹配，我们只需要做一些额外的工作。简而言之，dispatcher 得到一个函数列表和一个带参数的列表。第一个接受所有参数的函数获胜。\nclass Hold { has $.key; } class Press { has $.key; } class Err { has $.msg; } sub else(\u0026amp;code) { \u0026amp;code } sub match($needle, *@tests) { for @tests.head(*-1) -\u0026gt; \u0026amp;f { if \u0026amp;f.cando(\\($needle)) { return f($needle); } } @tests.tail.(); } match Hold.new(:key\u0026lt;a\u0026gt;), -\u0026gt; Hold (:$key) { put „holding $key“; }, -\u0026gt; Press (:$key) { put „pressing $key“; }, -\u0026gt; Err (:$msg) { warn „ERR: $msg“ }, else { fail ‚unsopported‘ }; 方法 .cando 需要一个 Capture 来告诉我们一个 Routine 是否可以用一个给定的参数列表来调用。为了创建这样一个捕获，我们使用字面的 \\($arguments, $go, $here)。我们不在最后测试默认值。相反，当没有其他函数匹配时，我们会调用该函数。声明 sub else 只是为了美化。\n由于我们是在函数式的土地上，我们可以使用 Raku 提供给我们的所有方便的功能。\nmy \u0026amp;key-matcher = \u0026amp;match.assuming(*,[ -\u0026gt; Hold (:$key) { put „holding $key“; }, -\u0026gt; Press (:$key) { put „pressing $key“; }, -\u0026gt; Err (:$msg) { warn „ERR: $msg“ }, else { fail ‚unsopported‘ }; ]); sub key-source { gather loop { sleep 1; take (Hold.new(:key\u0026lt;a\u0026gt;), Press.new(:key\u0026lt;b\u0026gt;), Err.new(:msg\u0026lt;WELP!\u0026gt;), 'unsupported').pick; } } .\u0026amp;key-matcher for key-source; 我们要帮助 .assuming 有点理解 slurpies，把函数列表放在一个显式 Array 中。\n总有一种函数式的方法来解决一个问题。有时我们甚至可以从中得到一个整齐的语法。\n原文链接: https://gfldex.wordpress.com/2021/02/24/pattern-dispatch/\n"},"name":"模式分派","published":"2021-02-28T00:00:00+08:00","summary":"Pattern Dispatch","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/"},{"content":{"html":"\u003cp\u003e我不太喜欢上一篇文章中使用匹配的语法。它的参数列表中的逗号看起来很奇怪，不合适。也许是因为我的眼睛习惯了给定的块。睡一觉就好了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub accord(\u0026amp;c) { (c(CALLER::\u0026lt;$_\u0026gt;); succeed) if \u0026amp;c.cando(\\(CALLER::\u0026lt;$_\u0026gt;)) }\n\ngiven Err.new(:msg\u0026lt;a\u0026gt;) {\n    accord -\u0026gt; Hold (:$key) { put „holding $key“; }\n    accord -\u0026gt; Err (:$msg) { warn „ERR: $msg“ }\n    default { fail ‚unsupported‘ }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这是因为 \u003ccode\u003eaccord\u003c/code\u003e 模仿了 \u003ccode\u003ewhen\u003c/code\u003e 的工作。它做了一些匹配，当 True 时调用一个块，并在每个块的结尾添加一个 success（通过抛出一个控制异常）。given 所做的只是设置主题。它还充当了 caller 的角色，所以我们可以通过一个伪包来访问它的 \u003ccode\u003e$_\u003c/code\u003e。利用 pointy 的签名来做\u003ca href=\"https://docs.raku.org/type/Signature#Destructuring_arguments\"\u003e解构\u003c/a\u003e是相当强大的。把这个添加到 CORE 中可能是个好主意。\u003c/p\u003e\n\u003cp\u003e我们可能要把 Raku 的定义改成: \u0026ldquo;Raku 是一种高度可组合的编程语言\u0026rdquo;, 在这里，所有的东西都会落到实处。\u0026quot;\u003c/p\u003e\n\u003cp\u003e更新一下。\u003c/p\u003e\n\u003cp\u003e有些情况下，\u003ccode\u003e$_\u003c/code\u003e 不是动态的。另外，success 正在抛出一个控制异常，而这些的处理程序是由 when 或默认添加的。这种情况是在编译时发生的，目前不能用宏来解决。第一个问题可以用黑魔法解决。后一个问题需要用默认块。我没有找到一种方法来提供一个合理的错误信息，如果缺少这个块。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emulti sub accord(\u0026amp;c) {\n    use nqp;\n    $_ := nqp::getlexcaller('$_');\n    (c($_); succeed) if \u0026amp;c.cando(\\($_))\n}\n\nfor @possibilities.roll(1) -\u0026gt; $needle {\n    given $needle {\n        accord -\u0026gt; Hold (:$key) { put „holding $key“; }\n        accord -\u0026gt; Err (:$msg) { warn „ERR: $msg“ }\n        default { warn ‚unsopported‘ }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e原文链接: \u003ca href=\"https://gfldex.wordpress.com/2021/02/25/custom-when/\"\u003ehttps://gfldex.wordpress.com/2021/02/25/custom-when/\u003c/a\u003e\u003c/p\u003e\n","text":"我不太喜欢上一篇文章中使用匹配的语法。它的参数列表中的逗号看起来很奇怪，不合适。也许是因为我的眼睛习惯了给定的块。睡一觉就好了。\nsub accord(\u0026amp;c) { (c(CALLER::\u0026lt;$_\u0026gt;); succeed) if \u0026amp;c.cando(\\(CALLER::\u0026lt;$_\u0026gt;)) } given Err.new(:msg\u0026lt;a\u0026gt;) { accord -\u0026gt; Hold (:$key) { put „holding $key“; } accord -\u0026gt; Err (:$msg) { warn „ERR: $msg“ } default { fail ‚unsupported‘ } } 这是因为 accord 模仿了 when 的工作。它做了一些匹配，当 True 时调用一个块，并在每个块的结尾添加一个 success（通过抛出一个控制异常）。given 所做的只是设置主题。它还充当了 caller 的角色，所以我们可以通过一个伪包来访问它的 $_。利用 pointy 的签名来做解构是相当强大的。把这个添加到 CORE 中可能是个好主意。\n我们可能要把 Raku 的定义改成: \u0026ldquo;Raku 是一种高度可组合的编程语言\u0026rdquo;, 在这里，所有的东西都会落到实处。\u0026quot;\n更新一下。\n有些情况下，$_ 不是动态的。另外，success 正在抛出一个控制异常，而这些的处理程序是由 when 或默认添加的。这种情况是在编译时发生的，目前不能用宏来解决。第一个问题可以用黑魔法解决。后一个问题需要用默认块。我没有找到一种方法来提供一个合理的错误信息，如果缺少这个块。\nmulti sub accord(\u0026amp;c) { use nqp; $_ := nqp::getlexcaller('$_'); (c($_); succeed) if \u0026amp;c.cando(\\($_)) } for @possibilities.roll(1) -\u0026gt; $needle { given $needle { accord -\u0026gt; Hold (:$key) { put „holding $key“; } accord -\u0026gt; Err (:$msg) { warn „ERR: $msg“ } default { warn ‚unsopported‘ } } } 原文链接: https://gfldex.wordpress.com/2021/02/25/custom-when/\n"},"name":"自定义 when","published":"2021-02-28T00:00:00+08:00","summary":"Custom When","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-02-28-custom-when/"},{"content":{"html":"\u003cp\u003e在过去的几周里，我看到了一些\u003ca href=\"https://mydeveloperplanet.com/2021/01/20/how-to-start-contributing-to-open-source/\"\u003e文章\u003c/a\u003e和\u003ca href=\"https://youtu.be/GAqfMNB-YBU\"\u003e视频\u003c/a\u003e，讲述了在开源软件中构思是多么的伟大。这次我又想起了另一篇旧文\u003ca href=\"http://strangelyconsistent.org/blog/perl-6-is-my-mmorpg\"\u003eRaku 是我的 MMORPG\u003c/a\u003e。它说，你可以从以下几个方面受益于开源软件。比如说，可以做一个大侠，基于一些开源软件来写软件。作为写手，可以写博客、微博等，对所选软件产生兴趣。或者你可以成为一个法师 - 实现新的功能和修复 bug。今天小编就带着弓箭手来告诉大家如何成为 \u003ca href=\"https://raku.org/\"\u003eRaku\u003c/a\u003e 编程语言的法师。\u003c/p\u003e\n\u003ch2 id=\"选择一个任务\"\u003e选择一个任务\u003c/h2\u003e\n\u003cp\u003e让我们挑选一些编译器的 bug，并修复它。让我们去 \u003ca href=\"https://rakudo.org/\"\u003eRakudo\u003c/a\u003e 编译器 \u003ca href=\"https://github.com/rakudo/rakudo/issues\"\u003eissues\u003c/a\u003e中选择我们想要修复的 bug。我滚动了一下 bug 列表，遇到了解析 - 运气不错，我前段时间一直在研究\u003ca href=\"https://www.apress.com/gp/book/9781484232279\"\u003e编译器语法\u003c/a\u003e，看了一本这方面的好书。找到了四个问题。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://rakurs.atroxaper.net/assets/img/posts/2021-02-13-contributing-raku-1.png\" alt=\"img\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e标签为 LTA （Less Than Awesome - 当真实行为与直觉预期不同时）- 我们暂时把它划掉。\u003c/li\u003e\n\u003cli\u003e标签 \u0026ldquo;需要共识\u0026rdquo; - 我们只想修复一个不复杂的 bug - 肯定要划掉。\u003c/li\u003e\n\u003cli\u003e标签为 \u0026ldquo;grammar and actions\u0026rdquo; 的关于一个可能死的代码是一个很好的候选人的第一个任务。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e任务确定后，现在我们需要配置工作环境。在 Windows、Linux 和 macOS 中，一切应该都差不多。我将通过 macOS 的例子来告诉你。\u003c/p\u003e\n\u003ch2 id=\"建立工作环境\"\u003e建立工作环境\u003c/h2\u003e\n\u003cp\u003e为源码和我们建立的编译器建立文件夹。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003emkdir ~/dev-rakudo \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e mkdir ~/dev-rakudo-install\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eRakudo 编译器由三部分组成。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e虚拟机。现在有三种 - JVM、JS 和 MoarVM。我们以 MoarVM 为最稳定的一个。\u003c/li\u003e\n\u003cli\u003eNQP（Not Quite Perl），是一种低级（中级）语言的实现，它是 Raku 的一个 \u0026ldquo;子集\u0026rdquo;。虚拟机可以执行用 NQP 编写的代码。\u003c/li\u003e\n\u003cli\u003eRakudo 编译器本身，用 NQP 和 Raku 编写。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e下载并编译这三个组件。我分别花了一分半钟、半分钟和两分半钟才编好。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~/dev-rakudo \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e git clone git@github.com:MoarVM/MoarVM.git \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e MoarVM\nperl Configure.pl --prefix ~/dev-rakudo-install \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make -j \u003cspan class=\"m\"\u003e4\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make install\n\n\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~/dev-rakudo \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e git clone git@github.com:Raku/nqp.git \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e nqp\nperl Configure.pl --backend\u003cspan class=\"o\"\u003e=\u003c/span\u003emoar --prefix ~/dev-rakudo-install \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make -j \u003cspan class=\"m\"\u003e4\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make install\n\n\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~/dev-rakudo \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e git clone git@github.com:rakudo/rakudo.git \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e rakudo\nperl Configure.pl --backend\u003cspan class=\"o\"\u003e=\u003c/span\u003emoar --prefix ~/dev-rakudo-install \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make -j \u003cspan class=\"m\"\u003e4\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make install\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e注意参数。\u003ccode\u003e--prefix\u003c/code\u003e 显示了 \u003ccode\u003emake install\u003c/code\u003e 命令后可执行文件的复制位置，\u003ccode\u003e--backend=moar\u003c/code\u003e 表示正在使用的虚拟机，而 \u003ccode\u003e-j 4\u003c/code\u003e 则要求跨多线程并行化（以防加快进度）。现在我们已经建立了 Rakudo 编译器 \u003ccode\u003e~/dev-rakudo-install/bin/raku\u003c/code\u003e。我们还需要官方的编译器测试套件。你应该把它和它的代码一起放在文件夹里。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~/dev-rakudo/rakudo \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e git clone https://github.com/Raku/roast.git t/spec\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我们先进行测试。这种情况很常见，有些测试甚至在新的变化之前就失败了。我们需要辨别出来，这样以后就不会害怕这些变化破坏了一些不必要的东西。\u003c/p\u003e\n\u003cp\u003e这里和下面我将在 \u003ccode\u003e~/dev-rakudo/rakudo\u003c/code\u003e 文件夹中工作，除非另有说明。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; make spectest\n[...]\nTest Summary Report\n-------------------\nt/spec/S32-str/utf8-c8.t    (Wstat: 65280 Tests: 54 Failed: 0)\n  Non-zero exit status: 255\n  Parse errors: Bad plan.  You planned 66 tests but ran 54.\nFiles=1346, Tests=117144, 829 wallclock secs (27.70 usr  6.04 sys + 2638.79 cusr 210.98 csys = 2883.51 CPU)\nResult: FAIL\nmake: *** [m-spectest5] Error 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e14分钟内共运行了1,346个文件中的117,144次测试。一些与utf8相关的测试由于某种原因失败了，其他的都能正常工作。我们已经准备好去工作了!\u003c/p\u003e\n\u003ch2 id=\"让我们来看看问题的陈述\"\u003e让我们来看看问题的陈述\u003c/h2\u003e\n\u003cp\u003e问题陈述说，某个元运算符 \u003ccode\u003eR\u003c/code\u003e 在 colonpair 上出了问题。我打开文档，搜索 R 这个词，但下拉列表中没有这个名字的元运算符。我试着输入 metaop，看到的是反向元操作符(R)。原来，如果你想把二元运算的操作数按相反的顺序写出来，你可以在其符号前使用前缀 R。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esay 3 R- 2 == -1 # Output: True\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eColonpair 是命名对的语法。它看起来就像名字前面有一个冒号，前面有一个括号，有一个值。例如 \u003ccode\u003e:foo(42)\u003c/code\u003e 是一个名称为 \u003ccode\u003efoo\u003c/code\u003e、值为 \u003ccode\u003e42\u003c/code\u003e 的对儿。这个语法通常用于在调用函数时，向函数传递一个命名参数中的值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub sub-with-named-parameter(:$foo) {\n    say $foo;\n}\n\nsub-with-named-parameter(:foo(42)); # Output: 42\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果一个函数参数不是命名的，而是位置的，那么在用命名对调用时，就会出现编译错误。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub sub-without-named-parameter($foo) { # \u0026lt;- 没有冒号\n  say $foo;\n}\n\nsub-without-named-parameter(:foo(42)); # Unexpected named argument 'foo' passed\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果你在调用这样的函数时用括号包围一个参数，整个参数对将被传递到位置参数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub sub-without-named-parameter($foo) {\n  say $foo;\n}\n\nsub-without-named-parameter((:foo(42))); # Output: foo =\u0026gt; 42\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在 Raku 中，你可以写一个函数来捕获所有传递给它的参数并分析它们。这是在单个参数 - 捕获前用竖线完成的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub sub-with-capture(|foo) { # \u0026lt;- 参数捕获\n  say foo;\n}\n\nsub-with-capture(:foo(42));     # Output: \\(:foo(42))\nsub-with-capture(42);           # Output: \\(42)\nsub-with-capture(:foo(3 Z- 2)); # Output: \\(:foo((1,).Seq))\nsub-with-capture(:foo(3 R- 2)); # Output: \\(-1)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e倒数第二行使用了 Z 元操作符 - zip 操作符。它将左右两部分作为一个列表，按顺序每次从它们中抽取一个元素，并进行操作，从而形成一个序列。\u003c/p\u003e\n\u003cp\u003e在最后一行，只用了我们需要的 R 元操作符。在这种情况下，它不是一个对，而是一个常量，它被传递到函数中。我们可以假设这是元运算符工作方式的一些特殊性，但用 Z 的例子表明并非如此。其实这是一个 bug - 当一个对被传递到一个使用 R 元运算符的函数中时，它的值会被转换。\u003c/p\u003e\n\u003ch2 id=\"我们需要一个新的测试\"\u003e我们需要一个新的测试\u003c/h2\u003e\n\u003cp\u003e为了确保未来的变化能够修复错误的行为，我们需要写一个新的测试。在测试文件中不难找到 R 元操作符的测试（\u003ca href=\"https://github.com/Raku/roast/blob/fea1d16d993eb851d2935155e0b0d074fa3593bf/S03-metaops/reverse.t\"\u003eS03-metops/reverse.t\u003c/a\u003e）。下面我将补充以下测试。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# https://github.com/rakudo/rakudo/issues/1632\n{\n  sub subroutine($expected, |actual) {\n    is actual.gist, $expected, \u0026quot;Сolonpair exists\u0026quot;\n  }\n\n  subroutine('\\(:foo(-1))', :foo(3 R- 2));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e该测试有一个功能，有两个参数 - 正常和捕获。在函数体中，第一个参数和传递的 Capture 的字符串表示进行比较。你可以使用 \u003ccode\u003emake\u003c/code\u003e 对新构建的编译器进行单独测试。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; make t/spec/S03-metaops/reverse.t\n[...]\nok 69 - [R~]=\nnot ok 70 - Colonpair exists\n# Failed test 'Colonpair exists'\n# at t/spec/S03-metaops/reverse.t line 191\n# expected: '\\(:foo(-1))'\n#      got: '\\(-1)'\n# You planned 69 tests, but ran 70\n# You failed 1 test of 70\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e你可以看到，测试失败了（如预期）。还有一个单独的说明，系统预计69次测试，但收到70次。这是基于 TAP 的测试系统的特点 - 必须在文件的顶部修正传递给 \u003ccode\u003eplan\u003c/code\u003e 函数的数字。现在测试崩溃了，但编号没有受到影响。你可以开始修复它。\u003c/p\u003e\n\u003ch2 id=\"凝视法\"\u003e凝视法\u003c/h2\u003e\n\u003cp\u003e一开始我很相信任务上的标签 - 如果是解析的话，一定是源码解析阶段的某个地方出现了问题。目前我的认识如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e基础解析器代码在文件 \u003ccode\u003erakudo/src/Perl6/Grammar.nqp\u003c/code\u003e 中。\u003c/li\u003e\n\u003cli\u003e这个解析器是从 \u003ccode\u003enqp/src/HLL/Grammar.nqp\u003c/code\u003e 文件中的基础解析器继承的。\u003c/li\u003e\n\u003cli\u003e元操作符的解析和工作方式都差不多，你可以通过仔细观察来发现不同之处。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e我在基础解析器代码中找到了对元操作符的引用。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003etoken infix_prefix_meta_operator:sym\u0026lt;R\u0026gt; {\n  \u0026lt;sym\u0026gt; \u0026lt;infixish('R')\u0026gt; {}\n  \u0026lt;.can_meta($\u0026lt;infixish\u0026gt;, \u0026quot;reverse the args of\u0026quot;)\u0026gt;\n  \u0026lt;O=.revO($\u0026lt;infixish\u0026gt;)\u0026gt;\n}\n\ntoken infix_prefix_meta_operator:sym\u0026lt;Z\u0026gt; {\n  \u0026lt;sym\u0026gt; \u0026lt;infixish('Z')\u0026gt; {}\n  \u0026lt;.can_meta($\u0026lt;infixish\u0026gt;, \u0026quot;zip with\u0026quot;)\u0026gt;\n  \u0026lt;O(|%list_infix)\u0026gt;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这需要对 Raku grammar 有一定的了解。据我所知，原来这两个元运算符在解析上并没有根本的区别。一段时间后，在解析器的源代码中挖得够多了，我开始怀疑解析工作是否正确。认为代码 \u003ccode\u003emy $r = :foo(3 R- 2); say $r; # Output: foo =\u0026gt; -1\u003c/code\u003e 正确工作的建议 - 问题恰恰发生在调用函数时。显然，我白白相信了任务栏上的标签。\u003c/p\u003e\n\u003ch2 id=\"编译器将帮助我们\"\u003e编译器将帮助我们\u003c/h2\u003e\n\u003cp\u003e颇为迟钝的我想起了我从一开始就应该做的事情。Rakudo 编译器有 \u003ccode\u003e--target\u003c/code\u003e 调试开关。它取编译器阶段的名称，你想将其结果输出到控制台并退出。我想看看 \u003ccode\u003e--target=parse\u003c/code\u003e（因为我只知道这一个）。\u003c/p\u003e\n\u003cp\u003e我从 \u003ccode\u003e~/dev-rakudo/rakudo\u003c/code\u003e 文件夹中使用 \u003ccode\u003erakumo-m\u003c/code\u003e，这样我就不必等待通过 \u003ccode\u003emake install\u003c/code\u003e 命令将所需文件复制到 \u003ccode\u003e~/dev-rakudo-install\u003c/code\u003e。简单的脚本可以这样运行。更复杂的脚本必须在 \u003ccode\u003emake install\u003c/code\u003e 之后从 \u003ccode\u003e-install\u003c/code\u003e 中运行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; cat ~/test.raku\nsub s(|c) { say c }\ns(:foo(3 R- 2));\ns(:foo(3 Z- 2));\n\n\u0026gt; ./rakudo-m --target=parse ~/test.raku\n[...]\n- args: (:foo(3 R- 2))\n  - semiarglist: :foo(3 R- 2)\n    - arglist: 1 matches\n      - EXPR: :foo(3 R- 2)\n        - colonpair: :foo(3 R- 2)\n          - identifier: foo\n          - coloncircumfix: (3 R- 2)\n            - circumfix: (3 R- 2)\n              - semilist: 3 R- 2\n                - statement: 1 matches\n                  - EXPR: R- 2\n[...]\n- args: (:foo(3 Z- 2))\n  - semiarglist: :foo(3 Z- 2)\n    - arglist: 1 matches\n      - EXPR: :foo(3 Z- 2)\n        - colonpair: :foo(3 Z- 2)\n          - identifier: foo\n          - coloncircumfix: (3 Z- 2)\n            - circumfix: (3 Z- 2)\n              - semilist: 3 Z- 2\n                - statement: 1 matches\n                  - EXPR: Z- 2\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e结论：R 和 Z 的解析是一样的。\u003c/p\u003e\n\u003ch2 id=\"这不是解析\"\u003e这不是解析\u003c/h2\u003e\n\u003cp\u003e所有被解析的东西都会被传递给所谓的 Action，把字词变成一棵语法树。在我们的例子中，Actions 位于文件 \u003ccode\u003erakudo/src/Perl6/Actions.nqp\u003c/code\u003e 和 \u003ccode\u003enqp/src/HLL/Actions.nqp\u003c/code\u003e 中。这里就比较容易搞清楚了，毕竟是代码，是 grammar。\u003c/p\u003e\n\u003cp\u003e我在主 Actions 中找到了以下代码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\nelsif $\u0026lt;infix_prefix_meta_operator\u0026gt; {\n[...]\n  if    $metasym eq 'R' { $helper := '\u0026amp;METAOP_REVERSE'; $t := nqp::flip($t) if $t; }\n  elsif $metasym eq 'X' { $helper := '\u0026amp;METAOP_CROSS'; $t := nqp::uc($t); }\n  elsif $metasym eq 'Z' { $helper := '\u0026amp;METAOP_ZIP'; $t := nqp::uc($t); }\n  \n  my $metapast := QAST::Op.new( :op\u0026lt;call\u0026gt;, :name($helper), WANTED($basepast,'infixish') );\n  $metapast.push(QAST::Var.new(:name(baseop_reduce($base\u0026lt;OPER\u0026gt;\u0026lt;O\u0026gt;.made)), :scope\u0026lt;lexical\u0026gt;))\n    if $metasym eq 'X' || $metasym eq 'Z';\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e它说，如果在代码中解析了元操作符 \u003ccode\u003eR\u003c/code\u003e、\u003ccode\u003eZ\u003c/code\u003e 或 \u003ccode\u003eX\u003c/code\u003e，就应该在语法树中添加一些 \u003ccode\u003eMETAOP_\u003c/code\u003e 函数调用。在 \u003ccode\u003eZ\u003c/code\u003e 和 \u003ccode\u003eX\u003c/code\u003e 的情况下，它会多一个参数，即某种还原函数。所有这些功能都可以在 \u003ccode\u003erakudo/src/core.c/metaops.pm6\u003c/code\u003e 中找到。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub METAOP_REVERSE(\\op) is implementation-detail {\n  -\u0026gt; |args { op.(|args.reverse) }\n}\n\nsub METAOP_ZIP(\\op, \u0026amp;reduce) is implementation-detail {\n nqp::if(op.prec('thunky').starts-with('.'),\n  -\u0026gt; +lol {\n    my $arity = lol.elems;\n    [...]\n  },\n  -\u0026gt; +lol {\n    Seq.new(Rakudo::Iterator.ZipIterablesOp(lol,op))\n  }\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e给你：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e\\op\u003c/code\u003e 是由我们的元操作符，即-，在前面的操作。\u003c/li\u003e\n\u003cli\u003eTrait \u003ccode\u003eimplementation-detail\u003c/code\u003e 只是表明这不是公共代码，是编译器实现的一部分。\u003c/li\u003e\n\u003cli\u003e由于-操作没有笨重的特性，所以 \u003ccode\u003e\u0026amp;reduce\u003c/code\u003e 函数不会参与计算，\u003ccode\u003eZ\u003c/code\u003e 的结果是 \u003ccode\u003eSeq.new(...)\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eR\u003c/code\u003e 的结果是一个操作调用 - 参数顺序相反。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这时我想起还有一个 - 目标，即星。它将显示行动的结果。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; ./rakudo-m --target=ast ~/test.raku\n[...]\n- QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R-\n    - QAST::Op(call \u0026amp;METAOP_REVERSE) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt;\n      - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt;\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(3)  3\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(2)  2\n[...]\n- QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;7\u0026gt; s(:foo(3 Z- 2))\n  - QAST::Op+{QAST::SpecialArg}(:named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;8\u0026gt; :before_promotion\u0026lt;?\u0026gt; Z-\n    - QAST::Op(call \u0026amp;METAOP_ZIP) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt;\n      - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt;\n      - QAST::Var(lexical \u0026amp;METAOP_REDUCE_LEFT)\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(3)  3\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(2)  2\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e一如所料。除了调用不同的 \u003ccode\u003eMETAOP_\u003c/code\u003e 函数外，所有的东西几乎都是一样的。从它们的代码中我们可以知道，原则上这些函数的不同之处在于返回值的类型 - 分别是 \u003ccode\u003eInt\u003c/code\u003e 和 \u003ccode\u003eSeq\u003c/code\u003e。众所周知，Raku 对不同类型的对象的上下文相当敏感\u0026hellip;\u0026hellip;我想，它关注的可能是返回值。我试着用下面的方式修改代码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub METAOP_REVERSE(\\op) is implementation-detail {\n  -\u0026gt; |args { Seq.new(op.(|args.reverse)) }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e编译、运行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; make\n[...]\nStage start      :   0.000\nStage parse      :  61.026\nStage syntaxcheck:   0.000\nStage ast        :   0.000\nStage optimize   :   7.076\nStage mast       :  14.120\nStage mbc        :   3.941\n[...]\n\u0026gt; ./rakudo-m ~/test.raku\n\\(-1)\n\\(:foo((1,).Seq))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e一切都没有改变。所以，不是返回值\u0026hellip;\u0026hellip;想了想，不知道为什么结果又是 \u003ccode\u003e-1\u003c/code\u003e 而不是 \u003ccode\u003e(-1,).Seq\u003c/code\u003e。而且，从代码来看，\u003ccode\u003eSeq\u003c/code\u003e 根本就没有一个合适的构造函数。下一次，作为一些疯狂的事情，我尝试调用 \u003ccode\u003eMETAOP_REVERSE\u003c/code\u003e 结果只是为了崩溃。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub METAOP_REVERSE(\\op) is implementation-detail {\n  -\u0026gt; |args { die }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e编译、运行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; make\n[...]\n\u0026gt; ./rakudo-m ~/test.raku\n\\(-1)\n\\(:foo((1,).Seq))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e怎么会呢？语法树中包含了对 \u003ccode\u003eMETAOP_REVERSE\u003c/code\u003e 的调用，它的代码应该是折叠的，但计算仍然进行，我们得到 \u003ccode\u003e-1\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这些都不是《行动》。\u003c/p\u003e\n\u003cp\u003e这里我的目光落在编译器的构建日志上。它是一些阶段被列在那里。我随机试了 \u003ccode\u003e--target=mast\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; ./rakudo-m --target=mast ~/test.raku\n[...]\nMAST::Frame name\u0026lt;s\u0026gt;, cuuid\u0026lt;1\u0026gt;\n  Local types: 0\u0026lt;obj\u0026gt;, 1\u0026lt;obj\u0026gt;, 2\u0026lt;obj\u0026gt;, 3\u0026lt;obj\u0026gt;, 4\u0026lt;int\u0026gt;, 5\u0026lt;str\u0026gt;, 6\u0026lt;obj\u0026gt;, 7\u0026lt;obj\u0026gt;, 8\u0026lt;obj\u0026gt;,\n  Lexical types: 0\u0026lt;obj\u0026gt;, 1\u0026lt;obj\u0026gt;, 2\u0026lt;obj\u0026gt;, 3\u0026lt;obj\u0026gt;, 4\u0026lt;obj\u0026gt;,\n  Lexical names: 0\u0026lt;c\u0026gt;, 1\u0026lt;$¢\u0026gt;, 2\u0026lt;$!\u0026gt;, 3\u0026lt;$/\u0026gt;, 4\u0026lt;$*DISPATCHER\u0026gt;,\n  Lexical map: $!\u0026lt;2\u0026gt;, c\u0026lt;0\u0026gt;, $*DISPATCHER\u0026lt;4\u0026gt;, $¢\u0026lt;1\u0026gt;, $/\u0026lt;3\u0026gt;,\n  Outer: name\u0026lt;\u0026lt;unit\u0026gt;\u0026gt;, cuuid\u0026lt;2\u0026gt;\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e某种不可读的矩阵。星号和桅杆之间有一个阶段性的优化。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; ./rakudo-m --target=optimize ~/test.raku\n[...]\n- QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Op(call \u0026amp;infix:\u0026lt;-\u0026gt;)  :METAOP_opt_result\u0026lt;?\u0026gt;\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(2)  2\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(3)  3\n[...]\n- QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;7\u0026gt; s(:foo(3 Z- 2))\n  - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;8\u0026gt; :before_promotion\u0026lt;?\u0026gt; Z-\n    - QAST::Op(callstatic \u0026amp;METAOP_ZIP) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt;\n      - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt;\n      - QAST::Var(lexical \u0026amp;METAOP_REDUCE_LEFT)\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(3)  3\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(2)  2\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e哈，就是这样。在优化阶段后，行将失踪。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eQAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R-.\u003c/code\u003e\n并将整个 \u003ccode\u003eMETAOP_REVERSE\u003c/code\u003e 调用替换为通常的操作 \u003ccode\u003e(\u0026amp;infix:\u0026lt;-\u0026gt;)\u003c/code\u003e。所以问题一定在优化器的某个地方。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e只有在 \u003ccode\u003eoptim_nameless_call\u003c/code\u003e 方法中才会提到 \u003ccode\u003e\u0026amp;METAOP_ASSIGN\u003c/code\u003e，其中 \u003ccode\u003eQAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;)\u003c/code\u003e。显然，这个操作负责生成一个命名对 - 它已经有了一个名字（命名参数），它需要计算值。从优化 \u003ccode\u003e_\u003c/code\u003e 无名方法的执行路径来看，我们可以得出结论，我们对最后一个块感兴趣。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n  elsif self.op_eq_core($metaop, '\u0026amp;METAOP_REVERSE') {\n    return NQPMu unless nqp::istype($metaop[0], QAST::Var)\n      \u0026amp;\u0026amp; nqp::elems($op) == 3;\n    return QAST::Op.new(:op\u0026lt;call\u0026gt;, :name($metaop[0].name),\n      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;\n  }\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e让我提醒你，优化前的树是这样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n- QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R-\n    - QAST::Op(call \u0026amp;METAOP_REVERSE) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt;\n      - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt;\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e而精简之后，是这样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n- QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Op(call \u0026amp;infix:\u0026lt;-\u0026gt;)  :METAOP_opt_result\u0026lt;?\u0026gt;\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e也就是说，优化 \u003ccode\u003e_nameless_call\u003c/code\u003e 做了以下工作。\u003c/p\u003e\n\u003cp\u003e如果我们的 \u003ccode\u003eQAST::Op+{QAST::SpecialArg}\u003c/code\u003e 操作没有三个参数，如果 \u003ccode\u003eMETAOP_REVERSE\u003c/code\u003e 调用没有一个正确的类型，我们就返回空。这不是我们的情况。\n否则，我们将返回一个新的操作，代替我们的 \u003ccode\u003eQAST::Op+{QAST::SpecialArg}\u003c/code\u003e 操作，以相反的顺序调用 \u003ccode\u003e\u0026amp;infix:\u0026lt;-\u0026gt;\u003c/code\u003e 参数。就是说，把结果打包成一对就没了。\u003c/p\u003e\n\u003cp\u003e在摸索了一下如何解决这个问题，并阅读了 \u003ccode\u003eQAST::SpecialArg\u003c/code\u003e 和 \u003ccode\u003eQAST::Node\u003c/code\u003e 的实现后，我想到了下面的代码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n  elsif self.op_eq_core($metaop, '\u0026amp;METAOP_REVERSE') {\n    return NQPMu unless nqp::istype($metaop[0], QAST::Var)\n      \u0026amp;\u0026amp; nqp::elems($op) == 3;\n    my $opt_result := QAST::Op.new(:op\u0026lt;call\u0026gt;, :name($metaop[0].name),\n      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;\n    if $op.named { $opt_result.named($op.named) } # 添加选项 named \n    if $op.flat { $opt_result.flat($op.flat) }    # 添加选项 flat\n    return $opt_result;\n  }\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e还有木头。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n- QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Op+{QAST::SpecialArg}(call \u0026amp;infix:\u0026lt;-\u0026gt; :named\u0026lt;foo\u0026gt;)  :METAOP_opt_result\u0026lt;?\u0026gt;\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e命名的参数返回到它的位置。测试也开始通过。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; make t/spec/S03-metaops/reverse.t\n[...]\nAll tests successful.\nFiles=1, Tests=70,  3 wallclock secs ( 0.03 usr  0.01 sys +  3.61 cusr  0.17 csys =  3.82 CPU)\nResult: PASS\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们本可以就此打住，但这是编译器优化器的代码，它的结果是一个有两个整数参数的方法调用。我认为这在某种程度上是次优的。如果我们将返回表达式改为返回 \u003ccode\u003eself.visit_op: $opt_result;\u003c/code\u003e，对产生的非优化操作调用优化器，那么产生的树就会像这样。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n- QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Want+{QAST::SpecialArg}(:named\u0026lt;foo\u0026gt;)\n    - QAST::WVal+{QAST::SpecialArg}(Int :named\u0026lt;foo\u0026gt;)\n    - QAST::IVal(-1)\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在一切都很理想。\u003c/p\u003e\n\u003ch2 id=\"分享成果\"\u003e分享成果\u003c/h2\u003e\n\u003cp\u003e我们已经到了终点线。现在我们只需要分享我们的经验。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e重要的是：运行所有的 \u003ccode\u003emake spectest\u003c/code\u003e 测试，确保没有新的东西被破坏。\u003c/li\u003e\n\u003cli\u003e在 GitHub 上使用 Rakudo 编译器和测试制作 fork 仓库。\u003c/li\u003e\n\u003cli\u003e将 fork 仓库添加为新的 git 远程仓库。\u003c/li\u003e\n\u003cli\u003ecd ~/dev-rakudo/rakudo \u0026amp;\u0026amp; git remote add fork \u003c!-- raw HTML omitted --\u003e。\u003c/li\u003e\n\u003cli\u003ecd ~/dev-rakudo/t/spec \u0026amp;\u0026amp; git remote add fork \u003c!-- raw HTML omitted --\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e重要：确保两个仓库在 git 中都有正确的用户名和用户邮箱。\u003c/p\u003e\n\u003cp\u003e提交到两个版本库，详细说明你为什么做了哪些改动，并添加对原始问题跟踪器的引用。\u003c/p\u003e\n\u003cp\u003e运行提交。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecd ~/dev-rakudo/rakudo \u0026amp;\u0026amp; git push fork\ncd ~/dev-rakudo/t/spec \u0026amp;\u0026amp; git push fork\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e向两个仓库提出拉取请求。在他们的描述中，最好是相互参照和原任务。\u003c/p\u003e\n\u003ch2 id=\"结论\"\u003e结论\u003c/h2\u003e\n\u003cp\u003e对开源软件的贡献是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e趣味性和趣味性。\u003c/li\u003e\n\u003cli\u003e给你的感觉是，你正在做一些有用的事情，你真的是。\u003c/li\u003e\n\u003cli\u003e让你认识新的有趣和专业的人（任何关于 Raku 的问题都会在 \u003ccode\u003e#raku IRC\u003c/code\u003e 频道中得到回答）。\u003c/li\u003e\n\u003cli\u003e解决非标准任务，没有截止日期的压力，是一种很好的体验。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e选择你觉得最舒服的角色等级，去做新的任务吧!\u003c/p\u003e\n","text":"在过去的几周里，我看到了一些文章和视频，讲述了在开源软件中构思是多么的伟大。这次我又想起了另一篇旧文Raku 是我的 MMORPG。它说，你可以从以下几个方面受益于开源软件。比如说，可以做一个大侠，基于一些开源软件来写软件。作为写手，可以写博客、微博等，对所选软件产生兴趣。或者你可以成为一个法师 - 实现新的功能和修复 bug。今天小编就带着弓箭手来告诉大家如何成为 Raku 编程语言的法师。\n选择一个任务 让我们挑选一些编译器的 bug，并修复它。让我们去 Rakudo 编译器 issues中选择我们想要修复的 bug。我滚动了一下 bug 列表，遇到了解析 - 运气不错，我前段时间一直在研究编译器语法，看了一本这方面的好书。找到了四个问题。\n 标签为 LTA （Less Than Awesome - 当真实行为与直觉预期不同时）- 我们暂时把它划掉。 标签 \u0026ldquo;需要共识\u0026rdquo; - 我们只想修复一个不复杂的 bug - 肯定要划掉。 标签为 \u0026ldquo;grammar and actions\u0026rdquo; 的关于一个可能死的代码是一个很好的候选人的第一个任务。  任务确定后，现在我们需要配置工作环境。在 Windows、Linux 和 macOS 中，一切应该都差不多。我将通过 macOS 的例子来告诉你。\n建立工作环境 为源码和我们建立的编译器建立文件夹。\nmkdir ~/dev-rakudo \u0026amp;\u0026amp; mkdir ~/dev-rakudo-install Rakudo 编译器由三部分组成。\n 虚拟机。现在有三种 - JVM、JS 和 MoarVM。我们以 MoarVM 为最稳定的一个。 NQP（Not Quite Perl），是一种低级（中级）语言的实现，它是 Raku 的一个 \u0026ldquo;子集\u0026rdquo;。虚拟机可以执行用 NQP 编写的代码。 Rakudo 编译器本身，用 NQP 和 Raku 编写。  下载并编译这三个组件。我分别花了一分半钟、半分钟和两分半钟才编好。\ncd ~/dev-rakudo \u0026amp;\u0026amp; git clone git@github.com:MoarVM/MoarVM.git \u0026amp;\u0026amp; cd MoarVM perl Configure.pl --prefix ~/dev-rakudo-install \u0026amp;\u0026amp; make -j 4 \u0026amp;\u0026amp; make install cd ~/dev-rakudo \u0026amp;\u0026amp; git clone git@github.com:Raku/nqp.git \u0026amp;\u0026amp; cd nqp perl Configure.pl --backend=moar --prefix ~/dev-rakudo-install \u0026amp;\u0026amp; make -j 4 \u0026amp;\u0026amp; make install cd ~/dev-rakudo \u0026amp;\u0026amp; git clone git@github.com:rakudo/rakudo.git \u0026amp;\u0026amp; cd rakudo perl Configure.pl --backend=moar --prefix ~/dev-rakudo-install \u0026amp;\u0026amp; make -j 4 \u0026amp;\u0026amp; make install 注意参数。--prefix 显示了 make install 命令后可执行文件的复制位置，--backend=moar 表示正在使用的虚拟机，而 -j 4 则要求跨多线程并行化（以防加快进度）。现在我们已经建立了 Rakudo 编译器 ~/dev-rakudo-install/bin/raku。我们还需要官方的编译器测试套件。你应该把它和它的代码一起放在文件夹里。\ncd ~/dev-rakudo/rakudo \u0026amp;\u0026amp; git clone https://github.com/Raku/roast.git t/spec 我们先进行测试。这种情况很常见，有些测试甚至在新的变化之前就失败了。我们需要辨别出来，这样以后就不会害怕这些变化破坏了一些不必要的东西。\n这里和下面我将在 ~/dev-rakudo/rakudo 文件夹中工作，除非另有说明。\n\u0026gt; make spectest [...] Test Summary Report ------------------- t/spec/S32-str/utf8-c8.t (Wstat: 65280 Tests: 54 Failed: 0) Non-zero exit status: 255 Parse errors: Bad plan. You planned 66 tests but ran 54. Files=1346, Tests=117144, 829 wallclock secs (27.70 usr 6.04 sys + 2638.79 cusr 210.98 csys = 2883.51 CPU) Result: FAIL make: *** [m-spectest5] Error 1 14分钟内共运行了1,346个文件中的117,144次测试。一些与utf8相关的测试由于某种原因失败了，其他的都能正常工作。我们已经准备好去工作了!\n让我们来看看问题的陈述 问题陈述说，某个元运算符 R 在 colonpair 上出了问题。我打开文档，搜索 R 这个词，但下拉列表中没有这个名字的元运算符。我试着输入 metaop，看到的是反向元操作符(R)。原来，如果你想把二元运算的操作数按相反的顺序写出来，你可以在其符号前使用前缀 R。\nsay 3 R- 2 == -1 # Output: True Colonpair 是命名对的语法。它看起来就像名字前面有一个冒号，前面有一个括号，有一个值。例如 :foo(42) 是一个名称为 foo、值为 42 的对儿。这个语法通常用于在调用函数时，向函数传递一个命名参数中的值。\nsub sub-with-named-parameter(:$foo) { say $foo; } sub-with-named-parameter(:foo(42)); # Output: 42 如果一个函数参数不是命名的，而是位置的，那么在用命名对调用时，就会出现编译错误。\nsub sub-without-named-parameter($foo) { # \u0026lt;- 没有冒号 say $foo; } sub-without-named-parameter(:foo(42)); # Unexpected named argument 'foo' passed 如果你在调用这样的函数时用括号包围一个参数，整个参数对将被传递到位置参数。\nsub sub-without-named-parameter($foo) { say $foo; } sub-without-named-parameter((:foo(42))); # Output: foo =\u0026gt; 42 在 Raku 中，你可以写一个函数来捕获所有传递给它的参数并分析它们。这是在单个参数 - 捕获前用竖线完成的。\nsub sub-with-capture(|foo) { # \u0026lt;- 参数捕获 say foo; } sub-with-capture(:foo(42)); # Output: \\(:foo(42)) sub-with-capture(42); # Output: \\(42) sub-with-capture(:foo(3 Z- 2)); # Output: \\(:foo((1,).Seq)) sub-with-capture(:foo(3 R- 2)); # Output: \\(-1) 倒数第二行使用了 Z 元操作符 - zip 操作符。它将左右两部分作为一个列表，按顺序每次从它们中抽取一个元素，并进行操作，从而形成一个序列。\n在最后一行，只用了我们需要的 R 元操作符。在这种情况下，它不是一个对，而是一个常量，它被传递到函数中。我们可以假设这是元运算符工作方式的一些特殊性，但用 Z 的例子表明并非如此。其实这是一个 bug - 当一个对被传递到一个使用 R 元运算符的函数中时，它的值会被转换。\n我们需要一个新的测试 为了确保未来的变化能够修复错误的行为，我们需要写一个新的测试。在测试文件中不难找到 R 元操作符的测试（S03-metops/reverse.t）。下面我将补充以下测试。\n# https://github.com/rakudo/rakudo/issues/1632 { sub subroutine($expected, |actual) { is actual.gist, $expected, \u0026quot;Сolonpair exists\u0026quot; } subroutine('\\(:foo(-1))', :foo(3 R- 2)); } 该测试有一个功能，有两个参数 - 正常和捕获。在函数体中，第一个参数和传递的 Capture 的字符串表示进行比较。你可以使用 make 对新构建的编译器进行单独测试。\n\u0026gt; make t/spec/S03-metaops/reverse.t [...] ok 69 - [R~]= not ok 70 - Colonpair exists # Failed test 'Colonpair exists' # at t/spec/S03-metaops/reverse.t line 191 # expected: '\\(:foo(-1))' # got: '\\(-1)' # You planned 69 tests, but ran 70 # You failed 1 test of 70 你可以看到，测试失败了（如预期）。还有一个单独的说明，系统预计69次测试，但收到70次。这是基于 TAP 的测试系统的特点 - 必须在文件的顶部修正传递给 plan 函数的数字。现在测试崩溃了，但编号没有受到影响。你可以开始修复它。\n凝视法 一开始我很相信任务上的标签 - 如果是解析的话，一定是源码解析阶段的某个地方出现了问题。目前我的认识如下：\n 基础解析器代码在文件 rakudo/src/Perl6/Grammar.nqp 中。 这个解析器是从 nqp/src/HLL/Grammar.nqp 文件中的基础解析器继承的。 元操作符的解析和工作方式都差不多，你可以通过仔细观察来发现不同之处。  我在基础解析器代码中找到了对元操作符的引用。\ntoken infix_prefix_meta_operator:sym\u0026lt;R\u0026gt; { \u0026lt;sym\u0026gt; \u0026lt;infixish('R')\u0026gt; {} \u0026lt;.can_meta($\u0026lt;infixish\u0026gt;, \u0026quot;reverse the args of\u0026quot;)\u0026gt; \u0026lt;O=.revO($\u0026lt;infixish\u0026gt;)\u0026gt; } token infix_prefix_meta_operator:sym\u0026lt;Z\u0026gt; { \u0026lt;sym\u0026gt; \u0026lt;infixish('Z')\u0026gt; {} \u0026lt;.can_meta($\u0026lt;infixish\u0026gt;, \u0026quot;zip with\u0026quot;)\u0026gt; \u0026lt;O(|%list_infix)\u0026gt; } 这需要对 Raku grammar 有一定的了解。据我所知，原来这两个元运算符在解析上并没有根本的区别。一段时间后，在解析器的源代码中挖得够多了，我开始怀疑解析工作是否正确。认为代码 my $r = :foo(3 R- 2); say $r; # Output: foo =\u0026gt; -1 正确工作的建议 - 问题恰恰发生在调用函数时。显然，我白白相信了任务栏上的标签。\n编译器将帮助我们 颇为迟钝的我想起了我从一开始就应该做的事情。Rakudo 编译器有 --target 调试开关。它取编译器阶段的名称，你想将其结果输出到控制台并退出。我想看看 --target=parse（因为我只知道这一个）。\n我从 ~/dev-rakudo/rakudo 文件夹中使用 rakumo-m，这样我就不必等待通过 make install 命令将所需文件复制到 ~/dev-rakudo-install。简单的脚本可以这样运行。更复杂的脚本必须在 make install 之后从 -install 中运行。\n\u0026gt; cat ~/test.raku sub s(|c) { say c } s(:foo(3 R- 2)); s(:foo(3 Z- 2)); \u0026gt; ./rakudo-m --target=parse ~/test.raku [...] - args: (:foo(3 R- 2)) - semiarglist: :foo(3 R- 2) - arglist: 1 matches - EXPR: :foo(3 R- 2) - colonpair: :foo(3 R- 2) - identifier: foo - coloncircumfix: (3 R- 2) - circumfix: (3 R- 2) - semilist: 3 R- 2 - statement: 1 matches - EXPR: R- 2 [...] - args: (:foo(3 Z- 2)) - semiarglist: :foo(3 Z- 2) - arglist: 1 matches - EXPR: :foo(3 Z- 2) - colonpair: :foo(3 Z- 2) - identifier: foo - coloncircumfix: (3 Z- 2) - circumfix: (3 Z- 2) - semilist: 3 Z- 2 - statement: 1 matches - EXPR: Z- 2 [...] 结论：R 和 Z 的解析是一样的。\n这不是解析 所有被解析的东西都会被传递给所谓的 Action，把字词变成一棵语法树。在我们的例子中，Actions 位于文件 rakudo/src/Perl6/Actions.nqp 和 nqp/src/HLL/Actions.nqp 中。这里就比较容易搞清楚了，毕竟是代码，是 grammar。\n我在主 Actions 中找到了以下代码。\n[...] elsif $\u0026lt;infix_prefix_meta_operator\u0026gt; { [...] if $metasym eq 'R' { $helper := '\u0026amp;METAOP_REVERSE'; $t := nqp::flip($t) if $t; } elsif $metasym eq 'X' { $helper := '\u0026amp;METAOP_CROSS'; $t := nqp::uc($t); } elsif $metasym eq 'Z' { $helper := '\u0026amp;METAOP_ZIP'; $t := nqp::uc($t); } my $metapast := QAST::Op.new( :op\u0026lt;call\u0026gt;, :name($helper), WANTED($basepast,'infixish') ); $metapast.push(QAST::Var.new(:name(baseop_reduce($base\u0026lt;OPER\u0026gt;\u0026lt;O\u0026gt;.made)), :scope\u0026lt;lexical\u0026gt;)) if $metasym eq 'X' || $metasym eq 'Z'; [...] 它说，如果在代码中解析了元操作符 R、Z 或 X，就应该在语法树中添加一些 METAOP_ 函数调用。在 Z 和 X 的情况下，它会多一个参数，即某种还原函数。所有这些功能都可以在 rakudo/src/core.c/metaops.pm6 中找到。\nsub METAOP_REVERSE(\\op) is implementation-detail { -\u0026gt; |args { op.(|args.reverse) } } sub METAOP_ZIP(\\op, \u0026amp;reduce) is implementation-detail { nqp::if(op.prec('thunky').starts-with('.'), -\u0026gt; +lol { my $arity = lol.elems; [...] }, -\u0026gt; +lol { Seq.new(Rakudo::Iterator.ZipIterablesOp(lol,op)) } ) } 给你：\n \\op 是由我们的元操作符，即-，在前面的操作。 Trait implementation-detail 只是表明这不是公共代码，是编译器实现的一部分。 由于-操作没有笨重的特性，所以 \u0026amp;reduce 函数不会参与计算，Z 的结果是 Seq.new(...)。 R 的结果是一个操作调用 - 参数顺序相反。  这时我想起还有一个 - 目标，即星。它将显示行动的结果。\n\u0026gt; ./rakudo-m --target=ast ~/test.raku [...] - QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R- - QAST::Op(call \u0026amp;METAOP_REVERSE) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt; - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt; - QAST::Want \u0026lt;wanted\u0026gt; 3 - QAST::WVal(Int) - Ii - QAST::IVal(3) 3 - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::WVal(Int) - Ii - QAST::IVal(2) 2 [...] - QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;7\u0026gt; s(:foo(3 Z- 2)) - QAST::Op+{QAST::SpecialArg}(:named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;8\u0026gt; :before_promotion\u0026lt;?\u0026gt; Z- - QAST::Op(call \u0026amp;METAOP_ZIP) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt; - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt; - QAST::Var(lexical \u0026amp;METAOP_REDUCE_LEFT) - QAST::Want \u0026lt;wanted\u0026gt; 3 - QAST::WVal(Int) - Ii - QAST::IVal(3) 3 - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::WVal(Int) - Ii - QAST::IVal(2) 2 [...] 一如所料。除了调用不同的 METAOP_ 函数外，所有的东西几乎都是一样的。从它们的代码中我们可以知道，原则上这些函数的不同之处在于返回值的类型 - 分别是 Int 和 Seq。众所周知，Raku 对不同类型的对象的上下文相当敏感\u0026hellip;\u0026hellip;我想，它关注的可能是返回值。我试着用下面的方式修改代码。\nsub METAOP_REVERSE(\\op) is implementation-detail { -\u0026gt; |args { Seq.new(op.(|args.reverse)) } } 编译、运行。\n\u0026gt; make [...] Stage start : 0.000 Stage parse : 61.026 Stage syntaxcheck: 0.000 Stage ast : 0.000 Stage optimize : 7.076 Stage mast : 14.120 Stage mbc : 3.941 [...] \u0026gt; ./rakudo-m ~/test.raku \\(-1) \\(:foo((1,).Seq)) 一切都没有改变。所以，不是返回值\u0026hellip;\u0026hellip;想了想，不知道为什么结果又是 -1 而不是 (-1,).Seq。而且，从代码来看，Seq 根本就没有一个合适的构造函数。下一次，作为一些疯狂的事情，我尝试调用 METAOP_REVERSE 结果只是为了崩溃。\nsub METAOP_REVERSE(\\op) is implementation-detail { -\u0026gt; |args { die } } 编译、运行。\n\u0026gt; make [...] \u0026gt; ./rakudo-m ~/test.raku \\(-1) \\(:foo((1,).Seq)) 怎么会呢？语法树中包含了对 METAOP_REVERSE 的调用，它的代码应该是折叠的，但计算仍然进行，我们得到 -1。\n这些都不是《行动》。\n这里我的目光落在编译器的构建日志上。它是一些阶段被列在那里。我随机试了 --target=mast。\n\u0026gt; ./rakudo-m --target=mast ~/test.raku [...] MAST::Frame name\u0026lt;s\u0026gt;, cuuid\u0026lt;1\u0026gt; Local types: 0\u0026lt;obj\u0026gt;, 1\u0026lt;obj\u0026gt;, 2\u0026lt;obj\u0026gt;, 3\u0026lt;obj\u0026gt;, 4\u0026lt;int\u0026gt;, 5\u0026lt;str\u0026gt;, 6\u0026lt;obj\u0026gt;, 7\u0026lt;obj\u0026gt;, 8\u0026lt;obj\u0026gt;, Lexical types: 0\u0026lt;obj\u0026gt;, 1\u0026lt;obj\u0026gt;, 2\u0026lt;obj\u0026gt;, 3\u0026lt;obj\u0026gt;, 4\u0026lt;obj\u0026gt;, Lexical names: 0\u0026lt;c\u0026gt;, 1\u0026lt;$¢\u0026gt;, 2\u0026lt;$!\u0026gt;, 3\u0026lt;$/\u0026gt;, 4\u0026lt;$*DISPATCHER\u0026gt;, Lexical map: $!\u0026lt;2\u0026gt;, c\u0026lt;0\u0026gt;, $*DISPATCHER\u0026lt;4\u0026gt;, $¢\u0026lt;1\u0026gt;, $/\u0026lt;3\u0026gt;, Outer: name\u0026lt;\u0026lt;unit\u0026gt;\u0026gt;, cuuid\u0026lt;2\u0026gt; [...] 某种不可读的矩阵。星号和桅杆之间有一个阶段性的优化。\n\u0026gt; ./rakudo-m --target=optimize ~/test.raku [...] - QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Op(call \u0026amp;infix:\u0026lt;-\u0026gt;) :METAOP_opt_result\u0026lt;?\u0026gt; - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::WVal(Int) - Ii - QAST::IVal(2) 2 - QAST::Want \u0026lt;wanted\u0026gt; 3 - QAST::WVal(Int) - Ii - QAST::IVal(3) 3 [...] - QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;7\u0026gt; s(:foo(3 Z- 2)) - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;8\u0026gt; :before_promotion\u0026lt;?\u0026gt; Z- - QAST::Op(callstatic \u0026amp;METAOP_ZIP) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt; - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt; - QAST::Var(lexical \u0026amp;METAOP_REDUCE_LEFT) - QAST::Want \u0026lt;wanted\u0026gt; 3 - QAST::WVal(Int) - Ii - QAST::IVal(3) 3 - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::WVal(Int) - Ii - QAST::IVal(2) 2 [...] 哈，就是这样。在优化阶段后，行将失踪。\n QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R-. 并将整个 METAOP_REVERSE 调用替换为通常的操作 (\u0026amp;infix:\u0026lt;-\u0026gt;)。所以问题一定在优化器的某个地方。  只有在 optim_nameless_call 方法中才会提到 \u0026amp;METAOP_ASSIGN，其中 QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;)。显然，这个操作负责生成一个命名对 - 它已经有了一个名字（命名参数），它需要计算值。从优化 _ 无名方法的执行路径来看，我们可以得出结论，我们对最后一个块感兴趣。\n[...] elsif self.op_eq_core($metaop, '\u0026amp;METAOP_REVERSE') { return NQPMu unless nqp::istype($metaop[0], QAST::Var) \u0026amp;\u0026amp; nqp::elems($op) == 3; return QAST::Op.new(:op\u0026lt;call\u0026gt;, :name($metaop[0].name), $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1; } [...] 让我提醒你，优化前的树是这样的。\n[...] - QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R- - QAST::Op(call \u0026amp;METAOP_REVERSE) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt; - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt; - QAST::Want \u0026lt;wanted\u0026gt; 3 - QAST::Want \u0026lt;wanted\u0026gt; 2 [...] 而精简之后，是这样的。\n[...] - QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Op(call \u0026amp;infix:\u0026lt;-\u0026gt;) :METAOP_opt_result\u0026lt;?\u0026gt; - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::Want \u0026lt;wanted\u0026gt; 3 [...] 也就是说，优化 _nameless_call 做了以下工作。\n如果我们的 QAST::Op+{QAST::SpecialArg} 操作没有三个参数，如果 METAOP_REVERSE 调用没有一个正确的类型，我们就返回空。这不是我们的情况。 否则，我们将返回一个新的操作，代替我们的 QAST::Op+{QAST::SpecialArg} 操作，以相反的顺序调用 \u0026amp;infix:\u0026lt;-\u0026gt; 参数。就是说，把结果打包成一对就没了。\n在摸索了一下如何解决这个问题，并阅读了 QAST::SpecialArg 和 QAST::Node 的实现后，我想到了下面的代码。\n[...] elsif self.op_eq_core($metaop, '\u0026amp;METAOP_REVERSE') { return NQPMu unless nqp::istype($metaop[0], QAST::Var) \u0026amp;\u0026amp; nqp::elems($op) == 3; my $opt_result := QAST::Op.new(:op\u0026lt;call\u0026gt;, :name($metaop[0].name), $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1; if $op.named { $opt_result.named($op.named) } # 添加选项 named if $op.flat { $opt_result.flat($op.flat) } # 添加选项 flat return $opt_result; } [...] 还有木头。\n[...] - QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Op+{QAST::SpecialArg}(call \u0026amp;infix:\u0026lt;-\u0026gt; :named\u0026lt;foo\u0026gt;) :METAOP_opt_result\u0026lt;?\u0026gt; - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::Want \u0026lt;wanted\u0026gt; 3 [...] 命名的参数返回到它的位置。测试也开始通过。\n\u0026gt; make t/spec/S03-metaops/reverse.t [...] All tests successful. Files=1, Tests=70, 3 wallclock secs ( 0.03 usr 0.01 sys + 3.61 cusr 0.17 csys = 3.82 CPU) Result: PASS 我们本可以就此打住，但这是编译器优化器的代码，它的结果是一个有两个整数参数的方法调用。我认为这在某种程度上是次优的。如果我们将返回表达式改为返回 self.visit_op: $opt_result;，对产生的非优化操作调用优化器，那么产生的树就会像这样。\n[...] - QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Want+{QAST::SpecialArg}(:named\u0026lt;foo\u0026gt;) - QAST::WVal+{QAST::SpecialArg}(Int :named\u0026lt;foo\u0026gt;) - QAST::IVal(-1) [...] 现在一切都很理想。\n分享成果 我们已经到了终点线。现在我们只需要分享我们的经验。\n 重要的是：运行所有的 make spectest 测试，确保没有新的东西被破坏。 在 GitHub 上使用 Rakudo 编译器和测试制作 fork 仓库。 将 fork 仓库添加为新的 git 远程仓库。 cd ~/dev-rakudo/rakudo \u0026amp;\u0026amp; git remote add fork 。 cd ~/dev-rakudo/t/spec \u0026amp;\u0026amp; git remote add fork 。  重要：确保两个仓库在 git 中都有正确的用户名和用户邮箱。\n提交到两个版本库，详细说明你为什么做了哪些改动，并添加对原始问题跟踪器的引用。\n运行提交。\ncd ~/dev-rakudo/rakudo \u0026amp;\u0026amp; git push fork cd ~/dev-rakudo/t/spec \u0026amp;\u0026amp; git push fork 向两个仓库提出拉取请求。在他们的描述中，最好是相互参照和原任务。\n结论 对开源软件的贡献是：\n 趣味性和趣味性。 给你的感觉是，你正在做一些有用的事情，你真的是。 让你认识新的有趣和专业的人（任何关于 Raku 的问题都会在 #raku IRC 频道中得到回答）。 解决非标准任务，没有截止日期的压力，是一种很好的体验。  选择你觉得最舒服的角色等级，去做新的任务吧!\n"},"name":"为最年轻的 Raku 贡献力量","published":"2021-02-16T00:00:00+08:00","summary":"Contributing to Raku","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/"},{"content":{"html":"\u003cp\u003e[113] 发表于2021年1月30日。\n这是我对 \u003ca href=\"https://perlweeklychallenge.org/blog/perl-weekly-challenge-097/\"\u003ePerl 每周挑战#097\u003c/a\u003e 的回应。\u003c/p\u003e\n\u003ch2 id=\"挑战-0971-凯撒密码\"\u003e挑战 #097.1: 凯撒密码\u003c/h2\u003e\n\u003cp\u003e给你一个只包含字母 \u003ccode\u003eA..Z\u003c/code\u003e 的字符串 \u003ccode\u003e$S\u003c/code\u003e 和一个数字 \u003ccode\u003e$N\u003c/code\u003e。\n写一个脚本，用\u003ca href=\"https://en.wikipedia.org/wiki/Caesar_cipher\"\u003e凯撒密码\u003c/a\u003e对给定的字符串 \u003ccode\u003e$S\u003c/code\u003e 进行加密，左移大小为 \u003ccode\u003e$N\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e例子:\n输入: $S = \u0026ldquo;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026rdquo;, $N = 3\n输出: \u0026ldquo;QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\u0026rdquo;\u003c/p\u003e\n\u003cp\u003ePlain:    ABCDEFGHIJKLMNOPQRSTUVWXYZ\nCipher:   XYZABCDEFGHIJKLMNOPQRSTUVW\u003c/p\u003e\n\u003cp\u003ePlaintext:  THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\nCiphertext: QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;只用字母 \u003ccode\u003eA...Z\u003c/code\u003e\u0026rdquo; 的表述是错误的，因为例子中也有几个空格。因此，应该允许这些空格。\u003c/p\u003e\n\u003cp\u003e文件: caesar-cipher\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e#! /usr/bin/env raku\n\nsubset AZ-space of Str where /^ \u0026lt;[ A .. Z \\s ]\u0026gt;+ $/;   # [1]\nsubset PosInt of Int where -25 \u0026lt;= $_ \u0026lt;= 25;            # [2]\n\nunit sub MAIN (AZ-space $S = 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG',\n               PosInt $N = 3);                         # [3]\n\nsay $S.comb.map({ caesar($_, $N) }).join;              # [4]\n\nsub caesar ($char, $shift)\n{\n  return $char if $char eq \u0026quot; \u0026quot;;                        # [5]\n\n  my $code = $char.ord;                                # [6]\n\n  $code -= $shift;                                     # [7]\n\n  $code += 26 if $code \u0026lt; 65;  # 'A'                    # [8]\n  $code -= 26 if $code \u0026gt; 90;  # 'Z'                    # [8a]\n\n  return $code.chr;                                    # [9]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e[1] 所允许的字符 (或 «特定领域字母»).\u003c/p\u003e\n\u003cp\u003e[2] 挑战说左移值是一个数字。允许除整数以外的任何东西是没有意义的，所以我把值限制在这个类型。负值应该是可以的，它们意味着右移值（而不是左移）。\u003c/p\u003e\n\u003cp\u003e[3] 参数，默认值为挑战中给出的值。\u003c/p\u003e\n\u003cp\u003e[4] 将字符串分割成单个字符（用梳子(comb)，在每个字符上应用 \u0026ldquo;caesar\u0026rdquo; 函数（用map），再次将字符连接成一个字符串（用join），然后打印出来。\u003c/p\u003e\n\u003cp\u003e[5] 不移动空格。\u003c/p\u003e\n\u003cp\u003e[6] 获取字符的代码点。\u003c/p\u003e\n\u003cp\u003e[7] 减去移位值（当我们向左移位时，或在字母表中降低移位值）。\u003c/p\u003e\n\u003cp\u003e[8] 绕回, 如果我们移出A-Z范围，这里为更低 - 或更高的 [8b]。\u003c/p\u003e\n\u003cp\u003e[9] 获取指定代码点的字符。\u003c/p\u003e\n\u003cp\u003e查看 docs.raku.org/routine/ord 获取更多关于 ord 的信息。\u003c/p\u003e\n\u003cp\u003e查看 docs.raku.org/routine/chr 获取更多关于 chr 的信息。\u003c/p\u003e\n\u003cp\u003e运行它:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3\nQEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\n\n$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3\nWKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ\n\n$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13\nGUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT\n\n$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13\nGUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRaku 有一个 ords 变体，它接收一整个字符串，而不是一个字符作为 ord。还有 chrs，它接收一个代码点数组，并将它们变成一个字符串，而不是像 chr 那样接收一个字符的代码点。让我们用它们来写一个更短的程序。\u003c/p\u003e\n\u003cp\u003e文件: caesar-cipher-map\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e#! /usr/bin/env raku\n\nsubset AZ-space of Str where /^ \u0026lt;[ A .. Z \\s ]\u0026gt;+ $/;\nsubset PosInt of Int where -25 \u0026lt;= $_ \u0026lt;= 25;\n\nunit sub MAIN (AZ-space $S = 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG',\n               PosInt $N = 3);\n\nsay caesar($S, $N);\n\nsub caesar ($string, $shift)\n{\n  return $string.ords.map({$_ == 32 ?? 32 !! (($_ - $shift - 65) % 26 ) + 65}).chrs;\n    # #################### # 1a ############# ############ # 1b  # 1c ## 1d\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e[1] 我们使用map来改变各个代码点。我们让代码点为32的空间单独存在[1a]。每一个其他的值我们都还原成0到25之间的数字（通过减去第一个字母的代码点（A：65）和移位值[1b]）。模数运算符 (%) 为我们处理负值，做正确的事情。例如：-2 % 26 -\u0026gt; 24 [1c]。然后我们添加调整值到它们应该在的位置(从A到Z)[1d]，然后我们将整个数组的代码点变成一个字符串。\u003c/p\u003e\n\u003cp\u003e查看 docs.raku.org/routine/ords 获取更多关于 ords 的信息。\u003c/p\u003e\n\u003cp\u003e查看 docs.raku.org/routine/chrs 获取更多关于 chrs 的信息。\u003c/p\u003e\n\u003cp\u003e运行它的结果和之前一样。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3\nQEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\n\n$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3\nWKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ\n\n$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13\nGUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT\n\n$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13\nGUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"perl-版本\"\u003ePerl 版本\u003c/h2\u003e\n\u003cp\u003e这是对第一个 Raku 版的直接翻译。\u003c/p\u003e\n\u003cp\u003eFile: caesar-cipher-perl\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"ch\"\u003e#! /usr/bin/env perl\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"nn\"\u003estrict\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"nn\"\u003ewarnings\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"nn\"\u003efeature\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#39;say\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"nn\"\u003efeature\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#39;signatures\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eno\u003c/span\u003e \u003cspan class=\"nn\"\u003ewarnings\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;experimental::signatures\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$S\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eshift\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e@ARGV\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"sr\"\u003e//\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"nb\"\u003edie\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Illegal characters\u0026#34;\u003c/span\u003e \u003cspan class=\"k\"\u003eunless\u003c/span\u003e \u003cspan class=\"nv\"\u003e$S\u003c/span\u003e \u003cspan class=\"o\"\u003e=~\u003c/span\u003e\u003cspan class=\"sr\"\u003e /^[A-Z\\s]+$/\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$N\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eshift\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e@ARGV\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"sr\"\u003e//\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"nb\"\u003edie\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Illegal shift $N\u0026#34;\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nv\"\u003e$N\u003c/span\u003e \u003cspan class=\"o\"\u003e!~\u003c/span\u003e \u003cspan class=\"sr\"\u003e/^\\-?\\d+$/\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"nv\"\u003e$N\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e25\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"nv\"\u003e$N\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e25\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003esay\u003c/span\u003e \u003cspan class=\"nb\"\u003ejoin\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003emap\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003ecaesar\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$_\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nv\"\u003e$N\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"nb\"\u003esplit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"sr\"\u003e//\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nv\"\u003e$S\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003ecaesar\u003c/span\u003e \u003cspan class=\"p\"\u003e($char, $shift)\n\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nv\"\u003e$char\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nv\"\u003e$char\u003c/span\u003e \u003cspan class=\"ow\"\u003eeq\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$code\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eord\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$char\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n  \u003cspan class=\"nv\"\u003e$code\u003c/span\u003e \u003cspan class=\"o\"\u003e-=\u003c/span\u003e \u003cspan class=\"nv\"\u003e$shift\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"nv\"\u003e$code\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"mi\"\u003e26\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nv\"\u003e$code\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e65\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# \u0026#39;A\u0026#39;\u003c/span\u003e\n  \u003cspan class=\"nv\"\u003e$code\u003c/span\u003e \u003cspan class=\"o\"\u003e-=\u003c/span\u003e \u003cspan class=\"mi\"\u003e26\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nv\"\u003e$code\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e90\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# \u0026#39;Z\u0026#39;\u003c/span\u003e\n\n  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nb\"\u003echr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$code\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e运行它的结果和 Raku 版一样。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3\nQEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\n\n$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3\nWKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ\n\n$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13\nGUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT\n\n$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13\nGUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"挑战-0972二进制子字符串binary-substrings\"\u003e挑战 #097.2：二进制子字符串(Binary Substrings)\u003c/h2\u003e\n\u003cp\u003e给你一个二进制字符串 \u003ccode\u003e$B\u003c/code\u003e 和一个整数 \u003ccode\u003e$S\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e写一个脚本来拆分大小为 \u003ccode\u003e$S\u003c/code\u003e 的二进制字符串 \u003ccode\u003e$B\u003c/code\u003e，然后找出使其相同的最小翻转次数。\u003c/p\u003e\n\u003cp\u003e例 1:\n输入: $B = “101100101”, $S = 3\n输出: 1\u003c/p\u003e\n\u003cp\u003e二进制子字符串:\n\u0026ldquo;101\u0026rdquo;: 0 flip\n\u0026ldquo;100\u0026rdquo;: 1 flip to make it \u0026ldquo;101\u0026rdquo;\n\u0026ldquo;101\u0026rdquo;: 0 flip\u003c/p\u003e\n\u003cp\u003e例 2:\n输入 $B = “10110111”, $S = 4\n输出: 2\u003c/p\u003e\n\u003cp\u003e二进制子字符串:\n\u0026ldquo;1011\u0026rdquo;: 0 flip\n\u0026ldquo;0111\u0026rdquo;: 2 flips to make it \u0026ldquo;1011\u0026rdquo;\u003c/p\u003e\n\u003cp\u003e我们先从第一个例子中的二进制子字符串中砍掉3个字符块。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; say \u0026quot;101100101\u0026quot;.comb(3);   # -\u0026gt; (101 100 101)\n\u0026gt; say \u0026quot;1011001010\u0026quot;.comb(3);  # -\u0026gt; (101 100 101 0)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e第二行显示了如果长度不匹配会发生什么。这就给了我们一个非法的值，因为我们不能将一位数翻转为三位数的值。所以我们必须添加一个检查。\u003c/p\u003e\n\u003cp\u003e然后我们将第一个子串与其余的子串进行比较，一次一个。在这里使用bitwise XOR（Exclusive OR）运算符是一个合理的选择。这给了我们一个二进制值，其中1的数量就是该子串的翻转次数。Raku确实有一个XOR运算符。+^. 但是它 \u0026ldquo;将两个参数都强制为Int，并进行位智XOR操作\u0026rdquo;(根据文档\u0026quot;；参见docs.raku.org/language/operators#infix_+^)。\u003c/p\u003e\n\u003cp\u003e我们可以在进行XOR操作之前，将二进制值转换为十进制值。让我们试试。\u003c/p\u003e\n\u003cp\u003e获取翻转的次数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; say (\u0026quot;10101\u0026quot;.parse-base(2) +^ \u0026quot;10111\u0026quot;.parse-base(2)).base(2).comb.sum;  # -\u0026gt; 1\n\u0026gt; say (\u0026quot;11101\u0026quot;.parse-base(2) +^ \u0026quot;10111\u0026quot;.parse-base(2)).base(2).comb.sum;  # -\u0026gt; 2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这当然可行，但需要大量的代码。所以我将使用一个更简单的方法 - 逐个比较每个数字。\u003c/p\u003e\n\u003cp\u003eFile: binary-substring\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e#! /usr/bin/env raku\n\nsubset BinaryString where /^ \u0026lt;[01]\u0026gt;+ $/;                    # [1]\nsubset PosInt of Int where * \u0026gt; 0;                           # [2]\n\nunit sub MAIN (BinaryString $B = '101100101',               # [1]\n               PosInt $S where $B.chars %% $S = 3,          # [2]\n\t       :v(:$verbose));\n\nmy @B     = $B.comb($S.Int);                                # [3]\nmy $first = @B.shift;                                       # [4]\nmy $total = 0;                                              # [5]\n\nfor @B -\u0026gt; $current                                          # [6]\n{\n  my $flip = bit-diff($first, $current);                    # [7]\n  $total += $flip;                                          # [8]\n  say \u0026quot;: $first -\u0026gt; $current -\u0026gt; Flip: $flip\u0026quot; if $verbose;\n}\n\nsay $total;                                                 # [9]\n\nsub bit-diff ($a, $b)                                       # [7]\n{\n  my $flip = 0;                                             # [10]\n\n  for ^$a.chars -\u0026gt; $index                                   # [11]\n  {\n    $flip++ if $a.substr($index,1) ne $b.substr($index,1);  # [12]\n  }\n\n  return $flip;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e[1] 确保二进制字符串是合法的（只包含 \u0026ldquo;0 \u0026ldquo;和 \u0026ldquo;1\u0026rdquo;）。\u003c/p\u003e\n\u003cp\u003e[2] 确保是一个正整数，同时确保字符串是被它偶数分割的。(例如，\u0026ldquo;4 \u0026ldquo;给我们提供了长度为4的子串，如果最后一个较短，程序将中止。)\u003c/p\u003e\n\u003cp\u003e[3] 梳子通常用于将一个字符串分割成单个字符，但我们可以通过指定长度来获得每个子字符串中的多个字符，比如这样。\u003c/p\u003e\n\u003cp\u003e[4] 例子首先将第一个子串与自己进行比较，给出零翻转。这是愚蠢的(ish)，所以我跳过这一点，把第一个子串移出。\u003c/p\u003e\n\u003cp\u003e[5] 结果会到这里。\u003c/p\u003e\n\u003cp\u003e[6] 对于每一个子串（除了第一个，见[4]）。\u003c/p\u003e\n\u003cp\u003e[7] 获取每个子串的翻转次数。\u003c/p\u003e\n\u003cp\u003e[8] 并将其添加到总数中。\u003c/p\u003e\n\u003cp\u003e[9] 打印它。\u003c/p\u003e\n\u003cp\u003e[10] 翻转的数量会在这里。\u003c/p\u003e\n\u003cp\u003e[11] 对于两个子串中的每个索引（具有相同的长度）。\u003c/p\u003e\n\u003cp\u003e[12] - 如果给定位置上的字符不同，则在总数的基础上加1，意味着移动。\u003c/p\u003e\n\u003cp\u003eSee docs.raku.org/routine/comb for more information about comb.\u003c/p\u003e\n\u003cp\u003e运行它。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ./binary-substring \u0026quot;101100101\u0026quot; 3\n 1\n\n$ ./binary-substring -v \u0026quot;101100101\u0026quot; 3\n: 101 -\u0026gt; 100 -\u0026gt; Flip: 1\n: 101 -\u0026gt; 101 -\u0026gt; Flip: 0\n1\n\n$ ./binary-substring \u0026quot;10110111\u0026quot; 4\n2\n\n$ ./binary-substring -v \u0026quot;10110111\u0026quot; 4\n: 1011 -\u0026gt; 0111 -\u0026gt; Flip: 2\n2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e看起来不错。\u003c/p\u003e\n\u003ch2 id=\"perl\"\u003ePerl\u003c/h2\u003e\n\u003cp\u003e这是对 Raku 版本的直接翻译，只是我必须实现 \u0026ldquo;comb\u0026rdquo;。\u003c/p\u003e\n\u003cp\u003e文件： binary-substring-perl\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e#! /usr/bin/env perl\n\nuse strict;\nuse warnings;\nuse feature 'say';\nuse feature 'signatures';\nuse Getopt::Long;\n\nno warnings \u0026quot;experimental::signatures\u0026quot;;\n\nmy $verbose = 0;\n\nGetOptions(\u0026quot;verbose\u0026quot;  =\u0026gt; \\$verbose);\n\nmy $B = shift(@ARGV) // '101100101';\n\ndie \u0026quot;Not a binary number\u0026quot; unless $B =~ /^[01]+$/;\n\nmy $S = shift(@ARGV) // 3;\n\ndie \u0026quot;Not an integer\u0026quot; unless $S =~ /^[1-9][0-9]*$/;\ndie \u0026quot;Not a legal length\u0026quot; if length($B) % $S;\n\nmy @B     =  comb($B, $S);\nmy $first = shift(@B);\nmy $total = 0;\n\nfor my $current (@B)\n{\n  my $flip = bit_diff($first, $current);\n  $total += $flip;\n  say \u0026quot;: $first -\u0026gt; $current -\u0026gt; Flip: $flip\u0026quot; if $verbose;\n}\n\nsay $total;\n\nsub bit_diff ($a, $b)\n{\n  my $flip = 0;\n\n  for my $index (0 .. length($a))\n  {\n    $flip++ if substr($a, $index,1) ne substr($b, $index,1);\n  }\n\n  return $flip;\n}\n\nsub comb ($string, $length = 1)  # [1]\n{\n  my @result;\n\n  while ($string)\n  {\n    push(@result, substr($string, 0, $length));\n    $string = substr($string, $length);\n  }\n  return @result;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e[1] 缺失的 Raku 例程 \u0026ldquo;comb\u0026rdquo;。可选的第二个参数指定了它所返回的每个子串中所包含的（第一个参数的）子串长度。\u003c/p\u003e\n\u003cp\u003e运行它的结果与 Raku 版本相同。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ./binary-substring-perl \u0026quot;101100101\u0026quot; 3\n1\n\n$ ./binary-substring-perl -v \u0026quot;101100101\u0026quot; 3\n: 101 -\u0026gt; 100 -\u0026gt; Flip: 1\n: 101 -\u0026gt; 101 -\u0026gt; Flip: 0\n1\n\n$ ./binary-substring-perl \u0026quot;101100111\u0026quot; 3\n2\n\n$ ./binary-substring-perl -v \u0026quot;101100111\u0026quot; 3\n: 101 -\u0026gt; 100 -\u0026gt; Flip: 1\n: 101 -\u0026gt; 111 -\u0026gt; Flip: 1\n2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e就是这样。\u003c/p\u003e\n","text":"[113] 发表于2021年1月30日。 这是我对 Perl 每周挑战#097 的回应。\n挑战 #097.1: 凯撒密码 给你一个只包含字母 A..Z 的字符串 $S 和一个数字 $N。 写一个脚本，用凯撒密码对给定的字符串 $S 进行加密，左移大小为 $N。\n例子: 输入: $S = \u0026ldquo;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026rdquo;, $N = 3 输出: \u0026ldquo;QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\u0026rdquo;\nPlain: ABCDEFGHIJKLMNOPQRSTUVWXYZ Cipher: XYZABCDEFGHIJKLMNOPQRSTUVW\nPlaintext: THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG Ciphertext: QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\n\u0026ldquo;只用字母 A...Z\u0026rdquo; 的表述是错误的，因为例子中也有几个空格。因此，应该允许这些空格。\n文件: caesar-cipher\n#! /usr/bin/env raku subset AZ-space of Str where /^ \u0026lt;[ A .. Z \\s ]\u0026gt;+ $/; # [1] subset PosInt of Int where -25 \u0026lt;= $_ \u0026lt;= 25; # [2] unit sub MAIN (AZ-space $S = 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG', PosInt $N = 3); # [3] say $S.comb.map({ caesar($_, $N) }).join; # [4] sub caesar ($char, $shift) { return $char if $char eq \u0026quot; \u0026quot;; # [5] my $code = $char.ord; # [6] $code -= $shift; # [7] $code += 26 if $code \u0026lt; 65; # 'A' # [8] $code -= 26 if $code \u0026gt; 90; # 'Z' # [8a] return $code.chr; # [9] } [1] 所允许的字符 (或 «特定领域字母»).\n[2] 挑战说左移值是一个数字。允许除整数以外的任何东西是没有意义的，所以我把值限制在这个类型。负值应该是可以的，它们意味着右移值（而不是左移）。\n[3] 参数，默认值为挑战中给出的值。\n[4] 将字符串分割成单个字符（用梳子(comb)，在每个字符上应用 \u0026ldquo;caesar\u0026rdquo; 函数（用map），再次将字符连接成一个字符串（用join），然后打印出来。\n[5] 不移动空格。\n[6] 获取字符的代码点。\n[7] 减去移位值（当我们向左移位时，或在字母表中降低移位值）。\n[8] 绕回, 如果我们移出A-Z范围，这里为更低 - 或更高的 [8b]。\n[9] 获取指定代码点的字符。\n查看 docs.raku.org/routine/ord 获取更多关于 ord 的信息。\n查看 docs.raku.org/routine/chr 获取更多关于 chr 的信息。\n运行它:\n$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3 QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD $ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3 WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ $ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13 GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT $ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13 GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT Raku 有一个 ords 变体，它接收一整个字符串，而不是一个字符作为 ord。还有 chrs，它接收一个代码点数组，并将它们变成一个字符串，而不是像 chr 那样接收一个字符的代码点。让我们用它们来写一个更短的程序。\n文件: caesar-cipher-map\n#! /usr/bin/env raku subset AZ-space of Str where /^ \u0026lt;[ A .. Z \\s ]\u0026gt;+ $/; subset PosInt of Int where -25 \u0026lt;= $_ \u0026lt;= 25; unit sub MAIN (AZ-space $S = 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG', PosInt $N = 3); say caesar($S, $N); sub caesar ($string, $shift) { return $string.ords.map({$_ == 32 ?? 32 !! (($_ - $shift - 65) % 26 ) + 65}).chrs; # #################### # 1a ############# ############ # 1b # 1c ## 1d } [1] 我们使用map来改变各个代码点。我们让代码点为32的空间单独存在[1a]。每一个其他的值我们都还原成0到25之间的数字（通过减去第一个字母的代码点（A：65）和移位值[1b]）。模数运算符 (%) 为我们处理负值，做正确的事情。例如：-2 % 26 -\u0026gt; 24 [1c]。然后我们添加调整值到它们应该在的位置(从A到Z)[1d]，然后我们将整个数组的代码点变成一个字符串。\n查看 docs.raku.org/routine/ords 获取更多关于 ords 的信息。\n查看 docs.raku.org/routine/chrs 获取更多关于 chrs 的信息。\n运行它的结果和之前一样。\n$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3 QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD $ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3 WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ $ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13 GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT $ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13 GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT Perl 版本 这是对第一个 Raku 版的直接翻译。\nFile: caesar-cipher-perl\n#! /usr/bin/env perl use strict; use warnings; use feature \u0026#39;say\u0026#39;; use feature \u0026#39;signatures\u0026#39;; no warnings \u0026#34;experimental::signatures\u0026#34;; my $S = shift(@ARGV) // \u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;; die \u0026#34;Illegal characters\u0026#34; unless $S =~/^[A-Z\\s]+$/; my $N = shift(@ARGV) // 3; die \u0026#34;Illegal shift $N\u0026#34; if $N !~ /^\\-?\\d+$/ || $N \u0026lt; -25 || $N \u0026gt; 25; say join(\u0026#34;\u0026#34;, map { caesar($_, $N) } split(//, $S)); sub caesar ($char, $shift) { return $char if $char eq \u0026#34; \u0026#34;; my $code = ord($char); $code -= $shift; $code += 26 if $code \u0026lt; 65; # \u0026#39;A\u0026#39; $code -= 26 if $code \u0026gt; 90; # \u0026#39;Z\u0026#39; return chr($code); } 运行它的结果和 Raku 版一样。\n$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3 QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD $ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3 WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ $ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13 GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT $ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13 GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT 挑战 #097.2：二进制子字符串(Binary Substrings) 给你一个二进制字符串 $B 和一个整数 $S。\n写一个脚本来拆分大小为 $S 的二进制字符串 $B，然后找出使其相同的最小翻转次数。\n例 1: 输入: $B = “101100101”, $S = 3 输出: 1\n二进制子字符串: \u0026ldquo;101\u0026rdquo;: 0 flip \u0026ldquo;100\u0026rdquo;: 1 flip to make it \u0026ldquo;101\u0026rdquo; \u0026ldquo;101\u0026rdquo;: 0 flip\n例 2: 输入 $B = “10110111”, $S = 4 输出: 2\n二进制子字符串: \u0026ldquo;1011\u0026rdquo;: 0 flip \u0026ldquo;0111\u0026rdquo;: 2 flips to make it \u0026ldquo;1011\u0026rdquo;\n我们先从第一个例子中的二进制子字符串中砍掉3个字符块。\n\u0026gt; say \u0026quot;101100101\u0026quot;.comb(3); # -\u0026gt; (101 100 101) \u0026gt; say \u0026quot;1011001010\u0026quot;.comb(3); # -\u0026gt; (101 100 101 0) 第二行显示了如果长度不匹配会发生什么。这就给了我们一个非法的值，因为我们不能将一位数翻转为三位数的值。所以我们必须添加一个检查。\n然后我们将第一个子串与其余的子串进行比较，一次一个。在这里使用bitwise XOR（Exclusive OR）运算符是一个合理的选择。这给了我们一个二进制值，其中1的数量就是该子串的翻转次数。Raku确实有一个XOR运算符。+^. 但是它 \u0026ldquo;将两个参数都强制为Int，并进行位智XOR操作\u0026rdquo;(根据文档\u0026quot;；参见docs.raku.org/language/operators#infix_+^)。\n我们可以在进行XOR操作之前，将二进制值转换为十进制值。让我们试试。\n获取翻转的次数。\n\u0026gt; say (\u0026quot;10101\u0026quot;.parse-base(2) +^ \u0026quot;10111\u0026quot;.parse-base(2)).base(2).comb.sum; # -\u0026gt; 1 \u0026gt; say (\u0026quot;11101\u0026quot;.parse-base(2) +^ \u0026quot;10111\u0026quot;.parse-base(2)).base(2).comb.sum; # -\u0026gt; 2 这当然可行，但需要大量的代码。所以我将使用一个更简单的方法 - 逐个比较每个数字。\nFile: binary-substring\n#! /usr/bin/env raku subset BinaryString where /^ \u0026lt;[01]\u0026gt;+ $/; # [1] subset PosInt of Int where * \u0026gt; 0; # [2] unit sub MAIN (BinaryString $B = '101100101', # [1] PosInt $S where $B.chars %% $S = 3, # [2] :v(:$verbose)); my @B = $B.comb($S.Int); # [3] my $first = @B.shift; # [4] my $total = 0; # [5] for @B -\u0026gt; $current # [6] { my $flip = bit-diff($first, $current); # [7] $total += $flip; # [8] say \u0026quot;: $first -\u0026gt; $current -\u0026gt; Flip: $flip\u0026quot; if $verbose; } say $total; # [9] sub bit-diff ($a, $b) # [7] { my $flip = 0; # [10] for ^$a.chars -\u0026gt; $index # [11] { $flip++ if $a.substr($index,1) ne $b.substr($index,1); # [12] } return $flip; } [1] 确保二进制字符串是合法的（只包含 \u0026ldquo;0 \u0026ldquo;和 \u0026ldquo;1\u0026rdquo;）。\n[2] 确保是一个正整数，同时确保字符串是被它偶数分割的。(例如，\u0026ldquo;4 \u0026ldquo;给我们提供了长度为4的子串，如果最后一个较短，程序将中止。)\n[3] 梳子通常用于将一个字符串分割成单个字符，但我们可以通过指定长度来获得每个子字符串中的多个字符，比如这样。\n[4] 例子首先将第一个子串与自己进行比较，给出零翻转。这是愚蠢的(ish)，所以我跳过这一点，把第一个子串移出。\n[5] 结果会到这里。\n[6] 对于每一个子串（除了第一个，见[4]）。\n[7] 获取每个子串的翻转次数。\n[8] 并将其添加到总数中。\n[9] 打印它。\n[10] 翻转的数量会在这里。\n[11] 对于两个子串中的每个索引（具有相同的长度）。\n[12] - 如果给定位置上的字符不同，则在总数的基础上加1，意味着移动。\nSee docs.raku.org/routine/comb for more information about comb.\n运行它。\n$ ./binary-substring \u0026quot;101100101\u0026quot; 3 1 $ ./binary-substring -v \u0026quot;101100101\u0026quot; 3 : 101 -\u0026gt; 100 -\u0026gt; Flip: 1 : 101 -\u0026gt; 101 -\u0026gt; Flip: 0 1 $ ./binary-substring \u0026quot;10110111\u0026quot; 4 2 $ ./binary-substring -v \u0026quot;10110111\u0026quot; 4 : 1011 -\u0026gt; 0111 -\u0026gt; Flip: 2 2 看起来不错。\nPerl 这是对 Raku 版本的直接翻译，只是我必须实现 \u0026ldquo;comb\u0026rdquo;。\n文件： binary-substring-perl\n#! /usr/bin/env perl use strict; use warnings; use feature 'say'; use feature 'signatures'; use Getopt::Long; no warnings \u0026quot;experimental::signatures\u0026quot;; my $verbose = 0; GetOptions(\u0026quot;verbose\u0026quot; =\u0026gt; \\$verbose); my $B = shift(@ARGV) // '101100101'; die \u0026quot;Not a binary number\u0026quot; unless $B =~ /^[01]+$/; my $S = shift(@ARGV) // 3; die \u0026quot;Not an integer\u0026quot; unless $S =~ /^[1-9][0-9]*$/; die \u0026quot;Not a legal length\u0026quot; if length($B) % $S; my @B = comb($B, $S); my $first = shift(@B); my $total = 0; for my $current (@B) { my $flip = bit_diff($first, $current); $total += $flip; say \u0026quot;: $first -\u0026gt; $current -\u0026gt; Flip: $flip\u0026quot; if $verbose; } say $total; sub bit_diff ($a, $b) { my $flip = 0; for my $index (0 .. length($a)) { $flip++ if substr($a, $index,1) ne substr($b, $index,1); } return $flip; } sub comb ($string, $length = 1) # [1] { my @result; while ($string) { push(@result, substr($string, 0, $length)); $string = substr($string, $length); } return @result; } [1] 缺失的 Raku 例程 \u0026ldquo;comb\u0026rdquo;。可选的第二个参数指定了它所返回的每个子串中所包含的（第一个参数的）子串长度。\n运行它的结果与 Raku 版本相同。\n$ ./binary-substring-perl \u0026quot;101100101\u0026quot; 3 1 $ ./binary-substring-perl -v \u0026quot;101100101\u0026quot; 3 : 101 -\u0026gt; 100 -\u0026gt; Flip: 1 : 101 -\u0026gt; 101 -\u0026gt; Flip: 0 1 $ ./binary-substring-perl \u0026quot;101100111\u0026quot; 3 2 $ ./binary-substring-perl -v \u0026quot;101100111\u0026quot; 3 : 101 -\u0026gt; 100 -\u0026gt; Flip: 1 : 101 -\u0026gt; 111 -\u0026gt; Flip: 1 2 就是这样。\n"},"name":"Caesarean Substrings With Raku and Perl","published":"2021-02-07T00:00:00+08:00","summary":"Caesarean Substrings With Raku and Perl","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/"},{"content":{"html":"\u003ch1 id=\"if-sets-would-dwimhttpsdonaldhwtf202101if-sets-would-dwim\"\u003e\u003ca href=\"https://donaldh.wtf/2021/01/if-sets-would-dwim/\"\u003eIf Sets Would DWIM\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e每当我在 Raku 中使用集合的时候，它们经常无法 \u003ca href=\"https://docs.raku.org/language/glossary#DWIM\"\u003eDWIM\u003c/a\u003e。这是一个简短的探索，看看是否可以改进 DWIMminess。\u003c/p\u003e\n\u003cp\u003e我最近重新审视了我前段时间写的一个利用 \u003ccode\u003e(-)\u003c/code\u003e 集差运算符的脚本。这段代码有一个 bug 潜伏在那里，显而易见，因为下面的代码并没有按照我的直觉去做。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e  my @allowed = \u0026lt;m c i p l o t\u0026gt;;\n  my @chars = 'impolitic'.comb;\n\n  my @remainder = @allowed (-) @chars;\n\n  if +@remainder == 0 {\n     say 'pangram';\n  } else {\n     say \u0026quot;unused: [{@remainder.join(' ')}]\u0026quot;;\n  }\nunused: []\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e错误的原因是 \u003ccode\u003e(-)\u003c/code\u003e 产生了一个 Set，而赋值给 \u003ccode\u003e@remainder\u003c/code\u003e 会产生1项的 Array。总是这样。但不方便的是，当它是一个空集合时，它就会字符串化为一个空字符串，这只是帮助掩盖了这个潜伏的错误。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy @items = \u0026lt;a b c d e\u0026gt; (-) \u0026lt;a b c d e\u0026gt;;\nsay @items.raku;\nsay +@items;\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e[Set.new()]\n1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e解决方法比较简单。只要不赋值给数组就可以了。使用一个标量容器来代替。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $items = \u0026lt;a b c d e\u0026gt; (-) \u0026lt;a b d\u0026gt;;\nsay $items.raku;\nsay +$items;\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003eSet.new(\u0026quot;e\u0026quot;,\u0026quot;c\u0026quot;)\n2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e甚至是关联容器也可以。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy %items = \u0026lt;a b c d e\u0026gt; (-) \u0026lt;a b d\u0026gt;;\nsay %items.raku;\nsay +%items;\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e{:c(Bool::True), :e(Bool::True)}\n2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e或在赋值前明确地取出键的列表。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy @items = (\u0026lt;a b c d e\u0026gt; (-) \u0026lt;a b d\u0026gt;).keys;\nsay @items.raku;\nsay +@items;\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e[\u0026quot;e\u0026quot;, \u0026quot;c\u0026quot;]\n2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e很好，起作用了。只是不要用数组容器来处理 \u003ccode\u003eSetty\u003c/code\u003e 这样的东西。只是这并不能阻止我的直觉时不时地碰上这个错误。同一类的 bug 在我的代码中出现过好几次，因为它实在是太容易犯错了。Raku 不会告诉我，我做错了什么，因为也许是故意的。但重要的是， Raku 没有设法 DWIM。\u003c/p\u003e\n\u003cp\u003e我可以采取的另一个方法是养成添加类型信息的习惯。这样确实可以让 Raku 在我掉进这个陷阱的时候告诉我。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Str @a = \u0026lt;a b c d e\u0026gt; (-) \u0026lt;a b d\u0026gt;;\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003eType check failed in assignment to @a; expected Str but got Set (Set.new(\u0026quot;e\u0026quot;,\u0026quot;c\u0026quot;))\n  in sub  at EVAL_0 line 3\n  in block \u0026lt;unit\u0026gt; at EVAL_0 line 5\n  in block \u0026lt;unit\u0026gt; at -e line 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这是一个明显的例子，添加类型信息有助于 Raku 编译器帮助我避免引入这种 bug。\u003c/p\u003e\n\u003ch2 id=\"实验---为-set-自定义数组存储\"\u003e实验 - 为 Set 自定义数组存储\u003c/h2\u003e\n\u003cp\u003e我开始研究核心设置(core setting)，看看可以做什么。我惊喜地发现，我可以在 \u003ccode\u003eArray.STORE\u003c/code\u003e 的多重分派中添加我正在寻找的语义。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003euse MONKEY;\n\naugment class Array {\n   multi method STORE(Array:D: Set \\item --\u0026gt; Array:D) {\n       self.STORE(item.keys)\n   }\n}\n\nmy @a = \u0026lt;a b c d e\u0026gt; (-) \u0026lt;a b d\u0026gt;;\nsay @a.raku;\nsay +@a;\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e[\u0026quot;c\u0026quot;, \u0026quot;e\u0026quot;]\n2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e分享这个似乎是谨慎的，看看我的小 DWIM 是否有任何我没有考虑到的问题或缺点。一个可能的缺点是，如果你需要这样做的话，你需要使用 \u003ccode\u003e,\u003c/code\u003e 来强制将一个集合变成一个数组。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy @a = \u0026lt;a b c d e\u0026gt; (-) \u0026lt;a b d\u0026gt; , ;\nsay @a.raku;\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e[Set.new(\u0026quot;e\u0026quot;,\u0026quot;c\u0026quot;)]\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"下一步是什么\"\u003e下一步是什么\u003c/h2\u003e\n\u003cp\u003e我希望这能引发关于这个问题以及其他我们的直觉和 Raku 的行为不太一致的情况的讨论。也许还有其他相关的语言边缘可以被磨平，以消除这种危害。\u003c/p\u003e\n\u003ch2 id=\"后续\"\u003e后续\u003c/h2\u003e\n\u003cp\u003e在 \u003ca href=\"https://t.co/0QSoMxrSXf?amp=1\"\u003eReddit\u003c/a\u003e 上有一些非常有启发性的讨论，涵盖了语言语义和各种替代方法。公平地说，我建议的方法引入了更多的不一致性，而不是价值，但讨论可能会导致一个语言一致的解决方案。\u003c/p\u003e\n","text":"If Sets Would DWIM 每当我在 Raku 中使用集合的时候，它们经常无法 DWIM。这是一个简短的探索，看看是否可以改进 DWIMminess。\n我最近重新审视了我前段时间写的一个利用 (-) 集差运算符的脚本。这段代码有一个 bug 潜伏在那里，显而易见，因为下面的代码并没有按照我的直觉去做。\nmy @allowed = \u0026lt;m c i p l o t\u0026gt;; my @chars = 'impolitic'.comb; my @remainder = @allowed (-) @chars; if +@remainder == 0 { say 'pangram'; } else { say \u0026quot;unused: [{@remainder.join(' ')}]\u0026quot;; } unused: [] 错误的原因是 (-) 产生了一个 Set，而赋值给 @remainder 会产生1项的 Array。总是这样。但不方便的是，当它是一个空集合时，它就会字符串化为一个空字符串，这只是帮助掩盖了这个潜伏的错误。\nmy @items = \u0026lt;a b c d e\u0026gt; (-) \u0026lt;a b c d e\u0026gt;; say @items.raku; say +@items; [Set.new()] 1 解决方法比较简单。只要不赋值给数组就可以了。使用一个标量容器来代替。\nmy $items = \u0026lt;a b c d e\u0026gt; (-) \u0026lt;a b d\u0026gt;; say $items.raku; say +$items; Set.new(\u0026quot;e\u0026quot;,\u0026quot;c\u0026quot;) 2 甚至是关联容器也可以。\nmy %items = \u0026lt;a b c d e\u0026gt; (-) \u0026lt;a b d\u0026gt;; say %items.raku; say +%items; {:c(Bool::True), :e(Bool::True)} 2 或在赋值前明确地取出键的列表。\nmy @items = (\u0026lt;a b c d e\u0026gt; (-) \u0026lt;a b d\u0026gt;).keys; say @items.raku; say +@items; [\u0026quot;e\u0026quot;, \u0026quot;c\u0026quot;] 2 很好，起作用了。只是不要用数组容器来处理 Setty 这样的东西。只是这并不能阻止我的直觉时不时地碰上这个错误。同一类的 bug 在我的代码中出现过好几次，因为它实在是太容易犯错了。Raku 不会告诉我，我做错了什么，因为也许是故意的。但重要的是， Raku 没有设法 DWIM。\n我可以采取的另一个方法是养成添加类型信息的习惯。这样确实可以让 Raku 在我掉进这个陷阱的时候告诉我。\nmy Str @a = \u0026lt;a b c d e\u0026gt; (-) \u0026lt;a b d\u0026gt;; Type check failed in assignment to @a; expected Str but got Set (Set.new(\u0026quot;e\u0026quot;,\u0026quot;c\u0026quot;)) in sub at EVAL_0 line 3 in block \u0026lt;unit\u0026gt; at EVAL_0 line 5 in block \u0026lt;unit\u0026gt; at -e line 1 这是一个明显的例子，添加类型信息有助于 Raku 编译器帮助我避免引入这种 bug。\n实验 - 为 Set 自定义数组存储 我开始研究核心设置(core setting)，看看可以做什么。我惊喜地发现，我可以在 Array.STORE 的多重分派中添加我正在寻找的语义。\nuse MONKEY; augment class Array { multi method STORE(Array:D: Set \\item --\u0026gt; Array:D) { self.STORE(item.keys) } } my @a = \u0026lt;a b c d e\u0026gt; (-) \u0026lt;a b d\u0026gt;; say @a.raku; say +@a; [\u0026quot;c\u0026quot;, \u0026quot;e\u0026quot;] 2 分享这个似乎是谨慎的，看看我的小 DWIM 是否有任何我没有考虑到的问题或缺点。一个可能的缺点是，如果你需要这样做的话，你需要使用 , 来强制将一个集合变成一个数组。\nmy @a = \u0026lt;a b c d e\u0026gt; (-) \u0026lt;a b d\u0026gt; , ; say @a.raku; [Set.new(\u0026quot;e\u0026quot;,\u0026quot;c\u0026quot;)] 下一步是什么 我希望这能引发关于这个问题以及其他我们的直觉和 Raku 的行为不太一致的情况的讨论。也许还有其他相关的语言边缘可以被磨平，以消除这种危害。\n后续 在 Reddit 上有一些非常有启发性的讨论，涵盖了语言语义和各种替代方法。公平地说，我建议的方法引入了更多的不一致性，而不是价值，但讨论可能会导致一个语言一致的解决方案。\n"},"name":"如果集合如我所想","published":"2021-02-07T00:00:00+08:00","summary":"If Sets Would DWIM","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/"},{"content":{"html":"\u003ch2 id=\"贪婪-junction-的奇闻异事\"\u003e贪婪 junction 的奇闻异事\u003c/h2\u003e\n\u003cp\u003e说明 Raku 的 junction 是如何贪婪的设计，以及一个建议。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://raku.org/\"\u003eRaku\u003c/a\u003e 有一个整洁的功能，叫做 \u003ca href=\"https://docs.raku.org/type/Junction\"\u003eJunction\u003c/a\u003e。在这篇短文中，我想强调一下 junction 与函数交互的一个特殊后果：它们是贪婪的，我的意思是它们会无意中把函数的其他参数变成 junction。为了说明这种行为，我将使用一个闭包创建一个 \u003ccode\u003epair\u003c/code\u003e 数据结构，它可以接受两个不同类型的值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eenum RGB \u0026lt;R G B\u0026gt;;\n\n# Pair Constructor: the arguments of pair() are captured\n# in a closure that is returned\nsub pair(\\x, \\y) {\n    sub (\u0026amp;p){ p(x, y) } \n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e所以 \u003ccode\u003epair\u003c/code\u003e 接受两个任意类型的参数，并返回一个以函数为参数的闭包。我们将使用这个函数来访问存储在 \u003ccode\u003epair\u003c/code\u003e 中的值。我将把这些访问(accessor)函数称为 \u003ccode\u003efst\u003c/code\u003e 和 \u003ccode\u003esnd\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# Accessors to get the values from the closure\nmy sub fst (\u0026amp;p) {p( sub (\\x,\\y){x})}\nmy sub snd (\u0026amp;p) {p( sub (\\x,\\y){y})}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e做实际选择的函数是由 \u003ccode\u003efst\u003c/code\u003e 和 \u003ccode\u003esnd\u003c/code\u003e 返回的匿名子程序，这纯粹是为了让我可以将它们应用于 \u003ccode\u003epair\u003c/code\u003e，而不是必须将它们作为参数传递。让我们看一个例子，一个 \u003ccode\u003eInt\u003c/code\u003e 和一个 \u003ccode\u003eRGB\u003c/code\u003e 的 pair。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \\p1 = pair 42, R;\n\nif ( 42 == fst p1) {\n    say snd p1;\t#=\u0026gt; says \u0026quot;R\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e所以我们用两个值调用 \u003ccode\u003epair\u003c/code\u003e 来创建一个 pair，并使用 \u003ccode\u003efst\u003c/code\u003e 和 \u003ccode\u003esnd\u003c/code\u003e 来访问 pair 中的值。这是一个不可变的数据结构，所以不可能进行更新。\u003c/p\u003e\n\u003cp\u003e现在让我们使用 junction 作为其中一个参数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# Example instance with a 'one'-type junction\nmy Junction \\p1j = pair (42^43),R;\n\nif ( 42 == fst p1j) {\n    say snd p1j; #=\u0026gt; one(R, R)\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这里发生的情况是，原始参数 \u003ccode\u003eR\u003c/code\u003e 已经不可逆转地变成了与自己的 junction，尽管我们从未明确地在 \u003ccode\u003eR\u003c/code\u003e 上创建过 junction，但还是发生了这种情况。这是将 junction 类型应用于函数的结果，它不是一个 bug，只是 junction 行为的一个影响。更详细的解释，请看我的文章\u0026quot;\u003ca href=\"https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e\"\u003e重构 Raku 的 Junction\u003c/a\u003e\u0026quot;。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://docs.raku.org/type/Junction\"\u003eRaku 关于 junction 的文档\u003c/a\u003e中说，你不应该真正尝试从 junction 中获取值。\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;Junction 是用来作为布尔上下文中的匹配器，不支持 junction 的自省。如果你觉得有自省 junction 的冲动，请使用 Set 或相关类型代替。\u0026rdquo;\u003c/p\u003e\n\u003cp\u003e然而，有一个 FAQ \u003ca href=\"https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)\"\u003e勉强地告诉你如何做\u003c/a\u003e。FAQ 再次警告不要这样做。\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;如果你想从 junction 中提取值（特征态），你可能做错了什么，应该用 Set 来代替。\u0026rdquo;\u003c/p\u003e\n\u003cp\u003e然而，正如我所举的例子所证明的那样，从 junction 中恢复值是有明确的用例的。当然，仅仅因为另一个值恰好是 junction，存储在 pair 中的其中一个值就变得不可访问，这不是我们的本意。\u003c/p\u003e\n\u003cp\u003e因此，我建议增加一个折叠(\u003ccode\u003ecollapse\u003c/code\u003e)函数，允许将这些无意中出现的 junction 值折叠成它们的原始值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif ( 42 == fst p1j) {\n    say collapse(snd p1j); #=\u0026gt; says 'R'\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e该函数的实现取自\u003ca href=\"https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)\"\u003e上述常见问题\u003c/a\u003e，并增加了一个检查，以确保 junction 上的所有值都相同。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub collapse(Junction \\j) {    \n    my @vvs;\n    -\u0026gt; Any \\s { push @vvs, s }.(j);    \n    my $v =  shift @vvs;        \n    my @ts = grep {!($_ ~~ $v)}, @vvs;\n    if (@ts.elems==0) {  \n        $v\n    } else {\n        die \u0026quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}\u0026quot;;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果能把这个功能作为一个 \u003ccode\u003ecollapse\u003c/code\u003e 方法添加到 \u003ccode\u003eJunction\u003c/code\u003e 类中就更好了。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003ehttps://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\u003c/a\u003e\u003c/p\u003e\n","text":"贪婪 junction 的奇闻异事 说明 Raku 的 junction 是如何贪婪的设计，以及一个建议。\nRaku 有一个整洁的功能，叫做 Junction。在这篇短文中，我想强调一下 junction 与函数交互的一个特殊后果：它们是贪婪的，我的意思是它们会无意中把函数的其他参数变成 junction。为了说明这种行为，我将使用一个闭包创建一个 pair 数据结构，它可以接受两个不同类型的值。\nenum RGB \u0026lt;R G B\u0026gt;; # Pair Constructor: the arguments of pair() are captured # in a closure that is returned sub pair(\\x, \\y) { sub (\u0026amp;p){ p(x, y) } } 所以 pair 接受两个任意类型的参数，并返回一个以函数为参数的闭包。我们将使用这个函数来访问存储在 pair 中的值。我将把这些访问(accessor)函数称为 fst 和 snd。\n# Accessors to get the values from the closure my sub fst (\u0026amp;p) {p( sub (\\x,\\y){x})} my sub snd (\u0026amp;p) {p( sub (\\x,\\y){y})} 做实际选择的函数是由 fst 和 snd 返回的匿名子程序，这纯粹是为了让我可以将它们应用于 pair，而不是必须将它们作为参数传递。让我们看一个例子，一个 Int 和一个 RGB 的 pair。\nmy \\p1 = pair 42, R; if ( 42 == fst p1) { say snd p1;\t#=\u0026gt; says \u0026quot;R\u0026quot; } 所以我们用两个值调用 pair 来创建一个 pair，并使用 fst 和 snd 来访问 pair 中的值。这是一个不可变的数据结构，所以不可能进行更新。\n现在让我们使用 junction 作为其中一个参数。\n# Example instance with a 'one'-type junction my Junction \\p1j = pair (42^43),R; if ( 42 == fst p1j) { say snd p1j; #=\u0026gt; one(R, R) } 这里发生的情况是，原始参数 R 已经不可逆转地变成了与自己的 junction，尽管我们从未明确地在 R 上创建过 junction，但还是发生了这种情况。这是将 junction 类型应用于函数的结果，它不是一个 bug，只是 junction 行为的一个影响。更详细的解释，请看我的文章\u0026quot;重构 Raku 的 Junction\u0026quot;。\nRaku 关于 junction 的文档中说，你不应该真正尝试从 junction 中获取值。\n\u0026ldquo;Junction 是用来作为布尔上下文中的匹配器，不支持 junction 的自省。如果你觉得有自省 junction 的冲动，请使用 Set 或相关类型代替。\u0026rdquo;\n然而，有一个 FAQ 勉强地告诉你如何做。FAQ 再次警告不要这样做。\n\u0026ldquo;如果你想从 junction 中提取值（特征态），你可能做错了什么，应该用 Set 来代替。\u0026rdquo;\n然而，正如我所举的例子所证明的那样，从 junction 中恢复值是有明确的用例的。当然，仅仅因为另一个值恰好是 junction，存储在 pair 中的其中一个值就变得不可访问，这不是我们的本意。\n因此，我建议增加一个折叠(collapse)函数，允许将这些无意中出现的 junction 值折叠成它们的原始值。\nif ( 42 == fst p1j) { say collapse(snd p1j); #=\u0026gt; says 'R' } 该函数的实现取自上述常见问题，并增加了一个检查，以确保 junction 上的所有值都相同。\nsub collapse(Junction \\j) { my @vvs; -\u0026gt; Any \\s { push @vvs, s }.(j); my $v = shift @vvs; my @ts = grep {!($_ ~~ $v)}, @vvs; if (@ts.elems==0) { $v } else { die \u0026quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}\u0026quot;; } } 如果能把这个功能作为一个 collapse 方法添加到 Junction 类中就更好了。\n原文链接: https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\n"},"name":"贪婪 Junction 的奇闻异事","published":"2020-10-04T00:00:00+08:00","summary":"The Strange Case of the Greedy Junction","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/"},{"content":{"html":"\u003ch2 id=\"重构-raku-的-junction\"\u003e重构 Raku 的 Junction\u003c/h2\u003e\n\u003cp\u003eRaku 中的 junction 很酷，但乍一看它们并没有遵循静态类型化的规则。我对它们的形式化类型语义很好奇，所以我从功能、静态类型的角度对 junction 进行了解构和重构。\u003c/p\u003e\n\u003ch3 id=\"raku-中的-junction\"\u003eRaku 中的 Junction\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://docs.raku.org/\"\u003eRaku\u003c/a\u003e 有一个整洁的功能叫做 \u003ca href=\"https://docs.raku.org/type/Junction\"\u003eJunction\u003c/a\u003e。Junction 是一个无序的复合值。当使用 junction 代替值时，会对每个结点(junction)元素进行操作，结果是所有这些操作符的返回值的结点(junction)。当在布尔上下文中使用 junction 时，结点(junction)会折叠成一个值。Junction 的类型可以是 all(\u003ccode\u003e\u0026amp;\u003c/code\u003e)、any(\u003ccode\u003e|\u003c/code\u003e)、one(\u003ccode\u003e^\u003c/code\u003e) 或 \u003ccode\u003enone\u003c/code\u003e (空结点)。\u003c/p\u003e\n\u003cp\u003e例如:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $j = 11|22; # short for any(11,22)\nif 33 == $j + 11 {\n    say 'yes';\n}\n\nsay so 3 == (1..30).one;         #=\u0026gt; True \nsay so (\u0026quot;a\u0026quot; ^ \u0026quot;b\u0026quot; ^ \u0026quot;c\u0026quot;) eq \u0026quot;a\u0026quot;; #=\u0026gt; True\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e函数 \u003ccode\u003eso\u003c/code\u003e 强制使用布尔上下文。\u003c/p\u003e\n\u003cp\u003eJunction 有 \u003ccode\u003eJunction\u003c/code\u003e 类型，我很好奇 Junction 的类型规则，因为乍一看有些奇怪。比方说我们有一个函数 \u003ccode\u003esq\u003c/code\u003e 从 \u003ccode\u003eInt\u003c/code\u003e 到 \u003ccode\u003eInt\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub sq(Int $x --\u0026gt; Int) { $x*$x }\n\nmy Int $res = sq(11); # OK\nsay $res; #=\u0026gt; 121\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在让我们定义一个类型为任何 \u003ccode\u003eInt\u003c/code\u003e 值的 Junction。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Junction $j = 11 | 22; \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e当我们将 \u003ccode\u003esq\u003c/code\u003e 应用于 \u003ccode\u003e$j\u003c/code\u003e 时，我们没有得到一个类型错误，即使函数的类型是 \u003ccode\u003e:(Int --\u0026gt; Int)\u003c/code\u003e，Junction 的类型是 \u003ccode\u003eJunction\u003c/code\u003e。相反，我们得到的是一个结果的 Junction。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esay sq($j); #=\u0026gt; any(121, 484)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果我们像之前一样将其赋值给一个类型为 \u003ccode\u003eInt\u003c/code\u003e 的变量，我们会得到一个类型错误。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Int $rj = sq($j); #=\u0026gt; Type check failed in assignment to $rj; expected Int but got Junction (any(121, 484))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e取而代之的是，现在返回值的类型为 \u003ccode\u003eJunction\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Junction $rj = sq(11|22); # OK\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e所以，Junction 类型可以代替任何其他类型，但这样一来，操作也变成了 Junction。\u003c/p\u003e\n\u003cp\u003e另一方面，Junction 是由其组成值隐式类型的，尽管它们看起来是不透明的 \u003ccode\u003eJunction\u003c/code\u003e 类型。例如，如果我们创建了一个由 \u003ccode\u003eStr\u003c/code\u003e 值组成的 Junction，并试图将这个 Junction 的值传递到 \u003ccode\u003esq\u003c/code\u003e 中，我们会得到一个类型错误。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $sj = '11' | '22';\nsay $sj.WHAT; #=\u0026gt;(Junction)\n\nmy Junction $svj = sq($sj); #=\u0026gt; Type check failed in binding to parameter 'x'; expected Int but got Str (\u0026quot;11\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"junction-不遵循静态类型规则\"\u003eJunction 不遵循静态类型规则\u003c/h3\u003e\n\u003cp\u003e虽然这样做是有道理的(如果原始函数期望使用 \u003ccode\u003eInt\u003c/code\u003e，我们不希望它与 \u003ccode\u003eStr\u003c/code\u003e 一起工作)，但这确实违背了静态类型化的规则，即使是子类型化。如果一个参数的类型是 \u003ccode\u003eInt\u003c/code\u003e，那么可以使用类型图中低于它的任何类型来代替。但是 \u003ccode\u003eInt\u003c/code\u003e 和 \u003ccode\u003eJunction\u003c/code\u003e 的简化类型图如下。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eInt -\u0026gt; Cool -\u0026gt; Any -\u0026gt; Mu \u0026lt;- Junction\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e所以 Junction 永远不是 \u003ccode\u003eAny\u003c/code\u003e 以下任何东西的子类型。因此，将 Junction 放在类型为 \u003ccode\u003eAny\u003c/code\u003e 或其子类型的槽中应该是一个类型错误。\u003c/p\u003e\n\u003cp\u003e此外，由于 Junction 类型是不透明的（即它不是一个参数化的类型），它不应该持有任何关于 Junction 内部值的类型的信息。然而它却对这些不可见、不可访问的值进行了类型检查。\u003c/p\u003e\n\u003cp\u003e那么这里到底发生了什么？\u003c/p\u003e\n\u003ch3 id=\"一个工作假设\"\u003e一个工作假设\u003c/h3\u003e\n\u003cp\u003e一个工作假设是，Junction 类型并不真正取代任何其他类型：它只是一个语法糖，使它看起来如此。\u003c/p\u003e\n\u003ch3 id=\"重构-junction-的第一部分类型\"\u003e重构 Junction 的第一部分：类型\u003c/h3\u003e\n\u003cp\u003e让我们试着重建这个。我们的目的是想出一个数据类型和一些动作，以复制观察到的 Raku Junction 的行为。首先我们讨论一下类型，为了清晰起见，使用 Haskell 符号。然后我介绍 Raku 中的实现。这个实现将像 Raku 的原生 Junction 一样，但没有神奇的语法糖。通过这种方式，我证明了 Raku 的 Junction 毕竟遵循了正确的类型规则。\u003c/p\u003e\n\u003ch4 id=\"junction-类型\"\u003eJunction 类型\u003c/h4\u003e\n\u003cp\u003eJunction 是一个由 Junction 类型 \u003ccode\u003eJType\u003c/code\u003e 和一组值组成的数据结构。为了方便起见，我将这个值集限制为单一类型，同时也是因为混合类型的 Junction 其实没有什么意义。我使用一个列表来模拟这个集合，同样是为了方便。因为 Junction 可以包含任何类型的值，所以它是一个多态的代数数据类型。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003edata JType = JAny | JAll | JOne | JNone\n\ndata Junction a = Junction JType [a]\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"应用结点\"\u003e应用结点\u003c/h4\u003e\n\u003cp\u003e对一个 Junction 做任何事情都意味着对它应用一个函数。我们可以考虑三种情况，我为每一种情况介绍一个特别定制的操作符。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将非 Junction 函数应用于 Junction 表达式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e(•￮) :: (a -\u0026gt; b) -\u0026gt; Junction a -\u0026gt;  Junction b\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e将 Junction 函数应用于非 Junction 表达式。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e(￮•) ::  Junction (b -\u0026gt; c) -\u0026gt; b -\u0026gt; Junction c\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e将 Junction 函数应用于 Junction 表达式，创建一个嵌套 Junction。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e(￮￮) ::  Junction (b -\u0026gt; c) -\u0026gt; Junction b -\u0026gt; Junction (Junction c)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e为了方便，我们还可以在 Junction a 和 a 之间创建自定义比较运算符。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e-- and similar for /-, \u0026gt;, \u0026lt;, \u0026lt;=,\u0026gt;=\n(￮==•) :: Junction a -\u0026gt; a -\u0026gt; Bool\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"折叠-junction\"\u003e折叠 Junction\u003c/h4\u003e\n\u003cp\u003e那么我们就有了 \u003ccode\u003eso\u003c/code\u003e，布尔强制函数。它的作用是将一个布尔的 Junction 折叠成一个布尔。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eso :: Junction Bool -\u0026gt; Bool\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后我们有 \u003ccode\u003ecollapse\u003c/code\u003e，它从一个 Junction 返回值，前提是它是一个 Junction，所有存储的值都是一样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003ecollapse :: (Show a,Eq a) =\u0026gt; Junction a -\u0026gt; a\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这似乎是一个奇怪的函数，但由于 Junction 的行为，它是必要的。正如我们将看到的，上述语义意味着 Junction 是贪婪的：如果一个函数的一个参数是 Junction，那么所有其他参数也会成为 Junction，但 Junction 中的所有值都是相同的。我已经在\u0026quot;\u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003e贪婪 Junction 的奇怪情况\u003c/a\u003e\u0026ldquo;中讨论过这个问题，但我们现在可以将这种行为形式化。\u003c/p\u003e\n\u003ch4 id=\"重新审视贪婪-junction-的奇怪情况\"\u003e重新审视贪婪 Junction 的奇怪情况\u003c/h4\u003e\n\u003cp\u003e假设我们有一个两个参数的函数 \u003ccode\u003ef :: a -\u0026gt; b -\u0026gt; c\u003c/code\u003e，我们对第一个参数应用一个结点 \u003ccode\u003ej :: Junction\u003c/code\u003e a 应用到第一个参数 \u003ccode\u003ef •￮ j\u003c/code\u003e 上，那么结果是一个部分应用的函数，包裹在一个 Junction 上：\u003ccode\u003efp :: Junction b -\u0026gt; c\u003c/code\u003e。如果我们现在想用 \u003ccode\u003efp ￮• v\u003c/code\u003e 将这个函数应用于一个非结点的值 \u003ccode\u003ev :: b\u003c/code\u003e，那么结果就是 \u003ccode\u003eJunction c\u003c/code\u003e 类型的。\u003c/p\u003e\n\u003cp\u003e现在，让我们考虑类型 \u003ccode\u003ec\u003c/code\u003e 是 \u003ccode\u003eforall d . (a -\u0026gt; b -\u0026gt; d) -\u0026gt; d\u003c/code\u003e 的特殊情况。所以我们有 \u003ccode\u003eJunction\u003c/code\u003e(\u003ccode\u003eforall d . (a-\u0026gt;b-\u0026gt;d) -\u0026gt; d\u003c/code\u003e)。这是一个函数，它接受一个函数参数并返回该函数的返回类型的东西。我们使用 \u003ccode\u003eforall\u003c/code\u003e，所以 \u003ccode\u003ed\u003c/code\u003e 可以是任何东西，但在实践中我们希望它是 \u003ccode\u003ea\u003c/code\u003e 或 \u003ccode\u003eb\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e假设我们将这个函数(称它为 \u003ccode\u003ep\u003c/code\u003e)应用于 \u003ccode\u003efst :: a-\u0026gt;b-\u0026gt;a\u003c/code\u003e，使用 \u003ccode\u003ep ￮• fst\u003c/code\u003e，那么我们得到 \u003ccode\u003eJunction a\u003c/code\u003e。但是如果我们将它应用于 \u003ccode\u003esnd :: a-\u0026gt;b-\u0026gt;b\u003c/code\u003e，使用 \u003ccode\u003ep ￮• snd\u003c/code\u003e，那么我们得到 \u003ccode\u003eJunction b\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这就是形式上基于类型的分析，为什么我们不能从一个 pair 中返回一个非 Junction 的值，在\u0026rdquo;\u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003e贪婪 Junction 的奇怪情况\u003c/a\u003e\u0026ldquo;中已经解释过。而这也是我们需要 \u003ccode\u003ecollapse\u003c/code\u003e 函数的原因。\u003c/p\u003e\n\u003ch4 id=\"重构-junction-的第2部分raku-的实现\"\u003e重构 Junction 的第2部分：Raku 的实现。\u003c/h4\u003e\n\u003cp\u003e我们从创建 Junction 类型开始，为四种 Junction 类型使用一个枚举，为实际的 Junction 数据类型使用一个角色。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# The types of Junctions\nenum JType \u0026lt;JAny  JAll  JOne  JNone \u0026gt;;\n\n# The actual Junction type\nrole Junction[\\jt, @vs] {\n    has JType $.junction-type=jt;\n    has @.values=@vs;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e接下来是四种类型的 Junction 的构造函数（下划线，避免与内建函数的名称冲突）。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eour sub all_(@vs) {\n    Junction[ JAll, @vs].new;\n}\n\nour sub any_(@vs) {\n    Junction[ JAny, @vs].new;\n}\n\nour sub one_(@vs) {\n    Junction[ JOne, @vs].new;\n}\n\nour sub none_(@vs) {\n    Junction[ JNone, @vs].new;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e将一个（单参数）函数应用于 junction 参数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub infix:\u0026lt;●○\u0026gt;( \u0026amp;f, \\j ) is export {\n    my \\jt=j.junction-type; \n    my @vs = j.values;\n  \n    Junction[ jt, map( {\u0026amp;f($_)}, @vs)].new;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e要将 Junction 内的函数应用于非 Junction 的参数:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub infix:\u0026lt;○●\u0026gt;( \\jf, \\v ) is export {\n    my \\jt=jf.junction-type; \n    my @fs = jf.values;\n\n    Junction[ jt, map( {$_( v)}, @fs)].new;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e将一个函数应用于两个 junction 参数，相当于将一个 junction 内的函数应用于一个 junction。这里有一个复杂的问题。Raku 对嵌套施加了一个排序，即所有的嵌套总是外嵌套。因此，我们必须检查 junction 的类型，如果需要的话，我们必须交换映射。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub infix:\u0026lt;○○\u0026gt;( \\jf, \\jv ) is export {\n    my \\jft= jf.junction-type; \n    my @fs = jf.values;\n    my \\jvt = jv.junction-type;\n    my @vs = jv.values;\n    if (jvt == JAll and jft != JAll) {        \n        Junction[ jvt, map( sub (\\v){jf ○● v}, @vs)].new;  \n    } else {        \n        Junction[ jft, map( sub (\u0026amp;f){ \u0026amp;f ●○ jv}, @fs)].new;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e为了完整，这里是 \u003ccode\u003e○==●\u003c/code\u003e 的定义。\u003ccode\u003e○!=●\u003c/code\u003e、\u003ccode\u003e○\u0026gt;●\u003c/code\u003e 等的定义是类似的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub infix:\u0026lt; ○==● \u0026gt;( \\j, \\v ) is export {\n    sub (\\x){x==v} ●○ j\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e接下来我们有 \u003ccode\u003eso\u003c/code\u003e，它把布尔值的 junction 变成了布尔值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eour sub so (\\jv) { \n    my @vs = jv.values;\n    given jv.junction-type {\n        when JAny { elems(grep {$_},  @vs) \u0026gt;0}\n        when JAll { elems(grep {!$_}, @vs)==0}\n        when JOne { elems(grep {$_},  @vs)==1}\n        when JOne { elems(grep {$_},  @vs)==0}\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后我们有 \u003ccode\u003ecollapse\u003c/code\u003e，正如\u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003e贪婪 Junction 的文章\u003c/a\u003e中所定义的那样， \u003ccode\u003ecollapse\u003c/code\u003e 返回 Junction 的值，只要它们都是一样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eour sub collapse( \\j ) {\n    my \\jt=j.junction-type; \n    my @vvs = j.values;\n    my $v =  shift @vvs;        \n    my @ts = grep {!($_ ~~ $v)}, @vvs;\n    if (@ts.elems==0) {  \n        $v\n    } else {\n        die \u0026quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}\u0026quot;;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"junction-清理\"\u003eJunction 清理\u003c/h3\u003e\n\u003cp\u003e现在我们再来看看我们的工作假说，将 Raku 的 Junction 上的动作解释为上述类型和操作符的语法糖。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub sq(Int $x --\u0026gt; Int) { $x*$x }\nmy Junction $j = 11 | 22; \nmy Junction $rj = sq($j); \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e去语法塘后这变成了:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Junction $j = any_ [11,22];\nmy Junction $rj = \u0026amp;sq ●○ $j;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e类似地,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif ($j == 42) {...} \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e变成了:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif (so ($j ○==● 42)) {...}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e和其他布尔上下文类似。\u003c/p\u003e\n\u003cp\u003e如果我们仔细看\u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003e贪婪 Junction 文章\u003c/a\u003e中的 pair 例子，那么将 junction 应用到一个有多个参数的函数上:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Junction \\p1j = pair R,(42^43);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e去语法塘后变为:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Junction \\p1j = \u0026amp;pair.assuming(R) ●○ one_ [42,43];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们使用 \u003ccode\u003e.assuming()\u003c/code\u003e 是因为我们需要部分应用。不管我们是先应用非 Junction 参数还是 Junction 参数，都没有关系。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \\p1jr = ( sub ($y){ \u0026amp;pair.assuming(*,$y) } ●○ one_ [42,43] ) ○● R;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后，举一个两个参数都是 Junction 的例子。由于 \u003ccode\u003e○○\u003c/code\u003e 的定义，应用的顺序并不重要。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub m(\\x,\\y){x*y}\n\nmy \\p4 = ( sub (\\x){ \u0026amp;m.assuming(x) } ●○ any_ [11,22] ) ○○ all_ [33,44];\nmy \\p4r = ( sub (\\x){ \u0026amp;m.assuming(*,x) } ●○ all_ [33,44] ) ○○ any_ [11,22];\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"结论\"\u003e结论\u003c/h3\u003e\n\u003cp\u003e从 Raku 的 junction 的神奇类型行为实际上是语法糖的假设出发，我使用多态代数数据类型重构了 junction 类型和它的动作，并表明 Raku 的行为作为语法糖的解释对于所提出的实现是成立的。换句话说，Raku 的 Junction 确实遵循静态类型规则。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e\"\u003ehttps://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e\u003c/a\u003e\u003c/p\u003e\n","text":"重构 Raku 的 Junction Raku 中的 junction 很酷，但乍一看它们并没有遵循静态类型化的规则。我对它们的形式化类型语义很好奇，所以我从功能、静态类型的角度对 junction 进行了解构和重构。\nRaku 中的 Junction Raku 有一个整洁的功能叫做 Junction。Junction 是一个无序的复合值。当使用 junction 代替值时，会对每个结点(junction)元素进行操作，结果是所有这些操作符的返回值的结点(junction)。当在布尔上下文中使用 junction 时，结点(junction)会折叠成一个值。Junction 的类型可以是 all(\u0026amp;)、any(|)、one(^) 或 none (空结点)。\n例如:\nmy $j = 11|22; # short for any(11,22) if 33 == $j + 11 { say 'yes'; } say so 3 == (1..30).one; #=\u0026gt; True say so (\u0026quot;a\u0026quot; ^ \u0026quot;b\u0026quot; ^ \u0026quot;c\u0026quot;) eq \u0026quot;a\u0026quot;; #=\u0026gt; True 函数 so 强制使用布尔上下文。\nJunction 有 Junction 类型，我很好奇 Junction 的类型规则，因为乍一看有些奇怪。比方说我们有一个函数 sq 从 Int 到 Int。\nsub sq(Int $x --\u0026gt; Int) { $x*$x } my Int $res = sq(11); # OK say $res; #=\u0026gt; 121 现在让我们定义一个类型为任何 Int 值的 Junction。\nmy Junction $j = 11 | 22; 当我们将 sq 应用于 $j 时，我们没有得到一个类型错误，即使函数的类型是 :(Int --\u0026gt; Int)，Junction 的类型是 Junction。相反，我们得到的是一个结果的 Junction。\nsay sq($j); #=\u0026gt; any(121, 484) 如果我们像之前一样将其赋值给一个类型为 Int 的变量，我们会得到一个类型错误。\nmy Int $rj = sq($j); #=\u0026gt; Type check failed in assignment to $rj; expected Int but got Junction (any(121, 484)) 取而代之的是，现在返回值的类型为 Junction。\nmy Junction $rj = sq(11|22); # OK 所以，Junction 类型可以代替任何其他类型，但这样一来，操作也变成了 Junction。\n另一方面，Junction 是由其组成值隐式类型的，尽管它们看起来是不透明的 Junction 类型。例如，如果我们创建了一个由 Str 值组成的 Junction，并试图将这个 Junction 的值传递到 sq 中，我们会得到一个类型错误。\nmy $sj = '11' | '22'; say $sj.WHAT; #=\u0026gt;(Junction) my Junction $svj = sq($sj); #=\u0026gt; Type check failed in binding to parameter 'x'; expected Int but got Str (\u0026quot;11\u0026quot;) Junction 不遵循静态类型规则 虽然这样做是有道理的(如果原始函数期望使用 Int，我们不希望它与 Str 一起工作)，但这确实违背了静态类型化的规则，即使是子类型化。如果一个参数的类型是 Int，那么可以使用类型图中低于它的任何类型来代替。但是 Int 和 Junction 的简化类型图如下。\nInt -\u0026gt; Cool -\u0026gt; Any -\u0026gt; Mu \u0026lt;- Junction  所以 Junction 永远不是 Any 以下任何东西的子类型。因此，将 Junction 放在类型为 Any 或其子类型的槽中应该是一个类型错误。\n此外，由于 Junction 类型是不透明的（即它不是一个参数化的类型），它不应该持有任何关于 Junction 内部值的类型的信息。然而它却对这些不可见、不可访问的值进行了类型检查。\n那么这里到底发生了什么？\n一个工作假设 一个工作假设是，Junction 类型并不真正取代任何其他类型：它只是一个语法糖，使它看起来如此。\n重构 Junction 的第一部分：类型 让我们试着重建这个。我们的目的是想出一个数据类型和一些动作，以复制观察到的 Raku Junction 的行为。首先我们讨论一下类型，为了清晰起见，使用 Haskell 符号。然后我介绍 Raku 中的实现。这个实现将像 Raku 的原生 Junction 一样，但没有神奇的语法糖。通过这种方式，我证明了 Raku 的 Junction 毕竟遵循了正确的类型规则。\nJunction 类型 Junction 是一个由 Junction 类型 JType 和一组值组成的数据结构。为了方便起见，我将这个值集限制为单一类型，同时也是因为混合类型的 Junction 其实没有什么意义。我使用一个列表来模拟这个集合，同样是为了方便。因为 Junction 可以包含任何类型的值，所以它是一个多态的代数数据类型。\ndata JType = JAny | JAll | JOne | JNone data Junction a = Junction JType [a] 应用结点 对一个 Junction 做任何事情都意味着对它应用一个函数。我们可以考虑三种情况，我为每一种情况介绍一个特别定制的操作符。\n 将非 Junction 函数应用于 Junction 表达式  (•￮) :: (a -\u0026gt; b) -\u0026gt; Junction a -\u0026gt; Junction b  将 Junction 函数应用于非 Junction 表达式。  (￮•) :: Junction (b -\u0026gt; c) -\u0026gt; b -\u0026gt; Junction c  将 Junction 函数应用于 Junction 表达式，创建一个嵌套 Junction。  (￮￮) :: Junction (b -\u0026gt; c) -\u0026gt; Junction b -\u0026gt; Junction (Junction c) 为了方便，我们还可以在 Junction a 和 a 之间创建自定义比较运算符。\n-- and similar for /-, \u0026gt;, \u0026lt;, \u0026lt;=,\u0026gt;= (￮==•) :: Junction a -\u0026gt; a -\u0026gt; Bool 折叠 Junction 那么我们就有了 so，布尔强制函数。它的作用是将一个布尔的 Junction 折叠成一个布尔。\nso :: Junction Bool -\u0026gt; Bool 最后我们有 collapse，它从一个 Junction 返回值，前提是它是一个 Junction，所有存储的值都是一样的。\ncollapse :: (Show a,Eq a) =\u0026gt; Junction a -\u0026gt; a 这似乎是一个奇怪的函数，但由于 Junction 的行为，它是必要的。正如我们将看到的，上述语义意味着 Junction 是贪婪的：如果一个函数的一个参数是 Junction，那么所有其他参数也会成为 Junction，但 Junction 中的所有值都是相同的。我已经在\u0026quot;贪婪 Junction 的奇怪情况\u0026ldquo;中讨论过这个问题，但我们现在可以将这种行为形式化。\n重新审视贪婪 Junction 的奇怪情况 假设我们有一个两个参数的函数 f :: a -\u0026gt; b -\u0026gt; c，我们对第一个参数应用一个结点 j :: Junction a 应用到第一个参数 f •￮ j 上，那么结果是一个部分应用的函数，包裹在一个 Junction 上：fp :: Junction b -\u0026gt; c。如果我们现在想用 fp ￮• v 将这个函数应用于一个非结点的值 v :: b，那么结果就是 Junction c 类型的。\n现在，让我们考虑类型 c 是 forall d . (a -\u0026gt; b -\u0026gt; d) -\u0026gt; d 的特殊情况。所以我们有 Junction(forall d . (a-\u0026gt;b-\u0026gt;d) -\u0026gt; d)。这是一个函数，它接受一个函数参数并返回该函数的返回类型的东西。我们使用 forall，所以 d 可以是任何东西，但在实践中我们希望它是 a 或 b。\n假设我们将这个函数(称它为 p)应用于 fst :: a-\u0026gt;b-\u0026gt;a，使用 p ￮• fst，那么我们得到 Junction a。但是如果我们将它应用于 snd :: a-\u0026gt;b-\u0026gt;b，使用 p ￮• snd，那么我们得到 Junction b。\n这就是形式上基于类型的分析，为什么我们不能从一个 pair 中返回一个非 Junction 的值，在\u0026rdquo;贪婪 Junction 的奇怪情况\u0026ldquo;中已经解释过。而这也是我们需要 collapse 函数的原因。\n重构 Junction 的第2部分：Raku 的实现。 我们从创建 Junction 类型开始，为四种 Junction 类型使用一个枚举，为实际的 Junction 数据类型使用一个角色。\n# The types of Junctions enum JType \u0026lt;JAny JAll JOne JNone \u0026gt;; # The actual Junction type role Junction[\\jt, @vs] { has JType $.junction-type=jt; has @.values=@vs; } 接下来是四种类型的 Junction 的构造函数（下划线，避免与内建函数的名称冲突）。\nour sub all_(@vs) { Junction[ JAll, @vs].new; } our sub any_(@vs) { Junction[ JAny, @vs].new; } our sub one_(@vs) { Junction[ JOne, @vs].new; } our sub none_(@vs) { Junction[ JNone, @vs].new; } 将一个（单参数）函数应用于 junction 参数。\nsub infix:\u0026lt;●○\u0026gt;( \u0026amp;f, \\j ) is export { my \\jt=j.junction-type; my @vs = j.values; Junction[ jt, map( {\u0026amp;f($_)}, @vs)].new; } 要将 Junction 内的函数应用于非 Junction 的参数:\nsub infix:\u0026lt;○●\u0026gt;( \\jf, \\v ) is export { my \\jt=jf.junction-type; my @fs = jf.values; Junction[ jt, map( {$_( v)}, @fs)].new; } 将一个函数应用于两个 junction 参数，相当于将一个 junction 内的函数应用于一个 junction。这里有一个复杂的问题。Raku 对嵌套施加了一个排序，即所有的嵌套总是外嵌套。因此，我们必须检查 junction 的类型，如果需要的话，我们必须交换映射。\nsub infix:\u0026lt;○○\u0026gt;( \\jf, \\jv ) is export { my \\jft= jf.junction-type; my @fs = jf.values; my \\jvt = jv.junction-type; my @vs = jv.values; if (jvt == JAll and jft != JAll) { Junction[ jvt, map( sub (\\v){jf ○● v}, @vs)].new; } else { Junction[ jft, map( sub (\u0026amp;f){ \u0026amp;f ●○ jv}, @fs)].new; } } 为了完整，这里是 ○==● 的定义。○!=●、○\u0026gt;● 等的定义是类似的。\nsub infix:\u0026lt; ○==● \u0026gt;( \\j, \\v ) is export { sub (\\x){x==v} ●○ j } 接下来我们有 so，它把布尔值的 junction 变成了布尔值。\nour sub so (\\jv) { my @vs = jv.values; given jv.junction-type { when JAny { elems(grep {$_}, @vs) \u0026gt;0} when JAll { elems(grep {!$_}, @vs)==0} when JOne { elems(grep {$_}, @vs)==1} when JOne { elems(grep {$_}, @vs)==0} } } 最后我们有 collapse，正如贪婪 Junction 的文章中所定义的那样， collapse 返回 Junction 的值，只要它们都是一样的。\nour sub collapse( \\j ) { my \\jt=j.junction-type; my @vvs = j.values; my $v = shift @vvs; my @ts = grep {!($_ ~~ $v)}, @vvs; if (@ts.elems==0) { $v } else { die \u0026quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}\u0026quot;; } } Junction 清理 现在我们再来看看我们的工作假说，将 Raku 的 Junction 上的动作解释为上述类型和操作符的语法糖。\nsub sq(Int $x --\u0026gt; Int) { $x*$x } my Junction $j = 11 | 22; my Junction $rj = sq($j); 去语法塘后这变成了:\nmy Junction $j = any_ [11,22]; my Junction $rj = \u0026amp;sq ●○ $j; 类似地,\nif ($j == 42) {...} 变成了:\nif (so ($j ○==● 42)) {...} 和其他布尔上下文类似。\n如果我们仔细看贪婪 Junction 文章中的 pair 例子，那么将 junction 应用到一个有多个参数的函数上:\nmy Junction \\p1j = pair R,(42^43); 去语法塘后变为:\nmy Junction \\p1j = \u0026amp;pair.assuming(R) ●○ one_ [42,43]; 我们使用 .assuming() 是因为我们需要部分应用。不管我们是先应用非 Junction 参数还是 Junction 参数，都没有关系。\nmy \\p1jr = ( sub ($y){ \u0026amp;pair.assuming(*,$y) } ●○ one_ [42,43] ) ○● R; 最后，举一个两个参数都是 Junction 的例子。由于 ○○ 的定义，应用的顺序并不重要。\nsub m(\\x,\\y){x*y} my \\p4 = ( sub (\\x){ \u0026amp;m.assuming(x) } ●○ any_ [11,22] ) ○○ all_ [33,44]; my \\p4r = ( sub (\\x){ \u0026amp;m.assuming(*,x) } ●○ all_ [33,44] ) ○○ any_ [11,22]; 结论 从 Raku 的 junction 的神奇类型行为实际上是语法糖的假设出发，我使用多态代数数据类型重构了 junction 类型和它的动作，并表明 Raku 的行为作为语法糖的解释对于所提出的实现是成立的。换句话说，Raku 的 Junction 确实遵循静态类型规则。\n原文链接: https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e\n"},"name":"重构 Raku 的 Junction","published":"2020-10-04T00:00:00+08:00","summary":"Reconstructing Raku\u0026rsquo;s Junctions","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/"},{"content":{"html":"\u003cp\u003e函数式编程是一种编程风格，现代语言或多或少都支持这种风格。在这篇文章中，我想解释一下函数式编程如何为你提供强大的抽象，使你的代码更加简洁。我将用 Raku 和 Python 中的例子来说明这一点，我们将看到这两种语言都是函数式编程的优秀语言。\u003c/p\u003e\n\u003ch2 id=\"raku-简介\"\u003eRaku: 简介\u003c/h2\u003e\n\u003cp\u003e本文的代码示例是用 Python 和 Raku 编写的。我想大多数人都熟悉 Python，但 Raku 不太为人所知，所以我先解释一下基础知识。本文中的代码不是很习惯，所以如果你懂得其他编程语言，应该很容易理解。\u003c/p\u003e\n\u003cp\u003eRaku 与 Perl 最为相似。两种语言在语法上都与 C/C++、Java 和 JavaScript 相似：基于块，语句用分号隔开，块用大括号分界，参数列表放在括号中，用逗号隔开。将 Perl 和 Raku 与其他语言区分开来的主要特征是使用魔符（\u0026ldquo;有趣的字符\u0026rdquo;）来识别变量的类型：\u003ccode\u003e$\u003c/code\u003e 代表标量，\u003ccode\u003e@\u003c/code\u003e 代表数组，\u003ccode\u003e%\u003c/code\u003e 代表哈希（映射），\u003ccode\u003e\u0026amp;\u003c/code\u003e 代表子程序。变量也有关键字来标识它们的作用域，我只用 \u003ccode\u003emy\u003c/code\u003e 来标识变量的词法作用域。子程序是用 \u003ccode\u003esub\u003c/code\u003e 关键字来声明的，子程序可以是命名的，也可以是匿名的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003esub square ($x) {\n    $x*$x;\n}\n# anonymous subroutine \nmy $anon_square = sub ($x) {\n    $x*$x;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在 Python 中，这将是：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003esquare\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e# anonymous subroutine \u003c/span\u003e\n\u003cspan class=\"n\"\u003eanon_square\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003elambda\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eRaku 支持无符号变量，并使用 \u003ccode\u003e\\\u003c/code\u003e 语法来声明它们。更多关于普通变量和无符号变量之间的区别，请参见 \u003ca href=\"https://docs.raku.org/language/variables#Sigilless_variables\"\u003eRaku 文档\u003c/a\u003e。例如(\u003ccode\u003esay\u003c/code\u003e 打印它的参数，后面加一个换行)。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003emy \\x = 42; # sigilless\nmy $y = 43; \nsay x + $y; \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在本文的代码中，我将尽可能地使用无符号变量。\u003c/p\u003e\n\u003cp\u003eRaku 有几种类型的序列数据结构。在下面的代码中，我将使用\u003ca href=\"https://docs.raku.org/language/list\"\u003e列表和数组\u003c/a\u003e以及\u003ca href=\"https://docs.raku.org/type/Range\"\u003e范围\u003c/a\u003e。在 Raku 中，列表和数组的主要区别在于，列表是不可变的，这意味着一旦创建，就不能修改。所以它是一个只读的数据结构。要\u0026quot;更新\u0026quot;一个不可变的数据结构，你需要创建一个更新的副本。另一方面，数组是可变的，所以我们可以更新它们的元素，扩展它们，缩小它们等等。所有的更新都发生在原始数据的位置上。\u003c/p\u003e\n\u003cp\u003eRaku 的数组类似于 Python 的 list，Raku 的 list 类似于 Python 的 tuple，也是不可变的。除了语法之外，Raku 中的范围与 Python 中的范围相似，都是不可变的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003emy @array1 = 1,2,3; #=\u0026gt; an array because of the '@' sigil\nmy \\array2 = [1,2,3]; #=\u0026gt; an array, because of the '[...]'\n\nmy \\range1 = 1 .. 10; #=\u0026gt; a range 1 .. 10\nmy @array3 = 1 .. 10; #=\u0026gt; an array from a range, because of the '@' sigil\n\nmy \\list1 = 1,2,3; #=\u0026gt; a list\nmy $list2 = (1,2,3); #=\u0026gt; also a list\nmy \\list3 = |(1 .. 10);  #=\u0026gt; an array from a range because of the '|' flattening operation\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e相应的 Python 代码为:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"n\"\u003elist1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003elist\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"c1\"\u003e#=\u0026gt; a list from a tuple\u003c/span\u003e\n\u003cspan class=\"n\"\u003elist2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e \u003cspan class=\"c1\"\u003e#=\u0026gt; a list, because of the \u0026#39;[...]\u0026#39;\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003erange1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e11\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"c1\"\u003e#=\u0026gt; a range 1 .. 10\u003c/span\u003e\n\u003cspan class=\"n\"\u003elist3\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003elist\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e11\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e \u003cspan class=\"c1\"\u003e#=\u0026gt; a list from a range\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003etuple1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e#=\u0026gt; a tuple\u003c/span\u003e\n\u003cspan class=\"n\"\u003etuple2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003etuple\u003c/span\u003e\u003cspan class=\"p\"\u003e([\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"c1\"\u003e#=\u0026gt; a tuple from a list\u003c/span\u003e\n\u003cspan class=\"n\"\u003etuple3\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003etuple\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e11\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"c1\"\u003e#=\u0026gt; creates a tuple from a range\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e其他具体的语法或功能将针对具体的例子进行解释。\u003c/p\u003e\n\u003ch2 id=\"其他任何名称的函数---作为值的函数\"\u003e\u003cem\u003e其他任何名称的函数\u003c/em\u003e - 作为值的函数\u003c/h2\u003e\n\u003cp\u003e函数是函数式编程的精髓。正如我在\u003ca href=\"https://wimvanderbauwhede.github.io/articles/everything-is-a-function\"\u003e\u0026ldquo;万物皆函数\u0026rdquo;\u003c/a\u003e一文中所解释的那样，在适当的函数式语言中，所有的结构都是由函数构建的。\u003c/p\u003e\n\u003cp\u003e所有现代编程语言都有函数、程序、子程序或方法的概念。它们是代码重用的重要机制。通常，我们认为函数是对一些输入值进行操作以产生一个或多个输出值的东西。输入值可以是全局声明的，也可以是一个类的属性，或者作为参数传递给函数。同样，输出值可以直接返回，到全局变量，作为类的属性或通过修改输入值。\u003c/p\u003e\n\u003cp\u003e要想从函数式编程中获益最多，最好是函数是纯粹的，这意味着对函数的调用总是对相同的输入产生相同的输出。在实践中，如果函数只接受输入作为参数，并直接返回输出，这一点比较容易实现，但这并不是必不可少的。\u003c/p\u003e\n\u003cp\u003e函数式编程的关键特征是，函数的输入值和输出值本身可以是函数。所以函数必须是你语言中的值。有时这被称为 \u0026ldquo;函数必须是一等公民\u0026rdquo;，一个接收和/或返回函数的函数有时被称为\u0026quot;高阶函数\u0026quot;。\u003c/p\u003e\n\u003cp\u003e如果函数是值，那么我们就可以将它们赋值给变量。特别是我们会将它们赋值给其他函数的参数。但我们也可以将它们赋值给普通的变量。\u003c/p\u003e\n\u003cp\u003e让我们考虑以下函数，\u003ccode\u003echoose\u003c/code\u003e，它需要三个参数 \u003ccode\u003et\u003c/code\u003e，\u003ccode\u003ef\u003c/code\u003e 和 \u003ccode\u003ec\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nsub choose (\\t, \\f, \\d) {\n    if (d) {t} else {f}\n}\n# Python\ndef choose (t, f, d):\n  if d:\n    return t \n  else:\n    return f\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e首先让我们用字符串作为前两个参数的值来调用 \u003ccode\u003echoose\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nmy \\tstr = \u0026quot;True!\u0026quot;;\nmy \\fstr = \u0026quot;False!\u0026quot;;\n\nmy \\res_str = choose(tstr, fstr, True);\n\nsay res_str; #=\u0026gt; says \u0026quot;True!\u0026quot;\n# Python\ntstr = \u0026quot;True!\u0026quot;\nfstr = \u0026quot;False!\u0026quot;\n\nres_str = choose(tstr,fstr,True)\n\nprint(res_str) #=\u0026gt; says \u0026quot;True!\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在让我们尝试用函数作为参数:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nsub tt (\\s) { say \u0026quot;True {s}!\u0026quot; }\nsub ff (\\s) { say \u0026quot;False {s}!\u0026quot; }\n\nmy \u0026amp;res_f = choose(\u0026amp;tt, \u0026amp;ff, False);\n\nsay \u0026amp;res_f; #=\u0026gt; says \u0026amp;ff\nres_f(\u0026quot;rumour\u0026quot;); #=\u0026gt; says \u0026quot;False rumour!\u0026quot;\n# Python\ndef tt(s):\n  print( \u0026quot;True \u0026quot;+s+\u0026quot;!\u0026quot;)\ndef ff(s):  \n  print( \u0026quot;False\u0026quot;+s+\u0026quot;!\u0026quot;)\n\nres_f = choose(tt,ff,True)\n\nprint(res_f) #=\u0026gt; says \u0026lt;function tt at 0x7f829c3aa310\u0026gt;\nres_f(\u0026quot;rumour\u0026quot;) #=\u0026gt; says \u0026quot;False rumour!\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e因此，我们的函数 \u003ccode\u003echoose\u003c/code\u003e  接收两个函数作为它的前两个参数，并返回一个函数。在 Raku 中，我们需要在函数名上加上 \u003ccode\u003e\u0026amp;\u003c/code\u003e 符号，因为否则它们会被求值：像 \u003ccode\u003ett\u003c/code\u003e 这样的裸函数名就等于调用没有参数的函数 \u003ccode\u003ett()\u003c/code\u003e。通过将这个函数赋值给一个变量(\u003ccode\u003eres_f\u003c/code\u003e)，我们现在可以将 \u003ccode\u003eres_f\u003c/code\u003e 作为一个函数来调用，它最终会根据选择来调用 \u003ccode\u003ett\u003c/code\u003e 或 \u003ccode\u003eff\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"函数不需要名字\"\u003e函数不需要名字\u003c/h2\u003e\n\u003cp\u003e现在，如果我们可以将函数赋值给变量，它们本身其实并不需要一个名字。所以我们的函数可以是匿名的。大多数语言都支持匿名函数，在函数式语言中，它们通常被称为 \u0026ldquo;lambda 函数\u0026rdquo;。在 Raku 中，我们有两种方法来创建匿名函数。\u003c/p\u003e\n\u003cp\u003e使用 \u003ccode\u003esub (...)\u003c/code\u003e 语法:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003emy \\tt = sub (\\s) { say \u0026quot;True {s}!\u0026quot; };\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e或者使用\u003ca href=\"https://docs.raku.org/language/functions#index-entry-pointy_blocks\"\u003e\u0026lsquo;尖号块\u0026rsquo;\u003c/a\u003e语法，这样更紧凑一些:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003emy \\ff = -\u0026gt; \\s { say \u0026quot;False {s}!\u0026quot; };\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ePython 使用 \u003ccode\u003elambda\u003c/code\u003e 关键字:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"n\"\u003ett\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003elambda\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"k\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;True \u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;!\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"n\"\u003eff\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003elambda\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"k\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;False \u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;!\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e所以现在我们可以说:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003emy \u0026amp;res_f = choose(tt, ff, True);\n\nsay \u0026amp;res_f; #=\u0026gt; says sub { }\nres_f(\u0026quot;story\u0026quot;); #=\u0026gt; says \u0026quot;True story!\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e当我们打印出函数所绑定的变量时，Raku 返回 \u003ccode\u003esub { }\u003c/code\u003e 来表示该变量包含一个函数。\u003c/p\u003e\n\u003cp\u003e在 Python 中:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"n\"\u003eres_f\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003echoose\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ett\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eff\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"bp\"\u003eTrue\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003eres_f\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"c1\"\u003e#=\u0026gt; says \u0026lt;function \u0026lt;lambda\u0026gt; at 0x7f829b298b80\u0026gt;\u003c/span\u003e\n\u003cspan class=\"n\"\u003eres_f\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;story\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"c1\"\u003e#=\u0026gt; says \u0026#34;True story!\u0026#34;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"例子-map-grep-和-reduce\"\u003e例子: \u003ccode\u003emap\u003c/code\u003e、 \u003ccode\u003egrep\u003c/code\u003e 和 \u003ccode\u003ereduce\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e函数的功能有很多用途，我只想重点介绍三个在 Raku 中现成的例子：\u003ccode\u003emap\u003c/code\u003e、\u003ccode\u003ereduce\u003c/code\u003e 和 \u003ccode\u003egrep\u003c/code\u003e。Python 有 \u003ccode\u003emap\u003c/code\u003e 和 \u003ccode\u003efilter\u003c/code\u003e，并通过 \u003ccode\u003efunctools\u003c/code\u003e 模块提供 \u003ccode\u003ereduce\u003c/code\u003e。这些函数的共同点是，它们提供了一种对列表进行 \u003ccode\u003efor\u003c/code\u003e 循环的替代方法。\u003c/p\u003e\n\u003ch3 id=\"map--对列表中的所有元素进行函数应用\"\u003e\u003ccode\u003emap\u003c/code\u003e : 对列表中的所有元素进行函数应用\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003emap\u003c/code\u003e 有两个参数：一个函数和一个列表。它将函数按顺序应用于列表中的所有值，并返回结果，例如将列表中的所有值平方。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003emy \\res = map -\u0026gt; \\x {x*x} , 1 .. 10;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在 Python 中，我们需要显式地创建元组，但除了语法上的差异，结构是完全一样的。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"n\"\u003eres\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003etuple\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"k\"\u003elambda\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003erange\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e11\u003c/span\u003e\u003cspan class=\"p\"\u003e)))\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这是对传统 \u003ccode\u003efor\u003c/code\u003e 循环的功能替代。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nmy \\res = [];\nfor 1 .. 10 -\u0026gt; \\x {\n    res.push(x*x);\n}\n# Python\nres = []\nfor x in range(1,11):\n    res.append(x*x)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e请注意，在 Raku 和 Python 中，我们需要为 \u003ccode\u003efor\u003c/code\u003e 循环版本使用一个可变的数据结构，而 \u003ccode\u003emap\u003c/code\u003e 版本则使用不可变的数据结构。\u003c/p\u003e\n\u003ch3 id=\"grep--过滤列表\"\u003e\u003ccode\u003egrep\u003c/code\u003e : 过滤列表\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003egrep\u003c/code\u003e (在 Python 中称为 \u003ccode\u003efilter\u003c/code\u003e)也接受参数，一个函数和一个列表，但它只返回函数返回真的列表中的值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nmy \\res = grep -\u0026gt; \\x { x % 5 == 0 }, 1 .. 30;\n# Python\nres = tuple(filter( lambda x : x % 5 == 0 ,range(1,31)))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e当然我们也可以用 \u003ccode\u003efor\u003c/code\u003e 循环和 \u003ccode\u003eif\u003c/code\u003e 语句来写，但这又需要一个可变的数据结构。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nmy \\res = [];\nfor 1 .. 30 -\u0026gt; \\x {\n    if (x % 5 == 0) {\n    res.push(x);\n    }\n}\n# Python\nres = []\nfor x in range(1,31): \n  if (x % 5 == 0):\n    res.append(x)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003emap\u003c/code\u003e 和 \u003ccode\u003egrep\u003c/code\u003e 的好处是，你可以很容易地把它们链在一起。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\ngrep -\u0026gt; \\x { x % 5 == 0 }, map -\u0026gt; \\x {x*x}, 1..30\n# Python\nres = tuple(filter( lambda x : x % 5 == 0 ,map( lambda x : x*x ,range(1,31))))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这是因为 \u003ccode\u003emap\u003c/code\u003e 和 \u003ccode\u003egrep\u003c/code\u003e 接受一个列表并返回一个列表，所以只要你需要对一个列表进行操作，就可以通过链式调用来实现。\u003c/p\u003e\n\u003ch3 id=\"reduce--化整为零\"\u003e\u003ccode\u003ereduce\u003c/code\u003e : 化整为零\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ereduce\u003c/code\u003e 也接受一个函数和一个 list，但它使用函数将 list 的所有元素合并成一个结果。所以函数必须接受两个参数。第二个参数是从列表中取出的元素，第一个参数作为状态变量来组合所有元素。例如，计算一个数字列表的和:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nmy \\sum = reduce sub (\\acc,\\elt) {acc+elt}, 1 .. 10;\n\nsay sum; #=\u0026gt; says 55\n# Python\nfrom functools import reduce\n\nsum = reduce(lambda acc,elt: acc+elt, range(1,11))\n\nprint( sum); #=\u0026gt; says 55\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这里发生的情况是，首先将 \u003ccode\u003eacc\u003c/code\u003e 设置为列表中的第一个元素(1)，然后加上第二个元素，所以 \u003ccode\u003eacc\u003c/code\u003e 变成 1+2=3；然后加上第三个元素(3)，以此类推。其效果是将列表中的所有数字连续相加。\u003c/p\u003e\n\u003cp\u003e为了更清楚地说明这一点，我们来写一个我们自己的 \u003ccode\u003ereduce\u003c/code\u003e 版本。\u003c/p\u003e\n\u003ch3 id=\"编写你自己的\"\u003e编写你自己的\u003c/h3\u003e\n\u003cp\u003e在许多函数式语言中，从左到右（从最低索引开始）和从右到左（从最高索引开始）的还原是有区别的。这一点很重要，因为根据做还原的函数，如果从左边或右边消耗列表，结果可能会不同。例如，假设我们的化简函数是\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\n-\u0026gt; \\x,\\y {x+y}\n# Python\nlambda x,y: x+y\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e那么我们从哪个方向遍历列表并不重要。但考虑以下函数:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\n-\u0026gt; \\x,\\y { x \u0026lt; y ?? x+y !! x }\n\n# Python\nlambda x,y: x+y if x\u0026lt;y else x\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e( \u003ccode\u003e... ?? ... !! ...\u003c/code\u003e 是条件操作符的 Raku 句法，在大多数其他语言中是 \u003ccode\u003e... ? ... : ...\u003c/code\u003e 在 Python 中是 \u003ccode\u003e... if ... else ...\u003c/code\u003e)。\u003c/p\u003e\n\u003cp\u003e在这种情况下，如果列表从左或从右还原，结果会有所不同。在 Raku 和 Python 中，\u003ccode\u003ereduce\u003c/code\u003e 是一种从左到右的还原。\u003c/p\u003e\n\u003cp\u003e另外，\u003ccode\u003ereduce\u003c/code\u003e 函数可以不使用列表的第一个元素，而是取一个额外的参数，通常称为累加器。在函数式语言中，\u003ccode\u003ereduce\u003c/code\u003e 通常被称为 \u003ccode\u003efold\u003c/code\u003e，所以我们可以有一个左折和一个右折。让我们来看看如何实现这些。\u003c/p\u003e\n\u003ch4 id=\"left-fold\"\u003eLeft fold\u003c/h4\u003e\n\u003cp\u003e实现左折的直接方法（所以和 \u003ccode\u003ereduce\u003c/code\u003e 一样）是在函数内部使用 \u003ccode\u003efor\u003c/code\u003e 循环。这意味着我们必须在循环的每次迭代上更新累加器的值。在 Raku 中，无符号变量是不可变的（我在这里简化了，完整的故事请看 \u003ca href=\"https://docs.raku.org/language/containers#Binding\"\u003eRaku 文档\u003c/a\u003e），所以我们需要使用一个有符号的变量，\u003ccode\u003e$acc\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nsub foldll (\u0026amp;f, \\iacc, \\lst) { \n  my $acc = iacc; \n  for lst -\u0026gt; \\elt {\n    $acc = f($acc,elt);\n  }\n  $acc;\n}\n\n# Python\ndef foldll (f, iacc, lst):\n  acc = iacc\n  for elt in lst:\n    acc = f(acc,elt)  \n  return acc\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果我们只想使用不可变的变量，我们可以使用递归。Raku 使这一点变得简单，因为它允许一个子程序有多个签名(\u003ccode\u003emulti sub\u003c/code\u003e)，并且它会调用与签名相匹配的变量。\u003c/p\u003e\n\u003cp\u003e我们的 \u003ccode\u003efoldl\u003c/code\u003e 将消耗输入列表 \u003ccode\u003elst\u003c/code\u003e，并使用 \u003ccode\u003ef\u003c/code\u003e 将其元素组合到累加器 \u003ccode\u003eacc\u003c/code\u003e 中，当列表被消耗后，计算结束，我们可以返回 \u003ccode\u003eacc\u003c/code\u003e 作为结果。所以我们的第一个变体说，如果输入列表是空的，我们应该返回 \u003ccode\u003eacc\u003c/code\u003e。 第二个变体从列表中取出一个元素 \u003ccode\u003eelt\u003c/code\u003e (关于 \u003ccode\u003e*\u003c/code\u003e 的细节请参见 \u003ca href=\"https://docs.raku.org/type/Range\"\u003eRaku 文档\u003c/a\u003e)，并将其与 \u003ccode\u003eacc\u003c/code\u003e 结合到 \u003ccode\u003ef(acc,elt)\u003c/code\u003e 中。然后用这个新的累加器和 list 的剩余部分 \u003ccode\u003erest\u003c/code\u003e 再次调用 \u003ccode\u003efoldl\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# When the list is empty, return the accumulator\nmulti sub foldl (\u0026amp;f, \\acc, ()) { acc }\nmulti sub foldl (\u0026amp;f, \\acc, \\lst) {\n  # Raku's way of splitting a list in the first elt and the rest\n  # The '*' is a shorthand for the end of the list\n   my (\\elt,\\rest) = lst[0, 1 .. * ]; \n   # The actual recursion\n   foldl( \u0026amp;f, f(acc, elt), rest);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ePython 不允许这种模式匹配，所以我们需要使用条件来编写递归。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003efoldl\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eacc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003elst\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n  \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003elst\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"p\"\u003e():\u003c/span\u003e \n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eacc\u003c/span\u003e \n  \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n  \u003cspan class=\"c1\"\u003e# Python\u0026#39;s way of splitting a tuple in the first elt and the rest\u003c/span\u003e\n  \u003cspan class=\"c1\"\u003e# rest will be a list, not a tuple, but we\u0026#39;ll let that pass\u003c/span\u003e\n   \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eelt\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003erest\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003elst\u003c/span\u003e \n   \u003cspan class=\"c1\"\u003e# The actual recursion\u003c/span\u003e\n   \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003efoldl\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eacc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eelt\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003erest\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在这个实现中，所有的变量都不会被更新。所以所有的变量都可以是不可变的。\u003c/p\u003e\n\u003ch4 id=\"right-fold\"\u003eRight fold\u003c/h4\u003e\n\u003cp\u003e右折与左折颇为相似。对于基于循环的版本，我们所做的只是将列表反转(\u003ccode\u003ereverse\u003c/code\u003e)。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nsub foldrl (\u0026amp;f, \\acc, \\lst) { \n  my $res = acc;\n  for  lst.reverse -\u0026gt; \\elt {\n    $res = f($res,elt);\n  }\n  $res;\n}\n\n# Python\ndef foldlr (f, iacc, lst):\n  acc = iacc\n  for elt in lst.reverse():\n    acc = f(acc,elt)  \n  return acc\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在递归版本中，我们从列表中取最后一个元素而不是第一个元素。关于 \u003ccode\u003e..^ * - 1\u003c/code\u003e 语法的细节，请参见 \u003ca href=\"https://docs.raku.org/language/operators#infix_..%5E\"\u003eRaku 文档\u003c/a\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nmulti sub foldr ( \u0026amp;f, \\acc, ()) { acc }\nmulti sub foldr (\u0026amp;f, \\acc, \\lst) {\n    my (\\rest,\\elt) = lst[0..^*-1, *  ];\n    foldr( \u0026amp;f, f(acc, elt), rest);\n}\n\n# Python\ndef foldr (f, acc, lst):\n  if lst == (): \n    return acc \n  else:\n   (*rest,elt) = lst \n   return foldr( f, f(acc, elt), rest)\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"map-and-grep-are-folds\"\u003e\u003ccode\u003emap\u003c/code\u003e and \u003ccode\u003egrep\u003c/code\u003e are folds\u003c/h4\u003e\n\u003cp\u003e现在，\u003ccode\u003emap\u003c/code\u003e 和 \u003ccode\u003egrep\u003c/code\u003e 呢？我们当然可以用 \u003ccode\u003efor\u003c/code\u003e 循环来实现，但我们也可以用我们的 \u003ccode\u003efoldl\u003c/code\u003e 来实现它们。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nsub map (\u0026amp;f,\\lst) {\n    foldl( sub (\\acc,\\elt) {\n            (|acc,f(elt))\n            }, (), lst);\n}\n\n# Python\ndef map (f,lst):\n    return foldl( \n      lambda acc,elt:(*acc, f(elt))\n      ,()\n      ,lst\n    )\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e因为函数 \u003ccode\u003ef\u003c/code\u003e 是可映射的，所以它只有一个参数。但是 \u003ccode\u003efoldl\u003c/code\u003e 需要一个有两个参数的函数，第一个参数为累加器。所以我们用两个参数的匿名函数调用 \u003ccode\u003efoldl\u003c/code\u003e。累积器本身是一个空列表。虽然我们前面说过，还原将原来列表的所有元素合并成一个返回值，当然这个返回值可以是任何数据类型，所以也是一个列表。所以我们对原始列表中的每一个元素都调用 \u003ccode\u003ef\u003c/code\u003e，并将其添加到累加器列表的末尾。(\u003ccode\u003e|\u003c/code\u003e 将列表扁平化，所以 \u003ccode\u003e(|acc,f(elt))\u003c/code\u003e 是一个由 \u003ccode\u003eacc\u003c/code\u003e 的元素和 \u003ccode\u003ef(elt)\u003c/code\u003e 的结果建立的新列表。)\u003c/p\u003e\n\u003cp\u003e类似地，我们也可以定义 \u003ccode\u003egrep\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nsub grep (\u0026amp;f,\\lst) {\n    foldl( sub (\\acc,\\elt) {\n      if (f(elt)) {\n          (|acc,elt)\n      } else {\n          acc\n      }\n    }, (), lst);\n}\n\n# Python\ndef filter (f,lst):\n    return foldl( \n      lambda acc,elt:\n        (*acc,elt) if f(elt) else acc\n      , (), lst)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e就像在 \u003ccode\u003emap\u003c/code\u003e 实现中一样，我们用一个匿名函数调用 \u003ccode\u003efoldl\u003c/code\u003e。在这个函数中，我们测试 \u003ccode\u003elst\u003c/code\u003e 中的每个 \u003ccode\u003eelt\u003c/code\u003e 是否为 \u003ccode\u003ef(elt)\u003c/code\u003e 为真。如果是真，我们就从 \u003ccode\u003eacc\u003c/code\u003e 和 \u003ccode\u003eelt\u003c/code\u003e 创建一个新的列表，否则我们就只返回 \u003ccode\u003eacc\u003c/code\u003e。 因为 \u003ccode\u003emap\u003c/code\u003e 和 \u003ccode\u003egrep\u003c/code\u003e 分别对列表中的每个元素进行操作，所以我们也可以使用右折来实现它们。\u003c/p\u003e\n\u003cp\u003e通过这些例子，我希望无论是对函数工作的概念，还是对函数可能的实现方式，都变得更加清晰。递归实现的优点是它允许我们使用不可变的数据结构。\u003c/p\u003e\n\u003ch3 id=\"为什么是不可变的数据结构\"\u003e为什么是不可变的数据结构？\u003c/h3\u003e\n\u003cp\u003e你可能会好奇为什么我关注这些不可变的数据结构。正如我们将看到的那样，函数式编程与不可改变的数据结构配合得非常好。而且它们有一个很大的优势：你永远不用担心是否不小心修改了你的数据，也不用担心是否应该做一个副本来确定。所以使用不可变数据结构可以使代码不易出错，更容易调试。它们还具有潜在的性能优势。而我们接下来会看到，在 Raku 中还有另一个优势。\u003c/p\u003e\n\u003ch2 id=\"返回函数的函数\"\u003e返回函数的函数\u003c/h2\u003e\n\u003cp\u003e函数也可以返回函数。如果我们想拥有一个可参数化的函数，这一点尤其有用。举个简单的例子，假设我们想要一系列以固定值递增一个数字的函数：\u003ccode\u003eadd1\u003c/code\u003e、\u003ccode\u003eadd2\u003c/code\u003e 等。当然，我们可以分别写出每一个函数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nsub add_1 (\\x) {x+1}\nsub add_2 (\\x) {x+2}\nsub add_3 (\\x) {x+3}\nsub add_4 (\\x) {x+4}\nsub add_5 (\\x) {x+5}\n\nsay add_1(4); #=\u0026gt; says 5\n# Python\ndef add_1 (x) : return x+1\ndef add_2 (x) : return x+2\ndef add_3 (x) : return x+3\ndef add_4 (x) : return x+4\ndef add_5 (x) : return x+5\n\nprint( add_1(4)) #=\u0026gt; says 5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e或者我们可以使用一个充满匿名函数的列表。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nmy \\add =\nsub (\\x) {x},\nsub (\\x) {x+1},\nsub (\\x) {x+2},\nsub (\\x) {x+3},\nsub (\\x) {x+4},\nsub (\\x) {x+5};\n\nsay add[0].(4); #=\u0026gt; says 5\n\n\n# Python\nadd = (\nlambda x : x+1,\nlambda x : x+2,\nlambda x : x+3,\nlambda x : x+4,\nlambda x : x+5\n)\n\nprint( add[0](4)) #=\u0026gt; says 5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们可以做得更好，用一个循环来填充一个匿名函数的数组。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nmy \\add = [];\nfor 0 .. 5 -\u0026gt; \\n {\n  add.push(sub (\\x) {x+n});\n}\n\nsay add[1].(4); #=\u0026gt; says 5\n\n# Python\nadd = []\nfor n in range(0,6):\n  add.append(lambda x: x+n)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们每次循环迭代都会创建一个新的匿名函数，并将其添加到数组中。但是，我们可以使用一个函数来创建这些匿名函数，然后我们可以使用 \u003ccode\u003emap\u003c/code\u003e 来代替循环，并使用一个不可改变的数据结构。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nsub gen_add(\\n) {  \n  sub (\\x) {x+n}\n}\n\nmy \\add = map \u0026amp;gen_add, 0..5;\n\nsay add[1].(4); #=\u0026gt; says 5\n\n# Python\ndef gen_add(n):  \n  return lambda x : x+n\n\nadd = tuple(map( gen_add, range(0,6)))\n\nprint( add[1](4)) #=\u0026gt; says 5\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"laziness\"\u003eLaziness\u003c/h3\u003e\n\u003cp\u003e在 Raku 中，使用(不可改变的)范围有一个额外的好处：我们可以将范围的末端设置为无穷大，在 Raku 中可以写成 \u003ccode\u003e∞\u003c/code\u003e(unicode 221E)、\u003ccode\u003e*\u003c/code\u003e 或 \u003ccode\u003eInf\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nmy \\add = map \u0026amp;gen_add, 0 .. ∞;  \n\nsay add[244].(7124); #=\u0026gt; says 7368\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这是一个所谓的\u0026quot;懒惰求值\u0026quot;的例子，简称 laziness：Raku 不会尝试（和失败）处理这个无限的列表。相反，它将在我们实际使用该列表中的一个元素时进行处理。表达式的评估会延迟到需要结果的时候，所以当我们调用 \u003ccode\u003eadd[244]\u003c/code\u003e 时，发生的情况是 \u003ccode\u003egen_add(244)\u003c/code\u003e 被调用来生成该函数。请注意，这在 \u003ccode\u003efor\u003c/code\u003e 循环中是行不通的，因为要使用 \u003ccode\u003efor\u003c/code\u003e 循环，我们需要一个可变的数据结构，而惰性列表必须是不可变的。所以这是一个很好的例子，说明函数式编程风格如何让你从懒惰中获益。\u003c/p\u003e\n\u003cp\u003e这也是为什么我们递归地实现了 \u003ccode\u003efoldl\u003c/code\u003e，然后用它来实现我们自己的 \u003ccode\u003emap\u003c/code\u003e 和 \u003ccode\u003egrep\u003c/code\u003e：基于递归的版本不需要更新任何变量，所以它们可以与不可变的惰性数据结构一起工作。\u003c/p\u003e\n\u003ch2 id=\"函数组合\"\u003e函数组合\u003c/h2\u003e\n\u003cp\u003e我们在上面看到，你可以把 \u003ccode\u003emap\u003c/code\u003e 和 \u003ccode\u003egrep\u003c/code\u003e 的调用链在一起。通常情况下，你只需要将 \u003ccode\u003emap\u003c/code\u003e 调用链在一起，例如\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nmap -\u0026gt; \\x { x + 5 }, map -\u0026gt; \\x {x*x}, 1..30;\n\n# Python\nmap( lambda x : x + 5, map( lambda x : x*x, range(1,31)))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在这种情况下，我们可以做得更有效率一些：比起创建一个列表，然后在这个列表上调用 \u003ccode\u003emap\u003c/code\u003e，我们可以通过组合函数一次完成两个计算。Raku 为此提供了一个特殊的操作符。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003emap -\u0026gt; \\x { x + 5 } ∘ -\u0026gt; \\x { x * x }, 1..30;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e操作符 \u003ccode\u003e∘\u003c/code\u003e（\u0026ldquo;环形操作符\u0026rdquo;，unicode 2218，但你也可以用普通的 \u003ccode\u003eo\u003c/code\u003e）是函数组成操作符，它的发音是 \u0026ldquo;after\u0026rdquo;，所以 \u003ccode\u003ef ∘ g\u003c/code\u003e 是 \u0026ldquo;f after g\u0026rdquo;。它的作用是将两个现有的函数组合起来，创建一个新的函数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003emy \u0026amp;h = \u0026amp;f ∘ \u0026amp;g;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e是下面的代码是一样的:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003esub h (\\x) {\n    f(g(x))\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e组成运算符的优点是，它可以适用于任何函数，包括匿名函数。但实际上，它只是另一个高阶函数。它只是下面函数的运算符形式。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl6\" data-lang=\"perl6\"\u003e# Raku\nsub compose(\u0026amp;f,\u0026amp;g) {\n    sub (\\x) { f(g(x)) }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ePython 没有函数组成操作符，但你也可以很容易地在 Python 中拥有 \u003ccode\u003ecompose\u003c/code\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"c1\"\u003e# Python\u003c/span\u003e\n\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003ecompose\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eg\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"k\"\u003elambda\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eg\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"结论\"\u003e结论\u003c/h2\u003e\n\u003cp\u003e在这篇文章中，我用 Raku 和 Python 的例子介绍了三种关键的函数式编程技术：对函数进行操作的函数、返回函数的函数和函数组成。我已经展示了你如何使用函数 \u003ccode\u003emap\u003c/code\u003e、\u003ccode\u003ereduce\u003c/code\u003e(折叠)和 \u003ccode\u003egrep\u003c/code\u003e(过滤)来操作不可变的列表。我已经解释了哟(如何用递归和不递归实现这样的函数，以及递归实现的优势是什么。下面是《 \u003ca href=\"https://github.com/wimvanderbauwhede/raku-examples/blob/master/decluttering-with-functional-programming.raku\"\u003eRaku\u003c/a\u003e 与 \u003ca href=\"https://github.com/wimvanderbauwhede/raku-examples/blob/master/decluttering-with-functional-programming.py\"\u003ePython\u003c/a\u003e》一文中的代码。\u003c/p\u003e\n\u003cp\u003e当然，函数式编程的内容还有很多，我也写了\u003ca href=\"https://wimvanderbauwhede.github.io/articles/\"\u003e几篇更高级的文章\u003c/a\u003e。本文介绍的概念应该为理解那些更高级的主题打下良好的基础。如果你想了解更多关于函数式编程的知识，你可以考虑我的\u003ca href=\"https://www.futurelearn.com/courses/functional-programming-haskell\"\u003e免费在线课程\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e原文: \u003ca href=\"https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/\"\u003ehttps://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/\u003c/a\u003e\u003c/p\u003e\n","text":"函数式编程是一种编程风格，现代语言或多或少都支持这种风格。在这篇文章中，我想解释一下函数式编程如何为你提供强大的抽象，使你的代码更加简洁。我将用 Raku 和 Python 中的例子来说明这一点，我们将看到这两种语言都是函数式编程的优秀语言。\nRaku: 简介 本文的代码示例是用 Python 和 Raku 编写的。我想大多数人都熟悉 Python，但 Raku 不太为人所知，所以我先解释一下基础知识。本文中的代码不是很习惯，所以如果你懂得其他编程语言，应该很容易理解。\nRaku 与 Perl 最为相似。两种语言在语法上都与 C/C++、Java 和 JavaScript 相似：基于块，语句用分号隔开，块用大括号分界，参数列表放在括号中，用逗号隔开。将 Perl 和 Raku 与其他语言区分开来的主要特征是使用魔符（\u0026ldquo;有趣的字符\u0026rdquo;）来识别变量的类型：$ 代表标量，@ 代表数组，% 代表哈希（映射），\u0026amp; 代表子程序。变量也有关键字来标识它们的作用域，我只用 my 来标识变量的词法作用域。子程序是用 sub 关键字来声明的，子程序可以是命名的，也可以是匿名的。\nsub square ($x) { $x*$x; } # anonymous subroutine my $anon_square = sub ($x) { $x*$x; } 在 Python 中，这将是：\ndef square(x): return x*x # anonymous subroutine  anon_square = lambda x: x*x Raku 支持无符号变量，并使用 \\ 语法来声明它们。更多关于普通变量和无符号变量之间的区别，请参见 Raku 文档。例如(say 打印它的参数，后面加一个换行)。\nmy \\x = 42; # sigilless my $y = 43; say x + $y; 在本文的代码中，我将尽可能地使用无符号变量。\nRaku 有几种类型的序列数据结构。在下面的代码中，我将使用列表和数组以及范围。在 Raku 中，列表和数组的主要区别在于，列表是不可变的，这意味着一旦创建，就不能修改。所以它是一个只读的数据结构。要\u0026quot;更新\u0026quot;一个不可变的数据结构，你需要创建一个更新的副本。另一方面，数组是可变的，所以我们可以更新它们的元素，扩展它们，缩小它们等等。所有的更新都发生在原始数据的位置上。\nRaku 的数组类似于 Python 的 list，Raku 的 list 类似于 Python 的 tuple，也是不可变的。除了语法之外，Raku 中的范围与 Python 中的范围相似，都是不可变的。\nmy @array1 = 1,2,3; #=\u0026gt; an array because of the '@' sigil my \\array2 = [1,2,3]; #=\u0026gt; an array, because of the '[...]' my \\range1 = 1 .. 10; #=\u0026gt; a range 1 .. 10 my @array3 = 1 .. 10; #=\u0026gt; an array from a range, because of the '@' sigil my \\list1 = 1,2,3; #=\u0026gt; a list my $list2 = (1,2,3); #=\u0026gt; also a list my \\list3 = |(1 .. 10); #=\u0026gt; an array from a range because of the '|' flattening operation 相应的 Python 代码为:\nlist1 = list((1,2,3)) #=\u0026gt; a list from a tuple list2 = [1,2,3]; #=\u0026gt; a list, because of the \u0026#39;[...]\u0026#39; range1 = range(1,11) #=\u0026gt; a range 1 .. 10 list3 = list(range(1,11)); #=\u0026gt; a list from a range tuple1 = 1,2,3; #=\u0026gt; a tuple tuple2 = tuple([1,2,3]) #=\u0026gt; a tuple from a list tuple3 = tuple(range(1,11)) #=\u0026gt; creates a tuple from a range 其他具体的语法或功能将针对具体的例子进行解释。\n其他任何名称的函数 - 作为值的函数 函数是函数式编程的精髓。正如我在\u0026ldquo;万物皆函数\u0026rdquo;一文中所解释的那样，在适当的函数式语言中，所有的结构都是由函数构建的。\n所有现代编程语言都有函数、程序、子程序或方法的概念。它们是代码重用的重要机制。通常，我们认为函数是对一些输入值进行操作以产生一个或多个输出值的东西。输入值可以是全局声明的，也可以是一个类的属性，或者作为参数传递给函数。同样，输出值可以直接返回，到全局变量，作为类的属性或通过修改输入值。\n要想从函数式编程中获益最多，最好是函数是纯粹的，这意味着对函数的调用总是对相同的输入产生相同的输出。在实践中，如果函数只接受输入作为参数，并直接返回输出，这一点比较容易实现，但这并不是必不可少的。\n函数式编程的关键特征是，函数的输入值和输出值本身可以是函数。所以函数必须是你语言中的值。有时这被称为 \u0026ldquo;函数必须是一等公民\u0026rdquo;，一个接收和/或返回函数的函数有时被称为\u0026quot;高阶函数\u0026quot;。\n如果函数是值，那么我们就可以将它们赋值给变量。特别是我们会将它们赋值给其他函数的参数。但我们也可以将它们赋值给普通的变量。\n让我们考虑以下函数，choose，它需要三个参数 t，f 和 c。\n# Raku sub choose (\\t, \\f, \\d) { if (d) {t} else {f} } # Python def choose (t, f, d): if d: return t else: return f 首先让我们用字符串作为前两个参数的值来调用 choose。\n# Raku my \\tstr = \u0026quot;True!\u0026quot;; my \\fstr = \u0026quot;False!\u0026quot;; my \\res_str = choose(tstr, fstr, True); say res_str; #=\u0026gt; says \u0026quot;True!\u0026quot; # Python tstr = \u0026quot;True!\u0026quot; fstr = \u0026quot;False!\u0026quot; res_str = choose(tstr,fstr,True) print(res_str) #=\u0026gt; says \u0026quot;True!\u0026quot; 现在让我们尝试用函数作为参数:\n# Raku sub tt (\\s) { say \u0026quot;True {s}!\u0026quot; } sub ff (\\s) { say \u0026quot;False {s}!\u0026quot; } my \u0026amp;res_f = choose(\u0026amp;tt, \u0026amp;ff, False); say \u0026amp;res_f; #=\u0026gt; says \u0026amp;ff res_f(\u0026quot;rumour\u0026quot;); #=\u0026gt; says \u0026quot;False rumour!\u0026quot; # Python def tt(s): print( \u0026quot;True \u0026quot;+s+\u0026quot;!\u0026quot;) def ff(s): print( \u0026quot;False\u0026quot;+s+\u0026quot;!\u0026quot;) res_f = choose(tt,ff,True) print(res_f) #=\u0026gt; says \u0026lt;function tt at 0x7f829c3aa310\u0026gt; res_f(\u0026quot;rumour\u0026quot;) #=\u0026gt; says \u0026quot;False rumour!\u0026quot; 因此，我们的函数 choose 接收两个函数作为它的前两个参数，并返回一个函数。在 Raku 中，我们需要在函数名上加上 \u0026amp; 符号，因为否则它们会被求值：像 tt 这样的裸函数名就等于调用没有参数的函数 tt()。通过将这个函数赋值给一个变量(res_f)，我们现在可以将 res_f 作为一个函数来调用，它最终会根据选择来调用 tt 或 ff。\n函数不需要名字 现在，如果我们可以将函数赋值给变量，它们本身其实并不需要一个名字。所以我们的函数可以是匿名的。大多数语言都支持匿名函数，在函数式语言中，它们通常被称为 \u0026ldquo;lambda 函数\u0026rdquo;。在 Raku 中，我们有两种方法来创建匿名函数。\n使用 sub (...) 语法:\nmy \\tt = sub (\\s) { say \u0026quot;True {s}!\u0026quot; }; 或者使用\u0026lsquo;尖号块\u0026rsquo;语法，这样更紧凑一些:\nmy \\ff = -\u0026gt; \\s { say \u0026quot;False {s}!\u0026quot; }; Python 使用 lambda 关键字:\ntt = lambda s : print( \u0026#34;True \u0026#34;+s+\u0026#34;!\u0026#34; ) ff = lambda s : print( \u0026#34;False \u0026#34;+s+\u0026#34;!\u0026#34; ) 所以现在我们可以说:\nmy \u0026amp;res_f = choose(tt, ff, True); say \u0026amp;res_f; #=\u0026gt; says sub { } res_f(\u0026quot;story\u0026quot;); #=\u0026gt; says \u0026quot;True story!\u0026quot; 当我们打印出函数所绑定的变量时，Raku 返回 sub { } 来表示该变量包含一个函数。\n在 Python 中:\nres_f = choose(tt, ff, True); print( res_f) #=\u0026gt; says \u0026lt;function \u0026lt;lambda\u0026gt; at 0x7f829b298b80\u0026gt; res_f(\u0026#34;story\u0026#34;) #=\u0026gt; says \u0026#34;True story!\u0026#34; 例子: map、 grep 和 reduce 函数的功能有很多用途，我只想重点介绍三个在 Raku 中现成的例子：map、reduce 和 grep。Python 有 map 和 filter，并通过 functools 模块提供 reduce。这些函数的共同点是，它们提供了一种对列表进行 for 循环的替代方法。\nmap : 对列表中的所有元素进行函数应用 map 有两个参数：一个函数和一个列表。它将函数按顺序应用于列表中的所有值，并返回结果，例如将列表中的所有值平方。\nmy \\res = map -\u0026gt; \\x {x*x} , 1 .. 10; 在 Python 中，我们需要显式地创建元组，但除了语法上的差异，结构是完全一样的。\nres = tuple( map( lambda x : x*x , range(1,11))) 这是对传统 for 循环的功能替代。\n# Raku my \\res = []; for 1 .. 10 -\u0026gt; \\x { res.push(x*x); } # Python res = [] for x in range(1,11): res.append(x*x) 请注意，在 Raku 和 Python 中，我们需要为 for 循环版本使用一个可变的数据结构，而 map 版本则使用不可变的数据结构。\ngrep : 过滤列表 grep (在 Python 中称为 filter)也接受参数，一个函数和一个列表，但它只返回函数返回真的列表中的值。\n# Raku my \\res = grep -\u0026gt; \\x { x % 5 == 0 }, 1 .. 30; # Python res = tuple(filter( lambda x : x % 5 == 0 ,range(1,31))) 当然我们也可以用 for 循环和 if 语句来写，但这又需要一个可变的数据结构。\n# Raku my \\res = []; for 1 .. 30 -\u0026gt; \\x { if (x % 5 == 0) { res.push(x); } } # Python res = [] for x in range(1,31): if (x % 5 == 0): res.append(x) map 和 grep 的好处是，你可以很容易地把它们链在一起。\n# Raku grep -\u0026gt; \\x { x % 5 == 0 }, map -\u0026gt; \\x {x*x}, 1..30 # Python res = tuple(filter( lambda x : x % 5 == 0 ,map( lambda x : x*x ,range(1,31)))) 这是因为 map 和 grep 接受一个列表并返回一个列表，所以只要你需要对一个列表进行操作，就可以通过链式调用来实现。\nreduce : 化整为零 reduce 也接受一个函数和一个 list，但它使用函数将 list 的所有元素合并成一个结果。所以函数必须接受两个参数。第二个参数是从列表中取出的元素，第一个参数作为状态变量来组合所有元素。例如，计算一个数字列表的和:\n# Raku my \\sum = reduce sub (\\acc,\\elt) {acc+elt}, 1 .. 10; say sum; #=\u0026gt; says 55 # Python from functools import reduce sum = reduce(lambda acc,elt: acc+elt, range(1,11)) print( sum); #=\u0026gt; says 55 这里发生的情况是，首先将 acc 设置为列表中的第一个元素(1)，然后加上第二个元素，所以 acc 变成 1+2=3；然后加上第三个元素(3)，以此类推。其效果是将列表中的所有数字连续相加。\n为了更清楚地说明这一点，我们来写一个我们自己的 reduce 版本。\n编写你自己的 在许多函数式语言中，从左到右（从最低索引开始）和从右到左（从最高索引开始）的还原是有区别的。这一点很重要，因为根据做还原的函数，如果从左边或右边消耗列表，结果可能会不同。例如，假设我们的化简函数是\n# Raku -\u0026gt; \\x,\\y {x+y} # Python lambda x,y: x+y 那么我们从哪个方向遍历列表并不重要。但考虑以下函数:\n# Raku -\u0026gt; \\x,\\y { x \u0026lt; y ?? x+y !! x } # Python lambda x,y: x+y if x\u0026lt;y else x ( ... ?? ... !! ... 是条件操作符的 Raku 句法，在大多数其他语言中是 ... ? ... : ... 在 Python 中是 ... if ... else ...)。\n在这种情况下，如果列表从左或从右还原，结果会有所不同。在 Raku 和 Python 中，reduce 是一种从左到右的还原。\n另外，reduce 函数可以不使用列表的第一个元素，而是取一个额外的参数，通常称为累加器。在函数式语言中，reduce 通常被称为 fold，所以我们可以有一个左折和一个右折。让我们来看看如何实现这些。\nLeft fold 实现左折的直接方法（所以和 reduce 一样）是在函数内部使用 for 循环。这意味着我们必须在循环的每次迭代上更新累加器的值。在 Raku 中，无符号变量是不可变的（我在这里简化了，完整的故事请看 Raku 文档），所以我们需要使用一个有符号的变量，$acc。\n# Raku sub foldll (\u0026amp;f, \\iacc, \\lst) { my $acc = iacc; for lst -\u0026gt; \\elt { $acc = f($acc,elt); } $acc; } # Python def foldll (f, iacc, lst): acc = iacc for elt in lst: acc = f(acc,elt) return acc 如果我们只想使用不可变的变量，我们可以使用递归。Raku 使这一点变得简单，因为它允许一个子程序有多个签名(multi sub)，并且它会调用与签名相匹配的变量。\n我们的 foldl 将消耗输入列表 lst，并使用 f 将其元素组合到累加器 acc 中，当列表被消耗后，计算结束，我们可以返回 acc 作为结果。所以我们的第一个变体说，如果输入列表是空的，我们应该返回 acc。 第二个变体从列表中取出一个元素 elt (关于 * 的细节请参见 Raku 文档)，并将其与 acc 结合到 f(acc,elt) 中。然后用这个新的累加器和 list 的剩余部分 rest 再次调用 foldl。\n# When the list is empty, return the accumulator multi sub foldl (\u0026amp;f, \\acc, ()) { acc } multi sub foldl (\u0026amp;f, \\acc, \\lst) { # Raku's way of splitting a list in the first elt and the rest # The '*' is a shorthand for the end of the list my (\\elt,\\rest) = lst[0, 1 .. * ]; # The actual recursion foldl( \u0026amp;f, f(acc, elt), rest); } Python 不允许这种模式匹配，所以我们需要使用条件来编写递归。\ndef foldl (f, acc, lst): if lst == (): return acc else: # Python\u0026#39;s way of splitting a tuple in the first elt and the rest # rest will be a list, not a tuple, but we\u0026#39;ll let that pass (elt,*rest) = lst # The actual recursion return foldl( f, f(acc, elt), rest) 在这个实现中，所有的变量都不会被更新。所以所有的变量都可以是不可变的。\nRight fold 右折与左折颇为相似。对于基于循环的版本，我们所做的只是将列表反转(reverse)。\n# Raku sub foldrl (\u0026amp;f, \\acc, \\lst) { my $res = acc; for lst.reverse -\u0026gt; \\elt { $res = f($res,elt); } $res; } # Python def foldlr (f, iacc, lst): acc = iacc for elt in lst.reverse(): acc = f(acc,elt) return acc 在递归版本中，我们从列表中取最后一个元素而不是第一个元素。关于 ..^ * - 1 语法的细节，请参见 Raku 文档。\n# Raku multi sub foldr ( \u0026amp;f, \\acc, ()) { acc } multi sub foldr (\u0026amp;f, \\acc, \\lst) { my (\\rest,\\elt) = lst[0..^*-1, * ]; foldr( \u0026amp;f, f(acc, elt), rest); } # Python def foldr (f, acc, lst): if lst == (): return acc else: (*rest,elt) = lst return foldr( f, f(acc, elt), rest) map and grep are folds 现在，map 和 grep 呢？我们当然可以用 for 循环来实现，但我们也可以用我们的 foldl 来实现它们。\n# Raku sub map (\u0026amp;f,\\lst) { foldl( sub (\\acc,\\elt) { (|acc,f(elt)) }, (), lst); } # Python def map (f,lst): return foldl( lambda acc,elt:(*acc, f(elt)) ,() ,lst ) 因为函数 f 是可映射的，所以它只有一个参数。但是 foldl 需要一个有两个参数的函数，第一个参数为累加器。所以我们用两个参数的匿名函数调用 foldl。累积器本身是一个空列表。虽然我们前面说过，还原将原来列表的所有元素合并成一个返回值，当然这个返回值可以是任何数据类型，所以也是一个列表。所以我们对原始列表中的每一个元素都调用 f，并将其添加到累加器列表的末尾。(| 将列表扁平化，所以 (|acc,f(elt)) 是一个由 acc 的元素和 f(elt) 的结果建立的新列表。)\n类似地，我们也可以定义 grep:\n# Raku sub grep (\u0026amp;f,\\lst) { foldl( sub (\\acc,\\elt) { if (f(elt)) { (|acc,elt) } else { acc } }, (), lst); } # Python def filter (f,lst): return foldl( lambda acc,elt: (*acc,elt) if f(elt) else acc , (), lst) 就像在 map 实现中一样，我们用一个匿名函数调用 foldl。在这个函数中，我们测试 lst 中的每个 elt 是否为 f(elt) 为真。如果是真，我们就从 acc 和 elt 创建一个新的列表，否则我们就只返回 acc。 因为 map 和 grep 分别对列表中的每个元素进行操作，所以我们也可以使用右折来实现它们。\n通过这些例子，我希望无论是对函数工作的概念，还是对函数可能的实现方式，都变得更加清晰。递归实现的优点是它允许我们使用不可变的数据结构。\n为什么是不可变的数据结构？ 你可能会好奇为什么我关注这些不可变的数据结构。正如我们将看到的那样，函数式编程与不可改变的数据结构配合得非常好。而且它们有一个很大的优势：你永远不用担心是否不小心修改了你的数据，也不用担心是否应该做一个副本来确定。所以使用不可变数据结构可以使代码不易出错，更容易调试。它们还具有潜在的性能优势。而我们接下来会看到，在 Raku 中还有另一个优势。\n返回函数的函数 函数也可以返回函数。如果我们想拥有一个可参数化的函数，这一点尤其有用。举个简单的例子，假设我们想要一系列以固定值递增一个数字的函数：add1、add2 等。当然，我们可以分别写出每一个函数。\n# Raku sub add_1 (\\x) {x+1} sub add_2 (\\x) {x+2} sub add_3 (\\x) {x+3} sub add_4 (\\x) {x+4} sub add_5 (\\x) {x+5} say add_1(4); #=\u0026gt; says 5 # Python def add_1 (x) : return x+1 def add_2 (x) : return x+2 def add_3 (x) : return x+3 def add_4 (x) : return x+4 def add_5 (x) : return x+5 print( add_1(4)) #=\u0026gt; says 5 或者我们可以使用一个充满匿名函数的列表。\n# Raku my \\add = sub (\\x) {x}, sub (\\x) {x+1}, sub (\\x) {x+2}, sub (\\x) {x+3}, sub (\\x) {x+4}, sub (\\x) {x+5}; say add[0].(4); #=\u0026gt; says 5 # Python add = ( lambda x : x+1, lambda x : x+2, lambda x : x+3, lambda x : x+4, lambda x : x+5 ) print( add[0](4)) #=\u0026gt; says 5 我们可以做得更好，用一个循环来填充一个匿名函数的数组。\n# Raku my \\add = []; for 0 .. 5 -\u0026gt; \\n { add.push(sub (\\x) {x+n}); } say add[1].(4); #=\u0026gt; says 5 # Python add = [] for n in range(0,6): add.append(lambda x: x+n) 我们每次循环迭代都会创建一个新的匿名函数，并将其添加到数组中。但是，我们可以使用一个函数来创建这些匿名函数，然后我们可以使用 map 来代替循环，并使用一个不可改变的数据结构。\n# Raku sub gen_add(\\n) { sub (\\x) {x+n} } my \\add = map \u0026amp;gen_add, 0..5; say add[1].(4); #=\u0026gt; says 5 # Python def gen_add(n): return lambda x : x+n add = tuple(map( gen_add, range(0,6))) print( add[1](4)) #=\u0026gt; says 5 Laziness 在 Raku 中，使用(不可改变的)范围有一个额外的好处：我们可以将范围的末端设置为无穷大，在 Raku 中可以写成 ∞(unicode 221E)、* 或 Inf。\n# Raku my \\add = map \u0026amp;gen_add, 0 .. ∞; say add[244].(7124); #=\u0026gt; says 7368 这是一个所谓的\u0026quot;懒惰求值\u0026quot;的例子，简称 laziness：Raku 不会尝试（和失败）处理这个无限的列表。相反，它将在我们实际使用该列表中的一个元素时进行处理。表达式的评估会延迟到需要结果的时候，所以当我们调用 add[244] 时，发生的情况是 gen_add(244) 被调用来生成该函数。请注意，这在 for 循环中是行不通的，因为要使用 for 循环，我们需要一个可变的数据结构，而惰性列表必须是不可变的。所以这是一个很好的例子，说明函数式编程风格如何让你从懒惰中获益。\n这也是为什么我们递归地实现了 foldl，然后用它来实现我们自己的 map 和 grep：基于递归的版本不需要更新任何变量，所以它们可以与不可变的惰性数据结构一起工作。\n函数组合 我们在上面看到，你可以把 map 和 grep 的调用链在一起。通常情况下，你只需要将 map 调用链在一起，例如\n# Raku map -\u0026gt; \\x { x + 5 }, map -\u0026gt; \\x {x*x}, 1..30; # Python map( lambda x : x + 5, map( lambda x : x*x, range(1,31))) 在这种情况下，我们可以做得更有效率一些：比起创建一个列表，然后在这个列表上调用 map，我们可以通过组合函数一次完成两个计算。Raku 为此提供了一个特殊的操作符。\nmap -\u0026gt; \\x { x + 5 } ∘ -\u0026gt; \\x { x * x }, 1..30; 操作符 ∘（\u0026ldquo;环形操作符\u0026rdquo;，unicode 2218，但你也可以用普通的 o）是函数组成操作符，它的发音是 \u0026ldquo;after\u0026rdquo;，所以 f ∘ g 是 \u0026ldquo;f after g\u0026rdquo;。它的作用是将两个现有的函数组合起来，创建一个新的函数。\nmy \u0026amp;h = \u0026amp;f ∘ \u0026amp;g; 是下面的代码是一样的:\nsub h (\\x) { f(g(x)) } 组成运算符的优点是，它可以适用于任何函数，包括匿名函数。但实际上，它只是另一个高阶函数。它只是下面函数的运算符形式。\n# Raku sub compose(\u0026amp;f,\u0026amp;g) { sub (\\x) { f(g(x)) } } Python 没有函数组成操作符，但你也可以很容易地在 Python 中拥有 compose。\n# Python def compose(f,g): return lambda x: f(g(x)) 结论 在这篇文章中，我用 Raku 和 Python 的例子介绍了三种关键的函数式编程技术：对函数进行操作的函数、返回函数的函数和函数组成。我已经展示了你如何使用函数 map、reduce(折叠)和 grep(过滤)来操作不可变的列表。我已经解释了哟(如何用递归和不递归实现这样的函数，以及递归实现的优势是什么。下面是《 Raku 与 Python》一文中的代码。\n当然，函数式编程的内容还有很多，我也写了几篇更高级的文章。本文介绍的概念应该为理解那些更高级的主题打下良好的基础。如果你想了解更多关于函数式编程的知识，你可以考虑我的免费在线课程。\n原文: https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/\n"},"name":"通过函数式编程实现更简洁的代码","published":"2020-07-26T00:00:00+08:00","summary":"Cleaner code with functional programming","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-07-26-cleaner-code-with-functional-programming/"},{"content":{"html":"\u003ch2 id=\"问题\"\u003e问题\u003c/h2\u003e\n\u003cp\u003e在 6.d 版本中, 很多东西都发生了变化, 我们至少需要发布一个版本。\u003ca href=\"https://github.com/perl6/roast/blob/master/docs/announce/6.d.md\"\u003e这里有个列表\u003c/a\u003e。然而, 覆盖面是不完整的。弃用通知采取了不同的形式, 一些新的类型和方法在那里, 一些则没有\u0026hellip;\u0026hellip;\u003c/p\u003e\n\u003cp\u003e用 \u003ccode\u003e#2632\u003c/code\u003e 引用这个问题, 并检查项目, 当你的工作, 无论是通过改变后的文档, 看到没有变化, 需要做它。在这种情况下, 请通过评论或如何解释为什么是这种情况。\u003c/p\u003e\n\u003ch2 id=\"版本控制的变更\"\u003e版本控制的变更\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e \u003ccode\u003e\u0026amp;await\u003c/code\u003e 在等待的时候不再阻塞线程\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e \u003ccode\u003ewhenever\u003c/code\u003e 不在 \u003ccode\u003ereact\u003c/code\u003e 抛出的词法作用域内\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e 在 \u003ccode\u003esub MAIN\u003c/code\u003e 里面的 \u003ccode\u003e$*ARGFILES\u003c/code\u003e 总是由 \u003ccode\u003e$*IN\u003c/code\u003e 馈入\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e 结构(字面上的) \u003ccode\u003e$()\u003c/code\u003e、\u003ccode\u003e@()\u003c/code\u003e 和 \u003ccode\u003e%()\u003c/code\u003e 不复存在\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e 带有 \u003ccode\u003e:D\u003c/code\u003e/\u003ccode\u003e:U\u003c/code\u003e 类型约束的变量默认为约束类型的类型对象(例如, 你可以在它们身上使用 \u003ccode\u003e.new\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e \u003ccode\u003estart\u003c/code\u003e 块在 sink 上下文中附加异常处理程序\u003c/li\u003e\n\u003cli\u003e\u003cdel\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e 例程必须使用 \u003ccode\u003ereturn-rw\u003c/code\u003e 来返回一个 \u003ccode\u003eProxy\u003c/code\u003e, 即使例程被标记为 \u003ccode\u003eis raw\u003c/code\u003e 或 \u003ccode\u003eis rw\u003c/code\u003e\u003c/del\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e 原生的 \u003ccode\u003enum\u003c/code\u003e 类型默认为 \u003ccode\u003e0e0\u003c/code\u003e 而不是 \u003ccode\u003eNaN\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e[6.d]\u003c/strong\u003e 在子程序名中, 保留了键名为 \u003ccode\u003esym\u003c/code\u003e 的冒号对（如\u003ccode\u003e:sym\u0026lt;foo\u0026gt;\u003c/code\u003e）, 以备将来使用\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"废弃\"\u003e废弃\u003c/h2\u003e\n\u003cp\u003e这些方法在 6.d 语言中已被废弃, 并将在 6.e 中被删除。实现者可以选择发出弃用警告, 或者在 6.e 版本发布后更长的时间内提供这些方法。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用 \u003ccode\u003e'-'\u003c/code\u003e (单连字符)作为 \u003ccode\u003e\u0026amp;open\u003c/code\u003e 的特殊路径, 表示特殊的句柄(使用 \u003ccode\u003eIO::Special\u003c/code\u003e 对象代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Handle.slurp-rest\u003c/code\u003e (使用 \u003ccode\u003e.slurp\u003c/code\u003e 代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAny.flatmap\u003c/code\u003e (使用\u003ccode\u003e.flat\u003c/code\u003e 和 \u003ccode\u003e.map\u003c/code\u003e 方法的组合来代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCool.path\u003c/code\u003e (使用 \u003ccode\u003e.IO\u003c/code\u003e 代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePair.freeze\u003c/code\u003e (使用去容器化的参数的 \u003ccode\u003ePair.new\u003c/code\u003e 来代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eStr.subst-mutate\u003c/code\u003e (使用带有 \u003ccode\u003e.=\u003c/code\u003e 方法调用赋值元运算符的 \u003ccode\u003eStr.subst\u003c/code\u003e 代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRational.norm\u003c/code\u003e (现在 \u003ccode\u003eRational\u003c/code\u003e 类型必须在创建时标准化)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Path.child\u003c/code\u003e (使用 \u003ccode\u003e.add\u003c/code\u003e 代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;undefine\u003c/code\u003e (直接分配 \u003ccode\u003eEmpty\u003c/code\u003e/\u003ccode\u003eNil\u003c/code\u003e 代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e:count\u003c/code\u003e \u003ccode\u003e\u0026amp;lines\u003c/code\u003e/\u003ccode\u003eStr.lines\u003c/code\u003e 例程上的参数(使用所返回的 \u003ccode\u003eSeq\u003c/code\u003e 上的 \u003ccode\u003e.elems\u003c/code\u003e 代替)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;is_approx\u003c/code\u003e in Test.pm6 (使用与 \u003ccode\u003e\u0026amp;is-approx\u003c/code\u003e 非常相似的行为来代替)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"新的行为\"\u003e新的行为\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e通过新的可定义的 \u003ccode\u003e\u0026amp;RUN-MAIN\u003c/code\u003e、\u003ccode\u003e\u0026amp;ARGS-TO-CAPTURE\u003c/code\u003e 和 \u003ccode\u003e\u0026amp;GENERATE-USAGE\u003c/code\u003e 子例程改善 \u003ccode\u003esub MAIN\u003c/code\u003e 的自定义处理\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e%\u003c/code\u003e 变量中的 \u003ccode\u003eQuantHash\u003c/code\u003e/\u003ccode\u003eMap\u003c/code\u003e 和 \u003ccode\u003e@\u003c/code\u003e 变量中的 \u003ccode\u003eList\u003c/code\u003e 可以用 \u003ccode\u003eis\u003c/code\u003e 特性来声明（例如，\u003ccode\u003emy %h is Set\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e新的 \u003ccode\u003e\u0026lt;ww\u0026gt;\u003c/code\u003e regex 规则: 只在单词内匹配\u003c/li\u003e\n\u003cli\u003e循环可以从上一条语句的值中产生一个值的列表\u003c/li\u003e\n\u003cli\u003e循环中的 \u003ccode\u003enext\u003c/code\u003e/\u003ccode\u003elast\u003c/code\u003e 收集其最后的语句值, 对它们运行的迭代返回 \u003ccode\u003eEmpty\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.perl\u003c/code\u003e 可以在消耗过的 \u003ccode\u003eSeq\u003c/code\u003e、多维数组、\u003ccode\u003eDate\u003c/code\u003e 和 \u003ccode\u003eCallFrame\u003c/code\u003e 上调用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.gist\u003c/code\u003e 可以在 \u003ccode\u003eAttribute\u003c/code\u003e 上调用\u003c/li\u003e\n\u003cli\u003e对自动生成的 \u003ccode\u003eUSAGE\u003c/code\u003e 信息进行了大量改进\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eis hidden-from-USAGE\u003c/code\u003e 特性，从自动生成的 \u003ccode\u003eUSAGE\u003c/code\u003e 消息中隐藏 \u003ccode\u003esub MAIN\u003c/code\u003e 候选者\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eParameter.perl\u003c/code\u003e 包括可内省的默认值\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e%*ENV\u003c/code\u003e 值是同素异形的\u003c/li\u003e\n\u003cli\u003e尝试使用变量 \u003ccode\u003e$;\u003c/code\u003e、\u003ccode\u003e$,\u003c/code\u003e、\u003ccode\u003e$.\u003c/code\u003e、\u003ccode\u003e$\\\u003c/code\u003e、\u003ccode\u003e$(\u003c/code\u003e、\u003ccode\u003e$)\u003c/code\u003e、\u003ccode\u003e$\u0026lt;\u003c/code\u003e、\u003ccode\u003e$\u0026gt;\u003c/code\u003e、\u003ccode\u003e$/\u003c/code\u003e、\u003ccode\u003e$\\\u003c/code\u003e、\u003ccode\u003e$[\u003c/code\u003e、\u003ccode\u003e$-\u003c/code\u003e、\u003ccode\u003e$+\u003c/code\u003e 和 \u003ccode\u003e$@\u003c/code\u003e 会抛出 \u003ccode\u003eX::Syntax::Perl5Var\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e默认的 \u003ccode\u003eHash.keyof\u003c/code\u003e 返回一个 \u003ccode\u003eStr(Any)\u003c/code\u003e 强转类型对象\u003c/li\u003e\n\u003cli\u003e非 ASCII 数字可以在 \u003ccode\u003e:42foo\u003c/code\u003e 冒号对快捷方式中使用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eStrDistance\u003c/code\u003e 字符串化为 \u003ccode\u003e.after\u003c/code\u003e 字符串\u003c/li\u003e\n\u003cli\u003e更明确的 Pod 表格格式\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEnumeration.enums\u003c/code\u003e 返回一个 \u003ccode\u003eMap\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e各种整数类型的 \u003ccode\u003e.Range\u003c/code\u003e 返回它们支持的值的范围\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emin\u003c/code\u003e/\u003ccode\u003emax\u003c/code\u003e  例程也适用于 \u003ccode\u003eHash\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSignature\u003c/code\u003e 字面值可以包含字符串/数字字面值以及调用者标记\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eList.invert\u003c/code\u003e 通过所需的 \u003ccode\u003ePair\u003c/code\u003e 绑定映射, 导致潜在的类型检查失败\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e:exists\u003c/code\u003e 可以与多维关联下标一起使用\u003c/li\u003e\n\u003cli\u003e动态创建的列表可以用来定义一个枚举\u003c/li\u003e\n\u003cli\u003e在 \u003ccode\u003e.first\u003c/code\u003e 中, Junction 可以作为匹配器使用\u003c/li\u003e\n\u003cli\u003e原生属性可以作为参数中的绑定目标\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eProc\u003c/code\u003e 可以与其他 \u003ccode\u003eProc\u003c/code\u003e 中的 \u003ccode\u003eIO::Pipe\u003c/code\u003e 一起工作\u003c/li\u003e\n\u003cli\u003e类型数组可以用 \u003ccode\u003emy SomeType @array\u003c/code\u003e 和 \u003ccode\u003emy @array of SomeType\u003c/code\u003e 创建\u003c/li\u003e\n\u003cli\u003e当把 \u003ccode\u003eMixy\u003c/code\u003e 强转为 \u003ccode\u003eSetty\u003c/code\u003e/\u003ccode\u003eBaggy \u003c/code\u003e 时, 负数权重的项将被删除\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e:nth\u003c/code\u003e 副词在 \u003ccode\u003em//\u003c/code\u003e 上接受一个 \u003ccode\u003eJunction\u003c/code\u003e 作为参数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCX::Warn' 和 \u003c/code\u003eCX::Done\u003ccode\u003e可以在\u003c/code\u003eCONTROL` phaser 中捕获\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enext\u003c/code\u003e 可用于 \u003ccode\u003ewhenever\u003c/code\u003e 中\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erequire\u003c/code\u003e 符号不再过境性地暴露出来\u003c/li\u003e\n\u003cli\u003e通过 \u003ccode\u003e{...}\u003c/code\u003e 进行多维访问, 类似于 \u003ccode\u003e[...]\u003c/code\u003e 的工作方式\u003c/li\u003e\n\u003cli\u003e在 \u003ccode\u003eEND\u003c/code\u003e 时间打开的任何手柄都会自动关闭\u003c/li\u003e\n\u003cli\u003e在缓存的 \u003ccode\u003eSeq\u003c/code\u003e 上, 当 \u003ccode\u003e\u0026amp;infix:\u0026lt;eqv\u0026gt;\u003c/code\u003e、\u003ccode\u003e.Slip\u003c/code\u003e、\u003ccode\u003e.join\u003c/code\u003e、\u003ccode\u003e.List\u003c/code\u003e、\u003ccode\u003e.list\u003c/code\u003e、\u003ccode\u003e.eager\u003c/code\u003e、\u003ccode\u003e.Array\u003c/code\u003e 和 \u003ccode\u003e.is-lazy\u003c/code\u003e 被调用时, 就会使用缓存列表\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Handle.encoding\u003c/code\u003e 以 \u003ccode\u003eNil\u003c/code\u003e 表示切换到二进制模式\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eis default\u003c/code\u003e 特质与属性一起工作\u003c/li\u003e\n\u003cli\u003e在多重分派中, 带有 \u003ccode\u003eis rw\u003c/code\u003e 特性的参数被认为比没有特性的参数窄\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eArray\u003c/code\u003e、\u003ccode\u003eBlob\u003c/code\u003e 和 \u003ccode\u003eMap\u003c/code\u003e 的 \u003ccode\u003e.gist\u003c/code\u003e 被裁剪成100个元素\u003c/li\u003e\n\u003cli\u003e新的 \u003ccode\u003efor\u003c/code\u003e 语句修饰符 \u003ccode\u003ehyper for\u003c/code\u003e、\u003ccode\u003erace for\u003c/code\u003e 和 \u003ccode\u003elazy for\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efor\u003c/code\u003e 循环自动序列化 \u003ccode\u003eRaceSeq\u003c/code\u003e/\u003ccode\u003eHyperSeq\u003c/code\u003e；使用新的 \u003ccode\u003efor\u003c/code\u003e 语句修饰符\u003ccode\u003ehyper for\u003c/code\u003e/\u003ccode\u003erace for\u003c/code\u003e避免\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;infix:\u0026lt;does\u0026gt;\u003c/code\u003e 可用于 RHS 上的非组合实例\u003c/li\u003e\n\u003cli\u003e数值比较器可以与 \u003ccode\u003eDateTime \u003c/code\u003e 对象一起使用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePod\u003c/code\u003e 保留空白类型\u003c/li\u003e\n\u003cli\u003e定义了带 \u003ccode\u003e@\u003c/code\u003e、\u003ccode\u003e%\u003c/code\u003e 和 \u003ccode\u003e\u0026amp;\u003c/code\u003e 魔符常数的语义\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"math\"\u003eMath\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eRational\u003c/code\u003e 总是在创建时被化简, 并在其一生中保持不变\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eInf\u003c/code\u003e、\u003ccode\u003eInf\u003c/code\u003e 和 \u003ccode\u003eNaN\u003c/code\u003e 可以分别用 \u003ccode\u003e\u0026lt;-1/0\u0026gt;\u003c/code\u003e、\u003ccode\u003e\u0026lt;1/0\u0026gt;\u003c/code\u003e 和 \u003ccode\u003e\u0026lt;0/0\u003c/code\u003e\u0026gt; 表示, 通过\u003ccode\u003eRational\u003c/code\u003e 类型进行舍去。零分母 \u003ccode\u003eRational\u003c/code\u003e 被标准化为这三个值之一\u003c/li\u003e\n\u003cli\u003e在 ±\u003ccode\u003eInf\u003c/code\u003e 和 \u003ccode\u003eNaN\u003c/code\u003e 上调用 \u003ccode\u003e.Int\u003c/code\u003e, 会抛出异常\u003c/li\u003e\n\u003cli\u003e改进了 \u003ccode\u003eNum\u003c/code\u003e 运算符和数学函数的 IEEE 754-2008 合规性\u003c/li\u003e\n\u003cli\u003e负零 \u003ccode\u003eNum\u003c/code\u003e(\u003ccode\u003e-0e0\u003c/code\u003e)被所有例程和语法结构正确处理\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNum\u003c/code\u003e 类型的字符串化必须是可舍弃到原始 \u003ccode\u003eNum\u003c/code\u003e 的\u003c/li\u003e\n\u003cli\u003e定义了涉及零的 \u003ccode\u003eComplex \u003c/code\u003e 指数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.expmod\u003c/code\u003e 中的负数幂有效\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"setsbagsmixesaka-quanthashes和集合运算符\"\u003eSets、Bags、Mixes(aka QuantHashes)和集合运算符\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSet 运算符可以用在任何对象上, 在需要的时候会被强转\n\u003cul\u003e\n\u003cli\u003e所以, 不需要也不希望有任何预先的强转\u003c/li\u003e\n\u003cli\u003e如果没有 QuantHash 就能实现所需的功能, 那么 Set 运算符可以自由地不创建任何 QuantHash\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e对不同类型的 QuantHashes 的 Set 操作将强转到最自由的形式（Set -\u0026gt; Bag -\u0026gt; Mix）\u003c/li\u003e\n\u003cli\u003e集合运算符的 set_precedes 家族( \u003ccode\u003e(\u0026lt;+)\u003c/code\u003e、\u003ccode\u003e≼\u003c/code\u003e、\u003ccode\u003e(\u0026gt;+)\u003c/code\u003e、\u003ccode\u003e≽\u003c/code\u003e) 已被移除\n\u003cul\u003e\n\u003cli\u003e曾经是子集运算符的 Baggy 形式\u003c/li\u003e\n\u003cli\u003eQuantHash 升级为最自由的形式, 所以 \u003ccode\u003e(\u0026lt;=)\u003c/code\u003e、\u003ccode\u003e⊆\u003c/code\u003e、\u003ccode\u003e(\u0026gt;=)\u003c/code\u003e、\u003ccode\u003e⊇\u003c/code\u003e 做正确的事情\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.classify-list\u003c/code\u003e 方法可用于 \u003ccode\u003eBaggy\u003c/code\u003e 类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.categorize-list\u003c/code\u003e 方法可用于 \u003ccode\u003eBaggy\u003c/code\u003e 类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.invert\u003c/code\u003e 方法可用于核心 \u003ccode\u003eQuantHash\u003c/code\u003e 类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.antipairs\u003c/code\u003e 方法可用于 \u003ccode\u003eQuantHash\u003c/code\u003e 类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eQuantHash\u003c/code\u003e 类型有 \u003ccode\u003e.new-from-pairs\u003c/code\u003e 和将一个 \u003ccode\u003eQuantHash\u003c/code\u003e 类型转换为另一个 \u003ccode\u003eQuantHash\u003c/code\u003e 类型的方法(例如 \u003ccode\u003eSet\u003c/code\u003e 类型的 \u003ccode\u003e.Bag\u003c/code\u003e 方法)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eQuantHash\u003c/code\u003e 类型上的 \u003ccode\u003e.hash\u003c/code\u003e 对键值进行了字符串化\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"新的形参和实参\"\u003e新的形参和实参\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eDate.new\u003c/code\u003e 接受一个 \u003ccode\u003e:\u0026amp;formatter\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.first\u003c/code\u003e 可以接受 \u003ccode\u003e:kv\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eunique\u003c/code\u003e 和 \u003ccode\u003e.repeated\u003c/code\u003e 可以接受 \u003ccode\u003e:\u0026amp;as\u003c/code\u003e 和 \u003ccode\u003e:\u0026amp;with\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eTest.pm6 中的 \u003ccode\u003e\u0026amp;plan\u003c/code\u003e 可以接受 \u003ccode\u003e:skip-all\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;run\u003c/code\u003e/\u003ccode\u003e\u0026amp;shell\u003c/code\u003e 可以接受 \u003ccode\u003e:merge\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;note\u003c/code\u003e 可以在没有参数的情况下调用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eopen\u003c/code\u003e 接受 \u003ccode\u003e:$out-buffer\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Path.resolve\u003c/code\u003e 可以接受 \u003ccode\u003e:completely\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Path.parent\u003c/code\u003e 可以接受一个 \u003ccode\u003eInt\u003c/code\u003e 表示父级\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eProc::Async.new\u003c/code\u003e 吞噬位置参数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSignature.ACCEPTS\u003c/code\u003e 接受非 \u003ccode\u003eSignature\u003c/code\u003e/\u003ccode\u003eCapture\u003c/code\u003e 参数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;EVAL\u003c/code\u003e 可以接受一个 \u003ccode\u003eBlob\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePromise.keep\u003c/code\u003e/\u003ccode\u003e.break\u003c/code\u003e 可以在没有参数的情况下调用\u003c/li\u003e\n\u003cli\u003e原生数组上的 \u003ccode\u003e.sum\u003c/code\u003e 可以接受 \u003ccode\u003e:wrap\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eis required\u003c/code\u003e 现在可以接受一个表示理由的参数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Socket::Async.listen\u003c/code\u003e 可以绑定到端口 \u003ccode\u003e0\u003c/code\u003e 以向操作系统申请免费端口\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.encode\u003c/code\u003e 可以接受 \u003ccode\u003e:translate-nl\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"新的例程和运算符\"\u003e新的例程和运算符\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e新的 \u003ccode\u003eatomicint\u003c/code\u003e Unicode 运算符和 ASCII 等价物, 保证线程安全, 原子操作:\n\u003ccode\u003e\u0026amp;infix:\u0026lt;⚛=\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-assign\u003c/code\u003e、\u003ccode\u003e\u0026amp;prefix:\u0026lt;⚛\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-fetch\u003c/code\u003e、\n\u003ccode\u003e\u0026amp;prefix:\u0026lt;++⚛\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-inc-fetch\u003c/code\u003e、\u003ccode\u003e\u0026amp;postfix:\u0026lt;⚛++\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-fetch-inc\u003c/code\u003e、\n\u003ccode\u003e\u0026amp;prefix:\u0026lt;--⚛\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-dec-fetch\u003c/code\u003e、\u003ccode\u003e\u0026amp;postfix:\u0026lt;⚛--\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-fetch-dec\u003c/code\u003e、\n\u003ccode\u003e\u0026amp;infix:\u0026lt;⚛-=\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;infix:\u0026lt;⚛−=\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-fetch-sub\u003c/code\u003e 和 \u003ccode\u003e\u0026amp;infix:\u0026lt;⚛+=\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;atomic-fetch-add\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;cas\u003c/code\u003e: 原子比较与交换\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e≤\u003c/code\u003e、\u003ccode\u003e≥\u003c/code\u003e 和 \u003ccode\u003e≠\u003c/code\u003e 运算符是 Unicode 运算符, 分别等价于 \u003ccode\u003e\u0026lt;=\u003c/code\u003e、\u003ccode\u003e\u0026gt;=\u003c/code\u003e 和 \u003ccode\u003e!=\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;infix:\u0026lt;unicmp\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;infix:\u0026lt;coll\u0026gt;\u003c/code\u003e: \u003ccode\u003e\u0026amp;infix:\u0026lt;cmp\u0026gt;\u003c/code\u003e 的替代行为\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTR///\u003c/code\u003e: \u003ccode\u003etr///\u003c/code\u003e 的非变异版本\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esubmethod TWEAK\u003c/code\u003e: 与 \u003ccode\u003eBUILD\u003c/code\u003e 类似, 除了它与属性默认值兼容之外\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;duckmap\u003c/code\u003e: 应用 \u003ccode\u003e\u0026amp;callable\u003c/code\u003e 到每个元素上\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;deepmap\u003c/code\u003e: 应用 \u003ccode\u003e\u0026amp;callable\u003c/code\u003e 到每个元素上, 下降到 \u003ccode\u003eIterable\u003c/code\u003e 中\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;take-rw\u003c/code\u003e: 像 \u003ccode\u003e\u0026amp;take\u003c/code\u003e 一样, 但有一个可写的容器\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;indir\u003c/code\u003e: 在给定的 \u003ccode\u003e$*CWD\u003c/code\u003e 中执行代码\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;spurt\u003c/code\u003e: 参见 \u003ccode\u003eIO::Path.spurt\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;prompt\u003c/code\u003e: 提示用户输入\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003euniprops\u003c/code\u003e: \u003ccode\u003euniprop\u003c/code\u003e 的多字符版本\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esymlink\u003c/code\u003e: 建立文件符号链接\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elink\u003c/code\u003e: 创建文件硬连接\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.hyper\u003c/code\u003e/\u003ccode\u003e.race\u003c/code\u003e: 并行处理值的列表\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSeq.from-loop\u003c/code\u003e: 从 \u003ccode\u003eCallable\u003c/code\u003e 生产一个 \u003ccode\u003eSeq\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eStr.uniparse\u003c/code\u003e: 将一个或多个 Unicode 字符名解析为实际字符\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eStr.parse-base\u003c/code\u003e: \u003ccode\u003eInt.base\u003c/code\u003e 操作的反转\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Path\u003c/code\u003e 提供了 \u003ccode\u003e.ACCEPTS\u003c/code\u003e、\u003ccode\u003e.SPEC\u003c/code\u003e、\u003ccode\u003e.CWD\u003c/code\u003e、\u003ccode\u003e.Numeric\u003c/code\u003e、\u003ccode\u003e.add\u003c/code\u003e、\u003ccode\u003e.extension\u003c/code\u003e、\u003ccode\u003e.mode\u003c/code\u003e 和各种文件测试、\u003ccode\u003e.parts\u003c/code\u003e、\u003ccode\u003e.sibling\u003c/code\u003e 和 \u003ccode\u003e.spurt\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Handle\u003c/code\u003e 提供了 \u003ccode\u003e.READ\u003c/code\u003e、\u003ccode\u003e.WRITE\u003c/code\u003e、\u003ccode\u003e.EOF\u003c/code\u003e、\u003ccode\u003e.DESTROY\u003c/code\u003e,\n\u003ccode\u003e.readchars\u003c/code\u003e、\u003ccode\u003e.flush\u003c/code\u003e、\u003ccode\u003e.lock\u003c/code\u003e、\u003ccode\u003e.unlock\u003c/code\u003e、\u003ccode\u003e.out-buffer\u003c/code\u003e、\u003ccode\u003e.tell\u003c/code\u003e,\n\u003ccode\u003e.say\u003c/code\u003e、\u003ccode\u003e.slurp\u003c/code\u003e、\u003ccode\u003e.seek\u003c/code\u003e、\u003ccode\u003e.printf\u003c/code\u003e、\u003ccode\u003e.print-nl\u003c/code\u003e 和 \u003ccode\u003e.watch\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Pipe\u003c/code\u003e 提供了 \u003ccode\u003e.proc\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIterator\u003c/code\u003e 提供了 \u003ccode\u003e.skip-one\u003c/code\u003e、\u003ccode\u003e.skip-at-least\u003c/code\u003e 和 \u003ccode\u003e.skip-at-least-pull-one\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMu.emit\u003c/code\u003e: \u003ccode\u003e\u0026amp;emit\u003c/code\u003e 的方法形式\u003c/li\u003e\n\u003cli\u003eTest.pm6 模块中的 \u003ccode\u003e\u0026amp;fails-like\u003c/code\u003e: 允许测试失败\u003c/li\u003e\n\u003cli\u003eTest.pm6 模块中的 \u003ccode\u003e\u0026amp;bail-out\u003c/code\u003e: 退出失败的测试套件\u003c/li\u003e\n\u003cli\u003eTest.pm6 模块中的 \u003ccode\u003e\u0026amp;is-approx\u003c/code\u003e: 测试一个数字近似于另一个\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBuf\u003c/code\u003e 拥有 \u003ccode\u003e.allocate\u003c/code\u003e、\u003ccode\u003e.reallocate\u003c/code\u003e、\u003ccode\u003e.append\u003c/code\u003e、\u003ccode\u003e.push\u003c/code\u003e、\u003ccode\u003e.pop\u003c/code\u003e、\u003ccode\u003e.splice\u003c/code\u003e、\u003ccode\u003e.subbuf-rw\u003c/code\u003e、\u003ccode\u003e.prepend\u003c/code\u003e 和 \u003ccode\u003e.unshift\u003c/code\u003e 方法\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRange\u003c/code\u003e 支持了 \u003ccode\u003e.rand\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBacktrace\u003c/code\u003e 拥有方法 \u003ccode\u003e.map\u003c/code\u003e、\u003ccode\u003e.flat\u003c/code\u003e、\u003ccode\u003e.concise\u003c/code\u003e 和 \u003ccode\u003e.summary\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.classify-list\u003c/code\u003e 方法可用于 \u003ccode\u003eHash\u003c/code\u003e 类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.categorize-list\u003c/code\u003e 方法可用于 \u003ccode\u003eHash\u003c/code\u003e 类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCode.of\u003c/code\u003e: 返回返回类型约束\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCode.line\u003c/code\u003e/\u003ccode\u003e.file\u003c/code\u003e: 返回定义的行/文件\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eProc::Async\u003c/code\u003e 提供了 \u003ccode\u003e.Supply\u003c/code\u003e、\u003ccode\u003e.ready\u003c/code\u003e、\u003ccode\u003e.pid\u003c/code\u003e、\u003ccode\u003e.bind-stdin\u003c/code\u003e、\u003ccode\u003e.bind-stdout\u003c/code\u003e 和 \u003ccode\u003e.bind-stderr\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eProc.command\u003c/code\u003e/\u003ccode\u003eProc::Async.command\u003c/code\u003e: 我们要执行的命令\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eProc\u003c/code\u003e 提供了 \u003ccode\u003e.signal\u003c/code\u003e、\u003ccode\u003e.pid\u003c/code\u003e 和 \u003cdel\u003e\u003ccode\u003e.encoding\u003c/code\u003e\u003c/del\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eComplex\u003c/code\u003e 提供了 \u003ccode\u003e.cis\u003c/code\u003e、\u003ccode\u003e.reals\u003c/code\u003e、\u003ccode\u003e.ceiling\u003c/code\u003e、\u003ccode\u003e.floor\u003c/code\u003e、\u003ccode\u003e.round\u003c/code\u003e、\u003ccode\u003e.truncate\u003c/code\u003e 和 \u003ccode\u003e.abs\u003c/code\u003e 方法, 并可以使用 \u003ccode\u003e\u0026lt;=\u0026gt;\u003c/code\u003e 进行比较(只要虚部可以忽略不计)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDateTime\u003c/code\u003e 提供了 \u003ccode\u003e.offset-in-hours\u003c/code\u003e、\u003ccode\u003e.hh-mm-ss\u003c/code\u003e 和 \u003ccode\u003e.Date\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDateTime\u003c/code\u003e 可以使用 \u003ccode\u003e\u0026lt;=\u0026gt;\u003c/code\u003e 运算符和其它 \u003ccode\u003eDateTime\u003c/code\u003e 对象进行比较\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDate\u003c/code\u003e 提供了 \u003ccode\u003e.DateTime\u003c/code\u003e 方法\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;infix:\u0026lt;+\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;infix:\u0026lt;-\u0026gt;\u003c/code\u003e 可以被 \u003ccode\u003eDuration\u003c/code\u003e、\u003ccode\u003eDateTime\u003c/code\u003e 和 \u003ccode\u003eReal\u003c/code\u003e 类型调用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEnumeration\u003c/code\u003e 提供了 \u003ccode\u003e.Int\u003c/code\u003e、\u003ccode\u003e.pred\u003c/code\u003e、\u003ccode\u003e.succ\u003c/code\u003e、\u003ccode\u003e.kv\u003c/code\u003e 和 \u003ccode\u003e.pair\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.Date\u003c/code\u003e 可以在 \u003ccode\u003eInstant\u003c/code\u003e 上调用\u003c/li\u003e\n\u003cli\u003eJunction 能使用 \u003ccode\u003eJunction.new\u003c/code\u003e 调用来创建\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eList\u003c/code\u003e 类型拥有 \u003ccode\u003e.to\u003c/code\u003e 和 \u003ccode\u003e.from\u003c/code\u003e 方法\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMap\u003c/code\u003e type 提供了 \u003ccode\u003eInt\u003c/code\u003e 方法, 返回 pair 的数量\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAny.skip\u003c/code\u003e: 跳过列表中的值\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAny.batch\u003c/code\u003e: \u003ccode\u003e.rotor\u003c/code\u003e 的更基本的表兄弟\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMu.iterator\u003c/code\u003e: 为一个列表中的值生成一个 \u003ccode\u003eIterator\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Spec::*\u003c/code\u003e 类型提供了 \u003ccode\u003e.tmpdir\u003c/code\u003e、\u003ccode\u003e.extension\u003c/code\u003e 和 \u003ccode\u003e.path\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePair\u003c/code\u003e 提供了 \u003ccode\u003e.ACCEPTS\u003c/code\u003e、\u003ccode\u003e.Pair\u003c/code\u003e 和 \u003ccode\u003e.invert\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.Capture\u003c/code\u003e 方法对所有核心类型都有明确定义\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003e.ACCEPTS\u003c/code\u003e 在同素异形体上的语义\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFailure.self\u003c/code\u003e 使未处理的 \u003ccode\u003eFailure\u003c/code\u003e 爆发\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eThread.is-initial-thread\u003c/code\u003e: 我们是在初始线程中运行吗\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMatch\u003c/code\u003e 提供了 \u003ccode\u003e.Int\u003c/code\u003e 和 \u003ccode\u003e.actions\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Socket::Async\u003c/code\u003e 提供了 \u003ccode\u003e.socket-port\u003c/code\u003e 和 \u003ccode\u003e.peer-port\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePromise\u003c/code\u003e 提供了另一种构造函器 \u003ccode\u003e.kept\u003c/code\u003e 和 \u003ccode\u003e.broken\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eWhateverCode\u003c/code\u003e 提供了 \u003ccode\u003e.assuming\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eWhateverCode\u003c/code\u003e 和 \u003ccode\u003eBlock\u003c/code\u003e 提供了 \u003ccode\u003e.cando\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.:\u0026lt;…\u0026gt;\u003c/code\u003e 语法用于调用前缀运算符作为后缀\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$*KERNEL\u003c/code\u003e 提供了 \u003ccode\u003e.hostname\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNil\u003c/code\u003e 拥有定义的 \u003ccode\u003e.FALLBACK\u003c/code\u003e 特殊方法来返回 \u003ccode\u003eNil\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"新类型\"\u003e新类型\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eatomicint\u003c/code\u003e: 原生的 \u003ccode\u003eint\u003c/code\u003e, 大小可用于新的原子运算符\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLock::Async\u003c/code\u003e: 互斥的非阻塞机制\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEncoding::Registry\u003c/code\u003e: 管理可用的编码\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEncoding::Encoder\u003c/code\u003e: 编码器, 用于特定的编码\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEncoding::Decoder\u003c/code\u003e: 解码器, 用于特定的编码\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::CatHandle\u003c/code\u003e: 将多个只读的 \u003ccode\u003eIO::Handle\u003c/code\u003e 视同一个\u003c/li\u003e\n\u003cli\u003e原生的 \u003ccode\u003estr\u003c/code\u003e 数组\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSupplier::Preserving\u003c/code\u003e: 缓存的实时 \u003ccode\u003eSupply\u003c/code\u003e 工厂\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSemaphore\u003c/code\u003e: 控制多线程对共享资源的访问\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Special\u003c/code\u003e: 特殊I/O设备的路径 (例如 \u003ccode\u003eSTDOUT\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eExceptions::JSON\u003c/code\u003e 自定义异常处理程序的实现(可与\u003ccode\u003ePERL6_EXCEPTIONS_HANDLER\u003c/code\u003e 环境变量一起使用)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSeekType\u003c/code\u003e 枚举: \u003ccode\u003eIO::Handle.seek\u003c/code\u003e 中使用的值\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"新的变量\"\u003e新的变量\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e$*USAGE\u003c/code\u003e: 可在 \u003ccode\u003eMAIN\u003c/code\u003e 子例程中使用, 包含自动生成的 \u003ccode\u003eUSAGE\u003c/code\u003e 信息\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e%*SUB-MAIN-OPTS: 设置 \u003ccode\u003esub MAIN\u003c/code\u003e 的行为\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e%*SUB-MAIN-OPTS\u0026lt;named-anywhere\u0026gt;\u003c/code\u003e 允许将命名参数放在命令行的任何位置\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e$*COLLATION\u003c/code\u003e: 配置四个 Unicode 校对级别\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e$*INIT-INSTANT\u003c/code\u003e: 代表程序启动时间的 \u003ccode\u003eInstant\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e$*HOME\u003c/code\u003e: 用户的主目录, 如果存在的话\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026amp;*chdir\u003c/code\u003e: \u003ccode\u003eCallable\u003c/code\u003e 包含 \u003ccode\u003eIO::Path.chdir\u003c/code\u003e 的变体, 也设置进程的当前目录\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ePERL6_TEST_DIE_ON_FAIL\u003c/code\u003e 环境变量: 在第一次失败时停止测试套件\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ePERL6_EXCEPTIONS_HANDLER\u003c/code\u003e 环境变量: 指定自定义异常处理类\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"对边缘情况强转行为的澄清\"\u003e对边缘情况/强转行为的澄清\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eUInt\u003c/code\u003e 与 \u003ccode\u003eInt\u003c/code\u003e 类型对象智能匹配为 \u003ccode\u003eTrue\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esink\u003c/code\u003e 语句前缀爆炸 \u003ccode\u003eFailure\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e定义了1项和0项列表以及负参数和非整数参数的 \u003ccode\u003epermutations\u003c/code\u003e/\u003ccode\u003ecombinations\u003c/code\u003e 的行为\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;val\u003c/code\u003e、\u003ccode\u003eStr.Numeric\u003c/code\u003e 和其他 \u003ccode\u003eStr\u003c/code\u003e 数字转换方法在试图转换 Unicode \u003ccode\u003eNo\u003c/code\u003e 字符组或合成数字时会 \u003ccode\u003efail\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e:42foo\u003c/code\u003e 冒号对快捷方式中不能使用合成数字\u003c/li\u003e\n\u003cli\u003e现在、\u003ccode\u003eEnumeration\u003c/code\u003e 可以作为一个数组形状指定器使用\u003c/li\u003e\n\u003cli\u003e含有空格的 \u003ccode\u003eStr\u003c/code\u003e 的数值转换现在返回 \u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e带空的模式参数的 \u003ccode\u003esamark\u003c/code\u003e, 简单地返回调用者\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.polymod\u003c/code\u003e 可用于 \u003ccode\u003elazy\u003c/code\u003e 但有限的除数列表\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003e.[*-0]\u003c/code\u003e 索引\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.rotor\u003c/code\u003e 中大于子列表的负数空隙抛出异常\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.rotor\u003c/code\u003e 的非 \u003ccode\u003eInt\u003c/code\u003e 参数被强转为 \u003ccode\u003eInt\u003c/code\u003e 参数\u003c/li\u003e\n\u003cli\u003e读取 \u003ccode\u003e/proc\u003c/code\u003e 文件时定义了 \u003ccode\u003e.lines\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e定义了字符串上后缀/前缀  \u003ccode\u003e++\u003c/code\u003e/\u003ccode\u003e--\u003c/code\u003e 中泰语数字的行为\u003c/li\u003e\n\u003cli\u003esunk \u003ccode\u003efor\u003c/code\u003e 里面的 \u003ccode\u003emap\u003c/code\u003e 被视为 sunk\u003c/li\u003e\n\u003cli\u003eSunk \u003ccode\u003efor\u003c/code\u003e 循环将上一条语句的方法调用值下沉\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBool\u003c/code\u003e 对象上的 \u003ccode\u003e.Int\u003c/code\u003e 返回一个 \u003ccode\u003eInt\u003c/code\u003e 对象\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esplice\u003c/code\u003e 可用于扩展数组\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eclassify\u003c/code\u003e 可以与 \u003ccode\u003eJunction\u003c/code\u003e 配合使用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.pairup\u003c/code\u003e on a type object returns an empty \u003ccode\u003eSeq\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.pairup\u003c/code\u003e 总是返回一个 \u003ccode\u003eSeq\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e拒绝接受  \u003ccode\u003eDate\u003c/code\u003e/\u003ccode\u003eDateTime\u003c/code\u003e 构造函数中的合成代码点\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e⸨\u003c/code\u003e/\u003ccode\u003e⸩\u003c/code\u003e 对儿现在可以作为引号结构中的匹配字符使用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eArray\u003c/code\u003e 类型对象上的 \u003ccode\u003e.flat\u003c/code\u003e 简单地返回该类型对象\u003c/li\u003e\n\u003cli\u003e混合级 \u003ccode\u003eclassify\u003c/code\u003e 在 \u003ccode\u003eHash\u003c/code\u003e 上抛出异常\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eJunction\u003c/code\u003e 可以用于给 \u003ccode\u003eHash\u003c/code\u003e 指定多个键\u003c/li\u003e\n\u003cli\u003e给 \u003ccode\u003e.classify-list\u003c/code\u003e 的 \u003ccode\u003eCallable\u003c/code\u003e 现在保证每项只执行一次\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e:delete\u003c/code\u003e 对 \u003ccode\u003eHash\u003c/code\u003e 类型对象进行关联查找时返回 \u003ccode\u003eNil\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eTest.pm6 中的 \u003ccode\u003e\u0026amp;is-deeply\u003c/code\u003e 会自动 \u003ccode\u003e.cache\u003c/code\u003e 作为参数的 \u003ccode\u003eSeq\u003c/code\u003e, 并使用返回的 \u003ccode\u003eList\u003c/code\u003e 进行测试\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eComplex.new()\u003c/code\u003e 给出 \u003ccode\u003e\u0026lt;0+0i\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eInt.new\u003c/code\u003e 现在可以保证构建一个新的 \u003ccode\u003eInt\u003c/code\u003e (而不是, 比如说, 从常量缓存中重用一个)\u003c/li\u003e\n\u003cli\u003e定义了一个参数(1-arg)版本的 \u003ccode\u003e\u0026amp;infix:\u0026lt;=:=\u0026gt;\u003c/code\u003e 和 \u003ccode\u003e\u0026amp;infix:\u0026lt;eqv\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e如果直接或间接地调用 \u003ccode\u003e.BIND-POS\u003c/code\u003e、\u003ccode\u003e.BIND-KEY\u003c/code\u003e、\u003ccode\u003e.ASSIGN-POS\u003c/code\u003e、\u003ccode\u003e.ASSIGN-KEY\u003c/code\u003e、\u003ccode\u003e.STORE\u003c/code\u003e、\u003ccode\u003e.push\u003c/code\u003e、\u003ccode\u003e.append\u003c/code\u003e、\u003ccode\u003e.unshift\u003c/code\u003e、\u003ccode\u003e.prepend\u003c/code\u003e、\u003ccode\u003eNil\u003c/code\u003e 类型现在抛出异常\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNil.ord\u003c/code\u003e 返回一个空的 \u003ccode\u003eSeq\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNil.chrs\u003c/code\u003e 返回一个 \u003ccode\u003e\u0026quot;\\0\u0026quot;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNum.new\u003c/code\u003e 强转参数为 \u003ccode\u003eNum\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einfix:\u0026lt;Z\u0026gt;()\u003c/code\u003e 返回一个空的 \u003ccode\u003eSeq\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.comb\u003c/code\u003e 总是返回一个 \u003ccode\u003eSeq\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e用 \u003ccode\u003e\u0026amp;infix:\u0026lt;+\u0026gt;\u003c/code\u003e 化简一个项, 简单地返回该项\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e()[0]\u003c/code\u003e 返回 \u003ccode\u003eNil\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e允许在(可能是无限的) \u003ccode\u003eSeq\u003c/code\u003e 上使用 Regex 智能匹配\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003eRange\u003c/code\u003e 对象的智能匹配\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSet\u003c/code\u003e 转换为\u003ccode\u003eMix\u003c/code\u003e/\u003ccode\u003eBag\u003c/code\u003e 不再有 \u003ccode\u003eBool\u003c/code\u003e 权重\u003c/li\u003e\n\u003cli\u003e当一个或多个操作数为 \u003ccode\u003e0\u003c/code\u003e 时、\u003ccode\u003egcd\u003c/code\u003e 是有定义的\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edefined\u003c/code\u003e 例程中的 \u003ccode\u003eJunction\u003c/code\u003e 自动线程化\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esum\u003c/code\u003e 可以处理含有 \u003ccode\u003eJunction\u003c/code\u003e 的列表\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGrammar.parse\u003c/code\u003e 让顶级 \u003ccode\u003eregex\u003c/code\u003e 回溯\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eU+2212 MINUS SIGN [Sm] (-)\u003c/code\u003e 现在得到更多结构的支持, 如 \u003ccode\u003eStr.Numeric\u003c/code\u003e 和 \u003ccode\u003e\u0026amp;val\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eArity-1 \u003ccode\u003e\u0026amp;infix:\u0026lt;~\u0026gt;\u003c/code\u003e 与 \u003ccode\u003eBlob\u003c/code\u003e 可以一起工作\u003c/li\u003e\n\u003cli\u003e在签名中, 所有的 \u003ccode\u003eNumeric\u003c/code\u003e 字面值都支持作为值字面值\u003c/li\u003e\n\u003cli\u003e正则表达式中的 \u003ccode\u003e\\b\u003c/code\u003e 和 \u003ccode\u003e\\B\u003c/code\u003e 抛出 \u003ccode\u003eX::Obsolete\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTrue\u003c/code\u003e 和 \u003ccode\u003eFalse\u003c/code\u003e 作为签名中的值字面量发出警告\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.sort\u003c/code\u003e 和 \u003ccode\u003eIO::Spec::Unix.path\u003c/code\u003e 的返回值总是 \u003ccode\u003eSeq\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRange\u003c/code\u003e 对象上的 Out-of-range \u003ccode\u003e.AT-POS\u003c/code\u003e 返回 \u003ccode\u003eNil\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e对于不存在的键、\u003ccode\u003ePair.AT-KEY\u003c/code\u003e 返回 \u003ccode\u003eNil\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e所有的 \u003ccode\u003eCool\u003c/code\u003e 类型都提供了 \u003ccode\u003e.Rat\u003c/code\u003e/\u003ccode\u003e.FatRat\u003c/code\u003e 强转器\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Path\u003c/code\u003e 文件测试不缓存先前测试执行的结果\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSeq\u003c/code\u003e eqv \u003ccode\u003eList\u003c/code\u003e 仅根据类型不匹配就定为 \u003ccode\u003eFalse\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cdel\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e 在 \u003ccode\u003eHash \u003c/code\u003e、\u003ccode\u003eHash \u003c/code\u003e 和 \u003ccode\u003eQuantHash\u003c/code\u003e 上, 来自 \u003ccode\u003e.kv\u003c/code\u003e、\u003ccode\u003e.values\u003c/code\u003e 和 \u003ccode\u003e.pair\u003c/code\u003e 序列的值是可写的\u003c/del\u003e 参见 \u003ca href=\"https://github.com/Raku/roast/issues/614\"\u003eRaku/roast#614\u003c/a\u003e 和 \u003ca href=\"https://github.com/Raku/doc/issues/3519\"\u003e#3519\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;infix:\u0026lt;∘\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;infix:\u0026lt;o\u0026gt;\u003c/code\u003e 保留 LHF 的 \u003ccode\u003e.of\u003c/code\u003e 和 RHS 的 \u003ccode\u003e.arity\u003c/code\u003e 和 \u003ccode\u003e.count\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e完善了 regex 运算符副词中的可接受参数(例如:\u003ccode\u003e:in(…)\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e完善了 \u003ccode\u003eIO::Handle.open\u003c/code\u003e 中可接受的参数组合\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Path.Str\u003c/code\u003e 不包含 \u003ccode\u003e.CWD\u003c/code\u003e 属性的值\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Path\u003c/code\u003e 类型拒绝带有  \u003ccode\u003enul\u003c/code\u003e 字节 (\u003ccode\u003e\u0026quot;\\0\u0026quot;\u003c/code\u003e) 的路径\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Pipe\u003c/code\u003e 的 \u003ccode\u003e.path\u003c/code\u003e/\u003ccode\u003e.IO\u003c/code\u003e 返回一个 \u003ccode\u003eIO::Path\u003c/code\u003e 类型对象\u003c/li\u003e\n\u003cli\u003e如果目的路径和源路径是一样的 \u003ccode\u003eIO::Path\u003c/code\u003e 的 \u003ccode\u003e.copy\u003c/code\u003e/\u003ccode\u003e.move\u003c/code\u003e 会 \u003ccode\u003efail\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edir\u003c/code\u003e 创建的 \u003ccode\u003eIO::Path\u003c/code\u003e 绝对性由调用者控制\u003c/li\u003e\n\u003cli\u003e更多定义的边缘行为、\u003ccode\u003eCallable \u003c/code\u003e 处理、\u003ccode\u003e. defined\u003c/code\u003e 调用, 以及 \u003ccode\u003e\u0026amp;infix:\u0026lt;andthen\u0026gt;\u003c/code\u003e、\u003ccode\u003e\u0026amp;infix:\u0026lt;orelse\u0026gt;\u003c/code\u003e 和 \u003ccode\u003e\u0026amp;infix:\u0026lt;notandthen\u0026gt;\u003c/code\u003e 操作符的链接\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSeq\u003c/code\u003e 的禅切不缓存它们\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eList.Capture\u003c/code\u003e 将任何包含的 \u003ccode\u003ePair\u003c/code\u003e 对象的键字符串化\u003c/li\u003e\n\u003cli\u003e带处理的 \u003ccode\u003eFailure\u003c/code\u003e 参数的 \u003ccode\u003e\u0026amp;fail\u003c/code\u003e 把它标记为是未处理的\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003euse lib\u003c/code\u003e 接受 \u003ccode\u003eIO::Path\u003c/code\u003e 对象\u003c/li\u003e\n\u003cli\u003e锚点 \u003ccode\u003e^\u003c/code\u003e、\u003ccode\u003e^^\u003c/code\u003e、\u003ccode\u003e$\u003c/code\u003e 和 \u003ccode\u003e$$\u003c/code\u003e 在环视中有效\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGrammar.made\u003c/code\u003e 支持类型对象\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.isa\u003c/code\u003e 支持 \u003ccode\u003esubset \u003c/code\u003e 类型对象\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e:delete\u003c/code\u003e 可用于惰性数组\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;infix:\u0026lt;eqv\u0026gt;\u003c/code\u003e 可以在某些情况下对惰性参数起作用\u003c/li\u003e\n\u003cli\u003e动态查询(\u003ccode\u003e::(...)\u003c/code\u003e) 是限制性的 regex 语法, 并且需要 \u003ccode\u003euse MONKEY-SEE-NO-EVAL\u003c/code\u003e 的许可\u003c/li\u003e\n\u003cli\u003e定义了带孔数组的 \u003ccode\u003e.Slip\u003c/code\u003e 和 \u003ccode\u003e.List\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePromise.in\u003c/code\u003e/\u003ccode\u003e.at\u003c/code\u003e 和 \u003ccode\u003eSupply.interval\u003c/code\u003e 可以用零值和负值工作\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSupply.interval\u003c/code\u003e 最小值为 \u003ccode\u003e0.001\u003c/code\u003e；较低值被处理为 \u003ccode\u003e0.001\u003c/code\u003e, 并发出警告#, 参见 \u003ca href=\"https://github.com/Raku/doc/pull/2649\"\u003ehttps://docs.perl6.org/type/Supply#method_interval PR [#2649]\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSupply\u003c/code\u003e 提供了 \u003ccode\u003e.Seq\u003c/code\u003e、\u003ccode\u003e.list\u003c/code\u003e 和 \u003ccode\u003e.zip\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e可以在构建方法中绑定到原生类型属性\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eWhateverCode\u003c/code\u003e 传播 \u003ccode\u003euse fatal\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esay\u003c/code\u003e、\u003ccode\u003enote\u003c/code\u003e、\u003ccode\u003eput\u003c/code\u003e、\u003ccode\u003eprint\u003c/code\u003e 和 \u003ccode\u003eprintf\u003c/code\u003e 例程自动线程化 \u003ccode\u003eJunction\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIO::Handle.eof\u003c/code\u003e 值在 \u003ccode\u003e.seek\u003c/code\u003e 过终点后再返回时也会相应改变\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003e.succ'、\u003c/code\u003e.pred\u003ccode\u003e和\u003c/code\u003e.Bool` 的同质异形体\u003c/li\u003e\n\u003cli\u003e在核心 \u003ccode\u003eNumeric\u003c/code\u003e 上定义了 \u003ccode\u003e.Bridge\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cdel\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e 在核心 \u003ccode\u003eNumeric\u003c/code\u003e 的类型对象上定义了 \u003ccode\u003e.Numeric\u003c/code\u003e/\u003ccode\u003e.Real\u003c/code\u003e\u003c/del\u003e\u003c/li\u003e\n\u003cli\u003e定义了关于零分母有理数的 \u003ccode\u003eRational.Bool\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esay\u003c/code\u003e/\u003ccode\u003enote\u003c/code\u003e 保证在 \u003ccode\u003eStr\u003c/code\u003e 的子类上调用 \u003ccode\u003e.gist\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003eJunction.Str\u003c/code\u003e 返回 \u003ccode\u003eJunction\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003eJunction.gist\u003c/code\u003e/\u003ccode\u003e.perl\u003c/code\u003e 返回一个 \u003ccode\u003eStr\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMap\u003c/code\u003e/\u003ccode\u003eHash\u003c/code\u003e 的 \u003ccode\u003e.list\u003c/code\u003e/\u003ccode\u003e.cache\u003c/code\u003e 返回一个 \u003ccode\u003eList\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003e.round\u003c/code\u003e 的返回类型\u003c/li\u003e\n\u003cli\u003e定义了 \u003ccode\u003eEnumeration:D\u003c/code\u003e  不  \u003ccode\u003e.ACCEPT\u003c/code\u003e 一个 \u003ccode\u003eEnumeration:U\u003c/code\u003e , 参见 \u003ca href=\"https://github.com/rakudo/rakudo/issues/2073\"\u003erakudo/rakudo#2073\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"杂项\"\u003e杂项\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eIO::ArgFiles\u003c/code\u003e 类型只是 \u003ccode\u003eIO::CatHandle\u003c/code\u003e 的一个空的子类\u003c/li\u003e\n\u003cli\u003e对常量的约束\n\u003cul\u003e\n\u003cli\u003e约束是完全强制的\u003c/li\u003e\n\u003cli\u003e试图在常量上使用参数化类型约束(例如使用 \u003ccode\u003emy Foo constant @int\u003c/code\u003e) 会引发 \u003ccode\u003eX::ParametricConstant\u003c/code\u003e 异常\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePod\u003c/code\u003e \u003ccode\u003e=defn\u003c/code\u003e(定义列表)指令可用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePod\u003c/code\u003e 提供了 \u003ccode\u003e:numbered\u003c/code\u003e 配置键\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.^ver\u003c/code\u003e、\u003ccode\u003e.^auth\u003c/code\u003e 和 \u003ccode\u003e.^name\u003c/code\u003e 元方法在 \u003ccode\u003emodule\u003c/code\u003e 中可用, 而在 \u003ccode\u003epackage\u003c/code\u003e 中则没有, 这是设计上的原因\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eqww\u0026lt;…\u0026gt;\u003c/code\u003e 中支持花哨的引号(\u003ccode\u003e’…’\u003c/code\u003e、\u003ccode\u003e“…”\u003c/code\u003e、\u003ccode\u003e｢…｣\u003c/code\u003e 和变体)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;infix:\u0026lt; \u0026gt;\u003c/code\u003e 支持查找自动生成的 \u003ccode\u003eCallables\u003c/code\u003e (例如: \u003ccode\u003e\u0026amp;infix:\u0026lt;XX\u0026gt;\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e使用命名的 \u003ccode\u003eanon\u003c/code\u003e 子例程不再产生重声明警告\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e::?MODULE\u003c/code\u003e/\u003ccode\u003e$?MODULE\u003c/code\u003e 变量的扩展规范\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esub MAIN\u003c/code\u003e 可以接受一个参数上的 \u003ccode\u003eEnumeration\u003c/code\u003e 类型约束和 \u003ccode\u003ewhere\u003c/code\u003e 子句\u003c/li\u003e\n\u003cli\u003e笑脸型约束可以用在子集上\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estart\u003c/code\u003e 块和 thunks 得到新的 \u003ccode\u003e$/\u003c/code\u003e 和 \u003ccode\u003e$!\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e定义了与列表关联运算符一起使用的 \u003ccode\u003eR\u003c/code\u003e 元运算符\u003c/li\u003e\n\u003cli\u003e类型强转可以用在签名返回类型约束中\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026amp;infix:\u0026lt;x\u0026gt;\u003c/code\u003e/\u003ccode\u003e\u0026amp;infix:\u0026lt;x\u0026gt;\u003c/code\u003e 抛出了 \u003ccode\u003e-Inf\u003c/code\u003e/\u003ccode\u003eNaN\u003c/code\u003e 重复参数\u003c/li\u003e\n\u003cli\u003e字面结构 \u003ccode\u003eput\u003c/code\u003e 和 \u003ccode\u003eput for\u003c/code\u003e 抛出, 需要使用括号\u003c/li\u003e\n\u003cli\u003e扩大了 Unicode 例程和功能的规范覆盖面-将覆盖面升级到 Unicode 第11版\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$.\u003c/code\u003e 方法调用语法能用在元方法中了\u003c/li\u003e\n\u003c/ul\u003e\n","text":"问题 在 6.d 版本中, 很多东西都发生了变化, 我们至少需要发布一个版本。这里有个列表。然而, 覆盖面是不完整的。弃用通知采取了不同的形式, 一些新的类型和方法在那里, 一些则没有\u0026hellip;\u0026hellip;\n用 #2632 引用这个问题, 并检查项目, 当你的工作, 无论是通过改变后的文档, 看到没有变化, 需要做它。在这种情况下, 请通过评论或如何解释为什么是这种情况。\n版本控制的变更  [6.d] \u0026amp;await 在等待的时候不再阻塞线程 [6.d] whenever 不在 react 抛出的词法作用域内 [6.d] 在 sub MAIN 里面的 $*ARGFILES 总是由 $*IN 馈入 [6.d] 结构(字面上的) $()、@() 和 %() 不复存在 [6.d] 带有 :D/:U 类型约束的变量默认为约束类型的类型对象(例如, 你可以在它们身上使用 .new) [6.d] start 块在 sink 上下文中附加异常处理程序 [6.d] 例程必须使用 return-rw 来返回一个 Proxy, 即使例程被标记为 is raw 或 is rw [6.d] 原生的 num 类型默认为 0e0 而不是 NaN [6.d] 在子程序名中, 保留了键名为 sym 的冒号对（如:sym\u0026lt;foo\u0026gt;）, 以备将来使用  废弃 这些方法在 6.d 语言中已被废弃, 并将在 6.e 中被删除。实现者可以选择发出弃用警告, 或者在 6.e 版本发布后更长的时间内提供这些方法。\n 使用 '-' (单连字符)作为 \u0026amp;open 的特殊路径, 表示特殊的句柄(使用 IO::Special 对象代替) IO::Handle.slurp-rest (使用 .slurp 代替) Any.flatmap (使用.flat 和 .map 方法的组合来代替) Cool.path (使用 .IO 代替) Pair.freeze (使用去容器化的参数的 Pair.new 来代替) Str.subst-mutate (使用带有 .= 方法调用赋值元运算符的 Str.subst 代替) Rational.norm (现在 Rational 类型必须在创建时标准化) IO::Path.child (使用 .add 代替) \u0026amp;undefine (直接分配 Empty/Nil 代替) :count \u0026amp;lines/Str.lines 例程上的参数(使用所返回的 Seq 上的 .elems 代替) \u0026amp;is_approx in Test.pm6 (使用与 \u0026amp;is-approx 非常相似的行为来代替)  新的行为  通过新的可定义的 \u0026amp;RUN-MAIN、\u0026amp;ARGS-TO-CAPTURE 和 \u0026amp;GENERATE-USAGE 子例程改善 sub MAIN 的自定义处理 % 变量中的 QuantHash/Map 和 @ 变量中的 List 可以用 is 特性来声明（例如，my %h is Set） 新的 \u0026lt;ww\u0026gt; regex 规则: 只在单词内匹配 循环可以从上一条语句的值中产生一个值的列表 循环中的 next/last 收集其最后的语句值, 对它们运行的迭代返回 Empty .perl 可以在消耗过的 Seq、多维数组、Date 和 CallFrame 上调用 .gist 可以在 Attribute 上调用 对自动生成的 USAGE 信息进行了大量改进 is hidden-from-USAGE 特性，从自动生成的 USAGE 消息中隐藏 sub MAIN 候选者 Parameter.perl 包括可内省的默认值 %*ENV 值是同素异形的 尝试使用变量 $;、$,、$.、$\\、$(、$)、$\u0026lt;、$\u0026gt;、$/、$\\、$[、$-、$+ 和 $@ 会抛出 X::Syntax::Perl5Var 默认的 Hash.keyof 返回一个 Str(Any) 强转类型对象 非 ASCII 数字可以在 :42foo 冒号对快捷方式中使用 StrDistance 字符串化为 .after 字符串 更明确的 Pod 表格格式 Enumeration.enums 返回一个 Map 各种整数类型的 .Range 返回它们支持的值的范围 min/max 例程也适用于 Hash Signature 字面值可以包含字符串/数字字面值以及调用者标记 List.invert 通过所需的 Pair 绑定映射, 导致潜在的类型检查失败 :exists 可以与多维关联下标一起使用 动态创建的列表可以用来定义一个枚举 在 .first 中, Junction 可以作为匹配器使用 原生属性可以作为参数中的绑定目标 Proc 可以与其他 Proc 中的 IO::Pipe 一起工作 类型数组可以用 my SomeType @array 和 my @array of SomeType 创建 当把 Mixy 强转为 Setty/Baggy  时, 负数权重的项将被删除 :nth 副词在 m// 上接受一个 Junction 作为参数 CX::Warn' 和 CX::Done可以在CONTROL` phaser 中捕获 next 可用于 whenever 中 require 符号不再过境性地暴露出来 通过 {...} 进行多维访问, 类似于 [...] 的工作方式 在 END 时间打开的任何手柄都会自动关闭 在缓存的 Seq 上, 当 \u0026amp;infix:\u0026lt;eqv\u0026gt;、.Slip、.join、.List、.list、.eager、.Array 和 .is-lazy 被调用时, 就会使用缓存列表 IO::Handle.encoding 以 Nil 表示切换到二进制模式 is default 特质与属性一起工作 在多重分派中, 带有 is rw 特性的参数被认为比没有特性的参数窄 Array、Blob 和 Map 的 .gist 被裁剪成100个元素 新的 for 语句修饰符 hyper for、race for 和 lazy for for 循环自动序列化 RaceSeq/HyperSeq；使用新的 for 语句修饰符hyper for/race for避免 \u0026amp;infix:\u0026lt;does\u0026gt; 可用于 RHS 上的非组合实例 数值比较器可以与 DateTime  对象一起使用 Pod 保留空白类型 定义了带 @、% 和 \u0026amp; 魔符常数的语义  Math  Rational 总是在创建时被化简, 并在其一生中保持不变 Inf、Inf 和 NaN 可以分别用 \u0026lt;-1/0\u0026gt;、\u0026lt;1/0\u0026gt; 和 \u0026lt;0/0\u0026gt; 表示, 通过Rational 类型进行舍去。零分母 Rational 被标准化为这三个值之一 在 ±Inf 和 NaN 上调用 .Int, 会抛出异常 改进了 Num 运算符和数学函数的 IEEE 754-2008 合规性 负零 Num(-0e0)被所有例程和语法结构正确处理 Num 类型的字符串化必须是可舍弃到原始 Num 的 定义了涉及零的 Complex  指数 .expmod 中的负数幂有效  Sets、Bags、Mixes(aka QuantHashes)和集合运算符  Set 运算符可以用在任何对象上, 在需要的时候会被强转  所以, 不需要也不希望有任何预先的强转 如果没有 QuantHash 就能实现所需的功能, 那么 Set 运算符可以自由地不创建任何 QuantHash   对不同类型的 QuantHashes 的 Set 操作将强转到最自由的形式（Set -\u0026gt; Bag -\u0026gt; Mix） 集合运算符的 set_precedes 家族( (\u0026lt;+)、≼、(\u0026gt;+)、≽) 已被移除  曾经是子集运算符的 Baggy 形式 QuantHash 升级为最自由的形式, 所以 (\u0026lt;=)、⊆、(\u0026gt;=)、⊇ 做正确的事情   .classify-list 方法可用于 Baggy 类型 .categorize-list 方法可用于 Baggy 类型 .invert 方法可用于核心 QuantHash 类型 .antipairs 方法可用于 QuantHash 类型 QuantHash 类型有 .new-from-pairs 和将一个 QuantHash 类型转换为另一个 QuantHash 类型的方法(例如 Set 类型的 .Bag 方法) QuantHash 类型上的 .hash 对键值进行了字符串化  新的形参和实参  Date.new 接受一个 :\u0026amp;formatter .first 可以接受 :kv unique 和 .repeated 可以接受 :\u0026amp;as 和 :\u0026amp;with Test.pm6 中的 \u0026amp;plan 可以接受 :skip-all \u0026amp;run/\u0026amp;shell 可以接受 :merge \u0026amp;note 可以在没有参数的情况下调用 open 接受 :$out-buffer IO::Path.resolve 可以接受 :completely IO::Path.parent 可以接受一个 Int 表示父级 Proc::Async.new 吞噬位置参数 Signature.ACCEPTS 接受非 Signature/Capture 参数 \u0026amp;EVAL 可以接受一个 Blob Promise.keep/.break 可以在没有参数的情况下调用 原生数组上的 .sum 可以接受 :wrap is required 现在可以接受一个表示理由的参数 IO::Socket::Async.listen 可以绑定到端口 0 以向操作系统申请免费端口 .encode 可以接受 :translate-nl  新的例程和运算符  新的 atomicint Unicode 运算符和 ASCII 等价物, 保证线程安全, 原子操作: \u0026amp;infix:\u0026lt;⚛=\u0026gt;/\u0026amp;atomic-assign、\u0026amp;prefix:\u0026lt;⚛\u0026gt;/\u0026amp;atomic-fetch、 \u0026amp;prefix:\u0026lt;++⚛\u0026gt;/\u0026amp;atomic-inc-fetch、\u0026amp;postfix:\u0026lt;⚛++\u0026gt;/\u0026amp;atomic-fetch-inc、 \u0026amp;prefix:\u0026lt;--⚛\u0026gt;/\u0026amp;atomic-dec-fetch、\u0026amp;postfix:\u0026lt;⚛--\u0026gt;/\u0026amp;atomic-fetch-dec、 \u0026amp;infix:\u0026lt;⚛-=\u0026gt;/\u0026amp;infix:\u0026lt;⚛−=\u0026gt;/\u0026amp;atomic-fetch-sub 和 \u0026amp;infix:\u0026lt;⚛+=\u0026gt;/\u0026amp;atomic-fetch-add \u0026amp;cas: 原子比较与交换 ≤、≥ 和 ≠ 运算符是 Unicode 运算符, 分别等价于 \u0026lt;=、\u0026gt;= 和 != \u0026amp;infix:\u0026lt;unicmp\u0026gt;/\u0026amp;infix:\u0026lt;coll\u0026gt;: \u0026amp;infix:\u0026lt;cmp\u0026gt; 的替代行为 TR///: tr/// 的非变异版本 submethod TWEAK: 与 BUILD 类似, 除了它与属性默认值兼容之外 \u0026amp;duckmap: 应用 \u0026amp;callable 到每个元素上 \u0026amp;deepmap: 应用 \u0026amp;callable 到每个元素上, 下降到 Iterable 中 \u0026amp;take-rw: 像 \u0026amp;take 一样, 但有一个可写的容器 \u0026amp;indir: 在给定的 $*CWD 中执行代码 \u0026amp;spurt: 参见 IO::Path.spurt \u0026amp;prompt: 提示用户输入 uniprops: uniprop 的多字符版本 symlink: 建立文件符号链接 link: 创建文件硬连接 .hyper/.race: 并行处理值的列表 Seq.from-loop: 从 Callable 生产一个 Seq Str.uniparse: 将一个或多个 Unicode 字符名解析为实际字符 Str.parse-base: Int.base 操作的反转 IO::Path 提供了 .ACCEPTS、.SPEC、.CWD、.Numeric、.add、.extension、.mode 和各种文件测试、.parts、.sibling 和 .spurt IO::Handle 提供了 .READ、.WRITE、.EOF、.DESTROY, .readchars、.flush、.lock、.unlock、.out-buffer、.tell, .say、.slurp、.seek、.printf、.print-nl 和 .watch IO::Pipe 提供了 .proc Iterator 提供了 .skip-one、.skip-at-least 和 .skip-at-least-pull-one Mu.emit: \u0026amp;emit 的方法形式 Test.pm6 模块中的 \u0026amp;fails-like: 允许测试失败 Test.pm6 模块中的 \u0026amp;bail-out: 退出失败的测试套件 Test.pm6 模块中的 \u0026amp;is-approx: 测试一个数字近似于另一个 Buf 拥有 .allocate、.reallocate、.append、.push、.pop、.splice、.subbuf-rw、.prepend 和 .unshift 方法 Range 支持了 .rand Backtrace 拥有方法 .map、.flat、.concise 和 .summary .classify-list 方法可用于 Hash 类型 .categorize-list 方法可用于 Hash 类型 Code.of: 返回返回类型约束 Code.line/.file: 返回定义的行/文件 Proc::Async 提供了 .Supply、.ready、.pid、.bind-stdin、.bind-stdout 和 .bind-stderr Proc.command/Proc::Async.command: 我们要执行的命令 Proc 提供了 .signal、.pid 和 .encoding Complex 提供了 .cis、.reals、.ceiling、.floor、.round、.truncate 和 .abs 方法, 并可以使用 \u0026lt;=\u0026gt; 进行比较(只要虚部可以忽略不计) DateTime 提供了 .offset-in-hours、.hh-mm-ss 和 .Date DateTime 可以使用 \u0026lt;=\u0026gt; 运算符和其它 DateTime 对象进行比较 Date 提供了 .DateTime 方法 \u0026amp;infix:\u0026lt;+\u0026gt;/\u0026amp;infix:\u0026lt;-\u0026gt; 可以被 Duration、DateTime 和 Real 类型调用 Enumeration 提供了 .Int、.pred、.succ、.kv 和 .pair .Date 可以在 Instant 上调用 Junction 能使用 Junction.new 调用来创建 List 类型拥有 .to 和 .from 方法 Map type 提供了 Int 方法, 返回 pair 的数量 Any.skip: 跳过列表中的值 Any.batch: .rotor 的更基本的表兄弟 Mu.iterator: 为一个列表中的值生成一个 Iterator IO::Spec::* 类型提供了 .tmpdir、.extension 和 .path Pair 提供了 .ACCEPTS、.Pair 和 .invert .Capture 方法对所有核心类型都有明确定义 定义了 .ACCEPTS 在同素异形体上的语义 Failure.self 使未处理的 Failure 爆发 Thread.is-initial-thread: 我们是在初始线程中运行吗 Match 提供了 .Int 和 .actions IO::Socket::Async 提供了 .socket-port 和 .peer-port Promise 提供了另一种构造函器 .kept 和 .broken WhateverCode 提供了 .assuming WhateverCode 和 Block 提供了 .cando .:\u0026lt;…\u0026gt; 语法用于调用前缀运算符作为后缀 $*KERNEL 提供了 .hostname Nil 拥有定义的 .FALLBACK 特殊方法来返回 Nil  新类型  atomicint: 原生的 int, 大小可用于新的原子运算符 Lock::Async: 互斥的非阻塞机制 Encoding::Registry: 管理可用的编码 Encoding::Encoder: 编码器, 用于特定的编码 Encoding::Decoder: 解码器, 用于特定的编码 IO::CatHandle: 将多个只读的 IO::Handle 视同一个 原生的 str 数组 Supplier::Preserving: 缓存的实时 Supply 工厂 Semaphore: 控制多线程对共享资源的访问 IO::Special: 特殊I/O设备的路径 (例如 STDOUT) Exceptions::JSON 自定义异常处理程序的实现(可与PERL6_EXCEPTIONS_HANDLER 环境变量一起使用) SeekType 枚举: IO::Handle.seek 中使用的值  新的变量   $*USAGE: 可在 MAIN 子例程中使用, 包含自动生成的 USAGE 信息\n  %*SUB-MAIN-OPTS: 设置 sub MAIN 的行为\n %*SUB-MAIN-OPTS\u0026lt;named-anywhere\u0026gt; 允许将命名参数放在命令行的任何位置    $*COLLATION: 配置四个 Unicode 校对级别\n  $*INIT-INSTANT: 代表程序启动时间的 Instant\n  $*HOME: 用户的主目录, 如果存在的话\n  \u0026amp;*chdir: Callable 包含 IO::Path.chdir 的变体, 也设置进程的当前目录\n  PERL6_TEST_DIE_ON_FAIL 环境变量: 在第一次失败时停止测试套件\n  PERL6_EXCEPTIONS_HANDLER 环境变量: 指定自定义异常处理类\n  对边缘情况/强转行为的澄清  UInt 与 Int 类型对象智能匹配为 True sink 语句前缀爆炸 Failure 定义了1项和0项列表以及负参数和非整数参数的 permutations/combinations 的行为 \u0026amp;val、Str.Numeric 和其他 Str 数字转换方法在试图转换 Unicode No 字符组或合成数字时会 fail :42foo 冒号对快捷方式中不能使用合成数字 现在、Enumeration 可以作为一个数组形状指定器使用 含有空格的 Str 的数值转换现在返回 0 带空的模式参数的 samark, 简单地返回调用者 .polymod 可用于 lazy 但有限的除数列表 定义了 .[*-0] 索引 .rotor 中大于子列表的负数空隙抛出异常 .rotor 的非 Int 参数被强转为 Int 参数 读取 /proc 文件时定义了 .lines 定义了字符串上后缀/前缀 ++/-- 中泰语数字的行为 sunk for 里面的 map 被视为 sunk Sunk for 循环将上一条语句的方法调用值下沉 Bool 对象上的 .Int 返回一个 Int 对象 splice 可用于扩展数组 classify 可以与 Junction 配合使用 .pairup on a type object returns an empty Seq .pairup 总是返回一个 Seq 拒绝接受 Date/DateTime 构造函数中的合成代码点 ⸨/⸩ 对儿现在可以作为引号结构中的匹配字符使用 Array 类型对象上的 .flat 简单地返回该类型对象 混合级 classify 在 Hash 上抛出异常 Junction 可以用于给 Hash 指定多个键 给 .classify-list 的 Callable 现在保证每项只执行一次 :delete 对 Hash 类型对象进行关联查找时返回 Nil Test.pm6 中的 \u0026amp;is-deeply 会自动 .cache 作为参数的 Seq, 并使用返回的 List 进行测试 Complex.new() 给出 \u0026lt;0+0i\u0026gt; Int.new 现在可以保证构建一个新的 Int (而不是, 比如说, 从常量缓存中重用一个) 定义了一个参数(1-arg)版本的 \u0026amp;infix:\u0026lt;=:=\u0026gt; 和 \u0026amp;infix:\u0026lt;eqv\u0026gt; 如果直接或间接地调用 .BIND-POS、.BIND-KEY、.ASSIGN-POS、.ASSIGN-KEY、.STORE、.push、.append、.unshift、.prepend、Nil 类型现在抛出异常 Nil.ord 返回一个空的 Seq Nil.chrs 返回一个 \u0026quot;\\0\u0026quot; Num.new 强转参数为 Num infix:\u0026lt;Z\u0026gt;() 返回一个空的 Seq .comb 总是返回一个 Seq 用 \u0026amp;infix:\u0026lt;+\u0026gt; 化简一个项, 简单地返回该项 ()[0] 返回 Nil 允许在(可能是无限的) Seq 上使用 Regex 智能匹配 定义了 Range 对象的智能匹配 Set 转换为Mix/Bag 不再有 Bool 权重 当一个或多个操作数为 0 时、gcd 是有定义的 defined 例程中的 Junction 自动线程化 sum 可以处理含有 Junction 的列表 Grammar.parse 让顶级 regex 回溯 U+2212 MINUS SIGN [Sm] (-) 现在得到更多结构的支持, 如 Str.Numeric 和 \u0026amp;val Arity-1 \u0026amp;infix:\u0026lt;~\u0026gt; 与 Blob 可以一起工作 在签名中, 所有的 Numeric 字面值都支持作为值字面值 正则表达式中的 \\b 和 \\B 抛出 X::Obsolete True 和 False 作为签名中的值字面量发出警告 .sort 和 IO::Spec::Unix.path 的返回值总是 Seq Range 对象上的 Out-of-range .AT-POS 返回 Nil 对于不存在的键、Pair.AT-KEY 返回 Nil 所有的 Cool 类型都提供了 .Rat/.FatRat 强转器 IO::Path 文件测试不缓存先前测试执行的结果 Seq eqv List 仅根据类型不匹配就定为 False 在 Hash 、Hash  和 QuantHash 上, 来自 .kv、.values 和 .pair 序列的值是可写的 参见 Raku/roast#614 和 #3519 \u0026amp;infix:\u0026lt;∘\u0026gt;/\u0026amp;infix:\u0026lt;o\u0026gt; 保留 LHF 的 .of 和 RHS 的 .arity 和 .count 完善了 regex 运算符副词中的可接受参数(例如::in(…)) 完善了 IO::Handle.open 中可接受的参数组合 IO::Path.Str 不包含 .CWD 属性的值 IO::Path 类型拒绝带有 nul 字节 (\u0026quot;\\0\u0026quot;) 的路径 IO::Pipe 的 .path/.IO 返回一个 IO::Path 类型对象 如果目的路径和源路径是一样的 IO::Path 的 .copy/.move 会 fail dir 创建的 IO::Path 绝对性由调用者控制 更多定义的边缘行为、Callable  处理、. defined 调用, 以及 \u0026amp;infix:\u0026lt;andthen\u0026gt;、\u0026amp;infix:\u0026lt;orelse\u0026gt; 和 \u0026amp;infix:\u0026lt;notandthen\u0026gt; 操作符的链接 Seq 的禅切不缓存它们 List.Capture 将任何包含的 Pair 对象的键字符串化 带处理的 Failure 参数的 \u0026amp;fail 把它标记为是未处理的 use lib 接受 IO::Path 对象 锚点 ^、^^、$ 和 $$ 在环视中有效 Grammar.made 支持类型对象 .isa 支持 subset  类型对象 :delete 可用于惰性数组 \u0026amp;infix:\u0026lt;eqv\u0026gt; 可以在某些情况下对惰性参数起作用 动态查询(::(...)) 是限制性的 regex 语法, 并且需要 use MONKEY-SEE-NO-EVAL 的许可 定义了带孔数组的 .Slip 和 .List Promise.in/.at 和 Supply.interval 可以用零值和负值工作 Supply.interval 最小值为 0.001；较低值被处理为 0.001, 并发出警告#, 参见 https://docs.perl6.org/type/Supply#method_interval PR [#2649] Supply 提供了 .Seq、.list 和 .zip 可以在构建方法中绑定到原生类型属性 WhateverCode 传播 use fatal say、note、put、print 和 printf 例程自动线程化 Junction IO::Handle.eof 值在 .seek 过终点后再返回时也会相应改变 定义了 .succ'、.pred和.Bool` 的同质异形体 在核心 Numeric 上定义了 .Bridge 在核心 Numeric 的类型对象上定义了 .Numeric/.Real 定义了关于零分母有理数的 Rational.Bool say/note 保证在 Str 的子类上调用 .gist 定义了 Junction.Str 返回 Junction 定义了 Junction.gist/.perl 返回一个 Str Map/Hash 的 .list/.cache 返回一个 List 定义了 .round 的返回类型 定义了 Enumeration:D 不 .ACCEPT 一个 Enumeration:U , 参见 rakudo/rakudo#2073  杂项  IO::ArgFiles 类型只是 IO::CatHandle 的一个空的子类 对常量的约束  约束是完全强制的 试图在常量上使用参数化类型约束(例如使用 my Foo constant @int) 会引发 X::ParametricConstant 异常   Pod =defn(定义列表)指令可用 Pod 提供了 :numbered 配置键 .^ver、.^auth 和 .^name 元方法在 module 中可用, 而在 package 中则没有, 这是设计上的原因 qww\u0026lt;…\u0026gt; 中支持花哨的引号(’…’、“…”、｢…｣ 和变体) \u0026amp;infix:\u0026lt; \u0026gt; 支持查找自动生成的 Callables (例如: \u0026amp;infix:\u0026lt;XX\u0026gt;) 使用命名的 anon 子例程不再产生重声明警告 ::?MODULE/$?MODULE 变量的扩展规范 sub MAIN 可以接受一个参数上的 Enumeration 类型约束和 where 子句 笑脸型约束可以用在子集上 start 块和 thunks 得到新的 $/ 和 $! 定义了与列表关联运算符一起使用的 R 元运算符 类型强转可以用在签名返回类型约束中 \u0026amp;infix:\u0026lt;x\u0026gt;/\u0026amp;infix:\u0026lt;x\u0026gt; 抛出了 -Inf/NaN 重复参数 字面结构 put 和 put for 抛出, 需要使用括号 扩大了 Unicode 例程和功能的规范覆盖面-将覆盖面升级到 Unicode 第11版 $. 方法调用语法能用在元方法中了  "},"name":"Checklist for Raku 6.d","published":"2020-07-21T00:00:00+08:00","summary":"Checklist for 6.d","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-07-21-checklist-for-6-dot-d/"}],"name":"raku","type":"feed","url":"https://ohmyweekly.github.io/tags/raku/"}