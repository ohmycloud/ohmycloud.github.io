{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"children":[{"content":{"html":"\u003ch2 id=\"flink-dataset-api-编程指南\"\u003eFlink DataSet API 编程指南\u003c/h2\u003e\n\u003cp\u003eFlink 中的数据集程序是对数据集实现转换（如过滤、映射、加入、分组）的常规程序。数据集最初是从某些来源创建的（例如，通过读取文件，或从本地集合中创建）。结果通过汇返回，例如可以将数据写入（分布式）文件，或标准输出（例如命令行终端）。Flink 程序可以在各种环境下运行，独立运行，或者嵌入其他程序中。执行可以发生在本地 JVM 中，也可以发生在许多机器的集群中。\u003c/p\u003e\n\u003cp\u003e请参考 \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/datastream_api.html\"\u003eDataStream API 概述\u003c/a\u003e，了解 Flink API 的基本概念。该概述是针对 DataStream API 的，但这两个 API 的基本概念是一样的。\u003c/p\u003e\n\u003cp\u003e为了创建你自己的 Flink DataSet 程序，我们鼓励你从 \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/datastream_api.html#anatomy-of-a-flink-program\"\u003eFlink 程序的骨架\u003c/a\u003e开始，并逐步添加你自己的\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/#dataset-transformations\"\u003e转换\u003c/a\u003e。其余部分作为附加操作和高级功能的参考。\u003c/p\u003e\n\u003ch3 id=\"程序示例\"\u003e程序示例\u003c/h3\u003e\n\u003cp\u003e下面的程序是一个完整的、可以使用的 WordCount 的例子，你可以复制和粘贴代码在本地运行。你可以复制和粘贴代码在本地运行它。你只需要在你的项目中加入正确的 Flink 的库（参见与 \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/project-configuration.html\"\u003eFlink 的链接\u003c/a\u003e部分）并指定导入。然后你就可以开始了\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003eorg.apache.flink.api.scala._\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eobject\u003c/span\u003e \u003cspan class=\"nc\"\u003eWordCount\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003emain\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eargs\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eArray\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e])\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eExecutionEnvironment\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetExecutionEnvironment\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003etext\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efromElements\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n      \u003cspan class=\"s\"\u003e\u0026#34;Who\u0026#39;s there?\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"s\"\u003e\u0026#34;I think I hear them. Stand, ho! Who\u0026#39;s there?\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ecounts\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etext\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eflatMap\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etoLowerCase\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esplit\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\\\\W+\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003efilter\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enonEmpty\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n      \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n      \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egroupBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n      \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esum\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n    \u003cspan class=\"n\"\u003ecounts\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprint\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"dataset-转换\"\u003eDataSet 转换\u003c/h3\u003e\n\u003cp\u003e数据转换将一个或多个 DataSet 转换为一个新的 DataSet。程序可以将多个转换组合成复杂的集合。\u003c/p\u003e\n\u003cp\u003e本节简要介绍了可用的转换。\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/dataset_transformations.html\"\u003e转换文档\u003c/a\u003e中有所有变换的完整描述和示例。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMap\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e接受一个元素，产生一个元素。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etoInt\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eFlatMap\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e接受一个元素并产生零、一个或多个元素。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eflatMap\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003estr\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003estr\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esplit\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eMapPartition\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在一个函数调用中转换一个并行分区。该函数以\u0026quot;迭代器\u0026quot;的形式获取分区，并可产生任意数量的结果值。每个分区的元素数量取决于平行度和之前的操作。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emapPartition\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003emap\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eFilter\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对每个元素进行布尔函数评估，并保留那些函数返回真的元素。\n重要：系统假设函数不会修改应用谓词的元素。违反这个假设会导致错误的结果。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efilter\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003e_\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e1000\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eReduce\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e通过重复将两个元素合并为一个元素，将一组元素合并为一个元素。换算可以应用于一个完整的数据集，也可以应用于一个分组的数据集。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ereduce\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003e_\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"k\"\u003e_\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eReduceGroup\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e将一组元素合并成一个或多个元素。\u003ccode\u003eReduceGroup\u003c/code\u003e 可以应用在一个完整的数据集上，也可以应用在一个分组的数据集上。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ereduceGroup\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003eelements\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eelements\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esum\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eAggregate\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e将一组值聚合成一个值。\u003ccode\u003eAggregation\u003c/code\u003e 函数可以被认为是内置的 \u003ccode\u003ereduce\u003c/code\u003e 函数。\u003ccode\u003eAggregate\u003c/code\u003e 可以应用于一个完整的数据集，也可以应用于一个分组的数据集。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eoutput\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eaggregate\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eSUM\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eaggregate\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eMIN\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e你也可以使用简写语法来进行 \u003ccode\u003eminimum\u003c/code\u003e, \u003ccode\u003emaximum\u003c/code\u003e 和 \u003ccode\u003esum\u003c/code\u003e 的聚合。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eoutput\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esum\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003emin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eDistinct\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e返回数据集的不同元素。它从输入的 DataSet 中删除元素的所有字段或字段子集的重复条目。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003edistinct\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eJoin\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e通过创建所有键值相等的元素对来连接两个数据集。可以选择使用 \u003ccode\u003eJoinFunction\u003c/code\u003e 将一对元素变成一个元素，或者使用 \u003ccode\u003eFlatJoinFunction\u003c/code\u003e 将一对元素变成任意多个（包括无）元素。请参阅\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/#specifying-keys\"\u003e键\u003c/a\u003e部分了解如何定义连接键。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"c1\"\u003e// In this case tuple fields are used as keys. \u0026#34;0\u0026#34; is the join field on the first tuple\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e// \u0026#34;1\u0026#34; is the join field on the second tuple.\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003einput1\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ejoin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003einput2\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eequalTo\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e你可以通过 Join Hints 指定运行时执行连接的方式。这些提示描述了连接是通过分区还是广播进行的，以及它是使用基于排序还是基于散列的算法。请参考\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/dataset_transformations.html#join-algorithm-hints\"\u003e转换指南\u003c/a\u003e，了解可能的提示列表和示例。\n如果没有指定提示，系统将尝试对输入大小进行估计，并根据这些估计选择最佳策略。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"c1\"\u003e// This executes a join by broadcasting the first data set\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e// using a hash table for the broadcast data\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003einput1\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ejoin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003einput2\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eJoinHint\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eBROADCAST_HASH_FIRST\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n                   \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eequalTo\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e请注意，连接转换只适用于等价连接。其他的连接类型需要使用 OuterJoin 或 CoGroup 来表达。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOuterJoin\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在两个数据集上执行左联接、右联接或完全外联接。外联接与常规（内联接）类似，创建所有键值相同的元素对。此外，如果在另一侧没有找到匹配的键，\u0026ldquo;外侧\u0026quot;的记录（左、右或全联接时两者都有）将被保留。匹配的元素对（或一个元素和另一个输入的 \u003ccode\u003enull\u003c/code\u003e 值）被交给 \u003ccode\u003eJoinFunction\u003c/code\u003e 将这对元素变成单个元素，或交给 \u003ccode\u003eFlatJoinFunction\u003c/code\u003e 将这对元素变成任意多个（包括无）元素。请参阅\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/#specifying-keys\"\u003e键\u003c/a\u003e部分，了解如何定义连接键。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ejoined\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eleft\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eleftOuterJoin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eright\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eequalTo\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n   \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eleft\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eright\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n     \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;none\u0026#34;\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"n\"\u003eleft\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_1\u003c/span\u003e\n     \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eright\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eCoGroup\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e减少操作的二维变体。在一个或多个字段上对每个输入进行分组，然后将分组合并。每一对组都会调用转换函数。请参阅\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/#specifying-keys\"\u003e键\u003c/a\u003e部分，了解如何定义 \u003ccode\u003ecoGroup\u003c/code\u003e 键。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003edata1\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecoGroup\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edata2\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eequalTo\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eCross\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e建立两个输入的笛卡尔乘积（交叉乘积），创建所有元素对。可选择使用交叉函数将一对元素变成一个单一元素。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003edata1\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003edata2\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003edata1\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecross\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edata2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e注意：\u003ccode\u003eCross\u003c/code\u003e 可能是一个非常耗费计算的操作，甚至可以挑战大型计算集群！建议使用 \u003ccode\u003ecrossWithTiny()\u003c/code\u003e 和 \u003ccode\u003ecrossWithHuge()\u003c/code\u003e 来提示系统数据集的大小。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eUnion\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e产生两个数据集的并集。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eunion\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edata2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eRebalance\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e均匀地重新平衡数据集的并行分区，以消除数据倾斜。只有类似于 Map 的变换才可以跟随重新平衡(rebalance)变换。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003edata1\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003edata1\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erebalance\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eHash-Partition\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在给定的键上对数据集进行散列分区。键可以被指定为位置键、表达式键和键选择函数。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epartitionByHash\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003emapPartition\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eRange-Partition\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在给定的键上按照范围分割数据集。键可以被指定为位置键、表达式键和键选择函数。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epartitionByRange\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003emapPartition\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e自定义分区\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e使用自定义的 \u003ccode\u003ePartitioner\u003c/code\u003e 函数，根据键将记录分配到特定的分区。键可以指定为位置键、表达式键和键选择函数。\n注意：此方法仅适用于单个字段键。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epartitionCustom\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epartitioner\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003emapPartition\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eSort Partition\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e按照指定的顺序对数据集的所有分区进行本地排序。字段可以指定为元组位置或字段表达式。对多个字段的排序是通过链式 \u003ccode\u003esortPartition()\u003c/code\u003e 调用完成的。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esortPartition\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eOrder\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eASCENDING\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003emapPartition\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eFirst-n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e返回一个数据集的前 n 个（任意）元素。First-n 可以应用于一个常规数据集、一个分组数据集或一个分组排序数据集。分组键可以指定为键选择函数、元组位置或 case 类字段。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e// regular data set\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult1\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efirst\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// grouped data set\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult2\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egroupBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003efirst\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// grouped-sorted data set\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult3\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egroupBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003esortGroup\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eOrder\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eASCENDING\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003efirst\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e以下转换可用于元组的数据集。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMinBy / MaxBy\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e从一组元组中选择一个元组，这些元组的一个或多个字段的值是最小的（最大的）。用于比较的字段必须是有效的键字段，即可比较。如果多个元组具有最小（最大）字段值，则返回这些元组的任意元组。MinBy (MaxBy)可以应用于一个完整的数据集或一个分组数据集。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e// a data set with a single tuple with minimum values for the Int and String fields.\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eminBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// a data set with one tuple for each group with the minimum value for the Double field.\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eout2\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egroupBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n                                             \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eminBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e通过匿名模式匹配从 tuple、case 类和集合中提取，比如下面。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ename\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003etemperature\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e不受 API 开箱即用的支持。要使用这个功能，你应该使用 \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/scala_api_extensions.html\"\u003eScala API 扩展\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e变换的\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/parallel.html\"\u003e并行度\u003c/a\u003e可以通过 \u003ccode\u003esetParallelism(int)\u003c/code\u003e 来定义，而 \u003ccode\u003ename(String)\u003c/code\u003e 可以给变换指定一个自定义的名称，这对调试很有帮助。\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/#data-sources\"\u003e数据源\u003c/a\u003e和\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/#data-sinks\"\u003e数据接收器\u003c/a\u003e也是如此。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ewithParameters(Configuration)\u003c/code\u003e 传递 Configuration 对象，这些对象可以从用户函数里面的 \u003ccode\u003eopen()\u003c/code\u003e 方法访问。\u003c/p\u003e\n\u003ch2 id=\"指定键\"\u003e指定键\u003c/h2\u003e\n\u003cp\u003e一些转换（join、coGroup、groupBy）需要在元素集合上定义一个键。其他转换（Reduce、GroupReduce、Aggregate）允许在应用之前将数据按键分组。\u003c/p\u003e\n\u003cp\u003e一个 DataSet 被分组为：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"n\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;...\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;...\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ereduced\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003egroupBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"cm\"\u003e/*define key here*/\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ereduceGroup\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"cm\"\u003e/*do something*/\u003c/span\u003e\u003cspan class=\"o\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFlink 的数据模型不是基于键值对的。因此，你不需要将数据集类型物理地打包成键和值。键是\u0026quot;虚拟的\u0026rdquo;：它们被定义为实际数据上的函数，以指导分组操作符。\u003c/p\u003e\n\u003ch3 id=\"为元组定义键\"\u003e为元组定义键\u003c/h3\u003e\n\u003cp\u003e最简单的情况是对 Tuple 的一个或多个字段进行分组。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ekeyed\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egroupBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e元组在第一个字段（整数类型的字段）上进行分组。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003egrouped\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egroupBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在这里，我们将元组放在一个由第一个字段和第二个字段组成的复合键上。\u003c/p\u003e\n\u003cp\u003e关于嵌套 Tuple 的说明。如果你的 DataSet 有一个嵌套的元组，比如：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"n\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eTuple3\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eInteger\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eFloat\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;,\u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eds\u003c/span\u003e\u003cspan class=\"o\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e指定 \u003ccode\u003egroupBy(0)\u003c/code\u003e 将使系统使用完整的 Tuple2 作为键（以 Integer 和 Float 为键）。如果要\u0026quot;导航\u0026quot;到嵌套的 Tuple2 中，就必须使用字段表达式键，下面将对其进行说明。\u003c/p\u003e\n\u003ch3 id=\"使用字段表达式定义键\"\u003e使用字段表达式定义键\u003c/h3\u003e\n\u003cp\u003e你可以使用基于字符串的字段表达式来引用嵌套的字段，并为分组、排序、连接(join)或 coGrouping 定义键。\u003c/p\u003e\n\u003cp\u003e字段表达式可以非常容易地选择（嵌套的）复合类型中的字段，如 Tuple 和 POJO 类型。\u003c/p\u003e\n\u003cp\u003e在下面的例子中，我们有一个有两个字段 \u0026ldquo;word\u0026rdquo; 和 \u0026ldquo;count\u0026rdquo; 的 WC POJO。要按字段 \u003ccode\u003eword\u003c/code\u003e 进行分组，我们只需将其名称传递给 \u003ccode\u003egroupBy()\u003c/code\u003e 函数。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"c1\"\u003e// some ordinary POJO (Plain old Java Object)\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eWC\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003eword\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0L\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ewords\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eWC\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ewordCounts\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ewords\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egroupBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;word\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// or, as a case class, which is less typing\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eWC\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eword\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ewords\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eWC\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ewordCounts\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ewords\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egroupBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;word\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"字段表达式语法\"\u003e字段表达式语法\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e通过字段名选择 POJO 字段。例如 \u0026ldquo;user\u0026rdquo; 指的是 POJO 类型的 \u0026ldquo;user\u0026rdquo; 字段。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e通过 1-offset 字段名或 0-offset 字段索引来选择 Tuple 字段。例如 \u0026ldquo;_1\u0026rdquo; 和 \u0026ldquo;5\u0026rdquo; 分别指 Scala Tuple 类型的第一和第六字段。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e你可以在 POJO 和 Tuple 中选择嵌套字段。例如 \u0026ldquo;user.zip\u0026rdquo; 指的是 POJO 的 \u0026ldquo;zip\u0026rdquo; 字段，它存储在 POJO 类型的 \u0026ldquo;user\u0026rdquo; 字段中。支持 POJO 和 Tuple 的任意嵌套和混合，如 \u0026ldquo;_2.user.zip\u0026rdquo; 或 \u0026ldquo;user._4.1.zip\u0026rdquo;。\u003c/p\u003e\n\u003cp\u003e你可以使用 \u0026ldquo;_\u0026rdquo; 通配符表达式选择完整的类型。这也适用于不是 Tuple 或 POJO 类型的类型。\u003c/p\u003e\n\u003cp\u003e字段表达式示例:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eWC\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ecomplex\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eComplexNestedClass\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eComplexNestedClass\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"k\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003esomeNumber\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"n\"\u003esomeFloat\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eFloat\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eword\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e),\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ehadoopCitizen\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eIntWritable\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e),\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eIntWritable\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这些都是上面例子代码的有效字段表达式。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u0026ldquo;count\u0026rdquo;: WC 类中的计数字段\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u0026ldquo;complex\u0026rdquo;: 递归选择 POJO 类型 \u003ccode\u003eComplexNestedClass\u003c/code\u003e 的 \u003ccode\u003ecomplex\u003c/code\u003e 字段的所有字段。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u0026ldquo;complex.word._3\u0026rdquo;: 选择嵌套的 Tuple3 的最后一个字段。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u0026ldquo;complex.hadoopCitizen\u0026rdquo;: 选择 Hadoop \u003ccode\u003eIntWritable\u003c/code\u003e 类型。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"使用键选择函数定义键\"\u003e使用键选择函数定义键\u003c/h3\u003e\n\u003cp\u003e另一种定义键的方法是\u0026quot;键选择器\u0026quot;函数。键选择器函数将一个元素作为输入，并返回该元素的键。键可以是任何类型的，并且可以从确定性计算中得到。\u003c/p\u003e\n\u003cp\u003e下面的例子显示了一个简单返回对象字段的键选择函数。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"c1\"\u003e// some ordinary case class\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eWC\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eword\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ewords\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eWC\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ekeyed\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ewords\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egroupBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e \u003cspan class=\"k\"\u003e_\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eword\u003c/span\u003e \u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"数据源\"\u003e数据源\u003c/h2\u003e\n\u003cp\u003e数据源创建初始数据集，例如从文件或 Java 集合中创建。创建数据集的一般机制是在 \u003ca href=\"https://github.com/apache/flink/blob/master//flink-core/src/main/java/org/apache/flink/api/common/io/InputFormat.java\"\u003eInputFormat\u003c/a\u003e 后面抽象出来的。Flink 自带了几种内置的格式来从常见的文件格式创建数据集。其中许多格式在 ExecutionEnvironment 上有快捷方法。\u003c/p\u003e\n\u003cp\u003e基于文件的:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ereadTextFile(path) / TextInputFormat\u003c/code\u003e - 读取文件并以字符串形式返回。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ereadTextFileWithValue(path) / TextValueInputFormat\u003c/code\u003e - 以行的方式读取文件并以 \u003ccode\u003eStringValues\u003c/code\u003e 的形式返回。\u003ccode\u003eStringValues\u003c/code\u003e 是可变字符串。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ereadCsvFile(path) / CsvInputFormat\u003c/code\u003e - 解析以逗号（或其他字符）分隔的文件。返回一个由 tuple、case 类对象或 POJOs 组成的 DataSet。支持基本的 java 类型及其对应的 Value 类型作为字段类型。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ereadFileOfPrimitives(path, delimiter) / PrimitiveInputFormat\u003c/code\u003e - 使用给定的定界符，解析新行（或其他字符序列）定界的基元数据类型的文件，如 String 或 Integer。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ereadSequenceFile(Key, Value, path) / SequenceFileInputFormat\u003c/code\u003e - 创建一个 JobConf 并从指定的路径读取文件，文件类型为 \u003ccode\u003eSequenceFileInputFormat\u003c/code\u003e，Key 类和 Value 类，并以 \u003ccode\u003eTuple2\u0026lt;Key, Value\u0026gt;\u003c/code\u003e 的形式返回。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e基于集合的:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003efromCollection(Iterable)\u003c/code\u003e - 从一个 Iterable 创建一个数据集。Iterable 返回的所有元素必须是相同的类型。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003efromCollection(Iterator)\u003c/code\u003e - 从一个 Iterator 创建一个数据集。该类指定了迭代器返回的元素的数据类型。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003efromElements(elements: _*)\u003c/code\u003e - 从给定的对象序列中创建一个数据集。所有对象必须是相同的类型。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003efromParallelCollection(SplittableIterator)\u003c/code\u003e - 从迭代器中并行创建一个数据集。该类指定了迭代器返回的元素的数据类型。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003egenerateSequence(from, to)\u003c/code\u003e - 在给定的区间内并行生成数字序列。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e通用的:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ereadFile(inputFormat, path) / FileInputFormat\u003c/code\u003e - 接受一个文件输入格式。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ecreateInput(inputFormat) / InputFormat\u003c/code\u003e - 接受一个通用的输入格式。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e示例:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e  \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eExecutionEnvironment\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetExecutionEnvironment\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// read text file from local files system\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003elocalLines\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ereadTextFile\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;file:///path/to/my/textfile\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// read text file from an HDFS running at nnHost:nnPort\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ehdfsLines\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ereadTextFile\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;hdfs://nnHost:nnPort/path/to/my/textfile\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// read a CSV file with three fields\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ecsvInput\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ereadCsvFile\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e\u003cspan class=\"o\"\u003e)](\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;hdfs:///the/CSV/file\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// read a CSV file with five fields, taking only two of them\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ecsvInput\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ereadCsvFile\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e\u003cspan class=\"o\"\u003e)](\u003c/span\u003e\n  \u003cspan class=\"s\"\u003e\u0026#34;hdfs:///the/CSV/file\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"n\"\u003eincludedFields\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eArray\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e \u003cspan class=\"c1\"\u003e// take the first and the fourth field\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// CSV input can also be used with Case Classes\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMyCaseClass\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estr\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003edbl\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ecsvInput\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ereadCsvFile\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eMyCaseClass\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\n  \u003cspan class=\"s\"\u003e\u0026#34;hdfs:///the/CSV/file\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"n\"\u003eincludedFields\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eArray\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e \u003cspan class=\"c1\"\u003e// take the first and the fourth field\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// read a CSV file with three fields into a POJO (Person) with corresponding fields\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ecsvInput\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ereadCsvFile\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003ePerson\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\n  \u003cspan class=\"s\"\u003e\u0026#34;hdfs:///the/CSV/file\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"n\"\u003epojoFields\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eArray\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;age\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;zipcode\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// create a set from some given elements\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003evalues\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efromElements\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Foo\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;bar\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;foobar\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;fubar\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// generate a number sequence\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003enumbers\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egenerateSequence\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e10000000\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// read a file from the specified path of type SequenceFileInputFormat\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003etuples\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecreateInput\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nc\"\u003eHadoopInputs\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ereadSequenceFile\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eclassOf\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eIntWritable\u003c/span\u003e\u003cspan class=\"o\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003eclassOf\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eText\u003c/span\u003e\u003cspan class=\"o\"\u003e],\u003c/span\u003e\n \u003cspan class=\"s\"\u003e\u0026#34;hdfs://nnHost:nnPort/path/to/file\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"配置-csv-解析\"\u003e配置 CSV 解析\u003c/h3\u003e\n\u003cp\u003eFlink 为 CSV 解析提供了许多配置选项。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003elineDelimiter: 字符串指定单个记录的定界符。默认的行定界符是新行字符 \u003ccode\u003e'/n'\u003c/code\u003e。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003efieldDelimiter: 字符串指定分隔记录字段的定界符。默认的字段定界符是逗号字符 \u003ccode\u003e','\u003c/code\u003e。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eincludeFields: \u003ccode\u003eArray[Int]\u003c/code\u003e 定义从输入文件中读取哪些字段（以及忽略哪些字段）。默认情况下，前 n 个字段（由 \u003ccode\u003etype()\u003c/code\u003e 调用中的类型数定义）会被解析。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003epojoFields: \u003ccode\u003eArray[String]\u003c/code\u003e 指定 POJO 的字段，这些字段被映射到 CSV 字段。CSV 字段的解析器会根据 POJO 字段的类型和顺序自动初始化。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eparseQuotedStrings: 启用引号字符串解析的字符。如果字符串字段的第一个字符是引号字符，那么字符串将被解析为引号字符串（前导或尾部的空白不被修剪）。引号字符串中的字段定界符会被忽略。如果引号字符串字段的最后一个字符不是引号字符，则引号字符串解析失败。如果启用了引号字符串解析，且字段的第一个字符不是引号字符串，则该字符串将被解析为未引号字符串。默认情况下，引号字符串解析被禁用。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eignoreComments: 字符串指定一个注解前缀。所有以指定注解前缀开始的行都不会被解析和忽略。默认情况下，没有行被忽略。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003elenient：布尔值，启用宽松解析。也就是说，不能正确解析的行会被忽略。默认情况下，禁用宽松解析，无效行会引发异常。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eignoreFirstLine: Boolean 配置 InputFormat 忽略输入文件的第一行。默认情况下，没有行被忽略。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"input-path-的递归遍历\"\u003eInput Path 的递归遍历\u003c/h3\u003e\n\u003cp\u003e对于基于文件的输入，当输入路径是一个目录时，默认情况下不会枚举嵌套文件。取而代之的是，只读取基础目录内的文件，而忽略嵌套文件。嵌套文件的递归枚举可以通过 \u003ccode\u003erecursive.file.enumeration\u003c/code\u003e 配置参数启用，就像下面的例子。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"c1\"\u003e// enable recursive enumeration of nested input files\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e  \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eExecutionEnvironment\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetExecutionEnvironment\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// create a configuration object\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eparameters\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eConfiguration\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// set the recursive enumeration parameter\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eparameters\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esetBoolean\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;recursive.file.enumeration\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// pass the configuration to the data source\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ereadTextFile\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;file:///path/with.nested/files\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewithParameters\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eparameters\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"读取压缩文件\"\u003e读取压缩文件\u003c/h3\u003e\n\u003cp\u003eFlink 目前支持输入文件的透明解压，如果这些文件被标记为适当的文件扩展名。特别是，这意味着无需进一步配置输入格式，任何 \u003ccode\u003eFileInputFormat\u003c/code\u003e 都支持压缩，包括自定义输入格式。请注意，压缩文件可能不会被并行读取，从而影响作业的可扩展性。\u003c/p\u003e\n\u003cp\u003e下表列出了当前支持的压缩方法。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e压缩方法\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e文件后缀\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e并行性\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eDEFLATE\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e.deflate\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eno\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eGZip\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e.gz, .gzip\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eno\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eBzip2\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e.bz2\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eno\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eXZ\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e.xz\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eno\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"数据接收器\"\u003e数据接收器\u003c/h2\u003e\n\u003cp\u003e数据接收器消费 DataSet 并用于存储或返回它们。数据接收器的操作是用 \u003ca href=\"https://github.com/apache/flink/blob/master//flink-core/src/main/java/org/apache/flink/api/common/io/OutputFormat.java\"\u003eOutputFormat\u003c/a\u003e 来描述的。Flink 带有各种内置的输出格式，这些格式被封装在对 DataSet 的操作后面。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ewriteAsText() / TextOutputFormat\u003c/code\u003e \u0026ndash;将元素逐行写成 Strings。通过调用每个元素的 \u003ccode\u003etoString()\u003c/code\u003e 方法获得字符串。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewriteAsCsv(...) / CsvOutputFormat\u003c/code\u003e - 将元组写成逗号分隔的值文件。行和字段定界符是可配置的。每个字段的值来自对象的 \u003ccode\u003etoString()\u003c/code\u003e 方法。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eprint() / printToErr()\u003c/code\u003e - 在标准输出/标准错误流上打印每个元素的 \u003ccode\u003etoString()\u003c/code\u003e 值。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewrite() / FileOutputFormat\u003c/code\u003e - 用于自定义文件输出的方法和基类。支持自定义对象到字节的转换。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eoutput()/ OutputFormat\u003c/code\u003e - 最通用的输出方法，用于非基于文件的数据接收器（如将结果存储在数据库中）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e一个 DataSet 可以被输入到多个操作中。程序可以写入或打印一个数据集，同时还可以对其进行额外的转换。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e示例\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e标准数据接收器方法:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"c1\"\u003e// text data\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003etextData\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// write DataSet to a file on the local file system\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003etextData\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewriteAsText\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;file:///my/result/on/localFS\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// write DataSet to a file on an HDFS with a namenode running at nnHost:nnPort\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003etextData\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewriteAsText\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;hdfs://nnHost:nnPort/my/result/on/localFS\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// write DataSet to a file and overwrite the file if it exists\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003etextData\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewriteAsText\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;file:///my/result/on/localFS\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eWriteMode\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eOVERWRITE\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// tuples as lines with pipe as the separator \u0026#34;a|b|c\u0026#34;\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003evalues\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003evalues\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewriteAsCsv\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;file:///path/to/the/result/file\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;\\n\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;|\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// this writes tuples in the text formatting \u0026#34;(a, b, c)\u0026#34;, rather than as CSV lines\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003evalues\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewriteAsText\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;file:///path/to/the/result/file\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// this writes values as strings using a user-defined formatting\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003evalues\u003c/span\u003e \u003cspan class=\"n\"\u003emap\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003etuple\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003etuple\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_1\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34; - \u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003etuple\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_2\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewriteAsText\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;file:///path/to/the/result/file\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"本地排序输出\"\u003e本地排序输出\u003c/h3\u003e\n\u003cp\u003e数据接收器的输出可以使用\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/#define-keys-for-tuples\"\u003e元组字段位置\u003c/a\u003e或\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/#define-keys-using-field-expressions\"\u003e字段表达式\u003c/a\u003e对指定字段按指定顺序进行本地排序。这适用于每一种输出格式。\u003c/p\u003e\n\u003cp\u003e下面的示例展示了如何使用该功能。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003etData\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003epData\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eBookPojo\u003c/span\u003e, \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003esData\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// sort output on String field in ascending order\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003etData\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esortPartition\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eOrder\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eASCENDING\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eprint\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// sort output on Double field in descending and Int field in ascending order\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003etData\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esortPartition\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eOrder\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eDESCENDING\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003esortPartition\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eOrder\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eASCENDING\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eprint\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// sort output on the \u0026#34;author\u0026#34; field of nested BookPojo in descending order\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003epData\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esortPartition\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;_1.author\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eOrder\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eDESCENDING\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewriteAsText\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// sort output on the full tuple in ascending order\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003etData\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esortPartition\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;_\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eOrder\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eASCENDING\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewriteAsCsv\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// sort atomic type (String) output in descending order\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003esData\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esortPartition\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;_\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eOrder\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eDESCENDING\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewriteAsText\u003c/span\u003e\u003cspan class=\"o\"\u003e(...)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e目前还不支持全局排序输出。\u003c/p\u003e\n\u003ch2 id=\"迭代运算符\"\u003e迭代运算符\u003c/h2\u003e\n\u003cp\u003e迭代在  Flink 程序中实现了循环。迭代运算符封装了程序的一部分，并反复执行，将一次迭代的结果（部分解）反馈到下一次迭代中。Flink 中的迭代有两种类型。\u003ccode\u003eBulkIteration\u003c/code\u003e 和 \u003ccode\u003eDeltaIteration\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e本节提供了如何使用这两种运算符的快速示例。查看\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/iterations.html\"\u003e迭代介绍页面\u003c/a\u003e可以获得更详细的介绍。\u003c/p\u003e\n\u003ch3 id=\"批量迭代\"\u003e批量迭代\u003c/h3\u003e\n\u003cp\u003e要创建一个 \u003ccode\u003eBulkIteration\u003c/code\u003e，调用迭代开始的 DataSet 的 \u003ccode\u003eiterate(int)\u003c/code\u003e 方法，同时指定一个 \u003ccode\u003estep\u003c/code\u003e 函数。\u003ccode\u003estep\u003c/code\u003e 函数获取当前迭代的输入 DataSet，并且必须返回一个新的 DataSet。迭代调用的参数是最大的迭代次数，迭代过后要停止。\u003c/p\u003e\n\u003cp\u003e还有 \u003ccode\u003eiterateWithTermination(int)\u003c/code\u003e 函数，接受 \u003ccode\u003estep\u003c/code\u003e 函数，返回两个 DataSets。迭代步骤的结果和一个终止标准。一旦终止准则 DataSet 为空，就会停止迭代。\u003c/p\u003e\n\u003cp\u003e下面的例子是迭代估计数字 Pi。目标是计算随机点的数量，这些随机点落入单位圆中。在每一次迭代中，都会挑选一个随机点。如果这个点位于单位圆内，我们就递增计数。然后，Pi 的估计值是所得到的计数除以迭代次数乘以 4。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eExecutionEnvironment\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetExecutionEnvironment\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// Create initial DataSet\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003einitial\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efromElements\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ecount\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003einitial\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eiterate\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e10000\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003eiterationInput\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eiterationInput\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eMath\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erandom\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eMath\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003erandom\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"n\"\u003eresult\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecount\u003c/span\u003e \u003cspan class=\"n\"\u003emap\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"mf\"\u003e10000.0\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eprint\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eexecute\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Iterative Pi Example\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e你也可以查看 \u003ca href=\"https://github.com/apache/flink/blob/master//flink-examples/flink-examples-batch/src/main/scala/org/apache/flink/examples/scala/clustering/KMeans.scala\"\u003eK-Means\u003c/a\u003e 的例子，它使用 \u003ccode\u003eBulkIteration\u003c/code\u003e 来聚类一组未标记的点。\u003c/p\u003e\n\u003ch3 id=\"增量迭代\"\u003e增量迭代\u003c/h3\u003e\n\u003cp\u003e增量迭代利用了某些算法在每次迭代中不改变解的每个数据点的事实。\u003c/p\u003e\n\u003cp\u003e除了在每次迭代中反馈的部分解（称为 workset），delta 迭代还保持着跨迭代的状态（称为解集），可以通过 delta 更新。迭代计算的结果是最后一次迭代后的状态。关于 delta 迭代的基本原理，请参考\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/iterations.html\"\u003e迭代简介\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e定义 \u003ccode\u003eDeltaIteration\u003c/code\u003e 与定义 \u003ccode\u003eBulkIteration\u003c/code\u003e 类似。对于 delta 迭代，两个数据集构成了每次迭代的输入（工作集和解集），并且在每次迭代中产生两个数据集作为结果（新工作集，解集 delta）。\u003c/p\u003e\n\u003cp\u003e要创建一个 DeltaIteration 在初始解集上调用 \u003ccode\u003eiterateDelta(initialWorkset，maxIterations，key)\u003c/code\u003e。\u003ccode\u003estep\u003c/code\u003e 函数需要两个参数。(solutionSet, workset), 并且必须返回两个值: (solutionSetDelta, newWorkset).\u003c/p\u003e\n\u003cp\u003e下面是一个 delta 迭代语法的例子。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"c1\"\u003e// read the initial data sets\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003einitialSolutionSet\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eLong\u003c/span\u003e, \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003einitialWorkset\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eLong\u003c/span\u003e, \u003cspan class=\"kt\"\u003eDouble\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"c1\"\u003e// [...]\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003emaxIterations\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e100\u003c/span\u003e\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ekeyPosition\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003einitialSolutionSet\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eiterateDelta\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003einitialWorkset\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003emaxIterations\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eArray\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekeyPosition\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esolution\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eworkset\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ecandidateUpdates\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eworkset\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egroupBy\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ereduceGroup\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eComputeCandidateChanges\u003c/span\u003e\u003cspan class=\"o\"\u003e())\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003edeltas\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecandidateUpdates\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ejoin\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esolution\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eequalTo\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eCompareChangesToCurrent\u003c/span\u003e\u003cspan class=\"o\"\u003e())\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003enextWorkset\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003edeltas\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efilter\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eFilterByThreshold\u003c/span\u003e\u003cspan class=\"o\"\u003e())\u003c/span\u003e\n\n    \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edeltas\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enextWorkset\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewriteAsCsv\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eoutputPath\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eexecute\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"在函数中对数据对象进行操作\"\u003e在函数中对数据对象进行操作\u003c/h2\u003e\n\u003cp\u003eFlink 的运行时以 Java 对象的形式与用户函数交换数据。函数从运行时接收输入对象作为方法参数，并返回输出对象作为结果。因为这些对象是由用户函数和运行时代码访问的，所以理解和遵循用户代码如何访问，即读取和修改这些对象的规则是非常重要的。\u003c/p\u003e\n\u003cp\u003e用户函数以常规方法参数（如 MapFunction）或通过 Iterable 参数（如 GroupReduceFunction）从 Flink 的运行时接收对象。我们把运行时传递给用户函数的对象称为输入对象。用户函数可以将对象作为方法返回值（像 MapFunction）或通过 Collector（像 FlatMapFunction）发射给 Flink 运行时。我们将用户函数向运行时发射的对象称为输出对象。\u003c/p\u003e\n\u003cp\u003eFlink 的 DataSet API 具有两种模式，它们在 Flink 的运行时如何创建或重用输入对象方面有所不同。这种行为会影响用户函数如何与输入和输出对象交互的保证和约束。下面的章节定义了这些规则，并给出了编写安全用户函数代码的编码指南。\u003c/p\u003e\n\u003ch3 id=\"禁用对象重用default\"\u003e禁用对象重用(DEFAULT)\u003c/h3\u003e\n\u003cp\u003e默认情况下，Flink 在禁用对象重用模式下运行。这种模式可以保证函数在函数调用中总是接收新的输入对象。对象重用禁用模式能提供更好的保证，使用起来也更安全。但是，它有一定的处理开销，可能会引起较高的 Java 垃圾收集活动。下表解释了在禁用对象重用模式下，用户函数如何访问输入和输出对象。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e操作\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e保证和限制\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e读取输入对象\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e在一个方法调用中，保证输入对象的值不会改变。这包括由 Iterable 服务的对象。例如，在 List 或 Map 中收集由 Iterable 服务的输入对象是安全的。请注意，在方法调用离开后，对象可能会被修改。跨函数调用记忆对象是不安全的。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e修改输入对象\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e你可以修改输入对象。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e发射输入对象\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e你可以发射输入对象。输入对象的值可能在发射后发生变化。读取发射后的输入对象是不安全的。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e读取输出对象\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e给予收集器的对象或作为方法结果返回的对象可能已经改变了其值。读取输出对象是不安全的。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e修改输出对象\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e你可以在对象被发射后对其进行修改，然后再次发射。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e对象重用禁用（默认）模式的编码准则。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e不要跨方法调用记忆和读取输入对象。\u003c/li\u003e\n\u003cli\u003e不要在发出对象后读取对象。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"启用对象重用\"\u003e启用对象重用\u003c/h3\u003e\n\u003cp\u003e在启用对象重用模式下，Flink 的运行时会尽量减少对象实例化的数量。这可以提高性能，并且可以减少 Java 垃圾收集的压力。通过调用 \u003ccode\u003eExecutionConfig.enableObjectReuse()\u003c/code\u003e 激活对象重用启用模式。下表解释了在启用对象重用模式下，用户函数如何访问输入和输出对象。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e操作\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e保证和限制\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e读取作为常规方法参数接收的输入对象\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e作为常规方法参数接收的输入对象在一次函数调用中不被修改。对象可能在方法调用结束后被修改。跨函数调用记忆对象是不安全的。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e读取从 Iterable 参数中接收到的输入对象\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e从 Iterable 中接收到的输入对象只在调用 next()方法之前有效。一个 Iterable 或 Iterator 可以多次服务于同一个对象实例。记住从 Iterable 接收的输入对象是不安全的，例如，把它们放在 List 或 Map 中。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e修改输入对象\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e除了 MapFunction、FlatMapFunction、MapPartitionFunction、GroupReduceFunction、GroupCombineFunction、CoGroupFunction 和 InputFormat.next(reuse)的输入对象外，你不得修改输入对象。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e发射输入对象\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e除了 MapFunction、FlatMapFunction、MapPartitionFunction、GroupReduceFunction、GroupCombineFunction、CoGroupFunction 和 InputFormat.next(重用)的输入对象外，你不得发射输入对象。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e读取输出对象\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e一个被交给 Collector 或作为方法结果返回的对象可能已经改变了它的值。读取输出对象是不安全的。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e修改输出对象\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e你可以修改一个输出对象并再次发出它。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e启用对象重用的编码准则。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e不记忆从 Iterable 接收的输入对象。\u003c/li\u003e\n\u003cli\u003e不记忆和读取跨方法调用的输入对象。\u003c/li\u003e\n\u003cli\u003e除了 MapFunction、FlatMapFunction、MapPartitionFunction、GroupReduceFunction、GroupCombineFunction、CoGroupFunction 和 InputFormat.next(reuse)的输入对象外，不要修改或发出输入对象。\u003c/li\u003e\n\u003cli\u003e为了减少对象实例化，你总是可以发出一个专门的输出对象，这个对象被反复修改，但从不读取。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"调试\"\u003e调试\u003c/h2\u003e\n\u003cp\u003e在分布式集群中的大型数据集上运行数据分析程序之前，最好确保所实现的算法能够按照预期的方式运行。因此，实现数据分析程序通常是一个检查结果、调试和改进的渐进过程。\u003c/p\u003e\n\u003cp\u003eFlink 提供了一些不错的功能，通过支持 IDE 内的本地调试、注入测试数据和收集结果数据，大大简化了数据分析程序的开发过程。本节给大家一些提示，如何简化 Flink 程序的开发。\u003c/p\u003e\n\u003ch3 id=\"本地执行环境\"\u003e本地执行环境\u003c/h3\u003e\n\u003cp\u003eLocalEnvironment 在它创建的同一个 JVM 进程中启动 Flink 系统。如果你从 IDE 中启动 LocalEnvironment，你可以在代码中设置断点，轻松调试你的程序。\u003c/p\u003e\n\u003cp\u003eLocalEnvironment 的创建和使用方法如下。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eExecutionEnvironment\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecreateLocalEnvironment\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003elines\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ereadTextFile\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epathToTextFile\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// build your program\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eexecute\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"收集数据源和接收器\"\u003e收集数据源和接收器\u003c/h3\u003e\n\u003cp\u003e为分析程序提供输入并检查其输出，如果通过创建输入文件和读取输出文件来完成，是很麻烦的。Flink 具有特殊的数据源和接收器，这些数据源和接收器由 Java 集合支持，以方便测试。一旦程序经过测试，源和接收器可以很容易地被从 HDFS 等外部数据存储中读取/写入的源和接收器所替代。\u003c/p\u003e\n\u003cp\u003e集合数据源可以使用以下方式。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eExecutionEnvironment\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecreateLocalEnvironment\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// Create a DataSet from a list of elements\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003emyInts\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efromElements\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// Create a DataSet from any Collection\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eSeq\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003emyTuples\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efromCollection\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// Create a DataSet from an Iterator\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003elongIt\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eIterator\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eLong\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003emyLongs\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efromCollection\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elongIt\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e注：目前，集合数据源要求数据类型和迭代器实现 Serializable。此外，集合数据源不能并行执行（ parallelism = 1）。\u003c/p\u003e\n\u003ch2 id=\"语义注解\"\u003e语义注解\u003c/h2\u003e\n\u003cp\u003e语义注解可以用来给 Flink 提供关于函数行为的提示。它们告诉系统，函数读取并评估了函数输入的哪些字段，以及它将哪些字段从输入转发到输出，而没有进行修改。语义注解是加快执行速度的有力手段，因为它们允许系统推理出在多个操作中重复使用排序顺序或分区的问题。使用语义注解最终可能会使程序免于不必要的数据洗牌或不必要的排序，并显著提高程序的性能。\u003c/p\u003e\n\u003cp\u003e注意：语义注解的使用是可选的。然而，在提供语义注解时，保守地使用语义注解是绝对关键的! 不正确的语义注解将导致 Flink 对你的程序做出不正确的假设，并可能最终导致不正确的结果。如果一个操作符的行为不是明确可预测的，就不应该提供注解。请仔细阅读文档。\u003c/p\u003e\n\u003cp\u003e目前支持以下语义注解。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e转发字段注解\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e转发字段信息声明了未被修改的输入字段被函数转发到输出中的同一位置或另一位置。该信息被优化器用来推断数据属性（如排序或分区）是否被函数保留。对于对输入元素组进行操作的函数，如 GroupReduce、GroupCombine、CoGroup 和 MapPartition，所有被定义为转发字段的字段必须总是从同一个输入元素联合转发。由组智函数发出的每个元素的转发字段可能来源于函数的输入组的不同元素。\u003c/p\u003e\n\u003cp\u003e字段转发信息使用\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/#define-keys-using-field-expressions\"\u003e字段表达式\u003c/a\u003e来指定。在输出中转发到同一位置的字段可以通过其位置来指定。指定的位置必须对输入和输出的数据类型有效，并具有相同的类型。例如字符串 \u0026ldquo;f2 \u0026ldquo;声明 Java 输入元组的第三个字段总是等于输出元组中的第三个字段。\u003c/p\u003e\n\u003cp\u003e将输入中的源字段和输出中的目标字段指定为字段表达式，就可以声明未修改的字段转发到输出中的另一个位置。字符串 \u003ccode\u003e\u0026quot;f0-\u0026gt;f2\u0026quot;\u003c/code\u003e 表示将 Java 输入元组的第一个字段不变的复制到 Java 输出元组的第三个字段。通配符表达式 \u003ccode\u003e*\u003c/code\u003e 可以用来指代整个输入或输出类型，即 \u003ccode\u003e\u0026quot;f0-\u0026gt;*\u0026quot;\u003c/code\u003e 表示一个函数的输出总是等于其 Java 输入元组的第一个字段。\u003c/p\u003e\n\u003cp\u003e多个转发字段可以在一个字符串中用分号隔开声明为 \u003ccode\u003e\u0026quot;f0; f2-\u0026gt;f1; f3-\u0026gt;f2\u0026quot;\u003c/code\u003e，也可以在单独的字符串中声明为 \u0026ldquo;f0\u0026rdquo;、\u0026ldquo;f2-\u0026gt;f1\u0026rdquo;、\u0026ldquo;f3-\u0026gt;f2\u0026rdquo;。当指定转发字段时，不要求所有的转发字段都声明，但所有的声明必须正确。\u003c/p\u003e\n\u003cp\u003e转发字段信息可以通过在函数类定义上附加 Java 注解来声明，或者在调用 DataSet 上的函数后将其作为操作符参数传递，如下图所示。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e函数类注解\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e@ForwardedFields\u003c/code\u003e 用于单输入的函数，如 Map 和 Reduce。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@ForwardedFieldsFirst\u003c/code\u003e 代表有两个输入的函数的第一个输入，如 Join 和 CoGroup。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@ForwardedFieldsSecond\u003c/code\u003e 代表有两个输入的函数的第二个输入，如 Join 和 CoGroup。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e操作符参数\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edata.map(myMapFnc).withForwardedFields()\u003c/code\u003e 用于单输入的函数，如 Map 和 Reduce。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edata1.join(data2).where().equalTo().with(myJoinFnc).withForwardFieldsFirst()\u003c/code\u003e 用于有两个输入的函数的第一个输入，如 Join 和 CoGroup。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edata1.join(data2).where().equalTo().with(myJoinFnc).withForwardFieldsSecond()\u003c/code\u003e 用于有两个输入的函数的第二个输入，如 Join 和 CoGroup。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e请注意，不可能覆盖通过操作符参数指定为类注解的字段前向信息。\u003c/p\u003e\n\u003cp\u003e例子：在函数的第二个输入端，如 Join 和 CoGroup，请注意不能覆盖通过运算符参数指定的类注解的字段前向信息。\u003c/p\u003e\n\u003cp\u003e下面的例子显示了如何使用函数类注解来声明转发的字段信息。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"nd\"\u003e@ForwardedFields\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;_1-\u0026gt;_3\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMyMap\u003c/span\u003e \u003cspan class=\"k\"\u003eextends\u003c/span\u003e \u003cspan class=\"nc\"\u003eMapFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e, \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)]{\u003c/span\u003e\n   \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;foo\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_2\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_1\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e非转发字段\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e非转发字段信息声明了所有在函数输出中不保留在同一位置的字段。所有其他字段的值都被认为保留在输出的同一位置。因此，非转发字段信息与转发字段信息是相反的。分组运算符（如 GroupReduce、GroupCombine、CoGroup 和 MapPartition）的非转发字段信息必须满足与转发字段信息相同的要求。\u003c/p\u003e\n\u003cp\u003e重要：非转发字段信息的规范是可选的。但是如果使用，必须指定 \u003cstrong\u003eALL!\u003c/strong\u003e 非转发字段，因为所有其他字段都被认为是原地转发的。将一个转发字段声明为非转发字段是安全的。\u003c/p\u003e\n\u003cp\u003e非转发字段被指定为\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/#define-keys-using-field-expressions\"\u003e字段表达式\u003c/a\u003e的列表。这个列表既可以是由分号分隔的字段表达式组成的单个字符串，也可以是多个字符串。例如 \u0026ldquo;f1; f3\u0026rdquo; 和 \u0026ldquo;f1\u0026rdquo;、\u0026ldquo;f3\u0026rdquo; 都声明 Java 元组的第二个和第四个字段不保留在原地，其他所有字段都保留在原地。非前向字段信息只能为输入和输出类型相同的函数指定。\u003c/p\u003e\n\u003cp\u003e非转发字段信息是作为函数类注解使用以下注解来指定的。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e@NonForwardedFields\u003c/code\u003e 用于单个输入函数，如 Map 和 Reduce。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@NonForwardedFieldsFirst\u003c/code\u003e 用于有两个输入的函数的第一个输入，如 Join 和 CoGroup。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@NonForwardedFieldsSecond\u003c/code\u003e 用于函数的第二个输入，如 Join 和 CoGroup。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e例子\u003c/p\u003e\n\u003cp\u003e下面的例子显示了如何声明非转发字段信息。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"nd\"\u003e@NonForwardedFields\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;_2\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"c1\"\u003e// second field is not forwarded\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMyMap\u003c/span\u003e \u003cspan class=\"k\"\u003eextends\u003c/span\u003e \u003cspan class=\"nc\"\u003eMapFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e, \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)]{\u003c/span\u003e\n  \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_1\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_2\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e读取字段\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e读取字段信息声明了所有被函数访问和评估的字段，也就是说，所有被函数用来计算结果的字段。例如，在条件语句中被评估的字段或用于计算的字段必须在指定读取字段信息时被标记为读取。仅仅是未经修改就转发到输出而不评估其值的字段，或者根本没有被访问的字段都不被认为是读。\u003c/p\u003e\n\u003cp\u003e重要：读取字段信息的指定是可选的。但是如果使用，必须指定 \u003cstrong\u003eALL!\u003c/strong\u003e 读取字段。将一个非读字段声明为读字段是安全的。\u003c/p\u003e\n\u003cp\u003e读取字段被指定为\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/#define-keys-using-field-expressions\"\u003e字段表达式\u003c/a\u003e的列表。这个列表可以是一个由分号分隔的字段表达式组成的单个字符串，也可以是多个字符串。例如 \u0026ldquo;f1; f3\u0026rdquo; 和 \u0026ldquo;f1\u0026rdquo;、\u0026ldquo;f3\u0026rdquo; 都声明 Java 元组的第二和第四字段被函数读取和评估。\u003c/p\u003e\n\u003cp\u003e读取字段信息是以函数类注解的形式指定的，使用以下注解。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e@ReadFields\u003c/code\u003e 用于单输入函数，如 Map 和 Reduce。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@ReadFieldsFirst\u003c/code\u003e 用于有两个输入的函数的第一个输入，如 Join 和 CoGroup。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@ReadFieldsSecond\u003c/code\u003e 用于有两个输入的函数的第二个输入，如 Join 和 CoGroup。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e示例：\u003c/p\u003e\n\u003cp\u003e下面的例子显示了如何声明读取字段信息。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"nd\"\u003e@ReadFields\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;_1; _4\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"c1\"\u003e// _1 and _4 are read and evaluated by the function.\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMyMap\u003c/span\u003e \u003cspan class=\"k\"\u003eextends\u003c/span\u003e \u003cspan class=\"nc\"\u003eMapFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e, \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e, \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)]{\u003c/span\u003e\n   \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"nc\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_1\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_1\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_4\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003e_2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"广播变量\"\u003e广播变量\u003c/h2\u003e\n\u003cp\u003e广播变量允许你在操作的常规输入之外，将一个数据集提供给操作的所有并行实例。这对辅助数据集或数据依赖性参数化很有用。然后，该数据集将作为一个集合在操作者处被访问。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e广播：广播集通过 \u003ccode\u003ewithBroadcastSet(DataSet，String)\u003c/code\u003e 按名称注册，并通过\u003c/li\u003e\n\u003cli\u003e访问方式：通过目标操作者处的 \u003ccode\u003egetRuntimeContext().getBroadcastVariable(String)\u003c/code\u003e 访问。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"c1\"\u003e// 1. The DataSet to be broadcast\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003etoBroadcast\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efromElements\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efromElements\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;a\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;b\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eRichMapFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e]()\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ebroadcastSet\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eTraversable\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eoverride\u003c/span\u003e \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003eopen\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econfig\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eConfiguration\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eUnit\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"c1\"\u003e// 3. Access the broadcast DataSet as a Collection\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e      \u003cspan class=\"n\"\u003ebroadcastSet\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003egetRuntimeContext\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003egetBroadcastVariable\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e](\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;broadcastSetName\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003easScala\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eString\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}).\u003c/span\u003e\u003cspan class=\"n\"\u003ewithBroadcastSet\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etoBroadcast\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;broadcastSetName\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 2. Broadcast the DataSet\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在注册和访问广播数据集时，确保名称（前面例子中的 \u003ccode\u003ebroadcastSetName\u003c/code\u003e）匹配。关于完整的示例程序，可以看一下 \u003ca href=\"https://github.com/apache/flink/blob/master//flink-examples/flink-examples-batch/src/main/scala/org/apache/flink/examples/scala/clustering/KMeans.scala\"\u003eKMeans 算法\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e注意：由于广播变量的内容在每个节点上都保存在内存中，所以它不应该变得太大。对于像标量值这样简单的东西，你可以简单地将参数作为函数闭包的一部分，或者使用 \u003ccode\u003ewithParameters(...)\u003c/code\u003e 方法来传递配置。\u003c/p\u003e\n\u003ch2 id=\"分布式缓存\"\u003e分布式缓存\u003c/h2\u003e\n\u003cp\u003eFlink 提供了一个类似于 Apache Hadoop 的分布式缓存，以使用户函数的并行实例可以在本地访问文件。该功能可用于共享包含静态外部数据的文件，如字典或机器学习的回归模型。\u003c/p\u003e\n\u003cp\u003e缓存的工作原理如下。程序在其 \u003ccode\u003eExecutionEnvironment\u003c/code\u003e 中以特定的名称将\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/connectors.html#reading-from-file-systems\"\u003e本地或远程文件系统（如 HDFS 或 S3）\u003c/a\u003e的文件或目录注册为缓存文件。当程序执行时，Flink 会自动将该文件或目录复制到所有工作者的本地文件系统中。用户函数可以查找指定名称下的文件或目录，并从工作者的本地文件系统中访问它。\u003c/p\u003e\n\u003cp\u003e分布式缓存的使用方法如下。\u003c/p\u003e\n\u003cp\u003e在 \u003ccode\u003eExecutionEnvironment\u003c/code\u003e 中注册文件或目录。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eExecutionEnvironment\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetExecutionEnvironment\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// register a file from HDFS\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eregisterCachedFile\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;hdfs:///path/to/your/file\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;hdfsFile\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// register a local executable file (script, executable, ...)\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eregisterCachedFile\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;file:///path/to/exec/file\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;localExecFile\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// define your program and execute\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eDataSet\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eInteger\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eMyMapper\u003c/span\u003e\u003cspan class=\"o\"\u003e())\u003c/span\u003e\n\u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eexecute\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在一个用户函数（这里是 MapFunction）中访问缓存文件。该函数必须扩展一个 RichFunction 类，因为它需要访问 RuntimeContext。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"c1\"\u003e// extend a RichFunction to have access to the RuntimeContext\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMyMapper\u003c/span\u003e \u003cspan class=\"k\"\u003eextends\u003c/span\u003e \u003cspan class=\"nc\"\u003eRichMapFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eString\u003c/span\u003e, \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\n  \u003cspan class=\"k\"\u003eoverride\u003c/span\u003e \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003eopen\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econfig\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eConfiguration\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eUnit\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// access cached file via RuntimeContext and DistributedCache\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003emyFile\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eFile\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003egetRuntimeContext\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetDistributedCache\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetFile\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;hdfsFile\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// read the file (or navigate the directory)\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\n  \u003cspan class=\"k\"\u003eoverride\u003c/span\u003e \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// use content of cached file\n\u003c/span\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"o\"\u003e...\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"向函数传递参数\"\u003e向函数传递参数\u003c/h2\u003e\n\u003cp\u003e可以使用构造函数或 \u003ccode\u003ewithParameters(Configuration)\u003c/code\u003e 方法将参数传递给函数。参数会被序列化为函数对象的一部分，并传送给所有并行任务实例。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e通过构造函数\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003etoFilter\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efromElements\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003etoFilter\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efilter\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eMyFilter\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMyFilter\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elimit\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eextends\u003c/span\u003e \u003cspan class=\"nc\"\u003eFilterFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"k\"\u003eoverride\u003c/span\u003e \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003efilter\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eBoolean\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003evalue\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003elimit\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e通过 withParameters(配置)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e本方法以一个 Configuration 对象作为参数，它将被传递给\u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/user_defined_functions.html#rich-functions\"\u003e富函数\u003c/a\u003e的 \u003ccode\u003eopen()\u003c/code\u003e 方法。配置对象是一个从 String 键到不同值类型的 Map。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003etoFilter\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efromElements\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eConfiguration\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esetInteger\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;limit\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003etoFilter\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efilter\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eRichFilterFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e]()\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003elimit\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eoverride\u003c/span\u003e \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003eopen\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econfig\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eConfiguration\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eUnit\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"n\"\u003elimit\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003econfig\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetInteger\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;limit\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"n\"\u003efilter\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ein\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"k\"\u003e:\u003c/span\u003e \u003cspan class=\"kt\"\u003eBoolean\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ein\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003elimit\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}).\u003c/span\u003e\u003cspan class=\"n\"\u003ewithParameters\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e在全局范围内通过 ExecutionConfig\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eFlink 还允许将自定义配置值传递到环境的 ExecutionConfig 接口。由于执行配置可以在所有（丰富的）用户函数中访问，因此自定义配置将在所有函数中全局可用。\u003c/p\u003e\n\u003cp\u003e设置一个自定义的全局配置：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003eenv\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"nc\"\u003eExecutionEnvironment\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetExecutionEnvironment\u003c/span\u003e\n\u003cspan class=\"k\"\u003eval\u003c/span\u003e \u003cspan class=\"n\"\u003econf\u003c/span\u003e \u003cspan class=\"k\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eConfiguration\u003c/span\u003e\u003cspan class=\"o\"\u003e()\u003c/span\u003e\n\u003cspan class=\"n\"\u003econf\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esetString\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;mykey\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;myvalue\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"n\"\u003eenv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egetConfig\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esetGlobalJobParameters\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econf\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e请注意，你也可以传递一个扩展 \u003ccode\u003eExecutionConfig.GlobalJobParameters\u003c/code\u003e 类的自定义类作为全局作业参数给执行配置。该接口允许实现 \u003ccode\u003eMap\u0026lt;String, String\u0026gt; toMap()\u003c/code\u003e 方法，该方法将在 web 前端显示来自配置的值。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e从全局配置中访问值\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e全局工作参数中的对象在系统中的很多地方都可以访问。所有实现 RichFunction 接口的用户函数都可以通过运行时上下文访问。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kd\"\u003estatic\u003c/span\u003e \u003cspan class=\"kd\"\u003efinal\u003c/span\u003e \u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eTokenizer\u003c/span\u003e \u003cspan class=\"kd\"\u003eextends\u003c/span\u003e \u003cspan class=\"n\"\u003eRichFlatMapFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eTuple2\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eInteger\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\n    \u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e \u003cspan class=\"n\"\u003eString\u003c/span\u003e \u003cspan class=\"n\"\u003emykey\u003c/span\u003e\u003cspan class=\"o\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"nd\"\u003e@Override\u003c/span\u003e\n    \u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eopen\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eConfiguration\u003c/span\u003e \u003cspan class=\"n\"\u003eparameters\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"kd\"\u003ethrows\u003c/span\u003e \u003cspan class=\"n\"\u003eException\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"kd\"\u003esuper\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eopen\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eparameters\u003c/span\u003e\u003cspan class=\"o\"\u003e);\u003c/span\u003e\n      \u003cspan class=\"n\"\u003eExecutionConfig\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eGlobalJobParameters\u003c/span\u003e \u003cspan class=\"n\"\u003eglobalParams\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003egetRuntimeContext\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"na\"\u003egetExecutionConfig\u003c/span\u003e\u003cspan class=\"o\"\u003e().\u003c/span\u003e\u003cspan class=\"na\"\u003egetGlobalJobParameters\u003c/span\u003e\u003cspan class=\"o\"\u003e();\u003c/span\u003e\n      \u003cspan class=\"n\"\u003eConfiguration\u003c/span\u003e \u003cspan class=\"n\"\u003eglobConf\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eConfiguration\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eglobalParams\u003c/span\u003e\u003cspan class=\"o\"\u003e;\u003c/span\u003e\n      \u003cspan class=\"n\"\u003emykey\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eglobConf\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003egetString\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;mykey\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"o\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// ... more here ...\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e原文链接: \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/\"\u003ehttps://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/\u003c/a\u003e\u003c/p\u003e\n","text":"Flink DataSet API 编程指南 Flink 中的数据集程序是对数据集实现转换（如过滤、映射、加入、分组）的常规程序。数据集最初是从某些来源创建的（例如，通过读取文件，或从本地集合中创建）。结果通过汇返回，例如可以将数据写入（分布式）文件，或标准输出（例如命令行终端）。Flink 程序可以在各种环境下运行，独立运行，或者嵌入其他程序中。执行可以发生在本地 JVM 中，也可以发生在许多机器的集群中。\n请参考 DataStream API 概述，了解 Flink API 的基本概念。该概述是针对 DataStream API 的，但这两个 API 的基本概念是一样的。\n为了创建你自己的 Flink DataSet 程序，我们鼓励你从 Flink 程序的骨架开始，并逐步添加你自己的转换。其余部分作为附加操作和高级功能的参考。\n程序示例 下面的程序是一个完整的、可以使用的 WordCount 的例子，你可以复制和粘贴代码在本地运行。你可以复制和粘贴代码在本地运行它。你只需要在你的项目中加入正确的 Flink 的库（参见与 Flink 的链接部分）并指定导入。然后你就可以开始了\nimport org.apache.flink.api.scala._ object WordCount { def main(args: Array[String]) { val env = ExecutionEnvironment.getExecutionEnvironment val text = env.fromElements( \u0026#34;Who\u0026#39;s there?\u0026#34;, \u0026#34;I think I hear them. Stand, ho! Who\u0026#39;s there?\u0026#34;) val counts = text.flatMap { _.toLowerCase.split(\u0026#34;\\\\W+\u0026#34;) filter { _.nonEmpty } } .map { (_, 1) } .groupBy(0) .sum(1) counts.print() } } DataSet 转换 数据转换将一个或多个 DataSet 转换为一个新的 DataSet。程序可以将多个转换组合成复杂的集合。\n本节简要介绍了可用的转换。转换文档中有所有变换的完整描述和示例。\n Map  接受一个元素，产生一个元素。\ndata.map { x =\u0026gt; x.toInt }  FlatMap  接受一个元素并产生零、一个或多个元素。\ndata.flatMap { str =\u0026gt; str.split(\u0026#34; \u0026#34;) }  MapPartition  在一个函数调用中转换一个并行分区。该函数以\u0026quot;迭代器\u0026quot;的形式获取分区，并可产生任意数量的结果值。每个分区的元素数量取决于平行度和之前的操作。\ndata.mapPartition { in =\u0026gt; in map { (_, 1) } }  Filter  对每个元素进行布尔函数评估，并保留那些函数返回真的元素。 重要：系统假设函数不会修改应用谓词的元素。违反这个假设会导致错误的结果。\ndata.filter { _ \u0026gt; 1000 }  Reduce  通过重复将两个元素合并为一个元素，将一组元素合并为一个元素。换算可以应用于一个完整的数据集，也可以应用于一个分组的数据集。\ndata.reduce { _ + _ }  ReduceGroup  将一组元素合并成一个或多个元素。ReduceGroup 可以应用在一个完整的数据集上，也可以应用在一个分组的数据集上。\ndata.reduceGroup { elements =\u0026gt; elements.sum }  Aggregate  将一组值聚合成一个值。Aggregation 函数可以被认为是内置的 reduce 函数。Aggregate 可以应用于一个完整的数据集，也可以应用于一个分组的数据集。\nval input: DataSet[(Int, String, Double)] = // [...] val output: DataSet[(Int, String, Double)] = input.aggregate(SUM, 0).aggregate(MIN, 2) 你也可以使用简写语法来进行 minimum, maximum 和 sum 的聚合。\nval input: DataSet[(Int, String, Double)] = // [...] val output: DataSet[(Int, String, Double)] = input.sum(0).min(2)  Distinct  返回数据集的不同元素。它从输入的 DataSet 中删除元素的所有字段或字段子集的重复条目。\ndata.distinct()  Join  通过创建所有键值相等的元素对来连接两个数据集。可以选择使用 JoinFunction 将一对元素变成一个元素，或者使用 FlatJoinFunction 将一对元素变成任意多个（包括无）元素。请参阅键部分了解如何定义连接键。\n// In this case tuple fields are used as keys. \u0026#34;0\u0026#34; is the join field on the first tuple // \u0026#34;1\u0026#34; is the join field on the second tuple. val result = input1.join(input2).where(0).equalTo(1) 你可以通过 Join Hints 指定运行时执行连接的方式。这些提示描述了连接是通过分区还是广播进行的，以及它是使用基于排序还是基于散列的算法。请参考转换指南，了解可能的提示列表和示例。 如果没有指定提示，系统将尝试对输入大小进行估计，并根据这些估计选择最佳策略。\n// This executes a join by broadcasting the first data set // using a hash table for the broadcast data val result = input1.join(input2, JoinHint.BROADCAST_HASH_FIRST) .where(0).equalTo(1) 请注意，连接转换只适用于等价连接。其他的连接类型需要使用 OuterJoin 或 CoGroup 来表达。\n OuterJoin  在两个数据集上执行左联接、右联接或完全外联接。外联接与常规（内联接）类似，创建所有键值相同的元素对。此外，如果在另一侧没有找到匹配的键，\u0026ldquo;外侧\u0026quot;的记录（左、右或全联接时两者都有）将被保留。匹配的元素对（或一个元素和另一个输入的 null 值）被交给 JoinFunction 将这对元素变成单个元素，或交给 FlatJoinFunction 将这对元素变成任意多个（包括无）元素。请参阅键部分，了解如何定义连接键。\nval joined = left.leftOuterJoin(right).where(0).equalTo(1) { (left, right) =\u0026gt; val a = if (left == null) \u0026#34;none\u0026#34; else left._1 (a, right) }  CoGroup  减少操作的二维变体。在一个或多个字段上对每个输入进行分组，然后将分组合并。每一对组都会调用转换函数。请参阅键部分，了解如何定义 coGroup 键。\ndata1.coGroup(data2).where(0).equalTo(1)  Cross  建立两个输入的笛卡尔乘积（交叉乘积），创建所有元素对。可选择使用交叉函数将一对元素变成一个单一元素。\nval data1: DataSet[Int] = // [...] val data2: DataSet[String] = // [...] val result: DataSet[(Int, String)] = data1.cross(data2) 注意：Cross 可能是一个非常耗费计算的操作，甚至可以挑战大型计算集群！建议使用 crossWithTiny() 和 crossWithHuge() 来提示系统数据集的大小。\n  Union\n  产生两个数据集的并集。\n  data.union(data2)  Rebalance  均匀地重新平衡数据集的并行分区，以消除数据倾斜。只有类似于 Map 的变换才可以跟随重新平衡(rebalance)变换。\nval data1: DataSet[Int] = // [...] val result: DataSet[(Int, String)] = data1.rebalance().map(...)  Hash-Partition  在给定的键上对数据集进行散列分区。键可以被指定为位置键、表达式键和键选择函数。\nval in: DataSet[(Int, String)] = // [...] val result = in.partitionByHash(0).mapPartition { ... }  Range-Partition  在给定的键上按照范围分割数据集。键可以被指定为位置键、表达式键和键选择函数。\nval in: DataSet[(Int, String)] = // [...] val result = in.partitionByRange(0).mapPartition { ... }  自定义分区  使用自定义的 Partitioner 函数，根据键将记录分配到特定的分区。键可以指定为位置键、表达式键和键选择函数。 注意：此方法仅适用于单个字段键。\nval in: DataSet[(Int, String)] = // [...] val result = in .partitionCustom(partitioner, key).mapPartition { ... }  Sort Partition  按照指定的顺序对数据集的所有分区进行本地排序。字段可以指定为元组位置或字段表达式。对多个字段的排序是通过链式 sortPartition() 调用完成的。\nval in: DataSet[(Int, String)] = // [...] val result = in.sortPartition(1, Order.ASCENDING).mapPartition { ... }  First-n  返回一个数据集的前 n 个（任意）元素。First-n 可以应用于一个常规数据集、一个分组数据集或一个分组排序数据集。分组键可以指定为键选择函数、元组位置或 case 类字段。\nval in: DataSet[(Int, String)] = // [...] // regular data set val result1 = in.first(3) // grouped data set val result2 = in.groupBy(0).first(3) // grouped-sorted data set val result3 = in.groupBy(0).sortGroup(1, Order.ASCENDING).first(3) 以下转换可用于元组的数据集。\n MinBy / MaxBy  从一组元组中选择一个元组，这些元组的一个或多个字段的值是最小的（最大的）。用于比较的字段必须是有效的键字段，即可比较。如果多个元组具有最小（最大）字段值，则返回这些元组的任意元组。MinBy (MaxBy)可以应用于一个完整的数据集或一个分组数据集。\nval in: DataSet[(Int, Double, String)] = // [...] // a data set with a single tuple with minimum values for the Int and String fields. val out: DataSet[(Int, Double, String)] = in.minBy(0, 2) // a data set with one tuple for each group with the minimum value for the Double field. val out2: DataSet[(Int, Double, String)] = in.groupBy(2) .minBy(1) 通过匿名模式匹配从 tuple、case 类和集合中提取，比如下面。\nval data: DataSet[(Int, String, Double)] = // [...] data.map { case (id, name, temperature) =\u0026gt; // [...] } 不受 API 开箱即用的支持。要使用这个功能，你应该使用 Scala API 扩展。\n变换的并行度可以通过 setParallelism(int) 来定义，而 name(String) 可以给变换指定一个自定义的名称，这对调试很有帮助。数据源和数据接收器也是如此。\nwithParameters(Configuration) 传递 Configuration 对象，这些对象可以从用户函数里面的 open() 方法访问。\n指定键 一些转换（join、coGroup、groupBy）需要在元素集合上定义一个键。其他转换（Reduce、GroupReduce、Aggregate）允许在应用之前将数据按键分组。\n一个 DataSet 被分组为：\nDataSet\u0026lt;...\u0026gt; input = // [...] DataSet\u0026lt;...\u0026gt; reduced = input .groupBy(/*define key here*/) .reduceGroup(/*do something*/); Flink 的数据模型不是基于键值对的。因此，你不需要将数据集类型物理地打包成键和值。键是\u0026quot;虚拟的\u0026rdquo;：它们被定义为实际数据上的函数，以指导分组操作符。\n为元组定义键 最简单的情况是对 Tuple 的一个或多个字段进行分组。\nval input: DataSet[(Int, String, Long)] = // [...] val keyed = input.groupBy(0) 元组在第一个字段（整数类型的字段）上进行分组。\nval input: DataSet[(Int, String, Long)] = // [...] val grouped = input.groupBy(0,1) 在这里，我们将元组放在一个由第一个字段和第二个字段组成的复合键上。\n关于嵌套 Tuple 的说明。如果你的 DataSet 有一个嵌套的元组，比如：\nDataSet\u0026lt;Tuple3\u0026lt;Tuple2\u0026lt;Integer, Float\u0026gt;,String,Long\u0026gt;\u0026gt; ds; 指定 groupBy(0) 将使系统使用完整的 Tuple2 作为键（以 Integer 和 Float 为键）。如果要\u0026quot;导航\u0026quot;到嵌套的 Tuple2 中，就必须使用字段表达式键，下面将对其进行说明。\n使用字段表达式定义键 你可以使用基于字符串的字段表达式来引用嵌套的字段，并为分组、排序、连接(join)或 coGrouping 定义键。\n字段表达式可以非常容易地选择（嵌套的）复合类型中的字段，如 Tuple 和 POJO 类型。\n在下面的例子中，我们有一个有两个字段 \u0026ldquo;word\u0026rdquo; 和 \u0026ldquo;count\u0026rdquo; 的 WC POJO。要按字段 word 进行分组，我们只需将其名称传递给 groupBy() 函数。\n// some ordinary POJO (Plain old Java Object) class WC(var word: String, var count: Int) { def this() { this(\u0026#34;\u0026#34;, 0L) } } val words: DataSet[WC] = // [...] val wordCounts = words.groupBy(\u0026#34;word\u0026#34;) // or, as a case class, which is less typing case class WC(word: String, count: Int) val words: DataSet[WC] = // [...] val wordCounts = words.groupBy(\u0026#34;word\u0026#34;) 字段表达式语法   通过字段名选择 POJO 字段。例如 \u0026ldquo;user\u0026rdquo; 指的是 POJO 类型的 \u0026ldquo;user\u0026rdquo; 字段。\n  通过 1-offset 字段名或 0-offset 字段索引来选择 Tuple 字段。例如 \u0026ldquo;_1\u0026rdquo; 和 \u0026ldquo;5\u0026rdquo; 分别指 Scala Tuple 类型的第一和第六字段。\n  你可以在 POJO 和 Tuple 中选择嵌套字段。例如 \u0026ldquo;user.zip\u0026rdquo; 指的是 POJO 的 \u0026ldquo;zip\u0026rdquo; 字段，它存储在 POJO 类型的 \u0026ldquo;user\u0026rdquo; 字段中。支持 POJO 和 Tuple 的任意嵌套和混合，如 \u0026ldquo;_2.user.zip\u0026rdquo; 或 \u0026ldquo;user._4.1.zip\u0026rdquo;。\n你可以使用 \u0026ldquo;_\u0026rdquo; 通配符表达式选择完整的类型。这也适用于不是 Tuple 或 POJO 类型的类型。\n字段表达式示例:\nclass WC(var complex: ComplexNestedClass, var count: Int) { def this() { this(null, 0) } } class ComplexNestedClass( var someNumber: Int, someFloat: Float, word: (Long, Long, String), hadoopCitizen: IntWritable) { def this() { this(0, 0, (0, 0, \u0026#34;\u0026#34;), new IntWritable(0)) } } 这些都是上面例子代码的有效字段表达式。\n  \u0026ldquo;count\u0026rdquo;: WC 类中的计数字段\n  \u0026ldquo;complex\u0026rdquo;: 递归选择 POJO 类型 ComplexNestedClass 的 complex 字段的所有字段。\n  \u0026ldquo;complex.word._3\u0026rdquo;: 选择嵌套的 Tuple3 的最后一个字段。\n  \u0026ldquo;complex.hadoopCitizen\u0026rdquo;: 选择 Hadoop IntWritable 类型。\n  使用键选择函数定义键 另一种定义键的方法是\u0026quot;键选择器\u0026quot;函数。键选择器函数将一个元素作为输入，并返回该元素的键。键可以是任何类型的，并且可以从确定性计算中得到。\n下面的例子显示了一个简单返回对象字段的键选择函数。\n// some ordinary case class case class WC(word: String, count: Int) val words: DataSet[WC] = // [...] val keyed = words.groupBy( _.word ) 数据源 数据源创建初始数据集，例如从文件或 Java 集合中创建。创建数据集的一般机制是在 InputFormat 后面抽象出来的。Flink 自带了几种内置的格式来从常见的文件格式创建数据集。其中许多格式在 ExecutionEnvironment 上有快捷方法。\n基于文件的:\n  readTextFile(path) / TextInputFormat - 读取文件并以字符串形式返回。\n  readTextFileWithValue(path) / TextValueInputFormat - 以行的方式读取文件并以 StringValues 的形式返回。StringValues 是可变字符串。\n  readCsvFile(path) / CsvInputFormat - 解析以逗号（或其他字符）分隔的文件。返回一个由 tuple、case 类对象或 POJOs 组成的 DataSet。支持基本的 java 类型及其对应的 Value 类型作为字段类型。\n  readFileOfPrimitives(path, delimiter) / PrimitiveInputFormat - 使用给定的定界符，解析新行（或其他字符序列）定界的基元数据类型的文件，如 String 或 Integer。\n  readSequenceFile(Key, Value, path) / SequenceFileInputFormat - 创建一个 JobConf 并从指定的路径读取文件，文件类型为 SequenceFileInputFormat，Key 类和 Value 类，并以 Tuple2\u0026lt;Key, Value\u0026gt; 的形式返回。\n  基于集合的:\n  fromCollection(Iterable) - 从一个 Iterable 创建一个数据集。Iterable 返回的所有元素必须是相同的类型。\n  fromCollection(Iterator) - 从一个 Iterator 创建一个数据集。该类指定了迭代器返回的元素的数据类型。\n  fromElements(elements: _*) - 从给定的对象序列中创建一个数据集。所有对象必须是相同的类型。\n  fromParallelCollection(SplittableIterator) - 从迭代器中并行创建一个数据集。该类指定了迭代器返回的元素的数据类型。\n  generateSequence(from, to) - 在给定的区间内并行生成数字序列。\n  通用的:\n  readFile(inputFormat, path) / FileInputFormat - 接受一个文件输入格式。\n  createInput(inputFormat) / InputFormat - 接受一个通用的输入格式。\n  示例:\nval env = ExecutionEnvironment.getExecutionEnvironment // read text file from local files system val localLines = env.readTextFile(\u0026#34;file:///path/to/my/textfile\u0026#34;) // read text file from an HDFS running at nnHost:nnPort val hdfsLines = env.readTextFile(\u0026#34;hdfs://nnHost:nnPort/path/to/my/textfile\u0026#34;) // read a CSV file with three fields val csvInput = env.readCsvFile[(Int, String, Double)](\u0026#34;hdfs:///the/CSV/file\u0026#34;) // read a CSV file with five fields, taking only two of them val csvInput = env.readCsvFile[(String, Double)]( \u0026#34;hdfs:///the/CSV/file\u0026#34;, includedFields = Array(0, 3)) // take the first and the fourth field  // CSV input can also be used with Case Classes case class MyCaseClass(str: String, dbl: Double) val csvInput = env.readCsvFile[MyCaseClass]( \u0026#34;hdfs:///the/CSV/file\u0026#34;, includedFields = Array(0, 3)) // take the first and the fourth field  // read a CSV file with three fields into a POJO (Person) with corresponding fields val csvInput = env.readCsvFile[Person]( \u0026#34;hdfs:///the/CSV/file\u0026#34;, pojoFields = Array(\u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;zipcode\u0026#34;)) // create a set from some given elements val values = env.fromElements(\u0026#34;Foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;foobar\u0026#34;, \u0026#34;fubar\u0026#34;) // generate a number sequence val numbers = env.generateSequence(1, 10000000) // read a file from the specified path of type SequenceFileInputFormat val tuples = env.createInput(HadoopInputs.readSequenceFile(classOf[IntWritable], classOf[Text], \u0026#34;hdfs://nnHost:nnPort/path/to/file\u0026#34;)) 配置 CSV 解析 Flink 为 CSV 解析提供了许多配置选项。\n  lineDelimiter: 字符串指定单个记录的定界符。默认的行定界符是新行字符 '/n'。\n  fieldDelimiter: 字符串指定分隔记录字段的定界符。默认的字段定界符是逗号字符 ','。\n  includeFields: Array[Int] 定义从输入文件中读取哪些字段（以及忽略哪些字段）。默认情况下，前 n 个字段（由 type() 调用中的类型数定义）会被解析。\n  pojoFields: Array[String] 指定 POJO 的字段，这些字段被映射到 CSV 字段。CSV 字段的解析器会根据 POJO 字段的类型和顺序自动初始化。\n  parseQuotedStrings: 启用引号字符串解析的字符。如果字符串字段的第一个字符是引号字符，那么字符串将被解析为引号字符串（前导或尾部的空白不被修剪）。引号字符串中的字段定界符会被忽略。如果引号字符串字段的最后一个字符不是引号字符，则引号字符串解析失败。如果启用了引号字符串解析，且字段的第一个字符不是引号字符串，则该字符串将被解析为未引号字符串。默认情况下，引号字符串解析被禁用。\n  ignoreComments: 字符串指定一个注解前缀。所有以指定注解前缀开始的行都不会被解析和忽略。默认情况下，没有行被忽略。\n  lenient：布尔值，启用宽松解析。也就是说，不能正确解析的行会被忽略。默认情况下，禁用宽松解析，无效行会引发异常。\n  ignoreFirstLine: Boolean 配置 InputFormat 忽略输入文件的第一行。默认情况下，没有行被忽略。\n  Input Path 的递归遍历 对于基于文件的输入，当输入路径是一个目录时，默认情况下不会枚举嵌套文件。取而代之的是，只读取基础目录内的文件，而忽略嵌套文件。嵌套文件的递归枚举可以通过 recursive.file.enumeration 配置参数启用，就像下面的例子。\n// enable recursive enumeration of nested input files val env = ExecutionEnvironment.getExecutionEnvironment // create a configuration object val parameters = new Configuration // set the recursive enumeration parameter parameters.setBoolean(\u0026#34;recursive.file.enumeration\u0026#34;, true) // pass the configuration to the data source env.readTextFile(\u0026#34;file:///path/with.nested/files\u0026#34;).withParameters(parameters) 读取压缩文件 Flink 目前支持输入文件的透明解压，如果这些文件被标记为适当的文件扩展名。特别是，这意味着无需进一步配置输入格式，任何 FileInputFormat 都支持压缩，包括自定义输入格式。请注意，压缩文件可能不会被并行读取，从而影响作业的可扩展性。\n下表列出了当前支持的压缩方法。\n   压缩方法 文件后缀 并行性     DEFLATE .deflate no   GZip .gz, .gzip no   Bzip2 .bz2 no   XZ .xz no    数据接收器 数据接收器消费 DataSet 并用于存储或返回它们。数据接收器的操作是用 OutputFormat 来描述的。Flink 带有各种内置的输出格式，这些格式被封装在对 DataSet 的操作后面。\n writeAsText() / TextOutputFormat \u0026ndash;将元素逐行写成 Strings。通过调用每个元素的 toString() 方法获得字符串。 writeAsCsv(...) / CsvOutputFormat - 将元组写成逗号分隔的值文件。行和字段定界符是可配置的。每个字段的值来自对象的 toString() 方法。 print() / printToErr() - 在标准输出/标准错误流上打印每个元素的 toString() 值。 write() / FileOutputFormat - 用于自定义文件输出的方法和基类。支持自定义对象到字节的转换。 output()/ OutputFormat - 最通用的输出方法，用于非基于文件的数据接收器（如将结果存储在数据库中）。  一个 DataSet 可以被输入到多个操作中。程序可以写入或打印一个数据集，同时还可以对其进行额外的转换。\n示例\n标准数据接收器方法:\n// text data val textData: DataSet[String] = // [...]  // write DataSet to a file on the local file system textData.writeAsText(\u0026#34;file:///my/result/on/localFS\u0026#34;) // write DataSet to a file on an HDFS with a namenode running at nnHost:nnPort textData.writeAsText(\u0026#34;hdfs://nnHost:nnPort/my/result/on/localFS\u0026#34;) // write DataSet to a file and overwrite the file if it exists textData.writeAsText(\u0026#34;file:///my/result/on/localFS\u0026#34;, WriteMode.OVERWRITE) // tuples as lines with pipe as the separator \u0026#34;a|b|c\u0026#34; val values: DataSet[(String, Int, Double)] = // [...] values.writeAsCsv(\u0026#34;file:///path/to/the/result/file\u0026#34;, \u0026#34;\\n\u0026#34;, \u0026#34;|\u0026#34;) // this writes tuples in the text formatting \u0026#34;(a, b, c)\u0026#34;, rather than as CSV lines values.writeAsText(\u0026#34;file:///path/to/the/result/file\u0026#34;) // this writes values as strings using a user-defined formatting values map { tuple =\u0026gt; tuple._1 + \u0026#34; - \u0026#34; + tuple._2 } .writeAsText(\u0026#34;file:///path/to/the/result/file\u0026#34;) 本地排序输出 数据接收器的输出可以使用元组字段位置或字段表达式对指定字段按指定顺序进行本地排序。这适用于每一种输出格式。\n下面的示例展示了如何使用该功能。\nval tData: DataSet[(Int, String, Double)] = // [...] val pData: DataSet[(BookPojo, Double)] = // [...] val sData: DataSet[String] = // [...]  // sort output on String field in ascending order tData.sortPartition(1, Order.ASCENDING).print() // sort output on Double field in descending and Int field in ascending order tData.sortPartition(2, Order.DESCENDING).sortPartition(0, Order.ASCENDING).print() // sort output on the \u0026#34;author\u0026#34; field of nested BookPojo in descending order pData.sortPartition(\u0026#34;_1.author\u0026#34;, Order.DESCENDING).writeAsText(...) // sort output on the full tuple in ascending order tData.sortPartition(\u0026#34;_\u0026#34;, Order.ASCENDING).writeAsCsv(...) // sort atomic type (String) output in descending order sData.sortPartition(\u0026#34;_\u0026#34;, Order.DESCENDING).writeAsText(...) 目前还不支持全局排序输出。\n迭代运算符 迭代在 Flink 程序中实现了循环。迭代运算符封装了程序的一部分，并反复执行，将一次迭代的结果（部分解）反馈到下一次迭代中。Flink 中的迭代有两种类型。BulkIteration 和 DeltaIteration。\n本节提供了如何使用这两种运算符的快速示例。查看迭代介绍页面可以获得更详细的介绍。\n批量迭代 要创建一个 BulkIteration，调用迭代开始的 DataSet 的 iterate(int) 方法，同时指定一个 step 函数。step 函数获取当前迭代的输入 DataSet，并且必须返回一个新的 DataSet。迭代调用的参数是最大的迭代次数，迭代过后要停止。\n还有 iterateWithTermination(int) 函数，接受 step 函数，返回两个 DataSets。迭代步骤的结果和一个终止标准。一旦终止准则 DataSet 为空，就会停止迭代。\n下面的例子是迭代估计数字 Pi。目标是计算随机点的数量，这些随机点落入单位圆中。在每一次迭代中，都会挑选一个随机点。如果这个点位于单位圆内，我们就递增计数。然后，Pi 的估计值是所得到的计数除以迭代次数乘以 4。\nval env = ExecutionEnvironment.getExecutionEnvironment() // Create initial DataSet val initial = env.fromElements(0) val count = initial.iterate(10000) { iterationInput: DataSet[Int] =\u0026gt; val result = iterationInput.map { i =\u0026gt; val x = Math.random() val y = Math.random() i + (if (x * x + y * y \u0026lt; 1) 1 else 0) } result } val result = count map { c =\u0026gt; c / 10000.0 * 4 } result.print() env.execute(\u0026#34;Iterative Pi Example\u0026#34;) 你也可以查看 K-Means 的例子，它使用 BulkIteration 来聚类一组未标记的点。\n增量迭代 增量迭代利用了某些算法在每次迭代中不改变解的每个数据点的事实。\n除了在每次迭代中反馈的部分解（称为 workset），delta 迭代还保持着跨迭代的状态（称为解集），可以通过 delta 更新。迭代计算的结果是最后一次迭代后的状态。关于 delta 迭代的基本原理，请参考迭代简介。\n定义 DeltaIteration 与定义 BulkIteration 类似。对于 delta 迭代，两个数据集构成了每次迭代的输入（工作集和解集），并且在每次迭代中产生两个数据集作为结果（新工作集，解集 delta）。\n要创建一个 DeltaIteration 在初始解集上调用 iterateDelta(initialWorkset，maxIterations，key)。step 函数需要两个参数。(solutionSet, workset), 并且必须返回两个值: (solutionSetDelta, newWorkset).\n下面是一个 delta 迭代语法的例子。\n// read the initial data sets val initialSolutionSet: DataSet[(Long, Double)] = // [...]  val initialWorkset: DataSet[(Long, Double)] = // [...]  val maxIterations = 100 val keyPosition = 0 val result = initialSolutionSet.iterateDelta(initialWorkset, maxIterations, Array(keyPosition)) { (solution, workset) =\u0026gt; val candidateUpdates = workset.groupBy(1).reduceGroup(new ComputeCandidateChanges()) val deltas = candidateUpdates.join(solution).where(0).equalTo(0)(new CompareChangesToCurrent()) val nextWorkset = deltas.filter(new FilterByThreshold()) (deltas, nextWorkset) } result.writeAsCsv(outputPath) env.execute() 在函数中对数据对象进行操作 Flink 的运行时以 Java 对象的形式与用户函数交换数据。函数从运行时接收输入对象作为方法参数，并返回输出对象作为结果。因为这些对象是由用户函数和运行时代码访问的，所以理解和遵循用户代码如何访问，即读取和修改这些对象的规则是非常重要的。\n用户函数以常规方法参数（如 MapFunction）或通过 Iterable 参数（如 GroupReduceFunction）从 Flink 的运行时接收对象。我们把运行时传递给用户函数的对象称为输入对象。用户函数可以将对象作为方法返回值（像 MapFunction）或通过 Collector（像 FlatMapFunction）发射给 Flink 运行时。我们将用户函数向运行时发射的对象称为输出对象。\nFlink 的 DataSet API 具有两种模式，它们在 Flink 的运行时如何创建或重用输入对象方面有所不同。这种行为会影响用户函数如何与输入和输出对象交互的保证和约束。下面的章节定义了这些规则，并给出了编写安全用户函数代码的编码指南。\n禁用对象重用(DEFAULT) 默认情况下，Flink 在禁用对象重用模式下运行。这种模式可以保证函数在函数调用中总是接收新的输入对象。对象重用禁用模式能提供更好的保证，使用起来也更安全。但是，它有一定的处理开销，可能会引起较高的 Java 垃圾收集活动。下表解释了在禁用对象重用模式下，用户函数如何访问输入和输出对象。\n   操作 保证和限制     读取输入对象 在一个方法调用中，保证输入对象的值不会改变。这包括由 Iterable 服务的对象。例如，在 List 或 Map 中收集由 Iterable 服务的输入对象是安全的。请注意，在方法调用离开后，对象可能会被修改。跨函数调用记忆对象是不安全的。   修改输入对象 你可以修改输入对象。   发射输入对象 你可以发射输入对象。输入对象的值可能在发射后发生变化。读取发射后的输入对象是不安全的。   读取输出对象 给予收集器的对象或作为方法结果返回的对象可能已经改变了其值。读取输出对象是不安全的。   修改输出对象 你可以在对象被发射后对其进行修改，然后再次发射。    对象重用禁用（默认）模式的编码准则。\n 不要跨方法调用记忆和读取输入对象。 不要在发出对象后读取对象。  启用对象重用 在启用对象重用模式下，Flink 的运行时会尽量减少对象实例化的数量。这可以提高性能，并且可以减少 Java 垃圾收集的压力。通过调用 ExecutionConfig.enableObjectReuse() 激活对象重用启用模式。下表解释了在启用对象重用模式下，用户函数如何访问输入和输出对象。\n   操作 保证和限制     读取作为常规方法参数接收的输入对象 作为常规方法参数接收的输入对象在一次函数调用中不被修改。对象可能在方法调用结束后被修改。跨函数调用记忆对象是不安全的。   读取从 Iterable 参数中接收到的输入对象 从 Iterable 中接收到的输入对象只在调用 next()方法之前有效。一个 Iterable 或 Iterator 可以多次服务于同一个对象实例。记住从 Iterable 接收的输入对象是不安全的，例如，把它们放在 List 或 Map 中。   修改输入对象 除了 MapFunction、FlatMapFunction、MapPartitionFunction、GroupReduceFunction、GroupCombineFunction、CoGroupFunction 和 InputFormat.next(reuse)的输入对象外，你不得修改输入对象。   发射输入对象 除了 MapFunction、FlatMapFunction、MapPartitionFunction、GroupReduceFunction、GroupCombineFunction、CoGroupFunction 和 InputFormat.next(重用)的输入对象外，你不得发射输入对象。   读取输出对象 一个被交给 Collector 或作为方法结果返回的对象可能已经改变了它的值。读取输出对象是不安全的。   修改输出对象 你可以修改一个输出对象并再次发出它。    启用对象重用的编码准则。\n 不记忆从 Iterable 接收的输入对象。 不记忆和读取跨方法调用的输入对象。 除了 MapFunction、FlatMapFunction、MapPartitionFunction、GroupReduceFunction、GroupCombineFunction、CoGroupFunction 和 InputFormat.next(reuse)的输入对象外，不要修改或发出输入对象。 为了减少对象实例化，你总是可以发出一个专门的输出对象，这个对象被反复修改，但从不读取。  调试 在分布式集群中的大型数据集上运行数据分析程序之前，最好确保所实现的算法能够按照预期的方式运行。因此，实现数据分析程序通常是一个检查结果、调试和改进的渐进过程。\nFlink 提供了一些不错的功能，通过支持 IDE 内的本地调试、注入测试数据和收集结果数据，大大简化了数据分析程序的开发过程。本节给大家一些提示，如何简化 Flink 程序的开发。\n本地执行环境 LocalEnvironment 在它创建的同一个 JVM 进程中启动 Flink 系统。如果你从 IDE 中启动 LocalEnvironment，你可以在代码中设置断点，轻松调试你的程序。\nLocalEnvironment 的创建和使用方法如下。\nval env = ExecutionEnvironment.createLocalEnvironment() val lines = env.readTextFile(pathToTextFile) // build your program  env.execute() 收集数据源和接收器 为分析程序提供输入并检查其输出，如果通过创建输入文件和读取输出文件来完成，是很麻烦的。Flink 具有特殊的数据源和接收器，这些数据源和接收器由 Java 集合支持，以方便测试。一旦程序经过测试，源和接收器可以很容易地被从 HDFS 等外部数据存储中读取/写入的源和接收器所替代。\n集合数据源可以使用以下方式。\nval env = ExecutionEnvironment.createLocalEnvironment() // Create a DataSet from a list of elements val myInts = env.fromElements(1, 2, 3, 4, 5) // Create a DataSet from any Collection val data: Seq[(String, Int)] = ... val myTuples = env.fromCollection(data) // Create a DataSet from an Iterator val longIt: Iterator[Long] = ... val myLongs = env.fromCollection(longIt) 注：目前，集合数据源要求数据类型和迭代器实现 Serializable。此外，集合数据源不能并行执行（ parallelism = 1）。\n语义注解 语义注解可以用来给 Flink 提供关于函数行为的提示。它们告诉系统，函数读取并评估了函数输入的哪些字段，以及它将哪些字段从输入转发到输出，而没有进行修改。语义注解是加快执行速度的有力手段，因为它们允许系统推理出在多个操作中重复使用排序顺序或分区的问题。使用语义注解最终可能会使程序免于不必要的数据洗牌或不必要的排序，并显著提高程序的性能。\n注意：语义注解的使用是可选的。然而，在提供语义注解时，保守地使用语义注解是绝对关键的! 不正确的语义注解将导致 Flink 对你的程序做出不正确的假设，并可能最终导致不正确的结果。如果一个操作符的行为不是明确可预测的，就不应该提供注解。请仔细阅读文档。\n目前支持以下语义注解。\n转发字段注解\n转发字段信息声明了未被修改的输入字段被函数转发到输出中的同一位置或另一位置。该信息被优化器用来推断数据属性（如排序或分区）是否被函数保留。对于对输入元素组进行操作的函数，如 GroupReduce、GroupCombine、CoGroup 和 MapPartition，所有被定义为转发字段的字段必须总是从同一个输入元素联合转发。由组智函数发出的每个元素的转发字段可能来源于函数的输入组的不同元素。\n字段转发信息使用字段表达式来指定。在输出中转发到同一位置的字段可以通过其位置来指定。指定的位置必须对输入和输出的数据类型有效，并具有相同的类型。例如字符串 \u0026ldquo;f2 \u0026ldquo;声明 Java 输入元组的第三个字段总是等于输出元组中的第三个字段。\n将输入中的源字段和输出中的目标字段指定为字段表达式，就可以声明未修改的字段转发到输出中的另一个位置。字符串 \u0026quot;f0-\u0026gt;f2\u0026quot; 表示将 Java 输入元组的第一个字段不变的复制到 Java 输出元组的第三个字段。通配符表达式 * 可以用来指代整个输入或输出类型，即 \u0026quot;f0-\u0026gt;*\u0026quot; 表示一个函数的输出总是等于其 Java 输入元组的第一个字段。\n多个转发字段可以在一个字符串中用分号隔开声明为 \u0026quot;f0; f2-\u0026gt;f1; f3-\u0026gt;f2\u0026quot;，也可以在单独的字符串中声明为 \u0026ldquo;f0\u0026rdquo;、\u0026ldquo;f2-\u0026gt;f1\u0026rdquo;、\u0026ldquo;f3-\u0026gt;f2\u0026rdquo;。当指定转发字段时，不要求所有的转发字段都声明，但所有的声明必须正确。\n转发字段信息可以通过在函数类定义上附加 Java 注解来声明，或者在调用 DataSet 上的函数后将其作为操作符参数传递，如下图所示。\n函数类注解\n @ForwardedFields 用于单输入的函数，如 Map 和 Reduce。 @ForwardedFieldsFirst 代表有两个输入的函数的第一个输入，如 Join 和 CoGroup。 @ForwardedFieldsSecond 代表有两个输入的函数的第二个输入，如 Join 和 CoGroup。  操作符参数\n data.map(myMapFnc).withForwardedFields() 用于单输入的函数，如 Map 和 Reduce。 data1.join(data2).where().equalTo().with(myJoinFnc).withForwardFieldsFirst() 用于有两个输入的函数的第一个输入，如 Join 和 CoGroup。 data1.join(data2).where().equalTo().with(myJoinFnc).withForwardFieldsSecond() 用于有两个输入的函数的第二个输入，如 Join 和 CoGroup。  请注意，不可能覆盖通过操作符参数指定为类注解的字段前向信息。\n例子：在函数的第二个输入端，如 Join 和 CoGroup，请注意不能覆盖通过运算符参数指定的类注解的字段前向信息。\n下面的例子显示了如何使用函数类注解来声明转发的字段信息。\n@ForwardedFields(\u0026#34;_1-\u0026gt;_3\u0026#34;) class MyMap extends MapFunction[(Int, Int), (String, Int, Int)]{ def map(value: (Int, Int)): (String, Int, Int) = { return (\u0026#34;foo\u0026#34;, value._2 / 2, value._1) } } 非转发字段\n非转发字段信息声明了所有在函数输出中不保留在同一位置的字段。所有其他字段的值都被认为保留在输出的同一位置。因此，非转发字段信息与转发字段信息是相反的。分组运算符（如 GroupReduce、GroupCombine、CoGroup 和 MapPartition）的非转发字段信息必须满足与转发字段信息相同的要求。\n重要：非转发字段信息的规范是可选的。但是如果使用，必须指定 ALL! 非转发字段，因为所有其他字段都被认为是原地转发的。将一个转发字段声明为非转发字段是安全的。\n非转发字段被指定为字段表达式的列表。这个列表既可以是由分号分隔的字段表达式组成的单个字符串，也可以是多个字符串。例如 \u0026ldquo;f1; f3\u0026rdquo; 和 \u0026ldquo;f1\u0026rdquo;、\u0026ldquo;f3\u0026rdquo; 都声明 Java 元组的第二个和第四个字段不保留在原地，其他所有字段都保留在原地。非前向字段信息只能为输入和输出类型相同的函数指定。\n非转发字段信息是作为函数类注解使用以下注解来指定的。\n @NonForwardedFields 用于单个输入函数，如 Map 和 Reduce。 @NonForwardedFieldsFirst 用于有两个输入的函数的第一个输入，如 Join 和 CoGroup。 @NonForwardedFieldsSecond 用于函数的第二个输入，如 Join 和 CoGroup。  例子\n下面的例子显示了如何声明非转发字段信息。\n@NonForwardedFields(\u0026#34;_2\u0026#34;) // second field is not forwarded class MyMap extends MapFunction[(Int, Int), (Int, Int)]{ def map(value: (Int, Int)): (Int, Int) = { return (value._1, value._2 / 2) } } 读取字段\n读取字段信息声明了所有被函数访问和评估的字段，也就是说，所有被函数用来计算结果的字段。例如，在条件语句中被评估的字段或用于计算的字段必须在指定读取字段信息时被标记为读取。仅仅是未经修改就转发到输出而不评估其值的字段，或者根本没有被访问的字段都不被认为是读。\n重要：读取字段信息的指定是可选的。但是如果使用，必须指定 ALL! 读取字段。将一个非读字段声明为读字段是安全的。\n读取字段被指定为字段表达式的列表。这个列表可以是一个由分号分隔的字段表达式组成的单个字符串，也可以是多个字符串。例如 \u0026ldquo;f1; f3\u0026rdquo; 和 \u0026ldquo;f1\u0026rdquo;、\u0026ldquo;f3\u0026rdquo; 都声明 Java 元组的第二和第四字段被函数读取和评估。\n读取字段信息是以函数类注解的形式指定的，使用以下注解。\n @ReadFields 用于单输入函数，如 Map 和 Reduce。 @ReadFieldsFirst 用于有两个输入的函数的第一个输入，如 Join 和 CoGroup。 @ReadFieldsSecond 用于有两个输入的函数的第二个输入，如 Join 和 CoGroup。  示例：\n下面的例子显示了如何声明读取字段信息。\n@ReadFields(\u0026#34;_1; _4\u0026#34;) // _1 and _4 are read and evaluated by the function. class MyMap extends MapFunction[(Int, Int, Int, Int), (Int, Int)]{ def map(value: (Int, Int, Int, Int)): (Int, Int) = { if (value._1 == 42) { return (value._1, value._2) } else { return (value._4 + 10, value._2) } } } 广播变量 广播变量允许你在操作的常规输入之外，将一个数据集提供给操作的所有并行实例。这对辅助数据集或数据依赖性参数化很有用。然后，该数据集将作为一个集合在操作者处被访问。\n 广播：广播集通过 withBroadcastSet(DataSet，String) 按名称注册，并通过 访问方式：通过目标操作者处的 getRuntimeContext().getBroadcastVariable(String) 访问。  // 1. The DataSet to be broadcast val toBroadcast = env.fromElements(1, 2, 3) val data = env.fromElements(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;) data.map(new RichMapFunction[String, String]() { var broadcastSet: Traversable[String] = null override def open(config: Configuration): Unit = { // 3. Access the broadcast DataSet as a Collection  broadcastSet = getRuntimeContext().getBroadcastVariable[String](\u0026#34;broadcastSetName\u0026#34;).asScala } def map(in: String): String = { ... } }).withBroadcastSet(toBroadcast, \u0026#34;broadcastSetName\u0026#34;) // 2. Broadcast the DataSet 在注册和访问广播数据集时，确保名称（前面例子中的 broadcastSetName）匹配。关于完整的示例程序，可以看一下 KMeans 算法。\n注意：由于广播变量的内容在每个节点上都保存在内存中，所以它不应该变得太大。对于像标量值这样简单的东西，你可以简单地将参数作为函数闭包的一部分，或者使用 withParameters(...) 方法来传递配置。\n分布式缓存 Flink 提供了一个类似于 Apache Hadoop 的分布式缓存，以使用户函数的并行实例可以在本地访问文件。该功能可用于共享包含静态外部数据的文件，如字典或机器学习的回归模型。\n缓存的工作原理如下。程序在其 ExecutionEnvironment 中以特定的名称将本地或远程文件系统（如 HDFS 或 S3）的文件或目录注册为缓存文件。当程序执行时，Flink 会自动将该文件或目录复制到所有工作者的本地文件系统中。用户函数可以查找指定名称下的文件或目录，并从工作者的本地文件系统中访问它。\n分布式缓存的使用方法如下。\n在 ExecutionEnvironment 中注册文件或目录。\nval env = ExecutionEnvironment.getExecutionEnvironment // register a file from HDFS env.registerCachedFile(\u0026#34;hdfs:///path/to/your/file\u0026#34;, \u0026#34;hdfsFile\u0026#34;) // register a local executable file (script, executable, ...) env.registerCachedFile(\u0026#34;file:///path/to/exec/file\u0026#34;, \u0026#34;localExecFile\u0026#34;, true) // define your program and execute ... val input: DataSet[String] = ... val result: DataSet[Integer] = input.map(new MyMapper()) ... env.execute() 在一个用户函数（这里是 MapFunction）中访问缓存文件。该函数必须扩展一个 RichFunction 类，因为它需要访问 RuntimeContext。\n// extend a RichFunction to have access to the RuntimeContext class MyMapper extends RichMapFunction[String, Int] { override def open(config: Configuration): Unit = { // access cached file via RuntimeContext and DistributedCache  val myFile: File = getRuntimeContext.getDistributedCache.getFile(\u0026#34;hdfsFile\u0026#34;) // read the file (or navigate the directory)  ... } override def map(value: String): Int = { // use content of cached file  ... } } 向函数传递参数 可以使用构造函数或 withParameters(Configuration) 方法将参数传递给函数。参数会被序列化为函数对象的一部分，并传送给所有并行任务实例。\n通过构造函数\nval toFilter = env.fromElements(1, 2, 3) toFilter.filter(new MyFilter(2)) class MyFilter(limit: Int) extends FilterFunction[Int] { override def filter(value: Int): Boolean = { value \u0026gt; limit } } 通过 withParameters(配置)\n本方法以一个 Configuration 对象作为参数，它将被传递给富函数的 open() 方法。配置对象是一个从 String 键到不同值类型的 Map。\nval toFilter = env.fromElements(1, 2, 3) val c = new Configuration() c.setInteger(\u0026#34;limit\u0026#34;, 2) toFilter.filter(new RichFilterFunction[Int]() { var limit = 0 override def open(config: Configuration): Unit = { limit = config.getInteger(\u0026#34;limit\u0026#34;, 0) } def filter(in: Int): Boolean = { in \u0026gt; limit } }).withParameters(c) 在全局范围内通过 ExecutionConfig\nFlink 还允许将自定义配置值传递到环境的 ExecutionConfig 接口。由于执行配置可以在所有（丰富的）用户函数中访问，因此自定义配置将在所有函数中全局可用。\n设置一个自定义的全局配置：\nval env = ExecutionEnvironment.getExecutionEnvironment val conf = new Configuration() conf.setString(\u0026#34;mykey\u0026#34;, \u0026#34;myvalue\u0026#34;) env.getConfig.setGlobalJobParameters(conf) 请注意，你也可以传递一个扩展 ExecutionConfig.GlobalJobParameters 类的自定义类作为全局作业参数给执行配置。该接口允许实现 Map\u0026lt;String, String\u0026gt; toMap() 方法，该方法将在 web 前端显示来自配置的值。\n从全局配置中访问值\n全局工作参数中的对象在系统中的很多地方都可以访问。所有实现 RichFunction 接口的用户函数都可以通过运行时上下文访问。\npublic static final class Tokenizer extends RichFlatMapFunction\u0026lt;String, Tuple2\u0026lt;String, Integer\u0026gt;\u0026gt; { private String mykey; @Override public void open(Configuration parameters) throws Exception { super.open(parameters); ExecutionConfig.GlobalJobParameters globalParams = getRuntimeContext().getExecutionConfig().getGlobalJobParameters(); Configuration globConf = (Configuration) globalParams; mykey = globConf.getString(\u0026#34;mykey\u0026#34;, null); } // ... more here ... 原文链接: https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/\n"},"name":"Flink Dataset API 编程指南","published":"2020-08-22T00:00:00Z","summary":"Flink Dataset Api Programming Guide","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-08-22-flink-dataset-api-programming-guide/"}],"name":"Guide","type":"feed","url":"https://ohmyweekly.github.io/tags/guide/"}