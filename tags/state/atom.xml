<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.63.2">Hugo</generator><title type="html"><![CDATA[State on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/state/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/state/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/state/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/state/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2020-10-04T12:40:59+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/state/</id>
    
        
        <entry>
            <title type="html"><![CDATA[使用状态]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-21-working-with-state/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-event-time/?utm_source=atom_feed" rel="related" type="text/html" title="Event Time" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-flink-datastream-api-programming-guide/?utm_source=atom_feed" rel="related" type="text/html" title="Flink Datastream API 编程指南" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-generating-watermarks/?utm_source=atom_feed" rel="related" type="text/html" title="Generating Watermarks" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-built-in-watermark-generators/?utm_source=atom_feed" rel="related" type="text/html" title="内置的水印生成器" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-state-and-fault-tolerance/?utm_source=atom_feed" rel="related" type="text/html" title="状态和容错性" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-21-working-with-state/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-21T00:00:00+08:00</published>
            <updated>2020-08-21T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Working With State</blockquote><h2 id="使用状态httpsciapacheorgprojectsflinkflink-docs-release-111devstreamstatestatehtml"><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html">使用状态</a></h2>
<p>在本节中，您将了解 Flink 为编写有状态程序提供的 API。请看 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html">Stateful Stream Processing</a> 来了解有状态流处理背后的概念。</p>
<h3 id="keyed-datastream">Keyed DataStream</h3>
<p>如果要使用 keyed state，首先需要在 DataStream 上指定一个键，这个键应该用来分隔(partition)状态（也包括流中的记录本身）。你可以在 DataStream 上使用 <code>keyBy(KeySelector)</code> 指定一个键。这将产生一个 <code>KeyedDataStream</code>，然后允许使用 keyed state 的操作。</p>
<p>键选择函数将一条记录作为输入，并返回该记录的键。键可以是任何类型的，并且必须从确定性计算中导出。</p>
<p>Flink 的数据模型不是基于键值对的。因此，您不需要将数据集类型物理地打包成键和值。键是&quot;虚拟&quot;的：它们被定义为实际数据上的函数，以指导分组操作符。</p>
<p>下面的例子显示了一个键选择函数，它只是返回对象的字段。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// 普通的 case 类
</span><span class="c1"></span><span class="k">case</span> <span class="k">class</span> <span class="nc">WC</span><span class="o">(</span><span class="n">word</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="k">val</span> <span class="n">words</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">WC</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// [...]
</span><span class="c1"></span><span class="k">val</span> <span class="n">keyed</span> <span class="k">=</span> <span class="n">words</span><span class="o">.</span><span class="n">keyBy</span><span class="o">(</span> <span class="k">_</span><span class="o">.</span><span class="n">word</span> <span class="o">)</span>
</code></pre></div><h4 id="元组键和表达式键">元组键和表达式键</h4>
<p>Flink 还有两种定义键的方法：元组键和表达式键。有了它，你可以使用元组字段索引或表达式来指定键，用于选择对象的字段。我们今天不推荐使用这些，但你可以参考 DataStream 的 Javadoc 来了解它们。严格来说，使用 <code>KeySelector</code> 函数更胜一筹：使用 Java lambdas，它们很容易使用，而且它们在运行时的开销可能更少。</p>
<h3 id="使用-keyed-state">使用 Keyed State</h3>
<p>keyed State 接口提供了对不同类型的状态的访问，这些状态的作用域都是当前输入元素的键。这意味着，这种类型的状态只能在 <code>KeyedStream</code> 上使用，它可以通过 <code>stream.keyBy(...)</code> 来创建。</p>
<p>现在，我们将首先看看不同类型的状态有哪些，然后我们会看看如何在程序中使用它们。可用的状态原语有:</p>
<ul>
<li>
<p><code>ValueState&lt;T&gt;</code>：它保留了一个可更新和检索的值（如上所述，作用域为输入元素的键，因此操作符所看到的每个键都可能有一个值）。这个值可以使用 <code>update(T)</code> 来设置，也可以使用 <code>T value()</code> 来检索。</p>
</li>
<li>
<p><code>ListState&lt;T&gt;</code>：这保存了一个元素列表。你可以在所有当前存储的元素上追加元素和检索一个 <code>Iterable</code>。使用 <code>add(T)</code> 或 <code>addAll(List&lt;T&gt;)</code> 添加元素，可以使用 <code>Iterable&lt;T&gt; get()</code> 检索 <code>Iterable</code>。你也可以用 <code>update(List&lt;T&gt;)</code> 覆盖现有的列表。</p>
</li>
<li>
<p><code>ReducingState&lt;T&gt;</code>: 这保留了一个单一的值，代表所有添加到状态的值的集合。该接口类似于 <code>ListState</code>，但使用 <code>add(T)</code> 添加的元素会使用指定的 <code>ReduceFunction</code> 被化简成一个总计。</p>
</li>
<li>
<p><code>AggregatingState&lt;IN，OUT&gt;</code>：这保留了一个单一的值，代表所有添加到状态的值的聚合。与 <code>ReducingState</code> 相反，<code>aggregate</code> 类型可能与添加到状态中的元素类型不同。接口与 <code>ListState</code> 相同，但使用 <code>add(IN)</code> 添加的元素会使用指定的 <code>AggregateFunction</code> 进行聚合。</p>
</li>
<li>
<p><code>MapState&lt;UK, UV&gt;</code>: 它保存了一个映射列表。你可以将键值对放入状态中，并在所有当前存储的映射上检索一个 <code>Iterable</code>。使用 <code>put(UK, UV)</code> 或 <code>putAll(Map&lt;UK, UV&gt;)</code> 可以添加映射。与用户键相关联的值可以使用 <code>get(UK)</code> 来检索。可以分别使用 <code>entries()</code>、<code>keys()</code> 和 <code>values()</code> 检索映射、键和值的可迭代视图。你也可以使用 <code>isEmpty()</code> 来检查这个映射是否包含任何键值映射。</p>
</li>
</ul>
<p>所有类型的状态也都有一个方法 <code>clear()</code>，可以清除当前活动键的状态，也就是输入元素的键。</p>
<p>需要注意的是，这些状态对象只用于带状态的接口。状态不一定存储在里面，而可能驻留在磁盘或其他地方。第二件要记住的事情是，你从状态中得到的值取决于输入元素的键。因此，如果所涉及的键不同，你在用户函数的一次调用中得到的值可能与另一次调用中的值不同。</p>
<p>为了得到一个状态句柄，你必须创建一个 <code>StateDescriptor</code>。这里面包含了状态的名称(我们稍后会看到，你可以创建多个状态，而且它们必须有独特的名称，这样你才能引用它们)，状态所拥有的值的类型，可能还有一个用户指定的函数，比如 <code>ReduceFunction</code>。根据你要检索的状态类型，你可以创建一个 <code>ValueStateDescriptor</code>、一个 <code>ListStateDescriptor</code>、一个 <code>ReducingStateDescriptor</code> 或一个 <code>MapStateDescriptor</code>。</p>
<p>状态是使用 <code>RuntimeContext</code> 访问的，所以只有在富函数(<em>rich functions</em>)中才有可能。请看<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/user_defined_functions.html#rich-functions">这里</a>了解相关信息，但我们也会很快看到一个例子。<code>RichFunction</code> 中可用的 <code>RuntimeContext</code> 有这些方法来访问状态。</p>
<ul>
<li>ValueState<!-- raw HTML omitted --> getState(ValueStateDescriptor<!-- raw HTML omitted -->)</li>
<li>ReducingState<!-- raw HTML omitted --> getReducingState(ReducingStateDescriptor<!-- raw HTML omitted -->)</li>
<li>ListState<!-- raw HTML omitted --> getListState(ListStateDescriptor<!-- raw HTML omitted -->)</li>
<li>AggregatingState&lt;IN, OUT&gt; getAggregatingState(AggregatingStateDescriptor&lt;IN, ACC, OUT&gt;)</li>
<li>MapState&lt;UK, UV&gt; getMapState(MapStateDescriptor&lt;UK, UV&gt;)</li>
</ul>
<p>这是一个 <code>FlatMapFunction</code> 的例子，它展示了所有的部分是如何结合在一起的。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">CountWindowAverage</span> <span class="k">extends</span> <span class="nc">RichFlatMapFunction</span><span class="o">[</span><span class="o">(</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">)</span>, <span class="o">(</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">)</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">var</span> <span class="n">sum</span><span class="k">:</span> <span class="kt">ValueState</span><span class="o">[</span><span class="o">(</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="k">_</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">flatMap</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="o">(</span><span class="kt">Long</span><span class="o">,</span> <span class="kt">Long</span><span class="o">)</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[</span><span class="o">(</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">)</span><span class="o">]</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>

    <span class="c1">// 访问状态值
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">tmpCurrentSum</span> <span class="k">=</span> <span class="n">sum</span><span class="o">.</span><span class="n">value</span>

    <span class="c1">// 如果之前没有使用过，则为 null。
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">currentSum</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">tmpCurrentSum</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">tmpCurrentSum</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="o">(</span><span class="mi">0L</span><span class="o">,</span> <span class="mi">0L</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="c1">// 更新次数
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">newSum</span> <span class="k">=</span> <span class="o">(</span><span class="n">currentSum</span><span class="o">.</span><span class="n">_1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">currentSum</span><span class="o">.</span><span class="n">_2</span> <span class="o">+</span> <span class="n">input</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>

    <span class="c1">// 更新状态
</span><span class="c1"></span>    <span class="n">sum</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="n">newSum</span><span class="o">)</span>

    <span class="c1">// 如果计数达到2，则发出平均数，并清除状态。
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">newSum</span><span class="o">.</span><span class="n">_1</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">out</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">newSum</span><span class="o">.</span><span class="n">_2</span> <span class="o">/</span> <span class="n">newSum</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span><span class="o">)</span>
      <span class="n">sum</span><span class="o">.</span><span class="n">clear</span><span class="o">(</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">open</span><span class="o">(</span><span class="n">parameters</span><span class="k">:</span> <span class="kt">Configuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">sum</span> <span class="k">=</span> <span class="n">getRuntimeContext</span><span class="o">.</span><span class="n">getState</span><span class="o">(</span>
      <span class="k">new</span> <span class="nc">ValueStateDescriptor</span><span class="o">[</span><span class="o">(</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">)</span><span class="o">]</span><span class="o">(</span><span class="s">&#34;average&#34;</span><span class="o">,</span> <span class="n">createTypeInformation</span><span class="o">[</span><span class="o">(</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">)</span><span class="o">]</span><span class="o">)</span>
    <span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>


<span class="k">object</span> <span class="nc">ExampleCountWindowAverage</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

  <span class="n">env</span><span class="o">.</span><span class="n">fromCollection</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span>
    <span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="mi">3L</span><span class="o">)</span><span class="o">,</span>
    <span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="mi">5L</span><span class="o">)</span><span class="o">,</span>
    <span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="mi">7L</span><span class="o">)</span><span class="o">,</span>
    <span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="mi">4L</span><span class="o">)</span><span class="o">,</span>
    <span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="mi">2L</span><span class="o">)</span>
  <span class="o">)</span><span class="o">)</span><span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
    <span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="nc">CountWindowAverage</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="o">)</span>
  <span class="c1">// the printed output will be (1,4) and (1,5)
</span><span class="c1"></span>
  <span class="n">env</span><span class="o">.</span><span class="n">execute</span><span class="o">(</span><span class="s">&#34;ExampleKeyedState&#34;</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div><p>这个例子实现了一个穷人的计数窗口。我们用第一个字段对元组进行 keyed 操作（在本例中，所有元组都有相同的键 <code>1</code>）。该函数将计数和运行的总和存储在一个 <code>ValueState</code>  中。一旦计数达到 2，它就会发出平均数并清除状态，这样我们就可以从 0 开始。注意，如果我们在第一个字段中的元组具有不同的值，那么这将为每个不同的输入键保持不同的状态值。</p>
<h4 id="状态存活时间ttl">状态存活时间(TTL)</h4>
<p>可以为任何类型的 keyed state 分配一个生存时间（TTL）。如果配置了 TTL，并且状态值已经过期，存储的值将在尽力的基础上进行清理，这将在下面详细讨论。</p>
<p>所有状态集合类型都支持每个条目的 TTL。这意味着列表元素和映射条目独立过期。</p>
<p>为了使用状态 TTL，必须首先建立一个 <code>StateTtlConfig</code> 配置对象。然后可以通过传递配置在任何状态描述符中启用 TTL 功能。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.common.state.StateTtlConfig</span>
<span class="k">import</span> <span class="nn">org.apache.flink.api.common.state.ValueStateDescriptor</span>
<span class="k">import</span> <span class="nn">org.apache.flink.api.common.time.Time</span>

<span class="k">val</span> <span class="n">ttlConfig</span> <span class="k">=</span> <span class="nc">StateTtlConfig</span>
    <span class="o">.</span><span class="n">newBuilder</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">setUpdateType</span><span class="o">(</span><span class="nc">StateTtlConfig</span><span class="o">.</span><span class="nc">UpdateType</span><span class="o">.</span><span class="nc">OnCreateAndWrite</span><span class="o">)</span>
    <span class="o">.</span><span class="n">setStateVisibility</span><span class="o">(</span><span class="nc">StateTtlConfig</span><span class="o">.</span><span class="nc">StateVisibility</span><span class="o">.</span><span class="nc">NeverReturnExpired</span><span class="o">)</span>
    <span class="o">.</span><span class="n">build</span>
    
<span class="k">val</span> <span class="n">stateDescriptor</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ValueStateDescriptor</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="o">(</span><span class="s">&#34;text state&#34;</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="o">)</span>
<span class="n">stateDescriptor</span><span class="o">.</span><span class="n">enableTimeToLive</span><span class="o">(</span><span class="n">ttlConfig</span><span class="o">)</span>
</code></pre></div><p>配置有几个选项需要考虑。</p>
<p><code>newBuilder</code> 方法的第一个参数是强制性的，它是存活的时间值。</p>
<p>更新类型配置状态 TTL 何时被刷新（默认为 <code>OnCreateAndWrite</code>）。</p>
<ul>
<li>StateTtlConfig.UpdateType.OnCreateAndWrite - 仅在创建和写入访问时才会出现</li>
<li>StateTtlConfig.UpdateType.OnReadAndWrite - 也是在读的时候。</li>
</ul>
<p>状态可见性配置如果过期值尚未清理，是否在读取访问时返回（默认为 <code>NeverReturnExpired</code>）。</p>
<ul>
<li>StateTtlConfig.StateVisibility.NeverReturnExpired - 过期值永不返回</li>
<li>StateTtlConfig.StateVisibility.ReturnExpiredIfNotCleanedUp - 如果仍然可用则返回。</li>
</ul>
<p>在 <code>NeverReturnExpired</code> 的情况下，过期状态就像不存在一样，即使它仍然必须被删除。这个选项对于数据在 TTL 之后必须严格地成为不可读的访问状态的用例是很有用的，例如处理隐私敏感数据的应用程序。</p>
<p>另一个选项 <code>ReturnExpiredIfNotCleanedUp</code> 允许在清理之前返回过期状态。</p>
<p>注意:</p>
<ul>
<li>
<p>状态后端存储最后一次修改的时间戳和用户值，这意味着启用该功能会增加状态存储的消耗。Heap 状态后端在内存中存储了一个额外的 Java 对象，该对象有一个对用户状态对象的引用和一个原始的长值。RocksDB 状态后端每存储一个值、列表项或映射项增加8个字节。</p>
</li>
<li>
<p>目前只支持参考处理时间的 TTL。</p>
</li>
<li>
<p>试图使用启用 TTL 的描述符来恢复之前没有配置 TTL 的状态，或者反之，将导致兼容性失败和 <code>StateMigrationException</code>。</p>
</li>
<li>
<p>TTL 配置不是检查点或保存点的一部分，而是 Flink 在当前运行的作业中如何处理的一种方式。</p>
</li>
<li>
<p>带 TTL 的映射状态目前只有在用户值序列化器能够处理 null 值的情况下才支持 null 用户值。如果序列化器不支持空值，可以用 <code>NullableSerializer</code> 包装，代价是在序列化形式中多出一个字节。</p>
</li>
</ul>
<h4 id="过期状态的清理">过期状态的清理</h4>
<p>默认情况下，过期的值会在读取时显式删除，如 <code>ValueState#value</code>，如果配置的状态后台支持，则会定期在后台进行垃圾回收。后台清理可以在 <code>StateTtlConfig</code> 中禁用。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.common.state.StateTtlConfig</span>
<span class="k">val</span> <span class="n">ttlConfig</span> <span class="k">=</span> <span class="nc">StateTtlConfig</span>
    <span class="o">.</span><span class="n">newBuilder</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">disableCleanupInBackground</span>
    <span class="o">.</span><span class="n">build</span>
</code></pre></div><p>如果想对后台的一些特殊清理进行更精细的控制，可以按照下面的描述单独配置。目前，堆状态后台依靠增量清理，RocksDB 后台使用压实过滤器进行后台清理。</p>
<h5 id="全快照中的清理">全快照中的清理</h5>
<p>此外，您可以在拍摄完整状态快照的瞬间激活清理，这将减少其大小。在当前的实现下，本地状态不会被清理，但在从上一个快照恢复的情况下，它将不包括删除的过期状态。可以在 <code>StateTtlConfig</code> 中进行配置。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.common.state.StateTtlConfig</span>
<span class="k">import</span> <span class="nn">org.apache.flink.api.common.time.Time</span>

<span class="k">val</span> <span class="n">ttlConfig</span> <span class="k">=</span> <span class="nc">StateTtlConfig</span>
    <span class="o">.</span><span class="n">newBuilder</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">cleanupFullSnapshot</span>
    <span class="o">.</span><span class="n">build</span>
</code></pre></div><p>此选项不适用于 RocksDB 状态后端的增量检查点。</p>
<p><strong>注意:</strong></p>
<ul>
<li>对于现有的作业，这个清理策略可以在 <code>StateTtlConfig</code> 中随时激活或停用，例如从保存点重新启动后。</li>
</ul>
<h5 id="增量清理">增量清理</h5>
<p>另一种选择是逐步触发一些状态条目的清理。触发器可以是每次状态访问或/和每次记录处理的回调。如果这种清理策略对某些状态是激活的，存储后端就会为这个状态的所有条目保留一个惰性的全局迭代器。每次触发增量清理时，迭代器都会被提前。对遍历过的状态条目进行检查，对过期的条目进行清理。</p>
<p>这个功能可以在 <code>StateTtlConfig</code> 中配置。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.common.state.StateTtlConfig</span>
<span class="k">val</span> <span class="n">ttlConfig</span> <span class="k">=</span> <span class="nc">StateTtlConfig</span>
    <span class="o">.</span><span class="n">newBuilder</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">cleanupIncrementally</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
    <span class="o">.</span><span class="n">build</span>
</code></pre></div><p>这个策略有两个参数。第一个是每次清理触发的检查状态条目数。它总是在每次状态访问时触发。第二个参数定义是否在每次记录处理中额外触发清理。堆后端默认的后台清理每次记录处理检查5个条目而不进行清理。</p>
<p><strong>注意:</strong></p>
<ul>
<li>如果没有发生对状态的访问或者没有处理记录，过期状态将持续存在。</li>
<li>增量清理所花费的时间会增加记录处理的延迟。</li>
<li>目前，增量清理只在堆状态后端实现。对 RocksDB 的设置不会有影响。</li>
<li>如果堆状态后端与同步快照一起使用，全局迭代器在迭代的时候会保留所有键的副本，因为它的具体实现不支持并发修改。那么启用这个功能会增加内存消耗。异步快照则不存在这个问题。</li>
<li>对于现有的作业，这个清理策略可以在 <code>StateTtlConfig</code> 中随时激活或停用，例如从保存点重新启动后。</li>
</ul>
<h5 id="rocksdb-压缩过程中的清理">RocksDB 压缩过程中的清理</h5>
<p>如果使用 RocksDB 状态后端，将调用 Flink 特定的压实过滤器进行后台清理。RocksDB  会定期运行异步压实来合并状态更新，减少存储量。Flink 压实过滤器通过 TTL 检查状态条目的过期时间戳，排除过期值。</p>
<p>这个功能可以在 <code>StateTtlConfig</code> 中配置。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.api.common.state.StateTtlConfig</span>

<span class="k">val</span> <span class="n">ttlConfig</span> <span class="k">=</span> <span class="nc">StateTtlConfig</span>
    <span class="o">.</span><span class="n">newBuilder</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">cleanupInRocksdbCompactFilter</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>
    <span class="o">.</span><span class="n">build</span>
</code></pre></div><p>RocksDB 压实过滤器在处理一定数量的状态条目后，每次都会从 Flink 中查询当前的时间戳，用于检查过期情况，你可以改变它，并传递自定义值给 <code>StateTtlConfig.newBuilder(...).cleanupInRocksdbCompactFilter(long queryTimeAfterNumEntries)</code> 方法。更频繁地更新时间戳可以提高清理速度，但由于它使用了来自本地代码的 JNI 调用，因此降低了压缩性能。RocksDB 后台默认的清理方式是每次处理1000个条目后查询当前时间戳。</p>
<p>你可以通过激活 <code>FlinkCompactionFilter</code> 的调试级别来激活 RocksDB 过滤器原生代码的调试日志。</p>
<pre><code>log4j.logger.org.rocksdb.FlinkCompactionFilter=DEBUG
</code></pre><p><strong>注意:</strong></p>
<ul>
<li>在压实过程中调用 TTL 过滤器会使其速度减慢。TTL 过滤器必须解析最后一次访问的时间戳，并检查每个被压缩的键的存储状态条目的到期时间。如果是集合状态类型(list 或 map)，每个存储元素的检查也会被调用。</li>
<li>如果该功能用于具有非固定字节长度元素的列表状态，则原生 TTL 过滤器必须额外调用每个至少第一个元素已过期的状态条目中元素在 JNI 上的 Flink java 类型序列化器，以确定下一个未过期元素的偏移。</li>
<li>对于现有的作业，这种清理策略可以在 <code>StateTtlConfig</code> 中随时激活或停用，例如从保存点重新启动后。</li>
</ul>
<h3 id="scala-datastream-api-中的状态">Scala DataStream API 中的状态</h3>
<p>除了上面描述的接口外，Scala API 还为 KeyedStream 上具有单个 <code>ValueState</code> 的有状态 <code>map()</code> 或 <code>flatMap()</code> 函数提供了快捷方式。用户函数在 <code>Option</code> 中获取 <code>ValueState</code> 的当前值，并且必须返回一个更新的值，该值将用于更新状态。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">stream</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="k">val</span> <span class="n">counts</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="n">stream</span>
  <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
  <span class="o">.</span><span class="n">mapWithState</span><span class="o">(</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">count</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span> <span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">in</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span> <span class="o">)</span>
      <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="o">(</span> <span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span> <span class="o">)</span>
    <span class="o">}</span><span class="o">)</span>
</code></pre></div><h3 id="operator-state">Operator State</h3>
<p>Operator State（或 non-keyed state）是指绑定到一个并行操作符实例的状态。<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/connectors/kafka.html">Kafka 连接器</a>是 Flink 中使用 Operator State 的一个很好的激励例子。Kafka 消费者的每个并行实例都维护着一个主题分区和偏移的映射作为其 Operator State。</p>
<p>Operator State 接口支持在并行操作符实例之间重新分配状态，当并行性发生变化时。有不同的方案来进行这种重新分配。</p>
<p>在典型的有状态的 Flink 应用中，你不需要操作符状态。它主要是一种特殊类型的状态，用于源/接收器实现和你没有键的情况下，可以通过它来分隔状态。</p>
<h3 id="广播状态">广播状态</h3>
<p>Broadcast State 是 Operator State 的一种特殊类型。引入它是为了支持这样的用例：一个流的记录(records)需要被广播到所有下游任务，它们被用来在所有子任务中保持相同的状态。然后在处理第二个流的记录时可以访问这个状态。作为一个广播状态可以自然出现的例子，我们可以想象一个低吞吐量的流，其中包含一组规则，我们希望对来自另一个流的所有元素进行评估。考虑到上述类型的用例，广播状态与其余运算符状态的不同之处在于。</p>
<ul>
<li>它有一个 map 格式。</li>
<li>它只适用于有广播流和非广播流作为输入的特定操作符，以及</li>
<li>这样的操作符可以拥有多个不同名称的广播状态。</li>
</ul>
<h3 id="使用-operator-state">使用 Operator State</h3>
<p>要使用运算符状态，有状态函数可以实现 <code>CheckpointedFunction</code> 接口。</p>
<h4 id="checkpointedfunction">CheckpointedFunction</h4>
<p><code>CheckpointedFunction</code> 接口提供了对不同重分配方案的 non-keyed 的访问。它需要实现两个方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">void</span> <span class="nf">snapshotState</span><span class="o">(</span><span class="n">FunctionSnapshotContext</span> <span class="n">context</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">;</span>

<span class="kt">void</span> <span class="nf">initializeState</span><span class="o">(</span><span class="n">FunctionInitializationContext</span> <span class="n">context</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">;</span>
</code></pre></div><p>每当需要执行一个检查点时，就会调用 <code>snapshotState()</code>。与之对应的 <code>initializeState()</code>，在每次用户定义的函数被初始化时都会被调用，不管是在函数首次初始化时，还是在函数实际从早期的检查点恢复时。鉴于此，<code>initializeState()</code> 不仅是初始化不同类型状态的地方，也是包含状态恢复逻辑的地方。</p>
<p>目前，支持列表式操作符状态。状态有望成为一个可序列化对象的 <code>List</code>，彼此独立，因此在重新缩放时有资格重新分配。换句话说，这些对象是 non-keyed state 可以重新分配的最细粒度。根据状态访问方法的不同，定义了以下重分布方案。</p>
<ul>
<li>
<p>均分重分配: 每个操作符都会返回一个状态元素列表。整个状态在逻辑上是所有列表的连接(concatenation)。在还原/再分配时，列表被平均分成有多少个并行操作符就有多少个子列表。每个操作符都会得到一个子列表，这个子列表可以是空的，也可以包含一个或多个元素。举个例子，如果在并行度为1的情况下，一个操作符的检查点状态包含元素1和元素2，当把并行度增加到2时，元素1可能最终进入操作符实例0，而元素2将进入操作符实例1。</p>
</li>
<li>
<p>联盟再分配。每个操作符都会返回一个状态元素列表。整个状态在逻辑上是所有 <code>List</code> 的连接(concatenation)。在还原/再分配时，每个操作符都会得到完整的状态元素列表。如果你的列表可能有很高的基数(cardinality)，请不要使用这个功能。检查点元数据将为每个列表条目存储一个偏移，这可能会导致 RPC 帧大小或内存外错误。</p>
</li>
</ul>
<p>下面是一个有状态的 <code>SinkFunction</code> 的例子，它使用 <code>CheckpointedFunction</code> 来缓冲元素，然后再将它们发送到外界。它演示了基本的均分重分配列表状态。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">BufferingSink</span><span class="o">(</span><span class="n">threshold</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">SinkFunction</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span>
    <span class="k">with</span> <span class="nc">CheckpointedFunction</span> <span class="o">{</span>

  <span class="nd">@transient</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">checkpointedState</span><span class="k">:</span> <span class="kt">ListState</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="k">_</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">bufferedElements</span> <span class="k">=</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span><span class="o">(</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">invoke</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span><span class="o">,</span> <span class="n">context</span><span class="k">:</span> <span class="kt">Context</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">bufferedElements</span> <span class="o">+=</span> <span class="n">value</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">bufferedElements</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">threshold</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">element</span> <span class="k">&lt;-</span> <span class="n">bufferedElements</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// send it to the sink
</span><span class="c1"></span>      <span class="o">}</span>
      <span class="n">bufferedElements</span><span class="o">.</span><span class="n">clear</span><span class="o">(</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">snapshotState</span><span class="o">(</span><span class="n">context</span><span class="k">:</span> <span class="kt">FunctionSnapshotContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">checkpointedState</span><span class="o">.</span><span class="n">clear</span><span class="o">(</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">element</span> <span class="k">&lt;-</span> <span class="n">bufferedElements</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">checkpointedState</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">element</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">initializeState</span><span class="o">(</span><span class="n">context</span><span class="k">:</span> <span class="kt">FunctionInitializationContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">descriptor</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListStateDescriptor</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span><span class="o">(</span>
      <span class="s">&#34;buffered-elements&#34;</span><span class="o">,</span>
      <span class="nc">TypeInformation</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="k">new</span> <span class="nc">TypeHint</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span><span class="o">}</span><span class="o">)</span>
    <span class="o">)</span>

    <span class="n">checkpointedState</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">getOperatorStateStore</span><span class="o">.</span><span class="n">getListState</span><span class="o">(</span><span class="n">descriptor</span><span class="o">)</span>

    <span class="k">if</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">isRestored</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">for</span><span class="o">(</span><span class="n">element</span> <span class="k">&lt;-</span> <span class="n">checkpointedState</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">bufferedElements</span> <span class="o">+=</span> <span class="n">element</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><p><code>initializeState</code> 方法的参数是一个 <code>FunctionInitializationContext</code>。它用于初始化 non-keyed &ldquo;容器&rdquo;。这些容器是一个 <code>ListState</code> 类型的容器，在检查点时，non-keyed 对象将被存储在那里。</p>
<p>请注意如何初始化状态，类似于 keyed state，用一个 <code>StateDescriptor</code> 来初始化，这个 <code>StateDescriptor</code> 包含了状态名称和状态所持有的值的类型信息。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">descriptor</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListStateDescriptor</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Long</span><span class="o">)</span><span class="o">]</span><span class="o">(</span>
    <span class="s">&#34;buffered-elements&#34;</span><span class="o">,</span>
    <span class="nc">TypeInformation</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="k">new</span> <span class="nc">TypeHint</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Long</span><span class="o">)</span><span class="o">]</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span><span class="o">}</span><span class="o">)</span>
<span class="o">)</span>

<span class="n">checkpointedState</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">getOperatorStateStore</span><span class="o">.</span><span class="n">getListState</span><span class="o">(</span><span class="n">descriptor</span><span class="o">)</span>
</code></pre></div><p>状态访问方法的命名约定包含其重分配模式，然后是其状态结构。例如，如果要在还原时使用 union 重分配方案的列表状态，则使用 <code>getUnionListState(descriptor)</code> 访问状态。如果方法名中不包含重分配模式，例如 <code>getListState(descriptor)</code>，则仅仅意味着将使用基本的均分重分配方案。</p>
<p>在初始化容器后，我们使用上下文的 <code>isRestored()</code> 方法来检查是否在故障后恢复。如果为真，即我们正在恢复，则应用还原逻辑。</p>
<p>如修改后的 <code>BufferingSink</code> 的代码所示，在状态初始化过程中恢复的这个 <code>ListState</code> 被保存在一个类变量中，以便将来在 <code>snapshotState()</code> 中使用。在那里，<code>ListState</code> 会被清除掉之前检查点所包含的所有对象，然后用我们要检查点的新对象来填充。</p>
<p>顺便说一下， keyed state 也可以在 <code>initializeState()</code> 方法中初始化。这可以使用提供的 <code>FunctionInitializationContext</code> 来完成。</p>
<h3 id="有状态的源函数">有状态的源函数</h3>
<p>与其他操作符相比，有状态的源需要更多的小心。为了使状态和输出集合的更新是原子性的（对于失败/恢复时的精确一次性语义来说是必需的），用户需要从源的上下文中获得一个锁。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">CounterSource</span>
       <span class="k">extends</span> <span class="nc">RichParallelSourceFunction</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>
       <span class="k">with</span> <span class="nc">CheckpointedFunction</span> <span class="o">{</span>

  <span class="nd">@volatile</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">isRunning</span> <span class="k">=</span> <span class="kc">true</span>

  <span class="k">private</span> <span class="k">var</span> <span class="n">offset</span> <span class="k">=</span> <span class="mi">0L</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">state</span><span class="k">:</span> <span class="kt">ListState</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="k">_</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">ctx</span><span class="k">:</span> <span class="kt">SourceFunction.SourceContext</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">lock</span> <span class="k">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">getCheckpointLock</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">isRunning</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// output and state update are atomic
</span><span class="c1"></span>      <span class="n">lock</span><span class="o">.</span><span class="n">synchronized</span><span class="o">(</span><span class="o">{</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="n">offset</span><span class="o">)</span>

        <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="o">}</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">cancel</span><span class="o">(</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">isRunning</span> <span class="k">=</span> <span class="kc">false</span>
  
  <span class="k">override</span> <span class="k">def</span> <span class="n">initializeState</span><span class="o">(</span><span class="n">context</span><span class="k">:</span> <span class="kt">FunctionInitializationContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">state</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">getOperatorStateStore</span><span class="o">.</span><span class="n">getListState</span><span class="o">(</span>
      <span class="k">new</span> <span class="nc">ListStateDescriptor</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span><span class="o">(</span><span class="s">&#34;state&#34;</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span><span class="o">)</span><span class="o">)</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">l</span> <span class="k">&lt;-</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">asScala</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">offset</span> <span class="k">=</span> <span class="n">l</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">snapshotState</span><span class="o">(</span><span class="n">context</span><span class="k">:</span> <span class="kt">FunctionSnapshotContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">state</span><span class="o">.</span><span class="n">clear</span><span class="o">(</span><span class="o">)</span>
    <span class="n">state</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">offset</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>一些运算符可能需要检查点被 Flink 完全承认时的信息来与外界沟通。在这种情况下，请参见 <code>org.apache.flink.runtime.state.CheckpointListener</code> 接口。</p>
<p>原文链接: <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html">https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/flink" term="flink" label="Flink" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" term="flink-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" label="Flink 官方文档" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/datastream-api" term="datastream-api" label="DataStream API" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/state" term="state" label="State" />
                            
                        
                    
                
            
        </entry>
    
</feed>
