<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.85.0">Hugo</generator><title type="html"><![CDATA[module on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/module/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/module/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/module/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/module/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2021-07-11T22:08:29+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/module/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的模块]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-23-modules-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-05-modules-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的 模块" />
            
                <id>https://ohmyweekly.github.io/notes/2015-03-23-modules-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+08:00</published>
            <updated>2021-07-10T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Modules in Raku</blockquote><h1 id="modules">Modules</h1>
<h2 id="exporting-and-selective-importing">Exporting and Selective Importing</h2>
<h3 id="is-export">is export</h3>
<p>packages(包), subroutines(子例程), variables(变量), constants(常量) 和 enums(枚举) , 通过在它们的名字后面添加 <code>is export</code> 特性来导出。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">unit</span> <span class="k">module</span> <span class="nn">MyModule</span><span class="p">;</span>
<span class="k">our</span> <span class="nv">$var</span> <span class="k">is</span> <span class="k">export</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">sub</span> <span class="nf">foo</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span>
<span class="k">constant</span> <span class="nv">$FOO</span> <span class="k">is</span> <span class="k">export</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">foobar</span><span class="p">&#34;;</span>
<span class="k">enum</span> <span class="n">FooBar</span> <span class="k">is</span> <span class="k">export</span> <span class="p">&lt;</span><span class="s">one two three</span><span class="p">&gt;;</span>

<span class="c1"># Packages like classes can be exported too</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{};</span>

<span class="c1"># If a subpackage is in the namespace of the current package</span>
<span class="c1"># it doesn&#39;t need to be explicitly exported</span>
<span class="k">class</span> <span class="nc">MyModule::MyClass</span> <span class="p">{};</span>
</code></pre></div><p>就像所有的 traits 一样, 如果应用到子例程(routine)上, &ldquo;is export&rdquo; 应该出现在参数列表的后面:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span> <span class="p">(</span><span class="nb">Str</span> <span class="nv">$string</span><span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div><p>你可以给 <code>is export</code> 传递命名参数以组织要导出的符号, 然后导入程序 (importer) 可以剔除和选择导入哪一个。有 3 个预先定义好的标签：<code>ALL</code>, <code>DEFAULT</code>, <code>MANDATORY</code>（强制的）。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># lib/MyModule.pm</span>
<span class="k">unit</span> <span class="k">module</span> <span class="nn">MyModule</span><span class="p">;</span>
<span class="k">sub</span> <span class="nb">bag</span>        <span class="k">is</span> <span class="k">export</span>              <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">pants</span>      <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">MANDATORY</span><span class="p">)</span>  <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">sunglasses</span> <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">day</span><span class="p">)</span>        <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">torch</span>      <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">night</span><span class="p">)</span>      <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">underpants</span> <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">ALL</span><span class="p">)</span>        <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># main.pl</span>
<span class="k">use</span> <span class="nb">lib</span> <span class="p">&#39;</span><span class="s1">lib</span><span class="p">&#39;;</span>
<span class="k">use</span> <span class="nn">MyModule</span><span class="p">;</span>           <span class="c1">#bag, pants</span>
<span class="k">use</span> <span class="nn">MyModule</span> <span class="p">:</span><span class="s">DEFAULT</span><span class="p">;</span>  <span class="c1">#the same</span>
<span class="k">use</span> <span class="nn">MyModule</span> <span class="p">:</span><span class="s">day</span><span class="p">;</span>      <span class="c1">#pants, sunglasses</span>
<span class="k">use</span> <span class="nn">MyModule</span> <span class="p">:</span><span class="s">night</span><span class="p">;</span>    <span class="c1">#pants, torch</span>
<span class="k">use</span> <span class="nn">MyModule</span> <span class="p">:</span><span class="s">ALL</span><span class="p">;</span>      <span class="c1">#bag, pants, sunglasses, torch, underpants</span>
</code></pre></div><h3 id="unitexport">UNIT::EXPORT::*</h3>
<p>表象之下, 其实 <code>is export</code> 是把符号添加到 <code>EXPORT</code> 命名空间中的 <code>UNIT</code> 作用域包中。例如, <code>is export(:FOO)</code> 会把目标添加到 <code>UNIT::EXPORT::FOO</code> 包中。这正是 Raku 决定导入什么所做的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">unit</span> <span class="k">module</span> <span class="nn">MyModule</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">foo</span> <span class="k">is</span> <span class="k">export</span>         <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">bar</span> <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">other</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>等价于:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">unit</span> <span class="k">module</span> <span class="nn">MyModule</span><span class="p">;</span>

<span class="k">my</span> <span class="nb">package</span> <span class="nn">EXPORT::DEFAULT</span> <span class="p">{</span>
  <span class="k">our</span> <span class="k">sub</span> <span class="nf">foo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nb">package</span> <span class="nn">EXPORT::other</span> <span class="p">{</span>
  <span class="k">our</span> <span class="k">sub</span> <span class="nf">bar</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>多数时候, <code>is export</code> 足够用了, 但是当你想动态生成要导出的符号时, <code>EXPORT</code> 包就很有用了。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># lib/MyModule.pm</span>
<span class="k">unit</span> <span class="k">module</span> <span class="nn">MuModule</span><span class="p">;</span>

<span class="k">my</span> <span class="nb">package</span> <span class="nn">EXPORT::DEFAULT</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">&lt;</span><span class="s">zero one two three four</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$number</span><span class="o">,</span> <span class="nv">$name</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">&lt;</span><span class="s">sqrt log</span><span class="p">&gt;</span> <span class="k">-&gt;</span> <span class="nv">$func</span> <span class="p">{</span>
          <span class="n">OUR::</span><span class="p">{&#39;</span><span class="s1">&amp;</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$func</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">-of-</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$name</span> <span class="p">}</span> <span class="o">:=</span> <span class="k">sub</span> <span class="p">{</span> <span class="nv">$number</span><span class="o">.</span><span class="p">&#34;</span><span class="nv">$func</span><span class="s2">()</span><span class="p">&#34;</span> <span class="p">};</span>
      <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># main.pl</span>
<span class="k">use</span> <span class="nn">MyModule</span><span class="p">;</span>
<span class="nb">say</span> <span class="n">sqrt-of-four</span><span class="p">;</span> <span class="c1">#-&gt; 2</span>
<span class="nb">say</span> <span class="n">log-of-zero</span><span class="p">;</span>  <span class="c1">#-&gt; -Inf</span>
</code></pre></div><h3 id="export">EXPORT</h3>
<p>你可以用一个 <code>EXPORT</code> 子例程导出任意符号。<code>EXPORT</code> 必须返回一个 <code>Map</code>, 在 map 里面键是符号名, 键值是想要的值。符号名应该包含(如果有的话)关联类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">MyModule::Class</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="k">sub</span> <span class="nf">EXPORT</span> <span class="p">{</span>
  <span class="p">{</span>
      <span class="p">&#39;</span><span class="s1">$var</span><span class="p">&#39;</span>      <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">one</span><span class="p">&#39;</span><span class="o">,</span>
      <span class="p">&#39;</span><span class="s1">@array</span><span class="p">&#39;</span>    <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="s">one two three</span><span class="p">&gt;</span><span class="o">,</span>
      <span class="p">&#39;</span><span class="s1">%hash</span><span class="p">&#39;</span>     <span class="o">=&gt;</span> <span class="p">{</span> <span class="s">one</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">two</span><span class="p">&#39;</span>, <span class="s">three</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">four</span><span class="p">&#39;}</span>,
      <span class="p">&#39;</span><span class="s1">&amp;doit</span><span class="p">&#39;</span>     <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span><span class="o">,</span>
      <span class="p">&#39;</span><span class="s1">ShortName</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="n">MyModule::class</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># main.pl</span>
<span class="k">use</span> <span class="nb">lib</span> <span class="p">&#39;</span><span class="s1">lib</span><span class="p">&#39;;</span>
<span class="k">use</span> <span class="nn">MyModule</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$var</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@array</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">%hash</span><span class="p">;</span>
<span class="nf">doit</span><span class="p">();</span>
<span class="nb">say</span> <span class="n">ShortName</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>  <span class="c1">#-&gt; MyModule::Class.new</span>
</code></pre></div><p>注意, <code>EXPORT</code> 不能声明在包内, 因为目前的 rakudo(2015.09) 好像把 EXPORT 当作 compunit 的一部分而非包的一部分。</p>
<p>虽然 <code>UNIT::EXPORT</code> 包处理传递给 <code>use</code> 的命名参数, 而 <code>EXPORT</code> sub 处理位置参数。如果你把位置参数传递给 <code>use</code>, 那么这些参数会被传递给 <code>EXPORT</code>。如果传递了位置参数, 那么 module 就不再需要导出默认符号了。你仍然可以伴随着你的位置参数, 通过显式地给 use 传递 <code>:DEFAULT</code> 参数来导入它们。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># lib/MyModule</span>

<span class="k">class</span> <span class="nc">MyModule::Class</span> <span class="p">{}</span>

<span class="k">sub</span> <span class="nf">EXPORT</span><span class="p">(</span><span class="nv">$short_name</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">{</span>
      <span class="nb">do</span> <span class="nv">$short_name</span> <span class="o">=&gt;</span> <span class="n">MyModule::Class</span> <span class="k">if</span> <span class="nv">$short_name</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">always</span> <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">MANDATORY</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">works</span><span class="p">&#34;</span> <span class="p">}</span>

<span class="c1">#import with :ALL or :DEFAULT to get</span>
<span class="k">sub</span> <span class="nf">shy</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">you found me!</span><span class="p">&#34;</span> <span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># main.pl</span>
<span class="k">use</span> <span class="nb">lib</span> <span class="p">&#39;</span><span class="s1">lib</span><span class="p">&#39;;</span>
<span class="k">use</span> <span class="nn">MyModule</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="n">foo</span><span class="o">.</span><span class="nb">new</span><span class="p">();</span> <span class="c1">#MyModule::Class.new</span>
<span class="nf">always</span><span class="p">();</span>      <span class="c1">#OK   - is imported</span>
<span class="nf">shy</span><span class="p">();</span>         <span class="c1">#FAIL - won&#39;t be imported</span>
</code></pre></div><h2 id="发布模块">发布模块</h2>
<p>如果你已经写了一个 Raku 模块, 你想把它分享到社区, 我们会很高兴地把它放到 Raku 模块文件夹清单中。<a href="http://modules.raku.org/">Raku modules directory</a></p>
<p>现在, 你需要使用 git 对你的模块进行版本控制。</p>
<p>这需要你有一个 Github 帐号, 以使你的模块能被从它的 Github 仓库中分享出去。</p>
<p>要分享你的模块, 按照下面说的做：</p>
<ul>
<li>
<p>创建一个以你的模块命名的工程文件夹。例如, 如果你的模块是 <code>Vortex::TotalPerspective</code>, 那么就创建一个叫做 <code>Vortex::TotalPerspective</code> 的工程文件夹。这个工程目录的名字也会被用作 Github 仓库的名字。</p>
</li>
<li>
<p>让你的工程目录看起来像这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">Vortex-TotalPerspective</span><span class="o">/</span>
<span class="o">|--</span> <span class="nb">lib</span>
<span class="o">|</span>   `<span class="o">--</span> <span class="n">Vortex</span>
<span class="o">|</span>       `<span class="o">--</span> <span class="n">TotalPerspective</span><span class="o">.</span><span class="nf">pm</span>
<span class="o">|--</span> <span class="n">LICENSE</span>
<span class="o">|--</span> <span class="n">META</span><span class="o">.</span><span class="nf">info</span>
<span class="o">|--</span> <span class="n">README</span><span class="o">.</span><span class="nf">md</span>
`<span class="o">--</span> <span class="nb">t</span>
    `<span class="o">--</span> <span class="n">basic</span><span class="o">.</span><span class="nb">t</span>
</code></pre></div><p>如果你的工程包含能帮助主模块完成工作的其它模块, 它们应该被放到你的 lib 目录中像这样组织：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">
<span class="nb">lib</span>
`<span class="o">--</span> <span class="n">Vortex</span>
    <span class="o">|--</span> <span class="n">TotalPerspective</span><span class="o">.</span><span class="nf">pm</span>
    `<span class="o">--</span> <span class="n">TotalPerspective</span>
        <span class="o">|--</span> <span class="n">FairyCake</span><span class="o">.</span><span class="nf">pm</span>
        `<span class="o">--</span> <span class="n">Gargravarr</span><span class="o">.</span><span class="nf">pm</span>
</code></pre></div><ul>
<li>
<p><code>README.md</code> 文件是一个 markdown 格式的文件, 它稍后会被 Github 自动渲染成 HTML</p>
</li>
<li>
<p>关于 LICENSE 文件, 如果你没有其它选择, 就是用和 Rakudo Raku 一样的 LICENSE 把。仅仅把它的原始 <a href="https://github.com/rakudo/rakudo/blob/nom/LICENSE">license</a> 复制/粘贴进你自己的 LICENSE 文件中。</p>
</li>
<li>
<p>如果你还没有任何测试, 现在你可以忽略 <code>t</code> 目录 和 <code>basic.t</code> 文件。关于如何写测试, 你可以看看其它模块是怎么使用 <code>Test</code> 的。它和 Perl'5 的 <code>Test::More</code> 很类似。</p>
</li>
<li>
<p>如果要文档化你的模块, 在你的模块中使用 <a href="http://design.raku.org/S26.html">Raku Pod</a> 标记。欢迎给模块写文档, 并且为了浏览的方便, 一旦 Raku module directory(或其它网站) 开始把 Pod 文档渲染成 HTML, 写文档尤为重要。</p>
</li>
<li>
<p>让你的 <code>META.info</code> 文件看起来像这样:</p>
</li>
</ul>
</li>
</ul>
<pre><code> {
        &quot;name&quot;        : &quot;Vortex::TotalPerspective&quot;,
        &quot;version&quot;     : &quot;0.1.0&quot;,
        &quot;description&quot; : &quot;Wonderful simulation to get some perspective.&quot;,
        &quot;author&quot;      : &quot;Your Name&quot;,
        &quot;provides&quot;    : {
            &quot;Vortex::TotalPerspective&quot; : &quot;lib/Vortex/TotalPerspective.pm&quot;
        },
        &quot;depends&quot;     : [ ],
        &quot;source-url&quot;  : &quot;git://github.com/you/Vortex-TotalPerspective.git&quot;
    }
</code></pre><p>关于选择版本号的方案, 或许使用 &ldquo;major.minor.patch&rdquo; （查看  the spec on versioning 获取详细信息 ）。如果版本号现在对你或你的用户来说不重要, 你可以给版本那儿放上一颗星(*)。</p>
<p>在 <code>provides</code> 一节, 包含进你的发布中提供的所有命名空间。</p>
<ul>
<li>把你的工程放在 git 版本控制之下, 如果你还未这样做。</li>
<li>一旦你对你的工程满意了, 在 Github 上为它创建一个仓库。必要的话,  查看 <a href="https://help.github.com/">Github&rsquo;s help docs</a>。 你的 Github 仓库的名字应该和你工程目录的名字一样。创建完 Githhub 仓库后, Github 会为你展示怎么配置你的本地仓库以获悉你的 Github 仓库。</li>
<li>把你的工程推送到 Github</li>
<li>在 IRC 频道找个人帮你展示怎么把你的模块添加到<a href="https://github.com/raku/ecosystem">ecosystem</a>, 或者让他们是否能替你添加。</li>
<li>pull 请求被接收之后, 等个把小时。如果你的模块没有出现在  <a href="http://modules.raku.org/,">http://modules.raku.org/,</a> 请到 <a href="http://modules.raku.org/log/update.log">http://modules.raku.org/log/update.log</a> 翻看log 日志文件, 以查找是否有错误。</li>
</ul>
<p>就是这样啦！感谢为 Raku 社区做贡献！</p>
<p>如果你想尝试安装你的模块, 使用熊猫 panda 安装工具, 这已经包含在 Rakudo Raku 中了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">zef</span> <span class="nb">install</span> <span class="n">Vortex::TotalPerspective</span>
</code></pre></div><p>这会下载你的模块到它自己的工作目录(~/.zef), 在那儿创建 build, 并把模块安装到 <code>~/.raku</code></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/module" term="module" label="module" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[模块]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-22-modules/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-22-alter-statements/?utm_source=atom_feed" rel="related" type="text/html" title="Alter 语句" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-22-catalogs/?utm_source=atom_feed" rel="related" type="text/html" title="Catalogs" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-22-create-statements/?utm_source=atom_feed" rel="related" type="text/html" title="Create 语句" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-22-drop-statements/?utm_source=atom_feed" rel="related" type="text/html" title="Drop 语句" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-22-explan-statements/?utm_source=atom_feed" rel="related" type="text/html" title="Explan 语句" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-22-modules/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-22T00:00:00+08:00</published>
            <updated>2020-08-22T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Modules</blockquote><h1 id="模块测试版">模块测试版</h1>
<p>模块允许用户扩展 Flink 的内置对象，比如定义一些行为类似 Flink 内置函数的功能。它们是可插拔的，虽然 Flink 提供了一些预建模块，但用户可以编写自己的模块。</p>
<p>例如，用户可以定义自己的地理函数，并将其作为内置函数插入 Flink，以便在 Flink SQL 和 Table API 中使用。又比如，用户可以加载一个现成的 Hive 模块，将 Hive 内置函数作为 Flink 内置函数使用。</p>
<h2 id="模块类型">模块类型</h2>
<h3 id="coremodule">CoreModule</h3>
<p>CoreModule 包含了 Flink 的所有系统（内置）功能，并且默认被加载。</p>
<h3 id="hivemodule">HiveModule</h3>
<p>HiveModule 作为 Flink 的系统函数，向 SQL 和 Table API 用户提供 Hive 内置函数。Flink 的 Hive 文档提供了设置该模块的全部细节。</p>
<h3 id="用户定义模块">用户定义模块</h3>
<p>用户可以通过实现 Module 接口来开发自定义模块。为了在 SQL CLI 中使用自定义模块，用户应该通过实现 ModuleFactory 接口同时开发一个模块和它对应的模块工厂。</p>
<p>模块工厂定义了一组属性，用于在 SQL CLI 引导时配置模块。属性被传递给发现服务，服务会尝试将属性与模块工厂进行匹配，并实例化一个相应的模块实例。</p>
<h2 id="命名空间和解析顺序">命名空间和解析顺序</h2>
<p>模块提供的对象被认为是 Flink 系统（内置）对象的一部分；因此，它们没有任何命名空间。</p>
<p>当有两个同名的对象存在于两个模块中时，Flink 总是将对象引用解析为第一个加载模块中的对象。</p>
<h2 id="模块-api">模块 API</h2>
<h3 id="装载和卸载模块">装载和卸载模块</h3>
<p>用户可以在现有的 Flink 会话中加载和卸载模块。</p>
<ul>
<li>Scala</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">tableEnv</span><span class="o">.</span><span class="n">loadModule</span><span class="o">(</span><span class="s">&#34;myModule&#34;</span><span class="o">,</span> <span class="k">new</span> <span class="nc">CustomModule</span><span class="o">());</span>
<span class="n">tableEnv</span><span class="o">.</span><span class="n">unloadModule</span><span class="o">(</span><span class="s">&#34;myModule&#34;</span><span class="o">);</span>
</code></pre></div><ul>
<li>YAML</li>
</ul>
<p>所有使用 YAML 定义的模块都必须提供一个 <code>type</code> 属性来指定类型。以下类型是开箱即用的。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Catalog</th>
<th style="text-align:left">Type Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CoreModule</td>
<td style="text-align:left">core</td>
</tr>
<tr>
<td style="text-align:left">HiveModule</td>
<td style="text-align:left">hive</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">modules</span><span class="p">:</span><span class="w">
</span><span class="w">   </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">core</span><span class="w">
</span><span class="w">     </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">core</span><span class="w">
</span><span class="w">   </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">myhive</span><span class="w">
</span><span class="w">     </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">hive</span><span class="w">
</span></code></pre></div><h3 id="列出可用的模块">列出可用的模块</h3>
<ul>
<li>Scala</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">tableEnv</span><span class="o">.</span><span class="n">listModules</span><span class="o">();</span>
</code></pre></div><ul>
<li>SQL</li>
</ul>
<pre><code>Flink SQL&gt; SHOW MODULES;
</code></pre><p>原文链接: <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/modules.html">https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/modules.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/flink" term="flink" label="Flink" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" term="flink-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" label="Flink 官方文档" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/table-api-sql" term="table-api-sql" label="Table API &amp; SQL" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/module" term="module" label="Module" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Julia 中的 模块]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-05-modules-in-julia/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-04-pkg-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的 Pkg" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-04-dates-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的日期和时间" />
                <link href="https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 语言学习笔记" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-05-modules-in-julia/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-05T00:00:00+08:00</published>
            <updated>2020-08-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Modules</blockquote><h1 id="模块">模块</h1>
<p>Julia 中的模块是独立的变量工作空间，即它们引入了一个新的全局作用域。它们在语法上是有分界的，在 <code>module Name ... end</code> 里面。模块允许您创建顶层定义（也就是全局变量），而不用担心您的代码与别人的代码一起使用时的名称冲突。在一个模块中，你可以控制哪些来自其他模块的名字是可见的（通过导入），并指定哪些名字是要公开的（通过导出）。</p>
<p>下面的例子展示了模块的主要功能。这个例子并不是为了运行，而是为了说明问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">MyModule</span>
<span class="k">using</span> <span class="n">Lib</span>

<span class="k">using</span> <span class="n">BigLib</span><span class="o">:</span> <span class="n">thing1</span><span class="p">,</span> <span class="n">thing2</span>

<span class="k">import</span> <span class="n">Base</span><span class="o">.</span><span class="n">show</span>

<span class="k">export</span> <span class="n">MyType</span><span class="p">,</span> <span class="n">foo</span>

<span class="k">struct</span> <span class="kt">MyType</span>
    <span class="n">x</span>
<span class="k">end</span>

<span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="n">x</span>
<span class="n">foo</span><span class="p">(</span><span class="n">a</span><span class="o">::</span><span class="kt">MyType</span><span class="p">)</span> <span class="o">=</span> <span class="n">bar</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">show</span><span class="p">(</span><span class="n">io</span><span class="o">::</span><span class="kt">IO</span><span class="p">,</span> <span class="n">a</span><span class="o">::</span><span class="kt">MyType</span><span class="p">)</span> <span class="o">=</span> <span class="n">print</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&#34;MyType </span><span class="si">$</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="s">&#34;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><p>需要注意的是，这个样式并不是要在模块的正文中缩进，因为这通常会导致整个文件被缩进。</p>
<p>这个模块定义了一个 <code>MyType</code> 类型和两个函数。函数 <code>foo</code> 和 <code>MyType</code> 类型是导出的，因此可以导入到其他模块中。函数 <code>bar</code> 是 <code>MyModule</code> 的私有函数。</p>
<p><code>using Lib</code> 语句意味着将有一个名为 <code>Lib</code> 的模块可以根据需要解析名称。当遇到一个全局变量在当前模块中没有定义时，系统会在 <code>Lib</code> 导出的变量中搜索它，如果在那里找到了，就会导入它。这意味着在当前模块内对该全局的所有使用都将解析为该变量在 <code>Lib</code> 中的定义。</p>
<p><code>using BigLib: thing1, thing2</code> 语句，只将标识符 <code>thing1</code> 和 <code>thing2</code> 从模块 <code>BigLib</code> 中带入作用域。如果这些名称指的是函数，那么将不允许向它们添加方法（你只能 &ldquo;使用 &ldquo;它们，而不是扩展它们）。</p>
<p><code>import</code> 关键字支持与 <code>using</code> 相同的语法。<code>import</code> 与 <code>using</code> 的不同之处在于，使用 <code>import</code> 导入的函数可以用新的方法进行扩展。</p>
<p>在上面的 <code>MyModule</code> 中，我们想给标准的 <code>show</code> 函数添加一个方法，所以我们必须写 <code>import Base.show</code>。只有通过 <code>using</code> 才能看到名字的函数不能被扩展。</p>
<p>一旦一个变量通过 <code>using</code> 或 <code>import</code> 变得可见，一个模块就不能创建自己的同名变量。导入的变量是只读的，分配给全局变量总是会影响到当前模块所拥有的变量，否则会引发错误。</p>
<h2 id="模块使用情况概述">模块使用情况概述</h2>
<p>要加载一个模块，可以使用两个主要的关键词：<code>using</code> 和 <code>import</code>。要了解它们的区别，请看下面的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">MyModule</span>

<span class="k">export</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

<span class="n">x</span><span class="p">()</span> <span class="o">=</span> <span class="s">&#34;x&#34;</span>
<span class="n">y</span><span class="p">()</span> <span class="o">=</span> <span class="s">&#34;y&#34;</span>
<span class="n">p</span><span class="p">()</span> <span class="o">=</span> <span class="s">&#34;p&#34;</span>

<span class="k">end</span>
</code></pre></div><p>在这个模块中，我们导出了 <code>x</code> 和 <code>y</code> 函数(用关键字 <code>export</code>)，也有非导出的函数 <code>p</code>，有几种不同的方法可以将 <code>Module</code> 及其内部函数加载到当前的工作空间中。</p>
<table>
<thead>
<tr>
<th style="text-align:left">导入命令</th>
<th style="text-align:left">带入带作用域中的东西</th>
<th style="text-align:left">可用于方法扩展</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>using MyModule</code></td>
<td style="text-align:left">所有导出的名字(<code>x</code> 和 <code>y</code>), <code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
<td style="text-align:left"><code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
</tr>
<tr>
<td style="text-align:left"><code>using MyModule: x, p</code></td>
<td style="text-align:left"><code>x</code> 和 <code>p</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>import MyModule</code></td>
<td style="text-align:left"><code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
<td style="text-align:left"><code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
</tr>
<tr>
<td style="text-align:left"><code>import MyModule.x, MyModule.p</code></td>
<td style="text-align:left"><code>x</code> 和 <code>p</code></td>
<td style="text-align:left"><code>x</code> 和 <code>p</code></td>
</tr>
<tr>
<td style="text-align:left"><code>import MyModule: x, p</code></td>
<td style="text-align:left"><code>x</code> 和 <code>p</code></td>
<td style="text-align:left"><code>x</code> 和 <code>p</code></td>
</tr>
</tbody>
</table>
<h2 id="模块和文件">模块和文件</h2>
<p>文件和文件名大多与模块无关，模块只与模块表达式有关。一个模块可以有多个文件，一个文件可以有多个模块。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">Foo</span>

<span class="n">include</span><span class="p">(</span><span class="s">&#34;file1.jl&#34;</span><span class="p">)</span>
<span class="n">include</span><span class="p">(</span><span class="s">&#34;file2.jl&#34;</span><span class="p">)</span>

<span class="k">end</span>
</code></pre></div><p>在不同的模块中包含相同的代码，提供了类似 mixin 的行为。人们可以使用这一点来用不同的基础定义来运行相同的代码，例如，通过使用某些操作符的&quot;安全&quot;版本来测试代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">Normal</span>
<span class="n">include</span><span class="p">(</span><span class="s">&#34;mycode.jl&#34;</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">module</span> <span class="n">Testing</span>
<span class="n">include</span><span class="p">(</span><span class="s">&#34;safe_operators.jl&#34;</span><span class="p">)</span>
<span class="n">include</span><span class="p">(</span><span class="s">&#34;mycode.jl&#34;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><h2 id="标准模块">标准模块</h2>
<p>There are three important standard modules:</p>
<p><a href="https://docs.julialang.org/en/v1/base/base/#Core">Core</a> 包含&quot;内置于&quot;语言中的所有功能。
<a href="https://docs.julialang.org/en/v1/base/base/#Base">Base</a> 包含几乎在所有情况下都有用的基本功能。
<a href="https://docs.julialang.org/en/v1/base/base/#Main">Main</a> 是当 Julia 被启动时的顶级模块和当前模块。</p>
<h2 id="默认的顶层定义和裸模块">默认的顶层定义和裸模块</h2>
<p>除了 <code>using Base</code> 之外，模块还自动包含 <a href="https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.eval">eval</a>和 <a href="https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.include">include</a> 函数的定义，这些函数在该模块的全局作用域内评估表达式/文件。</p>
<p>如果不想要这些默认的定义，可以使用关键字 <a href="https://docs.julialang.org/en/v1/base/base/#baremodule">baremodule</a> 来代替定义模块（注意： <code>Core</code> 仍然是导入的，如上所述）。以 <code>baremodule</code> 来说，一个标准的模块是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">baremodule</span> <span class="n">Mod</span>

<span class="k">using</span> <span class="n">Base</span>

<span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">Core</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">Mod</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">include</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="n">Mod</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="o">...</span>

<span class="k">end</span>
</code></pre></div><h2 id="相对和绝对模块路径">相对和绝对模块路径</h2>
<p>给定 <code>using Foo</code> 语句，系统会查询内部的顶层模块表，寻找一个名为 <code>Foo</code> 的模块。如果该模块不存在，系统会尝试 <code>require(:Foo)</code>，这通常会导致从安装的包中加载代码。</p>
<p>然而，有些模块包含子模块，这意味着你有时需要访问一个非顶层模块。有两种方法可以做到这一点。第一种是使用绝对路径，例如 <code>using Base.Sort</code>。第二种是使用相对路径，这样可以更容易地导入当前模块的子模块或其任何一个外层模块。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">Parent</span>

<span class="k">module</span> <span class="n">Utils</span>
<span class="o">...</span>
<span class="k">end</span>

<span class="k">using</span> <span class="o">.</span><span class="n">Utils</span>

<span class="o">...</span>
<span class="k">end</span>
</code></pre></div><p>这里模块 <code>Parent</code> 包含一个子模块 <code>Utils</code>，<code>Parent</code> 中的代码希望 <code>Utils</code> 的内容可见。这可以通过在 <code>using</code> 路径中使用点号来实现。添加更多的前导点号会使模块的层次结构上升。例如，<code>using ..Utils</code> 会在 <code>Parent</code> 的外层模块中查找<code>Utils</code>，而不是在 <code>Parent</code> 本身中查找。</p>
<p>注意相对导入限定符只在使用和导入语句中有效。</p>
<h2 id="命名空间杂项">命名空间杂项</h2>
<p>如果一个名字是限定的(例如 <code>Base.sin</code>)，那么即使它没有被导出，也可以被访问。这在调试时往往很有用。它也可以通过使用限定名作为函数名来添加方法。但是，由于会产生语法上的歧义，如果你想给不同模块中的一个函数添加方法，而这个函数的名称只包含符号，例如一个运算符，<code>Base.+</code>，你必须使用 <code>Base.:+</code> 来引用它。如果运算符的长度超过一个字符，你必须用括号把它括起来，比如 <code>Base.:(==)</code>。</p>
<p>在导入和导出语句中，宏的名称用 <code>@</code> 书写，例如 <code>import Mod.@mac</code>。其他模块中的宏可以用 <code>Mod.@mac</code> 或 <code>@Mod.mac</code> 来调用。</p>
<p>语法 <code>M.x = y</code> 不能用于分配其他模块中的全局，全局分配总是模块-局部的。</p>
<p>变量名可以通过声明为 <code>global x</code> 来 &ldquo;保留&quot;而不分配给它，这样可以防止加载后初始化的 globals 的名称冲突。</p>
<h2 id="模块初始化和预编译">模块初始化和预编译</h2>
<p>大型模块可能需要几秒钟的时间来加载，因为执行一个模块中的所有语句往往需要编译大量的代码。Julia 创建了模块的预编译缓存来减少这个时间。</p>
<p>当使用 <code>import</code> 或 <code>using</code> 加载模块时，会自动创建并使用增量的预编译模块文件。这将导致它在第一次导入时自动编译。另外，您也可以手动调用 <a href="https://docs.julialang.org/en/v1/base/base/#Base.compilecache">Base.compilecache(modulename)</a>。由此产生的缓存文件将存储在 <code>DEPOT_PATH[1]/compiled/</code> 中。随后，只要模块的任何依赖关系发生变化，模块就会在 <code>using</code> 或 <code>import</code> 时自动重新编译；依赖关系是指导入的模块、Julia 构建的模块、包含的文件，或者模块文件中 <a href="https://docs.julialang.org/en/v1/base/base/#Base.include_dependency">include_dependency(path)</a> 声明的显式依赖关系。</p>
<p>对于文件依赖，通过检查由 <code>include</code> 加载的文件或由 <code>include_dependency</code> 显式添加的文件的修改时间(mtime)是否保持不变，或者是否等于被截断到最接近秒的修改时间(以适应无法以亚秒级精度复制 mtime 的系统)来确定变化。它还考虑到在 <code>require</code> 中搜索逻辑选择的文件路径是否与创建预编译文件的路径匹配。它还会考虑到已经加载到当前进程中的一组依赖关系，即使这些模块的文件发生变化或消失，也不会重新编译这些模块，以避免在运行系统和预编译缓存之间产生不兼容的情况。</p>
<p>如果你知道某个模块预编译你的模块是不安全的（例如，出于下面描述的原因之一），你应该在模块文件中加上 <code>__precompile__(false)</code>（通常放在顶部）。这将导致 <code>Base.compilecache</code> 抛出一个错误，并将导致 <code>using</code> / <code>import</code> 直接将其加载到当前进程中而跳过预编译和缓存。这也因此阻止了该模块被任何其他预编译模块导入。</p>
<p>您可能需要注意创建增量共享库时固有的某些行为，在编写模块时可能需要注意。例如，外部状态不会被保存。为了适应这一点，明确地将任何必须在运行时发生的初始化步骤与可以在编译时发生的步骤分开。为此，Julia 允许您在您的模块中定义一个 <code>__init__()</code> 函数来执行任何必须在运行时发生的初始化步骤。这个函数在编译时不会被调用（<code>--output-*</code>）。实际上，你可以假设它在代码的生命周期中只运行一次。当然，如果有必要的话，你可以手动调用它，但是默认情况下，你可以假设这个函数处理的是本地机器的计算状态，它不需要&ndash;甚至不应该&ndash;在编译后的镜像中捕获。它将在模块被加载到一个进程后被调用，包括如果它被加载到增量编译中(<code>--output-incremental=yes</code>)，但如果它被加载到一个完整的编译进程中，则不会被调用。</p>
<p>特别是，如果你在一个模块中定义了一个 <code>function __init__()</code>，那么 Julia 将在模块被加载后（例如通过 <code>import</code>、<code>using</code> 或 <code>require</code>）在运行时第一次立即调用 <code>__init__()</code>（也就是说，<code>__init__</code> 只被调用一次，而且是在模块中的所有语句被执行后才被调用）。因为它是在模块完全导入之后被调用的，所以任何子模块或其它导入的模块都会在外层模块的 <code>__init__</code> 之前调用它们的 <code>__init__</code> 函数。</p>
<p><code>__init__</code> 的两个典型用途是调用外部 C 库的运行时初始化函数和初始化涉及外部库返回指针的全局常量。例如，假设我们正在调用一个 C 库 <code>libfoo</code>，它要求我们在运行时调用 <code>foo_init()</code> 初始化函数。假设我们还想定义一个全局常量 <code>foo_data_ptr</code>，用来存放 <code>libfoo</code> 定义的 <code>void *foo_data()</code> 函数的返回值&ndash;这个常量必须在运行时（而不是在编译时）初始化，因为指针地址会随着运行而改变。你可以通过在你的模块中定义下面的 <code>__init__</code> 函数来实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">const</span> <span class="n">foo_data_ptr</span> <span class="o">=</span> <span class="kt">Ref</span><span class="p">{</span><span class="kt">Ptr</span><span class="p">{</span><span class="kt">Cvoid</span><span class="p">}}(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">function</span> <span class="n">__init__</span><span class="p">()</span>
    <span class="k">ccall</span><span class="p">((</span><span class="ss">:foo_init</span><span class="p">,</span> <span class="ss">:libfoo</span><span class="p">),</span> <span class="kt">Cvoid</span><span class="p">,</span> <span class="p">())</span>
    <span class="n">foo_data_ptr</span><span class="p">[]</span> <span class="o">=</span> <span class="k">ccall</span><span class="p">((</span><span class="ss">:foo_data</span><span class="p">,</span> <span class="ss">:libfoo</span><span class="p">),</span> <span class="kt">Ptr</span><span class="p">{</span><span class="kt">Cvoid</span><span class="p">},</span> <span class="p">())</span>
    <span class="nb">nothing</span>
<span class="k">end</span>
</code></pre></div><p>请注意，我们完全可以在函数内部定义一个全局，比如 <code>__init__</code>；这是使用动态语言的优势之一。但是通过在全局作用域内定义一个常量，我们可以确保编译器知道这个类型，并允许它生成更好的优化代码。显然，你的模块中任何其他依赖于 <code>foo_data_ptr</code> 的 globals 也必须在 <code>__init__</code> 中初始化。</p>
<p>涉及大多数不是由 <a href="https://docs.julialang.org/en/v1/base/c/#ccall">ccall</a> 产生的 Julia 对象的常量不需要放在 <code>__init__</code> 中：它们的定义可以被预编译并从缓存的模块映像中加载。这包括像数组这样复杂的堆分配对象。然而，任何返回原始指针值的例程都必须在运行时调用，以便预编译工作（<a href="https://docs.julialang.org/en/v1/base/c/#Core.Ptr">Ptr</a> 对象将变成空指针，除非它们被隐藏在 <a href="https://docs.julialang.org/en/v1/base/base/#Base.isbits">isbits</a> 对象中）。这包括 Julia 函数 <code>cfunction</code> 和 <a href="https://docs.julialang.org/en/v1/base/c/#Base.pointer">pointer</a> 的返回值。</p>
<p>字典和集合类型，或者一般来说任何依赖于 <code>hash(key)</code> 方法输出的东西，都是比较棘手的情况。在常见的情况下，键是数字、字符串、符号、范围、<code>Expr</code> 或这些类型的组合（通过数组、元组、集合、对等），它们可以安全地进行预编译。然而，对于其他一些关键类型，如 <code>Function</code> 或 <code>DataType</code> 和通用的用户定义类型，在这些类型中，你没有定义 <code>hash</code> 方法，回退 <code>hash</code> 方法取决于对象的内存地址（通过它的 <code>objectid</code>），因此可能会在运行时改变。如果你有这些键类型之一，或者如果你不确定，为了安全起见，你可以在你的 <code>__init__</code> 函数中初始化这个字典。或者，你也可以使用 <a href="https://docs.julialang.org/en/v1/base/collections/#Base.IdDict">IdDict</a> 字典类型，它由预编译特别处理，所以在编译时初始化是安全的。</p>
<p>在使用预编译时，保持对编译阶段和执行阶段的清晰认识很重要。在这种模式下，往往会更清楚地认识到 Julia 是一个允许执行任意 Julia 代码的编译器，而不是一个同时生成编译代码的独立解释器。</p>
<p>其他已知的潜在故障情况包括。</p>
<ol>
<li>全局计数器（例如，用于试图唯一识别对象）。考虑以下代码片段。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">mutable struct</span> <span class="kt">UniquedById</span>
    <span class="n">myid</span><span class="o">::</span><span class="kt">Int</span>
    <span class="k">let</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">UniquedById</span><span class="p">()</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>虽然这段代码的目的是给每个实例一个唯一的 id，但计数器的值是在编译结束时记录的。这个增量编译模块的所有后续使用将从同一个计数器值开始。</p>
<p>请注意，<code>objectid</code>（通过哈希内存指针工作）也有类似的问题（参见下面关于 <code>Dict</code> 用法的说明）。</p>
<p>一种替代方法是使用宏来捕获 <a href="https://docs.julialang.org/en/v1/base/base/#Base.@__MODULE__">@<strong>MODULE</strong></a>，并将其与当前的计数器值一起单独存储，然而，重新设计代码使其不依赖于这个全局状态可能会更好。</p>
<ol start="2">
<li>
<p>关联集合(比如 <code>Dict</code> 和 <code>Set</code>)需要在 <code>__init__</code> 中重新洗牌(将来可能会提供一个机制来注册一个初始化函数)。</p>
</li>
<li>
<p>根据编译时的副作用在加载时持续存在。例如：修改其他 Julia 模块中的数组或其他变量；维护打开的文件或设备的句柄；存储其他系统资源（包括内存）的指针。</p>
</li>
<li>
<p>通过直接引用而不是通过它的查找路径，从另一个模块创建意外的全局状态&quot;副本&rdquo;。例如，（在全局作用域内）。</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="c">#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#</span>
<span class="c"># instead use accessor functions:</span>
<span class="n">getstdout</span><span class="p">()</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="nb">stdout</span> <span class="cm">#= best option =#</span>
<span class="c"># or move the assignment into the runtime:</span>
<span class="n">__init__</span><span class="p">()</span> <span class="o">=</span> <span class="k">global</span> <span class="n">mystdout</span> <span class="o">=</span> <span class="n">Base</span><span class="o">.</span><span class="nb">stdout</span> <span class="cm">#= also works =#</span>
</code></pre></div><p>对预编译代码时可以进行的操作进行了一些额外的限制，以帮助用户避免其他错误行为的情况。</p>
<ol>
<li>
<p>调用 <a href="https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.eval">eval</a> 引起另一个模块的副作用。当增量预编译标志被设置时，这也会导致发出警告。</p>
</li>
<li>
<p>在 <code>__init__()</code> 被启动后，从本地作用域调用 <code>global const</code> 语句(参见问题 <code>#12010</code>，计划为此增加一个错误)</p>
</li>
<li>
<p>在进行增量预编译时，替换一个模块是一个运行时错误。</p>
</li>
</ol>
<p>还有几点需要注意。</p>
<ol>
<li>
<p>在对源文件本身进行修改之后，不会进行代码重载/缓存无效化（包括通过 <code>Pkg.update</code>），而且在 <code>Pkg.rm</code> 之后也不会进行清理。</p>
</li>
<li>
<p>预编译不考虑重塑数组的内存共享行为 (每个视图都有自己的副本)</p>
</li>
<li>
<p>期待文件系统在编译时和运行时之间保持不变，例如 <a href="https://docs.julialang.org/en/v1/base/file/#Base.@__FILE__">@<strong>FILE</strong></a>/<code>source_path()</code> 在运行时查找资源，或者 BinDeps 的 <code>@checked_lib</code> 宏。有时这是不可避免的。然而，在可能的情况下，在编译时将资源复制到模块中是一个很好的做法，这样它们就不需要在运行时被找到。</p>
</li>
<li>
<p><code>WeakRef</code> 对象和 finalizers 目前还没有被序列化器正确处理（这将在即将发布的版本中得到修正）。</p>
</li>
<li>
<p>通常最好避免捕获对内部元数据对象实例的引用，如 <code>Method</code>、<code>MethodInstance</code>、<code>MethodTable</code>、<code>TypeMapLevel</code>、<code>TypeMapEntry</code> 以及这些对象的字段，因为这可能会混淆序列化器，可能不会导致你想要的结果。这样做不一定会出错，但你只需要做好准备，系统会尝试复制其中的一些对象，并为其他对象创建一个唯一的实例。</p>
</li>
</ol>
<p>在模块开发过程中，有时关闭增量预编译是很有帮助的。命令行标志 <code>--compiled-modules={yes|no}</code> 可以让你开启或关闭模块预编译。当 Julia 以 <code>--compiled-modules=no</code> 启动时，当加载模块和模块依赖时，编译缓存中的序列化模块会被忽略。<code>Base.compilecache</code> 仍然可以被手动调用。这个命令行标志的状态被传递给 <code>Pkg.build</code>，以便在安装、更新和显式构建包时禁用自动预编译触发。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia" term="julia" label="julia" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/module" term="module" label="module" />
                            
                        
                    
                
            
        </entry>
    
</feed>
