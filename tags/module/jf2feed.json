{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"children":[{"content":{"html":"\u003ch1 id=\"模块测试版\"\u003e模块测试版\u003c/h1\u003e\n\u003cp\u003e模块允许用户扩展 Flink 的内置对象，比如定义一些行为类似 Flink 内置函数的功能。它们是可插拔的，虽然 Flink 提供了一些预建模块，但用户可以编写自己的模块。\u003c/p\u003e\n\u003cp\u003e例如，用户可以定义自己的地理函数，并将其作为内置函数插入 Flink，以便在 Flink SQL 和 Table API 中使用。又比如，用户可以加载一个现成的 Hive 模块，将 Hive 内置函数作为 Flink 内置函数使用。\u003c/p\u003e\n\u003ch2 id=\"模块类型\"\u003e模块类型\u003c/h2\u003e\n\u003ch3 id=\"coremodule\"\u003eCoreModule\u003c/h3\u003e\n\u003cp\u003eCoreModule 包含了 Flink 的所有系统（内置）功能，并且默认被加载。\u003c/p\u003e\n\u003ch3 id=\"hivemodule\"\u003eHiveModule\u003c/h3\u003e\n\u003cp\u003eHiveModule 作为 Flink 的系统函数，向 SQL 和 Table API 用户提供 Hive 内置函数。Flink 的 Hive 文档提供了设置该模块的全部细节。\u003c/p\u003e\n\u003ch3 id=\"用户定义模块\"\u003e用户定义模块\u003c/h3\u003e\n\u003cp\u003e用户可以通过实现 Module 接口来开发自定义模块。为了在 SQL CLI 中使用自定义模块，用户应该通过实现 ModuleFactory 接口同时开发一个模块和它对应的模块工厂。\u003c/p\u003e\n\u003cp\u003e模块工厂定义了一组属性，用于在 SQL CLI 引导时配置模块。属性被传递给发现服务，服务会尝试将属性与模块工厂进行匹配，并实例化一个相应的模块实例。\u003c/p\u003e\n\u003ch2 id=\"命名空间和解析顺序\"\u003e命名空间和解析顺序\u003c/h2\u003e\n\u003cp\u003e模块提供的对象被认为是 Flink 系统（内置）对象的一部分；因此，它们没有任何命名空间。\u003c/p\u003e\n\u003cp\u003e当有两个同名的对象存在于两个模块中时，Flink 总是将对象引用解析为第一个加载模块中的对象。\u003c/p\u003e\n\u003ch2 id=\"模块-api\"\u003e模块 API\u003c/h2\u003e\n\u003ch3 id=\"装载和卸载模块\"\u003e装载和卸载模块\u003c/h3\u003e\n\u003cp\u003e用户可以在现有的 Flink 会话中加载和卸载模块。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eScala\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003etableEnv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eloadModule\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;myModule\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nc\"\u003eCustomModule\u003c/span\u003e\u003cspan class=\"o\"\u003e());\u003c/span\u003e\n\u003cspan class=\"n\"\u003etableEnv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eunloadModule\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;myModule\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eYAML\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e所有使用 YAML 定义的模块都必须提供一个 \u003ccode\u003etype\u003c/code\u003e 属性来指定类型。以下类型是开箱即用的。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003eCatalog\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003eType Value\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eCoreModule\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003ecore\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eHiveModule\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003ehive\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan class=\"nt\"\u003emodules\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003ecore\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e\u003cspan class=\"nt\"\u003etype\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003ecore\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e- \u003cspan class=\"nt\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003emyhive\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e\u003cspan class=\"nt\"\u003etype\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003ehive\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"列出可用的模块\"\u003e列出可用的模块\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eScala\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-scala\" data-lang=\"scala\"\u003e\u003cspan class=\"n\"\u003etableEnv\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elistModules\u003c/span\u003e\u003cspan class=\"o\"\u003e();\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eSQL\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003eFlink SQL\u0026gt; SHOW MODULES;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e原文链接: \u003ca href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/modules.html\"\u003ehttps://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/modules.html\u003c/a\u003e\u003c/p\u003e\n","text":"模块测试版 模块允许用户扩展 Flink 的内置对象，比如定义一些行为类似 Flink 内置函数的功能。它们是可插拔的，虽然 Flink 提供了一些预建模块，但用户可以编写自己的模块。\n例如，用户可以定义自己的地理函数，并将其作为内置函数插入 Flink，以便在 Flink SQL 和 Table API 中使用。又比如，用户可以加载一个现成的 Hive 模块，将 Hive 内置函数作为 Flink 内置函数使用。\n模块类型 CoreModule CoreModule 包含了 Flink 的所有系统（内置）功能，并且默认被加载。\nHiveModule HiveModule 作为 Flink 的系统函数，向 SQL 和 Table API 用户提供 Hive 内置函数。Flink 的 Hive 文档提供了设置该模块的全部细节。\n用户定义模块 用户可以通过实现 Module 接口来开发自定义模块。为了在 SQL CLI 中使用自定义模块，用户应该通过实现 ModuleFactory 接口同时开发一个模块和它对应的模块工厂。\n模块工厂定义了一组属性，用于在 SQL CLI 引导时配置模块。属性被传递给发现服务，服务会尝试将属性与模块工厂进行匹配，并实例化一个相应的模块实例。\n命名空间和解析顺序 模块提供的对象被认为是 Flink 系统（内置）对象的一部分；因此，它们没有任何命名空间。\n当有两个同名的对象存在于两个模块中时，Flink 总是将对象引用解析为第一个加载模块中的对象。\n模块 API 装载和卸载模块 用户可以在现有的 Flink 会话中加载和卸载模块。\n Scala  tableEnv.loadModule(\u0026#34;myModule\u0026#34;, new CustomModule()); tableEnv.unloadModule(\u0026#34;myModule\u0026#34;);  YAML  所有使用 YAML 定义的模块都必须提供一个 type 属性来指定类型。以下类型是开箱即用的。\n   Catalog Type Value     CoreModule core   HiveModule hive    modules:- name:coretype:core- name:myhivetype:hive列出可用的模块  Scala  tableEnv.listModules();  SQL  Flink SQL\u0026gt; SHOW MODULES; 原文链接: https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/modules.html\n"},"name":"模块","published":"2020-08-22T00:00:00+08:00","summary":"Modules","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-08-22-modules/"},{"content":{"html":"\u003ch1 id=\"模块\"\u003e模块\u003c/h1\u003e\n\u003cp\u003eJulia 中的模块是独立的变量工作空间，即它们引入了一个新的全局作用域。它们在语法上是有分界的，在 \u003ccode\u003emodule Name ... end\u003c/code\u003e 里面。模块允许您创建顶层定义（也就是全局变量），而不用担心您的代码与别人的代码一起使用时的名称冲突。在一个模块中，你可以控制哪些来自其他模块的名字是可见的（通过导入），并指定哪些名字是要公开的（通过导出）。\u003c/p\u003e\n\u003cp\u003e下面的例子展示了模块的主要功能。这个例子并不是为了运行，而是为了说明问题。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-julia\" data-lang=\"julia\"\u003e\u003cspan class=\"k\"\u003emodule\u003c/span\u003e \u003cspan class=\"n\"\u003eMyModule\u003c/span\u003e\n\u003cspan class=\"k\"\u003eusing\u003c/span\u003e \u003cspan class=\"n\"\u003eLib\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eusing\u003c/span\u003e \u003cspan class=\"n\"\u003eBigLib\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003ething1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ething2\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003eBase\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eshow\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"n\"\u003eMyType\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003efoo\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"kt\"\u003eMyType\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ex\u003c/span\u003e\n\u003cspan class=\"k\"\u003eend\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003ebar\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\n\u003cspan class=\"n\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"kt\"\u003eMyType\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ebar\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eshow\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eio\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"kt\"\u003eIO\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"kt\"\u003eMyType\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eio\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;MyType \u003c/span\u003e\u003cspan class=\"si\"\u003e$\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"k\"\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e需要注意的是，这个样式并不是要在模块的正文中缩进，因为这通常会导致整个文件被缩进。\u003c/p\u003e\n\u003cp\u003e这个模块定义了一个 \u003ccode\u003eMyType\u003c/code\u003e 类型和两个函数。函数 \u003ccode\u003efoo\u003c/code\u003e 和 \u003ccode\u003eMyType\u003c/code\u003e 类型是导出的，因此可以导入到其他模块中。函数 \u003ccode\u003ebar\u003c/code\u003e 是 \u003ccode\u003eMyModule\u003c/code\u003e 的私有函数。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eusing Lib\u003c/code\u003e 语句意味着将有一个名为 \u003ccode\u003eLib\u003c/code\u003e 的模块可以根据需要解析名称。当遇到一个全局变量在当前模块中没有定义时，系统会在 \u003ccode\u003eLib\u003c/code\u003e 导出的变量中搜索它，如果在那里找到了，就会导入它。这意味着在当前模块内对该全局的所有使用都将解析为该变量在 \u003ccode\u003eLib\u003c/code\u003e 中的定义。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eusing BigLib: thing1, thing2\u003c/code\u003e 语句，只将标识符 \u003ccode\u003ething1\u003c/code\u003e 和 \u003ccode\u003ething2\u003c/code\u003e 从模块 \u003ccode\u003eBigLib\u003c/code\u003e 中带入作用域。如果这些名称指的是函数，那么将不允许向它们添加方法（你只能 \u0026ldquo;使用 \u0026ldquo;它们，而不是扩展它们）。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eimport\u003c/code\u003e 关键字支持与 \u003ccode\u003eusing\u003c/code\u003e 相同的语法。\u003ccode\u003eimport\u003c/code\u003e 与 \u003ccode\u003eusing\u003c/code\u003e 的不同之处在于，使用 \u003ccode\u003eimport\u003c/code\u003e 导入的函数可以用新的方法进行扩展。\u003c/p\u003e\n\u003cp\u003e在上面的 \u003ccode\u003eMyModule\u003c/code\u003e 中，我们想给标准的 \u003ccode\u003eshow\u003c/code\u003e 函数添加一个方法，所以我们必须写 \u003ccode\u003eimport Base.show\u003c/code\u003e。只有通过 \u003ccode\u003eusing\u003c/code\u003e 才能看到名字的函数不能被扩展。\u003c/p\u003e\n\u003cp\u003e一旦一个变量通过 \u003ccode\u003eusing\u003c/code\u003e 或 \u003ccode\u003eimport\u003c/code\u003e 变得可见，一个模块就不能创建自己的同名变量。导入的变量是只读的，分配给全局变量总是会影响到当前模块所拥有的变量，否则会引发错误。\u003c/p\u003e\n\u003ch2 id=\"模块使用情况概述\"\u003e模块使用情况概述\u003c/h2\u003e\n\u003cp\u003e要加载一个模块，可以使用两个主要的关键词：\u003ccode\u003eusing\u003c/code\u003e 和 \u003ccode\u003eimport\u003c/code\u003e。要了解它们的区别，请看下面的例子。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-julia\" data-lang=\"julia\"\u003e\u003cspan class=\"k\"\u003emodule\u003c/span\u003e \u003cspan class=\"n\"\u003eMyModule\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;x\u0026#34;\u003c/span\u003e\n\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;y\u0026#34;\u003c/span\u003e\n\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;p\u0026#34;\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在这个模块中，我们导出了 \u003ccode\u003ex\u003c/code\u003e 和 \u003ccode\u003ey\u003c/code\u003e 函数(用关键字 \u003ccode\u003eexport\u003c/code\u003e)，也有非导出的函数 \u003ccode\u003ep\u003c/code\u003e，有几种不同的方法可以将 \u003ccode\u003eModule\u003c/code\u003e 及其内部函数加载到当前的工作空间中。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e导入命令\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e带入带作用域中的东西\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e可用于方法扩展\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eusing MyModule\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e所有导出的名字(\u003ccode\u003ex\u003c/code\u003e 和 \u003ccode\u003ey\u003c/code\u003e), \u003ccode\u003eMyModule.x\u003c/code\u003e, \u003ccode\u003eMyModule.y\u003c/code\u003e 和 \u003ccode\u003eMyModule.p\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eMyModule.x\u003c/code\u003e, \u003ccode\u003eMyModule.y\u003c/code\u003e 和 \u003ccode\u003eMyModule.p\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eusing MyModule: x, p\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex\u003c/code\u003e 和 \u003ccode\u003ep\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eimport MyModule\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eMyModule.x\u003c/code\u003e, \u003ccode\u003eMyModule.y\u003c/code\u003e 和 \u003ccode\u003eMyModule.p\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eMyModule.x\u003c/code\u003e, \u003ccode\u003eMyModule.y\u003c/code\u003e 和 \u003ccode\u003eMyModule.p\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eimport MyModule.x, MyModule.p\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex\u003c/code\u003e 和 \u003ccode\u003ep\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex\u003c/code\u003e 和 \u003ccode\u003ep\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eimport MyModule: x, p\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex\u003c/code\u003e 和 \u003ccode\u003ep\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex\u003c/code\u003e 和 \u003ccode\u003ep\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"模块和文件\"\u003e模块和文件\u003c/h2\u003e\n\u003cp\u003e文件和文件名大多与模块无关，模块只与模块表达式有关。一个模块可以有多个文件，一个文件可以有多个模块。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-julia\" data-lang=\"julia\"\u003e\u003cspan class=\"k\"\u003emodule\u003c/span\u003e \u003cspan class=\"n\"\u003eFoo\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003einclude\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;file1.jl\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"n\"\u003einclude\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;file2.jl\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在不同的模块中包含相同的代码，提供了类似 mixin 的行为。人们可以使用这一点来用不同的基础定义来运行相同的代码，例如，通过使用某些操作符的\u0026quot;安全\u0026quot;版本来测试代码。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-julia\" data-lang=\"julia\"\u003e\u003cspan class=\"k\"\u003emodule\u003c/span\u003e \u003cspan class=\"n\"\u003eNormal\u003c/span\u003e\n\u003cspan class=\"n\"\u003einclude\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;mycode.jl\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"k\"\u003eend\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003emodule\u003c/span\u003e \u003cspan class=\"n\"\u003eTesting\u003c/span\u003e\n\u003cspan class=\"n\"\u003einclude\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;safe_operators.jl\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"n\"\u003einclude\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;mycode.jl\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"k\"\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"标准模块\"\u003e标准模块\u003c/h2\u003e\n\u003cp\u003eThere are three important standard modules:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://docs.julialang.org/en/v1/base/base/#Core\"\u003eCore\u003c/a\u003e 包含\u0026quot;内置于\u0026quot;语言中的所有功能。\n\u003ca href=\"https://docs.julialang.org/en/v1/base/base/#Base\"\u003eBase\u003c/a\u003e 包含几乎在所有情况下都有用的基本功能。\n\u003ca href=\"https://docs.julialang.org/en/v1/base/base/#Main\"\u003eMain\u003c/a\u003e 是当 Julia 被启动时的顶级模块和当前模块。\u003c/p\u003e\n\u003ch2 id=\"默认的顶层定义和裸模块\"\u003e默认的顶层定义和裸模块\u003c/h2\u003e\n\u003cp\u003e除了 \u003ccode\u003eusing Base\u003c/code\u003e 之外，模块还自动包含 \u003ca href=\"https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.eval\"\u003eeval\u003c/a\u003e和 \u003ca href=\"https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.include\"\u003einclude\u003c/a\u003e 函数的定义，这些函数在该模块的全局作用域内评估表达式/文件。\u003c/p\u003e\n\u003cp\u003e如果不想要这些默认的定义，可以使用关键字 \u003ca href=\"https://docs.julialang.org/en/v1/base/base/#baremodule\"\u003ebaremodule\u003c/a\u003e 来代替定义模块（注意： \u003ccode\u003eCore\u003c/code\u003e 仍然是导入的，如上所述）。以 \u003ccode\u003ebaremodule\u003c/code\u003e 来说，一个标准的模块是这样的。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-julia\" data-lang=\"julia\"\u003e\u003cspan class=\"k\"\u003ebaremodule\u003c/span\u003e \u003cspan class=\"n\"\u003eMod\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eusing\u003c/span\u003e \u003cspan class=\"n\"\u003eBase\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eeval\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eCore\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eeval\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eMod\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"n\"\u003einclude\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBase\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003einclude\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eMod\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"相对和绝对模块路径\"\u003e相对和绝对模块路径\u003c/h2\u003e\n\u003cp\u003e给定 \u003ccode\u003eusing Foo\u003c/code\u003e 语句，系统会查询内部的顶层模块表，寻找一个名为 \u003ccode\u003eFoo\u003c/code\u003e 的模块。如果该模块不存在，系统会尝试 \u003ccode\u003erequire(:Foo)\u003c/code\u003e，这通常会导致从安装的包中加载代码。\u003c/p\u003e\n\u003cp\u003e然而，有些模块包含子模块，这意味着你有时需要访问一个非顶层模块。有两种方法可以做到这一点。第一种是使用绝对路径，例如 \u003ccode\u003eusing Base.Sort\u003c/code\u003e。第二种是使用相对路径，这样可以更容易地导入当前模块的子模块或其任何一个外层模块。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-julia\" data-lang=\"julia\"\u003e\u003cspan class=\"k\"\u003emodule\u003c/span\u003e \u003cspan class=\"n\"\u003eParent\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003emodule\u003c/span\u003e \u003cspan class=\"n\"\u003eUtils\u003c/span\u003e\n\u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003cspan class=\"k\"\u003eend\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eusing\u003c/span\u003e \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eUtils\u003c/span\u003e\n\n\u003cspan class=\"o\"\u003e...\u003c/span\u003e\n\u003cspan class=\"k\"\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这里模块 \u003ccode\u003eParent\u003c/code\u003e 包含一个子模块 \u003ccode\u003eUtils\u003c/code\u003e，\u003ccode\u003eParent\u003c/code\u003e 中的代码希望 \u003ccode\u003eUtils\u003c/code\u003e 的内容可见。这可以通过在 \u003ccode\u003eusing\u003c/code\u003e 路径中使用点号来实现。添加更多的前导点号会使模块的层次结构上升。例如，\u003ccode\u003eusing ..Utils\u003c/code\u003e 会在 \u003ccode\u003eParent\u003c/code\u003e 的外层模块中查找\u003ccode\u003eUtils\u003c/code\u003e，而不是在 \u003ccode\u003eParent\u003c/code\u003e 本身中查找。\u003c/p\u003e\n\u003cp\u003e注意相对导入限定符只在使用和导入语句中有效。\u003c/p\u003e\n\u003ch2 id=\"命名空间杂项\"\u003e命名空间杂项\u003c/h2\u003e\n\u003cp\u003e如果一个名字是限定的(例如 \u003ccode\u003eBase.sin\u003c/code\u003e)，那么即使它没有被导出，也可以被访问。这在调试时往往很有用。它也可以通过使用限定名作为函数名来添加方法。但是，由于会产生语法上的歧义，如果你想给不同模块中的一个函数添加方法，而这个函数的名称只包含符号，例如一个运算符，\u003ccode\u003eBase.+\u003c/code\u003e，你必须使用 \u003ccode\u003eBase.:+\u003c/code\u003e 来引用它。如果运算符的长度超过一个字符，你必须用括号把它括起来，比如 \u003ccode\u003eBase.:(==)\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e在导入和导出语句中，宏的名称用 \u003ccode\u003e@\u003c/code\u003e 书写，例如 \u003ccode\u003eimport Mod.@mac\u003c/code\u003e。其他模块中的宏可以用 \u003ccode\u003eMod.@mac\u003c/code\u003e 或 \u003ccode\u003e@Mod.mac\u003c/code\u003e 来调用。\u003c/p\u003e\n\u003cp\u003e语法 \u003ccode\u003eM.x = y\u003c/code\u003e 不能用于分配其他模块中的全局，全局分配总是模块-局部的。\u003c/p\u003e\n\u003cp\u003e变量名可以通过声明为 \u003ccode\u003eglobal x\u003c/code\u003e 来 \u0026ldquo;保留\u0026quot;而不分配给它，这样可以防止加载后初始化的 globals 的名称冲突。\u003c/p\u003e\n\u003ch2 id=\"模块初始化和预编译\"\u003e模块初始化和预编译\u003c/h2\u003e\n\u003cp\u003e大型模块可能需要几秒钟的时间来加载，因为执行一个模块中的所有语句往往需要编译大量的代码。Julia 创建了模块的预编译缓存来减少这个时间。\u003c/p\u003e\n\u003cp\u003e当使用 \u003ccode\u003eimport\u003c/code\u003e 或 \u003ccode\u003eusing\u003c/code\u003e 加载模块时，会自动创建并使用增量的预编译模块文件。这将导致它在第一次导入时自动编译。另外，您也可以手动调用 \u003ca href=\"https://docs.julialang.org/en/v1/base/base/#Base.compilecache\"\u003eBase.compilecache(modulename)\u003c/a\u003e。由此产生的缓存文件将存储在 \u003ccode\u003eDEPOT_PATH[1]/compiled/\u003c/code\u003e 中。随后，只要模块的任何依赖关系发生变化，模块就会在 \u003ccode\u003eusing\u003c/code\u003e 或 \u003ccode\u003eimport\u003c/code\u003e 时自动重新编译；依赖关系是指导入的模块、Julia 构建的模块、包含的文件，或者模块文件中 \u003ca href=\"https://docs.julialang.org/en/v1/base/base/#Base.include_dependency\"\u003einclude_dependency(path)\u003c/a\u003e 声明的显式依赖关系。\u003c/p\u003e\n\u003cp\u003e对于文件依赖，通过检查由 \u003ccode\u003einclude\u003c/code\u003e 加载的文件或由 \u003ccode\u003einclude_dependency\u003c/code\u003e 显式添加的文件的修改时间(mtime)是否保持不变，或者是否等于被截断到最接近秒的修改时间(以适应无法以亚秒级精度复制 mtime 的系统)来确定变化。它还考虑到在 \u003ccode\u003erequire\u003c/code\u003e 中搜索逻辑选择的文件路径是否与创建预编译文件的路径匹配。它还会考虑到已经加载到当前进程中的一组依赖关系，即使这些模块的文件发生变化或消失，也不会重新编译这些模块，以避免在运行系统和预编译缓存之间产生不兼容的情况。\u003c/p\u003e\n\u003cp\u003e如果你知道某个模块预编译你的模块是不安全的（例如，出于下面描述的原因之一），你应该在模块文件中加上 \u003ccode\u003e__precompile__(false)\u003c/code\u003e（通常放在顶部）。这将导致 \u003ccode\u003eBase.compilecache\u003c/code\u003e 抛出一个错误，并将导致 \u003ccode\u003eusing\u003c/code\u003e / \u003ccode\u003eimport\u003c/code\u003e 直接将其加载到当前进程中而跳过预编译和缓存。这也因此阻止了该模块被任何其他预编译模块导入。\u003c/p\u003e\n\u003cp\u003e您可能需要注意创建增量共享库时固有的某些行为，在编写模块时可能需要注意。例如，外部状态不会被保存。为了适应这一点，明确地将任何必须在运行时发生的初始化步骤与可以在编译时发生的步骤分开。为此，Julia 允许您在您的模块中定义一个 \u003ccode\u003e__init__()\u003c/code\u003e 函数来执行任何必须在运行时发生的初始化步骤。这个函数在编译时不会被调用（\u003ccode\u003e--output-*\u003c/code\u003e）。实际上，你可以假设它在代码的生命周期中只运行一次。当然，如果有必要的话，你可以手动调用它，但是默认情况下，你可以假设这个函数处理的是本地机器的计算状态，它不需要\u0026ndash;甚至不应该\u0026ndash;在编译后的镜像中捕获。它将在模块被加载到一个进程后被调用，包括如果它被加载到增量编译中(\u003ccode\u003e--output-incremental=yes\u003c/code\u003e)，但如果它被加载到一个完整的编译进程中，则不会被调用。\u003c/p\u003e\n\u003cp\u003e特别是，如果你在一个模块中定义了一个 \u003ccode\u003efunction __init__()\u003c/code\u003e，那么 Julia 将在模块被加载后（例如通过 \u003ccode\u003eimport\u003c/code\u003e、\u003ccode\u003eusing\u003c/code\u003e 或 \u003ccode\u003erequire\u003c/code\u003e）在运行时第一次立即调用 \u003ccode\u003e__init__()\u003c/code\u003e（也就是说，\u003ccode\u003e__init__\u003c/code\u003e 只被调用一次，而且是在模块中的所有语句被执行后才被调用）。因为它是在模块完全导入之后被调用的，所以任何子模块或其它导入的模块都会在外层模块的 \u003ccode\u003e__init__\u003c/code\u003e 之前调用它们的 \u003ccode\u003e__init__\u003c/code\u003e 函数。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__init__\u003c/code\u003e 的两个典型用途是调用外部 C 库的运行时初始化函数和初始化涉及外部库返回指针的全局常量。例如，假设我们正在调用一个 C 库 \u003ccode\u003elibfoo\u003c/code\u003e，它要求我们在运行时调用 \u003ccode\u003efoo_init()\u003c/code\u003e 初始化函数。假设我们还想定义一个全局常量 \u003ccode\u003efoo_data_ptr\u003c/code\u003e，用来存放 \u003ccode\u003elibfoo\u003c/code\u003e 定义的 \u003ccode\u003evoid *foo_data()\u003c/code\u003e 函数的返回值\u0026ndash;这个常量必须在运行时（而不是在编译时）初始化，因为指针地址会随着运行而改变。你可以通过在你的模块中定义下面的 \u003ccode\u003e__init__\u003c/code\u003e 函数来实现。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-julia\" data-lang=\"julia\"\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003efoo_data_ptr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kt\"\u003eRef\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"kt\"\u003ePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"kt\"\u003eCvoid\u003c/span\u003e\u003cspan class=\"p\"\u003e}}(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"k\"\u003efunction\u003c/span\u003e \u003cspan class=\"n\"\u003e__init__\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eccall\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"ss\"\u003e:foo_init\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"ss\"\u003e:libfoo\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"kt\"\u003eCvoid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e())\u003c/span\u003e\n    \u003cspan class=\"n\"\u003efoo_data_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003eccall\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"ss\"\u003e:foo_data\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"ss\"\u003e:libfoo\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"kt\"\u003ePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"kt\"\u003eCvoid\u003c/span\u003e\u003cspan class=\"p\"\u003e},\u003c/span\u003e \u003cspan class=\"p\"\u003e())\u003c/span\u003e\n    \u003cspan class=\"nb\"\u003enothing\u003c/span\u003e\n\u003cspan class=\"k\"\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e请注意，我们完全可以在函数内部定义一个全局，比如 \u003ccode\u003e__init__\u003c/code\u003e；这是使用动态语言的优势之一。但是通过在全局作用域内定义一个常量，我们可以确保编译器知道这个类型，并允许它生成更好的优化代码。显然，你的模块中任何其他依赖于 \u003ccode\u003efoo_data_ptr\u003c/code\u003e 的 globals 也必须在 \u003ccode\u003e__init__\u003c/code\u003e 中初始化。\u003c/p\u003e\n\u003cp\u003e涉及大多数不是由 \u003ca href=\"https://docs.julialang.org/en/v1/base/c/#ccall\"\u003eccall\u003c/a\u003e 产生的 Julia 对象的常量不需要放在 \u003ccode\u003e__init__\u003c/code\u003e 中：它们的定义可以被预编译并从缓存的模块映像中加载。这包括像数组这样复杂的堆分配对象。然而，任何返回原始指针值的例程都必须在运行时调用，以便预编译工作（\u003ca href=\"https://docs.julialang.org/en/v1/base/c/#Core.Ptr\"\u003ePtr\u003c/a\u003e 对象将变成空指针，除非它们被隐藏在 \u003ca href=\"https://docs.julialang.org/en/v1/base/base/#Base.isbits\"\u003eisbits\u003c/a\u003e 对象中）。这包括 Julia 函数 \u003ccode\u003ecfunction\u003c/code\u003e 和 \u003ca href=\"https://docs.julialang.org/en/v1/base/c/#Base.pointer\"\u003epointer\u003c/a\u003e 的返回值。\u003c/p\u003e\n\u003cp\u003e字典和集合类型，或者一般来说任何依赖于 \u003ccode\u003ehash(key)\u003c/code\u003e 方法输出的东西，都是比较棘手的情况。在常见的情况下，键是数字、字符串、符号、范围、\u003ccode\u003eExpr\u003c/code\u003e 或这些类型的组合（通过数组、元组、集合、对等），它们可以安全地进行预编译。然而，对于其他一些关键类型，如 \u003ccode\u003eFunction\u003c/code\u003e 或 \u003ccode\u003eDataType\u003c/code\u003e 和通用的用户定义类型，在这些类型中，你没有定义 \u003ccode\u003ehash\u003c/code\u003e 方法，回退 \u003ccode\u003ehash\u003c/code\u003e 方法取决于对象的内存地址（通过它的 \u003ccode\u003eobjectid\u003c/code\u003e），因此可能会在运行时改变。如果你有这些键类型之一，或者如果你不确定，为了安全起见，你可以在你的 \u003ccode\u003e__init__\u003c/code\u003e 函数中初始化这个字典。或者，你也可以使用 \u003ca href=\"https://docs.julialang.org/en/v1/base/collections/#Base.IdDict\"\u003eIdDict\u003c/a\u003e 字典类型，它由预编译特别处理，所以在编译时初始化是安全的。\u003c/p\u003e\n\u003cp\u003e在使用预编译时，保持对编译阶段和执行阶段的清晰认识很重要。在这种模式下，往往会更清楚地认识到 Julia 是一个允许执行任意 Julia 代码的编译器，而不是一个同时生成编译代码的独立解释器。\u003c/p\u003e\n\u003cp\u003e其他已知的潜在故障情况包括。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e全局计数器（例如，用于试图唯一识别对象）。考虑以下代码片段。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-julia\" data-lang=\"julia\"\u003e\u003cspan class=\"k\"\u003emutable struct\u003c/span\u003e \u003cspan class=\"kt\"\u003eUniquedById\u003c/span\u003e\n    \u003cspan class=\"n\"\u003emyid\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"kt\"\u003eInt\u003c/span\u003e\n    \u003cspan class=\"k\"\u003elet\u003c/span\u003e \u003cspan class=\"n\"\u003ecounter\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eUniquedById\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enew\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecounter\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eend\u003c/span\u003e\n\u003cspan class=\"k\"\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e虽然这段代码的目的是给每个实例一个唯一的 id，但计数器的值是在编译结束时记录的。这个增量编译模块的所有后续使用将从同一个计数器值开始。\u003c/p\u003e\n\u003cp\u003e请注意，\u003ccode\u003eobjectid\u003c/code\u003e（通过哈希内存指针工作）也有类似的问题（参见下面关于 \u003ccode\u003eDict\u003c/code\u003e 用法的说明）。\u003c/p\u003e\n\u003cp\u003e一种替代方法是使用宏来捕获 \u003ca href=\"https://docs.julialang.org/en/v1/base/base/#Base.@__MODULE__\"\u003e@\u003cstrong\u003eMODULE\u003c/strong\u003e\u003c/a\u003e，并将其与当前的计数器值一起单独存储，然而，重新设计代码使其不依赖于这个全局状态可能会更好。\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\n\u003cp\u003e关联集合(比如 \u003ccode\u003eDict\u003c/code\u003e 和 \u003ccode\u003eSet\u003c/code\u003e)需要在 \u003ccode\u003e__init__\u003c/code\u003e 中重新洗牌(将来可能会提供一个机制来注册一个初始化函数)。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e根据编译时的副作用在加载时持续存在。例如：修改其他 Julia 模块中的数组或其他变量；维护打开的文件或设备的句柄；存储其他系统资源（包括内存）的指针。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e通过直接引用而不是通过它的查找路径，从另一个模块创建意外的全局状态\u0026quot;副本\u0026rdquo;。例如，（在全局作用域内）。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-julia\" data-lang=\"julia\"\u003e\u003cspan class=\"c\"\u003e#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#\u003c/span\u003e\n\u003cspan class=\"c\"\u003e# instead use accessor functions:\u003c/span\u003e\n\u003cspan class=\"n\"\u003egetstdout\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBase\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003estdout\u003c/span\u003e \u003cspan class=\"cm\"\u003e#= best option =#\u003c/span\u003e\n\u003cspan class=\"c\"\u003e# or move the assignment into the runtime:\u003c/span\u003e\n\u003cspan class=\"n\"\u003e__init__\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003eglobal\u003c/span\u003e \u003cspan class=\"n\"\u003emystdout\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBase\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003estdout\u003c/span\u003e \u003cspan class=\"cm\"\u003e#= also works =#\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e对预编译代码时可以进行的操作进行了一些额外的限制，以帮助用户避免其他错误行为的情况。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e调用 \u003ca href=\"https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.eval\"\u003eeval\u003c/a\u003e 引起另一个模块的副作用。当增量预编译标志被设置时，这也会导致发出警告。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在 \u003ccode\u003e__init__()\u003c/code\u003e 被启动后，从本地作用域调用 \u003ccode\u003eglobal const\u003c/code\u003e 语句(参见问题 \u003ccode\u003e#12010\u003c/code\u003e，计划为此增加一个错误)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在进行增量预编译时，替换一个模块是一个运行时错误。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e还有几点需要注意。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e在对源文件本身进行修改之后，不会进行代码重载/缓存无效化（包括通过 \u003ccode\u003ePkg.update\u003c/code\u003e），而且在 \u003ccode\u003ePkg.rm\u003c/code\u003e 之后也不会进行清理。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e预编译不考虑重塑数组的内存共享行为 (每个视图都有自己的副本)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e期待文件系统在编译时和运行时之间保持不变，例如 \u003ca href=\"https://docs.julialang.org/en/v1/base/file/#Base.@__FILE__\"\u003e@\u003cstrong\u003eFILE\u003c/strong\u003e\u003c/a\u003e/\u003ccode\u003esource_path()\u003c/code\u003e 在运行时查找资源，或者 BinDeps 的 \u003ccode\u003e@checked_lib\u003c/code\u003e 宏。有时这是不可避免的。然而，在可能的情况下，在编译时将资源复制到模块中是一个很好的做法，这样它们就不需要在运行时被找到。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eWeakRef\u003c/code\u003e 对象和 finalizers 目前还没有被序列化器正确处理（这将在即将发布的版本中得到修正）。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e通常最好避免捕获对内部元数据对象实例的引用，如 \u003ccode\u003eMethod\u003c/code\u003e、\u003ccode\u003eMethodInstance\u003c/code\u003e、\u003ccode\u003eMethodTable\u003c/code\u003e、\u003ccode\u003eTypeMapLevel\u003c/code\u003e、\u003ccode\u003eTypeMapEntry\u003c/code\u003e 以及这些对象的字段，因为这可能会混淆序列化器，可能不会导致你想要的结果。这样做不一定会出错，但你只需要做好准备，系统会尝试复制其中的一些对象，并为其他对象创建一个唯一的实例。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在模块开发过程中，有时关闭增量预编译是很有帮助的。命令行标志 \u003ccode\u003e--compiled-modules={yes|no}\u003c/code\u003e 可以让你开启或关闭模块预编译。当 Julia 以 \u003ccode\u003e--compiled-modules=no\u003c/code\u003e 启动时，当加载模块和模块依赖时，编译缓存中的序列化模块会被忽略。\u003ccode\u003eBase.compilecache\u003c/code\u003e 仍然可以被手动调用。这个命令行标志的状态被传递给 \u003ccode\u003ePkg.build\u003c/code\u003e，以便在安装、更新和显式构建包时禁用自动预编译触发。\u003c/p\u003e\n","text":"模块 Julia 中的模块是独立的变量工作空间，即它们引入了一个新的全局作用域。它们在语法上是有分界的，在 module Name ... end 里面。模块允许您创建顶层定义（也就是全局变量），而不用担心您的代码与别人的代码一起使用时的名称冲突。在一个模块中，你可以控制哪些来自其他模块的名字是可见的（通过导入），并指定哪些名字是要公开的（通过导出）。\n下面的例子展示了模块的主要功能。这个例子并不是为了运行，而是为了说明问题。\nmodule MyModule using Lib using BigLib: thing1, thing2 import Base.show export MyType, foo struct MyType x end bar(x) = 2x foo(a::MyType) = bar(a.x) + 1 show(io::IO, a::MyType) = print(io, \u0026#34;MyType $(a.x)\u0026#34;) end 需要注意的是，这个样式并不是要在模块的正文中缩进，因为这通常会导致整个文件被缩进。\n这个模块定义了一个 MyType 类型和两个函数。函数 foo 和 MyType 类型是导出的，因此可以导入到其他模块中。函数 bar 是 MyModule 的私有函数。\nusing Lib 语句意味着将有一个名为 Lib 的模块可以根据需要解析名称。当遇到一个全局变量在当前模块中没有定义时，系统会在 Lib 导出的变量中搜索它，如果在那里找到了，就会导入它。这意味着在当前模块内对该全局的所有使用都将解析为该变量在 Lib 中的定义。\nusing BigLib: thing1, thing2 语句，只将标识符 thing1 和 thing2 从模块 BigLib 中带入作用域。如果这些名称指的是函数，那么将不允许向它们添加方法（你只能 \u0026ldquo;使用 \u0026ldquo;它们，而不是扩展它们）。\nimport 关键字支持与 using 相同的语法。import 与 using 的不同之处在于，使用 import 导入的函数可以用新的方法进行扩展。\n在上面的 MyModule 中，我们想给标准的 show 函数添加一个方法，所以我们必须写 import Base.show。只有通过 using 才能看到名字的函数不能被扩展。\n一旦一个变量通过 using 或 import 变得可见，一个模块就不能创建自己的同名变量。导入的变量是只读的，分配给全局变量总是会影响到当前模块所拥有的变量，否则会引发错误。\n模块使用情况概述 要加载一个模块，可以使用两个主要的关键词：using 和 import。要了解它们的区别，请看下面的例子。\nmodule MyModule export x, y x() = \u0026#34;x\u0026#34; y() = \u0026#34;y\u0026#34; p() = \u0026#34;p\u0026#34; end 在这个模块中，我们导出了 x 和 y 函数(用关键字 export)，也有非导出的函数 p，有几种不同的方法可以将 Module 及其内部函数加载到当前的工作空间中。\n   导入命令 带入带作用域中的东西 可用于方法扩展     using MyModule 所有导出的名字(x 和 y), MyModule.x, MyModule.y 和 MyModule.p MyModule.x, MyModule.y 和 MyModule.p   using MyModule: x, p x 和 p    import MyModule MyModule.x, MyModule.y 和 MyModule.p MyModule.x, MyModule.y 和 MyModule.p   import MyModule.x, MyModule.p x 和 p x 和 p   import MyModule: x, p x 和 p x 和 p    模块和文件 文件和文件名大多与模块无关，模块只与模块表达式有关。一个模块可以有多个文件，一个文件可以有多个模块。\nmodule Foo include(\u0026#34;file1.jl\u0026#34;) include(\u0026#34;file2.jl\u0026#34;) end 在不同的模块中包含相同的代码，提供了类似 mixin 的行为。人们可以使用这一点来用不同的基础定义来运行相同的代码，例如，通过使用某些操作符的\u0026quot;安全\u0026quot;版本来测试代码。\nmodule Normal include(\u0026#34;mycode.jl\u0026#34;) end module Testing include(\u0026#34;safe_operators.jl\u0026#34;) include(\u0026#34;mycode.jl\u0026#34;) end 标准模块 There are three important standard modules:\nCore 包含\u0026quot;内置于\u0026quot;语言中的所有功能。 Base 包含几乎在所有情况下都有用的基本功能。 Main 是当 Julia 被启动时的顶级模块和当前模块。\n默认的顶层定义和裸模块 除了 using Base 之外，模块还自动包含 eval和 include 函数的定义，这些函数在该模块的全局作用域内评估表达式/文件。\n如果不想要这些默认的定义，可以使用关键字 baremodule 来代替定义模块（注意： Core 仍然是导入的，如上所述）。以 baremodule 来说，一个标准的模块是这样的。\nbaremodule Mod using Base eval(x) = Core.eval(Mod, x) include(p) = Base.include(Mod, p) ... end 相对和绝对模块路径 给定 using Foo 语句，系统会查询内部的顶层模块表，寻找一个名为 Foo 的模块。如果该模块不存在，系统会尝试 require(:Foo)，这通常会导致从安装的包中加载代码。\n然而，有些模块包含子模块，这意味着你有时需要访问一个非顶层模块。有两种方法可以做到这一点。第一种是使用绝对路径，例如 using Base.Sort。第二种是使用相对路径，这样可以更容易地导入当前模块的子模块或其任何一个外层模块。\nmodule Parent module Utils ... end using .Utils ... end 这里模块 Parent 包含一个子模块 Utils，Parent 中的代码希望 Utils 的内容可见。这可以通过在 using 路径中使用点号来实现。添加更多的前导点号会使模块的层次结构上升。例如，using ..Utils 会在 Parent 的外层模块中查找Utils，而不是在 Parent 本身中查找。\n注意相对导入限定符只在使用和导入语句中有效。\n命名空间杂项 如果一个名字是限定的(例如 Base.sin)，那么即使它没有被导出，也可以被访问。这在调试时往往很有用。它也可以通过使用限定名作为函数名来添加方法。但是，由于会产生语法上的歧义，如果你想给不同模块中的一个函数添加方法，而这个函数的名称只包含符号，例如一个运算符，Base.+，你必须使用 Base.:+ 来引用它。如果运算符的长度超过一个字符，你必须用括号把它括起来，比如 Base.:(==)。\n在导入和导出语句中，宏的名称用 @ 书写，例如 import Mod.@mac。其他模块中的宏可以用 Mod.@mac 或 @Mod.mac 来调用。\n语法 M.x = y 不能用于分配其他模块中的全局，全局分配总是模块-局部的。\n变量名可以通过声明为 global x 来 \u0026ldquo;保留\u0026quot;而不分配给它，这样可以防止加载后初始化的 globals 的名称冲突。\n模块初始化和预编译 大型模块可能需要几秒钟的时间来加载，因为执行一个模块中的所有语句往往需要编译大量的代码。Julia 创建了模块的预编译缓存来减少这个时间。\n当使用 import 或 using 加载模块时，会自动创建并使用增量的预编译模块文件。这将导致它在第一次导入时自动编译。另外，您也可以手动调用 Base.compilecache(modulename)。由此产生的缓存文件将存储在 DEPOT_PATH[1]/compiled/ 中。随后，只要模块的任何依赖关系发生变化，模块就会在 using 或 import 时自动重新编译；依赖关系是指导入的模块、Julia 构建的模块、包含的文件，或者模块文件中 include_dependency(path) 声明的显式依赖关系。\n对于文件依赖，通过检查由 include 加载的文件或由 include_dependency 显式添加的文件的修改时间(mtime)是否保持不变，或者是否等于被截断到最接近秒的修改时间(以适应无法以亚秒级精度复制 mtime 的系统)来确定变化。它还考虑到在 require 中搜索逻辑选择的文件路径是否与创建预编译文件的路径匹配。它还会考虑到已经加载到当前进程中的一组依赖关系，即使这些模块的文件发生变化或消失，也不会重新编译这些模块，以避免在运行系统和预编译缓存之间产生不兼容的情况。\n如果你知道某个模块预编译你的模块是不安全的（例如，出于下面描述的原因之一），你应该在模块文件中加上 __precompile__(false)（通常放在顶部）。这将导致 Base.compilecache 抛出一个错误，并将导致 using / import 直接将其加载到当前进程中而跳过预编译和缓存。这也因此阻止了该模块被任何其他预编译模块导入。\n您可能需要注意创建增量共享库时固有的某些行为，在编写模块时可能需要注意。例如，外部状态不会被保存。为了适应这一点，明确地将任何必须在运行时发生的初始化步骤与可以在编译时发生的步骤分开。为此，Julia 允许您在您的模块中定义一个 __init__() 函数来执行任何必须在运行时发生的初始化步骤。这个函数在编译时不会被调用（--output-*）。实际上，你可以假设它在代码的生命周期中只运行一次。当然，如果有必要的话，你可以手动调用它，但是默认情况下，你可以假设这个函数处理的是本地机器的计算状态，它不需要\u0026ndash;甚至不应该\u0026ndash;在编译后的镜像中捕获。它将在模块被加载到一个进程后被调用，包括如果它被加载到增量编译中(--output-incremental=yes)，但如果它被加载到一个完整的编译进程中，则不会被调用。\n特别是，如果你在一个模块中定义了一个 function __init__()，那么 Julia 将在模块被加载后（例如通过 import、using 或 require）在运行时第一次立即调用 __init__()（也就是说，__init__ 只被调用一次，而且是在模块中的所有语句被执行后才被调用）。因为它是在模块完全导入之后被调用的，所以任何子模块或其它导入的模块都会在外层模块的 __init__ 之前调用它们的 __init__ 函数。\n__init__ 的两个典型用途是调用外部 C 库的运行时初始化函数和初始化涉及外部库返回指针的全局常量。例如，假设我们正在调用一个 C 库 libfoo，它要求我们在运行时调用 foo_init() 初始化函数。假设我们还想定义一个全局常量 foo_data_ptr，用来存放 libfoo 定义的 void *foo_data() 函数的返回值\u0026ndash;这个常量必须在运行时（而不是在编译时）初始化，因为指针地址会随着运行而改变。你可以通过在你的模块中定义下面的 __init__ 函数来实现。\nconst foo_data_ptr = Ref{Ptr{Cvoid}}(0) function __init__() ccall((:foo_init, :libfoo), Cvoid, ()) foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ()) nothing end 请注意，我们完全可以在函数内部定义一个全局，比如 __init__；这是使用动态语言的优势之一。但是通过在全局作用域内定义一个常量，我们可以确保编译器知道这个类型，并允许它生成更好的优化代码。显然，你的模块中任何其他依赖于 foo_data_ptr 的 globals 也必须在 __init__ 中初始化。\n涉及大多数不是由 ccall 产生的 Julia 对象的常量不需要放在 __init__ 中：它们的定义可以被预编译并从缓存的模块映像中加载。这包括像数组这样复杂的堆分配对象。然而，任何返回原始指针值的例程都必须在运行时调用，以便预编译工作（Ptr 对象将变成空指针，除非它们被隐藏在 isbits 对象中）。这包括 Julia 函数 cfunction 和 pointer 的返回值。\n字典和集合类型，或者一般来说任何依赖于 hash(key) 方法输出的东西，都是比较棘手的情况。在常见的情况下，键是数字、字符串、符号、范围、Expr 或这些类型的组合（通过数组、元组、集合、对等），它们可以安全地进行预编译。然而，对于其他一些关键类型，如 Function 或 DataType 和通用的用户定义类型，在这些类型中，你没有定义 hash 方法，回退 hash 方法取决于对象的内存地址（通过它的 objectid），因此可能会在运行时改变。如果你有这些键类型之一，或者如果你不确定，为了安全起见，你可以在你的 __init__ 函数中初始化这个字典。或者，你也可以使用 IdDict 字典类型，它由预编译特别处理，所以在编译时初始化是安全的。\n在使用预编译时，保持对编译阶段和执行阶段的清晰认识很重要。在这种模式下，往往会更清楚地认识到 Julia 是一个允许执行任意 Julia 代码的编译器，而不是一个同时生成编译代码的独立解释器。\n其他已知的潜在故障情况包括。\n 全局计数器（例如，用于试图唯一识别对象）。考虑以下代码片段。  mutable struct UniquedById myid::Int let counter = 0 UniquedById() = new(counter += 1) end end 虽然这段代码的目的是给每个实例一个唯一的 id，但计数器的值是在编译结束时记录的。这个增量编译模块的所有后续使用将从同一个计数器值开始。\n请注意，objectid（通过哈希内存指针工作）也有类似的问题（参见下面关于 Dict 用法的说明）。\n一种替代方法是使用宏来捕获 @MODULE，并将其与当前的计数器值一起单独存储，然而，重新设计代码使其不依赖于这个全局状态可能会更好。\n 关联集合(比如 Dict 和 Set)需要在 __init__ 中重新洗牌(将来可能会提供一个机制来注册一个初始化函数)。\n  根据编译时的副作用在加载时持续存在。例如：修改其他 Julia 模块中的数组或其他变量；维护打开的文件或设备的句柄；存储其他系统资源（包括内存）的指针。\n  通过直接引用而不是通过它的查找路径，从另一个模块创建意外的全局状态\u0026quot;副本\u0026rdquo;。例如，（在全局作用域内）。\n  #mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =# # instead use accessor functions: getstdout() = Base.stdout #= best option =# # or move the assignment into the runtime: __init__() = global mystdout = Base.stdout #= also works =# 对预编译代码时可以进行的操作进行了一些额外的限制，以帮助用户避免其他错误行为的情况。\n  调用 eval 引起另一个模块的副作用。当增量预编译标志被设置时，这也会导致发出警告。\n  在 __init__() 被启动后，从本地作用域调用 global const 语句(参见问题 #12010，计划为此增加一个错误)\n  在进行增量预编译时，替换一个模块是一个运行时错误。\n  还有几点需要注意。\n  在对源文件本身进行修改之后，不会进行代码重载/缓存无效化（包括通过 Pkg.update），而且在 Pkg.rm 之后也不会进行清理。\n  预编译不考虑重塑数组的内存共享行为 (每个视图都有自己的副本)\n  期待文件系统在编译时和运行时之间保持不变，例如 @FILE/source_path() 在运行时查找资源，或者 BinDeps 的 @checked_lib 宏。有时这是不可避免的。然而，在可能的情况下，在编译时将资源复制到模块中是一个很好的做法，这样它们就不需要在运行时被找到。\n  WeakRef 对象和 finalizers 目前还没有被序列化器正确处理（这将在即将发布的版本中得到修正）。\n  通常最好避免捕获对内部元数据对象实例的引用，如 Method、MethodInstance、MethodTable、TypeMapLevel、TypeMapEntry 以及这些对象的字段，因为这可能会混淆序列化器，可能不会导致你想要的结果。这样做不一定会出错，但你只需要做好准备，系统会尝试复制其中的一些对象，并为其他对象创建一个唯一的实例。\n  在模块开发过程中，有时关闭增量预编译是很有帮助的。命令行标志 --compiled-modules={yes|no} 可以让你开启或关闭模块预编译。当 Julia 以 --compiled-modules=no 启动时，当加载模块和模块依赖时，编译缓存中的序列化模块会被忽略。Base.compilecache 仍然可以被手动调用。这个命令行标志的状态被传递给 Pkg.build，以便在安装、更新和显式构建包时禁用自动预编译触发。\n"},"name":"Julia 中的 模块","published":"2020-08-05T00:00:00+08:00","summary":"Modules","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-08-05-modules-in-julia/"}],"name":"module","type":"feed","url":"https://ohmyweekly.github.io/tags/module/"}