<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.79.0">Hugo</generator><title type="html"><![CDATA[image on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/image/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/image/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/image/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/image/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2020-12-23T22:58:27+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/image/</id>
    
        
        <entry>
            <title type="html"><![CDATA[ImageMagick - Drawing]]></title>
            <link href="https://ohmyweekly.github.io/notes/imagemagick-drawing/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/imagemagick-notes/?utm_source=atom_feed" rel="related" type="text/html" title="ImageMagick 笔记" />
                <link href="https://ohmyweekly.github.io/notes/imagemagick-transform/?utm_source=atom_feed" rel="related" type="text/html" title="ImageMagick - Transform" />
            
                <id>https://ohmyweekly.github.io/notes/imagemagick-drawing/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-05T00:00:00+08:00</published>
            <updated>2020-07-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>ImageMagick Drawing</blockquote><p><a href="https://imagemagick.org/Usage/draw/">https://imagemagick.org/Usage/draw/</a></p>
<p>在 IM 中绘图是在现有图像中添加新元素的方法。虽然在<a href="https://imagemagick.org/Usage/fonts/">复合字体效果</a>的示例页和<a href="https://imagemagick.org/Usage/annotating/">图像注释</a>中涵盖了很多文本绘制的内容，但本页涉及 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?draw">-draw</a>&rdquo; 操作符的其他更普遍的方面。</p>
<p>绘制命令最初是作为一种创建简单图像的手段。但随着时间的推移，它已经扩展成为矢量图形到光栅图像转换的界面。</p>
<h2 id="imagemagick-绘制命令">ImageMagick 绘制命令</h2>
<p>计算机中的图像通常以两种不同的方式保存。第一种也是你在这些示例页面中看到的最常见的方式被称为光栅图形。在这种方式中，图像是以像素的矩形阵列来存储的。</p>
<p>另一种方式不太常见，也不太容易修改，但从另一个意义上讲，它的通用性更强，即对象矢量图形。在这种形式下，图像是用线条、弧线、颜色填充，有时还有深度来描述的。这是非常有用的，因为你可以将这些图像放大到你想要的任何尺寸，而且它们仍然可以完美地显示。与光栅格式的图像相比，您还可以在很小的空间内描述非常大和复杂的图像。</p>
<p>矢量图形图像的例子包括 postscript 和新的 <a href="http://www.w3.org/TR/SVG/">SVG-可缩放矢量图形</a>。</p>
<p>True-Type 字体也是矢量图形的例子，因为它允许在任何比例下使用单个字符描述。</p>
<p>&ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?draw">-draw</a>&rdquo; 图像操作符，是进入 ImageMagick 矢量绘图功能的一个窗口，并形成了一套与 IM 的普通命令行图像操作符相当独立的命令。</p>
<blockquote>
<p>一般使用的矢量图形文件格式只有几种，因为每一种这样的格式通常与其他这样的格式有很大的不同。其结果是，很少有代码共享的可能。
基于这个原因，ImageMagick 更关注使用矢量图形来绘制 SVG 格式的图像。Postscript 和 true-type 字体图形被传递给其他外部的&quot;<a href="https://imagemagick.org/Usage/files/#delegate">代理</a>&ldquo;库和应用程序，它们更适合绘制这些类型的矢量图形格式。
这并不是说 SVG 没有代理库。一个例子是 RSVG 库或 GTK SVG 库，这些库在编译时是可用的。IM 会链接到这些库来转换 SVG，而不是自己尝试去做。</p>
</blockquote>
<h3 id="原始绘图命令">原始绘图命令</h3>
<p>让我们从 MVG 命令的 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?draw">-draw</a>&rdquo; 图像操作符中最古老、最简单、最常见的绘图原语开始。</p>
<p>请注意，所有的参数都被视为浮点数，不一定是整数，比如我在这些例子中通常使用的。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Single Pixel Draw  (两种方式 -- 这些像素点都被放大了)</span>

  <span class="c1"># Point &#39;paints&#39; the color pixel</span>
  convert -size 10x6 xc:skyblue  -fill black <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;point 3,2&#39;</span>         -scale 100x60   draw_point.gif

  <span class="c1"># Color Point &#39;replaces&#39; the color pixel</span>
  convert -size 10x6 xc:skyblue  -fill black <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 6,3 point&#39;</span>   -scale 100x60   draw_color_point.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_point.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/draw_color_point.gif" alt="img"></p>
<p>根据给出的注释，当涉及半透明颜色时，这两种点方法会产生不同的结果。详情请参见下面的<a href="https://imagemagick.org/Usage/draw/#color">颜色填充原语</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># 矩形  /  圆角矩形  /  矩形圆弧</span>

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;rectangle 20,10 80,50&#34;</span>       draw_rect.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;roundrectangle 20,10 80,50 20,15&#34;</span>  draw_rrect.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;arc  20,10 80,50  0,360&#34;</span>     draw_arc.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;arc  20,10 80,50 45,270&#34;</span>     draw_arc_partial.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_rect.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/draw_rrect.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/draw_arc.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/draw_arc_partial.gif" alt="img"></p>
<p><code>arc</code> 绘制原语与矩形一起列出，因为它实际上只是一个&quot;椭圆&rdquo;，装在两个坐标定义的&quot;矩形&quot;(<code>rectangle</code>)内。部分弧线很少使用，因为很难确定端点，除非角度限制在九十度的倍数。</p>
<p><code>circle</code> 和 <code>ellipse</code> 原语涉及&quot;中心&quot;坐标与&quot;边缘&quot;坐标，或&quot;大小&quot;和&quot;角度&quot;值。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># 圆  /  椭圆    (以某一点为中心)</span>

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;circle 50,30 40,10&#34;</span>          draw_circle.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;ellipse 50,30 40,20 0,360&#34;</span>   draw_ellipse.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;ellipse 50,30 40,20 45,270&#34;</span>   draw_ellipse_partial.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_circle.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/draw_ellipse.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/draw_ellipse_partial.gif" alt="img"></p>
<p>你也可以看看 <a href="https://imagemagick.org/Usage/draw/#push_context">Push/Pop 上下文</a>，了解如何创建一个旋转的椭圆的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># 直线 / 折线 / 多边形 / 贝塞尔曲线</span>

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;line   20,50 90,10&#34;</span>                 draw_line.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;polyline 40,10 20,50 90,10 70,40&#34;</span>   draw_polyline.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;polygon  40,10 20,50 90,10 70,40&#34;</span>   draw_polygon.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;bezier   40,10 20,50 90,10 70,40&#34;</span>   draw_bezier.gif
</code></pre></div><p>比较好的画直线和曲线的方法是使用 <a href="https://imagemagick.org/Usage/draw/#paths">SVG 路径画法</a>，它的用途更广，甚至可以实现&quot;比例画线&quot;。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># text drawing  / image</span>

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -font Candice -pointsize <span class="m">40</span> -gravity center <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;text 0,0 &#39;Hello&#39;&#34;</span>   draw_text.gif

  convert -size 100x60 xc:skyblue -gravity center <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;image over 0,0 0,0 &#39;terminal.gif&#39;&#34;</span>   draw_image.gif
</code></pre></div><p>最后这两个填充类型的操作是目前唯一受 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?gravity">-gravity</a>&rdquo; 影响的绘制操作。这些操作的其他修饰符，包括 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?fill">-fill</a>&quot;、&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?tile">-tile</a>&quot;、&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?origin">-origin</a>&quot;、&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?stroke">-stroke</a>&quot;、&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?strokewidth">-strokeidth</a>&quot;、&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?font">-font</a>&quot;、&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?pointsize">-pointsize</a>&quot;、&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?box">-box</a>&quot;。他们还有其他的修饰符，但这些修饰符与更高级的 <a href="https://imagemagick.org/Usage/draw/#mvg">Magick Vector Graphics</a> 语言有关。</p>
<h2 id="贝赛尔原语">贝赛尔原语</h2>
<p>&ldquo;bezier&rdquo; 原语用于绘制曲线。每条命令只画一条曲线段。通常会给出 4 个点（8 个数字）：一个起点&rsquo;结'、两个控制点和一个终点&rsquo;结'。两个控制点定义了曲线的方向以及曲线偏离附加的终点&rsquo;结&rsquo;点的速度。</p>
<p>为了顺利地将两条曲线连接起来，应该将端点的控制点通过&rsquo;结&rsquo;镜像，形成下一条贝塞尔曲线的控制点。例如这里我画了两条平稳连接在一起的贝赛尔曲线。请注意控制线和点（也是画出来的）是如何通过连接坐标直线镜像的，无论是角度还是长度。这一点很重要，否则曲线将不平滑。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;10,10 30,90   25,10 50,50   50,50 75,90   70,10 90,40&#34;</span>
  <span class="nv">clines</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$points</span><span class="s2">&#34;</span> <span class="p">|</span> sed <span class="s1">&#39;s/   /\n/g&#39;</span> <span class="p">|</span><span class="se">\
</span><span class="se"></span>             <span class="k">while</span> <span class="nb">read</span> line<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s2">&#34;line </span><span class="nv">$line</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span><span class="sb">`</span>
  <span class="nv">symbols</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> path <span class="s2">&#34;&#39;&#34;</span><span class="p">;</span> <span class="k">for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
             <span class="nb">echo</span> <span class="s2">&#34;M </span><span class="nv">$point</span><span class="s2">   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2&#34;</span>
           <span class="k">done</span><span class="p">;</span>  <span class="nb">echo</span> <span class="s2">&#34;&#39;&#34;</span><span class="sb">`</span>

  convert -size 100x100 xc:skyblue -fill none <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke gray </span><span class="nv">$clines</span><span class="s2">    stroke blue </span><span class="nv">$symbols</span><span class="s2"> &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 10,10 30,90   25,10 50,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 50,50 75,90   70,10 90,40 &#34;</span> <span class="se">\
</span><span class="se"></span>          draw_bezier_joined.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_bezier_joined.gif" alt="img"></p>
<p>如果我移动其中一个控制点，使它不从同一&quot;结&quot;的另一个控制点通过附加的&quot;结&quot;进行&quot;反射&rdquo;，那么曲线将不连续。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;10,10 30,90   25,10 50,50   50,50 80,50   70,10 90,40&#34;</span>
  <span class="nv">clines</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$points</span><span class="s2">&#34;</span> <span class="p">|</span> sed <span class="s1">&#39;s/   /\n/g&#39;</span> <span class="p">|</span><span class="se">\
</span><span class="se"></span>             <span class="k">while</span> <span class="nb">read</span> line<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s2">&#34;line </span><span class="nv">$line</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span><span class="sb">`</span>
  <span class="nv">symbols</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> path <span class="s2">&#34;&#39;&#34;</span><span class="p">;</span> <span class="k">for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
             <span class="nb">echo</span> <span class="s2">&#34;M </span><span class="nv">$point</span><span class="s2">   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2&#34;</span>
           <span class="k">done</span><span class="p">;</span>  <span class="nb">echo</span> <span class="s2">&#34;&#39;&#34;</span><span class="sb">`</span>

  convert -size 100x100 xc:skyblue -fill none <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke gray </span><span class="nv">$clines</span><span class="s2">    stroke blue </span><span class="nv">$symbols</span><span class="s2"> &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 10,10 30,90   25,10 50,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 50,50 80,50   70,10 90,40 &#34;</span> <span class="se">\
</span><span class="se"></span>          draw_bezier_disjoint.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_bezier_disjoint.gif" alt="img"></p>
<p>如果再次移动控制点，使其与相关的&quot;结&quot;点相匹配，线条将直接从该点出发，完全没有任何&quot;曲线&quot;。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;10,10 30,90   25,10 50,50   50,50 50,50   70,10 90,40&#34;</span>
  <span class="nv">clines</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$points</span><span class="s2">&#34;</span> <span class="p">|</span> sed <span class="s1">&#39;s/   /\n/g&#39;</span> <span class="p">|</span><span class="se">\
</span><span class="se"></span>             <span class="k">while</span> <span class="nb">read</span> line<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s2">&#34;line </span><span class="nv">$line</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span><span class="sb">`</span>
  <span class="nv">symbols</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> path <span class="s2">&#34;&#39;&#34;</span><span class="p">;</span> <span class="k">for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
             <span class="nb">echo</span> <span class="s2">&#34;M </span><span class="nv">$point</span><span class="s2">   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2&#34;</span>
           <span class="k">done</span><span class="p">;</span>  <span class="nb">echo</span> <span class="s2">&#34;&#39;&#34;</span><span class="sb">`</span>

  convert -size 100x100 xc:skyblue -fill none <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke gray </span><span class="nv">$clines</span><span class="s2">    stroke blue </span><span class="nv">$symbols</span><span class="s2"> &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 10,10 30,90   25,10 50,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 50,50 50,50   70,10 90,40 &#34;</span> <span class="se">\
</span><span class="se"></span>          draw_bezier_no_curve.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_bezier_no_curve.gif" alt="img"></p>
<p>如果两个控制点都设置为各自的&quot;结点&quot;，那么就会生成一条直线。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;10,10 10,10   50,50 50,50   50,50 50,50   90,40 90,40&#34;</span>
  <span class="nv">clines</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$points</span><span class="s2">&#34;</span> <span class="p">|</span> sed <span class="s1">&#39;s/   /\n/g&#39;</span> <span class="p">|</span><span class="se">\
</span><span class="se"></span>             <span class="k">while</span> <span class="nb">read</span> line<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s2">&#34;line </span><span class="nv">$line</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span><span class="sb">`</span>
  <span class="nv">symbols</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> path <span class="s2">&#34;&#39;&#34;</span><span class="p">;</span> <span class="k">for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
             <span class="nb">echo</span> <span class="s2">&#34;M </span><span class="nv">$point</span><span class="s2">   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2&#34;</span>
           <span class="k">done</span><span class="p">;</span>  <span class="nb">echo</span> <span class="s2">&#34;&#39;&#34;</span><span class="sb">`</span>

  convert -size 100x100 xc:skyblue -fill none <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke gray </span><span class="nv">$clines</span><span class="s2">    stroke blue </span><span class="nv">$symbols</span><span class="s2"> &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 10,10 10,10   50,50 50,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 50,50 50,50   90,40 90,40 &#34;</span> <span class="se">\
</span><span class="se"></span>          draw_bezier_lines.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_bezier_lines.gif" alt="img"></p>
<p>如果不指定所有 4 个点，&lsquo;bezier&rsquo; 原语并不真正有用。只有第一个点和最后一个点被归类为&rsquo;结'，曲线将通过（或结束）这两个点。所有其他的点纯粹被视为控制点，按照给定的顺序对曲线产生影响，控制点越远，对该段曲线的影响越大。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;10,10 30,90   25,10    75,90   70,10 90,40&#34;</span>
  <span class="nv">symbols</span><span class="o">=</span><span class="sb">`</span><span class="k">for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
             <span class="nb">echo</span> <span class="s2">&#34;M </span><span class="nv">$point</span><span class="s2">   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2&#34;</span>
           <span class="k">done</span><span class="sb">`</span>

  convert -size 100x100  xc:skyblue  -fill none <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke gray  polyline </span><span class="nv">$points</span><span class="s2"> &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red   bezier </span><span class="nv">$points</span><span class="s2"> &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke blue  path &#39;</span><span class="nv">$symbols</span><span class="s2">&#39; &#34;</span> <span class="se">\
</span><span class="se"></span>          draw_bezier_multi.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_bezier_multi.gif" alt="img"></p>
<p>为了保持简单，不建议你每条 &lsquo;bezier&rsquo; 曲线段使用超过或少于4个点。</p>
<p>其实我建议你完全不要使用 &lsquo;bezier&rsquo; 原语，而是使用 <a href="https://imagemagick.org/Usage/draw/#cubic">SVG Path Cubic Bezier</a> 来生成曲线。它有一个特殊的 &ldquo;s&rdquo; 曲线延续功能，可以自动做相应的控制点&quot;反射&quot;，生成平滑连接的曲线段，减少你需要使用的控制点数量。您还可以定义相对于路径中最后一个端点的点。</p>
<h2 id="颜色填充原语">颜色填充原语</h2>
<p>除了上述 &ldquo;简单&quot;原语之外，&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?draw">-draw</a>&ldquo;还提供了一组颜色填充或修改原语。这些原语根据所选方法，从指定的点开始修改图像中的颜色。</p>
<p>这些填充方法实际上不是真正的 &lsquo;draw&rsquo; 命令，而是颜色替换函数。它们被添加到绘图中，因为在程序的早期版本中，将它们的操作插入到 ImageMagick 中是最简单的。</p>
<p>就像上面一样，使用的颜色是用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?fill">-fill</a>&ldquo;颜色设置的，但如果设置了，就会使用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?tile">-tile</a>&rdquo; 图像来代替。</p>
<p>上面的其他设置选项没有使用，对这些操作没有影响。</p>
<p>两个额外的设置也将应用于这些原语，即 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?bordercolor">-bordercolor</a>&rdquo; 和 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?fuzz">-fuzz</a>&ldquo;系数设置。但是，这些设置不能在 &ldquo;MVG&rdquo; 语言中定义，因此只能在使用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?draw">-draw</a>&rdquo; 操作符之前进行设置。</p>
<p>第一个 &lsquo;color point&rsquo; 你已经看到了，它是上述例子中 &lsquo;point&rsquo; 绘制原语的替代。如果你仔细观察，你会看到我们在测试图像中设置的单个白色像素。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert color_test.png   -fill white <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 point&#39;</span>      color_point.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/color_point.png" alt="img"></p>
<p>然而在绘制透明色和半透明色时，这些功能是不一样的。</p>
<p>这里我们有一个三个像素的红色图像（放大了），第二个或中间的像素我们用 <code>point</code> 函数在红色像素上画上半透明的蓝色，得到紫色的结果。然而如果使用 <code>color point</code> 函数（最后一个或右边的像素），红色完全被半透明的蓝色像素所取代。它不会被叠加。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 3x1 xc:red -matte -fill <span class="s1">&#39;#00F8&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;point 1,0&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 2,0 point&#39;</span>   -scale 33x33  draw_points.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_points.png" alt="img"></p>
<p>所有的 <code>color</code> 函数都会进行全色替换，而其他所有的颜色原语都会在图像上面&rsquo;画&rsquo;出颜色。因此，你可以使用 <code>color</code> 来绘制透明色。</p>
<p><code>color replace</code> 绘制函数将在指定的位置替换所有精确给定颜色的实例。而且正如您所看到的，这些区域不一定要连接在一起。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert color_test.png   -fill white <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 replace&#39;</span>      color_replace.png

  convert color_test.png   -fill white   -fuzz 13%<span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 replace&#39;</span>      color_replace_fuzz.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/color_replace.png" alt="img"></p>
<p>然而，正如你在第一个结果中所看到的，一些沿边缘的像素没有被替换。这些像素与所选像素的颜色不完全相同，所以它们被忽略了。添加一个小的<a href="https://imagemagick.org/Usage/color_basics/#fuzz">模糊因子</a>也会包含与原色相似的颜色。如上面第二个例子所示。</p>
<p>当然，<code>fuzz factor</code> 并不是一个很好的解决方案，因为它不会捕捉所有这样的边缘像素。这是所有这些 <code>color fill</code> 方法经常出现的问题，也是一个没有通用解决方案的问题。</p>
<p>如果你想替换一个特定的已知颜色，而不是从图像本身选择一种颜色，那么可以使用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?opaque">-opaque</a>&rdquo; 图像操作符来代替。该函数还使用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?fuzz">-fuzz</a>&rdquo; 因子设置来增加与给定颜色相匹配的颜色范围。</p>
<p><code>floodfill</code> 的方法也很简单，因为它只会填充所选点周围的整个区域，而不会选择任何其他没有以某种方式连接的类似颜色的区域。</p>
<p>你也可以通过使用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?fuzz">-fuzz</a>&rdquo; 来扩大被填充的区域，以包括相似的颜色。在这种情况下，我们选择了一个足够高的值，也包括了交叉边界，允许洪水填充&quot;泄漏&quot;到图像的另一侧。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert color_test.png   -fill white <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 floodfill&#39;</span>      color_floodfill.png

  convert color_test.png   -fill white   -fuzz 15%   <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 floodfill&#39;</span>      color_floodfill_fuzz.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/color_floodfill.png" alt="img">
<img src="https://imagemagick.org/Usage/draw/color_floodfill_fuzz.png" alt="img"></p>
<p>用颜色填充区域并非没有问题。颜色可能会越过薄薄的边界，渗入到不想要的区域，(<a href="https://imagemagick.org/Usage/formats/#bg_pattern">请看背景图案上的 GIF</a>，以证明这一点)。或者，它可能无法填满所选区域的边缘，（见<a href="https://imagemagick.org/Usage/antialiasing/#floodfill">反锯齿和泛滥填充问题</a>）。但它确实有效。</p>
<p><code>filltoborder</code> 就像 <code>floodfill</code> 一样，只是你指定了一个颜色，这个颜色的边界是要填充的区域，而不是填充过程中要替换的颜色。</p>
<p>当然也建议在该边框颜色选择中加入 <code>similar colors</code> 的<a href="https://imagemagick.org/Usage/color_basics/#fuzz">模糊因子</a>，以进一步限制洪水填充。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert color_test.png   -fill white  -bordercolor royalblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 filltoborder&#39;</span>   color_filltoborder.png

  convert color_test.png   -fill white  -bordercolor blue <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 filltoborder&#39;</span>   color_filltoborder2.png

  convert color_test.png   -fill white  -bordercolor blue  -fuzz 30% <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 filltoborder&#39;</span>   color_filltoborder_fuzz.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/color_filltoborder.png" alt="img">
<img src="https://imagemagick.org/Usage/draw/color_filltoborder2.png" alt="img">
<img src="https://imagemagick.org/Usage/draw/color_filltoborder_fuzz.png" alt="img"></p>
<p>最后的绘制颜色方法是 <code>reset</code>，它只是将整个图像替换或重置为填充颜色。在这种情况下，实际选择的像素对结果没有任何影响。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert color_test.png   -fill white <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 reset&#39;</span>      color_reset.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/color_reset.png" alt="img"></p>
<p>这实际上是非常有用的，因为它提供了一种简单的方法从现有图像生成纯色（或平铺图像）画布。(请参见 <a href="https://imagemagick.org/Usage/canvas/#sized">Canvases Sized to an Existing Image</a>)以了解此方法和其他做同样事情的方法。</p>
<p>未来：使用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?tile">-tile</a>&rdquo; 图案来填充该区域。</p>
<h2 id="matt-填充原语">Matt 填充原语</h2>
<p><code>matte</code> 绘制原语的工作方式与上述 <code>color</code> 原语完全相同，只是它不会替换所选区域的颜色，只会替换所选区域的 <code>matte</code> 通道。（也就是只有 <code>alpha</code> 或 <code>matte</code> 通道被这些填充函数调整）。</p>
<p>就像 <code>color</code> 填充函数一样，<code>matte</code> 值使用的是填充色（除非用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?tile">-tile</a>&rdquo; 作为 <code>alpha value</code> 的来源）。</p>
<p>这里我们使用上面同样的 <code>color floodfill</code> 例子，但这里只调整 matte 通道，使填充部分完全透明。也就是说，原来的颜色仍然存在，只是透明而已!</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert color_test.png   -fill none <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;matte 30,20 floodfill&#39;</span>      matte_floodfill.png

  convert color_test.png   -fill none   -fuzz 15%   <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;matte 30,20 floodfill&#39;</span>      matte_floodfill_fuzz.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/matte_floodfill.png" alt="img">
<img src="https://imagemagick.org/Usage/draw/matte_floodfill_fuzz.png" alt="img"></p>
<p>也可以使用 <code>matte reset</code> 函数使整个图像变成半透明的。当然在这种情况下，我们必须输出到 PNG，它可以接受半透明颜色的图像。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert color_test.png   -fill <span class="s1">&#39;#00000080&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;matte 30,20 reset&#39;</span>      matte_reset.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/matte_reset.png" alt="img"></p>
<p>注意，在操作中没有使用 <code>black</code> 颜色分量，只使用了颜色的 <code>matte</code> 分量。图像的原色保持原样。</p>
<p>未来：使用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?tile">-tile</a>&rdquo; 模式来制作有趣的哑光效果。</p>
<p><code>color</code> 和 <code>matte</code> 都是完全替换颜色的函数，它总是会产生一个布尔（all or nothing）类型的颜色替换。因此，这些区域的边缘总是会显示出 <a href="https://imagemagick.org/Usage/antialiasing/">Aliasing 效果</a>。</p>
<p>正因为如此，除了设置 GIF 图像的透明区域（也是布尔型）外，一般来说，这些都不是一般图像显影的好图像运算符。不过也不是全无用处，<a href="https://imagemagick.org/Usage/masking/#bg_remove">从背景去除</a>的例子中可以看出。</p>
<h2 id="关于绘图命令的具体内容">关于绘图命令的具体内容</h2>
<h3 id="像素坐标">像素坐标</h3>
<p><code>[-draw](https://imagemagick.org/Usage/option_link.cgi?draw)</code> 命令（以及IM中的许多其他命令）使用的是所谓的&quot;像素坐标&rdquo;。也就是 &ldquo;10,10&rdquo; 的坐标是左上角往下10个像素的中心。</p>
<p>在这个坐标系中，0,0 是左上角像素的中心，w-1,h-1 是右下角的中心。实际的边缘位于 -0.5,-0.5 和 w-0.5,h-0.5，中心像素（如果图像是奇数大小）位于 &lsquo;(w-1)/2,(h-1)/2&rsquo;。</p>
<p>然而，当您对图像进行数学处理时（如使用扭曲时），实际的像素没有实际意义，因此它使用&quot;图像坐标&rdquo;。在这个系统中，图像的实际边缘在 &lsquo;0,0&rsquo; 和 &lsquo;w,h&rsquo; 处。而图像的中心（可能是，也可能不是像素的中心）在 &lsquo;w/2,h/2&rsquo;。</p>
<p>要将 &lsquo;像素坐标&rsquo; 转换为图像坐标，请加上 ½ 如左上角像素的中心是 &lsquo;0.5,0.5&rsquo;，右下角像素的中心是 &lsquo;w-0.5,h-0.5&rsquo;。
<em>例如：小图像中的圆心</em></p>
<h3 id="绘制伽马和色域校正">绘制伽马和色域校正</h3>
<p>和几乎所有的 ImageMagick 操作一样， <code>[-draw](https://imagemagick.org/Usage/option_link.cgi?draw)</code> 是一个线性运算符，因此在线性 RGB 色彩空间中工作。这意味着，为了得到平滑的边缘，你可能需要对图像进行一些伽玛校正，然后再保存，这样就可以使用非线性（伽玛校正）的sRGB色彩空间来存储。</p>
<p>例如，如果你画了一个大圆，然后保存它&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 81x81 xc:black -fill white -draw <span class="s1">&#39;circle 40,40 40,3&#39;</span> <span class="se">\
</span><span class="se"></span>          circle_raw.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_raw.png" alt="img"></p>
<p>看看圆圈的边缘，其实看起来并不是真的很光滑。你可以看到明显的阶梯效果。</p>
<p>那是因为你是在线性 RGB 色彩空间中画的圆。但是你却把图像保存成了真正的 sRGB 色域！这就导致了你的图像在保存的过程中出现了明显的阶梯效果。</p>
<p>为了解决这个问题，我们需要在保存图像之前给图像添加一个伽玛校正。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 81x81 xc:black -fill white -draw <span class="s1">&#39;circle 40,40 40,3&#39;</span> <span class="se">\
</span><span class="se"></span>          -gamma 2.2 circle_gamma.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_gamma.png" alt="img"></p>
<p>现在，圆圈边缘实际上看起来光滑圆润，就像它们应该的那样。</p>
<p>如果你想正确地做这件事，我们真的应该使用色彩空间进行修正。然而，由于IM假设RGB是保存的默认色彩空间，你需要做一些棘手的处理来让它正确地做事情。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 81x81 xc:black -set colorspace RGB <span class="se">\
</span><span class="se"></span>          -fill white -draw <span class="s1">&#39;circle 40,40 40,3&#39;</span> <span class="se">\
</span><span class="se"></span>          -colorspace sRGB circle_sRGB.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_sRGB.png" alt="img"></p>
<blockquote>
<p>请注意，sRGB色彩空间（这是保存图像的正确方法）与简单地应用2.2伽玛校正并不完全相同。然而，两者之间的结果差异很小，只有在非常非常粗糙的图像中才能看到。
在IM v6.7.5-1之前，色彩空间名称 &ldquo;sRGB&rdquo; 和 &ldquo;RGB&rdquo;（线性-RGB）实际上是颠倒的。因此，在旧版本的IM中，上面的两个标签应该被调换。</p>
</blockquote>
<p>要使用真实的图像（在IMv6中）正确地绘制（或进行任何&quot;线性&quot;图像处理），你需要首先删除任何现有的伽玛，处理图像，然后恢复该伽玛校正。更多细节请参见<a href="https://imagemagick.org/Usage/resize/#resize_colorspace">使用色域校正调整大小</a>。</p>
<p>下面是一个在真实图像上绘图的例子&hellip;。首先是没有任何颜色校正（原始），然后是伽玛和色域校正。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert rose:  -fill none -stroke white -draw <span class="s1">&#39;line 5,40 65,5&#39;</span>  rose_raw.png

  convert rose: -gamma .454545 <span class="se">\
</span><span class="se"></span>          -fill none -stroke white -draw <span class="s1">&#39;line 5,40 65,5&#39;</span> <span class="se">\
</span><span class="se"></span>          -gamma 2.2 rose_gamma.png

  convert rose: -colorspace RGB <span class="se">\
</span><span class="se"></span>          -fill none -stroke white -draw <span class="s1">&#39;line 5,40 65,5&#39;</span> <span class="se">\
</span><span class="se"></span>          -colorspace sRGB rose_sRGB.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/rose_raw.png" alt="img">
<img src="https://imagemagick.org/Usage/draw/rose_gamma.png" alt="img">
<img src="https://imagemagick.org/Usage/draw/rose_sRGB.png" alt="img"></p>
<p>正如你所看到的，通过使用伽玛或色彩空间校正，线条变得非常平滑，没有锯齿状的&quot;楼梯&quot;别离效果，比直接绘制时可以看到。(你需要一个很好的显示器才能看到它)</p>
<blockquote>
<p>上面的线条是用 <code>[-stroke](https://imagemagick.org/Usage/option_link.cgi?stroke)</code> 颜色绘制的。您可以使用 <code>[-fill](https://imagemagick.org/Usage/option_link.cgi?fill)</code> 来绘制线条，并得到同样的结果，但这样您就不能使用 <code>[-strokewidth](https://imagemagick.org/Usage/option_link.cgi?strokewidth)</code> 来控制线条粗细。更多信息请参见下面的&rdquo;<a href="https://imagemagick.org/Usage/draw/#stroke">描边颜色设置</a>&quot;。
色域名称实际上是使用&rsquo;sRGB&rsquo;色彩空间的值来定义的，但通过绘制应用，就好像图像是在线性RGB色彩空间中一样。因此，对命名的颜色（不是&quot;白&quot;或&quot;黑&rdquo;）使用上述伽玛校正将导致这些颜色变得失真。在这种情况下，最好不要使用伽玛或色域校正，这样命名的颜色就会正确映射。
命名的&rsquo;sRGB&rsquo;颜色与图像的色彩空间的正确映射，将作为IMv7开发的一部分被修正。</p>
</blockquote>
<h3 id="描边描边宽度和填充的相互作用">描边、描边宽度和填充的相互作用</h3>
<p><code>[-stroke](https://imagemagick.org/Usage/option_link.cgi?stroke)</code> 和 <code>[-strokewidth](https://imagemagick.org/Usage/option_link.cgi?strokewidth)</code> 选项用于在字体边缘绘制轮廓。</p>
<p>这些选项通常与 <code>[-fill](https://imagemagick.org/Usage/option_link.cgi?fill)</code> 一起使用，以使文字更有趣，而不费力。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">    convert -size 380x70 xc:lightblue -pointsize <span class="m">50</span> -font Chisel <span class="se">\
</span><span class="se"></span>            -fill green  -stroke black  -draw <span class="s1">&#39;text 10,55 &#34;Black Border&#34;&#39;</span> <span class="se">\
</span><span class="se"></span>            stroke_font.jpg
</code></pre></div><p>默认设置是 <code>-strokewidth 1</code> 和 <code>-stroke None</code>。</p>
<p>但这样做会使轮廓笔画不可见，只留下 <code>[-fill](https://imagemagick.org/Usage/option_link.cgi?fill)</code> 的颜色，你不会看到它。</p>
<p>当 <code>-strokewidth</code> 为 &ldquo;不可见 &ldquo;时， <code>-strokewidth</code> 唯一的效果是对字体大小属性的影响，也就是说它仍然可以影响字体定位和 <a href="https://imagemagick.org/Usage/text/#label">Label 和 Caption</a> 图片生成的大小。否则，宽度在你使笔画可见之前是没有可见效果的。</p>
<p>为了了解 <code>[-strokewidth](https://imagemagick.org/Usage/option_link.cgi?strokewidth)</code> 对字体外观的实际影响（当使其可见时），我在这里绘制了一些不同宽度的文字，从 &ldquo;turned off&rdquo; 到越来越大。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">    convert -size 320x420 xc:lightblue -pointsize <span class="m">70</span> -font Vademecum <span class="se">\
</span><span class="se"></span>      -fill red -stroke none                 -draw <span class="s1">&#39;text 30,80  &#34;Stroke -&#34;&#39;</span> <span class="se">\
</span><span class="se"></span>      -fill red -stroke black -strokewidth <span class="m">0</span> -draw <span class="s1">&#39;text 30,160 &#34;Stroke 0&#34;&#39;</span> <span class="se">\
</span><span class="se"></span>      -fill red -stroke black -strokewidth <span class="m">1</span> -draw <span class="s1">&#39;text 30,240 &#34;Stroke 1&#34;&#39;</span> <span class="se">\
</span><span class="se"></span>      -fill red -stroke black -strokewidth <span class="m">2</span> -draw <span class="s1">&#39;text 30,320 &#34;Stroke 2&#34;&#39;</span> <span class="se">\
</span><span class="se"></span>      -fill red -stroke black -strokewidth <span class="m">3</span> -draw <span class="s1">&#39;text 30,400 &#34;Stroke 3&#34;&#39;</span> <span class="se">\
</span><span class="se"></span>      stroke_table.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/stroke_table.jpg" alt="img"></p>
<p>请注意，从上面的例子中，设置 <code>-strokewidth</code> 为 &ldquo;0&rdquo; 与设置 <code>-stroke</code> 颜色为 &ldquo;none&rdquo;（默认值）是不同的。前者会画出一个非常非常细的笔触轮廓，而后者则会有效地关闭它。在这两种情况下，笔触仍然会被绘制。</p>
<p>然而你也应该注意到，即使 <code>-strokewidth</code> 为 &ldquo;0&rdquo;，图像的轮廓也会比普通的 <code>filled</code> 图像（使用 <code>-stroke</code> 颜色为 &ldquo;none&rdquo;）扩大非常小。</p>
<p>最后，使用任何小于 &ldquo;1.0&rdquo; 的宽度都不能正常工作。在这种情况下，你应该谨慎行事。</p>
<p>但是请记住， <code>-strokewidth</code> 也是一个浮点设置。也就是说，&ldquo;0.5&rdquo; 的笔画宽度也是有效的。然而，通常只有当您试图在关闭防锐化功能的情况下绘制薄的位图圆时，这才是重要的。</p>
<p>下面是一个使用超大笔触宽度的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">   convert -size 320x100 xc:lightblue -font Candice -pointsize <span class="m">72</span> -fill white <span class="se">\
</span><span class="se"></span>           -stroke black -strokewidth <span class="m">15</span> -draw <span class="s2">&#34;text 25,65 &#39;Anthony&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>           stroke_thick.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/stroke_thick.jpg" alt="img"></p>
<p>请注意， <code>-strokewidth</code> 可以向内和向外扩展线条。下面是同样的例子，但是重新绘制了字体，没有笔画轮廓，去掉了很粗的笔画的内侧部分。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">   convert -size 320x100 xc:lightblue -font Candice -pointsize <span class="m">72</span> -fill white <span class="se">\
</span><span class="se"></span>           -stroke black -strokewidth <span class="m">15</span> -draw <span class="s2">&#34;text 25,65 &#39;Anthony&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>           -stroke none                  -draw <span class="s2">&#34;text 25,65 &#39;Anthony&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>           stroke_outline.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/stroke_outline.jpg" alt="img"></p>
<p>更多使用描边的例子请看<a href="https://imagemagick.org/Usage/fonts/">复合字体效果</a>。请特别看一下&rdquo;<a href="https://imagemagick.org/Usage/fonts/#balloon">气球效果</a>&quot;。</p>
<h3 id="绘制描边线条">绘制（描边）线条</h3>
<p>IM中的默认画线有一些奇怪的行为，值得了解。下面就为大家介绍一下默认画线&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line_default.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_default.jpg" alt="img"></p>
<p>你可以用 <a href="https://imagemagick.org/Usage/option_link.cgi?fill"><code>-fill</code></a> 选项设置线条的颜色。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill white -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line.jpg" alt="img"></p>
<p>此外，你还可以通过设置 <code>[-stroke](https://imagemagick.org/Usage/option_link.cgi?stroke)</code> 颜色，使线条稍微粗一些。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill white -stroke black -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line_stroke.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_stroke.jpg" alt="img"></p>
<p>但是我们用 <code>-fill</code> 选项指定的白色是怎么回事呢？</p>
<p>这就是在 ImageMagick 中绘制线条的棘手之处。该程序所做的实际上是将线条视为一个约1像素宽的填充对象。这是自然的，因为通常情况下，多条线通常用于扫出一个要填充的区域。</p>
<p>所以，就像我们在上一节中使用字体的描边一样，IM 用填充色绘制线条（或对象），然后用描边色在其周围绘制。结果就是，现在上面的描边色线条稍微粗了一点，填充色完全隐藏在下面。如果你把描边色做成半透明的，就可以让这个填充色再次显现出来。</p>
<p>综上所述，线条会出现在 <code>-fill</code> 颜色下绘制，但一旦 <code>-stroke</code> 颜色被定义为默认的&quot;无&quot;或&quot;透明&quot;颜色以外的颜色，该选项就没有任何意义了。</p>
<blockquote>
<p>选项 <code>-linewidth</code> 实际上只是 <code>-strokewidth</code> 的别名，不应该被使用。</p>
</blockquote>
<p>例如，你可能会认为这个命令会产生很粗的线条。确实如此，但由于 <code>-stroke</code> 的颜色是不可见的，所以你看不到它。你只能看到线条的一个像素宽的区域的内部&quot;填充&rdquo;。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill white -strokewidth <span class="m">3</span> -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line_fill_3.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_fill_3.jpg" alt="img"></p>
<blockquote>
<p>以上的结果其实我认为是一个 BUG，什么都没画，因为没有&rsquo;区域&rsquo;填充，也没有设置线的&rsquo;描边颜色'。什么都没有画，因为没有&quot;区域 &ldquo;需要填充，也没有设置线的&quot;笔触颜色&rdquo;。IM 目前这样做的原因是为了避免新用户的混淆，但实际上这只会给高级用户带来问题。详见<a href="https://imagemagick.org/Usage/draw/#bounds">《绘制填充边界》</a>。</p>
</blockquote>
<p>但如果同时定义了描边颜色，就会得到要求的粗线&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -stroke black -strokewidth <span class="m">3</span> -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line_stroke_3.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_stroke_3.jpg" alt="img"></p>
<p>如果将 <code>-strokewidth</code> 设置为1，则上面的一行将被完全覆盖。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -stroke black -strokewidth <span class="m">1</span> -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line_stroke_1.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_stroke_1.jpg" alt="img"></p>
<p>当然当你掌握了这些知识后，你就可以利用这些知识进行创作，就像画字体一样。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -stroke black -strokewidth <span class="m">5</span> -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          -stroke white -strokewidth <span class="m">2</span> -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line_multi.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_multi.jpg" alt="img"></p>
<p>在这里，我使用了最薄的 <code>-strokewidth</code> 设置为 &ldquo;0&rdquo;，就像我对上述字体所做的一样。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill white -stroke black -strokewidth <span class="m">0</span> -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line_stroke_0.jpg
</code></pre></div><p>这就产生了一个非常奇怪的结果，即由黑点和灰段组成的点线。这是笔触、填充和背景色之间奇怪的&quot;色拍频率&quot;的结果。</p>
<p>下面是线条的放大图&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 25x10 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill white -stroke black -strokewidth <span class="m">0</span> -draw <span class="s2">&#34;line 2,8 22,1&#34;</span> <span class="se">\
</span><span class="se"></span>          -scale 400%    line_stroke_0_white.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_stroke_0_white.jpg" alt="img"></p>
<blockquote>
<p>颜色节拍频率 &ldquo;的效果与&quot;声音节拍&quot;的效果并无二致，当你有两把非常轻微的不调的吉他时，你会得到这样的效果。在这种情况下，你会得到一个黑点，其中笔触颜色完全覆盖了基本的填充颜色，你会得到一个灰色的点，其中笔触颜色与填充和背景颜色混合。
颜色混合是反锯齿过程的自然结果，IM使用反锯齿过程来尝试改善线条和其他绘制对象的外观。更多信息请参见<a href="https://imagemagick.org/Usage/antialiasing/"> IM 中的抗锯齿</a>讨论和示例页面。</p>
</blockquote>
<p>需要注意的是，这种效果只出现在倾斜的线条上，而不是纯水平或垂直的线条，因为在这些线条上，别名没有影响，因此也就没有&quot;色拍频率&quot;的效果。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill white -stroke black -strokewidth <span class="m">0</span> -draw <span class="s2">&#34;line 5,20 95,20&#34;</span> <span class="se">\
</span><span class="se"></span>          line_stroke_horz.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_stroke_horz.jpg" alt="img"></p>
<p>在这里，我在放大的视图上使用了不同的底层填充颜色，所以你可以看到颜色如何改变结果的节拍。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 25x10 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill none -stroke black -strokewidth <span class="m">0</span> -draw <span class="s2">&#34;line 2,8 22,1&#34;</span> <span class="se">\
</span><span class="se"></span>          -scale 400%     line_stroke_0_none.jpg

  convert -size 25x10 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill red -stroke black -strokewidth <span class="m">0</span> -draw <span class="s2">&#34;line 2,8 22,1&#34;</span> <span class="se">\
</span><span class="se"></span>          -scale 400%    line_stroke_0_red.jpg

  convert -size 25x10 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill black -stroke black -strokewidth <span class="m">0</span> -draw <span class="s2">&#34;line 2,8 22,1&#34;</span> <span class="se">\
</span><span class="se"></span>          -scale 400%    line_stroke_0_black.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_stroke_0_none.jpg" alt="img">
<img src="https://imagemagick.org/Usage/draw/line_stroke_0_red.jpg" alt="img">
<img src="https://imagemagick.org/Usage/draw/line_stroke_0_black.jpg" alt="img"></p>
<p>让我们把它和无 stroke 相比&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 25x10 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill black -stroke none -draw <span class="s2">&#34;line 2,8 22,1&#34;</span> <span class="se">\
</span><span class="se"></span>          -scale 400%    line_stroke_-_black.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_stroke_-_black.jpg" alt="img"></p>
<p>正如你所看到的，当绘制非常细的线条时，你可以通过使用相同的填充和描边颜色，或者将其中一种颜色设置为无来减少&quot;节拍&rdquo;。虽然后者是最好的主意，但前者可能对你的特定编程需求更实用。</p>
<p>注意，填充线的粗细是 &ldquo;0&rdquo;。但描边线可以有更大的厚度。它也是一个浮点值! 2.5像素宽的线条是完全有效的。</p>
<blockquote>
<p>这些结果不仅是由于笔画宽度为0的bug，导致颜色跳动，而且在没有实际需要填充的区域时，&ldquo;填充色&quot;被画出了额外的1.0直径厚度。这我也认为是一个bug。请看<a href="https://imagemagick.org/Usage/draw/#bounds">绘制填充边界</a>。</p>
</blockquote>
<h3 id="绘制填充边界">绘制填充边界</h3>
<p>关于各种绘制原语，还有一些其他要点需要您注意。</p>
<p>笔画宽度对于大于 1.0 的浮点值工作得很好，但对于小于 1.0 的值似乎会崩溃。这是由于使用的实现算法造成的，而不仅仅是因为它是错误的，因为它在较大厚度的线条上工作得很好。</p>
<p>基本上，如果你使用的笔画宽度为零，你可以期待没有笔画颜色会被添加。相反，你会得到一种节拍模式，当线条穿过像素的实际&quot;中心&quot;时，笔触颜色就会达到全部强度。</p>
<p>真正应该发生的是，添加到像素上的颜色数量应该反映出被绘制的线条的面积，而不是像素与该线条的距离。因此，零宽度的线条不应该给图像添加任何颜色，而厚度小于1.0的线条应该只添加较少的颜色。</p>
<p>请看上面的例子 <a href="https://imagemagick.org/Usage/draw/#strokewidth">Draw Lines, with StrokeWidth and Stroke</a>。</p>
<p>另一个问题是，填充颜色没有应用到正在绘制的形状（多边形）的边缘，而是应用到更远的半像素处。这包括没有应用&quot;描边&quot;的情况，而边缘应该是精确的。它也包括画一条&quot;线&rdquo;，它的填充厚度实际上是&quot;零&rdquo;。</p>
<p>基本上，如果你画了一条线，没有启用描边，从技术上讲，你应该看到，没有线，因为它没有&quot;填充&quot;厚度。相反，线条的绘制至少包括1个像素宽的&quot;填充&quot;颜色。这是出于历史原因，一般来说可以避免新用户对IM的混淆。不幸的是，这对高级用户来说是不正确的。</p>
<p>这意味着，如果您只使用填充色绘制两个多边形，并共享一个边缘，该边缘将重叠1个像素，因为每个多边形的所有边缘都比它大半像素。换句话说，多边形和其他形状并不适合在一起，而是重叠的。</p>
<p>例如，在这里我试着使用 <code>draw</code> 把一张图片分成两半（在白色上绘制黑色）。要做到这一点，我画了两个多边形，共享一个边缘，完全没有重叠。由此产生的&quot;微小&quot;图像，已被放大显示。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 10x10 xc: -draw <span class="s1">&#39;polygon 2,-1 7,10 10,10 10,-1&#39;</span> bound_left.gif
  convert -size 10x10 xc: -draw <span class="s1">&#39;polygon 2,-1 7,10 -1,10 -1,-1&#39;</span> bound_right.gif
  convert bound_left.gif bound_right.gif -compose Plus -composite bound_add.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/bound_left_mag.gif" alt="img">
<img src="https://imagemagick.org/Usage/img_www/plus.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/bound_right_mag.gif" alt="img">
<img src="https://imagemagick.org/Usage/img_www/right.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/bound_add_mag.gif" alt="img"></p>
<p>两个黑色的部分(这是实际绘制的)实际上是相互重叠的! 换句话说，尽管我们试图使用绘制的多边形分别绘制这两个区域，但填充的区域比要求的略大。</p>
<p>我还将两张图片加（<a href="https://imagemagick.org/Usage/compose/#plus">加合成</a>）在一起，这样你就可以实际看到绘制的黑色区域的重叠。如果两个多边形是完美契合的，那么 &ldquo;添加 &ldquo;的图画将是纯白色的。</p>
<p>实际的重叠量相当于默认的 <code>-strokewidth 1.0</code> 设置。因此，通常情况下，这个额外的区域会被一个正常的笔画宽度所覆盖。然而它可能会造成一些实际问题。</p>
<p>旁白: 对于一个完整的连接测试，你会在黑色背景上生成50%的灰色区域，然后把它们加在一起。这样你就可以看到这些区域是否不仅 &ldquo;重叠&rdquo;（如上图所示），而且还可以测试当你把这些区域加在一起时，它们是否 &ldquo;重叠不足&rdquo;（在填充的区域之间留下一个间隙）。所得到的图像应该是一个完美平滑的50%灰色，沿连接处没有颜色变化。透明度检查会涉及到，在一个完全透明的背景上应该使用50%透明，50%灰色的颜色。</p>
<p>要查看一个完美的剪切和重新添加的例子，基于一个单一的蒙版图像，请参阅组成方法的例子，<a href="https://imagemagick.org/Usage/compose/#dstout">组成 DstOut</a>。</p>
<p>未来BUG修复：填充的区域应该是精确的，但为了在绘制形状时进行补偿，默认的 &ldquo;描边颜色 &ldquo;应该设置为填充颜色（除非它本身被特别设置）。</p>
<h2 id="mvg---魔法矢量图形">MVG - 魔法矢量图形</h2>
<p>上面显示的原语构成了所有 <code>-draw</code> 操作的基础。它们共同构成了 ImageMagick 中特殊内部语言的起点，称为 Magick Vector Graphics 语言。关于这种语言的更多细节，请参见IM网站上的 <a href="http://www.imagemagick.org/script/magick-vector-graphics.php">MVG 原语和语法摘要</a>。</p>
<p>这种 &ldquo;MVG&rdquo; 语言的设计目标是让 ImageMagick 处理更复杂的 SVG（可缩放矢量图形）语言。它通过尝试将给定 SVG 格式的图像转换为更简单的内部 MVG 格式来实现。更多细节请看下面的 <a href="https://imagemagick.org/Usage/draw/#svg">SVG 处理</a>。</p>
<p>因此，你上面看到的只是 <code>-draw</code> 操作符的一小部分功能。如果你想绘制复杂的对象，我建议你使用SVG编辑器（如 &ldquo;Sodipodi&rdquo;）为对象创建一个单独的SVG格式图像。参见下面的非IM矢量图形程序）。</p>
<p>与 SVG 不同，MVG 没有任何形式的&quot;容器&quot;或图像命令集。在转换过程中，这些命令都被删除，以产生一个简化的 MVG 绘图命令序列。相反，它使用<a href="https://imagemagick.org/Usage/draw/#push_context">图形上下文</a>的概念来保存和恢复各种绘图设置，这就是我们现在要看的。</p>
<h3 id="命令行设置与-mvg-设置">命令行设置与 MVG 设置</h3>
<p>首先，您通过命令行选项设置的几乎所有设置，绘制原语使用的设置在 MVG 绘制命令中都有直接对应的内容。</p>
<p>通过命令行选项（如 <code>-strokewidth</code>）或使用 MVG 绘图字符串（如 <code>strok-width</code>）中的设置，两者之间的主要区别在于 MVG 设置只在 MVG 命令字符串的持续时间内有效。</p>
<p>一般绘图设置的总结:</p>
<pre><code>  __cmd_option__   __draw_MVG__        __Argument__
    -fill            fill                color/tile for inside shapes
    -tile            fill                image tile, replaces fill color

    -stroke          stroke              line color/tile around the shapes
    -strokewidth     stroke-width        pixel width
    +antialias       stroke-antialias    0/1 aliasing line edges

    -font            font                font_name / font_file
    -family          font-family            ?
    -weight            ?                    ?
    -stretch           ?                    ?
    -pointsize       font-size           height in points
    -kerning           -                 extra inter-character spacing

    +antialias       text-antialias      0/1 aliasing drawing text
    -box             text-undercolor     fill color for font bounding box
      -              decorate        (None, Underline, LineThrough or Overline)

    -gravity         gravity             (None, North, South-East,...)
    -fuzz              -                 color delta / percentage
    -bordercolor       -                 color
</code></pre><p>Notes:</p>
<pre><code>  - no such option      ? unknown
</code></pre><p>这些设置通常很好理解，因为它们经常使用，上面也有演示。</p>
<blockquote>
<p>字体、拉伸、样式和重量用于从 ImageMagick 字体列表中识别字体。然而，大多数人只是选择一个特定的字体和大小点来代替使用。因此，它们在IM中很少使用。
正如您所看到的，&ldquo;color fill&rdquo; 原语的特殊设置在 MVG 中并没有直接对应的设置。这就是 <code>-bordercolor</code> 和 <code>-fuzz</code> 因子设置。在使用 <code>-draw</code> 操作符之前，必须从命令行指定这些设置。</p>
</blockquote>
<p>有些 MVG 设置作为全局命令行设置可能更有用，比如字体绘制的 <code>decorate</code> 设置。</p>
<p>警告： <code>[-gravity](https://imagemagick.org/Usage/option_link.cgi?gravity)</code> 不是 SVG 规范的一部分。在 MVG 中，它只用于文本和图像的放置以及对齐。目前没有与默认的&quot;引力&quot;效果分开的调整设置。然而，由于调整是 SVG 文本处理的一部分，这可能会在未来的某个时候改变。</p>
<p>现在，全局命令行设置（在 MVG 绘制字符串之外）用于初始化你所应用的每个 <code>-draw</code> 操作的设置，这就是为什么你可以设置一个 <code>-fill</code> 颜色，然后你可以用它来绘制该颜色的圆。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue   -fill red <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;circle 50,30 40,10&#34;</span>          draw_circle_global.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_circle_global.gif" alt="img"></p>
<p>你可以在 MVG 参数 <code>-draw</code> 中本地覆盖全局设置&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue   -fill red <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill green   circle 50,30 40,10&#34;</span>  draw_circle_override.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_circle_override.gif" alt="img"></p>
<p>然而，在单个 <code>-draw</code> MVG 参数中设置的设置只在 <code>-draw</code> 操作期间存在。也就是说， <code>-draw</code> 中的设置只限于该次绘制，而不会带入以后单独的 <code>-draw</code> 参数中。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue   -fill red   -draw <span class="s1">&#39;fill green&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;circle 50,30 40,10&#34;</span>          draw_circle_local.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_circle_local.gif" alt="img"></p>
<p>如果你打算进行大量的操作，那么在单个 MVG 字符串中进行这些操作可能会比多个 <code>-draw</code> 操作更好。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue  <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill green  circle 41,39 44,57
</span><span class="s2">                 fill blue   circle 59,39 56,57
</span><span class="s2">                 fill red    circle 50,21 50,3  &#34;</span>  draw_circle_multi.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_circle_multi.gif" alt="img"></p>
<h3 id="mvg-特定设置">MVG 特定设置</h3>
<p>其他控制线条和对象绘制方式的 MVG 设置，即使在使用原语操作时也需要了解。这些设置包括&hellip;</p>
<pre><code>   __draw_MVG__       __Description/Argument__
  fill-opacity        fill transparency, from 0.0 to 1.0
  clip-rule           fill style for crossed lines (evenodd, nonzero)

  stroke-opacity      line transparency, number from 0.0 to 1.0
  stroke-dasharray    list of 'on' and 'off' lengths for lines
  stroke-dash
  stroke-linecap      End of line look: butt round square
  stroke-linejoin     Lines joins:  butt  miter round square
  stroke-miterlimit   Angle when 'miter' joins become 'bevel' (or 'butt')
</code></pre><p>记住，所有 MVG 设置和绘图操作符的完整列表可以在 IM 网站的 <a href="http://www.imagemagick.org/script/magick-vector-graphics.php">MVG 原语和语法摘要</a>中看到。</p>
<p>让我们看看一些简单设置的效果&hellip;&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Stroke Opacity</span>
  convert -size 100x60 xc:skyblue -fill none -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;                           path &#39;M 10,10 L 90,10&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-opacity 0.8         path &#39;M 10,20 L 90,20&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-opacity 0.6         path &#39;M 10,30 L 90,30&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-opacity 0.4         path &#39;M 10,40 L 90,40&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-opacity 0.2         path &#39;M 10,50 L 90,50&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          set_stroke_opacity.gif

  <span class="c1"># Fill Opacity</span>
  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;                    rectangle  5,10 15,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-opacity 0.8    rectangle 20,10 30,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-opacity 0.6    rectangle 35,10 45,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-opacity 0.4    rectangle 50,10 60,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-opacity 0.2    rectangle 65,10 75,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-opacity  0     rectangle 80,10 90,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          set_fill_opacity.gif

  <span class="c1"># Plain and Dashed Lines</span>
  convert -size 100x60 xc:skyblue -fill none -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;                           path &#39;M 10,10 L 90,10&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 5 3       path &#39;M 10,20 L 90,20&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 5 5       path &#39;M 10,30 L 90,30&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 10 3 3 3  path &#39;M 10,40 L 90,40&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 1 6       path &#39;M 10,50 L 90,50&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          set_lines.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;                           path &#39;M 10,10 L 90,10&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 5 3       path &#39;M 10,20 L 90,20&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 5 5       path &#39;M 10,30 L 90,30&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 10 3 3 3  path &#39;M 10,40 L 90,40&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 1 6       path &#39;M 10,50 L 90,50&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          set_lines_fill.gif

  <span class="c1"># Note: Technically the second image should be the same as the first</span>
  <span class="c1"># as the &#39;filled&#39; lines contain no area.  This I regard as a BUG.</span>
  <span class="c1"># Stroke Ends and Joins</span>
  convert -size 100x60 xc:skyblue -fill white -stroke black -strokewidth <span class="m">8</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;                           path &#39;M 20,20 L 20,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-linecap butt        path &#39;M 40,20 L 40,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-linecap round       path &#39;M 60,20 L 60,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-linecap square      path &#39;M 80,20 L 80,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          set_endcaps.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black -strokewidth <span class="m">5</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;                        path &#39;M  5,70 L 20,20  35,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-linejoin miter   path &#39;M 35,70 L 50,20  65,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-linejoin bevel   path &#39;M 55,70 L 70,20  85,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-linejoin round   path &#39;M 75,70 L 90,20 105,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          set_linejoin.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black -strokewidth <span class="m">5</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;                        path &#39;M  5,70 L 20,20  35,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-miterlimit 7     path &#39;M 35,70 L 50,20  65,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-miterlimit 6     path &#39;M 65,70 L 80,20  95,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          set_miterlimit.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/set_stroke_opacity.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/set_fill_opacity.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/set_lines.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/set_lines_fill.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/set_endcaps.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/set_linejoin.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/set_miterlimit.gif" alt="img"></p>
<p><code>stroke-miterlimit</code> 的设置是相当难以演示的。这个属性定义了将 <code>miter</code> 连接变为 <code>bevel</code> 连接的角度。基本上对于非常尖锐的角度，一个斜面可以从两条线的实际接合处延伸很长的距离。这就为这个锐角设置了一个最大限度，当它变得太长时，就会使角点变钝。但请注意，它代表的是某种角度的三角值，而不是长度或距离。该值必须大于1.0。</p>
<p>上面显示了对于我所显示的连接角度，斜角会突然转换成一个介于6到7之间的斜角。</p>
<p>例如，1.414 的 <code>troke-miterlimit</code> 会将小于90度的任何角度的 &ldquo;miter&rdquo; 转换为 <code>bevel</code> 。4.0的 值（默认值）将小于约29度的角度转换为连接。而10.0的值可以将小于约11.5度的角度转换为斜面。</p>
<h3 id="svg-s路径绘制">SVG s路径绘制</h3>
<p>SVG 路径是 SVG 的基本绘图原语。它用于绘制线型、圆、曲线、弧线等。SVG 路径的完整规范可以在 <a href="http://www.w3.org/TR/SVG/paths.html#PathDataGeneralInformation">SVG 路径规范</a>文档中找到。</p>
<p>然而这并不是一个容易阅读的文档，因为它确实是为程序员而不是用户准备的，所以我将简化和总结路径规范&hellip;</p>
<ul>
<li>字母是命令，而所有的数字（浮点）都是参数</li>
<li>逗号或空格可以作为参数分隔符，否则完全忽略</li>
<li>每个路径组件的最后两个参数 <code>(x,y)</code> 将成为该路径组件的终点(或&quot;结&rdquo;)</li>
<li>大写字母是指最终点的绝对坐标</li>
<li>小写字母是相对于前一个组件的终点而言的</li>
<li>例如 &ldquo;M 1,2 L 3,4 L 2,4&rdquo; 和 &ldquo;M 1,2 L 4,6 L 6,2&rdquo; 是一样的。</li>
<li>即在1,2上加了3,4，画线到4,6。</li>
<li>然后在1,2上加2,4，画出一条线到最后的坐标6,2。</li>
<li>每个元素的参数可以重复，不需要重新发布相同的路径字母，可以多加数字参数组。不过对于曲线，为了方便阅读，我建议你还是加上函数字母。</li>
<li>重复的参数 &ldquo;M&rdquo; 或 &ldquo;m&rdquo; 分别作为 &ldquo;L&rdquo; 或 &ldquo;l&rdquo; 处理。</li>
<li>例如：&rdquo; M 1,2 3,4 5,6 &quot; 和 &quot; M 1,2 L 3,4 L 5,6 &quot; 是一样的。</li>
<li>而：&ldquo;m 1,2 3,4 2,4 &quot; 与 &quot; m 1,2 l 3,4 l 2,4 &quot; 相同。</li>
<li>对于立方贝塞尔，所有的点（控制点和结点）都是相对于前一个路径组件的端点而言的。</li>
</ul>
<p>请注意，您可以用绝对坐标或相对坐标来指定对象。因此，你可以用相对坐标来定义一个对象，只需提供一个初始的绝对&quot;移动&quot;坐标来定位整个路径。</p>
<p>另一方面，你也可以使用其他的&quot;图形内容&quot;命令来移动整个图形在&quot;视图框&quot;或&quot;转换&quot;中的位置（见下文）。因此，在 SVG 路径中使用绝对或相对坐标并不重要。
移动、线条和路径闭合是学习 SVG 对象路径的最初起点。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Open, Completed and Closed Paths (same points)</span>

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 40,10 L 20,50 90,10 70,40&#39;&#34;</span> path_open.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 40,10 L 20,50 90,10 70,40 40,10&#39;&#34;</span> path_complete.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 40,10 20,50 90,10 70,40 Z&#39;&#34;</span> path_closed.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_open.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_complete.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_closed.gif" alt="img"></p>
<p>但是请注意，&lsquo;z&rsquo; 只是关闭循环。它并没有创建一个单独的对象。因此，两个&quot;关闭&quot;的路径仍然被归类为一个单一的绘制对象，无论它们是重叠的还是完全断开的。</p>
<p>这里我们展示了两个闭合但重叠的循环，在同一方向上绘制。由于只使用了一条路径，所以对象是一个单一的对象，<code>fill-rule</code> 设置控制了重叠区域的填充方式。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Overlapping Paths and Fill Rule</span>
  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-rule evenodd \
</span><span class="s2">                 path &#39;M 40,10 20,20 70,50 Z
</span><span class="s2">                       M 20,40 70,40 90,10 Z&#39; &#34;</span> path_evenodd.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-rule nonzero \
</span><span class="s2">                 path &#39;M 40,10 20,20 70,50 Z
</span><span class="s2">                       M 20,40 70,40 90,10 Z&#39; &#34;</span> path_nonzero.gif

</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_evenodd.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_nonzero.gif" alt="img"></p>
<p>由于对象围绕中心以相同的角度方向绘制，两个闭合的循环将包含一个周期值为2的区域，因此 <code>evenodd</code> 规则使得该区域未被填充，而非零的 <code>nonzero</code> 规则则将其填充。但是请注意，所有的路径都是可见的，因为它们实际上是同一个对象。</p>
<p>绘制路径的方向是非常重要的，一般情况下，所有的路径相对于对象的&rsquo;内部&rsquo;应该绘制在完全相同的方向上。</p>
<p>例如这里我将第二个对象画成与第一个对象相反的方向。因此，当两个对象重叠时，该区域被圈出 &lsquo;0&rsquo; 次。也就是说，无论使用什么 <code>fill-rule</code>，它都将是未被填充的，形成一个&rsquo;洞'。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Overlapping Closed Objects, Second object drawn in reverse</span>
  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-rule evenodd \
</span><span class="s2">                 path &#39;M 40,10 20,20 70,50 Z
</span><span class="s2">                       M 20,40 90,10 70,40 Z&#39; &#34;</span> path_rvs_evenodd.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-rule nonzero \
</span><span class="s2">                 path &#39;M 40,10 20,20 70,50 Z
</span><span class="s2">                       M 20,40 90,10 70,40 Z&#39; &#34;</span> path_rvs_nonzero.gif

</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_rvs_nonzero.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_rvs_evenodd.gif" alt="img"></p>
<p>这意味着你可以在物体上产生一个&quot;洞&rdquo;，通过反转方向，使物体的&quot;内部&quot;保持在行进方向的同一侧。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># An object with a reversed drawn hole!</span>
  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,10 20,55 70,50 80,5 Z
</span><span class="s2">                       M 50,20 60,40 40,30 Z&#39; &#34;</span> path_with_hole.gif

</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_with_hole.gif" alt="img"></p>
<p>无论 <code>fill-rule</code> 的设置如何，结果都是一样的，因为这个洞是&rsquo;偶数&rsquo;和&rsquo;零'，所以是未填充的。</p>
<p>当然，如果您使用一个完全独立的 <code>path</code> 元素，您将生成一个完全独立的对象。在这种情况下，<code>fill-rule</code> 不适用，而只是按照给定的顺序，将对象画在彼此的上方。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Separate paths are separate objects</span>
  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 40,10 20,20 70,50 Z&#39;
</span><span class="s2">                 path &#39;M 20,40 70,40 90,10 Z&#39; &#34;</span> path_separate.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_separate.gif" alt="img"></p>
<p>未来：坐标对准路径 &ldquo;H&rdquo; 和 &ldquo;V&rdquo;。</p>
<p>椭圆弧是 SVG 路径的圆圈绘制功能&hellip;</p>
<p><code>large</code> 和 <code>sweep</code> 参数特别重要，因为它们用于决定从起点到终点的四种弧线中的哪一种。</p>
<p><code>large</code> 和 <code>sweep</code> 这两个标志定义了四条弧线中哪一条弧线将连接这两个点。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1">#  Elliptical Arcs :   A  radius_x,y  angle   large,sweep  x,y</span>
  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40  A 30,15 0 0,0 70,20&#39;&#34;</span>    path_arc.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40  A 30,15 0 0,1 70,20&#39;&#34;</span>    path_arc2.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40  A 30,15 0 1,0 70,20&#39;&#34;</span>    path_arc3.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40  A 30,15 0 1,1 70,20&#39;&#34;</span>    path_arc4.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_arc.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_arc2.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_arc3.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_arc4.gif" alt="img"></p>
<p>第二个标志 <code>sweep</code> 简单地决定了弧线路径的方向的哪一边应该被绘制。</p>
<p><code>large</code> 标志是用来选择较长的路径，绕着椭圆的中心走。这是设置的角度的弧线将大于180度。如果关闭，你会得到较小的&rsquo;弧'，不包含椭圆的中心，并且弧线的角度小于180度。</p>
<p>用 &ldquo;Z&rdquo; 来关闭弧线，只是画出最后的直线段。</p>
<p>要创建一个完整的椭圆或圆，你至少需要两个&rsquo;弧线&rsquo;段，从第一点到第二点，然后回到第一点。两条弧线都应该有相同的 <code>sweep</code> 设置，所以弧线将在不同的边上，有不同的移动方向。其中一条弧线应该有 <code>large</code> 的设置。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Closed and angled elliptical arcs  (defined by two edge points)</span>

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40  A 30,20  20  0,0 70,20 Z &#39;&#34;</span> path_arc5.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40  A 30,20  20  1,1 70,20 Z &#39;&#34;</span> path_arc6.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40  A 30,20  20  0,0 70,20 \
</span><span class="s2">                                A 30,20  20  1,0 30,40 Z &#39;&#34;</span> path_arc7.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_arc5.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_arc6.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_arc7.gif" alt="img"></p>
<p>请注意，如果直线太长，在给定的角度下无法适应给定的椭圆大小，椭圆的大小将被放大，以适应以椭圆为中心的直线，这意味着通过使用小数字作为轴半径，你可以只指定轴长的比例，并保证直线路径通过椭圆的中心点。</p>
<p>这意味着，通过使用小数字的轴半径，你可以只指定一个轴长的比例，并保证直线路径穿过椭圆的中心点。也就是说，路径从椭圆的一侧到另一侧形成一个椭圆直径。这并不是椭圆的主轴或次轴，只是一个椭圆的直径。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40   A 3,2  45  0,0 70,20&#39;&#34;</span> path_arc_x.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_arc_x.gif" alt="img"></p>
<p>当然，使用长度为 &ldquo;1,1&rdquo; 的结果是一个完美的半圆，从一个点，到下一个点。在这种情况下，椭圆角不会有任何区别。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40   A 1,1  0  0,0 70,20&#39;&#34;</span> path_hcircle.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_hcircle.gif" alt="img"></p>
<p>对于以两点为中心的全圆，用&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40   A 1,1  0  0,0 70,20
</span><span class="s2">                                 A 1,1  0  1,0 30,40  Z&#39;&#34;</span> path_circle.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_circle.gif" alt="img"></p>
<p>SVG 对 &ldquo;弧线&quot;的定义也声明，如果两个半径中的任何一个是0，那么就应该画一条直线。因此，任何半径为 &ldquo;0,0&rdquo; 的圆弧，都只是一条简单的直线圆弧&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40   A 0,0  0  0,0 70,20&#39;&#34;</span> path_arc_line.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_arc_line.gif" alt="img"></p>
<p>如果你为弧线指定了一个非常大的半径，而没有为回程路径指定 <code>large sweep</code>，你可以在两点之间创建该半径的透镜形状。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40   A 50,50  0  0,0 70,20
</span><span class="s2">                                 A 50,50  0  0,0 30,40  Z&#39;&#34;</span> path_lens.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_lens.gif" alt="img"></p>
<p>这种类型的弧线是一个关键特征。它可以让你很容易地把原本是直线的东西变成一条小而明显的曲线。</p>
<p>例如，与其说是一个简单的三角形，不如说是一个&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 20,55  L 25,10  L 70,5 L 20,55 Z&#39; &#34;</span>   triangle.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/triangle.gif" alt="img"></p>
<p>你可以用一个大半径的弧线代替每条线，让它们只是有轻微的曲线。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 20,55  A 100,100 0 0,0 25,10
</span><span class="s2">                                A 100,100 0 0,0 70,5
</span><span class="s2">                                A 100,100 0 0,0 20,55 Z&#39; &#34;</span> triangle_curved.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/triangle_curved.gif" alt="img"></p>
<p>线条的端点没有变化，所发生的只是每个 &ldquo;L&rdquo; 被一个弧线段代替。然而弧线的大小应该与线的长度成正比。由于我没有这样做，较长的对角线比其他两条线有更深的曲线。</p>
<p>请记住，当调整对象的大小或比例时，你也应该将半径的比例与线的长度相同，这样曲线的大小就会相应地调整，所以弧线的比例也会正确。</p>
<p>请注意，<code>sweep</code> 标志可以控制曲线是向外凸起还是向内凸起，这取决于每个路径段的绘制方向(见上文)。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 20,55  A 100,100 0 0,0 25,10
</span><span class="s2">                                A 100,100 0 0,1 70,5
</span><span class="s2">                                A 100,100 0 0,1 20,55 Z&#39; &#34;</span> triangle_bulge.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/triangle_bulge.gif" alt="img"></p>
<p>看起来 &ldquo;静态&quot;的直边三角形，现在看起来有点像充满风的帆。</p>
<p>如果你真的想让线条完美的直，而不把它们转换回真正的线段，你可以通过使用弧线半径为零来关闭曲线。</p>
<p>因此，弧线不仅适合生成椭圆和圆，而且对于绘制直线和微曲线段也很有用。它是一种非常通用的通用点到点的绘制路径。</p>
<p>使用椭圆弧来生成分离的曲线段的一个简单的替代方法是使用<a href="https://imagemagick.org/Usage/draw/#quad">四元贝塞尔段</a>来代替，主要的区别是使用一个单一的控制点，而不是一个圆形半径来定义弧线。这也允许您将弧线偏向线段的一端，但代价是难以生成对称的弧线。</p>
<p>当然，您也可以通过使用这两种方法来进行 <code>mix-n-match</code>。</p>
<h3 id="饼图示例">饼图示例</h3>
<p>为了完成对弧线的使用，让我们举个例子，使用为它们生成圆楔。当然，你可能需要使用一些外部的三角数学（你的高中数学有多好？）来确定所需的最终路径点。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 140x130 xc:white -stroke black <span class="se">\
</span><span class="se"></span>    -fill red   -draw <span class="s2">&#34;path &#39;M 60,70 L   60,20   A 50,50 0 0,1 68.7,20.8 Z&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>    -fill green -draw <span class="s2">&#34;path &#39;M 60,70 L 68.7,20.8 A 50,50 0 0,1 77.1,23.0 Z&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>    -fill blue  -draw <span class="s2">&#34;path &#39;M 68,65 L 85.1,18.0 A 50,50 0 0,1  118,65   Z&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>    -fill gold  -draw <span class="s2">&#34;path &#39;M 60,70 L  110,70   A 50,50 0 1,1   60,20   Z&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>    -fill black -stroke none  -pointsize <span class="m">10</span> <span class="se">\
</span><span class="se"></span>    -draw <span class="s2">&#34;text 57,19 &#39;10&#39; text 70,20 &#39;10&#39; text 90,19 &#39;70&#39; text 113,78 &#39;270&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>    piechart.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/piechart.jpg" alt="img"></p>
<p>请注意，所有的弧线都是画在 <code>line path</code> 的左边，并有相应的标志（使用 <code>sweep</code> 标志）。但如果弧线覆盖的角度大于180度，则需要设置 <code>large</code> 标志。见上面例子中最后一个 <code>gold</code> 组件。</p>
<p>还要注意的是，你应该完整地画出每个部分，尽管这意味着你可能要画两次边界线。如果你不这样做，你很可能要么不会完全用颜色填充该部分，要么填充颜色会覆盖之前绘制的部分轮廓。</p>
<p>避免重复绘制多条线的唯一方法是绘制所有填充区域，然后重复这样绘制轮廓。就是说你需要把所有的东西都画两遍，确保东西正确匹配。因此，将轮廓加倍可能是最简单的解决方案。</p>
<p>立方贝塞尔曲线可以使用 <code>c</code> 函数定义两个控制点，以及最终的终点。对于使用最后一个控制点的镜像的持续立方贝塞尔曲线（对于连续曲线），你可以使用 <code>s</code> 函数。</p>
<p>下面是一个例子。由于这个函数的复杂性，我预先准备了一个画布，显示控制点的位置，以及最后一个控制点的 <code>assumed mirror</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Cubic Bezier:    C  control_1_x,y control_2_x,y  x,y</span>
  <span class="c1"># Smooth &#34; :       S  control_2_x,y  x,y</span>

  convert path_cubic_canvas.gif  -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 10,30  C 10,4 50,4 50,30  S 90,55 90,30&#39; &#34;</span> <span class="se">\
</span><span class="se"></span>          path_cubic.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_cubic.gif" alt="img"></p>
<p>连接控制点和该路径段路径上的最终点的线（控制线）基本上定义了通过路径上该点的曲线方向。长的控制线会在该点产生一条更平滑的曲线，而短的控制线则会在该点产生一条更清晰的曲线。如果控制点与曲线的点相吻合（控制线长度为零），则曲线在该点有一个尖锐的不连续性，就像只用直线段一样。</p>
<p>作为一个更实际的例子，下面的代码是从 <a href="https://imagemagick.org/Usage/scripts/generate_logo">IM 实例 Logo 生成器脚本</a>中提取出来的，该脚本创建了 <a href="https://imagemagick.org/Usage/images/logo.gif">IM 实例 Logo</a> 的曲线溅射区域。</p>
<p>这个例子的棘手之处在于，我将我使用的立方贝塞尔路径字符串，转换为另一个路径，显示用于生成贝塞尔曲线的控制线。这让我可以看到曲线的控制线角度和长度，使得调整结果变得更加容易。只需要调整一组点就可以同时显示曲线和控制线，将错误控制在最小范围内。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">   <span class="nv">curve</span><span class="o">=</span><span class="s2">&#34;M 12,27  C 7,37  18,50 18,60  S  0,80 10,94
</span><span class="s2">          S 40,74 50,78  S 60,99 76,95  S 72,70 75,65
</span><span class="s2">          S 95,55 95,42  S 69,37 66,32  S 67,2  53,7
</span><span class="s2">          S 43,17 35,22  S 17,17 12,27  Z&#34;</span>
   <span class="nv">c_ctrls</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="nv">$curve</span> <span class="p">|</span> <span class="se">\
</span><span class="se"></span>              sed <span class="s1">&#39;1s/\([0-9]\)  *\([0-9]\)/\1 M \2/;
</span><span class="s1">                   s/S/M/g; s/C/ /;&#39;</span> -<span class="sb">`</span>
   convert -size 100x100 xc:white <span class="se">\
</span><span class="se"></span>           -draw <span class="s2">&#34;stroke None  fill Green  path &#39;</span><span class="nv">$curve</span><span class="s2">&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>           -draw <span class="s2">&#34;stroke Red   fill None   path &#39;</span><span class="nv">$c_ctrls</span><span class="s2">&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>           curvy_splash.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/curvy_splash.gif" alt="img"></p>
<p>如果你仔细观察图像，你会发现曲线的起点和终点有两条方向相反的控制线。对于一个封闭的连续路径来说，开始和结束的控制线应该在相同的角度（只是在镜面方向），当然也应该是相同的长度。这一点很重要，因为很容易弄错。</p>
<p>沿着曲线的所有其他点只有一个控制点/线，它与曲线的绘制方向相反。该线段越长，曲线在该控制点处的 <code>sharp</code> 越低，长度为零则产生一个 <code>point</code>。</p>
<p><code>s</code> 函数在内部根据前一段的数据生成下一段的镜像控制点/线，从而产生曲线的平滑延续。</p>
<p>关于这个路径函数的更多例子，请看<a href="http://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands">《SVG：立方贝塞尔曲线命令》</a>。</p>
<p>手动生成贝塞尔曲线是比较直接的，不需要任何花哨的 GUI 工具。</p>
<ul>
<li>首先定义所有你想让曲线经过的坐标点，在列表的最后重复起始坐标。</li>
<li>现在将这个列表扩大，将所有的 <code>x,y</code> 坐标点加倍成对，并在每对坐标点前添加一个 <code>s</code>（Smooth Cubic）函数。每对中的第一个数字是控制点，连接到第二个数字代表曲线上的点。然而第一个点对却把这一点反过来了，第一个点是曲线的起点，第二个点代表第一个也是唯一一个反转的控制点。</li>
<li>将第一对坐标的函数字母由 &lsquo;S&rsquo; 改为 &lsquo;M&rsquo;，然后在这对坐标之间加一个 &lsquo;C&rsquo;。最后将第二对坐标的 &lsquo;S&rsquo; 去掉，完成初始的立方体（&lsquo;C&rsquo;）函数。</li>
<li>通过添加最后的 &lsquo;Z&rsquo; 来完成路径，关闭曲线。</li>
<li>请看上面的示例序列，它应该是怎样的。</li>
<li>此时您可以测试绘制您的路径。由于所有的控制线长度为零，所以路径将只由直线段组成。</li>
<li>现在您需要做的就是慢慢地、小心地调整控制线段的位置（每个 &ldquo;S&rdquo; 对的第一个坐标），以得到您想要的最终曲线。不要把控制线做得太长，或者方向不对，否则你会得到一条看起来非常滑稽的曲线。</li>
<li>为了帮助查看你的变化和发现错误，请使用上面的转换 &ldquo;sed&rdquo; 命令来绘制路径控制点和曲线控制点之间的控制线。但是请注意，零长度的控制线是不可见的，但是由于lin会产生一个尖锐的点，所以位置应该很明显。</li>
<li>最后，确保 &ldquo;C&rdquo; 之后的第一条控制点/线与终点控制点/线的位置完全相反。</li>
</ul>
<p>交互式曲线的生成也可以通过使用一些矢量图形编辑器来实现。</p>
<p>例如 Luis Guerra 报告说，&ldquo;Inkscape&rdquo; 生成的贝塞尔曲线可以使用 &ldquo;Edit -&gt; XML Editor&rdquo; 功能，然后选择你想要控制点的路径或形状。</p>
<blockquote>
<p>你知道有什么其他的方法可以用GUI工具来提取贝塞尔曲线（在曲线上每个点给出两个或一个控制点）。或者是一些其他的技术来生成这样的曲线？请发邮件给我! 我很乐意听到它。你将会像其他人一样，被记入该技术的名下。</p>
</blockquote>
<p>二次方贝塞尔函数是立方贝塞尔函数的简化，当两个控制点合并成一个控制点时。同样，你可以用 &lsquo;Q&rsquo; 函数开始曲线，然后用 &lsquo;T&rsquo; 函数继续曲线，镜像最后一个控制点。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1">#  Quadratic Bezier:  Q  control_x,y  x,y</span>
  <span class="c1">#  Smooth &#34; :         T  x,y</span>

  convert path_quad_canvas.gif  -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 10,30   Q 20,4 50,30   T 90,30&#39; &#34;</span> <span class="se">\
</span><span class="se"></span>          path_quad.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_quad.gif" alt="img"></p>
<p>但我要提醒您，&ldquo;T&rdquo; 继续函数只适用于连接间距相等的点的路径。我不推荐使用它。</p>
<p>二次方曲线的优点是可以替代<a href="https://imagemagick.org/Usage/draw/#arcs">椭圆弧</a>，因为它使用的是实际的位置，而不是弧线的半径。它也可以使弧线偏向于一端而不是另一端，这在使用<a href="https://imagemagick.org/Usage/draw/#arcs">椭圆弧</a>时并不实用。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 20,55  Q 30,32 25,10
</span><span class="s2">                                Q 50,1 70,5
</span><span class="s2">                                Q 50,45 20,55 Z&#39; &#34;</span> triangle_bulge_2.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/triangle_bulge_2.gif" alt="img"></p>
<p>在这种情况下，弧线不是那么均匀，你得到的东西就像一个倒立的鲨鱼鳍，而不是一个帆。</p>
<p>请记住四边形弧线是抛物线，而椭圆弧线基本上是生成圆弧线段。这可能是决定你应该使用哪种类型的弧线段的关键。</p>
<p>有关此路径功能的更多例子，请参见：<a href="http://www.w3.org/TR/SVG/paths.html#PathDataQuadraticBezierCommands">SVG: Quadratic Bezier Curve Commands</a>。</p>
<h3 id="绘图表面的变形">绘图表面的变形</h3>
<p>在这些能力之上，绘制对象的绘图表面可以以各种方式变形，让你做一些令人惊奇的事情。</p>
<p>首先，你可以应用一些通用的绘图表面修改，比如&hellip; &ldquo;translate&rdquo;、&ldquo;rotate&rdquo;、&ldquo;scale&rdquo;、&ldquo;skewX&rdquo;、&ldquo;skewY&rdquo; 和 &ldquo;affine&rdquo;。</p>
<p>例如，给定一个线条的 <code>path</code>，我们可以 <code>translate</code> 绘图表面的原点或0,0点到另一个位置。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;translate 50,30
</span><span class="s2">                 image over 3,3 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span>  transform_translate.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/transform_translate.gif" alt="img"></p>
<p>请注意，&ldquo;0,0&rdquo; 或绘图区域的原点现在以图像为中心，尽管Y轴在图像的顶部仍然是负数，在底部仍然是正数。</p>
<p><code>rotate</code> 操作将旋转绘图表面，所以以后在该表面上绘制的任何东西都将被旋转绘制。当然，它会围绕转换后的原点进行旋转，所以最好同时使用这两个变换运算符。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;translate 50,30    rotate -30
</span><span class="s2">                 image over 4,4 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span>  transform_rotate.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/transform_rotate.gif" alt="img"></p>
<p><code>scale</code> 将放大和缩小原点周围的绘图面。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;translate 50,30    scale 1.5,1.5
</span><span class="s2">                 image over 4,4 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span>  transform_scale.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/transform_scale.gif" alt="img"></p>
<p>一个常见的 <code>scale</code> 用法是将Y轴翻转，使Y的正值向上。当然原点也应该移到中心，或者左下角，以保持秩序。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;translate 50,30    scale 1,-1
</span><span class="s2">                 image over 4,4 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span>    transform_flip.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/transform_flip.gif" alt="img"></p>
<p>最后，&ldquo;skewX&rdquo; 和 &ldquo;skewY&rdquo; 在X和Y方向上对图像进行剪切。例如，这里我们使用 &ldquo;skewX&rdquo; 给图像的垂直Y轴一个倾斜。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;translate 50,30   skewX 20
</span><span class="s2">                 image over 4,4 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span>    transform_skewY.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/transform_skewY.gif" alt="img"></p>
<p>这些操作符在 MVG <code>-draw</code> 字符串之外有对应的操作符，供一般使用。但是这些命令行版本是运算符，并且立即应用于内存中已经存在的图像，而不是应用于尚未绘制的矢量对象的绘制表面。更多细节请看扭曲图像。</p>
<h3 id="绘制表面的平移变形">绘制表面的平移变形</h3>
<p>上述所有五种画布变换都可以组合成一个通用的 Affine Matrix Operator，可以使用 MVG 原语 &ldquo;affine&rdquo;，也可以在调用 <code>-draw</code> 之前使用 <code>-affine</code> 设置 Affine 变换。</p>
<p>Affine 变换使用一组 &ldquo;Matrix Coefficients&rdquo;，它定义了如何将你给出的坐标修改为实际的绘图坐标。</p>
<p>关于这些 &ldquo;coefficients&rdquo; 如何工作的更多细节，请参阅 <a href="https://imagemagick.org/Usage/distorts/affine/">Affine Matrix Transforms</a>。</p>
<p>例如&hellip; 要设置一个相对于对象绘制时的中心原点&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;affine 1,0,0,1,50,30
</span><span class="s2">                 image over 4,4 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span>  affine_null.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/affine_null.gif" alt="img"></p>
<p>翻转图像&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;affine 1,0,0,-1,50,30
</span><span class="s2">                 image over 4,4 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span> affine_flip.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/affine_flip.gif" alt="img"></p>
<p>绕原点旋转30度&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;affine .866,-.5,.5,.866,50,30
</span><span class="s2">                 image over 4,4 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span>    affine_rot.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/affine_rot.gif" alt="img"></p>
<p>对于更复杂的仿射变换，您可以使用为此目的创建的<a href="https://imagemagick.org/Usage/distorts/affine/#affine_scripts">仿射辅助脚本</a>。这些脚本将诸如旋转角度和中心点之类的东西转换为 Affine 坐标，你可以直接在 <code>-draw affine</code> 或 <code>-affine</code> 设置中使用。</p>
<h3 id="推弹上下文">推/弹上下文</h3>
<p>一些 MVG 原语实际上依赖于这些变换的使用才能正确使用。例如，<a href="https://imagemagick.org/Usage/draw/#primitive_circle">椭圆原语</a>只能用正交对齐的轴直接指定。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;ellipse 50,30 30,15 0,360&#34;</span>   ellipse_orthogonal.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/ellipse_orthogonal.gif" alt="img"></p>
<p>然而，通过使用<a href="https://imagemagick.org/Usage/draw/#transform">绘图变换</a>，我们可以很容易地给椭圆添加一个&quot;旋转角&rdquo;。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;push graphic-context
</span><span class="s2">                 translate 50,30   rotate 30
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 ellipse 0,0 30,15 0,360
</span><span class="s2">                 pop graphic-context&#34;</span>       ellipse_rotated.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/ellipse_rotated.gif" alt="img"></p>
<p>请注意，椭圆的 <code>center</code>(旋转点)在应用旋转之前首先被转换。然后，<code>ellipse</code> 在 &ldquo;0,0&rdquo; 处的转换位置被绘制。</p>
<p>上面还显示了两个新的 MVG 绘图原语。&lsquo;push graphic-context&rsquo; 和 &lsquo;pop graphic-context&rsquo;。在上面的例子中，并不是严格意义上的需要，但在进行主要的绘图转换时，建议使用这两个原语。</p>
<p><code>push</code> 和 <code>pop</code> 原语的作用是保存当前的绘图状态或 &ldquo;graphic-context&rdquo;，然后再次恢复。在这两个原语之间更改的任何绘图设置都会被遗忘。这包括曲面变形（如 &ldquo;平移 &ldquo;和 &ldquo;旋转&rdquo;）、颜色设置 <code>fill</code> 和 <code>stroke</code> 或任何其他修改了绘图 <code>state</code> 的设置。</p>
<p>这些原语使您可以轻松地绘制具有许多变换的非常复杂的对象，然后将事物恢复到更 &ldquo;正常&quot;的状态，以便以后进行绘制操作。您可以在下面的<a href="https://imagemagick.org/Usage/draw/#arrows">绘制箭头</a>中看到更实用的演示。</p>
<h3 id="推弹特殊对象">推/弹特殊对象</h3>
<p><img src="https://imagemagick.org/Usage/img_www/const_barrier.gif" alt="img">  建设中 <img src="https://imagemagick.org/Usage/img_www/const_hole.gif" alt="img"></p>
<p>更多专门用于 MVG 处理 SVG 格式的设置。</p>
<pre><code>    font-family   font-stretch   font-style   font-weight
    encoding 'UTF-8'

    push defs

      push gradient 'def_name' linear X1,Y1 X2,Y2
        stop-color 'color' where
        stop-color 'color' where
          # where is a point between the two pixels given (0 = X1,Y1  1= X2,Y2)
        gradient-units 'objectBoundingBox|userSpaceOnUse'
        affine ....
      pop gradient

      push gradient 'def_name' radial CX,CY FX,FY R
        # Here CX,CY is the center of the radial gradient of radius R
        # the FX,FY is the focal, and is usually the same a CX,CY
        # unless you are trying to warp the gradient in a specific direction
        stop-color 'color' where
        ...
      pop gradient

    pop defs

    push graphic-context
      fill 'url(#def_name)'
      ... draw things here ...
    pop graphic-context
</code></pre><p>例子见 Florent Monnier 的开发网站&hellip;  <a href="http://www.linux-nantes.fr.eu.org/~fmonnier/OCaml/MVG/">http://www.linux-nantes.fr.eu.org/~fmonnier/OCaml/MVG/</a>。</p>
<h3 id="阅读-mvg-文件">阅读 MVG 文件</h3>
<p>正如你在上面的例子中所看到的，MVG 的 <code>-draw</code> 参数可以变得很长。事实上，SVG 到 MVG 的转换可以产生一些非常长的 MVG 绘图参数（见下文）。</p>
<p>然而，IM 的一般命令行界面允许您通过使用 <code>&quot;@filename&quot;</code> 参数从文件中读取任何字符串参数。这很方便，因为这意味着你可以从一个单独的文件中读取非常长和复杂的MVG绘图命令。</p>
<p>例如，如果我将 MVG 操作放入一个名为 &ldquo;draw_circles.mvg&rdquo; 的文件中，那么我就可以像这样绘制&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue  -draw @mvg_circles.mvg  mvg_draw.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/mvg_circles.mvg.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/mvg_draw.gif" alt="img"></p>
<p>不仅如此，ImageMagick 还懂得直接读取 &ldquo;MVG:&rdquo; 图像文件格式，让你可以更直接地绘制此类命令。然而，除非 MVG文 件定义了一个画布，否则你可能需要指定初始画布（ <code>-size</code> 和&rdquo;-background&rdquo;）来绘制。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60  -background limegreen  mvg_circles.mvg  mvg_file.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/mvg_circles.mvg.gif" alt="img"> <img src="https://imagemagick.org/Usage/img_www/right.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/mvg_file.gif" alt="img"></p>
<p>你可以通过在 MVG 文件中添加一个 &ldquo;viewbox&rdquo;，并添加适当的背景色填充绘制，将初始画布设置移动到 MVG 图像中。这样就完成了 MVG 图像文件作为一个完整的图像定义。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert    mvg_circles2.mvg    mvg_image.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/mvg_circles2.mvg.gif" alt="img"> <img src="https://imagemagick.org/Usage/img_www/right.gif" alt="img"> <img src="https://imagemagick.org/Usage/draw/mvg_image.gif" alt="img"></p>
<blockquote>
<p>目前只有一种方法可以从 MVG 参数字符串中读取外部 MVG 文件，那就是使用 &ldquo;图像 &ldquo;绘图原语。遗憾的是，这将 MVG 的 include 转换为光栅图像，然后再将该图像覆盖到绘图表面。
换句话说，目前还没有MVG的 &ldquo;include&quot;功能。 :-(</p>
</blockquote>
<p><img src="https://imagemagick.org/Usage/img_www/const_barrier.gif" alt="img">  建设中 <img src="https://imagemagick.org/Usage/img_www/const_hole.gif" alt="img"></p>
<p>您可以生成IM的低级绘制操作，使用 `<a href="https://imagemagick.org/Usage/option_link.cgi?render">+render</a> 来记录它们。</p>
<p>当你再给 <code>-render</code> 设置/操作时，IM将立即绘制这些保存的操作。</p>
<p>奇怪的是，仅仅输出到 &ldquo;MVG&rdquo; 文件似乎也能做到这一点&hellip;&hellip;。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">     convert  ...   -draw <span class="s1">&#39;....&#39;</span>  draw_commands.mvg
</code></pre></div><p>注意：如果你在输出 MVG 格式文件时画了一条曲线，文件中会列出以下内容。曲线是一系列的短线段，而不是原始曲线。</p>
<p>当然您也可以完全使用更通用的 SVG 格式。参见下面的 &ldquo;<a href="https://imagemagick.org/Usage/draw/#svg">SVG 格式处理</a>&quot;。</p>
<h3 id="mvg-阿尔法构成">MVG 阿尔法构成</h3>
<p><img src="https://imagemagick.org/Usage/img_www/const_barrier.gif" alt="img">  建设中 <img src="https://imagemagick.org/Usage/img_www/const_hole.gif" alt="img"></p>
<p>我没有看到任何使用 Alpha 构图的情况（除了 <code>painters</code> 的算法之外）。基本上是一种 &ldquo;over&rdquo; alpha 合成）来绘制对象。</p>
<p>然而，这并不是说不能这样做。</p>
<p>如果你喜欢将你的矩形、椭圆、圆形或其他物体用不同的阿尔法成分（如 &ldquo;DstOver&rdquo;，这是一个类似于 Under 的成分），然后在空白的透明画布上画出你的人物，同样的构图，并将其合成到您的图像上。</p>
<p>然而，由于 SVG 允许您使用 alpha 合成来绘制文本和其他的图像，因此，您可以使用 SVG 来绘制图像项目到图像上，我想这将是一个未来的补充。</p>
<p>敬请期待</p>
<h3 id="绘制符号">绘制符号</h3>
<p>有时你在图像上有一组点，你想在那里绘制参考符号，如十字、圆圈等。遗憾的是，目前IM还没有可以轻松绘制这类符号的命令，但只要稍加努力，你就可以绘制这类符号。</p>
<h4 id="符号绘制技巧">符号绘制技巧</h4>
<p>在给定的位置列表中绘制多个符号的诀窍是使用 shell 脚本或任何你正在使用的 API 生成 MVG 绘图命令，以便将给定的点集转化为适当的绘图命令集。
例如，我在这里将一条线上的点转换为每一个点的&quot;加号&rdquo;&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Define a string of X and Y coordinates</span>
  <span class="c1"># comma between values, space between coordinates.</span>
  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;6.6,7.7  25.0,75.0 42.2,85.4 75.8,94.7 51.5,39.3  92.5,66.6&#34;</span>

  <span class="c1"># convert each point into a draw command for a cross (using &#39;awk&#39;)</span>
  <span class="c1"># the &#39;tr&#39; converts spaces into &#39;newlines&#39; (one point per line).</span>
  <span class="nv">crosses</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="nv">$points</span> <span class="p">|</span> tr -s <span class="s1">&#39; &#39;</span> <span class="s1">&#39;\012&#39;</span> <span class="p">|</span><span class="se">\
</span><span class="se"></span>     awk -F, <span class="s1">&#39;{ print &#34;line &#34; $1-3 &#34;,&#34; $2 &#34; &#34; $1+3 &#34;,&#34; $2 ;
</span><span class="s1">                print &#34;line &#34; $1 &#34;,&#34; $2-3 &#34; &#34; $1 &#34;,&#34; $2+3 ; }&#39;</span> -<span class="sb">`</span>

  <span class="c1"># draw a red line between the points, and blue crosses on the points.</span>
  convert -size 100x100 xc:white <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill none stroke red   polyline </span><span class="nv">$points</span><span class="s2"> &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill none stroke blue  </span><span class="nv">$crosses</span><span class="s2"> &#34;</span> <span class="se">\
</span><span class="se"></span>          points_plus.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/points_plus.gif" alt="img"></p>
<p>上面使用 &ldquo;tr&rdquo; 将每个点（两个数字）分成每条线上的一个点，然后使用 &ldquo;awk&rdquo; 进行所有数学计算，在给定的点上绘制&quot;加号&rdquo;。你可以使用任何你喜欢的东西，因为我只是在输入点列表上应用了一种文本宏扩展的形式。几乎所有的编程语言都可以做到这一点。对于上面的shell脚本案例，我只是发现 &ldquo;awk&rdquo; 是最简单、最快的手段。</p>
<p>其实你甚至可以使用 Imagemagick 本身的 &ldquo;convert&rdquo; 格式选项来进行这种 &ldquo;macro&rdquo; 的扩展&hellip;比如这里我用它来计算圆周上的一个点，对于这个&quot;点符号&rdquo;。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Define a string of X and Y coordinates</span>
  <span class="c1"># comma between values, space between coordinates.</span>
  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;6.6,7.7  25.0,75.0 42.2,85.4 75.8,94.7 51.5,39.3  92.5,66.6&#34;</span>

  <span class="c1"># circle radius (or symbol size) to draw around each point.</span>
  <span class="nv">radius</span><span class="o">=</span>3.5

  <span class="c1"># convert each point into a draw command for a cross</span>
  <span class="c1"># In this case, points are space separated by the shell</span>
  <span class="nv">circles</span><span class="o">=</span><span class="k">$(for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
             <span class="nv">x</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$point</span><span class="s2">&#34;</span> <span class="p">|</span> cut -d, -f1<span class="k">)</span>
             <span class="nv">y</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$point</span><span class="s2">&#34;</span> <span class="p">|</span> cut -d, -f2<span class="k">)</span>
             <span class="c1"># use IM to do some floating point math, EG:  y2=$y+$radius</span>
             <span class="nv">y2</span><span class="o">=</span><span class="k">$(</span>convert xc: -format <span class="s1">&#39;%[fx:&#39;</span><span class="s2">&#34;</span><span class="nv">$y</span><span class="s2">&#34;</span><span class="s1">&#39;+&#39;</span><span class="s2">&#34;</span><span class="nv">$radius</span><span class="s2">&#34;</span><span class="s1">&#39;]&#39;</span> info:<span class="k">)</span>
             <span class="nb">echo</span> <span class="s2">&#34;circle </span><span class="nv">$x</span><span class="s2">,</span><span class="nv">$y</span><span class="s2"> </span><span class="nv">$x</span><span class="s2">,</span><span class="nv">$y2</span><span class="s2">&#34;</span>
           <span class="k">done)</span>

  <span class="c1"># Draw a red line between the points, and blue circles on the points.</span>
  convert -size 100x100 xc:white <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill none stroke red   polyline </span><span class="nv">$points</span><span class="s2"> &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill none stroke blue  </span><span class="nv">$circles</span><span class="s2"> &#34;</span> <span class="se">\
</span><span class="se"></span>          points_circle.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/points_circle.gif" alt="img"></p>
<p>现在，您生成的绘制字符串可能会变得相当长，并且可能会开始导致您的最终命令的长度问题。所以，与其将点转换成长字符串，然后我们在命令行上传递给 IM，不如将绘制命令以文件的形式管道化给 IM。</p>
<p>我这次也使用了 <a href="https://imagemagick.org/Usage/draw/#paths">SVG 路径</a>的绘制方法来代替 <a href="https://imagemagick.org/Usage/draw/#primitives">Draw Primitive</a> 的绘制方法。另外我生成的符号是每个点周围的三角形。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Define a string of X and Y coordinates</span>
  <span class="c1"># comma between values, space between coordinates.</span>
  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;6.6,7.7  25.0,75.0 42.2,85.4 75.8,94.7 51.5,39.3  92.5,66.6&#34;</span>

  <span class="c1"># convert each point into a draw commands to draw a triangle</span>
  <span class="k">for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
     <span class="nb">echo</span> <span class="s2">&#34;path &#39;M </span><span class="nv">$point</span><span class="s2">  m 0,-5 -4,+8 +8,0 -4,-8&#39;&#34;</span>
  <span class="k">done</span> <span class="p">|</span><span class="se">\
</span><span class="se"></span>    convert -size 100x100 xc:white <span class="se">\
</span><span class="se"></span>          -fill none -stroke red  -draw <span class="s2">&#34;path &#39;M </span><span class="nv">$points</span><span class="s2">&#39; &#34;</span> <span class="se">\
</span><span class="se"></span>          -fill none -stroke blue -draw <span class="s1">&#39;@-&#39;</span> <span class="se">\
</span><span class="se"></span>          points_tri.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/points_tri.gif" alt="img"></p>
<p><a href="https://imagemagick.org/Usage/draw/#paths">SVG 路径</a>实际上使这一点变得更容易，通过允许相对像素移动，允许你设计符号，所以它只需要一个单一的初始绝对移动&rsquo;M'，然后再给出&rsquo;移动&rsquo;和&rsquo;线&rsquo;的序列来绘制符号。正因为如此，你实际上根本不需要任何浮点计算，因为IM draw会完成所需的定位数学。</p>
<blockquote>
<p>相对移动SVG路径项&rsquo;m&rsquo;在IM v6.4.3-5之前被破坏了。如果你的IM比这更老，上面（和下一个）的例子可能什么也画不出来。您可以通过将上面的相对移动&rsquo;m&rsquo;替换为适当的相对线序列&rsquo;l&rsquo;来解决旧版本的问题。</p>
</blockquote>
<p>现在你可以更进一步，将一个完整的MVG文件，包括画布规格，直接作为一个绘画命令的流水线输入到IM中。这次让我们做一个&rsquo;十字'，这和上面第一个&rsquo;加&rsquo;的例子类似，需要大量的计算。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Define a string of X and Y coordinates</span>
  <span class="c1"># comma between values, space between coordinates.</span>
  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;6.6,7.7  25.0,75.0 42.2,85.4 75.8,94.7 51.5,39.3  92.5,66.6&#34;</span>

  <span class="c1"># Generate a MVG file for IM to draw all components</span>
  <span class="o">(</span> <span class="nb">echo</span> <span class="s2">&#34;viewbox 0 0 100 100   fill white  rectangle 0,0 100 100&#34;</span>
    <span class="nb">echo</span> <span class="s2">&#34;fill none stroke red   path &#39;M </span><span class="nv">$points</span><span class="s2">&#39;&#34;</span>
    <span class="nb">echo</span> <span class="s2">&#34;fill none stroke blue  path &#39;&#34;</span>
    <span class="k">for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
      <span class="nb">echo</span> <span class="s2">&#34;  M </span><span class="nv">$point</span><span class="s2">  m -2,-2 +4,+4  m -4,0 +4,-4&#34;</span>
    <span class="k">done</span>
    <span class="nb">echo</span> <span class="s2">&#34;&#39;&#34;</span>
  <span class="o">)</span> <span class="p">|</span> convert mvg:- points_cross.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/points_cross.gif" alt="img"></p>
<p>这使用了特殊的shell编程技术，在shell括号中 &ldquo;echo&rdquo; 的任何东西都将作为MVG文件被输入到最终的&quot;转换&quot;命令中。第一个 &ldquo;echo&rdquo; 定义并填充图像的绘图画布，而 &ldquo;while&rdquo; 循环则将每个 &ldquo;点&rdquo; 转换为一个给定半径的圆。</p>
<p>这种方法的优点是，你不会受到任何字符串的限制，而使用其他两种方法可能会受到限制。</p>
<p>其他你可以生成的符号包括方框、钻石、错误条等。</p>
<p>也请参见下面的&quot;绘制圆圈&rdquo;，了解其他圆圈方法，包括不计算相对 &ldquo;路径&quot;的圆圈绘制。</p>
<h4 id="绘制符号的替代方法">绘制符号的替代方法</h4>
<p>除了直接绘制符号外，还有其他的方法可以将符号添加到图像中。</p>
<h5 id="符号字体">符号字体</h5>
<p>您可以从 <a href="https://imagemagick.org/Usage/text/#symbol">Symbol Font</a> 中提取符号，并将其保存为一个小位图。你也可以使用小的预定义但色彩丰富的图像来做这件事。</p>
<p>然而这样做可能会出现问题，无法准确定位字体相对于特定像素的位置。也就是说这不是一个非常精确的技术。但是你可以在任何像素位置组成任何图像。例如这些符号是从一些字体中提取出来的，用于这些示例页面的具体使用。</p>
<pre><code>&lt;=   =&gt;   x   +   +   +   o   o   o   o
</code></pre><p>在<a href="https://imagemagick.org/Usage/layers/#composite">分层图像</a>一节中给出了将图像合成到大背景上的例子。然而，循环的方法可能更有用，例如在<a href="https://imagemagick.org/Usage/layers/#layer_prog">分层图像</a>的程序化定位中给出了。</p>
<p>未来：使用坐标对图像进行分层的例子</p>
<h4 id="形态学">形态学</h4>
<p>另一种选择是使用<a href="https://imagemagick.org/Usage/morphology/#intro">形态学</a>，使用特殊的&quot;形状&quot;内核，如 &ldquo;磁盘&rdquo;、&ldquo;环形 &ldquo;和 &ldquo;加&rdquo;，甚至是你自己的用户定义内核，来 &ldquo;稀释&quot;单个像素。</p>
<p>例如&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 80x80 xc:black -fill white <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;point 20,15 point 55,30 point 40,60&#39;</span>  points_pixels.gif

  convert points_pixels.gif -morphology Dilate Ring    points_rings.gif

  convert points_pixels.gif -morphology Dilate Plus:4  points_pluses.gif

  convert points_pixels.gif -morphology Dilate Cross:3 points_crosses.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/points_pixels.gif" alt="img">
<img src="https://imagemagick.org/Usage/img_www/right.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/points_rings.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/points_pluses.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/points_crosses.gif" alt="img"></p>
<p>然后可以通过使用 <a href="https://imagemagick.org/Usage/masking/#alpha_shape">Alpha Shape Operator</a> 将结果直接转换为彩色叠加。</p>
<p>这样做的最大好处是，你其实不需要知道每个符号的单独位置。或者有多少个符号。但这也可能是一个缺点。一个主要的缺点是，位置只在整数位置。你不能使用浮点 &ldquo;子像素&quot;定位来&quot;绘制&rdquo;。</p>
<h4 id="卷积">卷积</h4>
<p>一个几乎相同的技术是使用 <a href="https://imagemagick.org/Usage/convolve/#convolve">Convolve</a>，使用专门设计的内核，它允许你设置不同的灰度，而不仅仅是一个简单的开/关结果，如上所述。</p>
<p>通过使用不同的<a href="https://imagemagick.org/Usage/morphology/#user">用户定义内核</a>，为图像的每一个通道（红、绿、蓝和阿尔法），甚至可以从每个像素坐标创建多色符号。</p>
<p>为此，我使用了一个我写的特殊脚本 <a href="https://imagemagick.org/Usage/scripts/image2kernel">image2kernel</a> 来将彩色图像（见右图）转换为每个通道的独立浮点卷积核。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  image2kernel -q marker.png marker.dat
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/marker.png" alt="img"></p>
<p>这将生成四个文件，比如 <a href="https://imagemagick.org/Usage/draw/marker_R.dat">marker_R.dat</a>，每个通道都有一个非常小的输入图像，这是<a href="https://imagemagick.org/Usage/morphology/#user">用户定义</a>的图像表示（原点在图像中心）。</p>
<p>现在使用这些内核数据文件，我们可以将这些单点在透明的背景上 <a href="https://imagemagick.org/Usage/convolve/#convolve">Convolve</a> 成我们彩色的标记图像。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert points_pixels.gif -alpha off <span class="se">\
</span><span class="se"></span>          <span class="se">\(</span> -clone <span class="m">0</span> -morphology Convolve @marker_R.dat <span class="se">\)</span> <span class="se">\
</span><span class="se"></span>          <span class="se">\(</span> -clone <span class="m">0</span> -morphology Convolve @marker_G.dat <span class="se">\)</span> <span class="se">\
</span><span class="se"></span>          <span class="se">\(</span> -clone <span class="m">0</span> -morphology Convolve @marker_B.dat <span class="se">\)</span> <span class="se">\
</span><span class="se"></span>          <span class="se">\(</span> -clone <span class="m">0</span> -morphology Convolve @marker_A.dat <span class="se">\)</span> <span class="se">\
</span><span class="se"></span>          -delete <span class="m">0</span> -channel RGBA -combine point_markers.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/points_pixels.gif" alt="img">
<img src="https://imagemagick.org/Usage/img_www/right.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/point_markers.png" alt="img"></p>
<blockquote>
<p>在IM v6.7.6-9之前，Combine Operator 要求图像的透明度通道以 &ldquo;哑光&quot;值而不是alpha值的形式给出，因此，由此产生的alpha通道需要被否定。EG:</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  ... <span class="s2">&#34;`cat marker_A.dat`&#34;</span> -negate <span class="se">\)</span> <span class="se">\
</span></code></pre></div><p>只能使用小图像，像素点要足够分散，符号不要重叠。这是因为 <a href="https://imagemagick.org/Usage/convolve/#convolve">Convolve</a> 会将重叠的区域加在一起，使其比预期的更亮。</p>
<p>以上内容已被转换成UNIX shell脚本 <a href="https://imagemagick.org/Usage/scripts/convolve_image">convolve_image</a>，以方便使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convolve_image  points_pixels.gif marker.png   point_markers.png
</code></pre></div><p>这个技术源于IM论坛上的一个讨论-<a href="https://imagemagick.org/Usage/forum_link.cgi?t=17259&amp;p=64696">IM 的有趣体验</a>。用户希望在足球场的背景图上放置小人，让他们的位置在图片中拼出一个人的名字。</p>
<h4 id="分层">分层</h4>
<p>一种不同的技术，如<a href="https://imagemagick.org/Usage/layers/">图像层</a>，使用你从源图像中提取的像素列表进行定位，可能是更好的方法。你可以先叠加更远的符号图像，然后再叠加前景图像，你可以通过编程选择或随机选择什么符号替换什么点。</p>
<p>关于这个例子，请看<a href="https://imagemagick.org/Usage/layers/#layer_pins">地图中的图钉</a>。</p>
<h4 id="绘制圆圈">绘制圆圈</h4>
<p>绘制选项为您提供了许多方法来完成一些非常基本的工作。绘制圆。</p>
<p>例如，您可以在圆周上的任何一点上画一个圆，因此您需要计算一个中心点和一个半径为25像素的第二点。因此，您需要计算一个中心点和第二个点，这个点的半径（例如25像素）离第一个点的距离。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:  -stroke Firebrick  -fill tomato  -strokewidth <span class="m">2</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;circle 50,30 50,55&#39;</span>    circle_circle.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_circle.gif" alt="img"></p>
<p><a href="http://www.fmwconcepts.com/fmw/fmw.html">Fred Weinhaus</a> 指出，通过使用平移，你可以消除计算圆边坐标的需要，而直接给出半径即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:  -stroke SeaGreen  -fill PaleGreen  -strokewidth <span class="m">2</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;translate 50,30 circle 0,0 25,0&#39;</span>    circle_circle_trans.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_circle_trans.gif" alt="img"></p>
<p>但是当绘制多个圆时，上述操作需要对每个圆进行单独的 <code>-draw</code> 操作，或者使用 <a href="https://imagemagick.org/Usage/draw/#push_context">Context Pushing</a>。</p>
<p>使用椭圆可以直接指定半径为轴长</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:  -stroke Sienna  -fill Wheat  -strokewidth <span class="m">2</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;ellipse 50,30 25,25 0,360&#39;</span>    circle_ellipse.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_ellipse.gif" alt="img"></p>
<p>你也可以用 <code>stroke-lineecap round</code> 画一条非常非常短的线来生成一个圆。描边的宽度可以设置圆的直径。注意线条必须有一定的长度（无论多小），否则画不出任何东西。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:  -stroke Blue  -strokewidth <span class="m">50</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;stroke-linecap round line 50,30 50,30.0001&#39;</span> <span class="se">\
</span><span class="se"></span>          circle_line.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_line.gif" alt="img"></p>
<p>这种技术，不幸的是不能勾勒出生成的圆，但对于覆盖大面积的区域，大笔触宽度是有用的。请看下面一些简单的例子。</p>
<p>这种方法利用了 <a href="https://imagemagick.org/Usage/draw/#paths">SVG 路径</a>的绘制方法，所以可以在不需要计算任何额外坐标的情况下绘制圆形。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:  -stroke Blue  -fill DodgerBlue  -strokewidth <span class="m">2</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 50,30  m 0,25  a 1,1 0 0,0 0,-50  a 1,1 0 1,0 0,50&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          circle_path.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_path.gif" alt="img"></p>
<p>只有最初的绝对移动 &lsquo;M&rsquo; 是用来定义中心的，接下来的路径组件中的 &lsquo;25&rsquo; 和 &lsquo;50&rsquo; 是定义相对于这个中心的圆的半径和直径。</p>
<blockquote>
<p>在IM v6.4.3-5之前，相对移动SVG路径项 &rsquo;m' 是被破坏的。 如果您的IM比这更早，圆可能只显示为一个像素。您可以通过将上面的 &rsquo;m' 替换为 &lsquo;l&rsquo; 来修复旧版本的问题。</p>
</blockquote>
<p><a href="http://www.fmwconcepts.com/fmw/fmw.html">Fred Weinhaus</a> 添加了以下贝塞尔圆的方法。它非常接近真实的圆（虽然不精确），并且需要进行浮点计算。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">r</span><span class="o">=</span>25<span class="p">;</span>  <span class="nv">cx</span><span class="o">=</span>50<span class="p">;</span>  <span class="nv">cy</span><span class="o">=</span>30<span class="p">;</span>
  <span class="nv">x1</span><span class="o">=</span>25<span class="p">;</span>     <span class="nv">x2</span><span class="o">=</span>75<span class="p">;</span>      <span class="c1"># = cx ± radius</span>
  <span class="nv">y1</span><span class="o">=</span>-3.25<span class="p">;</span>  <span class="nv">y2</span><span class="o">=</span>63.25<span class="p">;</span>   <span class="c1"># = cy ± radius*1.275</span>

  convert -size 100x60 xc:  -stroke Purple  -fill Violet  -strokewidth <span class="m">2</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;bezier </span><span class="nv">$x1</span><span class="s2">,</span><span class="nv">$cy</span><span class="s2"> </span><span class="nv">$x1</span><span class="s2">,</span><span class="nv">$y1</span><span class="s2">  </span><span class="nv">$x2</span><span class="s2">,</span><span class="nv">$y1</span><span class="s2"> </span><span class="nv">$x2</span><span class="s2">,</span><span class="nv">$cy</span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;bezier </span><span class="nv">$x1</span><span class="s2">,</span><span class="nv">$cy</span><span class="s2"> </span><span class="nv">$x1</span><span class="s2">,</span><span class="nv">$y2</span><span class="s2">  </span><span class="nv">$x2</span><span class="s2">,</span><span class="nv">$y2</span><span class="s2"> </span><span class="nv">$x2</span><span class="s2">,</span><span class="nv">$cy</span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          circle_bezier.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_bezier.gif" alt="img"></p>
<p>如果画一个精确的圆并不重要，你可以使用这个4 Bezier段 SVG 路径，它只使用圆的X和Y边界进行计算。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">r</span><span class="o">=</span>25<span class="p">;</span>  <span class="nv">cx</span><span class="o">=</span>50<span class="p">;</span>  <span class="nv">cy</span><span class="o">=</span>30<span class="p">;</span>
  <span class="nv">x1</span><span class="o">=</span>25<span class="p">;</span>    <span class="nv">x2</span><span class="o">=</span>75<span class="p">;</span>      <span class="c1"># X bounds = cx ± radius</span>
  <span class="nv">y1</span><span class="o">=</span>5<span class="p">;</span>     <span class="nv">y2</span><span class="o">=</span>55<span class="p">;</span>      <span class="c1"># Y bounds = cy ± radius</span>

  convert -size 100x60 xc:  -stroke Tomato  -fill Gold  -strokewidth <span class="m">2</span> <span class="se">\
</span><span class="se"></span>     -draw <span class="s2">&#34;path &#39;M </span><span class="nv">$cx</span><span class="s2">,</span><span class="nv">$y1</span><span class="s2"> Q </span><span class="nv">$x1</span><span class="s2">,</span><span class="nv">$y1</span><span class="s2"> </span><span class="nv">$x1</span><span class="s2">,</span><span class="nv">$cy</span><span class="s2"> T </span><span class="nv">$cx</span><span class="s2">,</span><span class="nv">$y2</span><span class="s2"> </span><span class="nv">$x2</span><span class="s2">,</span><span class="nv">$cy</span><span class="s2"> </span><span class="nv">$cx</span><span class="s2">,</span><span class="nv">$y1</span><span class="s2"> z&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>     circle_bezier_path.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_bezier_path.gif" alt="img"></p>
<p>如果你喜欢一个完全相对于中心起点绘制的，你可以使用这种技术。只使用半径值，使其生成简单，只使用 API 中的字符串函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:  -stroke Orange  -fill LemonChiffon  -strokewidth <span class="m">2</span> <span class="se">\
</span><span class="se"></span>     -draw <span class="s2">&#34;path &#39;M 50,30  m 0,25  q 25,0 25,-25  t -25,-25  -25,25  25,25 z&#39;&#34;</span><span class="se">\
</span><span class="se"></span>     circle_bezier_path_rel.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_bezier_path_rel.gif" alt="img"></p>
<p>你能想到其他画圆的方法吗？</p>
<h3 id="绘制箭头-定位旋转和缩放符号">绘制箭头-定位、旋转和缩放符号</h3>
<p>使用上述技术，你可以创建一个特殊的符号，如箭头，你可以定位，使其点在线的最末端，并画在它上面。如果你画的箭头后的线（典型的情况），那么箭头将被绘制在该行的顶部。</p>
<p>然而，他们有三种类型的箭头，可以定义，每个类型的定义在不同的方式取决于它的使用。</p>
<ul>
<li>测量时，你只是想用箭头头标记线的两端，以指示一些工程图中的测量极限。非常简单。</li>
<li>矢量，显示一些数值的方向和强度。例如在天气风图中。需要一个尾巴，0,0点就是尾巴的末端。通常情况下，这样的向量会形成一个大网格。</li>
<li>指标，指出一些细节。对于这个0,0点可能应该是箭尖，或者是箭头本身前面的一些距离。</li>
</ul>
<h4 id="测量箭头">测量箭头</h4>
<p>简单地在一条线的末端添加一个箭头是比较容易做到的。基本上，您可以创建一个 &lsquo;arrow head&rsquo; <a href="https://imagemagick.org/Usage/draw/#symbols">符号</a>，并将其画在正确的位置。</p>
<p>例如&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">arrow_head</span><span class="o">=</span><span class="s2">&#34;l -15,-5  +5,+5  -5,+5  +15,-5 z&#34;</span>

  convert -size 100x60 xc: -draw <span class="s1">&#39;line 10,30 80,30&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke blue fill skyblue
</span><span class="s2">                 path &#39;M 80,30  </span><span class="nv">$arrow_head</span><span class="s2">&#39; &#34;</span> <span class="se">\
</span><span class="se"></span>          arrow_horizontal.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/arrow_horizontal.gif" alt="img"></p>
<p>请注意，我画的符号，使其起点是线的最末端。这样一来，它就可以在之前画好的线上面向后画，形成一个非常漂亮的整齐的符号。</p>
<p>箭头却有一个相关的方向。你可以在许多不同的角度创建大量的箭头定义，许多程序都这样做。但是既然箭头是一个矢量，那么为什么不把箭头作为一个矢量进行旋转呢。IM绘图命令内置了绘图旋转（<a href="https://imagemagick.org/Usage/draw/#transform">Canvas Warping</a>），所以让我们使用它们。</p>
<p>这样做还有一个好处，就是把位置从箭头头的 <code>path</code> 定义中移出来，让你把整个路径指定为 <code>constant</code>&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">arrow_head</span><span class="o">=</span><span class="s2">&#34;path &#39;M 0,0  l -15,-5  +5,+5  -5,+5  +15,-5 z&#39;&#34;</span>

  convert -size 100x60 xc: -draw <span class="s1">&#39;line 25,55 70,10&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke blue fill skyblue
</span><span class="s2">                 translate 70,10 rotate -45
</span><span class="s2">                 </span><span class="nv">$arrow_head</span><span class="s2">
</span><span class="s2">                &#34;</span> <span class="se">\
</span><span class="se"></span>          arrow_rotate.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/arrow_rotate.gif" alt="img"></p>
<p>如果你喜欢改变箭头的大小，可以在旋转后增加一个 <code>scale</code> 绘制选项。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">arrow_head</span><span class="o">=</span><span class="s2">&#34;path &#39;M 0,0  l -15,-5  +5,+5  -5,+5  +15,-5 z&#39;&#34;</span>

  convert -size 100x60 xc: -draw <span class="s1">&#39;line 25,55 70,10&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke blue fill skyblue
</span><span class="s2">                 translate 70,10 rotate -45 scale 2,2
</span><span class="s2">                 </span><span class="nv">$arrow_head</span><span class="s2">
</span><span class="s2">                &#34;</span> <span class="se">\
</span><span class="se"></span>          arrow_scale.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/arrow_scale.gif" alt="img"></p>
<p>请注意，它是如何放大离开箭头的&quot;尖端&rdquo;，你指定的地方。这是处理箭头的一个非常重要的方面，因为它是唯一的终点，和角度的线，你正在添加箭头的事项。</p>
<p><code>transforms</code> 的顺序是很重要的，而且实际上与它们实际被处理的顺序是相反的。也就是先将比例尺应用于座标，然后是旋转，再是平移。如果座标变换不是按照这个顺序进行的，我们最终也会对箭头的最终位置进行缩放，而不是我们期望的位置。</p>
<p>另外由于比例尺有两个数字，而原来的箭头头符号是水平设计的（角度为零），所以可以分别将箭头的宽度与高度进行比例。同时注意笔画宽度也随着箭头的大小而缩放，保持一致。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">arrow_head</span><span class="o">=</span><span class="s2">&#34;path &#39;M 0,0  l -15,-5  +5,+5  -5,+5  +15,-5 z&#39;&#34;</span>

  convert -size 100x60 xc: -draw <span class="s1">&#39;line 25,55 70,10&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke blue fill skyblue
</span><span class="s2">                 translate 70,10 rotate -45 scale 2,1
</span><span class="s2">                 </span><span class="nv">$arrow_head</span><span class="s2">
</span><span class="s2">                &#34;</span> <span class="se">\
</span><span class="se"></span>          arrow_scale_aspect.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/arrow_scale_aspect.gif" alt="img"></p>
<p>现在，当你在画布上翘起一个个箭头时，也许还有许多其他的绘画操作，你可能喜欢在一次 <code>[&quot;-draw&quot;](https://imagemagick.org/Usage/option_link.cgi?draw)</code> 操作中把它们全部画完。说要画线，然后在两端添加箭头，需要不同的颜色、位置、旋转，甚至可能是不同的比例。这意味着我们需要将画布翘曲的范围限制在每个单独箭头头的绘制上。如果你不限制范围，你可能会在以后开始影响到其他后面的绘制操作，永远不能很确定你生成的是什么。</p>
<p>为了限制翘曲的范围（以及所有其他的绘图属性），您将涉及到的部分包裹在一个 <code>graphic-context</code>&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">arrow_head</span><span class="o">=</span><span class="s2">&#34;path &#39;M 0,0  l -15,-5  +5,+5  -5,+5  +15,-5 z&#39;&#34;</span>

  convert -size 100x60 xc: <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke black fill none
</span><span class="s2">                 path &#39;M 10,40 A 50,50 0 0,1 90,40&#39;
</span><span class="s2">                 push graphic-context
</span><span class="s2">                   stroke blue fill skyblue
</span><span class="s2">                   translate 10,40 rotate 135
</span><span class="s2">                   </span><span class="nv">$arrow_head</span><span class="s2">
</span><span class="s2">                 pop graphic-context
</span><span class="s2">                 push graphic-context
</span><span class="s2">                   stroke firebrick fill tomato
</span><span class="s2">                   translate 90,40 rotate 45
</span><span class="s2">                   </span><span class="nv">$arrow_head</span><span class="s2">
</span><span class="s2">                 pop graphic-context
</span><span class="s2">                &#34;</span> <span class="se">\
</span><span class="se"></span>          arrow_context.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/arrow_context.gif" alt="img"></p>
<p><code>push</code> 主要是将当前所有的绘图属性保存起来，以备将来使用，而 <code>pop</code> 则恢复这些属性，用之前保存的设置替换任何设置（颜色、扭曲、位置等）。这意味着在 &lsquo;popping&rsquo; 之后，&lsquo;canvas warp&rsquo; 会被取消，画图会回到修改之前的状态。</p>
<p>上述技术只是生成箭头的一种方法，在绘制箭头作为测量距离的一部分时，如在技术图纸中，是一种很好的方法。</p>
<h4 id="矢量箭头">矢量箭头</h4>
<p>如前所述，矢量既显示方向，又显示某个数值的强度。这意味着箭头的长度是可变的，箭头头可以在任何位置远离向量的起点。</p>
<p>现在，你可以做一些沉重的数学计算的位置，箭头头应该是地方给定的向量的长度和角度，但他们是一个更好的方法，这让 ImageMagick 为你做这些计算。</p>
<p>解决的办法是在 <a href="https://imagemagick.org/Usage/draw/#transform">Warped Canvas Space</a> 中画一条长度合适的水平线作为向量长度。当这条线画好后，只需将绘图空间再次转换到线的末端，而画布仍然是&quot;扭曲的&rdquo;(<code>warped</code>)。现在你的位置已经正确了，只要正确的旋转就可以像正常的那样画出矢量的 <code>'arrow head'</code>。</p>
<p>例如，这里我以-35度角生成一个70像素长的矢量。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">vector_head</span><span class="o">=</span><span class="s2">&#34;path &#39;M 0,0  l -15,-5  +5,+5  -5,+5  +15,-5 z&#39;&#34;</span>
  <span class="nv">indicator</span><span class="o">=</span><span class="s2">&#34;path &#39;M 10,0  l +15,+5  -5,-5  +5,-5  -15,+5  m +10,0 +20,0 &#39;&#34;</span>

  convert -size 100x100 xc: <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke black fill none  circle 20,50 23,50
</span><span class="s2">                 push graphic-context
</span><span class="s2">                   stroke blue fill skyblue
</span><span class="s2">                   translate 20,50 rotate -35
</span><span class="s2">                   line 0,0  70,0
</span><span class="s2">                   translate 70,0
</span><span class="s2">                   </span><span class="nv">$vector_head</span><span class="s2">
</span><span class="s2">                 pop graphic-context
</span><span class="s2">                 push graphic-context
</span><span class="s2">                   stroke firebrick fill tomato
</span><span class="s2">                   translate 20,50 rotate 40
</span><span class="s2">                   </span><span class="nv">$indicator</span><span class="s2">
</span><span class="s2">                   translate 40,0 rotate -40
</span><span class="s2">                   stroke none fill firebrick
</span><span class="s2">                   text 3,6 &#39;Center&#39;
</span><span class="s2">                 pop graphic-context
</span><span class="s2">                &#34;</span> <span class="se">\
</span><span class="se"></span>          arrow_with_tails.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/arrow_with_tails.gif" alt="img"></p>
<h4 id="指示箭头">指示箭头</h4>
<p>在上面我还演示了一个指示箭头，指向之前矢量箭头的起点。</p>
<p>然而我没有像之前那样画箭头，而是将它创建为一个反向的箭头符号，它的起始点距离原点（或起始点）10像素。这是一个符号位于我想要指示的位置，所以我实际上并不希望箭头直接在那个位置上面，而是离它稍微远一点。</p>
<p>现在，虽然指示符比向量处理起来更简单，通常不需要可变长度，但你通常要在指示符的远端添加文字来指定指示的内容。和之前一样，计算这个位置可能很困难，何必呢。</p>
<p>文字定位的解决方法也和向量一样。保留原来用于绘制指示箭头的翘曲空间，并将原点转换到该箭头的尾端（在翘曲空间中水平40像素）。现在我们已经重新定位了，我们可以围绕这个新的位置解除扭曲，这样你就可以像正常的那样绘制文本（有轻微的偏移）。</p>
<p>不幸的是，虽然默认的文字对齐方式是&quot;左&rdquo;，但目前你不能在 MVG 中指定文字对齐方式，作为重力的单独设置。如果这是一个问题，请在 IM bugs 论坛上提出请求，希望文本对齐（作为独立于重力定位）能够成为现实，尤其是它实际上是 SVG 规范的一部分。</p>
<h3 id="绘制对象">绘制对象</h3>
<h4 id="宽广的色彩笔触">宽广的色彩笔触</h4>
<p>你不需要用路径或轮廓完全封闭填充区域，就能创造出各种形状。使用非常大和宽的<a href="https://imagemagick.org/Usage/draw/#stroke">笔触</a>，你可以在画布上生成大面积的颜色和色块。</p>
<p>例如，一个宽阔的笔触椭圆弧形可以生成一个漂亮的颜色区域，我实际上已经看到用于创建海报。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x100 xc: -fill none -stroke powderblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;stroke-width 70 ellipse -30,0 90,90 10,50&#39;</span> <span class="se">\
</span><span class="se"></span>          -rotate <span class="m">180</span>  arc_background.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/arc_background.gif" alt="img"></p>
<p>或者你可以生成一个小丑相当复杂的笑容。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x100 xc: <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;fill none stroke-linecap round
</span><span class="s1">             stroke-width 40 stroke tomato ellipse 50,0 70,70 65,115
</span><span class="s1">             stroke-width 2  stroke black  ellipse 50,0 70,70 60,120
</span><span class="s1">             stroke-width 40 stroke palegreen line 50,40 50,40.01&#39;</span> clown.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/clown.gif" alt="img"></p>
<p>你能想出什么办法？请告诉我们。</p>
<h4 id="圆柱体">圆柱体</h4>
<p>在 <a href="https://imagemagick.org/Usage/forum_link.cgi?t=17550">IM 论坛的讨论</a>中，有一个关于使用 ImageMagick 绘制命令绘制圆柱体（特别是阴影圆柱体）的重要讨论。</p>
<p>绘制圆柱体的诀窍是绘制 <code>roundrectangle</code> 原语，使其末端形成椭圆形。也就是说，如果圆柱体的宽度为 50 像素，则将矩形的角分别舍去 25 和 12 像素。这就是矩形宽度的一半，然后再减半。</p>
<p>这样，一个圆柱体就变成了两个相互叠加的圆角矩形。第二个颜色填充的 <code>'end oval'</code> 的大小正好是两个角的两倍。例如&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 60x100 xc:white -stroke snow4 <span class="se">\
</span><span class="se"></span>          -fill chartreuse3    -draw <span class="s1">&#39;roundrectangle 5,5 55,95 25,12&#39;</span> <span class="se">\
</span><span class="se"></span>          -fill chartreuse2    -draw <span class="s1">&#39;roundrectangle 5,5 55,29 25,12&#39;</span> <span class="se">\
</span><span class="se"></span>          cylinder.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/cylinder.gif" alt="img"></p>
<p>通过将第一种填充色替换为渐变色（使用<a href="https://imagemagick.org/Usage/canvas/#tile_memory">记忆中的平铺技术</a>），你可以让圆柱体看起来更像3D&hellip;&hellip;。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 60x100 xc:white -stroke snow4 <span class="se">\
</span><span class="se"></span>          <span class="se">\(</span> -size 1x60 gradient:chartreuse1-chartreuse4 -rotate -90 <span class="se">\
</span><span class="se"></span>             -write mpr:shading +delete <span class="se">\)</span> <span class="se">\
</span><span class="se"></span>          -tile mpr:shading  -draw <span class="s1">&#39;roundrectangle 5,5 55,95 25,12&#39;</span> +tile <span class="se">\
</span><span class="se"></span>          -fill chartreuse2  -draw <span class="s1">&#39;roundrectangle 5,5 55,29 25,12&#39;</span> <span class="se">\
</span><span class="se"></span>          cylinder_shade.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/cylinder_shade.gif" alt="img"></p>
<p>通过慢慢完善圆柱体的绘制（如IM论坛中讨论的那样），你可以走很长的路来生成非常复杂和具有视觉吸引力的圆柱体。这包括增加封闭半透明玻璃圆柱体、阴影效果和标签。</p>
<p>该讨论的最终结果是一个脚本 &ldquo;<a href="https://imagemagick.org/Usage/scripts/cylinder_bar">cylinder_bar</a>&quot;，生成一个圆柱体百分比条&hellip;&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  cylinder_bar <span class="m">95</span> cylinder_95.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/cylinder_95.png" alt="img"></p>
<p>该脚本可以生成任何尺寸的图像，根据该尺寸和脚本顶部定义的其他设置适当调整所有参数。还包括 <code>glass thickness</code> 的概念，在一个封闭的半透明玻璃圆柱体和内部的彩色圆柱体之间创造一个间隙。</p>
<p>请注意圆柱体非常微妙的阴影，特别是当绿色圆柱体的末端与玻璃圆柱体的末端重叠时。只要稍加预想，就能做出惊人的效果。</p>
<h3 id="在文字串中绘制特殊字符">在文字串中绘制特殊字符</h3>
<h4 id="引号还是反斜杠">引号还是反斜杠？</h4>
<p>人们在使用 <code>-draw</code> 时遇到的最大的问题之一是绘制字符，这些字符对 UNIX shell 和 DOS 命令行甚至其他语言如 C、Perl、PHP、R 或 Visual Basic 都有特殊意义。</p>
<p>在这方面最大的罪魁祸首是两种类型的引号字符，以及变量替换字符，如美元 <code>'$'</code> 和 shell 和 ImageMagick 的转义字符，反斜杠 <code>'\'</code>。</p>
<p>基本上作为 <code>-draw</code> 的MVG参数需要加引号，而里面的 <code>'text'</code> 字符串参数也可能需要一些额外的引号。</p>
<p>为了解决这个问题，用户通常会使用两个不同的引号字符，一个用于 shell，另一个用于 MVG 文本字符串。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">-draw <span class="s1">&#39;... text 0,0 &#34;string&#34; ...&#39;</span>
</code></pre></div><p>需要注意的是，对于 windows 用户来说，这是唯一真正的选择，它有自己的引号问题和方法。或者他们会交换引号，用&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">-draw <span class="s2">&#34;... text 0,0 &#39;string&#39; ...&#34;</span>
</code></pre></div><p>它允许你包含 shell 变量替换(使用 <code>'$'</code> 而不进行转义。)</p>
<p>选择正确的形式可以解决大多数问题，但有些字符仍然存在困难，每个解决方案都取决于你到底使用哪一组引号，因为它们也定义了特殊字符应该如何转义。</p>
<p>以下是四种情况下的引号，以及特殊字符的处理&hellip;</p>
<ul>
<li>对 shell 参数使用单引号，对 MVG 文本字符串周围使用双引号。</li>
</ul>
<p>处理绘制文本字符串的最简单的技术是为包装 shell 参数使用单引号。然而，这意味着要在绘制的字符串中包含一个撇号，你需要离开 shell 的&quot;单引号模式&rdquo;，并在 shell 的单引号之外提供撇号。</p>
<p>例如，这里是如何处理我提到的四个特殊字符。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 250x50 xc:none  -box white  -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;text 0,0 &#34;  &#39;</span><span class="se">\&#39;</span><span class="s1">&#39;  \&#34;  $  \\  &#34; &#39;</span> <span class="se">\
</span><span class="se"></span>          -trim +repage  text_special_sd.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/text_special_sd.gif" alt="img"></p>
<p>请注意，由于美元符号不需要转义，你也不能用它来替代 shell 变量的内容。</p>
<p>重要的是要记住，反斜杠是IM绘图字符串处理的唯一特殊字符。同时，它存在的原因也纯粹是为了让你可以转义任何&quot;IM 绘制字符串引号&rdquo;，比如我们在上面使用的双引号。除此以外，其他所有的怪异都是由 UNIX 命令行 shell 引起的，而不是 IM。</p>
<p>PC-DOS 有它自己的怪异之处，我希望在使用环境中的IM时，能对特殊字符进行转义。</p>
<ul>
<li>在 shell 参数中使用双引号。
在 MVG 文本字符串周围使用单引号。</li>
</ul>
<p>如果你确实想在绘制的字符串中插入一个 &lsquo;shell variable&rsquo;，那么你将不得不在 shell 参数的外面使用双引号。这使得整个事情变得更加复杂，因为你失去了 shell 的保护，你现在不仅要转义美元 <code>'$'</code> 符号，而且还要转义反斜杠 <code>'\'</code>。</p>
<p>另一方面，shell 将不需要使用单引号字符作为它的参数结束限制字符，所以这方面被简化了。让我们总结一下我们的特殊字符短名单的结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 250x50 xc:none  -box white  -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;text 0,0 &#39;  \\&#39;  \&#34;  \$  \\\\  &#39; &#34;</span> <span class="se">\
</span><span class="se"></span>          -trim +repage  text_special_ds.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/text_special_ds.gif" alt="img"></p>
<p>请注意，如果你想画一个反斜线本身，MVG 文本字符串需要将反斜线加倍（如前面的例子），但是 shell 本身也需要将每个反斜线加倍，总共产生四个反斜线才能产生一个这样的字符。</p>
<p>这种翻倍很快就会让人不知所措，需要大量的反斜杠才能达到你想要的效果。只要采取的是慢慢的、简单的方法，你就会针对自己的情况想出办法。</p>
<ul>
<li>使用单引号进行 shell 论证。
与 MVG 文本字符串周围的单引号。</li>
</ul>
<p>最后，让我们总结一下最后两种引号组合。我将让你去弄清楚它们是如何被 shell 和 MVG 解码的。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 250x50 xc:none  -box white  -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;text 0,0 &#39;</span><span class="se">\&#39;</span><span class="s1">&#39;  \&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;  &#34;  $  \\  &#39;</span><span class="se">\&#39;</span><span class="s1">&#39; &#39;</span> <span class="se">\
</span><span class="se"></span>          -trim +repage  text_special_ss.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/text_special_ss.gif" alt="img"></p>
<ul>
<li>在shell参数中使用双引号。</li>
</ul>
<p>在 MVG 文本字符串周围加上双引号。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 250x50 xc:none  -box white  -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;text 0,0 \&#34;  &#39;  \\\&#34;  \$  \\\\  \&#34;&#34;</span> <span class="se">\
</span><span class="se"></span>          -trim +repage  text_special_dd.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/text_special_dd.gif" alt="img"></p>
<p>正如你所看到的，来自命令行的 <code>-draw</code> 参数既要处理命令行 shell，也要处理 MVG 文本字符串中的反斜杠和引号转义。其结果可能会让人感到困惑和棘手。只要记住，shell 对这两种引号的处理方式不同，而 MVG 文本字符串则不同。</p>
<p>当然，在复杂的脚本中，更好的方法可能是完全避免 shell 和任何脚本问题。你可以通过读取 MVG 绘图文件中的 <code>-draw</code> 参数来实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">-draw @drawfile.mvg
</code></pre></div><p>当然，你仍然需要对你使用的任何引号字符进行反斜杠处理，以及对文本中的任何反斜杠进行处理。然而，这比起同时处理 shell 自己的引号和转义系统要简单得多。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 500x50 xc:lightblue  -font Candice -pointsize <span class="m">36</span> <span class="se">\
</span><span class="se"></span>          -gravity center     -draw @text_quotes.mvg      text_quotes.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/img_www/right.gif" alt="img"><img src="https://imagemagick.org/Usage/draw/text_quotes.gif" alt="img"></p>
<p>第一张图片来自我使用的一个 &ldquo;MVG&rdquo; 文本文件。它不包含转义符或引号。因此，只有 MVG 引号和转义符是存在的。</p>
<p>请注意，在上面的例子中，如果我对 MVG 文本字符串使用了单引号，唯一的变化是我需要对字符串中的单引号字符进行反斜杠处理，而不是双引号字符。</p>
<h4 id="关于百分比字符">关于百分比字符</h4>
<p>最后一点是关于 <code>&quot;-draw text&quot;</code> 操作符中的特殊 <code>escape</code> 字符。百分号字符 <code>&quot;%&quot;</code> 应该&quot;按原样&quot;绘制。你不需要做任何特殊的操作来绘制它们。如果它们不能&quot;按原样&quot;绘制，那么你的IM版本较旧，应该尽快升级。</p>
<blockquote>
<p>直到IM 6.2.4版本，<code>&quot;%&quot;</code> 字符被用作转义字符，在绘制的文本字符串中包含额外的图像信息。现在不再是这样了，因为当SVG图像也试图绘制百分数字符时，这种转义符是混乱和不正确的。
百分号 &ldquo;转义符 &ldquo;的使用（以及&rdquo;/n &ldquo;换行符）被认为与 <code>-draw</code> 操作符和MVG格式处理SVG图像格式的预期用途不兼容。因此，从 IM 6.2.4 版本开始，%转义就不适用了，反斜杠只能转义自己和周围的引号。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">    convert -size 250x50 xc:none -box white  -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>            -draw <span class="s1">&#39;text 0,0 &#34;%w\n%h&#34;&#39;</span>    -trim +repage text_escapes.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/text_escapes.gif" alt="img"></p>
<p>关于&quot;百分比错误&quot;的更多细节，以及在旧版 ImageMagick 中使用 <code>-draw</code> 时避免该错误的方法，请参见 <a href="https://imagemagick.org/Usage/bugs/draw_percent/">Drawing a Percent Bug</a> 页面。</p>
<h4 id="用注释代替绘制">用注释代替绘制</h4>
<p>避免这类问题的较好方法是使用 <code>[-annotate](https://imagemagick.org/Usage/option_link.cgi?annotate)</code> 而不是  <code>draw</code> 来绘制文本。这个操作符是 <code>draw</code> 操作符的一个封装器，可以使用 <code>draw</code> 的所有功能，但形式更简单。</p>
<p>基本上这个操作符只需要一组引号（对于 shell）。这使得处理特殊字符变得更加简单。</p>
<p>不幸的是，虽然你不再需要为 IM 转义引号，但你现在有百分比转义，如 <code>'@'</code> 文件读取，<code>'\n'</code> 换行，以及其他<a href="https://imagemagick.org/Usage/basics/#arg_percent">百分号转义</a>扩展。</p>
<p>例如，使用单引号&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">    convert -size 200x50 xc:none  -box white  -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>            -annotate <span class="m">0</span> <span class="s1">&#39;\@  &#39;</span><span class="se">\&#39;</span><span class="s1">&#39;  &#34;  $  \\  %% &#39;</span> <span class="se">\
</span><span class="se"></span>            -trim +repage  annotate_s.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/annotate_s.gif" alt="img"></p>
<p>而对于双引号&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">    convert -size 200x50 xc:none -box white -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>            -annotate <span class="m">0</span> <span class="s2">&#34;\@  &#39;  \&#34;  \$  \\\\  %% &#34;</span> <span class="se">\
</span><span class="se"></span>            -trim +repage  annotate_d.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/annotate_d.gif" alt="img"></p>
<p>然而，如果你使用 <code>'@'</code> 转义符从文件中读取字符串，所有的注释引号和转义符将被完全忽略。</p>
<p>例如，我们在这里包含了一个图像的宽度和高度的信息!</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">    convert -size 200x50 xc:none -box white -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>            -annotate <span class="m">0</span> <span class="s1">&#39;%w\n%h&#39;</span> -trim +repage    annotate_percents.gif
</code></pre></div><p>然而，当从文件中读取注释字符串时，所有的转义都会被完全忽略。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">    <span class="nb">echo</span> -n <span class="s1">&#39;@ %w\n%h&#39;</span> <span class="p">|</span><span class="se">\
</span><span class="se"></span>      convert -size 200x50 xc:none -box white -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>              -annotate <span class="m">0</span> <span class="s1">&#39;@-&#39;</span>  -trim +repage  annotate_file.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/annotate_file.gif" alt="img"></p>
<p>更多信息请参见 <a href="https://imagemagick.org/Usage/text/#annotate">Annotate Text Drawing Operator</a>，特别是 <a href="https://imagemagick.org/Usage/text/#escape_chars">Annotate Escape Characters</a>。</p>
<h2 id="im-和-svg-处理">IM 和 SVG 处理</h2>
<h3 id="svg-输入驱动rsvg-与-msvg">SVG 输入驱动。RSVG 与 MSVG</h3>
<p>处理实际的 SVG 图像格式是一项非常复杂的工作。引擎需要处理 <a href="http://www.w3.org/TR/SVG/">SVG&ndash;可缩放矢量图形</a>文档所定义的所有方面。这需要大量的编程工作和时间。</p>
<p>因此，ImageMagick 在 SVG 格式图像的处理上提供了两种方法。第一种是使用一个开源的 RSV G库，将 SVG 格式转换成 IM 没有问题的光栅图像。这个引擎几乎在 SVG 处理的所有方面都是完整的。</p>
<p>第二种方法是IM尝试将 SVG 转换为 MVG，使用一个名为 MSVG 的内置IM方法。MSVG 试图将SVG图像转换成IM的 <code>-draw</code> 运算符 &ldquo;MVG&quot;绘图语言。绘制 MVG 的很多功能都是专门为此而创建的。不幸的是，虽然基本的线条绘制和着色功能是存在的，但它远不是一个完整的 SVG 转换器。</p>
<p>你可以通过使用特殊的输入格式 &ldquo;MSVG:&quot;（IM v6.3.4新增）读取 SVG 图像来强制使用内部的 MSVG 转换器。但如果 RSVG 库存在，大多数 ImageMagick 将使用它来渲染 <code>SVG</code> 图像。</p>
<p>要找出你的 IM 会做什么，请用&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -list format <span class="p">|</span> grep SVG
</code></pre></div><p>从括号中的 &ldquo;RSVG&rdquo; 可以看出，我自己的 IM 将使用我电脑上的 RSVG 库，并给出了版本。</p>
<p>在这里，我&quot;绘制&quot;了一个小的、手工制作的 SVG 图像 &ldquo;<a href="https://imagemagick.org/Usage/draw/diagonal.svg">diagonal.svg</a>&quot;（由论坛用户 <a href="https://imagemagick.org/Usage/forum_link.cgi?u=8538">penciledin</a> 贡献），它在白色背景上创建了一个简单的对角线渐变的矩形。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert diagonal.svg  diagonal_rsvg.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/diagonal_rsvg.gif" alt="img"></p>
<p>完美的。一个正确的对角线梯度被生成。</p>
<p>然而，如果你使用内部的 MSVG（如果没有 RSVG 库，则为默认值）来渲染&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert msvg:diagonal.svg  diagonal_msvg.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/diagonal_msvg.gif" alt="img"></p>
<p>正如你所看到的，内部 MSVG 转换失败，返回的是垂直梯度而不是对角线。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert msvg:diagonal.svg diagonal.mvg
</code></pre></div><p>你大概可以看到MSVG转换器是如何尝试将 SVG 转换为 MVG 绘图命令的。</p>
<p>当前内部 MSVG 已知失败的地方包括&hellip;</p>
<ul>
<li>非垂直梯度(没有转换到新的MVG梯度处理)</li>
<li>沿着弯曲路径的文字</li>
<li>文本对齐（与重力分开）。</li>
</ul>
<p>然而大多数基本的绘图动作都被处理了。</p>
<p>还请记住，MVG 语言实际上可以处理 SVG 不能处理的事情，包括使用重力来定位图像和文本。重力不是 SVG 规范的一部分，尽管它是 IM 文本和字体处理的一个组成部分。</p>
<p>另外请记住，MVG 没有 SVG 所拥有的容器机制。内部的 MSVG 转换器用图形上下文的推送和弹出代替了 XML 容器（见上面的 MVG  输出），效果是一样的。
SVG 的设置</p>
<p>SVG 图像格式是一种矢量格式（请参见<a href="https://imagemagick.org/Usage/formats/#vector">关于矢量图像格式的一句话</a>），因此图像通常没有一个默认的&quot;大小&rdquo;，而是以特定的 <code> &quot;-density&quot;</code> 来 &ldquo;绘制&quot;或&quot;渲染&rdquo;，就像 postscript 一样（默认密度是72dpi）。</p>
<p>另外，如果 SVG 没有 &ldquo;绘制&quot;背景，您可以通过使用 <code>-background</code> 设置指定要使用的背景颜色。</p>
<p>例如这里是另一个小的 SVG 图像 &ldquo;home.svg&rdquo;，它已经使用3种不同的密度，3种不同的背景进行&quot;渲染&rdquo;，包括一个透明的背景。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -density <span class="m">36</span>                      home.svg  home_1.gif

  convert              -background skyblue home.svg  home_2.gif

  convert -density <span class="m">144</span> -background none    home.svg  home_3.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/home_1.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/home_2.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/home_3.png" alt="img"></p>
<p>请注意，我使用了 PNG 格式的图片来制作上面例子中较大的透明背景版本。由于半透明的边缘像素，这产生的图像比 GIF 图像格式产生的图像更干净。当最终图像中涉及到透明度时，总是建议使用 PNG。</p>
<blockquote>
<p>我发现有些 SVG 图像不能缩放。也就是说，它们被定义为&quot;像素&rdquo;，而不是现实世界中的长度，如&quot;点&rdquo;、&ldquo;英寸&quot;或&quot;毫米&rdquo;。因此，虽然 <code>-density</code> 设置可能会改变图像的整体大小（以现实世界为单位），但 &ldquo;像素 &ldquo;的大小不会改变，因此图像本身的大小也不会改变。然而这样的SVG图像是相当罕见的。</p>
</blockquote>
<p>更糟糕的是，一些 SVG 图像使用了&quot;像素&quot;和 &ldquo;点&quot;的混合测量，除非作者故意这样做，否则你可能会得到一个真正的混乱，你可以尝试使用不同的密度，而不是作者想要的。幸运的是，这种情况更加罕见。</p>
<p>一个简单的解决方法就是将 SVG 中所有的 &ldquo;像素&quot;单位改成&quot;点&rdquo;，但也不能盲目的使用，以防故意使用&quot;像素&rdquo;。</p>
<h2 id="svg-输出处理">SVG 输出处理</h2>
<p>从 IM v6.4.2 开始，IM 可以将任何位图图像转换为 SVG 矢量图! 转换并不总是成功的，但较大和/或较简单的图像（如位图蒙版）会转换得很好。</p>
<p>例如，我在这里将一个可怕的位图形状转换为SVG图像，然后再将其转换回来，以便将位图平滑为一个适当的反锯齿形状。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -pointsize <span class="m">72</span> -font Candice label:A -threshold 50% <span class="se">\
</span><span class="se"></span>          -trim +repage -bordercolor white -border 5x5 A.gif

  convert A.gif  A.svg

  convert A.svg  A.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/A.gif" alt="img"> -&gt; <img src="https://imagemagick.org/Usage/draw/A.png" alt="img"></p>
<p>然而，要使之工作，必须安装&quot;开发&quot;的 <a href="http://autotrace.sourceforge.net/">AutoTrace</a> 库，并在IM中配置 <code>-with-autotrace</code> 开关。</p>
<p>如果没有安装 <a href="http://autotrace.sourceforge.net/">AutoTrace</a> 库并将其编译到 IM 中，那么生成的 SVG 输出将是大量的单像素圆圈，生成一个二进制结果，而不是一个平滑的 SVG 轮廓图像。这样的图像比较巨大，通过 SVG 渲染往往需要很长的时间来渲染。</p>
<p>其实需要一种更好的默认栅格到矢量的技术，可能会使用 Morphology skeletion 和 MAT 技术。</p>
<p>有一个 <code>autotrace:</code> <a href="https://imagemagick.org/Usage/files/#delegates">输入代理</a>，来&quot;平滑输入位图图像&rdquo;，直接使用 &ldquo;autotrace&rdquo; 命令一次性完成上述所有步骤。然而我最后一次看到这个代理已经消失了。</p>
<p>你应该这样使用它&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert autotrace:A.gif  A_traced.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/A_traced.png" alt="img"></p>
<p>当然这并不能让你从 &ldquo;autotrace&rdquo; 命令中得到 SVG 输出，只是通过 SVG 过滤输入的图像来平滑它。</p>
<p>作为一种替代方法，你可以直接使用 &ldquo;autotrace&rdquo; 命令，如 <a href="https://imagemagick.org/Usage/transform/#edge_vector">Raster to Vector Edging</a> 和 <a href="https://imagemagick.org/Usage/morphology/#autotrace_skeleton">Skeleton using Autotrace</a> 示例所示。</p>
<p>你也可以看看 <a href="https://imagemagick.org/Usage/forum_link.cgi?u=39994">cancerberosgx</a> 的结果，在<a href="https://imagemagick.org/Usage/forum_link.cgi?p=167161">生成 SVG 图像</a>，他研究了转换照片的解决方案。</p>
<h2 id="非im矢量图形编辑器">非IM矢量图形编辑器</h2>
<p>ImageMagick 是一个像素数组处理器，它一般不会保存矢量图像（&lsquo;MVG&rsquo; 是唯一的例外），只会读取图像并将其转换为像素数组。</p>
<p>其他像素图像编辑器也是如此，如 Gimp、Photoshop 等。</p>
<p>对于编辑和处理基于矢量的图像，可以使用以下程序，如</p>
<ul>
<li>Sodipodi 基于SVG的矢量图形编辑器。</li>
<li>Xfig 简单但非常好的矢量对象编辑器。(适用于标志、地图和在页面上排列照片)</li>
<li>Dia</li>
<li>AutoTrace 将位图数组中的形状转换为矢量轮廓。</li>
<li>Sketch 基于 Python 的曲线文字矢量编辑器。</li>
</ul>
<p>当然，这不是一个完整的列表。即使是许多文字处理程序，如 OpenOffice、Word 和 TeX，一般都有各种简单的，虽然往往难以使用的对象编辑器。</p>
<p>然而对于一般将矢量图形格式转换为不同的矢量格式，不要使用 ImageMagick。ImageMagick 本质上是一个光栅图像或位图图形转换器和操作器，而且永远都是这样。更多信息请参见 <a href="https://imagemagick.org/Usage/formats/#vector">A word about Vector Image formats</a>。</p>
<ul>
<li>创建于: 24 March 2004</li>
<li>更新于: 14 March 2011</li>
<li>作者: Anthony Thyssen, <a href="mailto:Anthony.Thyssen@gmail.com">Anthony.Thyssen@gmail.com</a></li>
<li>Examples Generated with:  [version image]</li>
<li>URL: <a href="http://www.imagemagick.org/Usage/draw/">http://www.imagemagick.org/Usage/draw/</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/imagemagick" term="imagemagick" label="imagemagick" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/image" term="image" label="image" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[ImageMagick 笔记]]></title>
            <link href="https://ohmyweekly.github.io/notes/imagemagick-notes/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/imagemagick-drawing/?utm_source=atom_feed" rel="related" type="text/html" title="ImageMagick - Drawing" />
                <link href="https://ohmyweekly.github.io/notes/imagemagick-transform/?utm_source=atom_feed" rel="related" type="text/html" title="ImageMagick - Transform" />
            
                <id>https://ohmyweekly.github.io/notes/imagemagick-notes/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-05T00:00:00+08:00</published>
            <updated>2020-07-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>ImageMagick</blockquote><h2 id="几个有意思的-imagemagick-脚本">几个有意思的 ImageMagick 脚本</h2>
<p><a href="http://www.fmwconcepts.com/imagemagick/randomclipart/index.php">http://www.fmwconcepts.com/imagemagick/randomclipart/index.php</a>
<a href="http://www.fmwconcepts.com/imagemagick/sketching/index.php">http://www.fmwconcepts.com/imagemagick/sketching/index.php</a>
<a href="http://www.fmwconcepts.com/imagemagick/sphericalpano2cube/index.php">http://www.fmwconcepts.com/imagemagick/sphericalpano2cube/index.php</a>
<a href="http://www.fmwconcepts.com/imagemagick/surroundblur/index.php">http://www.fmwconcepts.com/imagemagick/surroundblur/index.php</a>
<a href="http://www.fmwconcepts.com/imagemagick/transfercolor/index.php">http://www.fmwconcepts.com/imagemagick/transfercolor/index.php</a>
<a href="http://www.fmwconcepts.com/imagemagick/colorcells/index.php">http://www.fmwconcepts.com/imagemagick/colorcells/index.php</a></p>
<h2 id="给图片添加网格线">给图片添加网格线</h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">./glasseffects -e none -k simple -o <span class="s1">&#39;#FFDAB9&#39;</span> -t single -m overlay -c <span class="m">200</span> -w <span class="m">1</span> -s <span class="m">20</span> -r <span class="m">10</span> in.jpeg out.jpg
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">./grid -o 0.3 -s <span class="m">200</span> -c white in.jpeg out.jpeg
</code></pre></div><h2 id="折叠图片">折叠图片</h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">./picturefold -o <span class="m">80</span> -h <span class="m">50</span> in.jpeg out.jpeg
</code></pre></div><h2 id="给图片添加心形图片">给图片添加心形图片</h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">./randomclipart -d <span class="s2">&#34;64,16&#34;</span> -a <span class="s2">&#34;45,-45&#34;</span> -p <span class="m">50</span> -c random in.jpeg heart.png out.jpeg
</code></pre></div><h2 id="给图片分成带颜色的方块">给图片分成带颜色的方块</h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">./colorcells -n 8,8 -d 100,100 in.jpeg out.jpeg
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/imagemagick" term="imagemagick" label="imagemagick" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/image" term="image" label="image" />
                            
                        
                    
                
            
        </entry>
    
</feed>
