<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.92.0">Hugo</generator><title type="html"><![CDATA[calendar on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/calendar/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/calendar/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/calendar/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/calendar/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2022-01-23T16:05:49+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/calendar/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 圣诞月历(2010)]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-10-05-raku-calendar-2010/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-04-15-raku-calendar-2012/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 圣诞月历 2012" />
                <link href="https://ohmyweekly.github.io/notes/2014-12-19-raku-calendar/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 圣诞月历 - 2014" />
            
                <id>https://ohmyweekly.github.io/notes/2015-10-05-raku-calendar-2010/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+00:00</published>
            <updated>2021-07-11T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Calendar(2010)</blockquote><h2 id="第二天-用-main-函数控制命令行交互">第二天: 用 MAIN 函数控制命令行交互</h2>
<p>在 UNIX 环境下，很多脚本都是要从命令行里获取运行参数的。在 Raku 中实现这个相当简单。比如下面这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ cat add.pl
sub MAIN <span class="o">(</span><span class="nv">$x</span>, <span class="nv">$y</span><span class="o">)</span> <span class="o">{</span>
    say <span class="nv">$x</span> + <span class="nv">$y</span>
<span class="o">}</span>
$ raku add.pl <span class="m">3</span> <span class="m">4</span>
<span class="m">7</span>
$ raku add.pl too many arguments
Usage:
add.pl x y
</code></pre></div><p>只要定义一个带命名变量的 MAIN 函数，你就可以获得一个命令行分析器。然后命令行参数就被自动绑定到 <code>$x</code> 和 <code>$y</code> 上了。如果不匹配，还有温馨的 Usage 提示。</p>
<p>当然，你可能更喜欢自己定制 Usage 信息。那么自己动手，编写 USAGE 函数好了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ cat add2.pl
sub MAIN<span class="o">(</span><span class="nv">$x</span>, <span class="nv">$y</span><span class="o">)</span> <span class="o">{</span>
    say <span class="nv">$x</span> + <span class="nv">$y</span>
<span class="o">}</span>
sub USAGE <span class="o">()</span> <span class="o">{</span>
    say <span class="s2">&#34;Usage: add.pl &lt;num1&gt; &lt;num2&gt;&#34;</span><span class="p">;</span>
<span class="o">}</span>
$ raku add2.pl too many arguments
Usage: add.pl &lt;num1&gt; &lt;num2&gt;
</code></pre></div><p>更进一步的，你可以用 <code>multi</code> 指令声明多个 MAIN 函数以完成一种可替代的语法，或者根据某些常量做出不同反应，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ cat calc
<span class="c1">#!/usr/bin/env raku</span>

multi MAIN<span class="o">(</span><span class="s1">&#39;add&#39;</span>, <span class="nv">$x</span>, <span class="nv">$y</span><span class="o">)</span>  <span class="o">{</span> say <span class="nv">$x</span> + <span class="nv">$y</span> <span class="o">}</span>
multi MAIN<span class="o">(</span><span class="s1">&#39;div&#39;</span>, <span class="nv">$x</span>, <span class="nv">$y</span><span class="o">)</span>  <span class="o">{</span> say <span class="nv">$x</span> / <span class="nv">$y</span> <span class="o">}</span>
multi MAIN<span class="o">(</span><span class="s1">&#39;mult&#39;</span>, <span class="nv">$x</span>, <span class="nv">$y</span><span class="o">)</span> <span class="o">{</span> say <span class="nv">$x</span> * <span class="nv">$y</span> <span class="o">}</span>
$ ./calc add <span class="m">3</span> <span class="m">5</span>
<span class="m">8</span>
$ ./calc mult <span class="m">3</span> <span class="m">5</span>
<span class="m">15</span>
$ ./calc
Usage:
./calc add x y
or
./calc div x y
or
./calc mult x y
</code></pre></div><p>还有命名参数对应不同的选项的情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ cat copy.pl
sub MAIN<span class="o">(</span><span class="nv">$source</span>, <span class="nv">$target</span>, Bool :<span class="nv">$verbose</span><span class="o">)</span> <span class="o">{</span>
    say <span class="s2">&#34;Copying &#39;</span><span class="nv">$source</span><span class="s2">&#39; to &#39;</span><span class="nv">$target</span><span class="s2">&#39;&#34;</span> <span class="k">if</span> <span class="nv">$verbose</span><span class="p">;</span>
    run <span class="s2">&#34;cp </span><span class="nv">$source</span><span class="s2"> </span><span class="nv">$target</span><span class="s2">&#34;</span><span class="p">;</span>
<span class="o">}</span>
$ raku copy.pl calc calc2
$ raku copy.pl  --verbose calc calc2
Copying <span class="s1">&#39;calc&#39;</span> to <span class="s1">&#39;calc2&#39;</span>
</code></pre></div><p>这里申明变量 <code>$verbose</code> 类型为 Bool，也就是不接受赋值。如果没有这个类型约束的话，它是需要赋值的，就像下面这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ cat <span class="k">do</span>-nothing.pl
sub MAIN<span class="o">(</span>:<span class="nv">$how</span> <span class="o">=</span> <span class="s1">&#39;fast&#39;</span><span class="o">)</span> <span class="o">{</span>
    say <span class="s2">&#34;Do nothing, but do it </span><span class="nv">$how</span><span class="s2">&#34;</span><span class="p">;</span>
<span class="o">}</span>
$ raku <span class="k">do</span>-nothing.pl
Do nothing, but <span class="k">do</span> it fast

$ raku <span class="k">do</span>-nothing.pl --how<span class="o">=</span>well
Do nothing, but <span class="k">do</span> it well

$ raku <span class="k">do</span>-nothing.pl what?
Usage:
<span class="k">do</span>-nothing.pl <span class="o">[</span>--how<span class="o">=</span>value-of-how<span class="o">]</span>
</code></pre></div><p>总之，Raku 提供了内置的命令行解析功能和使用帮助说明，你只要声明好函数就行了。</p>
<h2 id="文件操作">文件操作</h2>
<ul>
<li>目录</li>
</ul>
<p>不再用 <code>opendir</code> 和其他神马滴，Raku 中有专门的 <code>dir</code> 函数，用来列出指定目录（默认是当前所在目录）下所有的文件。好了，直接贴代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">dir</span>
<span class="nb">dir</span> <span class="p">&#39;</span><span class="s1">t</span><span class="p">&#39;</span> <span class="c1"># t 目录下的文件</span>
</code></pre></div><p><code>dir</code> 还有一个可选的命名参数 <code>test</code>，用来 <code>grep</code> 结果，这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">dir</span> <span class="p">&#39;</span><span class="s1">src/core</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">test</span> <span class="o">=&gt;</span> <span class="nb">any</span><span class="p">(/</span><span class="ni">^</span><span class="sr">C</span><span class="p">/</span><span class="o">,</span> <span class="p">/</span><span class="ni">^</span><span class="sr">P</span><span class="p">/)</span>
</code></pre></div><p>创建目录，还是 <code>mkdir</code> 函数没错啦。</p>
<ul>
<li>文件</li>
</ul>
<p>最简单的读取文件的办法，是直接使用 <code>slurp</code> 函数，这个函数以标量形式返回文件的内容，这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">slurp</span> <span class="p">&#39;</span><span class="s1">VERSION</span><span class="p">&#39;</span>
</code></pre></div><p>当然原始的文件句柄方式还是有效的，这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#39;</span><span class="s1">CREDITS</span><span class="p">&#39;</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">getc</span> <span class="c1">#读取一个字符</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">get</span>  <span class="c1">#读取一行（译者注：这两看起来好有 C 语言的赶脚啊）</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>

<span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#39;</span><span class="s1">new</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">w</span>  <span class="c1"># 以可写方式打开</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;)</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">say</span><span class="p">(&#39;</span><span class="s1">bar</span><span class="p">&#39;)</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
<span class="nb">say</span> <span class="nb">slurp</span><span class="p">(&#39;</span><span class="s1">new</span><span class="p">&#39;)</span>
</code></pre></div><ul>
<li>文件测试</li>
</ul>
<p>如果要测试文件是否存在以及文件的具体类型，直接使用 <code>~~</code> 操作符就搞定了，还是用代码说话：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#39;</span><span class="s1">LICENSE</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span> <span class="o">~~</span> <span class="p">:</span><span class="s">e</span>     <span class="c1"># 文件(广义的)是否存在</span>
<span class="p">&#39;</span><span class="s1">LICENSE</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span> <span class="o">~~</span> <span class="p">:</span><span class="s">d</span>     <span class="c1"># 那么他是目录么？</span>
<span class="p">&#39;</span><span class="s1">LICENSE</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span> <span class="o">~~</span> <span class="p">:</span><span class="s">f</span>     <span class="c1"># 那么是文件么(狭义的)？</span>
</code></pre></div><ul>
<li>File::Find</li>
</ul>
<p>如果这些个标准特性还不够，那模块就派上用场了。<code>File::Tools</code> 包里的 <code>File::Find</code> 模块可以递归你指定的目录找你要的东西然后列出来。这个模块应该是跟着 Rakudo Star 一起打包了，如果你只裸装了 Rakudo，那么用 neutro 命令安装也是挺方便的。</p>
<p>额，还是要例子？好吧~很简单的一行 <code>find(:dir, :type, :name(/foo/))</code>，这就会在 <code>t/dir1</code> 目录下，寻找名字匹配 foo 的文件，然后以树的形式列出来~不过要注意的是：这命令的返回可不是文本标量，而是一个个包括他们的完整路径在内的对象，而且还提供文件本身以及文件所在目录的访问器！更多信息，直接看文档吧。</p>
<p>1、创建新文件</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">open</span><span class="p">(&#39;</span><span class="s1">new</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">w</span><span class="p">)</span><span class="o">.</span><span class="nb">close</span>
</code></pre></div><p>2、匿名文件句柄</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">given</span> <span class="nb">open</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">w</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">.</span><span class="nb">say</span><span class="p">(&#39;</span><span class="s1">Hello, world!</span><span class="p">&#39;);</span>
    <span class="o">.</span><span class="nb">close</span>
<span class="p">}</span>
</code></pre></div><h2 id="第四天--序列操作符">第四天 – 序列操作符</h2>
<p>去年，有一个序列操作符的简要梳理：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@even-numbers</span>  <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">2</span> <span class="o">...</span> <span class="o">*</span><span class="p">;</span>    <span class="c1"># 算术序列</span>
<span class="k">my</span> <span class="nv">@odd-numbers</span>   <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span> <span class="o">...</span> <span class="o">*</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@powers-of-two</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="o">*</span><span class="p">;</span> <span class="c1"># 几何序列</span>
</code></pre></div><p>这些现在在 Rakudo 里面实现了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@powers-of-two</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="o">*</span><span class="p">;</span>
<span class="nv">@powers-of-two</span><span class="o">[^</span><span class="mi">10</span><span class="o">]</span><span class="p">;</span>
<span class="c1"># 1 2 4 8 16 32 64 128 256 512</span>
</code></pre></div><p>我们需要削减这个无限列表让 Rakudo 不会花费无限长的时间来计算它。这种情况下，我使用 <code>[^10]</code>, 这其实是说 &ldquo;给我前 10 个元素&rdquo;。注意，当你把一个惰性列表绑定到一个数组变量上时，被计算过的值是会被记忆的，这是一种快捷的缓存。</p>
<p>序列操作符 <code>...</code> 是一个生成惰性列表的强大工具。上面的例子仅仅暗示了它能做什么。给定一个数字，它就从这个数字开始往下计数（除非序列的终点是一个更小的数字，这种情况下，它会倒数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">1</span> <span class="o">...</span> <span class="mi">10</span><span class="p">;</span> <span class="c1"># 1 2 3 4 5 6 7 8 9 10</span>
<span class="mi">5</span> <span class="o">...</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1"># 5 4 3 2 1</span>
</code></pre></div><p>给定两个数字来开始一个序列，它会把这当作一个算术序列，把前两个元素的差异添加到最后一个生成的元素上来产生下一个元素。如果给定三个元素，它会检查它们是否代表一个算术序列的开始或者它是否是一个几何序列，然后继续这个序列。</p>
<p>当然，很多有趣的序列既非算术序列也非几何序列，这时，你需要显式地提供一个 sub 来生成序列中的下一个数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@Fibonacci</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span> <span class="p">}</span> <span class="o">...</span> <span class="o">*</span><span class="p">;</span>
<span class="nv">@Fibonacci</span><span class="o">[^</span><span class="mi">10</span><span class="o">]</span><span class="p">;</span> <span class="c1"># 0 1 1 2 3 5 8 13 21 34</span>
</code></pre></div><p>上面的 <code>-&gt; $a, $b { $a + $b }</code> 是一个 pointy block (或者是一个匿名函数)，它带有 2 个参数并返回它们的和。这个序列操作符计算出该 block 有多少个参数，然后从当前序列的末尾传递所需的参数来生成序列的下一个数字，以此类推，循环下去。</p>
<p>或者也可以中断循环，目前为止，所有的例子都有一个星号 <code>*</code> 放在右边，它意味着“没有终止条件”。如果你反而在那里放上一个数字，这个列表就会终止在那个数字。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">1</span><span class="o">,</span> <span class="mf">1.1</span> <span class="o">...</span> <span class="mi">2</span><span class="p">;</span>          <span class="c1"># 1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2</span>
<span class="mi">1</span><span class="o">,</span> <span class="mf">1.1</span> <span class="o">...</span> <span class="mf">2.01</span><span class="p">;</span>       <span class="c1"># 1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2</span>
<span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mf">1.1</span> <span class="o">...</span> <span class="mf">2.01</span><span class="p">)</span><span class="o">[^</span><span class="mi">14</span><span class="o">]</span> <span class="c1"># (1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2 Nil Nil Nil)</span>
</code></pre></div><p>第一个列表很自然地终止了，但是第二个列表漏掉了终止数，它会循环下去。结果就是一个无限列表，所以我把它限制到前 14 个元素，以至于我们能明白它正在做什么。</p>
<p>那些有做浮点数学背景的人可能会气急败坏地说反复增加 0.1 直到精确到 2 为止很危险。</p>
<p>在 Raku 中，没有这个问题，因为它会在可能的地方使用有理数（例如.分数)。如果我想找出所有 10000 以下的斐波纳契数，要找到到何处停止的那个精确的数字是很大的问题。幸运的是，就像你能使用块来指定怎样生成序列中的下一个元素一样，你可以使用块来测试序列是否结束：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span> <span class="p">}</span> <span class="o">...</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">&gt;</span> <span class="mi">10000</span> <span class="p">};</span>
<span class="c1"># 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946</span>
</code></pre></div><p>尖头块 <code>-&gt; $a { $a &gt; 10000 }</code> 创建了一个含有一个参数的块，并且当参数大于 10000 时返回真；这就是我们需要的测试。</p>
<p>除了我们所期待的所有斐波那契数小于 10000。 我们生成的裴波纳契数有一个大于 10000 的，当传递一个块作为终止测试时，该序列操作符所有的元素直到那个块返回真为止，然后它返回最后一个元素，然后停止。但是有一种替代形式的操作符能做同样的事情：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span> <span class="p">}</span> <span class="o">...^</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">&gt;</span> <span class="mi">10000</span> <span class="p">};</span>
<span class="c1"># 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765</span>
</code></pre></div><p>从 <code>...</code> 转换为 <code>...^</code> 意味着结果列表不包含让终止测试返回真时的第一个元素。</p>
<p>在 Raku 中这真是一种冗长的指定序列的方法。在这里我没有地方解释所谓的闭包，但是去年的文章已经说过它们。使用闭包，你可以将上一个序列写为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*</span> <span class="o">+</span> <span class="o">*</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">;</span>
<span class="c1"># 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765</span>
</code></pre></div><p>这样写是否清晰完全取决于你，条条大路通罗马。并且，序列操作符的左侧可以是任何列表，甚至是惰性的。这意味着你可以很容易的使用一个终止块来得到已存在的惰性列表的有限的一部分：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@Fibonacci</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*</span> <span class="o">+</span> <span class="o">*</span> <span class="o">...</span> <span class="o">*</span><span class="p">;</span>
<span class="nv">@Fibonacci</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">;</span>
<span class="c1"># 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765</span>
<span class="nb">say</span> <span class="nv">@Fibonacci</span><span class="o">[</span><span class="mi">30</span><span class="o">]</span><span class="p">;</span> <span class="c1"># 832040</span>
</code></pre></div><p>(我坚持最后的检查只是为了说明 <code>@Fibonacci</code> 在超过 10000 之后依然会继续。</p>
<p>这才触及到序列能做什么的皮毛，更多的信息，查看细则中的 “List infix precedence”，然后下拉到序列操作符（尽管如此，注意这还没有全部实现！它是一个极其复杂的操作符。）</p>
<p>我还要告诉你的是，序列操作符不局限于工作于数字，如果你显式地指定了你自己的生成器，你可以生成任何类型的序列。但是我喜欢将这保留到未来的圣诞节礼物。</p>
<h2 id="第五天--为什么-raku-语法是你想要的">第五天 – 为什么 Raku 语法是你想要的</h2>
<p>圣临月第五天，您或许有些失望没能看到 Raku 酷呆了的新玩法。这次会是直观的解释一些编程语言的运行原理。
作为样例，先说下面这两行吧：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">6</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Price: 15 Euro</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="se">\d</span><span class="o">+</span><span class="p">/;</span>
</code></pre></div><p>嗯，两行代码的运行结果分别是 2 和 15。相信这对 Raku 程序员来说没什么可奇怪的。但你再细看看，两行都有斜杠 <code>/</code>，却为了完全不一样的目的，第一个是数值运算，第二 个是正则匹配。</p>
<p>Raku 怎么知道一个 <code>/</code> 号意味着什么？这当然不是简单的看 <code>/</code> 号后面的文本来决定，因为正则表达式可以看起来跟普通代码一样。
答案是：Raku 会持续跟踪他的预期。Raku 预期中最重要的两样东西就是：词和操作符。</p>
<p>一个词可以是像 23 或者 str 这样的文字。当解释器发现这样一个文字，然后后面就会是一个语句的结束（即分号;），或者一个操作符像 <code>+/*</code> 等等。过了这个操作符，解 释器又开始预期下一个词。</p>
<p>其实这就是问题的答案了：当解释器预期为词的时候，斜线 / 就代表正则表达式的开始；当预期为操作符的时候，斜线 / 就代表数字的除法运算。</p>
<p>这种做法造成了深远的后果。子函数运行可以不加括号，而在函数名后面，perl 预期一个词开端的参数列表。另一方面，类型名必须跟在操作符后面，所以，所有的类型名必 须在解析时就是已知的。</p>
<p>这样，很多字符都可以重复使用在不同的语法环境下了。</p>
<h2 id="第六天--x-和-z-元操作符">第六天 – X 和 Z 元操作符</h2>
<p>Raku 中一个新的创意就是元操作符，这种元操作符和普通的操作符结合改变了普通操作符的行为。这种元操作符有很多，但这里我们只关注它们中的两个: <code>X</code> 和 <code>Z</code>。</p>
<p><code>X</code> 操作符你可能已经见过它作为中缀交叉操作符的普通角色。它将列表联合在一起，每个列表中各取一个元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">X</span> <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;))</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1">#  ((1, &#34;a&#34;), (1, &#34;b&#34;), (2, &#34;a&#34;), (2, &#34;b&#34;))</span>
</code></pre></div><p>然而, 这个中缀操作符 <code>infix:&lt;X&gt;</code> 其实是将 <code>X</code> 操作符应用到列表连接操作符 <code>infix:&lt;,&gt;</code> 上的简便形式。事实上，你可以这样写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">X</span><span class="o">,</span> <span class="p">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="p">))</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1"># ((1, 10), (1, 11), (2, 10), (2, 11))</span>
</code></pre></div><p>如果你将 <code>X</code> 应用到不同的中缀操作符上面会发生什么？应用到 <code>infix:&lt;+&gt;</code> 上呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">X</span><span class="o">+</span> <span class="p">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="p">))</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1"># (11, 12, 12, 13).list</span>
</code></pre></div><p>它做了什么？它不是从每个组合中挑出所有的元素列表，这个操作符将中缀操作符 <code>+</code> 应用到元素间，并且结果不是一个列表，而是一个数字，是那个组合中所有元素的和。</p>
<p>这对任何中缀操作符都有效。看看字符串连接 <code>infix:&lt; ~ &gt;</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">X</span><span class="o">~</span> <span class="p">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="p">))</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1"># (&#34;110&#34;, &#34;111&#34;, &#34;210&#34;, &#34;211&#34;)</span>
</code></pre></div><p>或者也许数值相等操作符 <code>infix:&lt;==&gt;</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">X</span><span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="nb">raku</span>
<span class="c1"># (Bool::True, Bool::True, Bool::False, Bool::False)</span>
</code></pre></div><p>但是这篇文章也是关于 <code>Z</code> 元操作符的。我们期望你已经知道他是什么了。如果你遇见过中缀操作符 <code>Z</code>，它当然是 <code>Z,</code> 的便捷形式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">Z</span><span class="o">,</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1"># ((1, 3), (2, 4))</span>
<span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">Z</span><span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1"># (4, 6).list</span>
<span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">Z</span><span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1"># (Bool::True, Bool::False)</span>
</code></pre></div><p><code>Z,</code> 然后, 依次操作每个列表的每个元素，同时操作每个列表中的第一个元素，然后同时操作第二对儿，然后第三对儿，不管有多少。当到达列表的结尾时停止。</p>
<p><code>Z</code> 也是惰性的,所以你可以将它用在两个无限列表上，它会尽可能多地生成你需要的结果。<code>X</code> 只能处理左边是无限列表的列表，否则它不会设法得到任何东西。</p>
<p>有一个键和值得列表，你想得到一个散列？ 容易！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%hash</span> <span class="o">=</span> <span class="nv">@keys</span> <span class="ow">Z</span><span class="o">=&gt;</span> <span class="nv">@values</span><span class="p">;</span>
</code></pre></div><p>或者，也许你想并行遍历两个列表？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">@a</span> <span class="ow">Z</span> <span class="nv">@b</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>或者三个?</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">@a</span> <span class="ow">Z</span> <span class="nv">@b</span> <span class="ow">Z</span> <span class="nv">@c</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="o">,</span> <span class="nv">$c</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>或者你能从扔3次有10个面的骰子的所有数字组合中，得到所有可能的总数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@d10</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">...</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="p">(</span><span class="nv">@d10</span> <span class="ow">X</span><span class="o">+</span> <span class="nv">@d10</span><span class="p">)</span> <span class="ow">X</span><span class="o">+</span> <span class="nv">@d10</span><span class="p">;</span>
</code></pre></div><p>如果你想看到一些在真实世界这些原操作符的用途，看看 Moritz Lenz’s 写的 Sudoku.pm 数独解算器。</p>
<h2 id="第七天-词法变量">第七天 词法变量</h2>
<p>编程总是件很难持续做下去的事情。串几行代码很容易，根据想法做一个原型也是轻松愉快的。但随着程序慢慢变大，维护时间慢慢变长，事情慢慢就棘手起来了……最后，如果不幸的话，我们就得被迫重构——不是因为早先的问题复杂，而是因为程序本身复杂了……在不断的调试中急白了头的程序员们，早就不记得到底要怎么扩展程序以完成目的了……</p>
<p>所以我们回溯一下编程史，找找对着复杂性的办法。而答案就在那里，不来不去——<code>限制长度</code>。当你架构一个成百上千模块组成的大型程序的时候，你必须能够让这些组件通过表面上很小的设置进行交互——否则你就等着被乱七八糟的组合干死吧。</p>
<p>在各层次的编程上，我们都可以看到这么一个原则。因为他就只关心这一件事情：分散注意，专一的做一件事情！BCNF 范式、monads (译者注：不知道这东东咋翻译)、单子，例程，类，角色，模块，包等。这些都是在督促和指导我们限制编程的长度。这样我们才不会输在组
合学上。而这方面最简单的例子，就是词法变量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">{</span>
    <span class="k">my</span> <span class="nv">$var</span><span class="p">;</span>
    <span class="c1"># $var可见</span>
<span class="p">}</span>
<span class="c1"># $var不可见</span>
</code></pre></div><p>哈哈，这就是今天要介绍的一个非常酷的功能了！非常有趣的说。</p>
<p>Perl 从第一版开始，在这方面一直不太对。比如 Perl5 的默认变量作用域是包。而这就是全局变量的一种。我在某个代码块里定义了一个变量，其他地方居然也能看到……</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ perl -v
This is perl 5, version 12, subversion <span class="m">1</span> <span class="o">(</span>v5.12.1<span class="o">)</span>
$ perl -E <span class="s1">&#39;{ $var = 42 }; say $var&#39;</span>
<span class="m">42</span>
$ perl -wE <span class="s1">&#39;{ my $var= 42 }; say $var&#39;</span>
Name <span class="s2">&#34;main::var&#34;</span> used only once: possible typo at -e line 1.
Use of uninitialized value <span class="nv">$var</span> in say at -e line 1.
</code></pre></div><p>在 Raku 里，词法变量变成了默认设置。在 Rakudo 上运行上面的代码，根本无法通过编译：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ raku -e <span class="s1">&#39;{ $var = 42 }; say $var&#39;</span>
<span class="o">===</span>SORRY!<span class="o">===</span>
Symbol <span class="s1">&#39;$var&#39;</span> not predeclared in &lt;anonymous&gt;
$ raku -e <span class="s1">&#39;{ my $var = 42 }; say $var&#39;</span>
<span class="o">===</span>SORRY!<span class="o">===</span>
Symbol <span class="s1">&#39;$var&#39;</span> not predeclared in &lt;anonymous&gt;
</code></pre></div><p>好了，你可能说：“嗯，可以减少点打错字的可能了”。这当然没错，但是更重要的是：这让你认真坦诚的对待<code>变量作用域</code>。这对你控制代码复杂性很有利！</p>
<p>我们可以说出很多很多解释来说明为啥 Perl5 这么做。比如 Perl5 已经建议大家 <code>use warnings;</code> <code>use strict;</code> ，比如 Perl5 承诺的向后兼容，嗯，很伟大的做法，而 Perl1 压根没打算用来写大型程序和管理带来的复杂性；比如全局变量在单行模式下的各种方便……</p>
<p>Raku 内置的强制你从小处着手，帮你在系统扩容的时候，更苛责的关注架构基础。在变量方面，也就是在脚本和模块中，将词法变量作为默认设置。不过在 perl -e 执行的单行命令中，默认依然是全局变量。（ Rakudo 还没有实现这个，目前单行依然是词法变量，期待实现的那天~）</p>
<p>继续。好像到这里你感觉词法变量的价值已经说完了？没有！正确设计的结果可是令人惊讶和奖金源源不断啊~考虑一下这个子程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">counter</span><span class="p">(</span><span class="nv">$start_value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$count</span> <span class="o">=</span> <span class="nv">$start_value</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nv">$count</span><span class="o">++</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div><p>这里返回的是一个代码块。所以每次我们调用 <code>counter()</code> 的时候，得到的都是一小片断开的代码。然后看看当我创建两片这样的代码后的结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$c1</span> <span class="o">=</span> <span class="nf">counter</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$c1</span><span class="p">();</span>           <span class="c1"># 5</span>
<span class="nb">say</span> <span class="nv">$c1</span><span class="p">();</span>           <span class="c1"># 6</span>
<span class="nv">&amp;nbsp_place_holder</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$c2</span> <span class="o">=</span> <span class="nf">counter</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$c2</span><span class="p">();</span>           <span class="c1"># 42</span>
<span class="nb">say</span> <span class="nv">$c1</span><span class="p">();</span>           <span class="c1"># 7</span>
<span class="nb">say</span> <span class="nv">$c2</span><span class="p">();</span>           <span class="c1"># 43</span>
</code></pre></div><p>看到了吧， <code>$c1</code> 和 <code>$c2</code> 是完全分开的，他们相互独立互不影响。尽管他们都写成 $count 的样子，看起来真是差不多，但他们都有自己独立的存储单元——因为每次我们运行进入那个代码块的时候，就是一次重新开始。这个小代码块从运行中的计数器里返回，这些计数器里保留了存储单元的对应关系。（他“关闭”这个存储单元，保护它不被 GC 回收掉。这类代码块叫闭包）</p>
<p>这个闭包看起来像是个轻量级的对象？gxgx，他们确实就是。闭包背后的原则，即规范对闭包值的访问方式，与面向对象背后的封装和信息的原则是一样的。他们都是尽力限制事情的程度，在事情变得糟糕的时候，帮忙减少其影响和损失。</p>
<p>你可以用词法变量做些很有趣的事情，比如闭包；而包变量不行。词法变量最酷啦！吼吼~~</p>
<h2 id="第八天---不同东西用不同名字">第八天 - 不同东西用不同名字</h2>
<p>Perl5 的新手们，总会很奇怪的说为啥自己没法倒装呢？Perl 里有内置的 reverse 命令，但好像压根不起作用啊：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ perl -E <span class="s2">&#34;say reverse &#39;hello&#39;&#34;</span>
hello
</code></pre></div><p>当他们去问一些有经验的 perler 的时候，解决办法很快就有了。因为 reverse 有两种操作模式，分别工作在标量和列表环境下，用来倒装字符串和列表元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ perl -E <span class="s2">&#34;say scalar reverse &#39;hello&#39;&#34;</span>
olleh
</code></pre></div><p>比较悲剧的是这个情况和大多数的 perl 语境是不一致的。比方说，绝大多数的操作符和函数由自己决定语境，并在这个语境下分析数据。好比 + 和 * 作用于数字，. 作用于字符串。所以说他们代表一个操作并且提供语境，而 <code>reverse</code> 却不是。</p>
<p>在 Raku 里，我们从过去的错误里吸取教训以摆脱历史的窘境。所以我们把列表倒叙，字符串翻转，哈希反演分开成了三个操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># 字符串翻转，改名叫flip</span>
<span class="nv">$</span> <span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">say flip &#34;hello&#34;</span><span class="p">&#39;</span>
<span class="n">olleh</span>
<span class="c1"># 列表倒叙</span>
<span class="nv">$</span> <span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">say join &#34;, &#34;, reverse &lt;ab cd ef&gt;</span><span class="p">&#39;</span>
<span class="n">ef</span><span class="o">,</span> <span class="n">cd</span><span class="o">,</span> <span class="n">ab</span>
<span class="c1"># 哈希反转，叫 invert</span>

<span class="k">my</span> <span class="nv">%capitals</span> <span class="o">=</span> <span class="s">France</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Paris</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">UK</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">London</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="nv">%capitals</span><span class="o">.</span><span class="nb">invert</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="p">(&#34;</span><span class="s2">Paris</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">France</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">London</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">UK</span><span class="p">&#34;)</span>
</code></pre></div><p>注意哈希的反演和其他两个不同。因为哈希的值不要求是唯一的，所以反演后，哈希结构可能会被改变，或者某些值被覆盖……
如果必要的话，使用者可以自己决定返回哈希结构时的操作方式。比如下面就是一种无损的方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%inverse</span><span class="p">;</span>
<span class="nv">%inverse</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span> <span class="nv">%original</span><span class="o">.</span><span class="nb">invert</span> <span class="p">);</span>
</code></pre></div><p>这个方法会在键值对存在的情况下，把新值 push 在原有值的队尾变成一个数组：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%h</span><span class="p">;</span>
<span class="nv">%h</span><span class="o">.</span><span class="nb">push</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">);</span>    <span class="c1"># foo =&gt; 1</span>
<span class="nv">%h</span><span class="o">.</span><span class="nb">push</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">);</span>    <span class="c1"># foo =&gt; [1, 2]</span>
<span class="nv">%h</span><span class="o">.</span><span class="nb">push</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">);</span>    <span class="c1"># foo =&gt; [1, 2, 3]</span>
</code></pre></div><p>这三个函数，都会强制转换他们的参数。也就是说，如果你传递一个列表给 flip，这个列表会被强制成字符串后再翻转返回。</p>
<h2 id="第十天--feed-operators">第十天 – Feed operators</h2>
<p>使用Perl 5 编程一段时间的人可能遇到或写过下面这样相似的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="k">my</span> <span class="nv">@new</span> <span class="o">=</span> <span class="nb">sort</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="nb">map</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="nb">grep</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="nv">@original</span><span class="p">;</span>
</code></pre></div><p>在这个构造中，数据从 <code>@original</code> 数组流进 <code>grep</code>，然后按顺序，流进 <code>map</code> ，然后流进 <code>sort</code>，最后将结果赋值给 <code>@new</code> 数组。因为它们每个都将列表作为它们最终的参数，仅仅通过位置，数据从一个操作符向左流进下一个操作符。</p>
<p>Raku, 从另一方面，通过引入流向操作符让数据从一个操作符流进另一个操作符，让这种思想更明确。上面的 Perl 5 代码能使用 Raku 重写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@new</span> <span class="o">&lt;==</span> <span class="nb">sort</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="o">&lt;==</span> <span class="nb">map</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="o">&lt;==</span> <span class="nb">grep</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="o">&lt;==</span> <span class="nv">@original</span><span class="p">;</span>
</code></pre></div><p>注意条条大路通罗马，这个在 Raku 中更能体现。你也可以跟 Perl 5 的写法相同：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@new</span> <span class="o">=</span> <span class="nb">sort</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span><span class="o">,</span> <span class="nb">map</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span><span class="o">,</span> <span class="nb">grep</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span><span class="o">,</span> <span class="nv">@original</span><span class="p">;</span>
</code></pre></div><p>唯一不同的是额外的逗号。</p>
<p>所以，我们从这些流向操作符得到了什么？通常，当我们阅读代码的时候，你是从左向右读的，在原来的 Perl 5 代码中，你可能从左到右阅读你的代码直到你发现正在处理的结构，其流向是从右向左的，然后你跳到末尾，按照从右往左的方式再读一遍。</p>
<p>在 Raku 中，现在有一个突出的句法标记，告诉你数据向左流动的性质。</p>
<p>这样写也可以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@original</span> <span class="o">==&gt;</span> <span class="nb">grep</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="o">==&gt;</span> <span class="nb">map</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="o">==&gt;</span> <span class="nb">sort</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>  <span class="o">==&gt;</span> <span class="k">my</span> <span class="nv">@new</span><span class="p">;</span>
</code></pre></div><p>下面是一些使用流向操作符的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@random-nums</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="o">*</span><span class="p">);</span>  <span class="c1"># 100个随机数</span>
<span class="k">my</span> <span class="nv">@odds-squared</span> <span class="o">&lt;==</span> <span class="nb">sort</span> <span class="o">&lt;==</span> <span class="nb">map</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">}</span> <span class="o">&lt;==</span> <span class="nb">grep</span> <span class="p">{</span> <span class="nv">$_</span> <span class="nv">%</span> <span class="mi">2</span> <span class="p">}</span> <span class="o">&lt;==</span> <span class="nv">@random-nums</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">~</span><span class="nv">@odds-squared</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">@a</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="o">*</span><span class="p">);</span>

<span class="nv">@a</span> <span class="o">==&gt;</span> <span class="nb">grep</span> <span class="p">{</span><span class="nv">$_</span> <span class="nv">%</span> <span class="mi">2</span><span class="p">}</span> <span class="o">==&gt;</span> <span class="nb">map</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">**</span> <span class="mi">2</span><span class="p">}</span> <span class="o">==&gt;</span> <span class="nb">sort</span> <span class="p">{</span><span class="nv">$^a</span> <span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;</span> <span class="nv">$^b</span><span class="p">}</span> <span class="o">==&gt;</span> <span class="k">my</span> <span class="nv">@c</span><span class="p">;</span>
<span class="c1"># 1 9 25 49 81 121 169 225 289 361 441 529 625 729 841 961 1089 1225 1369 1521 1681 1849 2025 2209 2401 2601 2809 3025 3249 3481 3721 3969 4225 4489 4761 5041 5329 5625 5929 6241 6561 6889 7225 7569 7921 8281 8649 9025 9409 9801</span>

<span class="k">my</span> <span class="nv">@odds-squared</span> <span class="o">&lt;==</span> <span class="nb">sort</span> <span class="p">{</span><span class="nv">$^b</span> <span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;</span> <span class="nv">$^a</span><span class="p">}</span> <span class="o">&lt;==</span> <span class="nb">map</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">}</span> <span class="o">&lt;==</span> <span class="nb">grep</span> <span class="p">{</span> <span class="nv">$_</span> <span class="nv">%</span> <span class="mi">2</span> <span class="p">}</span> <span class="o">&lt;==</span> <span class="nv">@random-nums</span>   <span class="c1"># 降序排列</span>
<span class="c1"># 9801 9409 9025 8649 8281 7921 7569 7225 6889 6561 6241 5929 5625 5329 5041 4761 4489 4225 3969 3721 3481 3249 3025 2809 2601 2401 2209 2025 1849 1681</span>
<span class="mi">1521</span> <span class="mi">1369</span> <span class="mi">1225</span> <span class="mi">1089</span> <span class="mi">961</span> <span class="mi">841</span> <span class="mi">729</span> <span class="mi">625</span> <span class="mi">529</span> <span class="mi">441</span> <span class="mi">361</span> <span class="mi">289</span> <span class="mi">225</span> <span class="mi">169</span> <span class="mi">121</span> <span class="mi">81</span> <span class="mi">49</span> <span class="mi">25</span> <span class="mi">9</span> <span class="mi">1</span>

<span class="k">my</span> <span class="nv">@rakudo-people</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">scott patrick carl moritz jonathan jerry stephen</span><span class="p">&gt;;</span>
<span class="nv">@rakudo-people</span> <span class="o">==&gt;</span> <span class="nb">grep</span> <span class="p">{</span> <span class="p">/</span><span class="sr">at</span><span class="p">/</span> <span class="p">}</span> <span class="o">==&gt;</span> <span class="nb">map</span> <span class="p">{</span> <span class="o">.</span><span class="nf">ucfirst</span> <span class="p">}</span> <span class="o">==&gt;</span> <span class="k">my</span> <span class="nv">@who-it&#39;s-at</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">~</span><span class="nv">@who-it&#39;s-at</span><span class="p">;</span>    <span class="c1"># Patrick Jonathan</span>

<span class="o">[+]</span><span class="p">(</span><span class="k">my</span> <span class="nv">@a</span><span class="p">)</span> <span class="o">&lt;==</span> <span class="nb">map</span> <span class="p">{</span><span class="nv">$_</span> <span class="o">**</span><span class="mi">2</span><span class="p">}</span> <span class="o">&lt;==</span>  <span class="mi">1</span><span class="o">..</span><span class="mi">10</span>   <span class="c1"># 385， 1 到 10 的平方和</span>
<span class="o">[+]</span><span class="p">()</span> <span class="o">&lt;==</span> <span class="nb">map</span> <span class="p">{</span><span class="nv">$_</span> <span class="o">**</span><span class="mi">2</span><span class="p">}</span> <span class="o">&lt;==</span>  <span class="mi">1</span><span class="o">..</span><span class="mi">10</span>        <span class="c1"># 385</span>
</code></pre></div><h2 id="第十二天--智能匹配">第十二天 – 智能匹配</h2>
<p>还记得<a href="http://rakuadvent.wordpress.com/2010/12/04/the-sequence-operator/">Raku Advent</a> 序列操作符吗?因为最后一个参数它接受的是一个上限，这让序列的生成停止了，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="mi">32</span><span class="p">;</span>         <span class="c1"># 1 2 4 8 16 32</span>
<span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">;</span>     <span class="c1"># 1 2 4 8 16</span>
<span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span> <span class="o">...</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">;</span>      <span class="c1"># 1 2 4 8 16 32 64 128</span>
<span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">;</span>     <span class="c1"># 1 2 4 8 16 32 64</span>
</code></pre></div><p>你能看到，在第一种情况下，使用了数值相等。第二个更有意思：<code>*&gt;10</code> 在内部被重写为一个闭包，像这样 <code>-&gt; $x { $x &gt; 10 }</code> (through currying).</p>
<p>序列操作符做了一些不可思议的比较，根据匹配者的类型。这种比较就叫做智能匹配，并且是在 Raku 中重复出现的一个概念，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># after the &#39;when&#39; keyword:</span>
<span class="k">given</span> <span class="nv">$age</span> <span class="p">{</span>
    <span class="k">when</span> <span class="mi">100</span>    <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">congratulations!</span><span class="p">&#34;</span>      <span class="p">}</span>
    <span class="k">when</span> <span class="o">*</span> <span class="o">&lt;</span> <span class="mi">18</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">You&#39;re not of age yet</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># after &#39;where&#39;:</span>
<span class="k">subset</span> <span class="nc">Even</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">where</span> <span class="o">*</span> <span class="nv">%%</span> <span class="mi">2</span><span class="p">;</span>

<span class="c1"># 显式地使用智能匹配操作符:</span>
<span class="k">if</span> <span class="nv">$input</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="ni">^</span><span class="se">\d</span><span class="o">+</span><span class="ni">$</span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$input</span><span class="s2"> is an integer</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="c1"># arguments to grep(), first() etc.:</span>
<span class="k">my</span> <span class="nv">@even</span> <span class="o">=</span> <span class="nv">@numbers</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="n">Even</span><span class="p">;</span>
</code></pre></div><p>在智能操作符 <code>~~</code> 的右侧，并且在 <code>when</code> 和 <code>where</code> 的后面，要匹配的值被设置为 主题变量 <code>$_</code>。</p>
<p>下面是一些智能操作符的用法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$foo</span> <span class="o">~~</span> <span class="nb">Str</span>             <span class="c1">#它的类型是 Str吗?</span>
<span class="nv">$foo</span> <span class="o">~~</span> <span class="mi">6</span>               <span class="c1">#它等于 6 吗?</span>
<span class="nv">$foo</span> <span class="o">~~</span> <span class="p">&#34;</span><span class="s2">bar</span><span class="p">&#34;</span>           <span class="c1">#或者它是 &#34;bar&#34; 吗?</span>
<span class="nv">$foo</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">/</span> <span class="c1"># 它匹配某个模式吗?</span>
<span class="nv">$foo</span> <span class="o">~~</span> <span class="p">(</span><span class="mi">15</span><span class="o">..</span><span class="mi">25</span><span class="p">)</span>        <span class="c1"># 它的值在 15 和 25 之间吗?</span>
<span class="nv">$foo</span> <span class="o">~~</span> <span class="k">-&gt;</span> <span class="nv">$x</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">ok</span><span class="p">&#39;</span> <span class="k">if</span> <span class="mi">5</span> <span class="o">&lt;</span> <span class="nv">$x</span> <span class="o">&lt;</span> <span class="mi">25</span> <span class="p">}</span> <span class="c1"># 调用闭包</span>
<span class="nv">$foo</span> <span class="o">~~</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="o">*,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*]</span> <span class="c1"># 含有6个元素的数组，是否其所有的奇数元素的值都为 1?</span>
</code></pre></div><p><a href="http://perlcabal.org/syn/S03.html#Smart_matching">智能匹配的全部表现可以在这找到：</a>.</p>
<p>智能匹配没有特殊的操作符，而大部分智能匹配的情况会返回 Bool 值，对正则进行匹配会返回一个 Match 对象</p>
<p>你可能开始怀疑：一个正确的，内置的类型，我怎么将它用在我自己的类中？你需要为它写一个特别的 ACCEPTS 方法。假如我们有一个叫Point 的类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">ACCEPTS</span><span class="p">(</span><span class="nb">Positional</span> <span class="nv">$p2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$.x</span> <span class="o">==</span> <span class="nv">$p2</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="ow">and</span> <span class="nv">$.y</span> <span class="o">==</span> <span class="nv">$p2</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>一切都清楚了吗?让我们看看它是如何工作的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">7</span><span class="o">,</span> <span class="s">y</span> <span class="o">=&gt;</span> <span class="mi">9</span><span class="p">);</span>
<span class="nb">say</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span> <span class="o">~~</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1"># Bool::False</span>
<span class="nb">say</span> <span class="p">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">~~</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1"># Bool::True</span>
</code></pre></div><p>现在能恰当地做到你想要的，甚至使用你自己的类。</p>
<h2 id="第-16-天---raku-里的时间">第 16 天 - Raku 里的时间</h2>
<p>今天是圣诞月历的第 0x10 天，是时候学习一下 raku 里的时间了。S32::Temporal 简介在过去一年中有了大量的修改，今天我们就来介绍一下在 raku 实现中关于时间的一些基础知识。</p>
<p><code>time</code> 和 <code>now</code> 是两个可以返回当前时间（至少是你的系统认为的当前时间）的词。简单的展示一下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nb">time</span><span class="p">;</span>
<span class="nb">say</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><pre tabindex="0"><code>1292460064
Instant:2010-12-16T00:41:4.873248Z
</code></pre><p>第一个明显的区别，前者返回的是 POSIX 格式的数值型的结果；而后者返回的是一个瞬间的对象。如果你想获取秒级以下小数点位或者说闰秒，请用 now ；如果不用，那用 time 获取 POSIX 格式就够了。随你的便。</p>
<ul>
<li>DateTime 和他的伙伴</li>
</ul>
<p>大多数时候，你要的不是当前时间。这种时候，你需要的是 <code>DateTime</code> 。比如还是获取当前时间：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$moment</span> <span class="o">=</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nb">now</span><span class="p">);</span> <span class="c1"># 或者 DateTime.new(time)</span>
</code></pre></div><p>你有两种方式来创建 DateTime 对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$dw</span> <span class="o">=</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">year</span><span class="p">(</span><span class="mi">1963</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">month</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">day</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">hour</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">minute</span><span class="p">(</span><span class="mi">15</span><span class="p">));</span>
</code></pre></div><p>这是 UTC 时区，如果你要更改时区的话，再加上 <code>:timezone</code> 就好了。这个格式里，只有 <code>:year</code> 是必须的，其他的默认就是1月1号半夜0点0分。</p>
<p>上面这种写法确实乏味，你可以采用 ISO8601 格式的输入，来创建一个 DateTime 对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$dw</span> <span class="o">=</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">1963-11-23T17:15:00Z</span><span class="p">&#34;);</span>
</code></pre></div><p>其中 Z 表示 UTC ，想改变的话，把 Z 替换成 <code>+hhmm</code> 或者 <code>-hhmm</code> 就好了。hh 表示小时，mm 表示分钟。
此外，还有一个更简略的 Date 对象。只包括年月日的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$jfk</span> <span class="o">=</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">1963-11-22</span><span class="p">&#34;);</span> <span class="c1"># 你也可以用:year 等的写法</span>
</code></pre></div><p>引入 Date 对象，是吸取了 CPAN 上 DateTime 模块的教训：有时候你压根不关心什么时区啊闰秒啊的。Date 对象非常容易处理，比如它有内置的 <code>.succ</code> 和 <code>.pred</code> 方法，用来简单的递增和递减。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$jfk</span><span class="o">++</span><span class="p">;</span> <span class="c1"># 肯尼迪遇刺后的第二天</span>
</code></pre></div><p>最后…</p>
<p>以上就是关于 Raku 里的时间的内容了，想了解更多细节，去看看规范吧；或者去社区里提问</p>
<h2 id="第十九天---假作真时真亦假">第十九天 - 假作真时真亦假</h2>
<p>今天的圣临礼物是教大家怎么用混淆完成一个小邪恶滴目的，吼吼~看起来这个功能挺疯狂的，其实有时候蛮有用的。先看下面这个用 but 的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$value</span> <span class="o">=</span> <span class="mi">42</span> <span class="k">but</span> <span class="k">role</span> <span class="p">{</span> <span class="k">method</span> <span class="nb">Bool</span>  <span class="p">{</span> <span class="nb">False</span> <span class="p">}</span> <span class="p">};</span>
<span class="nb">say</span> <span class="nv">$value</span><span class="p">;</span>    <span class="c1"># 42</span>
<span class="nb">say</span> <span class="o">?</span><span class="nv">$value</span><span class="p">;</span>   <span class="c1"># False</span>
</code></pre></div><p>你看，我们改变了 <code>$value</code> 的 <code>.Bool</code> 方法。他不影响程序里其他所有的整数，哪怕别的变量也是 42。一般情况下，对于 Int 型，<code>.Bool</code> 方法（通过?操作符）返回值依据是是否等于 0。但这次它永远都返回 false 了。
事实上，我们还可以写的更简单，因为 False 是一个枚举值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$value</span> <span class="o">=</span> <span class="mi">42</span> <span class="k">but</span> <span class="nb">False</span><span class="p">;</span>
</code></pre></div><p>因为 False 是 Bool 值，所有它会自动重载 <code>.Bool</code> 方法。这是 Raku 的一种转换方法。其他的值，也会对应的重载。</p>
<p>这样在有的时候，这个东西就比较有用了：在 Perl5 里，你用 system 调用 shell 的时候，得牢牢记住在 shell 里，返回 0 才是正常的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">(</span> <span class="nf">system</span><span class="p">(</span><span class="nv">$cmd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>  <span class="c1"># 或者!system($cmd)</span>
    <span class="c1"># ...</span>
<span class="p">}</span>
</code></pre></div><p>而在 Raku 中，对应的 run 命令返回的是上面说的这种重载过的 Int，当且仅当返回值是 0 的时候，它的 bool 变成了 True，这正是我们想要的额！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nb">run</span><span class="p">(</span><span class="nv">$cmd</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">#不需要否定了</span>
    <span class="c1"># ...</span>
<span class="p">}</span>
</code></pre></div><p>好了，现在进入最疯狂的部分 —— 我们可以重载布尔值的布尔方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$value</span> <span class="o">=</span> <span class="nb">True</span> <span class="k">but</span> <span class="nb">False</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$value</span><span class="p">;</span>    <span class="c1"># True</span>
<span class="nb">say</span> <span class="o">?</span><span class="nv">$value</span><span class="p">;</span>   <span class="c1"># False</span>
</code></pre></div><p>没错，Raku 允许你这样自己踢自己屁股~~虽然我也不知道除了捣乱外怎么会有人愿意这么做，但是我还是很高兴看到 Raku 保持这种微妙的跟踪和重载类型的心态。我可没有……</p>
<h2 id="day-21--transliteration-and-beyond">Day 21 – transliteration and beyond</h2>
<p>转换听起来像拉丁词根,意味着字母的变化。这就是 Str.trans 方法所做的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">GATTACA</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">trans</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">TCAG</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">0123</span><span class="p">&#34;</span> <span class="p">);</span>  <span class="c1"># prints &#34;3200212\n&#34;</span>
</code></pre></div><p>使用过Perl5 的人马上意识到这就是 <code>tr/tcag/0123/</code> .</p>
<p>下面是一个例子，使用 ROT-13算法加密文本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">rot13</span><span class="p">(</span><span class="nv">$text</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$text</span><span class="o">.</span><span class="nb">trans</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">A..Za..z</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">N..ZA..Mn..za..m</span><span class="p">&#34;</span> <span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>当 <code>.trans</code> 方法看到那些 <code>..</code> 区间时，它会在内部将那些字母展开 (所以 &ldquo;n..z&rdquo; 意思是 &ldquo;nopqrstuvwxyz&rdquo;). 因此,rot13子例程的最终效果是将ASCII字母表的特定部分映射到其他部分。</p>
<p>在 Perl5 中，两个点跟一个破折号相同，但是在Raku 中我们让那两个点 .. 代表 范围的概念，在主程序中，在正则中，还有在这里，转换。</p>
<p>要注意的是，<code>.trans</code> 方法是不会改变原来的字符串； 它不会噶边 $text, 而是返回一个新的值。这在 Raku 中也是一个通用的旋律。要改变原值，请使用  <code>.=trans</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$kabbala</span><span class="o">.=</span><span class="nb">trans</span><span class="p">(&#34;</span><span class="s2">A..Ia..i</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">1..91..9</span><span class="p">&#34;);</span>
</code></pre></div><p>(并且，它不仅仅适用于 <code>.trans</code> 方法，它对所有方法都适用。)</p>
<p><code>.trans</code> 方法包含了一个秘密武器：假如我们想转义一些HTML，即，根据下面这个表来替换东西：</p>
<pre tabindex="0"><code>&amp; =&gt; &amp;amp;
&lt; =&gt; &amp;lt;
&gt; =&gt; &amp;gt;
</code></pre><p>但是我们不想关心替换还要按顺序进行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="s">foo</span>         <span class="o">=&gt;</span> <span class="n">bar</span>
<span class="s">foolishness</span> <span class="o">=&gt;</span> <span class="n">folly</span>
</code></pre></div><p>在上面的例子中，如果前面的替换先发生，就不回有后面的替换出现了 - 这可能不是你想要的。通常，我们想在短的子串之前，尝试并匹配最长的子串。</p>
<p>所以，这看起来我们需要一个最长记号的替换匹配，以避免因为偶然的重复替换而产生的无限循环。
那就是 Raku 的 <code>.trans</code> 方法所提供的。这就是它的秘密武器：嵌入两个数组而非字符串。对于 HTML 转义，我们所需要的就是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$escaped</span> <span class="o">=</span> <span class="nv">$html</span><span class="o">.</span><span class="nb">trans</span><span class="p">(</span>
    <span class="o">[</span> <span class="p">&#39;</span><span class="s1">&amp;</span><span class="p">&#39;</span><span class="o">,</span>     <span class="p">&#39;</span><span class="s1">&lt;</span><span class="p">&#39;</span><span class="o">,</span>    <span class="p">&#39;</span><span class="s1">&gt;</span><span class="p">&#39;</span>    <span class="o">]</span> <span class="o">=&gt;</span>
    <span class="o">[</span> <span class="p">&#39;</span><span class="s1">&amp;amp;</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">&amp;lt;</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">&amp;gt;</span><span class="p">&#39;</span> <span class="o">]</span>
<span class="p">);</span>
</code></pre></div><p>替换的顺序问题和避免循环就不用我们关心了。</p>
<h2 id="第二十二天---meta-object-protocol">第二十二天 - Meta-Object Protocol</h2>
<p>你有没有想过用你最爱的编程语言写一个类——但是不是按部就班的写类定义，而是通过几行代码？有些语言提供了 API 来完成这个功能。这些 API 的后面，就是元对象协议( Meta-Object Protocol )，简称 MOP。</p>
<p>Raku 就有 MOP，你可以自己创建类、角色、语法，添加方法和属性，并且内省类。比如我们可以调用 MOP 查看 Rakudo 是如何实现 Rat 类型（有理数）的。调用 MOP ，只要把一般的 <code>.</code> 换成 <code>.^</code> 就可以了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ raku
&gt; say join <span class="s1">&#39;, &#39;</span>, Rat.^attributes
<span class="nv">$!</span>numerator, <span class="nv">$!</span>denominator
&gt; <span class="c1"># 列出全部方法比较多，所以随机选几个</span>
&gt; say join <span class="s1">&#39;, &#39;</span>, Rat.^methods<span class="o">(</span>:local<span class="o">)</span>.pick<span class="o">(</span>5<span class="o">)</span>
unpolar, ceiling, reals, Str, round
&gt; say Rat.^methods<span class="o">(</span>:local<span class="o">)</span>.grep<span class="o">(</span><span class="s1">&#39;log&#39;</span><span class="o">)</span>.<span class="o">[</span>0<span class="o">]</span>.signature.raku
:<span class="o">(</span>Numeric <span class="nv">$x</span>: Numeric <span class="nv">$base</span> <span class="o">=</span> <span class="o">{</span> ... <span class="o">}</span><span class="p">;;</span> *%_<span class="o">)</span>
</code></pre></div><p>显示出来的这几行信息相信都是不言自明了。Rat 有两个属性，<code>$!numerator</code> 和 <code>$!denominator</code>；有很多方法，其中 log 方法可接受的第一个变量是数值型 invocant(译者注：不知道怎么翻译，反正就是对象本身的引用 <code>$_[0]</code> )，用冒号标记过；第二个变量参数是可选的，名字是 <code>$base</code>，它设有一个默认值，不过 Rakudo 不打算告诉你……</p>
<p>Raku 的数据库接口代码里有一个很不错的使用实例。它有一个选项用来记录对象的调用，但是只是记录一部分特定角色（比如和连接管理或者数据检索有关的）。下面是 dbi 里的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">log-calls</span><span class="p">(</span><span class="nv">$obj</span><span class="o">,</span> <span class="n">Role</span> <span class="nv">$r</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">my</span> <span class="nv">$wrapper</span> <span class="o">=</span> <span class="n">RoleHOW</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>

     <span class="k">for</span> <span class="nv">$r</span><span class="o">.^</span><span class="nb">methods</span> <span class="k">-&gt;</span> <span class="nv">$m</span> <span class="p">{</span>
         <span class="nv">$wrapper</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(</span><span class="nv">$m</span><span class="o">.</span><span class="nb">name</span><span class="o">,</span> <span class="k">method</span> <span class="p">(</span><span class="o">|</span><span class="nv">$c</span><span class="p">)</span> <span class="p">{</span>
             <span class="c1"># 打印日志信息，note() 函数输出到标准错误</span>
             <span class="nb">note</span> <span class="p">&#34;</span><span class="s2">&gt;&gt; </span><span class="nv">$m</span><span class="p">&#34;;</span>
             <span class="nb">nextsame</span><span class="p">;</span>
         <span class="p">});</span>
     <span class="p">}</span>

     <span class="nv">$wrapper</span><span class="o">.^</span><span class="nb">compose</span><span class="p">();</span>
     <span class="c1"># does 操作符和 but 类似，不过只修改一个对象的拷贝</span>
     <span class="nv">$obj</span> <span class="k">does</span> <span class="nv">$wrapper</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">role</span> <span class="nc">Greet</span> <span class="p">{</span>
     <span class="k">method</span> <span class="nf">greet</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
         <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">hello, </span><span class="nv">$x</span><span class="p">&#34;;</span>
     <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">SomeGreeter</span> <span class="k">does</span> <span class="nc">Greet</span> <span class="p">{</span>
     <span class="k">method</span> <span class="nf">LOLGREET</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
         <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">OH HAI </span><span class="p">&#34;</span><span class="o">~</span> <span class="nb">uc</span> <span class="nv">$x</span><span class="p">;</span>
     <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$o</span> <span class="o">=</span> <span class="nf">log-calls</span><span class="p">(</span><span class="n">SomeGreeter</span><span class="o">.</span><span class="nb">new</span><span class="o">,</span> <span class="n">Greet</span><span class="p">);</span>
<span class="c1"># 记录日志啦，因为由 Greet 角色提供了</span>
<span class="nv">$o</span><span class="o">.</span><span class="nf">greet</span><span class="p">(&#39;</span><span class="s1">you</span><span class="p">&#39;);</span>
<span class="c1"># 没记录，因为没角色提供这个</span>
<span class="nv">$o</span><span class="o">.</span><span class="nf">LOLGREET</span><span class="p">(&#39;</span><span class="s1">u</span><span class="p">&#39;);</span>
</code></pre></div><p>运行结果如下：</p>
<pre tabindex="0"><code>&gt;&gt; greet
hello, you
OH HAI U
</code></pre><p>所以说，有了 MOP ，除了指定的语法，你还可以像普通接口一样访问类、角色、语法和属性。这给了面向对象更大的灵活性，可以轻松的内省和修改对象了。</p>
<h2 id="第23天----一些精彩的排序示例">第23天 -  一些精彩的排序示例</h2>
<p>继续我们的圣临礼物。</p>
<p>排序是一个非常非常常见的编程任务。Raku 加强了它的 <code>.sort</code> 功能来帮助大家更好的排序。
最最正常的默认写法是这样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="p">;</span> <span class="c1"># 或者这样</span>
<span class="nb">sort</span> <span class="nv">@unsorted</span><span class="p">;</span>
</code></pre></div><p>和 Perl 5 一样，也是可以自定义函数的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># 数值比较</span>
<span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^a</span> <span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;</span> <span class="nv">$^b</span> <span class="p">};</span>
<span class="c1"># 或者用函数调用的形式</span>
<span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nb">sort</span> <span class="p">{</span> <span class="nv">$^a</span> <span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;</span> <span class="nv">$^b</span> <span class="p">}</span><span class="o">,</span> <span class="nv">@unsorted</span><span class="p">;</span>
<span class="c1"># 字符串比对 ( 跟Perl5的cmp一样 )</span>
<span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^a</span> <span class="ow">leg</span> <span class="nv">$^b</span> <span class="p">};</span>
<span class="c1"># 类型依赖比对</span>
<span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^a</span> <span class="ow">cmp</span> <span class="nv">$^b</span> <span class="p">};</span>
</code></pre></div><p>你也可以把 <code>:</code> 换成 <code>()</code> ，然后再跟上一些方法进行后续处理，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@topten</span> <span class="o">=</span> <span class="nv">@scores</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span> <span class="p">{</span> <span class="nv">$^b</span> <span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;</span> <span class="nv">$^a</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">list</span><span class="o">.</span><span class="nf">munch</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</code></pre></div><p>小提示： <code>$a</code> 和 <code>$b</code> 不再像在 Perl5 中那样有特殊含义了，在 sort 代码块里用别的命名变量 <code>$var</code>、位置变量 <code>$^var</code> 或者其他任何的都跟在其他代码段里一样。</p>
<p>你可以直接在排序的时候直接就做好变换函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$^a</span><span class="p">)</span> <span class="ow">cmp</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$^b</span><span class="p">)</span> <span class="p">};</span>
</code></pre></div><p>不过 <code>foo()</code> 会在重复执行，如果列表不大也就罢了，如果比较大的话……如果 <code>foo()</code> 还是个计算密集型的……你懂的！</p>
<p>在这种情况下，Perl 5 里有个习惯就是使用施瓦茨( Schwartzian )变换。施瓦茨变换的做法就是 decorate-sort-undecorate，<code>foo()</code> 函数只用执行一次：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@sorted</span> <span class="o">=</span>
    <span class="nb">map</span>  <span class="p">{</span> <span class="nv">$_-</span><span class="o">&gt;[</span><span class="mi">0</span><span class="o">]</span> <span class="p">}</span>
    <span class="nb">sort</span> <span class="p">{</span> <span class="nv">$a-</span><span class="o">&gt;[</span><span class="mi">1</span><span class="o">]</span> <span class="ow">cmp</span> <span class="nv">$b-</span><span class="o">&gt;[</span><span class="mi">1</span><span class="o">]</span> <span class="p">}</span>
    <span class="nb">map</span>  <span class="p">{</span> <span class="o">[</span><span class="nv">$_</span><span class="o">,</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span><span class="o">]</span> <span class="p">}</span>
    <span class="nv">@unsorted</span><span class="p">;</span>
</code></pre></div><p>Raku 里，你一样可以使用施瓦茨变换，不过 Raku 内置了一些智能方法。如果你有一个函数，它接受的参数个数是 0 或 1，Raku 会自动的替你启用施瓦茨变换。</p>
<p>现在让我们来看一些例子吧。</p>
<ul>
<li>不区分大小写的排序</li>
</ul>
<p>把每个元素都改成小写，然后把数组按照小写的次序排好返回。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="o">.</span><span class="nb">lc</span> <span class="p">};</span>
</code></pre></div><ul>
<li>单词长度排序</li>
</ul>
<p>把每个元素的单词按照从短到长排序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="o">.</span><span class="nb">chars</span> <span class="p">};</span>
</code></pre></div><p>或者从长到短:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="o">-.</span><span class="nb">chars</span> <span class="p">};</span>
</code></pre></div><ul>
<li>多次排序比较</li>
</ul>
<p>你可以在 <code>sort</code> 代码块里放多个比较函数，<code>sort</code> 会注意执行直到退出。比如在单词长度的基础上，再按照 ASCII 码的顺序排序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^a</span><span class="o">.</span><span class="nb">chars</span><span class="o">,</span> <span class="nv">$^a</span> <span class="p">}</span> <span class="p">;</span>
</code></pre></div><p>不过，在 Rakudo 里好像运行有点问题……它只会比较长度不会比较数值，也就是说，10 排在 2 的前面。（没关系，TMTONTDI）</p>
<p>Raku 里的 <code>sort</code> 本身是稳定工作的，你可以重复使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">sort</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^a</span><span class="o">.</span><span class="nb">chars</span> <span class="p">};</span>
</code></pre></div><p>不过这样 <code>sort</code> 有两次调用，no fashion！所以你还可以这么写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^a</span><span class="o">.</span><span class="nb">chars</span> <span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;</span> <span class="nv">$^b</span><span class="o">.</span><span class="nb">chars</span> <span class="o">||</span> <span class="nv">$^a</span> <span class="ow">leg</span> <span class="nv">$^b</span> <span class="p">};</span>
</code></pre></div><p>不过这下你有两个参数了，Raku 没法自动给你启动施瓦茨变换了。</p>
<p>又或者，你可以加上一个给自然数排序的函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^a</span><span class="o">.</span><span class="nb">chars</span><span class="o">.&amp;</span><span class="nf">naturally</span><span class="o">,</span> <span class="nv">$^a</span> <span class="p">};</span>
</code></pre></div><p>“给自然数排序？”我好像听到你们的哭声了，“哪里有？” 很高兴你们这么问，现在继续解决这个问题。</p>
<ul>
<li>自然数排序</li>
</ul>
<p>标准的词法排序是按照 ASCII 次序的。先是自然数，然后是大写字母，最后是小写字母。所以人们在排序的时候经常得到这样的结果：</p>
<pre tabindex="0"><code>0
1
100
11
144th
2
21
210
3rd
33rd
AND
ARE
An
Bit
Can
and
by
car
d1
d10
d2
</code></pre><p>完全正确，但是没用……尤其是对非程序员来说，更郁闷了就……真正的自然排序，应该是先按数学量级排自然数，然后才是大小写字母。比如上面那个例子，应该排成这样：</p>
<pre tabindex="0"><code>0
1
2
3rd
11
21
33rd
100
144th
210
An
AND
and
ARE
Bit
by
Can
car
d1
d2
d10
</code></pre><p>所以，我们必须的在排序的时候加上一点转换了。我使用 <code>.subst</code> 方法，这是我们所熟悉的 <code>s///</code> 操作符的面向对象形式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">subst</span><span class="p">(/(</span><span class="se">\d</span><span class="o">+</span><span class="p">)/</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$/</span> <span class="p">{</span> <span class="mi">0</span> <span class="o">~</span> <span class="nv">$0</span><span class="o">.</span><span class="nb">chars</span><span class="o">.</span><span class="nb">chr</span> <span class="o">~</span> <span class="nv">$0</span> <span class="p">}</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span>
</code></pre></div><p>第一部分，捕获一个连续的数字，然后由 <code>-&gt; $/ {}</code> 构成一个尖号块，意思是：“传递匹配到 <code>$/</code> 的数组到 <code>{}</code> 代码里”。然后代码里替换成用 0 按照数量级排序的顺序联结的字符串。这个 0 是以 ASCII 字符串出现，联结在原始字符串上的。最后 <code>/g</code> 表示全局替换。</p>
<p>如果也不区分大小写，那么：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">lc</span><span class="o">.</span><span class="nb">subst</span><span class="p">(/(</span><span class="se">\d</span><span class="o">+</span><span class="p">)/</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$/</span> <span class="p">{</span> <span class="mi">0</span> <span class="o">~</span> <span class="nv">$0</span><span class="o">.</span><span class="nb">chars</span><span class="o">.</span><span class="nb">chr</span> <span class="o">~</span> <span class="nv">$0</span> <span class="p">}</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span>
</code></pre></div><p>改成子例程的方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">naturally</span> <span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$a</span><span class="o">.</span><span class="nb">lc</span><span class="o">.</span><span class="nb">subst</span><span class="p">(/(</span><span class="se">\d</span><span class="o">+</span><span class="p">)/</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$/</span> <span class="p">{</span> <span class="mi">0</span> <span class="o">~</span> <span class="nv">$0</span><span class="o">.</span><span class="nb">chars</span><span class="o">.</span><span class="nb">chr</span> <span class="o">~</span> <span class="nv">$0</span> <span class="p">}</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>看起来很不错了，不过还有点小问题，比如 THE 、 The 和 the 会按照他们在列表里的顺序返回，而不是我们预计的顺序。有个简单的解决办法，就是在转换过的元素的结尾，加上一个中断。所以最终结果是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">naturally</span> <span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$a</span><span class="o">.</span><span class="nb">lc</span><span class="o">.</span><span class="nb">subst</span><span class="p">(/(</span><span class="se">\d</span><span class="o">+</span><span class="p">)/</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$/</span> <span class="p">{</span> <span class="mi">0</span> <span class="o">~</span> <span class="nv">$0</span><span class="o">.</span><span class="nb">chars</span><span class="o">.</span><span class="nb">chr</span> <span class="o">~</span> <span class="nv">$0</span> <span class="p">}</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span> <span class="o">~</span> <span class="p">&#34;</span><span class="se">\x</span><span class="mh">0</span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$a</span>
<span class="p">}</span>
</code></pre></div><p>然后你看，这个子例程只有一个参数，所以我们还可以用上施瓦茨变换了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">0 1 100 11 144th 2 21 210 3rd 33rd AND ARE An Bit Can and by car d1 d10 d2</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="o">.&amp;</span><span class="nf">naturally</span> <span class="p">};</span>
</code></pre></div><p>或者用来给 ip 排序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@ips</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="o">..</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">.</span><span class="p">&#39;)</span><span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">99</span><span class="p">);</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@ips</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="o">.&amp;</span><span class="nf">naturally</span> <span class="p">};</span>
</code></pre></div><p>输出:</p>
<pre tabindex="0"><code>4.108.172.65
5.149.121.70
10.24.201.53
11.10.90.219
12.83.84.206
12.124.106.41
12.162.149.98
14.203.88.93
16.18.0.178
17.68.226.104
21.201.181.225
23.61.166.202
</code></pre><p>以及目录排序啊等等各种数字与字母的混合体。</p>
<p>最后，圣诞快乐，排序快乐，愿施瓦茨与你同在！</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/calendar" term="calendar" label="calendar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 圣诞月历 2012]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-04-15-raku-calendar-2012/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2014-12-19-raku-calendar/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 圣诞月历 - 2014" />
            
                <id>https://ohmyweekly.github.io/notes/2015-04-15-raku-calendar-2012/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+00:00</published>
            <updated>2021-07-10T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Calendar 2012</blockquote><h2 id="一个日历">一个日历</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!/usr/bin/env raku</span>

<span class="k">constant</span> <span class="nv">@months</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">January February March April May June July August September October November December</span><span class="p">&gt;;</span>
<span class="k">constant</span> <span class="nv">@days</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">Su Mo Tu We Th Fr Sa</span><span class="p">&gt;;</span>

<span class="k">sub</span> <span class="nf">center</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$text</span><span class="o">,</span> <span class="nb">Int</span> <span class="nv">$width</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$prefix</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span> <span class="nb">x</span> <span class="p">(</span><span class="nv">$width</span> <span class="o">-</span> <span class="nv">$text</span><span class="o">.</span><span class="nb">chars</span><span class="p">)</span> <span class="ow">div</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$suffix</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span> <span class="nb">x</span> <span class="nv">$width</span> <span class="o">-</span> <span class="nv">$text</span><span class="o">.</span><span class="nb">chars</span> <span class="o">-</span> <span class="nv">$prefix</span><span class="o">.</span><span class="nb">chars</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">$prefix</span> <span class="o">~</span> <span class="nv">$text</span> <span class="o">~</span> <span class="nv">$suffix</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="o">:</span><span class="nv">$year</span> <span class="o">=</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">today</span><span class="o">.</span><span class="nb">year</span><span class="o">,</span> <span class="o">:</span><span class="nv">$month</span> <span class="o">=</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">today</span><span class="o">.</span><span class="nb">month</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$dt</span> <span class="o">=</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">year</span><span class="p">(</span><span class="nv">$year</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">month</span><span class="p">(</span><span class="nv">$month</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">day</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">);</span>
    <span class="k">my</span> <span class="nv">$ss</span> <span class="o">=</span> <span class="nv">$dt</span><span class="o">.</span><span class="nb">day-of-week</span> <span class="nv">%</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">@slots</span> <span class="o">=</span> <span class="p">&#39;&#39;</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#34;</span><span class="nv">%2s</span><span class="p">&#34;)</span> <span class="ow">xx</span> <span class="nv">$ss</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$days-in-month</span> <span class="o">=</span> <span class="nv">$dt</span><span class="o">.</span><span class="nb">days-in-month</span><span class="p">;</span>

    <span class="k">for</span> <span class="nv">$ss</span> <span class="o">..^</span> <span class="nv">$ss</span> <span class="o">+</span> <span class="nv">$days-in-month</span> <span class="p">{</span>
        <span class="nv">@slots</span><span class="o">[</span><span class="nv">$_</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$dt</span><span class="o">.</span><span class="nb">day</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#34;</span><span class="nv">%2d</span><span class="p">&#34;);</span>
        <span class="nv">$dt</span><span class="o">++</span>
    <span class="p">}</span>

    <span class="k">my</span> <span class="nv">$weekdays</span> <span class="o">=</span> <span class="nv">@days</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#34;</span><span class="nv">%2s</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">join</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;;</span>
    <span class="nb">say</span> <span class="nf">center</span><span class="p">(</span><span class="nv">@months</span><span class="o">[</span><span class="nv">$month-1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$year</span><span class="o">,</span> <span class="nv">$weekdays</span><span class="o">.</span><span class="nb">chars</span><span class="p">);</span>
    <span class="nb">say</span> <span class="nv">$weekdays</span><span class="p">;</span>

    <span class="k">for</span> <span class="nv">@slots</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$k</span><span class="o">,</span> <span class="nv">$v</span> <span class="p">{</span>
        <span class="nb">print</span> <span class="p">&#34;</span><span class="nv">$v</span><span class="s2"> </span><span class="p">&#34;;</span>
        <span class="nb">print</span> <span class="p">&#34;</span><span class="se">\n</span><span class="p">&#34;</span> <span class="k">if</span> <span class="p">(</span><span class="nv">$k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="nv">%%</span> <span class="mi">7</span> <span class="ow">or</span> <span class="nv">$v</span> <span class="o">==</span> <span class="nv">$days-in-month</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="bags-and-sets">Bags and Sets</h2>
<p>过去几年, 我写了很多这种代码的变种：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%words</span><span class="p">;</span>
<span class="k">for</span> <span class="nb">slurp</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">lc</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$word</span> <span class="p">{</span>
    <span class="nv">%words</span><span class="p">{</span><span class="nv">$word</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>(此外: <code>slurp.comb(/\w+/).map(*.lc)</code> 从指定的标准输入或命令行读取文件, 遍历数据中的单词, 然后小写化该单词。 eg: raku slurp.pl score.txt)</p>
<p>Raku 引入了两种新的组合类型来实现这种功能。 在这种情况下, 半路杀出个 KeyBag 代替了 hash:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%words</span> <span class="o">:=</span> <span class="n">KeyBag</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="k">for</span> <span class="nb">slurp</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">lc</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$word</span> <span class="p">{</span>
    <span class="nv">%words</span><span class="p">{</span><span class="nv">$word</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这种情况下, 为什么你会喜欢 KeyBag 多于散列呢, 难道是前者代码更多吗？很好, 如果你想要的是一个正整数值的散列的话, KeyBag 将更好地表达出你的意思。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%words</span><span class="p">{&#34;</span><span class="s2">the</span><span class="p">&#34;}</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;;</span>
</code></pre></div><p>未处理过的异常：不能解析数字：green</p>
<p>然而 KeyBag 有几条锦囊妙计。首先, 四行代码初始化你的 KeyBag 不是很罗嗦, 但是 Raku 能让它全部写在一行也不会有问题：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%words</span> <span class="o">:=</span> <span class="n">KeyBag</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nb">slurp</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">lc</span><span class="p">));</span>
</code></pre></div><p>KeyBag.new 尽力把放到它里面的东西变成 KeyBag 的内容。给出一个列表, 列表中的每个元素都会被添加到 KeyBag 中, 结果和之前的代码块是完全一样的。</p>
<p>如果你不需要在创建bag后去修改它, 你可以使用 Bag 来代替 KeyBag。不同之处是 Bag 是不会改变的；如果 %words 是一个 Bag, 则 %words{$word}++ 是非法的。如果对你的程序来说, 不变没有问题的话, 那你可以让代码更紧凑。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%words</span> <span class="o">:=</span> <span class="nb">bag</span> <span class="nb">slurp</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">lc</span><span class="p">);</span>  <span class="c1"># 散列 %words 不会再变化</span>
</code></pre></div><p>bag 是一个有用的子例程, 它只是对任何你给它的东西上调用 Bag.new 方法。（我不清楚为什么没有同样功能的 keybag 子例程）</p>
<p>Bag 和 KeyBag 有几个雕虫小技。它们都有它们自己的 .roll 和 .pick 方法, 以根据给定的值来权衡它们的结果：</p>
<pre tabindex="0"><code>&gt; my $bag = bag &quot;red&quot; =&gt; 2, &quot;blue&quot; =&gt; 10;
&gt; say $bag.roll(10);
&gt; say $bag.pick(*).join(&quot; &quot;);

blue blue blue blue blue blue red blue red blue
blue red blue blue red blue blue blue blue blue blue blue
This wouldn’t be too hard to emulate using a normal Array, but this version would be:
&gt; $bag = bag &quot;red&quot; =&gt; 20000000000000000001, &quot;blue&quot; =&gt; 100000000000000000000;
&gt; say $bag.roll(10);
&gt; say $bag.pick(10).join(&quot; &quot;);
blue blue blue blue red blue red blue blue blue
blue blue blue red blue blue blue red blue blue
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="nv">$file1</span><span class="o">,</span> <span class="nv">$file2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$words1</span> <span class="o">=</span> <span class="nb">bag</span> <span class="nb">slurp</span><span class="p">(</span><span class="nv">$file1</span><span class="p">)</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">lc</span><span class="p">);</span>
    <span class="k">my</span> <span class="nv">$words2</span> <span class="o">=</span> <span class="nb">set</span> <span class="nb">slurp</span><span class="p">(</span><span class="nv">$file2</span><span class="p">)</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">lc</span><span class="p">);</span>
    <span class="k">my</span> <span class="nv">$unique</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$words1</span> <span class="ow">(-)</span> <span class="nv">$words2</span><span class="p">);</span>

    <span class="k">for</span> <span class="nv">$unique</span><span class="o">.</span><span class="nb">list</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="o">-</span><span class="nv">$words1</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">[^</span><span class="mi">10</span><span class="o">]</span> <span class="k">-&gt;</span> <span class="nv">$word</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$word:</span><span class="s2"> </span><span class="p">{</span> <span class="nv">$words1</span><span class="p">{</span><span class="nv">$word</span><span class="p">}</span> <span class="p">}&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>传递两个文件名, 这使得 Bag 从第一个文件中获取单词, 让 Set 从第二个文件中获取单词, 然后使用 集合差 操作符 <code>(-)</code> 来计算只在第一个文件中含有的单词, 按那些单词出现的频率排序, 然后打印出前10 个单词。</p>
<p>这是介绍 Set 的最好时机。就像你从上面猜到的一样, Set 跟 Bag 的作用很像。不同的地方在于, 它们都是散列, 而 Bag 是从Any到正整数的映射, Set 是从 Any 到 Bool::True 的映射。集合 Set 是不可改变的, 所以也有一个 可变的 KeySet。</p>
<p>在 Set 和 Bag 之间, 我们有很丰富的操作符：</p>
<pre tabindex="0"><code>操作符	Unicode	“Texas”	结果类型

属于	∈	(elem)	Bool
不属于	∉	!(elem)	Bool
包含	∋	(cont)	Bool
不包含	∌	!(cont)	Bool

并集	∪	(|)	Set 或 Bag
交集	∩	(&amp;)	Set 或 Bag
差集	        (-)	Set

子集	⊆	(&lt;=)	Bool
非子集	⊈	!(&lt;=)	Bool
真子集	⊂	(&lt;)	Bool
非真子集	⊄	!(&lt;)	Bool

超级	⊇	(&gt;=)	Bool
非超级	⊉	!(&gt;=)	Bool
真超级	⊃	(&gt;)	Bool
非真超级	⊅	!(&gt;)	Bool

bag multiplication	⊍	(.)	Bag
bag addition	⊎	(+)	Bag
set symmetric difference (^)	Set
</code></pre><p>它们中的大多数都能不言自明。返回 Set 的操作符在做运算前会将它们的参数提升为 Set。返回 Bag 的操作符在做运算前会将它们的参数提升为 Bag。返回 Set 或 Bag 的操作符在做运算前会将它们的参数提升为 Bag, 如果它们中至少有一个是 Bag 或 KeyBag, 否则会转换为 Set；在任何一种情况下, 它们都返回提升后的类型。</p>
<pre tabindex="0"><code>&gt; my $a = bag &lt;a a a b b c&gt;;  # bag(a(3), b(2), c)
&gt; my $b = bag &lt;a b b b&gt;;      # bag(a, b(3))

&gt; $a (|) $b;
bag(&quot;a&quot; =&gt; 3, &quot;b&quot; =&gt; 3, &quot;c&quot; =&gt; 1)

&gt; $a (&amp;) $b;
bag(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2)

&gt; $a (+) $b;
bag(&quot;a&quot; =&gt; 4, &quot;b&quot; =&gt; 5, &quot;c&quot; =&gt; 1)

&gt; $a (.) $b;
bag(&quot;a&quot; =&gt; 3, &quot;b&quot; =&gt; 6)
</code></pre><p><a href="https://github.com/colomon/raku-set-bag-demo">下面是作者放在 github上的 Demo</a></p>
<p>A quick example of getting the 10 most common words in Hamlet which are not found in Much Ado About Nothing:</p>
<pre tabindex="0"><code>&gt; raku bin/most-common-unique.pl data/Hamlet.txt data/Much_Ado_About_Nothing.txt
</code></pre><p>ham: 358
queen: 119
hamlet: 118
hor: 111
pol: 86
laer: 62
oph: 58
ros: 53
horatio: 48
clown: 47</p>
<h2 id="超棒的匿名函数">超棒的匿名函数</h2>
<p>Raku 对函数有很好的支持。Raku 令人惊叹的把函数声明包起来, 让你可以用各种方法来定义一个函数又不丢失任何特性。你可以定义参数类型、可选参数、命名参数, 甚至在子句里也可以。如果我不知道更好的理由的话, 我可能都在怀疑这是不是在补偿 Perl5 里那个相当基本的参数处理（咳咳 , <code>@_</code>, 你懂的）。
除开这些, Raku 也允许你定义没有命名的函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="p">{</span><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">lol, I&#39;m so anonymous!</span><span class="p">&#34;</span> <span class="p">}</span>
</code></pre></div><p>这有什么用？你不命名它, 就没法调用它啊, 对不？错！</p>
<p>你可以保存这个函数到一个变量里。或者从另一个函数里 return 这个函数。或者传参给下一个函数。事实上, 当你不命名你的函数的时候, 你随后要运行什么代码就变得非常清晰了。就像一个可执行的 &ldquo;todo&rdquo; 列表一样。</p>
<p>现在让我们说说匿名函数可以给我们做点什么。在 Raku 里它看起来会是什么样子呢？</p>
<p>嗯, 就用最著名的排序来做例子吧。你可能想象 Raku 有一个 sort_lexicographically 函数和一个 sort_numberically 函数。不过其实没有。只有一个 sort 函数。当你需要具体用某种形式的排序时, 你就可以传递一个匿名函数给 sort 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted_words</span>   <span class="o">=</span> <span class="nv">@words</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="o">~</span><span class="nv">$_</span> <span class="p">});</span>
<span class="k">my</span> <span class="nv">@sorted_numbers</span> <span class="o">=</span> <span class="nv">@numbers</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="o">+</span><span class="nv">$_</span> <span class="p">});</span>
</code></pre></div><p>（从技术上来说, 这是块, 不是函数。不过如果你不打算在里面使用 return 的话, 差异不大。）
当然你可以做的比这两个排序办法多多了。你可以通过鞋子大小排序, 或者最大地面速度, 或者自燃可能性的降序等等。因为你可以把任何逻辑作为一个参数传递进去。面向对象的教徒们对这种模式可非常自豪, 还专门命名为“依赖注入”。</p>
<p>想想看, map、 grep 和 reduce 都很依赖这种函数传递。我们有时候把这种传递函数给函数的做法叫“高阶编程”, 好像这是某些高手的特权似的。但其实这是一个非常有用而且可以普通使用的技能。</p>
<p>上面的示例都是在当前执行时就运行函数了。其实这里没什么限制。我们可以创建函数, 然后稍后再运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">make_surprise_for</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Sur-priiise, </span><span class="nv">$name</span><span class="s2">!</span><span class="p">&#34;</span> <span class="p">};</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$reveal_surprise</span> <span class="o">=</span> <span class="nf">make_surprise_for</span><span class="p">(&#34;</span><span class="s2">Finn</span><span class="p">&#34;);</span>    <span class="c1">#</span>

<span class="c1"># 目前什么都没发生</span>
<span class="c1"># 等着</span>
<span class="c1"># 继续等着</span>
<span class="c1"># 等啊等啊等啊</span>
<span class="nv">$reveal_surprise</span><span class="p">();</span>        <span class="c1"># &#34;Sur-priiise, Finn!&#34;</span>
</code></pre></div><p><code>$reveal_surpirse</code> 里的函数记住了 <code>$name</code> 变量值, 虽然原始函数是在很早之前传递进去的参数。棒极了！这个效果就叫在 <code>$name</code> 变量上闭合的匿名函数。不过这里可没什么技术 - 反正很棒就是了。</p>
<p>事实上, 如果放在其他主要存储机制比如数组和散列旁边再看匿名函数本身, 这感觉是很自然的事情。所有这些都可以存储在变量里, 作为参数传递或者从函数里返回。一个匿名数组允许你保存序列给以后调用。一个匿名散列允许你存储映射给以后调用。一个匿名函数允许你存储计算或者行为给以后调用。</p>
<p>本月晚些时候, 我会写篇介绍怎样通过 Raku 的动态域来创建漂亮的 DSL-y 接口。我们可以看到匿名函数在那里是怎么发挥作用的。</p>
<h2 id="第九天最长标示匹配">第九天:最长标示匹配</h2>
<p>Raku 正则表达式偏好尽可能的匹配最长的选择。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">food and drink</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> foo </span><span class="o">|</span><span class="sr"> food </span><span class="p">/;</span>   <span class="c1"># food</span>
</code></pre></div><p>这跟 Perl5 不一样。Perl5 更喜欢上面例子中的第一个选择, 结果匹配的是 &ldquo;foo&rdquo;。
如果你希望的话, 你依然可以按照优先匹配的原则运行, 这个原则隐藏在稍长选择操作符 <code>||</code> 背后：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">food and drink</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> foo </span><span class="o">||</span><span class="sr"> food </span><span class="p">/;</span>  <span class="c1"># foo</span>
</code></pre></div><p>&hellip;就是这样。这就是最长标记匹配。 ☺ 短文完毕。</p>
<p>“喂, 等等！”你听见你绝望而惊讶的大叫了, 满足你希望让每天的 Raku 圣临历走的慢一点的愿望。“为什么说最长标记匹配很重要？谁会在意这个？”</p>
<p>我很高兴你这样问。事实证明, 最长标记匹配（简称 LTM ）在如何解析的时候和我们的直觉配合相当默契。如果你创造了一门语言, 你希望人们可以声明一个叫 forest_density 的变量而不用提及这个单词和循环里用的 for 语法冲突, LTM 可以做到。</p>
<p>我喜欢“奇怪的一致性”这个说法 - 尤其当程序语言设计的共性让大家越来越雷同的时候。这里就是一种在类和语法之间的一致性。 Raku 基本上把这种一致性发挥到了极致。让我简单的阐述下我的意思。
现在我们习惯于写一个类, 总体来看, 类差不多是长这个样子的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="p">{</span>
    <span class="k">method</span>
    <span class="k">method</span>
    <span class="k">method</span>
<span class="p">}</span>
</code></pre></div><p>奇怪的是, 语法有个非常类似的结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="p">{</span>
    <span class="k">rule</span>
    <span class="k">rule</span>
    <span class="k">rule</span>
<span class="p">}</span>
</code></pre></div><p>(实际上关键词有 regex, token 和 rule, 不过当我们把他当作一个组来讨论的时候, 我们暂时统一叫做 rules)</p>
<p>我们同样习惯于派生子类（class B is A）, 然后添加或者重写方法来产生一个新旧行为在一起的组合。Pelr6 提供了 multi methods , 它允许你添加相同名字的新方法, 而且不重写原有的, 它只尝试匹配所有的到新方法而已。这个调度是由一个（通常自动生成的） proto method 处理的。它负责调度给所有合格的候选者。</p>
<p>这些是怎样用语法和角色运行起来的呢？额, 首先它从原有的里面派生出新的语法, 和派生子类一样。（事实上, 底层是 完全 相同的机制。语法不过是有个不同元类对象的类罢了。）新的角色也会重写原有的角色, 和你在方法上习惯的一样。</p>
<p>S05 有个漂亮的解析信件的示例。然后派生出来解析正式信件的语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Letter</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">text</span>     <span class="p">{</span><span class="sr">    </span><span class="p">}</span>
    <span class="k">rule</span> <span class="nf">greet</span> <span class="p">{</span><span class="sr"> </span><span class="p">[</span><span class="sr">Hi</span><span class="o">|</span><span class="sr">Hey</span><span class="o">|</span><span class="sr">Yo</span><span class="p">]</span><span class="sr"> </span><span class="ni">$</span><span class="o">=</span><span class="p">(</span><span class="se">\S</span><span class="o">+?</span><span class="p">)</span><span class="sr"> , </span><span class="ni">$$</span><span class="p">}</span>
    <span class="k">rule</span> <span class="nf">body</span>     <span class="p">{</span><span class="sr"> </span><span class="o">+?</span><span class="sr"> </span><span class="p">}</span>   <span class="c1"># note: backtracks forwards via +?</span>
    <span class="k">rule</span> <span class="nf">close</span> <span class="p">{</span><span class="sr"> Later dude, </span><span class="ni">$</span><span class="o">=</span><span class="p">(</span><span class="ni">.</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">grammar</span> <span class="nc">FormalLetter</span> <span class="k">is</span> <span class="nc">Letter</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">greet</span> <span class="p">{</span><span class="sr"> Dear </span><span class="ni">$</span><span class="o">=</span><span class="p">(</span><span class="se">\S</span><span class="o">+?</span><span class="p">)</span><span class="sr"> , </span><span class="ni">$$</span><span class="p">}</span>
    <span class="k">rule</span> <span class="nf">close</span> <span class="p">{</span><span class="sr"> Yours sincerely, </span><span class="ni">$</span><span class="o">=</span><span class="p">(</span><span class="ni">.</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>派生出来的 FormalLetter 重写了 greet 和 close, 但是没重写 body。</p>
<p>但是这一切在 multi 方法下也能正常运行吗？我们是不是可以定义一种“原型角色”来允许我们在一个语法里用同样的名字有多种角色, 内容各不相同？比如, 我们可能希望用一个角色 term 来解析语言, 不过有很多不同的 terms：字符串、数字……而且数字可能是十进制、二进制、八进制、十六进制等……</p>
<p>Raku 语法可以包含一个原型角色, 然后你可以定义、重定义同名角色随便多少次。显然让我们回到文章最开始的 <code>/ foo | food /</code>。所有你起了相同名字的角色会编译成一个大的 alternation。</p>
<p>不仅如此 - 调用其他角色的角色, 有些可能是原型角色, 这些也会全部扁平化到一个大的 LTM 轮流选择里。实践中, 这意味着一个 term 的所有可能会一次被全部尝试一遍, 机会平等。没哪个会因为自己是先定义的所以胜出, 只有最长匹配的那个选择才胜出。</p>
<p>这个奇怪的一致性说明事实上, 在调用某个方式的时候, 最具体的方法胜出, 而且这个“最具体”必须加上引号。签名里参数描述类型越好, 方法就越具体。</p>
<p>在分析某个角色的时候, 同样是最具体的角色胜出, 不过这里“最具体”必须成功解析才行。角色描述下一步进入的文本越详细, 角色就越具体。</p>
<p>这就是奇怪的一致性。因为表面上方法和角色看起来就是完全不一样的怪兽。</p>
<p>我们真心相信我们理解了派生语法的原理并且得到了一门新的语言。 LTM 就是最合适的因为它允许新旧角色通过一个公平和可预测的办法混杂在一起。角色不是因为他们定义的前后而胜出, 而是因为它能最好的解析文本。这才是挑选精英的办法。</p>
<p>事实上, Raku 编译器自己就是这样工作的。它使用 Raku 语法解析你的程序, 这个语法是可以派生的……不管你在程序里什么时候声明了一个新操作符, 都会给你派生出一个新的语法。新操作符的解析就作为新角色加入到新语法里。然后把解析剩余程序的任务交给新的语法。你的新操作符会胜过那写相同但匹配更短的, 不过输给相同但匹配更长的。</p>
<h2 id="开开心心玩-rakudo-和-euler-项目">开开心心玩 Rakudo 和 Euler 项目</h2>
<p>Raku 实现的领先者 Rakudo , 目前还不完美, 说起性能也尤其让人尴尬。然而先行者不会问“他快么？”, 而会问“他够快么？”, 甚至是“我怎样能帮他变得更快呢？”。</p>
<p>为了说服你 Rakudo 已经能做到足够快了。我们准备尝试做一组 Euler 项目测试。其中很多涉及强行的数值计算, Rakudo 目前还不是很擅长。不过我们可没必要就此顿足：语言性能降低了, 程序员就要更心灵手巧了, 这正是乐趣所在啊。</p>
<p>所有的代码都是在 Rakudo 2012.11 上测试通过的。</p>
<p>先从一些简单的例子开始。</p>
<p>想想斐波那契序列里数值不超过四百万的元素, 计算这些值的总和。办法超级简单：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">[+]</span> <span class="nb">grep</span> <span class="o">*</span> <span class="nv">%%</span> <span class="mi">2</span><span class="o">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">*+*</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">4_000_000</span><span class="p">);</span>
</code></pre></div><p>运行时间：0.4秒</p>
<p>注意怎样使用操作符才能让代码即紧凑又保持可读性(当然这点大家肯定意见不一)。我们用了：</p>
<ul>
<li>无论如何用 <code>*</code> 创建 lambda 函数</li>
<li>用序列操作符 <code>...^</code> 来建立斐波那契序列</li>
<li>用整除操作符 <code>%%</code> 来过滤元素</li>
<li>用 <code>[+]</code> 做 reduce 操作计算和</li>
</ul>
<p>当然, 没人强制你这样疯狂的使用操作符 - 香草(vanilla)命令式的代码也没问题：</p>
<blockquote>
<p>600851475143 的最大素因数是多少？</p>
</blockquote>
<p>命令式的解决方案是这样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">largest-prime-factor</span><span class="p">(</span><span class="nv">$n</span> <span class="k">is</span> <span class="nb">copy</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">*+</span><span class="mi">2</span> <span class="o">...</span> <span class="o">*</span> <span class="p">{</span>
        <span class="k">while</span> <span class="nv">$n</span> <span class="nv">%%</span> <span class="nv">$_</span> <span class="p">{</span>
            <span class="nv">$n</span> <span class="ow">div</span><span class="o">=</span> <span class="nv">$_</span><span class="p">;</span>
            <span class="k">return</span> <span class="nv">$_</span> <span class="k">if</span> <span class="nv">$_</span> <span class="o">&gt;</span> <span class="nv">$n</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nf">largest-prime-factor</span><span class="p">(</span><span class="mi">600_851_475_143</span><span class="p">);</span>
</code></pre></div><p>运行时间：2.6秒</p>
<p>注意用的 <code>is copy</code>, 因为 Raku 的绑定参数默认是只读的。还有用了整数除法 <code>div</code>, 而没用数值除法的 <code>/</code>。</p>
<p>到目前为止都没有什么特别的, 我们继续:</p>
<p>n从1到100, <!-- raw HTML omitted -->n<!-- raw HTML omitted -->C<!-- raw HTML omitted -->r<!-- raw HTML omitted --> 的值, 不一定要求不同, 有多少大于一百万的？</p>
<p>我们将使用 feed 操作符 <code>==&gt;</code> 来分解算法成计算的每一步：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="k">-&gt;</span> <span class="nv">@p</span> <span class="p">{</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="nv">@p</span> <span class="ow">Z</span><span class="o">+</span> <span class="nv">@p</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="p">}</span> <span class="o">...</span> <span class="o">*</span> <span class="c1"># 生成杨辉三角</span>
<span class="o">==&gt;</span> <span class="p">(</span><span class="o">*[</span><span class="mi">0</span><span class="o">..</span><span class="mi">100</span><span class="o">]</span><span class="p">)()</span>                     <span class="c1"># 生成0到100的n行</span>
<span class="o">==&gt;</span> <span class="nb">map</span> <span class="o">*.</span><span class="nb">list</span>                        <span class="c1"># 平铺成一个列表</span>
<span class="o">==&gt;</span> <span class="nb">grep</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">1_000_000</span>                <span class="c1"># 过滤超过1000000的数</span>
<span class="o">==&gt;</span> <span class="nb">elems</span><span class="p">()</span>                           <span class="c1"># 计算个数</span>
<span class="o">==&gt;</span> <span class="nb">say</span><span class="p">;</span>                              <span class="c1"># 输出结果</span>
</code></pre></div><p>运行时间：5.2s</p>
<p>注意使用了 <code>Z</code> 操作符和 <code>+</code> 来压缩 <code>0,@p</code> 和 <code>@p,0</code> 的两个列表。</p>
<p>这个单行生成杨辉三角的写法是从 Rosetta 代码里偷过来的。那是另一个不错的项目, 如果你对 Raku 的片段练习很感兴趣的话。</p>
<p>让我们做些更巧妙的。</p>
<p>存在一个毕达哥拉斯三元数组让 <code>a +b + c = 1000</code> 。求 a、b、c 的值。</p>
<p>暴力破解可以完成 (Polettix 的解决办法), 但是这个办法不够快（在我机器上花了11秒左右）。让我们用点代数知识把问题更简单的解决。</p>
<p>先创建一个 (a, b, c) 组成的毕达哥拉斯三元数组:</p>
<pre tabindex="0"><code>a &lt; b &lt; c
a² + b² = c²
</code></pre><p>要求 <code>N = a + b +c</code> 就要符合：</p>
<pre tabindex="0"><code>b = N·(N - 2a) / 2·(N - a)
c = N·(N - 2a) / 2·(N - a) + a²/(N - a)
</code></pre><p>这就自动符合了 <code>b &lt; c</code> 的条件。
而 <code>a &lt; b</code> 的条件则产生下面这个约束：</p>
<pre tabindex="0"><code>a &lt; (1 - 1/√2)·N
</code></pre><p>我们就得到以下代码了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">triplets</span><span class="p">(</span>\<span class="n">N</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="nb">Int</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="k">-&gt;</span> \<span class="n">a</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">\u</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">);</span>
        <span class="k">my</span> <span class="nv">\v</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span>

        <span class="c1"># 检查 b = u/v 是否是整数</span>
        <span class="c1"># 如果是, 我们就找到了一个三元数组</span>
        <span class="k">if</span> <span class="n">u</span> <span class="nv">%%</span> <span class="n">v</span> <span class="p">{</span>
            <span class="k">my</span> <span class="nv">\b</span> <span class="o">=</span> <span class="n">u</span> <span class="ow">div</span> <span class="n">v</span><span class="p">;</span>
            <span class="k">my</span> <span class="nv">\c</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
            <span class="nb">take</span> <span class="nv">$</span><span class="p">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="o">[*]</span> <span class="o">.</span><span class="nb">list</span> <span class="k">for</span> <span class="k">gather</span> <span class="nf">triplets</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</code></pre></div><p>运行时间：0.5s</p>
<p>注意 sigilless 变量 <code>\N</code>, <code>\a</code> …… 的声明, <code>$(...)</code> 是怎么用来把三元数组作为单独元素返回的, 用<code>$_.list</code> 的缩写 <code>.list</code> 来恢复其列表性。</p>
<p><code>&amp;triplets</code> 子例程作为生成器, 并且使用 <code>&amp;take</code> 切换到结果。相应的 <code>&amp;gather</code> 用来划定生成器的(动态)作用域, 而且它也可以放进 <code>&amp;triplets</code>, 这个可能返回一个惰性列表。</p>
<p>我们同样可以使用流操作符改写成数据流驱动的风格：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">constant</span> <span class="no">N</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

<span class="mi">1</span><span class="o">..</span><span class="nb">Int</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span>
<span class="o">==&gt;</span> <span class="nb">map</span> <span class="k">-&gt;</span> \<span class="n">a</span> <span class="p">{</span> <span class="o">[</span> <span class="n">a</span><span class="o">,</span> <span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span><span class="o">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">]</span> <span class="p">}</span>
<span class="o">==&gt;</span> <span class="nb">grep</span> <span class="k">-&gt;</span> <span class="o">[</span> \<span class="n">a</span><span class="o">,</span> \<span class="n">u</span><span class="o">,</span> \<span class="n">v</span> <span class="o">]</span> <span class="p">{</span> <span class="n">u</span> <span class="nv">%%</span> <span class="n">v</span> <span class="p">}</span>
<span class="o">==&gt;</span> <span class="nb">map</span> <span class="k">-&gt;</span> <span class="o">[</span> \<span class="n">a</span><span class="o">,</span> \<span class="n">u</span><span class="o">,</span> \<span class="n">v</span> <span class="o">]</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">\b</span> <span class="o">=</span> <span class="n">u</span> <span class="ow">div</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">\c</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>
<span class="p">}</span>
<span class="o">==&gt;</span> <span class="nb">say</span><span class="p">;</span>
</code></pre></div><p>运行时间：0.5s</p>
<p>注意我们是怎样用解压签名绑定 <code>-&gt; [...]</code> 来解压传递过来的数组的。</p>
<p>使用这种特殊的风格没有什么实质的好处：事实上还很容易影响到性能, 我们随后会看到一个这方面的例子。
写纯函数式算法是个超级好的路子。不过原则上这就意味着让那些足够先进的优化器乱来（想想自动向量化和线程）。不过 Rakudo 还没到这个复杂地步。</p>
<p>但是如果我们没有聪明到可以找到这么牛叉的解决办法, 该怎么办呢？</p>
<p>求第一个连续四个整数, 他们有四个不同的素因数。</p>
<p>除了暴力破解, 我没找到任何更好的办法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">constant</span> <span class="nv">$N</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">2</span><span class="o">..*</span> <span class="p">{</span>
    <span class="nv">$i</span> <span class="o">=</span> <span class="nf">factors</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="o">==</span> <span class="nv">$N</span> <span class="o">??</span> <span class="nv">$i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!!</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="nv">$i</span> <span class="o">==</span> <span class="nv">$N</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nv">$_</span> <span class="o">-</span> <span class="nv">$N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nb">last</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这里, <code>&amp;fators</code> 返回素因数的个数, 原始的实现差不多是这样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">factors</span><span class="p">(</span><span class="nv">$n</span> <span class="k">is</span> <span class="nb">copy</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">*+</span><span class="mi">2</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="nv">$n</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$n</span> <span class="nv">%%</span> <span class="nv">$_</span> <span class="p">{</span>
            <span class="o">++</span><span class="nv">$i</span><span class="p">;</span>
            <span class="k">repeat</span> <span class="k">while</span> <span class="nv">$n</span> <span class="nv">%%</span> <span class="nv">$_</span> <span class="p">{</span>
                <span class="nv">$n</span> <span class="ow">div</span><span class="o">=</span> <span class="nv">$_</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nv">$i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>运行时间：unknown (33s for N=3)</p>
<p>注意 <code>repeat while ...{...}</code> 的用法, 这是 <code>do {...} while(...);</code> 的新写法。
我们可以加上点缓存来加速程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">BEGIN</span> <span class="k">my</span> <span class="nv">%cache</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">multi</span> <span class="nf">factors</span><span class="p">(</span><span class="nv">$n</span> <span class="k">where</span> <span class="nv">%cache</span><span class="p">)</span> <span class="p">{</span> <span class="nv">%cache</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">factors</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">*+</span><span class="mi">2</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="nb">sqrt</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$n</span> <span class="nv">%%</span> <span class="nv">$_</span> <span class="p">{</span>
            <span class="k">my</span> <span class="nv">$r</span> <span class="o">=</span> <span class="nv">$n</span><span class="p">;</span>
            <span class="nv">$r</span> <span class="ow">div</span><span class="o">=</span> <span class="nv">$_</span> <span class="k">while</span> <span class="nv">$r</span> <span class="nv">%%</span> <span class="nv">$_</span><span class="p">;</span>
            <span class="k">return</span> <span class="nv">%cache</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">factors</span><span class="p">(</span><span class="nv">$r</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nv">%cache</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>运行时间：unknown (3.5s for N=3)</p>
<p>注意用 <code>BEGIN</code> 来初始化缓存, 不管出现在源代码里哪个位置。还有用 <code>multi</code> 来启用对 <code>&amp;factors</code> 的多样调度。<code>where</code> 子句可以根据参数的值进行动态调度。</p>
<p>哪怕有缓存, 我们依然无法在一个合理的时间内回答上来原来的问题。现在我们怎么办？只能用点骗子手段了Zavolaj – Rakudo 版本的 NativeCall – 来在C语言里实现因式分解。</p>
<p>事实证明这还不够好, 所以我们继续重构剩下的代码, 添加一些原型声明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nb">NativeCall</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">factors</span><span class="p">(</span><span class="nb">int</span> <span class="nv">$n</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">int</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#39;</span><span class="s1">./prob047-gerdr</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>

<span class="k">my</span> <span class="nb">int</span> <span class="nv">$N</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

<span class="k">my</span> <span class="nb">int</span> <span class="nv">$n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">my</span> <span class="nb">int</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">while</span> <span class="nv">$i</span> <span class="o">!=</span> <span class="nv">$N</span> <span class="p">{</span>
    <span class="nv">$i</span> <span class="o">=</span> <span class="nf">factors</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="o">==</span> <span class="nv">$N</span> <span class="o">??</span> <span class="nv">$i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!!</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nv">$n</span> <span class="o">=</span> <span class="nv">$n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nv">$n</span> <span class="o">-</span> <span class="nv">$N</span><span class="p">;</span>
</code></pre></div><p>运行时间：1m2s (0.8s for N=3)</p>
<p>相比之下, 完全使用C语言实现这个算法, 运行时间在0.1秒之内。所以目前 Rakudo 还没法赢得任何一种速度测试。</p>
<p>重复一下, 用三种办法做一件事：</p>
<p>在 <code>2 ≤ a ≤ 100</code> 和 <code>2 ≤ b ≤ 100</code> 的情况下由 a<!-- raw HTML omitted -->b<!-- raw HTML omitted --> 生成的序列里有多少不一样的元素？
下面是一个很漂亮但很慢的解决办法, 可以用来验证其他办法是否正确：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="mi">100</span> <span class="ow">X</span><span class="o">=&gt;</span> <span class="mi">2</span><span class="o">..</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="nb">classify</span><span class="p">({</span> <span class="o">.</span><span class="nb">key</span> <span class="o">**</span> <span class="o">.</span><span class="nb">value</span> <span class="p">});</span>
</code></pre></div><p>运行时间：11s</p>
<p>注意使用 <code>X=&gt;</code> 来构造笛卡尔乘积。用对构造器 <code>=&gt;</code> 防止序列被压扁而已。</p>
<p>因为 Rakudo 支持大整数语义, 所以在计算像 100100 这种大数的时候没有精密度上的损失。</p>
<p>不过我们并不真的在意幂的值, 不过用基数和指数来唯一标示幂。我们需要注意基数可能自己本身就是前面某次的幂值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">constant</span> <span class="no">A</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">constant</span> <span class="no">B</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="k">my</span> <span class="p">(</span><span class="nv">%powers</span><span class="o">,</span> <span class="nv">%count</span><span class="p">);</span>

<span class="c1"># 找出那些是之前基数的幂的基数</span>
<span class="c1"># 分别存储基数和指数</span>
<span class="k">for</span> <span class="mi">2</span><span class="o">..</span><span class="nb">Int</span><span class="p">(</span><span class="nb">sqrt</span> <span class="n">A</span><span class="p">)</span> <span class="k">-&gt;</span> \<span class="n">a</span> <span class="p">{</span>
    <span class="nb">next</span> <span class="k">if</span> <span class="n">a</span> <span class="o">~~</span> <span class="nv">%powers</span><span class="p">;</span>
    <span class="nv">%powers</span><span class="p">{</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">,</span> <span class="n">a</span><span class="o">**</span><span class="mi">3</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">}</span> <span class="o">=</span> <span class="n">a</span> <span class="ow">X</span><span class="o">=&gt;</span> <span class="mi">1</span><span class="o">..*</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1"># 计算重复的个数</span>
<span class="k">for</span> <span class="nv">%powers</span><span class="o">.</span><span class="nb">values</span> <span class="k">-&gt;</span> \<span class="n">p</span> <span class="p">{</span>
    <span class="k">for</span> <span class="mi">2</span><span class="o">..</span><span class="n">B</span> <span class="k">-&gt;</span> \<span class="nb">e</span> <span class="p">{</span>
        <span class="c1"># 上升到 \e 的幂</span>
        <span class="c1"># 根据之前的基数和对应指数分类</span>
        <span class="o">++</span><span class="nv">%count</span><span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="s">key</span> <span class="o">=&gt;</span> <span class="n">p</span><span class="o">.</span><span class="nb">value</span> <span class="o">*</span> <span class="nb">e</span><span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># 添加 +%count 作为一个需要保存的副本</span>
<span class="nb">say</span> <span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">B</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nv">%count</span> <span class="o">-</span> <span class="o">[+]</span> <span class="nv">%count</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>
</code></pre></div><p>运行时间：0.9s</p>
<p>注意用序列操作符 <code>...^</code> 推断集合序列, 只要提供至少三个元素, 列表赋值 <code>%powers{...} = ...</code> 就会无休止的进行下去。</p>
<p>我们再次用数据驱动的函数式的风格重写一遍：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">cross</span><span class="p">(</span><span class="nv">@a</span><span class="o">,</span> <span class="nv">@b</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@a</span> <span class="ow">X</span> <span class="nv">@b</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">dups</span><span class="p">(</span><span class="nv">@a</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@a</span> <span class="o">-</span> <span class="nv">@a</span><span class="o">.</span><span class="nf">uniq</span> <span class="p">}</span>

<span class="k">constant</span> <span class="no">A</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">constant</span> <span class="no">B</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="mi">2</span><span class="o">..</span><span class="nb">Int</span><span class="p">(</span><span class="nb">sqrt</span> <span class="n">A</span><span class="p">)</span>
<span class="o">==&gt;</span> <span class="nb">map</span> <span class="k">-&gt;</span> \<span class="n">a</span> <span class="p">{</span> <span class="p">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">,</span> <span class="n">a</span><span class="o">**</span><span class="mi">3</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">)</span> <span class="ow">Z</span><span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">X</span> <span class="mi">1</span><span class="o">..*</span><span class="p">)</span><span class="o">.</span><span class="nb">tree</span> <span class="p">}</span>
<span class="o">==&gt;</span> <span class="nb">reverse</span><span class="p">()</span>
<span class="o">==&gt;</span> <span class="nb">hash</span><span class="p">()</span>
<span class="o">==&gt;</span> <span class="nb">values</span><span class="p">()</span>
<span class="o">==&gt;</span> <span class="nb">cross</span><span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="n">B</span><span class="p">)</span>
<span class="o">==&gt;</span> <span class="nb">map</span> <span class="k">-&gt;</span> \<span class="n">n</span><span class="o">,</span> <span class="o">[</span>\<span class="nb">r</span><span class="o">,</span> \<span class="nb">e</span><span class="o">]</span> <span class="p">{</span> <span class="p">(</span><span class="nb">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">e</span> <span class="o">*</span> <span class="n">n</span> <span class="p">}</span>
<span class="o">==&gt;</span> <span class="nf">dups</span><span class="p">()</span>
<span class="o">==&gt;</span> <span class="p">((</span><span class="n">A</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">B</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="o">*</span><span class="p">)()</span>
<span class="o">==&gt;</span> <span class="nb">say</span><span class="p">();</span>
</code></pre></div><p>运行时间：1.5s</p>
<p>注意我们怎么用 <code>&amp;tree</code> 来防止压扁的。我们可以像之前那样用 <code>X=&gt;</code> 替代 X , 不过这会让通过 <code>-&gt;  \n, [\r, \e]</code> 解构变得很复杂。</p>
<p>和预想的一样, 这个写法没像命令式的那样执行出来。怎么才能正常运行呢？这算是我留给读者的作业吧。</p>
<h2 id="解析-ipv4-地址">解析 IPv4 地址</h2>
<p>Raku 的正则现在是一种子语言了, 很多语法没有变:</p>
<pre tabindex="0"><code>/\d+/
</code></pre><p>捕获数字：</p>
<pre tabindex="0"><code>/(\d+)/
</code></pre><p>现在 <code>$0</code> 存储着匹配到的数字, 而不是 Perl 5 中的 <code>$1</code>. 所有的特殊变量 <code>$0</code>,<code>$1</code>,<code>$2</code> 在 Raku 里就是 <code>$/[0]</code>, <code>$/[1]</code>, <code>$/[2]</code>. 在 Perl 5 中, <code>$0</code> 是脚本或程序的文件名, 但是这在 Raku 中变成了 <code>$*EXECUTABLE_NAME</code>。</p>
<p>如果你对获得一个正则匹配的所有捕获组感兴趣, 你可以使用 <code>@()</code>, 它是 <code>@($/)</code> 的语法糖。
<code>$/</code> 变量中的对象拥有许多关于最后一次匹配的有用信息。例如, <code>$/.from</code> 将给你匹配的起始字符串位置。
但是 <code>$0</code> 将使我们在这篇文章中走得足够远。我们用它来从一个字符串中提取单个特征。</p>
<p>修饰符现在放在前面了:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">1 23 456 78.9</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="o">.</span><span class="nb">Str</span> <span class="k">for</span> <span class="k">m</span><span class="p">:</span><span class="na">g</span><span class="p">/(</span><span class="se">\d</span><span class="o">+</span><span class="p">)/;</span> <span class="c1"># 1 23 456 78 9</span>
</code></pre></div><p>匹配所有看起来像这样的东西很有用, 以至于它有一个专门的 <code>.comb</code> 方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$str</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\d</span><span class="o">+</span><span class="p">/);</span>
</code></pre></div><p>如果你对 <code>.split</code> 很熟悉, 你可以想到 <code>.comb</code> 就是它的表哥, 它匹配 <code>.split</code> 丢弃的东西 。
Perl 5 中匹配 IPv4 地址的正则如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">/(</span><span class="se">\d</span><span class="p">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="p">})</span><span class="se">\</span><span class="sr">.</span><span class="p">(</span><span class="se">\d</span><span class="p">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="p">})</span><span class="se">\</span><span class="sr">.</span><span class="p">(</span><span class="se">\d</span><span class="p">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="p">})</span><span class="se">\</span><span class="sr">.</span><span class="p">(</span><span class="se">\d</span><span class="p">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="p">})/</span>
</code></pre></div><p>这在 Raku 中是无效的。首先, {} 块在 Raku 的 正则中是真正的代码块；它们包含 Raku 代码。第二, 在 Raku 中请使用 <code>** N..M</code> (或 <code>** N..*</code>)  代替 <code>{N,M}</code></p>
<p>在 Raku 中匹配1到3位数字的正则如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">/</span><span class="se">\d</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">/</span>
</code></pre></div><p>匹配 Ipv4地址：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">/(</span><span class="se">\d</span><span class="o">**</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="sr"> </span><span class="se">\</span><span class="sr">. </span><span class="p">(</span><span class="se">\d</span><span class="o">**</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="sr"> </span><span class="se">\</span><span class="sr">. </span><span class="p">(</span><span class="se">\d</span><span class="o">**</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="sr"> </span><span class="se">\</span><span class="sr">. </span><span class="p">(</span><span class="se">\d</span><span class="o">**</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)/</span>
</code></pre></div><p>那仍有点笨拙。在 Raku 的正则中, 你可以使用重复操作符 <code>%</code> , 下面是重复 <code>(\d ** 1..3)</code> 这个正则 4次, 并使用 <code>.</code> 点号作为分隔符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">4</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">/</span>
</code></pre></div><p><code>%</code> 操作符是一个量词修饰符, 所以它只跟在一个像 <code>*</code> 或 <code>+</code> 或 <code>**</code> 的量词后面。上面的正则意思是 匹配 4 组数字, 在每组数字间插入一个直接量 点号 <code>.</code>。</p>
<p>你也可能注意到 <code>\.</code> 变成了 <code>'.'</code> , 它们是一样的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Go 127.0.0.1, I said! He went to 173.194.32.32.</span><span class="p">&#34;;</span>

<span class="nb">say</span> <span class="o">.</span><span class="nb">Str</span> <span class="k">for</span> <span class="k">m</span><span class="p">:</span><span class="na">g</span><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">4</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">/;</span>
<span class="c1"># output: 127.0.0.1 173.194.32.32</span>
</code></pre></div><p>或者我们可以使用 <code>.comb</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Go 127.0.0.1, I said! He went to 173.194.32.32.</span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">@ip4addrs</span> <span class="o">=</span> <span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">4</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">/);</span>   <span class="c1"># 127.0.0.1 173.194.32.32</span>
</code></pre></div><p>如果我们对单独的数字感兴趣：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Go 127.0.0.1, I said! He went to 173.194.32.32.</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="o">.</span><span class="nb">list</span><span class="o">&gt;&gt;.</span><span class="nb">Str</span><span class="o">.</span><span class="nb">perl</span> <span class="k">for</span> <span class="k">m</span><span class="p">:</span><span class="na">g</span><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">4</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">/;</span>
<span class="c1"># output: (&#34;127&#34;, &#34;0&#34;, &#34;0&#34;, &#34;1&#34;) (&#34;173&#34;, &#34;194&#34;, &#34;32&#34;, &#34;32&#34;)</span>
</code></pre></div><h2 id="引号">引号</h2>
<p>在很多地方, Raku 都提供给你更合理的默认设置以便在大多数情况下让你的工作变得更简单有趣。引号也不例外。</p>
<p>最常见的两种引号就是单引号和双引号。单引号最简单：让你引起一个字符串。唯一的“魔法”就是你可以用反斜杠转义一个单引号。而因为反斜杠的这个作用, 你可以用 <code>\\</code> 来表示反斜杠本身了。不过其实这个做法也是没必要的, 反斜杠自己可以直接传递。下面是一组例子：</p>
<pre tabindex="0"><code>&gt; say 'Everybody loves Magical Trevor’;
Everybody loves Magical Trevor
&gt; say 'Oh wow, it\'s backslashed!’;
Oh wow, it's backslashed!
&gt; say 'You can include a \\ like this’;
You can include a \ like this
&gt; say 'Nothing like \n is available’;
Nothing like \n is available
&gt; say 'And a \ on its own is no problem’;
And a \ on its own is no problem
</code></pre><p>双引号, 额, 从字面上看就知道了, 两倍自然更强大了。:-) 它支持反斜杠转义, 但更重要的是他支持<code>内插</code>。也就是说<code>变量</code>和<code>闭包</code>可以放进双引号里。大大的帮你节约使用连接操作符或者字符串格式定义等等的时间。</p>
<p>下面是几个简单的例子：</p>
<pre tabindex="0"><code>&gt; say &quot;Ooh look!\nLine breaks!&quot;
Ooh look!
Line breaks!
&gt; my $who = 'Ninochka'; say &quot;Hello, dear $who&quot;
Hello, dear Ninochka
&gt; say &quot;Hello, { prompt 'Enter your name: ' }!&quot;
Enter your name: _Jonathan_
Hello, Jonathan!
</code></pre><p>上面第二个例子展示了标量内插, 第三个则展示了闭包也可以插入双引号字符串里。闭包产生的值会被字符串化然后插入字符串中。那除了 <code>$</code> 开头的呢？ 规则是这样的：所有的都可以插入, 但前提是它们被某些后环缀(译者注：postcircumfix)(也就是带下标或者扩的数组或者哈希, 可以做引用或者方法调用)允许。事实上你也可以把他们都存进标量里。</p>
<pre tabindex="0"><code>&gt; my @beer = &lt;Chimay Hobgoblin Yeti&gt;;
Chimay Hobgoblin Yeti
&gt; say &quot;First up, a @beer[0]&quot;
First up, a Chimay
&gt; say &quot;Then @beer[1,2].join(' and ')!&quot;
Then Hobgoblin and Yeti!
&gt; say &quot;Tu je &amp;prompt('Ktore pivo chces? ')&quot;
Ktore pivo chces? _Starobrno_
Tu je Starobrno
</code></pre><p>这里你看到了一个数组元素的内插, 一个被调用了方法的数组切片的内插和一个函数调用的内插。后环缀规则意味着我们再也不会砸掉你口年的邮箱地址了(译者注：邮箱地址里有@号)。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Please spam me at blackhole</span><span class="nv">@jnthn</span><span class="s2">.net</span><span class="p">&#34;</span>
<span class="n">Please</span> <span class="n">spam</span> <span class="n">me</span> <span class="nb">at</span> <span class="n">blackhole</span><span class="nv">@jnthn</span><span class="o">.</span><span class="nf">net</span>
</code></pre></div><h3 id="选择你自己的分隔符">选择你自己的分隔符</h3>
<p>单/双引号对大多数情况下都很好用, 不过如果你想在字符串里使用这些引号的时候咋办？继续用反斜杠不是什么好主意。其实你可以自定义其他字符做为引号字符。Raku 替你选好了。<code>q</code> 和 <code>qq</code> 引号结构后面紧跟的字符就会被作为分隔符。如果这个字符有相对应的关闭符, 那么就自动查找这个（比如, 如果你用了一个开启花括号{, 那么字符串就会在闭合花括号}处结束。注意你还可以使用多字符开启符和闭合符（不过要求是相同字符重复组成的多字符））。另外, <code>q</code> 的语义等同于单引号, <code>qq</code> 的语义等同于双引号。</p>
<pre tabindex="0"><code>&gt; say q{C'est la vie}
C'est la vie
&gt; say q{{Unmatched } and { are { OK } in { here}}
Unmatched } and { are { OK } in { here
&gt; say qq!Lottery results: {(1..49).roll(6).sort}!
Lottery results: 12 13 26 34 36 46
</code></pre><h3 id="定界符heredoc">定界符(Heredoc)</h3>
<p>所有的引号结构都允许你包含多行内容。不过, 还有更好的办法：定界文档。还是用 <code>q</code> 或者 <code>qq</code> 开始, 然后跟上 <code>:to</code> 副词来定义我们期望在文本最后某行匹配的字符。让我们通过下面这个感人的故事看看它是怎么工作的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">print</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/THE END/
</span><span class="p"></span><span class="s">    Once upon a time, there was a pub. The pub had
</span><span class="s">    lots of awesome beer. One day, a Perl workshop
</span><span class="s">    was held near to the pub. The hackers drank
</span><span class="s">    the pub dry. The pub owner could finally afford
</span><span class="s">    a vacation.
</span><span class="s">    </span><span class="p">THE END</span>
</code></pre></div><p>脚本的输出如下：</p>
<pre tabindex="0"><code>Once upon a time, there was a pub. The pub had
lots of awesome beer. One day, a Perl workshop
was held near to the pub. The hackers drank
the pub dry. The pub owner could finally afford
a vacation.
</code></pre><p>注意输出文本并没有像源程序那样缩进。定界符会自动清楚缩进到终端的级别。如果我们用 qq , 我们也可以往定界符里插入东西。注意这些都是通过字符串的 ident 方法实现的, 但是如果你的字符串里没有内插, 我们会在编译期的时候调用 ident 作为一种优化手段。</p>
<p>你同样可以有多个定界符, 包括调用定界符里的数据的方法也是可以的（注意下面的程序就调用了 lines 方法）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="p">(</span><span class="nv">$input</span><span class="o">,</span> <span class="nv">@searches</span><span class="p">)</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/INPUT/,</span><span class="s"> q:to/SEARCHES/.lines;
</span><span class="s">    Once upon a time, there was a pub. The pub had
</span><span class="s">    lots of awesome beer. One day, a Perl workshop
</span><span class="s">    was held near to the pub. The hackers drank
</span><span class="s">    the pub dry. The pub owner could finally afford
</span><span class="s">    a vacation.
</span><span class="s">    </span><span class="p">INPUT</span>
    <span class="n">beer</span>
    <span class="n">masak</span>
    <span class="n">vacation</span>
    <span class="n">whisky</span>
    <span class="n">SEARCHES</span>

<span class="k">for</span> <span class="nv">@searches</span> <span class="k">-&gt;</span> <span class="nv">$s</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$input</span> <span class="o">~~</span> <span class="p">/</span><span class="nv">$s</span><span class="p">/</span>
        <span class="o">??</span> <span class="p">&#34;</span><span class="s2">Found </span><span class="nv">$s</span><span class="p">&#34;</span>
        <span class="o">!!</span> <span class="p">&#34;</span><span class="s2">Didn&#39;t find </span><span class="nv">$s</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>这个程序输出是：</p>
<pre tabindex="0"><code>Found beer
Didn't find masak
Found vacation
Didn't find whisky
</code></pre><h3 id="自定义引号结构的引号副词">自定义引号结构的引号副词</h3>
<p>单/双引号的语义, 也是 q 和 qq 的语义, 已经可以解决绝大多数情况了。不过如果你有这么种情况：你要输出内插闭包而不是标量怎么办？这时候就要用上引号副词了。它们决定你是否开启引号特性。下面是例子：</p>
<pre tabindex="0"><code>&gt; say qq:!s&quot;It costs $10 to {&lt;eat nom&gt;.pick} here.&quot;
It costs $10 to eat here.
</code></pre><p>这里我们使用了 qq 语义, 但是关闭里标量内插, 这意味着我们可以放心往里写价钱而不用担心他会试图解析成上一次正则匹配的第十一个捕获值。注意这里使用的标准的冒号对(colonpair)语法。如果你希望从一个最基础的引号结构开始, 然后自己手动的一个个打开选项, 那么你应该使用 Q 结构。</p>
<pre tabindex="0"><code>&gt; say Q{$*OS\n&amp;sin(3)}
$*OS\n&amp;sin(3)
&gt; say Q:s{$*OS\n&amp;sin(3)}
MSWin32\n&amp;sin(3)
&gt; say Q:s:b{$*OS\n&amp;sin(3)}
MSWin32
&amp;sin(3)
&gt; say Q:s:b:f{$*OS\n&amp;sin(3)}
MSWin32
0.141120008059867
</code></pre><p>这里我们用了无特性引号结构, 然后打开附加特性, 地一个是标量内插, 然后是反斜杠转义, 然后函数内插。注意我们同样可以选择自己希望的任何分隔符。</p>
<h3 id="引号结构是一门语言">引号结构是一门语言</h3>
<p>最后, 值得一提的是：当解析器进入引号结构的时候, 其实他是切换成解析另外一个语言了。当我们用副词构建引号结构的时候, 他只不过是把这些额外的角色混合进基础的引号语言里来开启额外的特性。好奇的童鞋可以看这里： Rakudo 怎么做到的。而当我们碰到闭包或者其他内插的时候, 解析器再临时切换回主语言。所以你可以这样写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, </span><span class="p">{</span> <span class="nb">prompt</span> <span class="p">&#34;</span><span class="s2">Enter your name: </span><span class="p">&#34;</span> <span class="p">}</span><span class="s2">!</span><span class="p">&#34;</span>
<span class="n">Enter</span> <span class="nf">your</span> <span class="nb">name</span><span class="o">:</span> <span class="n">Jonathan</span>
<span class="n">Hello</span><span class="o">,</span> <span class="n">Jonathan</span><span class="o">!</span>
</code></pre></div><p>解析器不会困惑于内插的闭包里又带有其他双引号字符串的问题。因为我们解析主语言, 然后切换到引号语言, 然后返回主语言, 然后重新再返回引号语言来解析这个程序里的字符串里的闭包里的字符串。这就是 Raku 解析器送给我们的圣诞节礼物, 俄罗斯套娃娃。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/calendar" term="calendar" label="calendar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 圣诞月历 - 2014]]></title>
            <link href="https://ohmyweekly.github.io/notes/2014-12-19-raku-calendar/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2014-12-19-raku-calendar/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-07T00:00:00+00:00</published>
            <updated>2021-07-07T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Calendar</blockquote><h2 id="data-munging-in-raku">Data munging in Raku</h2>
<p>案例学习: 生成成绩报告单</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">example.txt
STDOUT
Peter	B
Celine	A-
Zsófia	B+
João	F
Maryam	B+
秀英	B-
Finn	D+
Aarav	A
Emma	F
Omar	B
</code></pre></div><p>输出报告单：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">Zsófia&#39;s grade: B+
List of students with a failing grade:
  João, Emma
Distribution of grades by letter:
  A: 2 students
  B: 5 students
  D: 1 student
  F: 2 students
</code></pre></div><p>example.txt 是一个文本文件, 每行一个学生姓名和分数, 中间用空格分割。
我们希望我们的脚本能解析这样的文件并打印含有如下信息的报告：</p>
<p>学生名为 “Zsófia” 的成绩<br>
所有不及格学生的名字 (i.e. worse than D-),<br>
根据字母( 不带 <code>+</code>/<code>-</code> ) 把成绩分组。得到学生成绩的分布。</p>
<p>让我们一步步来, 添加 shebang 行:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!/usr/bin/env raku</span>
</code></pre></div><p>在 Raku 中所有这些都为我们做好了。</p>
<p>读取并解析输入:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%grade</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">grades.txt</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span>
   <span class="k">m</span><span class="p">:</span><span class="na">s</span><span class="p">/</span><span class="ni">^</span><span class="p">(</span><span class="se">\w</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">(&lt;[</span><span class="sr">A</span><span class="o">..</span><span class="sr">F</span><span class="p">]&gt;&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="p">)</span><span class="ni">$</span><span class="p">/</span>
        <span class="ow">or</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Can&#39;t parse line &#39;</span><span class="nv">$_&#39;</span><span class="p">&#34;;</span>
    <span class="o">~</span><span class="nv">$0</span> <span class="o">=&gt;</span> <span class="o">~</span><span class="nv">$1</span>
<span class="p">};</span>
</code></pre></div><p>在 Raku 中, 对文件名字符串调用 <a href="https://docs.raku.org/type/IO::Path">.IO</a> 方法会返回一个代表文件系统路径的对象, 我们可以继续在这个对象上调用 <a href="https://docs.raku.org/routine/lines">.lines</a> 方法, 得到文件的所有行的一个惰性列表。“Lazy” 意味着它只会从磁盘中按需读取新行, 当我们使用 <a href="https://docs.raku.org/routine/map">.map</a> 方法遍历列表元素的时候, 这样能使用单个赋值操作就能优雅地初始化一个散列。</p>
<p>我们不需要让文件句柄识别 Unicode, 也不用管文件句柄是否正确关闭, 这在 Raku 中都是默认发生的。</p>
<p><code>method: ...</code> 语法也可以写为 <code>.method(...)</code>, 前者使 map 看起来更像一个 block 语句, 并减少了括号凌乱。
<code>:s</code>(&ldquo;sigspace&rdquo;) 正则修饰符使解析 token 间的空白更优雅。但 Raku 中的字符类比 Perl 5 复杂了一丢丢。
正则捕获结果变量(<code>$0</code>, <code>$1</code>, …) 返回一个完整的 <a href="https://docs.raku.org/type/Match">Match</a> 对象 - 它为复杂使用场景增加了很多灵活性, 但是这里我们只想保留字符串, 所以使用 <a href="https://docs.raku.org/routine/~">~</a> 前置操作符字符串化了匹配对象。</p>
<p>查看数据的特定项:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Zsófia&#39;s grade: </span><span class="nv">%grade</span><span class="s2">&lt;Zsófia&gt;</span><span class="p">&#34;;</span>
</code></pre></div><p>Raku 总是把散列中 <code>{ }</code> 中的东西解析为表达式, 使用 <code>&lt; &gt;</code> 表示字面值。</p>
<p>过滤数据:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">List of students with a failing grade:</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">  </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">%grade</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*.</span><span class="nb">value</span> <span class="ow">ge</span> <span class="p">&#34;</span><span class="s2">E</span><span class="p">&#34;)</span><span class="o">».</span><span class="nb">key</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">, </span><span class="p">&#34;);</span>
</code></pre></div><p>Raku 中允许我们按执行顺序把一些列方法写为链式操作。有一个重要区别：Raku 能让我们直接遍历散列的项, 散列中每一项都是一个 <a href="https://docs.raku.org/type/Pair">Pair</a> 对象(Pair 对象能使用 <a href="https://docs.raku.org/type/Pair#method_key">.key</a> 和 <a href="https://docs.raku.org/type/Pair#method_value">.value</a> 方法)。</p>
<p><code>*</code> <a href="https://docs.raku.org/type/Whatever">Whatever</a> star 用于定义一个简单的回调, 而不用写一个花括号块。
<code>».</code> <a href="https://docs.raku.org/language/operators#index-entry-hyper_%3C%3C-hyper_%3E%3E-hyper_%C2%AB-hyper_%C2%BB-Hyper_operators">hyper operator</a> 用于对 <a href="https://docs.raku.org/routine/grep">.grep</a> 返回的 Pairs 的每个 Pair 上调用 一次 .key 方法, 得出姓名列表</p>
<p>从数据中创建频率分布:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Distribution of grades by letter:</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;{</span><span class="o">.</span><span class="nb">key</span><span class="p">}</span><span class="s2">: </span><span class="p">{</span><span class="o">+.</span><span class="nb">value</span><span class="p">}</span><span class="s2"> student</span><span class="p">{&#34;</span><span class="s2">s</span><span class="p">&#34;</span> <span class="k">if</span> <span class="o">.</span><span class="nb">value</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">}&#34;</span>

<span class="k">for</span> <span class="nv">%grade</span><span class="o">.</span><span class="nb">classify</span><span class="p">(</span><span class="o">*.</span><span class="nb">value</span><span class="o">.</span><span class="nb">comb</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">*.</span><span class="nb">key</span><span class="p">);</span>
</code></pre></div><p>计数和分组实在太常见了, Raku 提供了 <a href="https://docs.raku.org/routine/classify">.classify</a> 方法。
classify 方法里需要指定要分组的项(这里是代表 <code>%grade</code> 条目的 Pair 对象), 这些项应该根据什么规则进行分组(这里是根据第一个字母的值, 它代表分数(没有 <code>+</code>/<code>-</code>)。</p>
<p>这生成一个匿名的散列, 散列的值是匿名数组。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">%(&#34;B&#34; =&gt; [&#34;Peter&#34; =&gt; &#34;B&#34;, &#34;Zsófia&#34; =&gt; &#34;B+&#34;, &#34;Maryam&#34; =&gt; &#34;B+&#34;,
 &#34;秀英&#34; =&gt; &#34;B-&#34;, &#34;Omar&#34; =&gt; &#34;B&#34;], &#34;A&#34; =&gt; [&#34;Celine&#34; =&gt; &#34;A-&#34;, &#34;Aarav&#34; =&gt; &#34;A&#34;], &#34;F&#34; =&gt; [&#34;João&#34; =&gt; &#34;F&#34;, &#34;Emma&#34; =&gt; &#34;F&#34;], &#34;D&#34; =&gt; [&#34;Finn&#34; =&gt; &#34;D+&#34;])
</code></pre></div><p>因为我们只对每组元素的个数感兴趣, 我们使用 <a href="https://docs.raku.org/routine/+">+</a> 前置操作符数字化每个值然后打印它, 在数组前面添加 <code>+</code> 符号会得到数组元素的个数。</p>
<p>在 term 位置上一个单独的 <code>.method</code> 方法等价于 <code>$_.method</code>, 意思是对当前循环变量调用该方法。任意代码的返回值能使用花括号 <code>{}</code> 插值到字符串中。</p>
<p><code>if</code> 语句能被用作表达式 - 当条件为 false 时, 返回空列表, 然后被字符串化为空字符串。对字符串调用不带参数的 <a href="https://docs.raku.org/routine/comb">.comb</a> 会生成该字符串的一个字符列表。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/calendar" term="calendar" label="calendar" />
                            
                        
                    
                
            
        </entry>
    
</feed>
