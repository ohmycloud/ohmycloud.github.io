<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.85.0">Hugo</generator><title type="html"><![CDATA[calendar on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/calendar/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/calendar/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/calendar/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/calendar/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2021-07-07T23:01:08+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/calendar/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 圣诞月历 - 2014]]></title>
            <link href="https://ohmyweekly.github.io/notes/2014-12-19-raku-calendar/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2014-12-19-raku-calendar/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-07T00:00:00+08:00</published>
            <updated>2021-07-07T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Calendar</blockquote><h2 id="data-munging-in-raku">Data munging in Raku</h2>
<p>案例学习: 生成成绩报告单</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">example.txt
STDOUT
Peter	B
Celine	A-
Zsófia	B+
João	F
Maryam	B+
秀英	B-
Finn	D+
Aarav	A
Emma	F
Omar	B
</code></pre></div><p>输出报告单：</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Zsófia&#39;s grade: B+
List of students with a failing grade:
  João, Emma
Distribution of grades by letter:
  A: 2 students
  B: 5 students
  D: 1 student
  F: 2 students
</code></pre></div><p>example.txt 是一个文本文件, 每行一个学生姓名和分数, 中间用空格分割。
我们希望我们的脚本能解析这样的文件并打印含有如下信息的报告：</p>
<p>学生名为 “Zsófia” 的成绩<br>
所有不及格学生的名字 (i.e. worse than D-),<br>
根据字母( 不带 <code>+</code>/<code>-</code> ) 把成绩分组。得到学生成绩的分布。</p>
<p>让我们一步步来, 添加 shebang 行:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!/usr/bin/env raku</span>
</code></pre></div><p>在 Raku 中所有这些都为我们做好了。</p>
<p>读取并解析输入:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%grade</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">grades.txt</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span>
   <span class="k">m</span><span class="p">:</span><span class="na">s</span><span class="p">/</span><span class="ni">^</span><span class="p">(</span><span class="se">\w</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">(&lt;[</span><span class="sr">A</span><span class="o">..</span><span class="sr">F</span><span class="p">]&gt;&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="p">)</span><span class="ni">$</span><span class="p">/</span>
        <span class="ow">or</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Can&#39;t parse line &#39;</span><span class="nv">$_&#39;</span><span class="p">&#34;;</span>
    <span class="o">~</span><span class="nv">$0</span> <span class="o">=&gt;</span> <span class="o">~</span><span class="nv">$1</span>
<span class="p">};</span>
</code></pre></div><p>在 Raku 中, 对文件名字符串调用 <a href="https://docs.raku.org/type/IO::Path">.IO</a> 方法会返回一个代表文件系统路径的对象, 我们可以继续在这个对象上调用 <a href="https://docs.raku.org/routine/lines">.lines</a> 方法, 得到文件的所有行的一个惰性列表。“Lazy” 意味着它只会从磁盘中按需读取新行, 当我们使用 <a href="https://docs.raku.org/routine/map">.map</a> 方法遍历列表元素的时候, 这样能使用单个赋值操作就能优雅地初始化一个散列。</p>
<p>我们不需要让文件句柄识别 Unicode, 也不用管文件句柄是否正确关闭, 这在 Raku 中都是默认发生的。</p>
<p><code>method: ...</code> 语法也可以写为 <code>.method(...)</code>, 前者使 map 看起来更像一个 block 语句, 并减少了括号凌乱。
<code>:s</code>(&ldquo;sigspace&rdquo;) 正则修饰符使解析 token 间的空白更优雅。但 Raku 中的字符类比 Perl 5 复杂了一丢丢。
正则捕获结果变量(<code>$0</code>, <code>$1</code>, …) 返回一个完整的 <a href="https://docs.raku.org/type/Match">Match</a> 对象 - 它为复杂使用场景增加了很多灵活性, 但是这里我们只想保留字符串, 所以使用 <a href="https://docs.raku.org/routine/~">~</a> 前置操作符字符串化了匹配对象。</p>
<p>查看数据的特定项:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Zsófia&#39;s grade: </span><span class="nv">%grade</span><span class="p">&lt;</span><span class="s">Zsófia</span><span class="p">&gt;&#34;;</span>
</code></pre></div><p>Raku 总是把散列中 <code>{ }</code> 中的东西解析为表达式, 使用 <code>&lt; &gt;</code> 表示字面值。</p>
<p>过滤数据:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">List of students with a failing grade:</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">  </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">%grade</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*.</span><span class="nb">value</span> <span class="ow">ge</span> <span class="p">&#34;</span><span class="s2">E</span><span class="p">&#34;)</span><span class="o">».</span><span class="nb">key</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">, </span><span class="p">&#34;);</span>
</code></pre></div><p>Raku 中允许我们按执行顺序把一些列方法写为链式操作。有一个重要区别：Raku 能让我们直接遍历散列的项, 散列中每一项都是一个 <a href="https://docs.raku.org/type/Pair">Pair</a> 对象(Pair 对象能使用 <a href="https://docs.raku.org/type/Pair#method_key">.key</a> 和 <a href="https://docs.raku.org/type/Pair#method_value">.value</a> 方法)。</p>
<p><code>*</code> <a href="https://docs.raku.org/type/Whatever">Whatever</a> star 用于定义一个简单的回调, 而不用写一个花括号块。
<code>».</code> <a href="https://docs.raku.org/language/operators#index-entry-hyper_%3C%3C-hyper_%3E%3E-hyper_%C2%AB-hyper_%C2%BB-Hyper_operators">hyper operator</a> 用于对 <a href="https://docs.raku.org/routine/grep">.grep</a> 返回的 Pairs 的每个 Pair 上调用 一次 .key 方法, 得出姓名列表</p>
<p>从数据中创建频率分布:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Distribution of grades by letter:</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;{</span><span class="o">.</span><span class="nb">key</span><span class="p">}</span><span class="s2">: </span><span class="p">{</span><span class="o">+.</span><span class="nb">value</span><span class="p">}</span><span class="s2"> student</span><span class="p">{&#34;</span><span class="s2">s</span><span class="p">&#34;</span> <span class="k">if</span> <span class="o">.</span><span class="nb">value</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">}&#34;</span>

<span class="k">for</span> <span class="nv">%grade</span><span class="o">.</span><span class="nb">classify</span><span class="p">(</span><span class="o">*.</span><span class="nb">value</span><span class="o">.</span><span class="nb">comb</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">*.</span><span class="nb">key</span><span class="p">);</span>
</code></pre></div><p>计数和分组实在太常见了, Raku 提供了 <a href="https://docs.raku.org/routine/classify">.classify</a> 方法。
classify 方法里需要指定要分组的项(这里是代表 <code>%grade</code> 条目的 Pair 对象), 这些项应该根据什么规则进行分组(这里是根据第一个字母的值, 它代表分数(没有 <code>+</code>/<code>-</code>)。</p>
<p>这生成一个匿名的散列, 散列的值是匿名数组。</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">%(&#34;B&#34; =&gt; [&#34;Peter&#34; =&gt; &#34;B&#34;, &#34;Zsófia&#34; =&gt; &#34;B+&#34;, &#34;Maryam&#34; =&gt; &#34;B+&#34;,
 &#34;秀英&#34; =&gt; &#34;B-&#34;, &#34;Omar&#34; =&gt; &#34;B&#34;], &#34;A&#34; =&gt; [&#34;Celine&#34; =&gt; &#34;A-&#34;, &#34;Aarav&#34; =&gt; &#34;A&#34;], &#34;F&#34; =&gt; [&#34;João&#34; =&gt; &#34;F&#34;, &#34;Emma&#34; =&gt; &#34;F&#34;], &#34;D&#34; =&gt; [&#34;Finn&#34; =&gt; &#34;D+&#34;])
</code></pre></div><p>因为我们只对每组元素的个数感兴趣, 我们使用 <a href="https://docs.raku.org/routine/+">+</a> 前置操作符数字化每个值然后打印它, 在数组前面添加 <code>+</code> 符号会得到数组元素的个数。</p>
<p>在 term 位置上一个单独的 <code>.method</code> 方法等价于 <code>$_.method</code>, 意思是对当前循环变量调用该方法。任意代码的返回值能使用花括号 <code>{}</code> 插值到字符串中。</p>
<p><code>if</code> 语句能被用作表达式 - 当条件为 false 时, 返回空列表, 然后被字符串化为空字符串。对字符串调用不带参数的 <a href="https://docs.raku.org/routine/comb">.comb</a> 会生成该字符串的一个字符列表。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/calendar" term="calendar" label="calendar" />
                            
                        
                    
                
            
        </entry>
    
</feed>
