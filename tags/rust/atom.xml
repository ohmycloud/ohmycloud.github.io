<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.79.0">Hugo</generator><title type="html"><![CDATA[Rust on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/rust/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/rust/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/rust/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/rust/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2021-04-05T19:55:25+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/rust/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Call Site Dependency Injection]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="related" type="text/html" title="For the Love of Macros" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Std Error in Rust" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/?utm_source=atom_feed" rel="related" type="text/html" title="Two Beautiful Rust Programs" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-20-pest-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Pest Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-19-parser-api-example-ini/?utm_source=atom_feed" rel="related" type="text/html" title="Parser API - 解析 INI" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-05T00:00:00+08:00</published>
            <updated>2021-04-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Call Site Dependency Injection</blockquote><p>本帖文档调用站点依赖注入模式。这是一个相当低级的样本，和企业 DI 没有什么关系。这个模式有点 Rust 特有。</p>
<p>通常，当你实现一个需要用户提供一些功能的类型时，首先想到的是在构造函数中提供它。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Engine</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">config</span>: <span class="nc">Config</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Engine</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">config</span>: <span class="nc">Config</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Engine</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">go</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在这个例子中，我们实现了 Engine，调用者提供了 Config。</p>
<p>另一种方法是将依赖关系传递给每个方法调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Engine</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Engine</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Engine</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">go</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">config</span>: <span class="kp">&amp;</span><span class="nc">Config</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在 Rust 中，后者(call-site injection)有时用 lifetime 更好。让我们来看看这些例子吧!</p>
<h2 id="lazy-字段">Lazy 字段</h2>
<p>在第一个例子中，我们想根据其他字段惰性地计算一个字段的值。就像这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Widget</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">name_hash</span>: <span class="nc">Lazy</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Widget</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">name</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Widget</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Widget</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">name</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">name_hash</span>: <span class="nc">Lazy</span>::<span class="n">new</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">compute_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">}),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个设计的问题是在 Rust 中无法使用。Lazy 中的闭包需要访问 <strong>self</strong>，而这将创建一个自引用的数据结构!</p>
<p>解决的办法是在使用 Lazy 的地方提供闭包。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Widget</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">name_hash</span>: <span class="nc">OnceCell</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Widget</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">name</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Widget</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Widget</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">name</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">name_hash</span>: <span class="nc">OnceCell</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">name_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u64</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">name_hash</span><span class="p">.</span><span class="n">get_or_init</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">compute_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="间接哈希表">间接哈希表</h2>
<p>下一个例子是关于将一个自定义的哈希函数插入到哈希表中。在 Rust 的标准库中，这只能在类型级别上实现，通过实现类型的 Hash 特性。更通用的设计是在运行时用哈希函数给表做参数。这是 <code>C++</code> 所做的。然而在 Rust 中，这就不够通用了。</p>
<p>考虑一个字符串互译器，它将字符串存储在一个向量中，并额外维护一个基于哈希的索引。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Interner</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">set</span>: <span class="nc">HashSet</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Interner</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">intern</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">i</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><strong>set</strong> 字段将字符串存储在一个哈希表中，但它是用相邻 <strong>vec</strong> 的索引来表示它们。</p>
<p>用一个闭包来构造 <strong>set</strong> 不会成功，原因和 Lazy 一样 - 这将创建一个自引用结构。在 <code>C++</code> 中，存在一个变通的方法 - 可以将 <strong>vec</strong> 装箱，并在 <strong>Interner</strong> 和闭包之间共享一个稳定的指针。在 Rust 中，这会产生别名，阻止使用 <strong>&amp;mut Vec</strong>。</p>
<p>奇怪的是，在 std API 中，使用排序的 vec 而不是哈希是可行的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Interner</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="c1">// Invariant: sorted
</span><span class="c1"></span><span class="w">    </span><span class="n">set</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Interner</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">intern</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">set</span><span class="p">.</span><span class="n">binary_search_by</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">idx</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">vec</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">cmp</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">});</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">set</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span><span class="w">
</span><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">vec</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span><span class="w">
</span><span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="n">res</span><span class="p">);</span><span class="w">
</span><span class="w">                </span><span class="n">res</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">i</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这是因为闭包是在调用站点而不是在构造站点供给的。</p>
<p>hashbrown crate 通过 <a href="https://docs.rs/hashbrown/0.9.1/hashbrown/hash_map/struct.HashMap.html#method.raw_entry_mut">RawEntry</a> 为哈希提供了这种风格的 API。</p>
<h2 id="per-容器分配器">Per 容器分配器</h2>
<p>第三个例子来自 Zig 编程语言。与 Rust 不同，Zig 没有一个祝福的全局分配器。相反，Zig 中的容器有两种风味。&ldquo;Managed&rdquo; 风味接受一个分配器作为构造参数，并将其存储为一个字段（<a href="https://github.com/ziglang/zig/blob/1590ed9d6aea95e5a21e3455e8edba4cdb374f2c/lib/std/array_list.zig#L36-L43">Source</a>）。而 &ldquo;Unmanaged&rdquo; 风味则在每个方法中添加一个分配器参数（<a href="https://github.com/ziglang/zig/blob/1590ed9d6aea95e5a21e3455e8edba4cdb374f2c/lib/std/array_list.zig#L436-L440">Source</a>）。</p>
<p>第二种方式更节俭 - 可以用一个分配器引用与许多容器。</p>
<h2 id="胖指针">胖指针</h2>
<p>最后一个例子来自于 Rust 语言本身。为了实现动态调度，Rust 使用了胖指针，它有两个字宽。第一个字指向对象，第二个字指向 vtable。这些指针是在泛用具体类型的时候制造的。</p>
<p>这与 <code>C++</code> 不同，<code>C++</code> 的 vtable 指针是在构造过程中嵌入到对象本身中的。</p>
<p>看了这些例子后，我对 Scala 式的隐式参数很热衷。考虑一下这段带有 Zig 风格向量的 Rust 代码的假设。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_allocator</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">xs</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">ys</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这里的问题是 Drop - 释放向量需要访问分配器，而如何提供一个分配器并不清楚。Zig 通过使用 defer 语句而不是 destructors 躲避了这个问题。在使用隐式参数的 Rust 中，我想下面的方法可以用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">implicit</span><span class="w"> </span><span class="n">a</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Allocator</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div><p>最后，我想分享最后一个例子，CSDI 思维帮助我发现了一个更好的应用级架构。</p>
<p>rust-analyzer 的很多行为是可以配置的。有嵌套提示的切换，完成度可以调整，一些功能根据编辑器的不同而有不同的工作方式。第一个实现是将一个全局的 Config 结构和其他分析状态一起存储。然后各个子系统读取这个 Config 的位。为了避免通过这个共享结构将不同的功能耦合在一起，配置键是动态的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">type</span> <span class="nc">Config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>这个系统是可行的，但感觉相当笨拙。</p>
<p>现在的实现要简单得多。现在每个方法都接受一个特定的 config 参数，而不是将一个单一的 Config 作为状态的一部分来存储。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">get_completions</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">analysis</span>: <span class="kp">&amp;</span><span class="nc">Analysis</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">config</span>: <span class="kp">&amp;</span><span class="nc">CompletionConfig</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">file</span>: <span class="nc">FileId</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">offset</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">get_inlay_hints</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">analysis</span>: <span class="kp">&amp;</span><span class="nc">Analysis</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">config</span>: <span class="kp">&amp;</span><span class="nc">HintsConfig</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">file</span>: <span class="nc">FileId</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w">
</span></code></pre></div><p>不仅代码更简单，而且更灵活。因为配置不再是状态的一部分，所以可以根据上下文的不同，对同一功能使用不同的配置。例如，显式调用的完成和异步的完成可能是不同的。</p>
<p>在 <a href="https://old.reddit.com/r/rust/comments/kmd41e/blog_post_call_site_dependency_injection/">/r/rust</a> 上讨论。</p>
<p>原文链接: <a href="https://matklad.github.io/2020/12/28/csdi.html">https://matklad.github.io/2020/12/28/csdi.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rust" term="rust" label="Rust" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[For the Love of Macros]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Std Error in Rust" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/?utm_source=atom_feed" rel="related" type="text/html" title="Two Beautiful Rust Programs" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-20-pest-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Pest Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-19-parser-api-example-ini/?utm_source=atom_feed" rel="related" type="text/html" title="Parser API - 解析 INI" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-05T00:00:00+08:00</published>
            <updated>2021-04-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>For the Love of Macros</blockquote><p>我一直在重读 Ted Kaminski 关于软件设计的博客。我强烈推荐所有的文章，尤其是早期的文章（这是<a href="https://www.tedinski.com/2018/01/16/how-humans-write-programs.html">第一篇</a>）。他设法提供了既不平凡又合理的设计建议（当然是主观判断），这是一个难得的标本!</p>
<p>无论如何，这一系列的见解之一是，当设计一个抽象的概念时，我们总是要面对权力和属性之间的内在权衡。我们使用一个特定的抽象能表达的越多，我们对使用它的代码能说的就越少。然而，我们人类对更多表达能力的偏爱并非与生俱来。这一点在编程语言社区中很明显，用户不停地要求提供新功能，而语言设计者却说不。</p>
<p>宏是一个在 &ldquo;更强大&quot;方面走得很远的语言功能。宏给了你一种在源代码上抽象的能力。作为交换，你放弃了（自动）推理表面语法的能力。作为一个具体的<a href="https://rust-analyzer.github.io/blog/2020/03/30/macros-vs-rename.html">例子</a>，重命名重构在具有强大宏系统的语言中并不能 100% 可靠地工作。</p>
<p>我确实认为，在理想的世界里，对于一个想要扩展到巨大项目的语言来说，这是一个错误的交易。当你增加了更多的程序员、更多的年限和更多的数百万行代码时，自动推理和转换源代码的能力就会变得越来越重要。但是，请谨慎对待这一点 - 我显然是有偏见的，因为我花了几年时间开发 Rust IDE。</p>
<p>也就是说，宏有巨大的吸引力 - 它们是语言设计师的胶带。宏很少是最好的工具，但它们几乎可以完成任何工作。语言设计是渐进式的。宏系统通过为许多功能提供一个现成的穷人的替代品来缓解设计压力。</p>
<p>在这篇文章中，我想探讨一下 Rust 中宏的用途。目的是为了找到不放弃&quot;推理源代码&quot;属性的解决方案。</p>
<h2 id="字符串插值">字符串插值</h2>
<p>到目前为止，最常见的使用情况是 <code>format!</code> 系列的宏。这里的无宏解决方案很直接 - 字符串插值语法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;number&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">92</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="s">&#34;$key: ${values()}&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="s">&#34;number: 92&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>在 Rust 中，插值可能不应该直接构造一个字符串，而是可以产生一个实现 Display 的值（就像 <code>format_args!</code> 一样），这样可以避免分配。一个有趣的扩展是允许在格式字符串片段上迭代。这样一来，插值语法就可以用于 SQL 语句或命令行参数之类的东西，而不用担心引入注入漏洞。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;my dir&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="s">&#34;ls $arg&#34;</span><span class="p">.</span><span class="n">to_cmd</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="s">&#34;ls &#39;my dir&#39;&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></div><p><a href="https://julialang.org/blog/2012/03/shelling-out-sucks/">这篇</a>关于 Julia 编程语言的文章解释了这个问题。 <a href="https://github.com/matklad/xshell">xshell</a> crate 为 Rust 实现了这个想法。</p>
<h2 id="derives">Derives</h2>
<p>我认为在 Rust 中，宏的第二个最常见，也可能是最重要的用法是派生。Rust 是为数不多的能正确实现平等的语言之一（禁止比较苹果和橘子），但这关键取决于 <code>derive(Eq)</code> 的能力。这个领域常见的解决方案是编译器中的特殊 casing（Haskell 的派生）或运行时反射。</p>
<p>但我最感兴趣的解决方案是 <code>C#</code> <a href="https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/">源码生成器</a>。这并不是什么新鲜事 - 这只是老式的（源码）代码生成器，只是具有很好的实现质量。你可以提供自定义的代码，这些代码在构建过程中被运行，它可以读取现有的源码并生成额外的文件，然后再添加到编译中。</p>
<p>这个解决方案的优点在于它将所有的复杂性从语言中移出，移到了编译系统中。这意味着你可以免费获得基线工具支持。生成代码的 Goto 定义？就能用了。调试时想介入一些序列化代码？磁盘上有实际的源码，所以可以放心的去做! 你是比较喜欢用 <code>printf</code> 的人？好吧，你需要说服构建系统不要踩过你的改动，但是，否则，为什么不呢？</p>
<p>此外，源码生成器的表现力明显更强。它们可以调用到 Roslyn 编译器来分析源代码，所以它们能够生成类型导向的代码。</p>
<p>为了有用，源码生成器需要一些语言级别的支持，以便将一个实体分割到多个文件中。在 <code>C#</code> 中，部分类就扮演了这个角色。</p>
<h2 id="特定领域语言">特定领域语言</h2>
<p>宏的存在理由是嵌入式 DSL 的实现。我们希望在语言中引入自定义语法，以简洁地对程序的领域进行建模。例如，可以用宏来嵌入 Rust 代码中的 HTML 片段。</p>
<p>对我个人来说，eDSL 不是要解决的问题，只是一个问题。引入一个新的子语言（即使是小的）会花费大量的认知复杂性预算。如果你偶尔需要它，最好坚持只把有点啰嗦的函数调用链在一起。如果你经常需要它，引入外部的 DSL 是有意义的，它有一个编译器，一个语言服务器，以及所有使编程富有成效的工具。对我来说，基于宏的 DSL 只是在成本效益曲线上不落像一个有趣的点。</p>
<p>也就是说，Kotlin 编程语言很好地解决了强类型化、工具友好型 DSL 的问题（例子）。令人气愤的是，很难指出具体的解决方案是什么。就是&hellip;&hellip;主要是具体的语法。下面是一些成分。</p>
<ul>
<li>闭包的语法是 <code>{ arg -&gt; body }</code>，或者直接是 <code>{ body }</code>，所以闭包在语法上类似于块。</li>
<li>扩展方法（这只是静态方法的语法糖）。</li>
<li>Java 风格的隐式 this，它将名称引入到作用域中，而不需要显式声明。</li>
<li><a href="https://boats.gitlab.io/blog/post/the-problem-of-effects/">TCP-preserving</a> inline closures (这是唯一一个非语法特征)</li>
</ul>
<p>尽管如此，这还不足以实现 Jetpack Compose UI DSL，它还需要一个编译器插件。</p>
<h2 id="sqlx">sqlx</h2>
<p>我想调用的一个有趣的 DSL 案例是 <a href="https://docs.rs/sqlx/0.5.1/sqlx/macro.query.html">sqlx::query</a>。它允许我们写这样的代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">account</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">  </span><span class="n">sqlx</span>::<span class="n">query</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;select (1) as id, &#39;Herp Derpinson&#39; as name&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">fetch_one</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="k">await</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// anonymous struct has `#[derive(Debug)]` for convenience
</span><span class="c1"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">account</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">account</span><span class="p">.</span><span class="n">name</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>这一点我想是eDSL确实很拉风的几个案例之一。没有宏的情况下，我不知道该怎么做。使用字符串插值（高级版本，以保护不被注入），可以指定查询。使用源码生成器，可以检查查询的语法和类型，例如，在这种情况下，会出现类型错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">  </span><span class="n">query</span><span class="p">(</span><span class="s">&#34;select (1) as id, &#39;Herp Derpinson&#39; as name&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">fetch_one</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="k">await</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>但这还不足以生成一个匿名结构体，也不足以摆脱动态 casts。</p>
<h2 id="有条件编译">有条件编译</h2>
<p>Rust 还使用宏进行条件编译。这个用例令人信服地展示了&quot;缺乏属性&quot;方面的能力。处理特征组合是 Cargo 永远头痛的问题。当特征标志改变时，用户不得不反复重新编译大块的装箱图。在 CI 上用 <code>Cargo test --no-default-features</code> 捕捉类型错误是非常恼人的，尤其是当你在提交 PR 之前确实运行了 <code>Cargo test</code>。&ldquo;添加特性&quot;是一个无法选中的一厢情愿。</p>
<p>在这种情况下，我不知道有什么好的无宏选择。但是，原则上，这似乎是可行的，如果将条件编译进一步推到编译器流水线的下游，推到代码生成和链接阶段。编译器可以在为一个函数生成机器代码之前，选择特定平台的版本，而不是在解析过程中提前丢弃一些代码。在此之前，它会检查该函数的所有条件编译版本是否具有相同的接口。这样一来，平台特定的类型错误就不可能出现了。</p>
<h2 id="占位符语法">占位符语法</h2>
<p>最后一个我想介绍的用例是占位符语法。Rust 的 <code>macro_call!(...)</code> 语法开辟了一个很好的隔离区域，只要小括号是平衡的，任何东西都可以用。理论上，这允许语言设计者在确定某些东西之前先试验临时语法。在实践中，这看起来好像并没有什么好处？有人反对稳定 <code>postfix .await</code>，而不通过中间期与 <code>await!</code> 宏来稳定。而且，稳定之后，所有的语法讨论都立即被遗忘了？另一方面，我们确实有 <code>try! -&gt; ?</code> 转变，但我不认为它有助于发现任何设计上的缺陷？至少，我们成功地稳定了那个<a href="https://internals.rust-lang.org/t/can-try-and-use-the-into-trait-instead-of-from/6714">不必要的限制性</a>去语法糖。</p>
<p>对于结论，我想绕回源码生成器。究竟是什么让它们比宏更容易被工具化？我认为有以下三个特性。第一，无论是输入还是输出，从根本上说，都是文本。没有中间的表示方式（比如 token 树），而这个元程序设施使用的是中间的表示方式。这意味着，它不需要与编译器深度集成。当然，在内部，该工具可以自由地对代码进行任意解析、类型检查和转换。其次，有一个阶段性的区分。源码生成器是一次执行，无序的。在元编程和名称解析之间没有来回，这又可以将&quot;元&quot;的部分保留在外面。第三，源码生成器只能添加代码，不能改变现有代码的含义。这意味着，在代码生成器的存在下，语义上合理的源码转换依然如此。</p>
<p>就这样吧! 在 <a href="https://old.reddit.com/r/rust/comments/ljnkwg/blog_post_for_the_love_of_macros/">/r/rust</a> 上讨论。</p>
<p>原文链接: <a href="https://matklad.github.io/2021/02/14/for-the-love-of-macros.html">https://matklad.github.io/2021/02/14/for-the-love-of-macros.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Std Error in Rust]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="related" type="text/html" title="For the Love of Macros" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/?utm_source=atom_feed" rel="related" type="text/html" title="Two Beautiful Rust Programs" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-20-pest-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Pest Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-19-parser-api-example-ini/?utm_source=atom_feed" rel="related" type="text/html" title="Parser API - 解析 INI" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-05T00:00:00+08:00</published>
            <updated>2021-04-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Std Error in Rust</blockquote><h1 id="学习-stdioerror">学习 std::io::Error</h1>
<p>在这篇文章中，我们将剖析 Rust 标准库中 std::io::Error 类型的实现。相关代码在这里：<code>library/std/src/io/error.rs</code>。</p>
<p>你可以把这篇文章看成是其中之一。</p>
<ul>
<li>一个标准库的特定位的研究</li>
<li>一个高级错误管理指南</li>
<li>一个漂亮的 API 设计案例</li>
</ul>
<p>文章要求基本熟悉 Rust 错误处理。</p>
<p>在设计一个用于 <code>Result&lt;T，E&gt;</code> 的 Error 类型时，主要的问题是&quot;如何使用这个错误？&quot;。通常，以下情况之一为真。</p>
<ul>
<li>错误被程序化处理。消费者检查错误，所以它的内部结构需要在合理的程度上暴露出来。</li>
<li>错误被传播并显示给用户。消费者不检查 <code>fmt::Display</code> 之外的错误；所以它的内部结构可以被封装。</li>
</ul>
<p>请注意，暴露实现细节和封装细节之间存在紧张关系。实现第一种情况的常见反模式是定义一个厨房水槽枚举。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">Tokio</span><span class="p">(</span><span class="n">tokio</span>::<span class="n">io</span>::<span class="n">Error</span><span class="p">),</span><span class="w">
</span><span class="w">  </span><span class="n">ConnectionDiscovery</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">path</span>: <span class="nc">PathBuf</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">reason</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">stderr</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">},</span><span class="w">
</span><span class="w">  </span><span class="n">Deserialize</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">source</span>: <span class="nc">serde_json</span>::<span class="n">Error</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">data</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">},</span><span class="w">
</span><span class="w">  </span><span class="p">...,</span><span class="w">
</span><span class="w">  </span><span class="n">Generic</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这种方法有很多问题。</p>
<p>首先，从底层库中暴露错误会使它们成为你的公共 API 的一部分。在你的依赖关系中的主要 semver bump 会要求你也做一个新的主要版本。</p>
<p>其次，它将所有的实现细节都固定下来。例如，如果你注意到 ConnectionDiscovery 的大小是巨大的，那么将这个变体装箱将是一个突破性的变化。</p>
<p>第三，它通常表明了一个更大的设计问题。厨房水槽错误将不同的故障模式打包成一种类型。但是，如果故障模式差异很大，处理起来可能就不合理了! 这说明情况看起来更像案例二。</p>
<p>错误厨房水槽病的一个经常有效的治疗方法是将错误推送给调用者的模式。</p>
<p>考虑这个例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">my_function</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">MyError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dep_function</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">  </span><span class="p">...</span><span class="w">
</span><span class="w">  </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">92</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>my_function</code> 调用 <code>dep_function</code>，所以 <code>MyError</code> 应该可以从 <code>DepError</code> 转换过来。更好的写法可能是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">my_function</span><span class="p">(</span><span class="n">thing</span>: <span class="nc">DepThing</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">MyError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="p">...</span><span class="w">
</span><span class="w">  </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">92</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在这个版本中，调用者被迫调用 <code>dep_function</code> 并处理其错误。这就用更多的类型交换了更多的类型安全。<code>MyError</code> 和 <code>DepError</code> 现在是不同的类型，调用者可以分别处理它们。如果 <code>DepError</code> 是 <code>MyError</code> 的变体，那么就需要进行运行时匹配。</p>
<p>这个想法的一个极端版本是 <code>sans-io</code> 编程。大多数错误来自于 IO；如果你把所有的 IO 推给调用者，你就可以跳过大部分的错误处理。</p>
<p>无论枚举方法多么糟糕，它确实实现了第一种情况的最大可检查性。</p>
<p>以传播为中心的第二种情况下的错误管理，通常是通过使用盒状特质对象来处理。像 <code>Box&lt;dyn std::error::Error&gt;</code> 这样的类型可以从任何具体的错误中构造出来，可以通过 <code>Display</code> 打印出来，并且仍然可以选择通过动态下传来暴露底层错误。<code>Anyhow</code> crate 就是这种风格的一个很好的例子。</p>
<p><code>std::io::Error</code> 的例子很有趣，因为它想同时具备上述两种风格。</p>
<ul>
<li>这是 std，所以封装和面向未来是最重要的。</li>
<li>来自操作系统的 IO 错误往往可以被处理（比如 EWOULDBLOCK）。</li>
<li>对于系统编程语言来说，准确地暴露底层 OS 错误是很重要的。</li>
<li>未来潜在的操作系统错误集是没有限制的。</li>
<li><code>io::Error</code> 也是一种词汇类型，应该可以表示一些不完全的 os 错误。例如，Rust Paths 可以包含内部的0字节，打开这样的路径应该在进行 <code>syscall</code> 之前返回一个 <code>io::Error</code>。</li>
</ul>
<p>下面是 <code>std::io::Error</code> 的样子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">repr</span>: <span class="nc">Repr</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">Os</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span><span class="w">
</span><span class="w">  </span><span class="n">Simple</span><span class="p">(</span><span class="n">ErrorKind</span><span class="p">),</span><span class="w">
</span><span class="w">  </span><span class="n">Custom</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Custom</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Custom</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">kind</span>: <span class="nc">ErrorKind</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">error</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>首先要注意的是，它内部是一个枚举，但这是一个隐藏得很好的实现细节。为了允许检查和处理各种错误条件，有一个单独的公共无字段种类枚举。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Clone, Copy)]</span><span class="w">
</span><span class="w"></span><span class="cp">#[non_exhaustive]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">ErrorKind</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">NotFound</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">PermissionDenied</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">Interrupted</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">...</span><span class="w">
</span><span class="w">  </span><span class="n">Other</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">kind</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ErrorKind</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">sys</span>::<span class="n">decode_error_kind</span><span class="p">(</span><span class="o">*</span><span class="n">code</span><span class="p">),</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">kind</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">kind</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>虽然 ErrorKind 和 Repr 都是枚举，但公开暴露 ErrorKind 就没那么可怕了。一个 <code>#[non_exhaustive]Copy</code> 无字段枚举的设计空间是一个点 - 没有合理的替代方案或兼容性隐患。</p>
<p>有些 <code>io::Errors</code> 只是原始的操作系统错误代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">from_raw_os_error</span><span class="p">(</span><span class="n">code</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">repr</span>: <span class="nc">Repr</span>::<span class="n">Os</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">raw_os_error</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>特定平台的 <code>sys::decode_error_kind</code> 函数负责将错误代码映射到 <code>ErrorKind</code> 枚举。所有这些都意味着代码可以通过检查 <code>.kind()</code> 来跨平台处理错误类别。然而，如果需要以一种依赖于操作系统的方式处理一个非常特殊的错误代码，这也是可能的。API 小心翼翼地提供了一个方便的抽象，而没有抽象掉重要的低级细节。</p>
<p>一个 <code>std::io::Error</code> 也可以从一个 <code>ErrorKind</code> 中构造出来。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">ErrorKind</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">kind</span>: <span class="nc">ErrorKind</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">repr</span>: <span class="nc">Repr</span>::<span class="n">Simple</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这提供了跨平台访问错误代码风格的错误处理。如果你需要尽可能快的错误，这很方便。</p>
<p>最后，还有第三种完全自定义的变体表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kind</span>: <span class="nc">ErrorKind</span><span class="p">,</span><span class="w"> </span><span class="n">error</span>: <span class="nc">E</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Error</span><span class="w">
</span><span class="w">  </span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">E</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Self</span>::<span class="n">_new</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">.</span><span class="n">into</span><span class="p">())</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="k">fn</span> <span class="nf">_new</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">kind</span>: <span class="nc">ErrorKind</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">error</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">repr</span>: <span class="nc">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Custom</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">kind</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="p">})),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_ref</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">c</span><span class="p">.</span><span class="n">error</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">into_inner</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="bp">self</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">error</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>需要注意的地方。</p>
<ul>
<li>
<p>通用的 <code>new</code> 函数委托给单态的 <code>_new</code> 函数。这改善了编译时间，因为在单态化过程中需要重复的代码更少。我认为这也改善了一些运行时：<code>_new</code> 函数没有被标记为内联，所以会在调用处产生一个函数调用。这是好的，因为错误构造是冷路径，节省指令缓存是受欢迎的。</p>
</li>
<li>
<p>自定义变体被框住了 - 这是为了让整体 <code>size_of</code> 更小。错误的 <code>on-the-stack</code> 大小是很重要的：即使没有错误，你也要为此付出代价!</p>
</li>
</ul>
<p>这两种类型都是指&quot;静态错误&quot;。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">type</span> <span class="nc">A</span><span class="w"> </span><span class="o">=</span><span class="w">   </span><span class="o">&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div><p>在 <code>dyn Trait + '_</code> 中，<code>'_</code> 被省略为 <code>'static</code>，除非 trait 对象是在引用后面，在这种情况下，它被省略为 <code>&amp;'a dyn Trait + 'a</code>。</p>
<p><code>get_ref</code>, <code>get_mut</code> 和 <code>into_inner</code> 提供了对底层错误的完全访问。类似于 <code>os_error</code> 的情况，抽象模糊了细节，但也提供了钩子来获取底层数据的原样。</p>
<p>同样，Display 的实现揭示了内部表示的最重要细节。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">detail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys</span>::<span class="n">os</span>::<span class="n">error_string</span><span class="p">(</span><span class="o">*</span><span class="n">code</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{} (os error {})&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">detail</span><span class="p">,</span><span class="w"> </span><span class="n">code</span><span class="p">)</span><span class="w">
</span><span class="w">      </span><span class="p">}</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">kind</span><span class="p">.</span><span class="n">as_str</span><span class="p">()),</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="n">fmt</span><span class="p">(</span><span class="n">fmt</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>综上所述，std::io::Error:</p>
<ul>
<li>封装了它的内部表现形式，并通过框定大的枚举变体来优化它。</li>
<li>通过 <code>ErrorKind</code> 模式提供了一种方便的方法来处理基于类别的错误。</li>
<li>完全暴露底层操作系统的错误（如果有的话）。</li>
</ul>
<p>可以透明地包裹任何其他错误类型。</p>
<p>最后一点意味着 <code>io::Error</code> 可以用于临时错误，因为 <code>&amp;str</code> 和 String 可以转换为 <code>Box&lt;dyn std::error::Error&gt;</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">io</span>::<span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">Other</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;something went wrong&#34;</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>它也可以作为 anyhow 的简单替换。我想一些库可能会用这个来简化他们的错误处理。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">io</span>::<span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">InvalidData</span><span class="p">,</span><span class="w"> </span><span class="n">my_specific_error</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>例如，<code>serde_json</code> 提供了以下方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">from_reader</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rdr</span>: <span class="nc">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">serde_json</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">  </span><span class="n">R</span>: <span class="nc">Read</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">T</span>: <span class="nc">DeserializeOwned</span><span class="p">,</span><span class="w">
</span></code></pre></div><p>读取会因为 <code>io::Error</code> 而失败，所以 <code>serde_json::Error</code> 需要能够在内部表示 <code>io::Error</code>。我认为这是倒退的 (但我不知道整个上下文，如果被证明是错的我会很高兴！)，签名应该是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">from_reader</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rdr</span>: <span class="nc">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">  </span><span class="n">R</span>: <span class="nc">Read</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">T</span>: <span class="nc">DeserializeOwned</span><span class="p">,</span><span class="w">
</span></code></pre></div><p>那么，<code>serde_json::Error</code> 就不会有 <code>Io</code> 的变体，而会以 <code>InvalidData</code> 的形式被藏到 <code>io::Error</code> 中。
补遗, 2021-01-25</p>
<p>重新阅读这篇文章，我现在认为正确的返回类型应该是：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">from_reader</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span><span class="w">  </span><span class="n">rdr</span>: <span class="nc">R</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">serde_json</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">  </span><span class="n">R</span>: <span class="nc">Read</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">T</span>: <span class="nc">DeserializeOwned</span><span class="p">,</span><span class="w">
</span></code></pre></div><p>这迫使 IO 和反序列化错误分开处理，这在这种情况下是有意义的。IO 错误可能是程序领域之外的硬件/环境问题，而序列化错误很可能是系统中的某个错误。</p>
<p>我认为 <code>std::io::Error</code> 是一个非常了不起的类型，它能够在没有太多妥协的情况下为许多不同的用例服务。但我们是否可以做得更好呢？</p>
<p><code>std::io::Error</code> 的首要问题是，当一个文件系统操作失败时，你不知道它是为哪个路径失败的。这是可以理解的 - Rust 是一种系统语言，所以它不应该比 OS 原生提供的东西增加多少脂肪。OS 返回的是一个整数返回代码，而将其与一个堆分配的 <code>PathBuf</code> 耦合在一起，可能是一个不可接受的开销!</p>
<p>我很惊讶地得知，事实上，<code>std</code> 对每一个与路径相关的系统调用都会进行分配。</p>
<p>它需要以某种形式存在。<code>OS API</code> 需要在字符串的结尾有一个不幸的零字节. 但我想知道对短路径使用堆栈分配的缓冲区是否有意义。可能不会 - 路径通常不会那么短，而且现代分配器能有效地处理瞬时分配。</p>
<p>我不知道这里有什么明显的好办法。一个选择是在编译时（一旦我们得到 <code>std-aware cargo</code>）或运行时（<code>a-la RUST_BACKTRACE</code>）添加开关，以堆分配所有与路径相关的 IO 错误。一个类似形的问题是 <code>io::Error</code> 不携带 backtrace。</p>
<p>另一个问题是，<code>std::io::Error</code> 的效率不高。</p>
<p>它的体积是相当大的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span></code></pre></div><p>对于自定义的情况，会产生双重的间接和分配。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="k">enum</span> <span class="nc">Repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Os</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span><span class="w">
</span><span class="w">      </span><span class="n">Simple</span><span class="p">(</span><span class="n">ErrorKind</span><span class="p">),</span><span class="w">
</span><span class="w">      </span><span class="c1">// First Box :|
</span><span class="c1"></span><span class="w">      </span><span class="n">Custom</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Custom</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">struct</span> <span class="nc">Custom</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">kind</span>: <span class="nc">ErrorKind</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="c1">// Second Box :(
</span><span class="c1"></span><span class="w">      </span><span class="n">error</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我想我们现在可以解决这个问题了</p>
<p>首先，我们可以通过使用一个瘦的特质对象来摆脱双重内向性，比如失败或 anyhow。现在 GlobalAlloc 已经存在，这是一个比较直接的实现。</p>
<p>其次，我们可以利用指针是对齐的这一事实，将 Os 和 Simple 变体都用最小的有效位集储藏到 usize 中。我认为我们甚至可以发挥创意，使用第二个最小有意义的位，把第一个位留作小众。这样一来，即使是像 <code>io::Result&lt;i32&gt;</code> 这样的东西，也可以是指针大小的!</p>
<p>本篇文章到此结束。下一次你要为你的库设计一个错误类型的时候，花点时间去看看 <code>std::io::Error</code> 的源头，你可能会发现一些值得偷的东西。</p>
<p>讨论在 /r/rust.Net 上进行。</p>
<h2 id="额外的谜题">额外的谜题</h2>
<p>看看实现中的这一行。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">detail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys</span>::<span class="n">os</span>::<span class="n">error_string</span><span class="p">(</span><span class="o">*</span><span class="n">code</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{} (os error {})&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">detail</span><span class="p">,</span><span class="w"> </span><span class="n">code</span><span class="p">)</span><span class="w">
</span><span class="w">      </span><span class="p">}</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">kind</span><span class="p">.</span><span class="n">as_str</span><span class="p">()),</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="n">fmt</span><span class="p">(</span><span class="n">fmt</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>原文链接: <a href="https://matklad.github.io/2020/10/15/study-of-std-io-error.html">https://matklad.github.io/2020/10/15/study-of-std-io-error.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Two Beautiful Rust Programs]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="related" type="text/html" title="For the Love of Macros" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Std Error in Rust" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-20-pest-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Pest Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-19-parser-api-example-ini/?utm_source=atom_feed" rel="related" type="text/html" title="Parser API - 解析 INI" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-05T00:00:00+08:00</published>
            <updated>2021-04-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Two Beautiful Rust Programs</blockquote><h1 id="two-beautiful-rust-programs">Two Beautiful Rust Programs</h1>
<p>这是一则 Rust 编程语言的短广告，目标是有经验的 <code>C++</code> 开发者。作为一则广告，它只能吊起你的胃口，具体内容请参考其他资源。</p>
<p>第一个程序:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="kp">&amp;</span><span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span><span class="w">  </span><span class="n">xs</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">92</span><span class="p">);</span><span class="w">
</span><span class="w">  </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个程序创建了一个 32 位整数的向量(<code>std::vector&lt;int32_t&gt;</code>)，接收第一个元素 <code>x</code> 的引用，再向向量推送一个数字，然后使用 <code>x</code>。这个程序是错误的：扩展向量可能会使对元素的引用无效，而且 <code>*x</code> 可能会取消引用一个 danging 指针。</p>
<p>这个程序的好处是它不会被编译。</p>
<pre><code>error[E0502]: cannot borrow xs as mutable
    because it is also borrowed as immutable
 --&gt; src/main.rs:4:5

     let x: &amp;i32 = &amp;xs[0];
                    -- immutable borrow occurs here
     xs.push(92);
     ^^^^^^^^^^^ mutable borrow occurs here
     println!(x);
              - immutable borrow later used here
</code></pre><p>Rust 编译器跟踪每块数据的别名状态，并禁止潜在的别名数据的突变。在这个例子中，<code>x</code> 和 <code>xs</code> 别名了向量在堆中存储的第一个整数。</p>
<p>Rust 不允许做傻事。</p>
<p>第二个程序:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">crossbeam</span>::<span class="n">scope</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">parking_lot</span>::<span class="p">{</span><span class="n">Mutex</span><span class="p">,</span><span class="w"> </span><span class="n">MutexGuard</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="n">scope</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">s</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">          </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">guard</span>: <span class="nc">MutexGuard</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span><span class="w">
</span><span class="w">          </span><span class="o">*</span><span class="n">guard</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">      </span><span class="p">});</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">total</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="p">.</span><span class="n">get_mut</span><span class="p">();</span><span class="w">
</span><span class="w">  </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;total = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">total</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个程序创建一个由 mutex 保护的整数计数器，生成10个线程，从每个线程开始将计数器递增10次，并打印出总数。</p>
<p>计数器变量位于堆栈中，这些堆栈数据的指针与其他线程共享。线程必须锁定 mutex 才能进行增量。打印总数时，绕过 mutex 读取计数器，没有任何同步。</p>
<p>这个程序的妙处在于，它的正确性依赖于几位精妙的推理，每一个推理都会被编译器检查。</p>
<p>子线程不会逃离主函数 所以可以从它的堆栈中读取计数器</p>
<p>子线程只通过 mutex 访问 counter。</p>
<p>子线程将在我们从计数器中读出总数而不使用 mutex 时终止。</p>
<p>如果这些约束中的任何一个被破坏，编译器就会拒绝该代码。没有必要使用 <code>std::shared_ptr</code> 只是为了防御性地确保内存不会在你的脚下被释放。</p>
<p>Rust 允许做危险的、聪明的、快速的事情，而不用担心引入未定义的行为。</p>
<p>如果你喜欢你所看到的，这里有两本我推荐的书，可以让你更深入地了解 Rust。</p>
<p>原文链接: <a href="https://matklad.github.io/2020/07/15/two-beautiful-programs.html">https://matklad.github.io/2020/07/15/two-beautiful-programs.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Pest Grammars]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-01-20-pest-grammars/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-01-19-parser-api-example-ini/?utm_source=atom_feed" rel="related" type="text/html" title="Parser API - 解析 INI" />
            
                <id>https://ohmyweekly.github.io/notes/2021-01-20-pest-grammars/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-01-20T00:00:00+08:00</published>
            <updated>2021-01-20T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Pest Grammars</blockquote><h1 id="grammar">Grammar</h1>
<p>与许多解析工具一样，<code>pest</code> 使用与 Rust 代码不同的正式 grammar 进行操作。<code>pest</code> 使用的格式称为解析表达式 grammar，或 PEG。当构建一个项目时，<code>pest</code> 会自动将位于单独文件中的 PEG 编译成您可以调用的普通 Rust 函数。</p>
<h2 id="如何激活-pest">如何激活 <code>pest</code></h2>
<p>大多数项目至少会有两个使用 <code>pest</code> 的文件：解析器 (比如 <code>src/parser/mod.rs</code>) 和 grammar (<code>src/parser/grammar.pest</code>)。假设它们在同一个目录下。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">pest</span>::<span class="n">Parser</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Parser)]</span><span class="w">
</span><span class="w"></span><span class="cp">#[grammar = </span><span class="s">&#34;parser/grammar.pest&#34;</span><span class="cp">]</span><span class="w"> </span><span class="c1">// relative to project `src`
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">MyParser</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>每当你编译这个文件时，<code>pest</code> 会自动使用 grammar 文件生成这样的项。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Rules</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Parser</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyParser</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">Rules</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">pest</span>::<span class="n">Pairs</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>你永远不会看到 <code>enum Rules</code> 或 <code>impl Parser</code> 的纯文本。这些代码只存在于编译过程中。然而，您可以像使用其他枚举一样使用 <code>Rules</code>，并且您可以通过 <a href="https://pest.rs/book/parser_api.html">Parser API 章节</a>中描述的 <code>Pairs</code> 接口使用 <code>parse(...)</code>。</p>
<h2 id="关于-pegs-的警告">关于 PEGs 的警告!</h2>
<p>解析表达式 grammar 看起来和你可能习惯的其他解析工具很相似，比如正则表达式、BNF grammar 和其他工具（Yacc/Bison、LALR、CFG）。然而，PEGs 的行为却有微妙的不同。PEGs 是<a href="https://pest.rs/book/grammars/peg.html#eagerness">急切的</a>、<a href="https://pest.rs/book/grammars/peg.html#non-backtracking">非回溯的</a>、<a href="https://pest.rs/book/grammars/peg.html#ordered-choice">有序的</a>、<a href="https://pest.rs/book/grammars/peg.html#unambiguous">不含糊的</a>。</p>
<p>如果你不认识以上任何一个名字，不要害怕! 你已经比认识的人快了一步 - 当你使用 <code>pest</code> 的 PEGs 时，你不会被与其他工具的比较所绊倒。</p>
<p>如果你之前使用过其他解析工具，一定要仔细阅读下一节。我们会提到一些关于 PEGs 的常见错误。</p>
<h2 id="解析表达式语法">解析表达式语法</h2>
<p>解析表达式语法(PEG)只是严格地表示了如果你用手写一个解析器会写的简单的命令式代码。</p>
<pre><code>number = {            // To recognize a number...
    ASCII_DIGIT+      //   take as many ASCII digits as possible (at least one).
}
expression = {        // To recognize an expression...
    number            //   first try to take a number...
    | &quot;true&quot;          //   or, if that fails, the string &quot;true&quot;.
}
</code></pre><p>事实上，pest 产生的代码与上面注释中的伪代码十分相似。</p>
<h3 id="eagerness">Eagerness</h3>
<p>当在输入字符串上运行<a href="https://pest.rs/book/grammars/syntax.html#repetition">重复的</a> PEG 表达式时。</p>
<pre><code>ASCII_DIGIT+      // one or more characters from '0' to '9'
</code></pre><p>它尽可能多地运行该表达式（&ldquo;急切地&quot;或 &ldquo;贪婪地&quot;匹配）。它要么成功，消耗它所匹配的任何内容，并将剩余的输入传递到解析器的下一步。</p>
<pre><code>&quot;42 boxes&quot;
 ^ Running ASCII_DIGIT+

&quot;42 boxes&quot;
   ^ Successfully took one or more digits!

&quot; boxes&quot;
 ^ Remaining unparsed input.
</code></pre><p>或失败，什么也不消耗。</p>
<pre><code>&quot;galumphing&quot;
 ^ Running ASCII_DIGIT+
   Failed to take one or more digits!

&quot;galumphing&quot;
 ^ Remaining unparsed input (everything).
</code></pre><p>如果一个表达式未能匹配，那么这个失败就会向上传播，最终导致解析失败，除非这个失败在 grammar 中的某个地方被&quot;抓住&rdquo;。选择操作符是&quot;捕获&quot;这种失败的一种方法。</p>
<h3 id="有序选择">有序选择</h3>
<p><a href="https://pest.rs/book/grammars/syntax.html#ordered-choice">选择操作符</a>，写成一条竖线 <code>|</code>，是有序的。PEG 表达式 <code>first | second</code> 的意思是 &ldquo;先试 <code>first</code>，但如果失败了，再试 <code>second</code>&quot;。</p>
<p>在许多情况下，顺序并不重要。例如，<code>&quot;true&quot; | &quot;false&quot;</code> 将匹配字符串 <code>&quot;true&quot;</code> 或字符串 <code>&quot;false&quot;</code>（如果两者都不出现，则失败）。</p>
<p>然而，有时顺序确实很重要。考虑一下 PEG 表达式 <code>&quot;a&quot; | &quot;ab&quot;</code>。你可能期望它能匹配字符串 <code>&quot;a&quot;</code> 或字符串 <code>&quot;ab&quot;</code>。但事实并非如此 - 该表达式的意思是 &ldquo;尝试 <code>&quot;a&quot;</code>；但如果失败，则尝试 <code>&quot;ab&quot;</code>。如果你正在匹配字符串 &ldquo;abc&rdquo;，尝试 <code>&quot;a&quot;</code> 不会失败；相反，它将成功匹配 <code>&quot;a&quot;</code>，留下 <code>&quot;bc&quot;</code> 未被解析。</p>
<p>一般来说，当编写一个有选择的解析器时，把最长或最具体的选择放在前面，而把最短或最一般的选择放在最后。</p>
<h3 id="非回溯">非回溯</h3>
<p>在解析过程中，一个 PEG 表达式要么成功，要么失败。如果成功了，下一步就照常进行。但如果它失败了，整个表达式就会失败。引擎不会后退再试。</p>
<p>请看下面这个 grammar，在字符串 <code>&quot;frumious&quot;</code> 上进行匹配。</p>
<pre><code>word = {     // to recognize a word...
    ANY*     //   take any character, zero or more times...
    ~ ANY    //   followed by any character
}
</code></pre><p>你可能期望这条规则能够解析任何至少包含一个字符（相当于 <code>ANY+</code>）的输入字符串。但它不会。相反，第一个 <code>ANY*</code> 会急切地吃掉整个字符串 - 它会得偿所愿的。然后，下一个 <code>ANY</code> 将一无所有，所以它会失败。</p>
<pre><code>&quot;frumious&quot;
 ^ (word)

&quot;frumious&quot;
         ^ (ANY*) Success! Continue to `ANY` with remaining input &quot;&quot;.

&quot;&quot;
 ^ (ANY) Failure! Expected one character, but found end of string.
</code></pre><p>在有回溯功能的系统中（比如正则表达式），你会往后退一步，&ldquo;吐出&quot;一个字符，然后再试。但 PEG 不会这样做。在规则 <code>first~second</code> 中，一旦 <code>first</code> 解析成功，就已经消耗了一些字符，永远不会再回来，<code>second</code> 只能在 <code>first</code> 没有消耗的输入上运行。</p>
<h3 id="毫不含糊">毫不含糊</h3>
<p>这些规则构成了一个优雅而简单的系统。每个 PEG 规则都会在输入字符串的剩余部分上运行，消耗尽可能多的输入。一旦一个规则完成，剩下的输入就会被传递给解析器的其他部分。</p>
<p>例如，表达式 <code>ASCII_DIGIT+</code>，&ldquo;一个或多个数字&rdquo;，将始终匹配可能的最大的连续数字序列。不存在意外地让后面的规则回溯并以一种不直观和非局部的方式窃取一些数字的危险。</p>
<p>这与其他解析工具形成了鲜明的对比，比如正则表达式和 CFG，在这些工具中，规则的结果往往取决于一些距离的代码。事实上，LR解析器中著名的&quot;移位/还原冲突&quot;在 PEG 中并不存在问题。</p>
<h3 id="不要惊慌">不要惊慌</h3>
<p>这一切在一开始可能有点反常。但正如你所看到的，基本的逻辑是非常简单和直接的。你可以琐碎地逐步完成任何 PEG 表达式的执行。</p>
<ul>
<li>试试这个。</li>
<li>如果它成功了，就尝试下一件事。</li>
<li>否则，尝试另一件事。</li>
</ul>
<pre><code>(this ~ next_thing) | (other_thing)
</code></pre><p>这些规则结合在一起，使得 PEG 成为编写解析器的非常愉快的工具。</p>
<h2 id="pet-解析器的语法">pet 解析器的语法</h2>
<p><code>pet</code> grammar 是规则的列表。规则是这样定义的。</p>
<pre><code>my_rule = { ... }

another_rule = {        // comments are preceded by two slashes
    ...                 // whitespace goes anywhere
}
</code></pre><p>由于规则名被翻译成 Rust enum 变体，所以不允许成为 Rust 关键字。</p>
<p>定义规则的左大括号 <code>{</code> 前面可以有<a href="https://pest.rs/book/grammars/syntax.html#silent-and-atomic-rules">影响其操作</a>的符号。</p>
<pre><code>silent_rule = _{ ... }
atomic_rule = @{ ... }
</code></pre><h3 id="表达式">表达式</h3>
<p>Grammar 规则是由表达式建立起来的（因此称为&quot;解析表达式文法&rdquo;）。这些表达式是对如何解析输入字符串的简明、正式的描述。</p>
<p>表达式是可以组合的：它们可以从其他表达式中构建出来，也可以互相嵌套，以产生任意复杂的规则（尽管你应该将非常复杂的表达式分解成多个规则，以使它们更容易管理）。</p>
<p>PEG 表达式既适用于高级意义，如&quot;一个函数签名，后面是一个函数体&rdquo;，也适用于低级意义，如&quot;一个分号，后面是换行&rdquo;。组合形式&quot;后面是&rdquo;，即<a href="https://pest.rs/book/grammars/syntax.html#sequence">序列操作符</a>，在这两种情况下都是一样的。</p>
<h3 id="终端">终端</h3>
<p>最基本的规则是双引号的文字字符串。<code>&quot;text&quot;</code>。</p>
<p>如果一个字符串前面有一个逗号，那么它可以不区分大小写（仅适用于 ASCII 字符）: <code>^&quot;text&quot;</code>。</p>
<p>在一个范围内的单个字符被写成两个单引号字符，用两个点分开：<code>'0'...'9'</code>。</p>
<p>你可以用特殊规则 <code>ANY</code> 来匹配任何单个字符。这相当于 <code>'\u{00}'...'\u{10FFFF}'</code>，任何一个 Unicode 字符。</p>
<pre><code>&quot;a literal string&quot;
^&quot;ASCII case-insensitive string&quot;
'a'..'z'
ANY
</code></pre><p>最后，你可以直接写出其他规则的名称来引用它们，甚至可以递归使用规则。</p>
<pre><code>my_rule = { &quot;slithy &quot; ~ other_rule }
other_rule = { &quot;toves&quot; }
recursive_rule = { &quot;mimsy &quot; ~ recursive_rule }
</code></pre><h3 id="序列">序列</h3>
<p>序列运算符写成一个波浪号 <code>~</code>。</p>
<pre><code>first ~ and_then

(&quot;abc&quot;) ~ (^&quot;def&quot;) ~ ('g'..'z')        // matches &quot;abcDEFr&quot;
</code></pre><p>当匹配一个序列表达式时，尝试匹配 <code>first</code>。如果 <code>first</code> 匹配成功，则接下来尝试 <code>and_then</code>。但是，如果 <code>first</code> 失败，则整个表达式失败。</p>
<p>表达式的列表可以与序列链在一起，这表明所有的组件必须出现，按照指定的顺序。</p>
<h3 id="有序选择-1">有序选择</h3>
<p>选择运算符写成一条竖线 <code>|</code>。</p>
<pre><code>first | or_else

(&quot;abc&quot;) | (^&quot;def&quot;) | ('g'..'z')        // matches &quot;DEF&quot;
</code></pre><p>当匹配一个选择表达式时，尝试匹配 <code>first</code>。如果 <code>first</code> 匹配成功，则整个表达式立即成功。但是，如果 <code>first</code> 失败，接下来会尝试 <code>or_else</code>。</p>
<p>注意，<code>first</code> 和 <code>or_else</code> 总是在同一个位置尝试，即使 <code>first</code> 在失败之前匹配了一些输入。当遇到解析失败时，引擎会尝试下一个有序的选择，就像没有匹配到输入一样。失败的解析永远不会消耗任何输入。</p>
<pre><code>start = { &quot;Beware &quot; ~ creature }
creature = {
    (&quot;the &quot; ~ &quot;Jabberwock&quot;)
    | (&quot;the &quot; ~ &quot;Jubjub bird&quot;)
}

&quot;Beware the Jubjub bird&quot;
 ^ (start) Parses via the second choice of `creature`,
           even though the first choice matched &quot;the &quot; successfully.
</code></pre><p>借用术语，把这种操作看成是&quot;交替&quot;或简单的 &ldquo;OR&rdquo;，有点诱人，但这是误导。之所以特别使用 &ldquo;选择&rdquo; 这个词，是因为这个操作不仅仅是逻辑上的 &ldquo;OR&rdquo;。</p>
<h3 id="重复">重复</h3>
<p>有两个重复运算符：星号 <code>*</code> 和加号 <code>+</code>。它们被放在一个表达式之后。星号 <code>*</code> 表示前面的表达式可以出现零次或多次。加号 <code>+</code> 表示前面的表达式可以出现一次或多次（必须至少出现一次）。</p>
<p>问号运算符 <code>?</code> 类似，但它表示表达式是可选的 - 它可以出现0次或1次。</p>
<pre><code>(&quot;zero&quot; ~ &quot;or&quot; ~ &quot;more&quot;)*
 (&quot;one&quot; | &quot;or&quot; | &quot;more&quot;)+
           (^&quot;optional&quot;)?
</code></pre><p>请注意，<code>expr*</code> 和 <code>expr?</code> 总是会成功，因为它们被允许匹配零次。例如，<code>&quot;a&quot;* ~ &quot;b&quot;?</code> 即使在空的输入字符串上也会成功。</p>
<p>其他重复次数可以用大括号来表示。</p>
<pre><code>expr{n}           // exactly n repetitions
expr{m, n}        // between m and n repetitions, inclusive

expr{, n}         // at most n repetitions
expr{m, }         // at least m repetitions
</code></pre><p>因此，<code>expr*</code> 等同于 <code>expr{0，}</code>；<code>expr+</code> 等同于 <code>expr{1，}</code>；<code>expr?</code> 等同于 <code>expr{0，1}</code>。</p>
<h3 id="谓词">谓词</h3>
<p>在表达式前面加上安括号 <code>&amp;</code> 或感叹号 <code>!</code>，就会变成一个不消耗任何输入的谓词。你可能知道这些运算符为 &ldquo;向前查看&rdquo; 或 &ldquo;不进位&rdquo;。</p>
<p>写成安培符 <code>&amp;</code> 的正式谓词试图匹配其内部表达式。如果内部表达式成功，解析就会继续，但位置与谓词相同 - <code>&amp;foo ~ bar</code> 因此是一种 &ldquo;AND&rdquo; 语句。&ldquo;输入字符串必须匹配 <code>foo</code> AND <code>bar</code>&quot;。如果内部表达式失败，整个表达式也会失败。</p>
<p>写成感叹号的否定谓词 <code>!</code>，试图匹配其内部表达式。如果内部表达式失败，则谓词成功，并在与谓词相同的位置继续解析。如果内部表达式成功，则谓词失败 - <code>!foo ~ bar</code> 因此是一种 &ldquo;NOT&rdquo; 语句。&ldquo;输入的字符串必须与 <code>bar</code> 匹配，但不能是 <code>foo</code>&quot;。</p>
<p>这就引出了一个常见的惯用法，意思是&quot;任何字符但是&rdquo;：</p>
<pre><code>not_space_or_tab = {
    !(                // if the following text is not
        &quot; &quot;           //     a space
        | &quot;\t&quot;        //     or a tab
    )
    ~ ANY             // then consume one character
}

triple_quoted_string = {
    &quot;'''&quot;
    ~ triple_quoted_character*
    ~ &quot;'''&quot;
}
triple_quoted_character = {
    !&quot;'''&quot;        // if the following text is not three apostrophes
    ~ ANY         // then consume one character
}
</code></pre><h3 id="操作符优先级和分组-wip">操作符优先级和分组 (WIP)</h3>
<p>重复运算符星号 <code>*</code>、加号 <code>+</code> 和问号 <code>?</code> 适用于紧接前面的表达式。</p>
<pre><code>&quot;One &quot; ~ &quot;or &quot; ~ &quot;more. &quot;+
&quot;One &quot; ~ &quot;or &quot; ~ (&quot;more. &quot;+)
    are equivalent and match
&quot;One or more. more. more. more. &quot;
</code></pre><p>较大的表达式可以通过用括号包围来重复。</p>
<pre><code>(&quot;One &quot; ~ &quot;or &quot; ~ &quot;more. &quot;)+
    matches
&quot;One or more. One or more. &quot;
</code></pre><p>重复运算符的优先性最高，其次是谓词运算符、序列运算符，最后是有序选择。</p>
<pre><code>my_rule = {
    &quot;a&quot;* ~ &quot;b&quot;?
    | &amp;&quot;b&quot;+ ~ &quot;a&quot;
}

// equivalent to

my_rule = {
      ( (&quot;a&quot;*) ~ (&quot;b&quot;?) )
    | ( (&amp;(&quot;b&quot;+)) ~ &quot;a&quot; )
}
</code></pre><h3 id="输入的开始和结束">输入的开始和结束</h3>
<p>规则 <code>SOI</code> 和 <code>EOI</code> 分别匹配输入字符串的开始和结束。两者都不消耗任何文本。它们只表明解析器当前是否在输入的一个边缘。</p>
<p>例如，为了确保一条规则匹配整个输入，其中任何语法错误都会导致解析失败（而不是成功但不完整的解析）。</p>
<pre><code>main = {
    SOI
    ~ (...)
    ~ EOI
}
</code></pre><h3 id="隐含的空白">隐含的空白</h3>
<p>许多语言和文本格式允许在逻辑标记之间任意留白和注释。例如，Rust 认为 <code>4+5</code> 相当于 <code>4 + 5</code> 和 <code>4 /* comment */ + 5</code>。</p>
<p>可选规则 <code>WHITESPACE</code> 和 <code>COMMENT</code> 实现了这种行为。如果定义了这两个规则中的任何一个(或两个)，它们将被隐式地插入到每个<a href="https://pest.rs/book/grammars/syntax.html#sequence">序列</a>和每个<a href="https://pest.rs/book/grammars/syntax.html#repetition">重复</a>之间(<a href="https://pest.rs/book/grammars/syntax.html#atomic">原子规则</a>除外)。</p>
<pre><code>expression = { &quot;4&quot; ~ &quot;+&quot; ~ &quot;5&quot; }
WHITESPACE = _{ &quot; &quot; }
COMMENT = _{ &quot;/*&quot; ~ (!&quot;*/&quot; ~ ANY)* ~ &quot;*/&quot; }
</code></pre><pre><code>&quot;4+5&quot;
&quot;4 + 5&quot;
&quot;4  +     5&quot;
&quot;4 /* comment */ + 5&quot;
</code></pre><p>正如你所看到的，<code>WHITESPACE</code> 和 <code>COMMENT</code> 是重复运行的，所以它们只需要匹配一个空白字符或一个注释。上面的 grammar 相当于。</p>
<pre><code>expression = {
    &quot;4&quot;   ~ (ws | com)*
    ~ &quot;+&quot; ~ (ws | com)*
    ~ &quot;5&quot;
}
ws = _{ &quot; &quot; }
com = _{ &quot;/*&quot; ~ (!&quot;*/&quot; ~ ANY)* ~ &quot;*/&quot; }
</code></pre><p>请注意，隐式空格不会插入规则的开头或结尾 - 例如，表达式不匹配 <code>&quot; 4+5 &quot;</code>。如果你想在规则的开头和结尾加入隐式空格，你需要把它夹在两个空规则之间（通常是 <code>SOI</code> 和 <code>EOI</code>，<a href="https://pest.rs/book/grammars/syntax.html#start-and-end-of-input">如上所述</a>）。</p>
<pre><code>WHITESPACE = _{ &quot; &quot; }
expression = { &quot;4&quot; ~ &quot;+&quot; ~ &quot;5&quot; }
main = { SOI ~ expression ~ EOI }
</code></pre><pre><code>&quot;4+5&quot;
&quot;  4 + 5   &quot;
</code></pre><p>(请务必将 <code>WHITESPACE</code> 和 <code>COMMENT</code> 规则标记为<a href="https://pest.rs/book/grammars/syntax.html#silent-and-atomic-rules">静默</a>规则，除非你想在其他规则中看到它们！)</p>
<h3 id="静默规则和原子规则">静默规则和原子规则</h3>
<p>静默规则就像普通规则一样 - 当运行时，它们的功能是一样的 - 除了它们不产生 <a href="https://pest.rs/book/parser_api.html#pairs">pairs</a>或 <a href="https://pest.rs/book/parser_api.html#tokens">tokens</a>。如果一条规则是静默的，那么它永远不会出现在解析结果中。</p>
<p>要创建一个静默规则，请在左边的大括号 <code>{</code> 前加上一个下划线 <code>_</code>。</p>
<pre><code>silent = _{ ... }
</code></pre><h3 id="原子">原子</h3>
<p>pest 有两种原子规则：原子和复合原子。要做一个，在左大括号 <code>{</code> 前写上一个符号。</p>
<pre><code>atomic = @{ ... }
compound_atomic = ${ ... }
</code></pre><p>这两种原子规则都可以防止<a href="https://pest.rs/book/grammars/syntax.html#implicit-whitespace">隐式空格</a>：在原子规则中，波浪号 <code>~</code> 表示 &ldquo;紧接着&rdquo;，<a href="https://pest.rs/book/grammars/syntax.html#repetition">重复操作符</a>（星号 <code>*</code> 和加号 <code>+</code>）没有隐式分隔。此外，所有从原子规则中调用的其他规则也被视为原子规则。</p>
<p>两者的区别在于它们如何产生内部规则的标记。在一个原子规则中，内部匹配规则是<a href="https://pest.rs/book/grammars/syntax.html#silent-and-atomic-rules">静默的</a>。相比之下，复合原子规则会像普通规则一样产生内部 token。</p>
<p>当您要解析的文本忽略空白时，原子规则是很有用的，除了少数情况，例如文字字符串。在这种情况下，您可以编写 <code>WHITESPACE</code> 或 <code>COMMENT</code> 规则，然后使您的字符串匹配规则成为原子规则。</p>
<h3 id="非原子的">非原子的</h3>
<p>有时候，你会想要取消原子解析的效果。例如，你可能想在表达式内部进行字符串插值，里面的表达式仍然可以像正常的一样有空格。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="ch">#!/bin/env python3</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&#34;The answer is {2 + 4}.&#34;</span><span class="p">)</span>
</code></pre></div><p>这是你使用非原子规则的地方。在定义的大括号前面写一个感叹号 <code>!</code> 无论是否从原子规则中调用，该规则都将作为非原子规则运行。</p>
<pre><code>fstring = @{ &quot;\&quot;&quot; ~ ... }
expr = !{ ... }
</code></pre><h3 id="堆栈wip">堆栈(WIP)</h3>
<p>pest 维护了一个可以直接从 grammar 中操作的栈。一个表达式可以用关键字 <code>PUSH</code> 进行匹配并推到栈上，然后再用关键字 <code>PEEK</code> 和 <code>POP</code> 进行精确匹配。</p>
<p>使用栈可以对完全相同的文本进行多次匹配，而不是相同的模式。</p>
<p>例如:</p>
<pre><code>same_text = {
    PUSH( &quot;a&quot; | &quot;b&quot; | &quot;c&quot; )
    ~ POP
}
same_pattern = {
    (&quot;a&quot; | &quot;b&quot; | &quot;c&quot;)
    ~ (&quot;a&quot; | &quot;b&quot; | &quot;c&quot;)
}
</code></pre><p>在这种情况下，<code>same_pattern</code> 会匹配 <code>&quot;ab&quot;</code>，而 <code>same_text</code> 不会。</p>
<p>一个实际的用途是解析 Rust 的 &ldquo;<a href="https://doc.rust-lang.org/book/second-edition/appendix-02-operators.html#non-operator-symbols">原始字符串字面值</a>&quot;，它看起来像这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">const</span><span class="w"> </span><span class="n">raw_str</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">r###&#34;
</span><span class="s">    Some number of number signs # followed by a quotation mark &#34;.
</span><span class="s">
</span><span class="s">    Quotation marks can be used anywhere inside: &#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;,
</span><span class="s">    as long as one is not followed by a matching number of number signs,
</span><span class="s">    which ends the string: &#34;###</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>当解析一个原始字符串时，我们必须跟踪引号前出现了多少个数字符号 <code>#</code>。我们可以使用栈来完成这个任务。</p>
<pre><code>raw_string = {
    &quot;r&quot; ~ PUSH(&quot;#&quot;*) ~ &quot;\&quot;&quot;    // push the number signs onto the stack
    ~ raw_string_interior
    ~ &quot;\&quot;&quot; ~ POP               // match a quotation mark and the number signs
}
raw_string_interior = {
    (
        !(&quot;\&quot;&quot; ~ PEEK)    // unless the next character is a quotation mark
                          // followed by the correct amount of number signs,
        ~ ANY             // consume one character
    )*
}
</code></pre><h3 id="小抄">小抄</h3>
<table>
<thead>
<tr>
<th style="text-align:left">语法</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">语法</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>foo = { ... }</code></td>
<td style="text-align:left">regular rule</td>
<td style="text-align:left"><code>baz = @{ ... }</code></td>
<td style="text-align:left">atomic</td>
</tr>
<tr>
<td style="text-align:left"><code>bar = _{ ... }</code></td>
<td style="text-align:left">silent<code>	                  | </code>qux = ${ &hellip; }`   | compound-atomic    |</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"><code>plugh = !{ ... }</code></td>
<td style="text-align:left">non-atomic</td>
</tr>
<tr>
<td style="text-align:left"><code>&quot;abc&quot;</code></td>
<td style="text-align:left">exact string</td>
<td style="text-align:left"><code>^&quot;abc&quot;</code></td>
<td style="text-align:left">case insensitive</td>
</tr>
<tr>
<td style="text-align:left"><code>'a'..'z'</code></td>
<td style="text-align:left">character range</td>
<td style="text-align:left"><code>ANY</code></td>
<td style="text-align:left">any character</td>
</tr>
<tr>
<td style="text-align:left"><code>foo ~ bar</code></td>
<td style="text-align:left">sequence</td>
<td style="text-align:left"><code>baz | qux</code></td>
<td style="text-align:left">ordered choice</td>
</tr>
<tr>
<td style="text-align:left"><code>foo*</code></td>
<td style="text-align:left">zero or more</td>
<td style="text-align:left"><code>bar+</code></td>
<td style="text-align:left">one or more</td>
</tr>
<tr>
<td style="text-align:left"><code>baz?</code></td>
<td style="text-align:left">optional</td>
<td style="text-align:left"><code>qux{n}</code></td>
<td style="text-align:left">exactly n</td>
</tr>
<tr>
<td style="text-align:left"><code>qux{m, n}</code></td>
<td style="text-align:left">between m and n  (inclusive)</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>&amp;foo</code></td>
<td style="text-align:left">positive predicate</td>
<td style="text-align:left"><code>!bar</code></td>
<td style="text-align:left">negative predicate</td>
</tr>
<tr>
<td style="text-align:left"><code>PUSH(baz)</code></td>
<td style="text-align:left">match and push</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>POP</code></td>
<td style="text-align:left">match and pop</td>
<td style="text-align:left"><code>PEEK</code></td>
<td style="text-align:left">match without pop</td>
</tr>
</tbody>
</table>
<h2 id="内置规则">内置规则</h2>
<p>除了 <code>ANY</code>，匹配任何单一的 Unicode 字符外，<code>pest</code> 还提供了几条规则，让解析文本更加方便。</p>
<h3 id="ascii-规则">ASCII 规则</h3>
<p>在可打印的 ASCII 字符中，它通常对匹配字母字符和数字很有用。对于数字，pest 提供了常见的（基数）的数字。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Built-in rule</th>
<th style="text-align:left">Equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>ASCII_DIGIT</code></td>
<td style="text-align:left"><code>'0'..'9'</code></td>
</tr>
<tr>
<td style="text-align:left"><code>ASCII_NONZERO_DIGIT</code></td>
<td style="text-align:left"><code>'1'..'9'</code></td>
</tr>
<tr>
<td style="text-align:left"><code>ASCII_BIN_DIGIT</code></td>
<td style="text-align:left"><code>'0'..'1'</code></td>
</tr>
<tr>
<td style="text-align:left"><code>ASCII_OCT_DIGIT</code></td>
<td style="text-align:left"><code>'0'..'7'</code></td>
</tr>
<tr>
<td style="text-align:left"><code>ASCII_HEX_DIGIT</code></td>
<td style="text-align:left"><code>'0'..'9' | 'a'..'f' | 'A'..'F'</code></td>
</tr>
</tbody>
</table>
<p>对于字母字符，要区分大写和小写。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Built-in rule</th>
<th style="text-align:left">Equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ASCII_ALPHA_LOWER</td>
<td style="text-align:left"><code>'a'..'z'</code></td>
</tr>
<tr>
<td style="text-align:left">ASCII_ALPHA_UPPER</td>
<td style="text-align:left"><code>'A'..'Z'</code></td>
</tr>
<tr>
<td style="text-align:left">ASCII_ALPHA</td>
<td style="text-align:left"><code>'a'..'z' | 'A'..'Z'</code></td>
</tr>
</tbody>
</table>
<p>And for miscellaneous use:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Built-in rule</th>
<th style="text-align:left">Meaning</th>
<th>Equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ASCII_ALPHANUMERIC</td>
<td style="text-align:left">any digit or letter</td>
<td><code>ASCII_DIGIT | ASCII_ALPHA</code></td>
</tr>
<tr>
<td style="text-align:left">NEWLINE</td>
<td style="text-align:left">any line feed format</td>
<td><code>&quot;\n&quot; | &quot;\r\n&quot; | &quot;\r&quot;</code></td>
</tr>
</tbody>
</table>
<h3 id="统一码规则">统一码规则</h3>
<p>为了更容易正确解析任意 Unicode 文本，pest 包含了大量对应 Unicode 字符属性的规则。这些规则分为一般类别和二进制属性规则。</p>
<p>Unicode 字符根据其一般用途被划分为不同的类别。每一个字符都属于一个类别，就像每一个 ASCII 字符都是一个控制字符、一个数字、一个字母、一个符号或一个空格一样。</p>
<p>此外，每个 Unicode 字符都有一个二进制属性列表（真或假），它满足或不满足这些属性。字符可以属于任何数量的这些属性，这取决于它们的含义。</p>
<p>例如，字符 &ldquo;A&rdquo;，&ldquo;拉丁文大写字母A&rdquo;，属于一般的 &ldquo;大写字母&rdquo; 类别，因为它的一般用途是字母。它具有 &ldquo;大写字母&rdquo; 的二元属性，但不具有 &ldquo;表情符号&rdquo; 的属性。相比之下，&ldquo;负数平方的拉丁文大写字母A&rdquo; 这个字符，因为在文本中一般不作为字母出现，所以属于一般类别 &ldquo;其他符号&rdquo;。它同时具有 &ldquo;大写字母&rdquo; 和 &ldquo;表情符号&rdquo; 的二元属性。</p>
<p>详情请参考《Unicode 标准》第四章。</p>
<h3 id="一般类别">一般类别</h3>
<p>从形式上看，类别是不重叠的：每个 Unicode 字符正好属于一个类别，没有一个类别包含另一个类别。然而，由于某些类别组经常一起使用，pest 在下面暴露了类别的层次结构。例如，规则 <code>CASED_LETTER</code> 在技术上不是 Unicode 通用类别，而是匹配属于 UPPERCASE_LETTER  或LOWERCASE_LETTER 的字符，这些都是通用类别。</p>
<ul>
<li>LETTER</li>
<li>CASED_LETTER</li>
<li>UPPERCASE_LETTER</li>
<li>LOWERCASE_LETTER</li>
<li>TITLECASE_LETTER</li>
<li>MODIFIER_LETTER</li>
<li>OTHER_LETTER</li>
<li>MARK</li>
<li>NONSPACING_MARK</li>
<li>SPACING_MARK</li>
<li>ENCLOSING_MARK</li>
<li>NUMBER</li>
<li>DECIMAL_NUMBER</li>
<li>LETTER_NUMBER</li>
<li>OTHER_NUMBER</li>
<li>PUNCTUATION</li>
<li>CONNECTOR_PUNCTUATION</li>
<li>DASH_PUNCTUATION</li>
<li>OPEN_PUNCTUATION</li>
<li>CLOSE_PUNCTUATION</li>
<li>INITIAL_PUNCTUATION</li>
<li>FINAL_PUNCTUATION</li>
<li>OTHER_PUNCTUATION</li>
<li>SYMBOL</li>
<li>MATH_SYMBOL</li>
<li>CURRENCY_SYMBOL</li>
<li>MODIFIER_SYMBOL</li>
<li>OTHER_SYMBOL</li>
<li>SEPARATOR</li>
<li>SPACE_SEPARATOR</li>
<li>LINE_SEPARATOR</li>
<li>PARAGRAPH_SEPARATOR</li>
<li>OTHER</li>
<li>CONTROL</li>
<li>FORMAT</li>
<li>SURROGATE</li>
<li>PRIVATE_USE</li>
<li>UNASSIGNED</li>
</ul>
<h3 id="binary-properties">Binary properties</h3>
<p>这些属性中有许多是用来定义 Unicode 文本算法的，如双向算法和文本分割算法。这类属性对于大多数解析器来说可能并不有用。</p>
<p>但是，XID_START 和 XID_CONTINUE 这两个属性特别值得注意，因为它们被定义为 &ldquo;协助标识符的标准处理&rdquo;，&ldquo;如编程语言变量&rdquo;。详见技术报告31。</p>
<ul>
<li>ALPHABETIC</li>
<li>BIDI_CONTROL</li>
<li>CASE_IGNORABLE</li>
<li>CASED</li>
<li>CHANGES_WHEN_CASEFOLDED</li>
<li>CHANGES_WHEN_CASEMAPPED</li>
<li>CHANGES_WHEN_LOWERCASED</li>
<li>CHANGES_WHEN_TITLECASED</li>
<li>CHANGES_WHEN_UPPERCASED</li>
<li>DASH</li>
<li>DEFAULT_IGNORABLE_CODE_POINT</li>
<li>DEPRECATED</li>
<li>DIACRITIC</li>
<li>EXTENDER</li>
<li>GRAPHEME_BASE</li>
<li>GRAPHEME_EXTEND</li>
<li>GRAPHEME_LINK</li>
<li>HEX_DIGIT</li>
<li>HYPHEN</li>
<li>IDS_BINARY_OPERATOR</li>
<li>IDS_TRINARY_OPERATOR</li>
<li>ID_CONTINUE</li>
<li>ID_START</li>
<li>IDEOGRAPHIC</li>
<li>JOIN_CONTROL</li>
<li>LOGICAL_ORDER_EXCEPTION</li>
<li>LOWERCASE</li>
<li>MATH</li>
<li>NONCHARACTER_CODE_POINT</li>
<li>OTHER_ALPHABETIC</li>
<li>OTHER_DEFAULT_IGNORABLE_CODE_POINT</li>
<li>OTHER_GRAPHEME_EXTEND</li>
<li>OTHER_ID_CONTINUE</li>
<li>OTHER_ID_START</li>
<li>OTHER_LOWERCASE</li>
<li>OTHER_MATH</li>
<li>OTHER_UPPERCASE</li>
<li>PATTERN_SYNTAX</li>
<li>PATTERN_WHITE_SPACE</li>
<li>PREPENDED_CONCATENATION_MARK</li>
<li>QUOTATION_MARK</li>
<li>RADICAL</li>
<li>REGIONAL_INDICATOR</li>
<li>SENTENCE_TERMINAL</li>
<li>SOFT_DOTTED</li>
<li>TERMINAL_PUNCTUATION</li>
<li>UNIFIED_IDEOGRAPH</li>
<li>UPPERCASE</li>
<li>VARIATION_SELECTOR</li>
<li>WHITE_SPACE</li>
<li>XID_CONTINUE</li>
<li>XID_START</li>
</ul>
<h2 id="例子-json">例子: JSON</h2>
<p>JSON 是一种流行的数据序列化格式，它源于 JavaScript 的语法。JSON 文档是树状的，并且可能是递归的&ndash;对象和数组这两种数据类型可以包含其他值，包括其他对象和数组。</p>
<p>下面是一个 JSON 文档的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;nesting&#34;</span><span class="p">:</span> <span class="p">{</span> <span class="nt">&#34;inner object&#34;</span><span class="p">:</span> <span class="p">{}</span> <span class="p">},</span>
    <span class="nt">&#34;an array&#34;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">],</span>
    <span class="nt">&#34;string with escaped double quotes&#34;</span> <span class="p">:</span> <span class="s2">&#34;\&#34;quick brown foxes\&#34;&#34;</span>
<span class="p">}</span>
</code></pre></div><p>让我们写一个程序，将 JSON 解析成一个 Rust 对象，也就是抽象语法树，然后将 AST 序列化回 JSON。</p>
<h3 id="设置">设置</h3>
<p>我们将从定义 Rust 中的 AST 开始。每个 JSON 数据类型都由一个枚举变体来表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">JSONValue</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Object</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">JSONValue</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">Array</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">JSONValue</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;&gt;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="nb">String</span><span class="p">(</span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">Number</span><span class="p">(</span><span class="kt">f64</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">Boolean</span><span class="p">(</span><span class="kt">bool</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">Null</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为了避免反序列化字符串时的复制，JSONValue 从原始未解析的 JSON 中借用字符串。为了使其工作，我们不能解释字符串转义序列：输入字符串 &ldquo;\n&rdquo; 将由 JSONValue::String(&quot;\n&rdquo;) 表示，这是一个有两个字符的 Rust 字符串，尽管它表示的是一个只有一个字符的 JSON 字符串。</p>
<p>让我们继续看序列化器。为了清晰起见，它使用分配的 Strings，而不是提供 std::fmt::Display 的实现，后者会更习惯。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">serialize_jsonvalue</span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="nc">JSONValue</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">JSONValue</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Object</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">contents</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">o</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="o">|</span><span class="w">
</span><span class="w">                     </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;\&#34;{}\&#34;:{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">serialize_jsonvalue</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span><span class="w">
</span><span class="w">                </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{{{}}}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#34;,&#34;</span><span class="p">))</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">Array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">contents</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">serialize_jsonvalue</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;[{}]&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#34;,&#34;</span><span class="p">))</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="nb">String</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;\&#34;{}\&#34;&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Number</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Boolean</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Null</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;null&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>请注意，在对象和数组的情况下，函数会递归地调用自己。这种模式出现在整个解析器中。AST创建函数在解析结果中递归迭代，而语法的规则也包括了自己。</p>
<h3 id="grammar-的编写">grammar 的编写</h3>
<p>让我们从 whitespace 开始。JSON 空格可以出现在任何地方，除了字符串内部（必须单独解析）和数字中的数字之间（不允许）。这使得它很适合 pest 的隐式空白。在 <code>src/json.pest</code>:</p>
<pre><code>WHITESPACE = _{ &quot; &quot; | &quot;\t&quot; | &quot;\r&quot; | &quot;\n&quot; }
</code></pre><p>JSON 规范包括解析 JSON 字符串的图。我们可以直接从该页面写出语法。让我们把 object 写成一个用逗号分隔的对的序列。</p>
<pre><code>object = {
    &quot;{&quot; ~ &quot;}&quot; |
    &quot;{&quot; ~ pair ~ (&quot;,&quot; ~ pair)* ~ &quot;}&quot;
}
pair = { string ~ &quot;:&quot; ~ value }

array = {
    &quot;[&quot; ~ &quot;]&quot; |
    &quot;[&quot; ~ value ~ (&quot;,&quot; ~ value)* ~ &quot;]&quot;
}
</code></pre><p>对象和数组规则展示了如何用分隔符解析一个潜在的空列表。有两种情况：一种是空列表，另一种是至少有一个元素的列表。这是必要的，因为数组中的逗号，如 <code>[0，1，]</code>，在 JSON 中是非法的。</p>
<p>现在我们可以写 value，它代表任何单一的数据类型。我们将模仿我们的 AST，将 boolean 和 null 写成单独的规则。</p>
<pre><code>value = _{ object | array | string | number | boolean | null }

boolean = { &quot;true&quot; | &quot;false&quot; }

null = { &quot;null&quot; }
</code></pre><p>让我们把字符串的逻辑分成三个部分。<code>char</code> 是一个匹配字符串中任何逻辑字符的规则，包括任何反斜杠转义序列。<code>inner</code> 代表字符串的内容，不包括周围的双引号。<code>string</code> 匹配字符串的内部内容，包括周围的双引号。</p>
<p><code>char</code> 规则使用成语 <code>!(...) ~ ANY</code>，它匹配除了括号中给出的字符之外的任何字符。在这种情况下，除了双引号 <code>&quot;&quot;</code> 和反斜杠 <code>\</code> 之外，任何字符在字符串内部都是合法的，这需要单独的解析逻辑。</p>
<pre><code>string = ${ &quot;\&quot;&quot; ~ inner ~ &quot;\&quot;&quot; }
inner = @{ char* }
char = {
    !(&quot;\&quot;&quot; | &quot;\\&quot;) ~ ANY
    | &quot;\\&quot; ~ (&quot;\&quot;&quot; | &quot;\\&quot; | &quot;/&quot; | &quot;b&quot; | &quot;f&quot; | &quot;n&quot; | &quot;r&quot; | &quot;t&quot;)
    | &quot;\\&quot; ~ (&quot;u&quot; ~ ASCII_HEX_DIGIT{4})
}
</code></pre><p>因为 <code>string</code> 被标记为复原子，所以 <code>string</code> token 对也会包含一个 <code>inner</code> 对。因为 <code>inner</code> 被标记为原子，所以在 <code>inner</code> 中不会出现 <code>char</code> 对。由于这些规则是原子性的，所以在不同的标记之间不允许有空格。</p>
<p>数字有四个逻辑部分：一个可选的符号、一个整数部分、一个可选的分数部分和一个可选的指数。我们将把数字标记为原子，这样它的部分之间就不能出现空白。</p>
<pre><code>number = @{
    &quot;-&quot;?
    ~ (&quot;0&quot; | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
    ~ (&quot;.&quot; ~ ASCII_DIGIT*)?
    ~ (^&quot;e&quot; ~ (&quot;+&quot; | &quot;-&quot;)? ~ ASCII_DIGIT+)?
}
</code></pre><p>我们需要一个最终规则来表示整个 JSON 文件。JSON 文件的唯一合法内容是一个对象或数组。我们将把这个规则标记为沉默，这样一个解析后的 JSON 文件只包含两个标记对：解析后的值本身，以及 EOI 规则。</p>
<pre><code>json = _{ SOI ~ (object | array) ~ EOI }
</code></pre><h3 id="ast-生成">AST 生成</h3>
<p>让我们把 grammar 编译成 Rust。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">pest</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="cp">#[macro_use]</span><span class="w">
</span><span class="w"></span><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">pest_derive</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">pest</span>::<span class="n">Parser</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Parser)]</span><span class="w">
</span><span class="w"></span><span class="cp">#[grammar = </span><span class="s">&#34;json.pest&#34;</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">JSONParser</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>我们将写一个同时处理解析和 AST 生成的函数。该函数的用户可以在输入字符串上调用它，然后将返回的结果作为 JSONValue 或解析错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">pest</span>::<span class="n">error</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">parse_json_file</span><span class="p">(</span><span class="n">file</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">JSONValue</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&lt;</span><span class="n">Rule</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JSONParser</span>::<span class="n">parse</span><span class="p">(</span><span class="n">Rule</span>::<span class="n">json</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="p">)</span><span class="o">?</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>现在我们需要根据规则，递归处理 <code>Pair</code>。我们知道 json 是一个对象或者数组，但是这些值本身可能包含一个对象或者数组！这时，我们就需要写一个辅助递归函数，直接将 <code>Pair</code> 解析成 <code>JSONValue</code>。最合理的处理方式是写一个辅助递归函数，直接将 <code>Pair</code> 解析成 JSONValue。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">parse_json_file</span><span class="p">(</span><span class="n">file</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">JSONValue</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&lt;</span><span class="n">Rule</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">pest</span>::<span class="n">iterators</span>::<span class="n">Pair</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">parse_value</span><span class="p">(</span><span class="n">pair</span>: <span class="nc">Pair</span><span class="o">&lt;</span><span class="n">Rule</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">JSONValue</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">as_rule</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Rule</span>::<span class="n">object</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">JSONValue</span>::<span class="n">Object</span><span class="p">(</span><span class="w">
</span><span class="w">                </span><span class="n">pair</span><span class="p">.</span><span class="n">into_inner</span><span class="p">()</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">pair</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">inner_rules</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">into_inner</span><span class="p">();</span><span class="w">
</span><span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inner_rules</span><span class="w">
</span><span class="w">                            </span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w">
</span><span class="w">                            </span><span class="p">.</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span><span class="w">                            </span><span class="p">.</span><span class="n">into_inner</span><span class="p">()</span><span class="w">
</span><span class="w">                            </span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w">
</span><span class="w">                            </span><span class="p">.</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span><span class="w">                            </span><span class="p">.</span><span class="n">as_str</span><span class="p">();</span><span class="w">
</span><span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_value</span><span class="p">(</span><span class="n">inner_rules</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span><span class="w">
</span><span class="w">                        </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">})</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">collect</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">Rule</span>::<span class="n">array</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">JSONValue</span>::<span class="n">Array</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">into_inner</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">parse_value</span><span class="p">).</span><span class="n">collect</span><span class="p">()),</span><span class="w">
</span><span class="w">            </span><span class="n">Rule</span>::<span class="n">string</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">JSONValue</span>::<span class="nb">String</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">into_inner</span><span class="p">().</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_str</span><span class="p">()),</span><span class="w">
</span><span class="w">            </span><span class="n">Rule</span>::<span class="n">number</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">JSONValue</span>::<span class="n">Number</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">as_str</span><span class="p">().</span><span class="n">parse</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()),</span><span class="w">
</span><span class="w">            </span><span class="n">Rule</span>::<span class="n">boolean</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">JSONValue</span>::<span class="n">Boolean</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">as_str</span><span class="p">().</span><span class="n">parse</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()),</span><span class="w">
</span><span class="w">            </span><span class="n">Rule</span>::<span class="n">null</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">JSONValue</span>::<span class="n">Null</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">Rule</span>::<span class="n">json</span><span class="w">
</span><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="n">Rule</span>::<span class="n">EOI</span><span class="w">
</span><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="n">Rule</span>::<span class="n">pair</span><span class="w">
</span><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="n">Rule</span>::<span class="n">value</span><span class="w">
</span><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="n">Rule</span>::<span class="n">inner</span><span class="w">
</span><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="n">Rule</span>::<span class="n">char</span><span class="w">
</span><span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="n">Rule</span>::<span class="n">WHITESPACE</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">unreachable</span><span class="o">!</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>对象和数组的情况值得特别注意。数组令牌对的内容只是一个值的序列。由于我们使用的是 Rust 迭代器，我们可以简单地将每个值递归地映射到它的解析 AST 节点，然后将它们收集到一个 Vec 中。对于对象，过程是类似的，除了迭代器是在对上，我们需要分别从对上提取名称和值。</p>
<p>数字和布尔的情况下，使用 Rust 的 str::parse 方法将解析后的字符串转换为相应的 Rust 类型。每一个合法的 JSON 数字都可以直接解析成一个 Rust 浮点数！我们在 Rust 的 str::parse 方法上运行 parse_value。</p>
<p>我们对解析结果运行 parse_value 来完成转换。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">parse_json_file</span><span class="p">(</span><span class="n">file</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">JSONValue</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&lt;</span><span class="n">Rule</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">parse_value</span><span class="p">(</span><span class="n">json</span><span class="p">))</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="精加工">精加工</h3>
<p>我们的主要功能现在非常简单。首先，我们从一个名为 data.json 的文件中读取 JSON 数据。接下来，我们将文件内容解析成一个 JSON AST。最后，我们将 AST 序列化回一个字符串并打印出来。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">unparsed_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">read_to_string</span><span class="p">(</span><span class="s">&#34;data.json&#34;</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;cannot read file&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">json</span>: <span class="nc">JSONValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_json_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unparsed_file</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;unsuccessful parse&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">serialize_jsonvalue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">json</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>试试吧! 将本章顶部的示例文档复制到 data.json 中，然后运行程序! 你应该看到这样的东西。</p>
<pre><code>$ cargo run
  [ ... ]
{&quot;nesting&quot;:{&quot;inner object&quot;:{}},&quot;an array&quot;:[1.5,true,null,0.000001],&quot;string with escaped double quotes&quot;:&quot;\&quot;quick brown foxes\&quot;&quot;}
</code></pre><h2 id="例子-j-语言">例子: J 语言</h2>
<p>J 语言是一种受 APL 影响的数组编程语言。在 J 语言中，对单个数字(<code>2*3</code>)的操作可以很容易地应用于整个数字列表(<code>2*3 4 5</code>，返回 <code>6 8 10</code>)。</p>
<p>J 中的操作符被称为动词。动词要么是一元的（取一个参数，如 <code>*: 3</code>，&ldquo;3 的平方&rdquo;），要么是二元的（取两个参数，两边各一个，如 <code>5 - 4</code>，&ldquo;5减4&rdquo;）。</p>
<p>下面是一个 J 程序的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-J" data-lang="J"><span class="s">&#39;A string&#39;</span>

<span class="o">*:</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span>

<span class="nv">matrix</span> <span class="o">=:</span> <span class="mi">2</span> <span class="mi">3</span> <span class="o">$</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span>
<span class="mi">10</span> <span class="o">*</span> <span class="nv">matrix</span>

<span class="mi">1</span> <span class="o">+</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span>
<span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">10</span>

<span class="nv">residues</span> <span class="o">=:</span> <span class="mi">2</span> <span class="o">|</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span>
<span class="nv">residues</span>
</code></pre></div><p>使用 J 的<a href="https://jsoftware.com/">解释器</a>运行上述程序，在标准输出上得到如下结果。</p>
<pre><code>A string

1 4 9 16

 70  80  90
100 110 120

11 21 31
11 12 13

0 1 0 1 0 1 0 1
</code></pre><p>在这一节中，我们将为 J 的一个子集写一个 grammar，然后我们将通过一个解析器，通过迭代 <code>pest</code> 给我们的规则来建立一个 AST。你可以在<a href="https://github.com/pest-parser/book/tree/master/examples/jlang-parser">本书的资源库</a>中找到完整的源代码。</p>
<h3 id="grammar-1">Grammar</h3>
<p>我们将从程序规则开始，逐节建立 grammar。</p>
<pre><code>program = _{ SOI ~ &quot;\n&quot;* ~ (stmt ~ &quot;\n&quot;+) * ~ stmt? ~ EOI }
</code></pre><p>每个 J 程序都包含由一个或多个换行符分隔的语句。请注意前面的下划线，它告诉 <code>pest</code> <a href="https://pest.rs/book/grammars/syntax.html#silent-and-atomic-rules">屏蔽</a> <code>program</code> 规则 - 我们不想让 <code>program</code> 作为一个 token 出现在解析流中，我们想要的是底层语句。</p>
<p>语句就是一个简单的表达式，由于只有一种这样的可能性，所以我们也将这个 <code>stmt</code> 规则<a href="https://pest.rs/book/grammars/syntax.html#silent-and-atomic-rules">屏蔽</a>，这样我们的解析器就会收到一个底层 <code>expr</code> 的迭代器。</p>
<pre><code>stmt = _{ expr }
</code></pre><p>表达式可以是对变量标识符的赋值，也可以是单项表达式、对偶表达式、单个字符串或术语数组。</p>
<pre><code>expr = {
      assgmtExpr
    | monadicExpr
    | dyadicExpr
    | string
    | terms
}
</code></pre><p>一元表达式由一个动词组成，其唯一的操作数在右边；三元表达式的操作数在动词的两边。赋值表达式将标识符与表达式相关联。</p>
<p>在 J 中，没有操作符的优先性 - 求值是右联的（从右到左），括号内的表达式先被求值。</p>
<pre><code>monadicExpr = { verb ~ expr }

dyadicExpr = { (monadicExpr | terms) ~ verb ~ expr }

assgmtExpr = { ident ~ &quot;=:&quot; ~ expr }
</code></pre><p>项的列表应该至少包含一个十进制、整数、标识符或小括号表达式；我们只关心这些基础值，所以我们用前导下划线<a href="https://pest.rs/book/grammars/syntax.html#silent-and-atomic-rules">屏蔽</a> <code>term</code> 规则。</p>
<pre><code>terms = { term+ }

term = _{ decimal | integer | ident | &quot;(&quot; ~ expr ~ &quot;)&quot; }
</code></pre><p>J 的几个动词在这个 grammar 中是有定义的，J 的<a href="https://code.jsoftware.com/wiki/NuVoc">全部词汇</a>要广泛得多。</p>
<pre><code>verb = {
    &quot;&gt;:&quot; | &quot;*:&quot; | &quot;-&quot;  | &quot;%&quot; | &quot;#&quot; | &quot;&gt;.&quot;
  | &quot;+&quot;  | &quot;*&quot;  | &quot;&lt;&quot;  | &quot;=&quot; | &quot;^&quot; | &quot;|&quot;
  | &quot;&gt;&quot;  | &quot;$&quot;
}
</code></pre><p>现在我们可以进入词法规则了。J 中的数字和平常一样，除了负数用前导的 <code>_</code> 下划线表示外（因为 <code>-</code> 是一个动词，它作为单项式执行否定，作为对偶式执行减法）。J 中的标识符必须以字母开头，但之后可以包含数字。字符串由单引号包围；引号本身可以通过用附加引号转义来嵌入。</p>
<p>请注意我们如何使用 <code>pest</code> 的 <code>@</code> 修饰符使这些规则中的每一条都是<a href="https://pest.rs/book/grammars/syntax.html#atomic">原子的</a>，这意味着<a href="https://pest.rs/book/grammars/syntax.html#implicit-whitespace">隐式空白</a>是被禁止的，而且内部规则（即 <code>ident</code> 中的 <code>ASCII_ALPHA</code>）变为 <a href="https://pest.rs/book/grammars/syntax.html#silent-and-atomic-rules">silent</a> - 当我们的解析器接收到这些 token 时，它们将是终端的。</p>
<pre><code>integer = @{ &quot;_&quot;? ~ ASCII_DIGIT+ }

decimal = @{ &quot;_&quot;? ~ ASCII_DIGIT+ ~ &quot;.&quot; ~ ASCII_DIGIT* }

ident = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | &quot;_&quot;)* }

string = @{ &quot;'&quot; ~ ( &quot;''&quot; | (!&quot;'&quot; ~ ANY) )* ~ &quot;'&quot; }
</code></pre><p>J 中的空白只由空格和制表符组成。换行的意义在于它们是对语句的定界，因此它们不在本规则之内。</p>
<pre><code>WHITESPACE = _{ &quot; &quot; | &quot;\t&quot; }
</code></pre><p>最后，我们必须处理注释。J 中的注释以 <code>NB.</code> 开始，一直到它们所在行的末尾。关键的是，我们决不能消耗注释行末的换行；这是为了将注释之前的任何语句与后续行的语句分开。</p>
<pre><code>COMMENT = _{ &quot;NB.&quot; ~ (!&quot;\n&quot; ~ ANY)* }
</code></pre><h3 id="解析和-ast-生成">解析和 AST 生成</h3>
<p>本节将介绍一个使用上述 grammar 的解析器。这里省略了库中的内容和自明的代码，你可以在<a href="https://github.com/pest-parser/book/tree/master/examples/jlang-parser">本书的资源库</a>中找到解析器的全部内容。</p>
<p>首先我们将枚举我们 grammar 中定义的动词，区分一元动词和二元动词。这些枚举将在我们的 AST 中作为标签使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">MonadicVerb</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Increment</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Square</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Negate</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Reciprocal</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Tally</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Ceiling</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ShapeOf</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">DyadicVerb</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Plus</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Times</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">LessThan</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">LargerThan</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Equal</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Minus</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Divide</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Power</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Residue</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="nb">Copy</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">LargerOf</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">LargerOrEqual</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Shape</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>那么我们就来列举一下 AST 的各类节点。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">AstNode</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Print</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">AstNode</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">Integer</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">DoublePrecisionFloat</span><span class="p">(</span><span class="kt">f64</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">MonadicOp</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">verb</span>: <span class="nc">MonadicVerb</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">expr</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">AstNode</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">},</span><span class="w">
</span><span class="w">    </span><span class="n">DyadicOp</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">verb</span>: <span class="nc">DyadicVerb</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">lhs</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">AstNode</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">rhs</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">AstNode</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">},</span><span class="w">
</span><span class="w">    </span><span class="n">Terms</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AstNode</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">IsGlobal</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">ident</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">expr</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">AstNode</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">},</span><span class="w">
</span><span class="w">    </span><span class="n">Ident</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">Str</span><span class="p">(</span><span class="n">CString</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为了解析 J 程序中的顶层语句，我们有下面的 <code>parse</code> 函数，它接受一个字符串形式的 J 程序，并将其传递给 <code>pest</code> 进行解析。我们得到一个 <code>Pair</code> 的序列。正如 grammar 中所规定的那样，一个语句只能由一个表达式组成，所以下面的匹配会解析这些顶层表达式中的每一个，并将它们包装在一个 <code>Print</code> AST 节点中，以符合 J 解释器的 REPL 行为。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">source</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AstNode</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&lt;</span><span class="n">Rule</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">pairs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JParser</span>::<span class="n">parse</span><span class="p">(</span><span class="n">Rule</span>::<span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">pairs</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">as_rule</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Rule</span>::<span class="n">expr</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">ast</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Print</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">build_ast_from_expr</span><span class="p">(</span><span class="n">pair</span><span class="p">))));</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>AST 节点是通过遍历 <code>Pair</code> 迭代器，按照我们 grammar 文件中设定的期望值，从表达式中构建出来的。常见的行为被抽象出单独的函数，如 <code>parse_monadic_verb</code> 和 <code>parse_dyadic_verb</code>，代表表达式本身的 <code>Pair</code> 则在递归调用 <code>build_ast_from_expr</code> 中传递。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">build_ast_from_expr</span><span class="p">(</span><span class="n">pair</span>: <span class="nc">pest</span>::<span class="n">iterators</span>::<span class="n">Pair</span><span class="o">&lt;</span><span class="n">Rule</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">AstNode</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">as_rule</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Rule</span>::<span class="n">expr</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">build_ast_from_expr</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">into_inner</span><span class="p">().</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="n">Rule</span>::<span class="n">monadicExpr</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">into_inner</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">verb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">build_ast_from_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="n">parse_monadic_verb</span><span class="p">(</span><span class="n">verb</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="c1">// ... other cases elided here ...
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>二元动词从它们的字符串表示方式直接映射到 AST 节点。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">parse_dyadic_verb</span><span class="p">(</span><span class="n">pair</span>: <span class="nc">pest</span>::<span class="n">iterators</span>::<span class="n">Pair</span><span class="o">&lt;</span><span class="n">Rule</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">lhs</span>: <span class="nc">AstNode</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">AstNode</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">AstNode</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">AstNode</span>::<span class="n">DyadicOp</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">lhs</span>: <span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">rhs</span>: <span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">verb</span>: <span class="nc">match</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">as_str</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;+&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">DyadicVerb</span>::<span class="n">Plus</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;*&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">DyadicVerb</span>::<span class="n">Times</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;-&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">DyadicVerb</span>::<span class="n">Minus</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;&lt;&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">DyadicVerb</span>::<span class="n">LessThan</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;=&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">DyadicVerb</span>::<span class="n">Equal</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;&gt;&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">DyadicVerb</span>::<span class="n">LargerThan</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;%&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">DyadicVerb</span>::<span class="n">Divide</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;^&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">DyadicVerb</span>::<span class="n">Power</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;|&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">DyadicVerb</span>::<span class="n">Residue</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;#&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">DyadicVerb</span>::<span class="nb">Copy</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;&gt;.&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">DyadicVerb</span>::<span class="n">LargerOf</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;&gt;:&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">DyadicVerb</span>::<span class="n">LargerOrEqual</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;$&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">DyadicVerb</span>::<span class="n">Shape</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Unexpected dyadic verb: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">as_str</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如同一元动词一样。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">parse_monadic_verb</span><span class="p">(</span><span class="n">pair</span>: <span class="nc">pest</span>::<span class="n">iterators</span>::<span class="n">Pair</span><span class="o">&lt;</span><span class="n">Rule</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span>: <span class="nc">AstNode</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">AstNode</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">AstNode</span>::<span class="n">MonadicOp</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">verb</span>: <span class="nc">match</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">as_str</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;&gt;:&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">MonadicVerb</span>::<span class="n">Increment</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;*:&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">MonadicVerb</span>::<span class="n">Square</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;-&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">MonadicVerb</span>::<span class="n">Negate</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;%&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">MonadicVerb</span>::<span class="n">Reciprocal</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;#&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">MonadicVerb</span>::<span class="n">Tally</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;&gt;.&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">MonadicVerb</span>::<span class="n">Ceiling</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;$&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">MonadicVerb</span>::<span class="n">ShapeOf</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Unsupported monadic verb: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">as_str</span><span class="p">()),</span><span class="w">
</span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">        </span><span class="n">expr</span>: <span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>最后，我们定义了一个函数来处理数字和字符串等项。数字需要一些操作来处理 J 的前导下划线，表示否定，但除此之外，处理过程是典型的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">build_ast_from_term</span><span class="p">(</span><span class="n">pair</span>: <span class="nc">pest</span>::<span class="n">iterators</span>::<span class="n">Pair</span><span class="o">&lt;</span><span class="n">Rule</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">AstNode</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">as_rule</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Rule</span>::<span class="n">integer</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">istr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">as_str</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">sign</span><span class="p">,</span><span class="w"> </span><span class="n">istr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="n">istr</span><span class="p">[..</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="s">&#34;_&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">istr</span><span class="p">[</span><span class="mi">1</span><span class="p">..]),</span><span class="w">
</span><span class="w">                </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">istr</span><span class="p">[..]),</span><span class="w">
</span><span class="w">            </span><span class="p">};</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">integer</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">istr</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="n">AstNode</span>::<span class="n">Integer</span><span class="p">(</span><span class="n">sign</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">integer</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">Rule</span>::<span class="n">decimal</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">dstr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">as_str</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">sign</span><span class="p">,</span><span class="w"> </span><span class="n">dstr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dstr</span><span class="p">[..</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="s">&#34;_&#34;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dstr</span><span class="p">[</span><span class="mi">1</span><span class="p">..]),</span><span class="w">
</span><span class="w">                </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dstr</span><span class="p">[..]),</span><span class="w">
</span><span class="w">            </span><span class="p">};</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">flt</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="n">dstr</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">flt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// Avoid negative zeroes; only multiply sign by nonzeroes.
</span><span class="c1"></span><span class="w">                </span><span class="n">flt</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">sign</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="n">AstNode</span>::<span class="n">DoublePrecisionFloat</span><span class="p">(</span><span class="n">flt</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">Rule</span>::<span class="n">expr</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">build_ast_from_expr</span><span class="p">(</span><span class="n">pair</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Rule</span>::<span class="n">ident</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">AstNode</span>::<span class="n">Ident</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">as_str</span><span class="p">())),</span><span class="w">
</span><span class="w">        </span><span class="n">unknown_term</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Unexpected term: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">unknown_term</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="运行解析器">运行解析器</h3>
<p>现在我们可以定义一个 <code>main</code> 函数，将 J 程序传递给我们的 <code>pest</code>-enabled 解析器。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">unparsed_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">read_to_string</span><span class="p">(</span><span class="s">&#34;example.ijs&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">      </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;cannot read ijs file&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">astnode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unparsed_file</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;unsuccessful parse&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">astnode</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在 example.ijs 中使用这段代码。</p>
<pre><code>_2.5 ^ 3
*: 4.8
title =: 'Spinning at the Boundary'
*: _1 2 _3 4
1 2 3 + 10 20 30
1 + 10 20 30
1 2 3 + 10
2 | 0 1 2 3 4 5 6 7
another =: 'It''s Escaped'
3 | 0 1 2 3 4 5 6 7
(2+1)*(2+2)
3 * 2 + 1
1 + 3 % 4
x =: 100
x - 1
y =: x - 1
y
</code></pre><p>当我们运行解析器时，我们会在标准输出上得到以下抽象语法树。</p>
<pre><code>$ cargo run
  [ ... ]
[Print(DyadicOp { verb: Power, lhs: DoublePrecisionFloat(-2.5),
    rhs: Integer(3) }),
Print(MonadicOp { verb: Square, expr: DoublePrecisionFloat(4.8) }),
Print(IsGlobal { ident: &quot;title&quot;, expr: Str(&quot;Spinning at the Boundary&quot;) }),
Print(MonadicOp { verb: Square, expr: Terms([Integer(-1), Integer(2),
    Integer(-3), Integer(4)]) }),
Print(DyadicOp { verb: Plus, lhs: Terms([Integer(1), Integer(2), Integer(3)]),
    rhs: Terms([Integer(10), Integer(20), Integer(30)]) }),
Print(DyadicOp { verb: Plus, lhs: Integer(1), rhs: Terms([Integer(10),
    Integer(20), Integer(30)]) }),
Print(DyadicOp { verb: Plus, lhs: Terms([Integer(1), Integer(2), Integer(3)]),
    rhs: Integer(10) }),
Print(DyadicOp { verb: Residue, lhs: Integer(2),
    rhs: Terms([Integer(0), Integer(1), Integer(2), Integer(3), Integer(4),
    Integer(5), Integer(6), Integer(7)]) }),
Print(IsGlobal { ident: &quot;another&quot;, expr: Str(&quot;It\'s Escaped&quot;) }),
Print(DyadicOp { verb: Residue, lhs: Integer(3), rhs: Terms([Integer(0),
    Integer(1), Integer(2), Integer(3), Integer(4), Integer(5),
    Integer(6), Integer(7)]) }),
Print(DyadicOp { verb: Times, lhs: DyadicOp { verb: Plus, lhs: Integer(2),
    rhs: Integer(1) }, rhs: DyadicOp { verb: Plus, lhs: Integer(2),
        rhs: Integer(2) } }),
Print(DyadicOp { verb: Times, lhs: Integer(3), rhs: DyadicOp { verb: Plus,
    lhs: Integer(2), rhs: Integer(1) } }),
Print(DyadicOp { verb: Plus, lhs: Integer(1), rhs: DyadicOp { verb: Divide,
    lhs: Integer(3), rhs: Integer(4) } }),
Print(IsGlobal { ident: &quot;x&quot;, expr: Integer(100) }),
Print(DyadicOp { verb: Minus, lhs: Ident(&quot;x&quot;), rhs: Integer(1) }),
Print(IsGlobal { ident: &quot;y&quot;, expr: DyadicOp { verb: Minus, lhs: Ident(&quot;x&quot;),
    rhs: Integer(1) } }),
Print(Ident(&quot;y&quot;))]
</code></pre>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rust" term="rust" label="Rust" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust-grammar" term="rust-grammar" label="Rust Grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Parser API - 解析 INI]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-01-19-parser-api-example-ini/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2021-01-19-parser-api-example-ini/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-01-19T00:00:00+08:00</published>
            <updated>2021-01-19T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Parser API - Example: INI</blockquote><h2 id="例子-ini">例子: INI</h2>
<p>INI(initialization 的简称)文件是简单的配置文件。由于没有标准的格式，我们将编写一个能够解析这个例子文件的程序。</p>
<div class="highlight"><pre class="chroma"><code class="language-ini" data-lang="ini"><span class="na">username</span> <span class="o">=</span> <span class="s">noha</span>
<span class="na">password</span> <span class="o">=</span> <span class="s">plain_text</span>
<span class="na">salt</span> <span class="o">=</span> <span class="s">NaCl</span>

<span class="k">[server_1]</span>
<span class="na">interface</span><span class="o">=</span><span class="s">eth0</span>
<span class="na">ip</span><span class="o">=</span><span class="s">127.0.0.1</span>
<span class="na">document_root</span><span class="o">=</span><span class="s">/var/www/example.org</span>

<span class="k">[empty_section]</span>

<span class="k">[second_server]</span>
<span class="na">document_root</span><span class="o">=</span><span class="s">/var/www/example.com</span>
<span class="na">ip</span><span class="o">=</span>
<span class="na">interface</span><span class="o">=</span><span class="s">eth1</span>
</code></pre></div><p>每一行都包含一个键和值，中间用等号隔开；或者包含一个用方括号括起来的章节名；或者是空白，没有任何意义。</p>
<p>每当出现一个节名，下面的键和值就属于该节，直到下一个节名。文件开头的键值对属于一个隐式的 &ldquo;空&quot;节。</p>
<h2 id="编写-grammar">编写 grammar</h2>
<p>首先使用 Cargo <a href="https://pest.rs/book/examples/csv.html#setup">初始化一个新项目</a>，添加依赖关系 <code>pest = &quot;2.0&quot;</code> 和  <code>pest_derive = &quot;2.0&quot;</code>。创建一个新文件 <code>src/ini.pest</code> 来保存 grammar。</p>
<p>我们文件中感兴趣的文本 - <code>username</code>、<code>/var/www/example.org</code> 等 - 只由几个字符组成。让我们制定一个规则来识别该集合中的单个字符。内置的规则 <code>ASCII_ALPHANUMERIC</code> 是表示任何大写或小写 ASCII 字母或任何数字的快捷方式。</p>
<pre><code>char = { ASCII_ALPHANUMERIC | &quot;.&quot; | &quot;_&quot; | &quot;/&quot; }
</code></pre><p>节名和属性键不能为空，但属性值可以为空（如上文中的 <code>ip=</code> 行）。也就是说，前者由一个或多个字符组成，<code>char+</code>; 后者由零或多个字符组成，<code>char*</code>。我们将其含义分为两条规则。</p>
<pre><code>name = { char+ }
value = { char* }
</code></pre><p>现在很容易表达这两种输入行。</p>
<pre><code>section = { &quot;[&quot; ~ name ~ &quot;]&quot; }
property = { name ~ &quot;=&quot; ~ value }
</code></pre><p>最后，我们需要一个规则来表示整个输入文件。表达式 <code>(section | property)?</code> 匹配 <code>section</code>、<code>property</code>，否则什么也不匹配。使用内置规则 <code>NEWLINE</code> 来匹配行尾。</p>
<pre><code>file = {
    SOI ~
    ((section | property)? ~ NEWLINE)* ~
    EOI
}
</code></pre><p>要将解析器编译成 Rust，我们需要在 <code>src/main.rs</code> 中添加以下内容。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">pest</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="cp">#[macro_use]</span><span class="w">
</span><span class="w"></span><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">pest_derive</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">pest</span>::<span class="n">Parser</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Parser)]</span><span class="w">
</span><span class="w"></span><span class="cp">#[grammar = </span><span class="s">&#34;ini.pest&#34;</span><span class="cp">]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">INIParser</span><span class="p">;</span><span class="w">
</span></code></pre></div><h2 id="程序初始化">程序初始化</h2>
<p>现在我们可以读取文件，并用 <code>pest</code> 进行解析。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashMap</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">unparsed_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">read_to_string</span><span class="p">(</span><span class="s">&#34;config.ini&#34;</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;cannot read file&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INIParser</span>::<span class="n">parse</span><span class="p">(</span><span class="n">Rule</span>::<span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">unparsed_file</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;unsuccessful parse&#34;</span><span class="p">)</span><span class="w"> </span><span class="c1">// unwrap the parse result
</span><span class="c1"></span><span class="w">        </span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="c1">// get and unwrap the `file` rule; never fails
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们将使用嵌套的 <code>HashMap</code> 来表达属性列表。外层哈希 map 将以章节名称作为键，以章节内容（内部哈希 map）作为值。每个内部哈希 map 将有属性键和属性值。例如，要访问 <code>server_1</code> 的 <code>document_root</code>，我们可以写 <code>properties[&quot;server_1&quot;][&quot;document_root&quot;]</code>。隐含的 &ldquo;空&quot;节将由常规部分表示，名称为空字符串 <code>&quot;&quot;</code>，这样 <code>properties[&quot;&quot;][&quot;salt&quot;]</code> 就是有效的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">properties</span>: <span class="nc">HashMap</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>请注意，哈希 map 的键和值都是 <code>&amp;str</code>，即借用的字符串。<code>pest</code> 解析器不会复制他们解析的输入，而是借用。所有用于检查解析结果的方法都会返回从原始解析字符串中借用字符串。</p>
<h2 id="主循环">主循环</h2>
<p>现在我们解释解析结果。我们循环浏览文件的每一行，这一行要么是节名，要么是键值属性对。如果遇到一个节名，我们更新一个变量。如果遇到一个属性对，我们就获取一个对当前章节的哈希 map 的引用，然后把这个属性对插入到这个哈希 map 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">current_section_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">file</span><span class="p">.</span><span class="n">into_inner</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">as_rule</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Rule</span>::<span class="n">section</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">inner_rules</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">into_inner</span><span class="p">();</span><span class="w"> </span><span class="c1">// { name }
</span><span class="c1"></span><span class="w">                </span><span class="n">current_section_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inner_rules</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_str</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="n">Rule</span>::<span class="n">property</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">inner_rules</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">into_inner</span><span class="p">();</span><span class="w"> </span><span class="c1">// { name ~ &#34;=&#34; ~ value }
</span><span class="c1"></span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="n">inner_rules</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_str</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="n">inner_rules</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_str</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">                </span><span class="c1">// Insert an empty inner hash map if the outer hash map hasn&#39;t
</span><span class="c1"></span><span class="w">                </span><span class="c1">// seen this section name before.
</span><span class="c1"></span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">section</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">properties</span><span class="p">.</span><span class="n">entry</span><span class="p">(</span><span class="n">current_section_name</span><span class="p">).</span><span class="n">or_default</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="n">section</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="n">Rule</span>::<span class="n">EOI</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">unreachable</span><span class="o">!</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span></code></pre></div><p>在输出方面，我们用<a href="https://doc.rust-lang.org/std/fmt/index.html#sign0">漂亮的打印</a> <code>Debug</code> 格式简单地转储哈希 map。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// ...
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:#?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">properties</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="空白">空白</h2>
<p>如果你把本章顶部的例子 INI 文件复制到 <code>config.ini</code> 文件中并运行程序，它将无法解析。我们已经忘记了等号周围的可选空格!</p>
<p>对于大型 grammar 来说，处理空白会很不方便。显示地编写 <code>whitespace</code> 规则并手动插入空白会让 grammar 变得难以阅读和修改。<code>pest</code> 提供了一个<a href="https://pest.rs/book/grammars/syntax.html#implicit-whitespace">特殊规则 <code>WHITESPACE</code></a> 的解决方案。如果定义了 <code>WHITESPACE</code>，它将被隐式地运行，尽可能多次地在每个波浪号 <code>~</code> 和每个重复之间运行（例如，<code>*</code> 和 <code>+</code>）。对于我们的 INI 解析器，只有空格才是合法的 whitespace。</p>
<pre><code>WHITESPACE = _{ &quot; &quot; }
</code></pre><p>我们用一个前导的下划线 <code>_{ ... }</code> 来标记 <code>WHITESPACE</code> 规则的<a href="https://pest.rs/book/grammars/syntax.html#silent-and-atomic-rules">静默</a>。}. 这样，即使它匹配，也不会出现在其他规则中。如果它不是静默的，解析就会复杂得多，因为对  <code>Pairs::next(...)</code> 的每次调用都有可能返回 <code>Rule::WHITESPACE</code> 而不是想要的下一条规则。</p>
<p>但是等等! 节名、键或值中不应该有空格！目前，空格是自动插入的。目前，在 <code>name = { char+ }</code> 中，空格会自动插入字符之间。对空格敏感的规则需要用前导符号 <code>@{ ... }</code> 来标记<a href="https://pest.rs/book/grammars/syntax.html#atomic">原子</a>。}. 在原子规则中，自动的空白处理是被禁用的，而内部规则是静默的。</p>
<pre><code>name = @{ char+ }
value = @{ char* }
</code></pre><h2 id="完工">完工</h2>
<p>试试吧！确保文件 <code>config.ini</code> 存在，然后运行程序! 你应该看到这样的东西。</p>
<pre><code>$ cargo run
  [ ... ]
{
    &quot;&quot;: {
        &quot;password&quot;: &quot;plain_text&quot;,
        &quot;username&quot;: &quot;noha&quot;,
        &quot;salt&quot;: &quot;NaCl&quot;
    },
    &quot;second_server&quot;: {
        &quot;ip&quot;: &quot;&quot;,
        &quot;document_root&quot;: &quot;/var/www/example.com&quot;,
        &quot;interface&quot;: &quot;eth1&quot;
    },
    &quot;server_1&quot;: {
        &quot;interface&quot;: &quot;eth0&quot;,
        &quot;document_root&quot;: &quot;/var/www/example.org&quot;,
        &quot;ip&quot;: &quot;127.0.0.1&quot;
    }
}
</code></pre>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rust" term="rust" label="Rust" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="Grammar" />
                            
                        
                    
                
            
        </entry>
    
</feed>
